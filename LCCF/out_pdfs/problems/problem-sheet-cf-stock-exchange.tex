% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Stock Exchange}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1178/H}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{Warning: This problem has an unusual memory limit!

Bob decided that he will not waste his prime years implementing GUI forms for a large corporation and instead will earn his supper on the Stock Exchange Reykjavik. The Stock Exchange Reykjavik is the only actual stock exchange in the world. The only type of transaction is to take a single share of stock $x$ and exchange it for a single share of stock $y$, provided that the current price of share $x$ is at least the current price of share $y$.

There are $2n$ stocks listed on the SER that are of interest to Bob, numbered from $1$ to $2n$. Bob owns a single share of stocks $1$ through $n$ and would like to own a single share of each of $n+1$ through $2n$ some time in the future.

Bob managed to forecast the price of each stock — in time $t \ge 0$, the stock $i$ will cost $a_i \cdot \lfloor t \rfloor + b_i$. The time is currently $t = 0$. Help Bob find the earliest moment in time in which he can own a single share of each of $n+1$ through $2n$, and the minimum number of stock exchanges he has to perform in order to do that.

You may assume that the Stock Exchange has an unlimited amount of each stock at any point in time.

Input:
The first line contains a single integer $n$ ($1 \le n \le 2200$) — the number stocks currently owned by Bob.

Each of the next $2n$ lines contains integers $a_i$ and $b_i$ ($0 \le a_i, b_i \le 10^9$), representing the stock price of stock $i$.

Output:
If it is impossible for Bob to achieve his goal, output a single integer $-1$.

Otherwise, output two integers $T$ and $E$, where $T$ is the minimum time in which he can achieve his goal, and $E$ is the minimum number of exchanges in which he can achieve his goal at time $T$.

Note:
In the first example, Bob simply waits until time $t = 3$, when both stocks cost exactly the same amount.

In the second example, the optimum strategy is to exchange stock $2$ for stock $1$ at time $t = 1$, then exchange one share of stock $1$ for stock $3$ at time $t = 5$ (where both cost $15$) and then at time $t = 6$ exchange the second on for the stock number $4$ (when they cost $18$ and $17$, respectively). Note that he can achieve his goal also with only two exchanges, but this would take total time of $t = 9$, when he would finally be able to exchange the share number $2$ for the share number $3$.

In the third example, Bob can never achieve his goal, as the second stock is always strictly more expensive than the first one.}
\BREAKDOWN{We model each stock $i$ with price $P_i(k)=a_i \cdot k + b_i$ at integer time step $k=\lfloor t \rfloor$. An exchange at time $k$ can move a share from $x$ to $y$ iff $P_x(k)\ge P_y(k)$. Over time, a share can follow a path of stock indices as long as each step happens no later than $T$. We need the minimum $T$ so that we can route $n$ initial shares (stocks $1..n$) to $n$ target stocks ($n+1..2n$), and among such $T$, the minimum total number of exchanges.}
\ELI{Think of each stock as a line; you can move a share from a higher line to a lower one when they meet. Find the earliest time when each of your $n$ shares can travel along such steps to end up on the $n$ destination stocks; then minimize the total steps taken.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test.\\
- Integer $n$ ($1 \le n \le 2200$).\\
- Then $2n$ lines with integers $a_i$, $b_i$ ($0 \le a_i, b_i \le 10^9$). Indexing: sources $i \in [1,n]$, targets $j \in [n+1,2n]$.}
\OUTPUTS{- If impossible, print $-1$.\\
- Else print two integers $T$ and $E$: minimal time step $T$ (an integer) and the minimal number of exchanges to achieve the goal by time $T$.}
\SAMPLES{Example A (easy feasibility):
\begin{BreakableEquation*}
n=1;\ (a_1,b_1)=(1,0),\ (a_2,b_2)=(0,2).
\end{BreakableEquation*}
Prices: $P_1(k)=k$, $P_2(k)=2$. Earliest $k$ with $P_1(k)\ge P_2(k)$ is $k=2$. Answer: $T=2$, $E=1$.\\
Example B (impossible):
\begin{BreakableEquation*}
n=1;\ (a_1,b_1)=(0,0),\ (a_2,b_2)=(1,1).
\end{BreakableEquation*}
$P_1(k)=0$, $P_2(k)=k+1$. Never $P_1 \ge P_2$. Answer: $-1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{1,\ldots,2n\}$. For integer time $k \ge 0$, define prices $P_i(k)=a_i \cdot k + b_i$. Define a directed edge $u \to v$ usable at time $k$ if $P_u(k)\ge P_v(k)$. Let $t_{uv}$ be the earliest integer time at which an exchange $u \to v$ is possible:
\[
t_{uv}=\begin{cases}
0,& b_u \ge b_v,\\
\left\lceil\dfrac{b_v-b_u}{a_u-a_v}\right\rceil,& a_u>a_v\text{ and }b_u<b_v,\\
+\infty,& \text{otherwise.}
\end{cases}
\]
For a deadline $T$, the usable-edge subgraph is $G_T=(V,E_T)$ where $E_T=\{(u,v): t_{uv}\le T\}$. A share can follow any directed path in $G_T$ (exchanging at nondecreasing times) from its current stock to some target. We seek the minimum $T$ such that there exist $n$ vertex-disjoint (at sources and targets) paths from sources $\{1,\ldots,n\}$ to targets $\{n+1,\ldots,2n\}$; since the market is unlimited, paths may reuse intermediate vertices. Among such $T$, minimize the total number of edges used across the $n$ paths.}
\varmapStart
\var{n}{number of initial shares and targets}
\var{a_i,b_i}{slope and intercept for stock $i$}
\var{P_i(k)}{price of stock $i$ at time step $k$}
\var{t_{uv}}{earliest time an exchange $u \to v$ is possible}
\var{G_T}{digraph of exchanges allowed by time $T$}
\var{d_T(i,j)}{shortest path length in $G_T$ from source $i$ to target $j$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Feasible}(T)\iff \text{there exists a perfect matching on bipartite graph }(L,R,E_T^+)
\end{BreakableEquation*}
\begin{BreakableEquation*}
L=\{1,\ldots,n\},\quad R=\{n+1,\ldots,2n\},\quad (i,j)\in E_T^+ \iff d_T(i,j)<\infty.
\end{BreakableEquation*}
\begin{BreakableEquation*}
E(T)=\min_{\text{perfect matchings }M\subseteq E_T^+}\ \sum_{(i,j)\in M} d_T(i,j).
\end{BreakableEquation*}
}
\ASSUMPTIONS{- Time is effectively discrete since prices depend on $\lfloor t \rfloor$.\\
- Exchanges can be instantaneous and arbitrarily many at a fixed time.\\
- Intermediate stocks may be reused by multiple shares (unlimited market).}
\INVARIANTS{- Along any single exchange, price never increases: if $u \to v$ at time $k$, then $P_u(k)\ge P_v(k)$.\\
- If an edge $(u,v)$ is usable by time $T$, it is usable at all later times $T' \ge T$.\\
- The subgraph $G_T$ is monotone with $T$: $G_T \subseteq G_{T'}$ for $T' \ge T$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Construct $G_T$ explicitly for a candidate $T$ and perform reachability via BFS from each source to detect which targets are reachable, then greedy-match if possible. Sweep $T$ from small to large.}
\ASSUMPTIONS{Small $n$; correctness prioritized over speed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $t_{uv}$ for all ordered pairs.
\item For $T=0,1,2,\ldots$ up to a crude cap:
  \begin{itemize}
  \item Build adjacency list of $G_T$ with edges $(u,v)$ if $t_{uv}\le T$.
  \item For each source $i$, BFS to mark reachable targets.
  \item Try to find a perfect matching greedily (or with DFS augmenting paths).
  \end{itemize}
\item First $T$ with perfect matching is the answer time. Count exchanges as sum of path lengths chosen by greedy paths.
\end{algosteps}
\COMPLEXITY{Brute time is prohibitive in general.
\[
\begin{aligned}
\text{Build }t_{uv}:&\ O((2n)^2).\\
\text{Per }T\text{ check:} &\ O((2n)^2) \text{ to build }G_T\ +\ O\big(n\cdot((2n)+(2n)^2)\big) \text{ for $n$ BFS}.\\
\end{aligned}
\]
Space $O((2n)^2)$.}
\CORRECTNESS{By construction, $G_T$ contains exactly the exchanges usable no later than $T$. Reachability captures existence of some sequence of exchanges by time $T$. A perfect matching pairs distinct sources to distinct targets.}
\EDGECASES{- No edges at all: immediate impossibility.\\
- Equal-price ties: edges both ways exist at the same time; $t_{uv}=0$ when $b_u\ge b_v$.\\
- Large slopes require waiting; ensure ceiling division is correct.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline brute-force (small inputs): step T upward, BFS reachability, greedy matching.
from collections import deque

INF_TIME = 10**18

def ceil_div_pos(x, y):
    # x > 0, y > 0
    return (x + y - 1) // y

def build_earliest_times(a, b):
    m = len(a)
    t = [[INF_TIME]*m for _ in range(m)]
    for u in range(m):
        for v in range(m):
            if u == v:
                t[u][v] = 0
                continue
            bu, bv = b[u], b[v]
            au, av = a[u], a[v]
            if bu >= bv:
                t[u][v] = 0
            elif au > av:
                t[u][v] = ceil_div_pos(bv - bu, au - av)
            else:
                t[u][v] = INF_TIME
    return t

def bfs_reach(adj, start):
    n = len(adj)
    vis = [False]*n
    dq = deque([start])
    vis[start] = True
    while dq:
        u = dq.popleft()
        for v in adj[u]:
            if not vis[v]:
                vis[v] = True
                dq.append(v)
    return vis

def greedy_match(reach):
    # reach[i] = list of targets j reachable from source i
    n = len(reach)
    matchR = [-1]*n
    def dfs(i, seen):
        for j in reach[i]:
            if seen[j]:
                continue
            seen[j] = True
            if matchR[j] == -1 or dfs(matchR[j], seen):
                matchR[j] = i
                return True
        return False
    msize = 0
    for i in range(n):
        if dfs(i, [False]*n):
            msize += 1
    return msize == n

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a, b = [], []
    for _ in range(2*n):
        ai = int(next(it)); bi = int(next(it))
        a.append(ai); b.append(bi)
    return n, a, b

def solve_case(n, a, b):
    m = 2*n
    t = build_earliest_times(a, b)
    # crude cap for baseline
    CAP = 2000
    for T in range(CAP+1):
        adj = [[] for _ in range(m)]
        for u in range(m):
            for v in range(m):
                if t[u][v] <= T:
                    adj[u].append(v)
        reach = [[] for _ in range(n)]
        for i in range(n):
            vis = bfs_reach(adj, i)
            for j in range(n, 2*n):
                if vis[j]:
                    reach[i].append(j - n)
        if greedy_match(reach):
            # Count exchanges as 1 per source -> target (lower bound)
            # Baseline returns E = n as a simple estimate.
            return T, n
    return -1,

def main():
    inp = read_input()
    if inp is None:
        # tiny self-checks
        n = 1
        a = [1, 0]
        b = [0, 2]
        assert solve_case(n, a, b) == (2, 1)
        n = 1
        a = [0, 1]
        b = [0, 1]
        assert solve_case(n, a, b) == (-1,)
        print("OK")
        return
    n, a, b = inp
    ans = solve_case(n, a, b)
    if len(ans) == 1:
        print(-1)
    else:
        print(ans[0], ans[1])

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{- Single-share easy feasibility and impossibility assertions in main when no input.\\
- The baseline returns $E=n$ as a simple bound once $T$ is found.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search on Time + Matching}
\WHICHFORMULA{Monotonicity: feasibility $\text{Feasible}(T)$ is monotone nondecreasing in $T$. Use binary search on $T$. For a fixed $T$, build $G_T$ and test existence of a perfect matching from sources to targets using transitive reachability and Hopcroft–Karp.}
\ASSUMPTIONS{Compute $t_{uv}$ once. For each $T$, we build $G_T$ and perform $n$ BFS reachabilities and maximum matching.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $t_{uv}$ for all ordered pairs.
\item Exponentially increase $T$ until feasible or a preset bound; if never feasible in the limit graph (all finite edges), output $-1$.
\item Binary search the minimal feasible $T$:
  \begin{itemize}
  \item Build adjacency of $G_T$ (edges with $t_{uv}\le T$).
  \item For each source $i$, BFS to mark reachable targets.
  \item Run Hopcroft–Karp on the bipartite graph (sources to reachable targets).
  \end{itemize}
\item Report minimal $T$.}
\COMPLEXITY{Let $V=2n$, $E$ be edges with $t_{uv}\le T$. Per check: build $G_T$ in $O(V^2)$ worst case, $n$ BFS in $O(n(V+E))$, and Hopcroft–Karp in $O(E\sqrt{n})$. Overall $O(\log U \cdot (V^2 + n(V+E) + E\sqrt{n}))$ where $U$ is the time search range.}
\CORRECTNESS{Monotonicity holds since $G_T \subseteq G_{T'}$ for $T'\ge T$. Reachability encodes possible exchange sequences by time $T$. HK ensures distinct targets are assigned.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Binary search on T with Hopcroft-Karp maximum matching using reachability per source.
from collections import deque

INF_TIME = 10**18

def ceil_div_pos(x, y):
    return (x + y - 1) // y

def build_earliest_times(a, b):
    m = len(a)
    t = [[INF_TIME]*m for _ in range(m)]
    for u in range(m):
        for v in range(m):
            if u == v:
                t[u][v] = 0
                continue
            bu, bv = b[u], b[v]
            au, av = a[u], a[v]
            if bu >= bv:
                t[u][v] = 0
            elif au > av:
                t[u][v] = ceil_div_pos(bv - bu, au - av)
            else:
                t[u][v] = INF_TIME
    return t

def build_graph_leq_T(t, T):
    m = len(t)
    adj = [[] for _ in range(m)]
    for u in range(m):
        row = t[u]
        au = adj[u]
        for v in range(m):
            if row[v] <= T:
                au.append(v)
    return adj

def bfs_reach(adj, start):
    n = len(adj)
    vis = [False]*n
    dq = deque([start])
    vis[start] = True
    while dq:
        u = dq.popleft()
        for v in adj[u]:
            if not vis[v]:
                vis[v] = True
                dq.append(v)
    return vis

def hopcroft_karp(graph, n_left, n_right):
    # graph: adjacency list for left side 0..n_left-1, edges to right 0..n_right-1
    INF = 10**9
    dist = [0]*n_left
    matchL = [-1]*n_left
    matchR = [-1]*n_right

    def bfs():
        dq = deque()
        for u in range(n_left):
            if matchL[u] == -1:
                dist[u] = 0
                dq.append(u)
            else:
                dist[u] = INF
        found = False
        while dq:
            u = dq.popleft()
            for v in graph[u]:
                w = matchR[v]
                if w != -1 and dist[w] == INF:
                    dist[w] = dist[u] + 1
                    dq.append(w)
                if w == -1:
                    found = True
        return found

    def dfs(u):
        for v in graph[u]:
            w = matchR[v]
            if w == -1 or (dist[w] == dist[u] + 1 and dfs(w)):
                matchL[u] = v
                matchR[v] = u
                return True
        dist[u] = 10**9
        return False

    matching = 0
    while bfs():
        for u in range(n_left):
            if matchL[u] == -1 and dfs(u):
                matching += 1
    return matching, matchL, matchR

def feasible_T(n, adj, T):
    m = 2*n
    reachR = [[] for _ in range(n)]
    for i in range(n):
        vis = bfs_reach(adj, i)
        for j in range(n, 2*n):
            if vis[j]:
                reachR[i].append(j - n)
    size, _, _ = hopcroft_karp(reachR, n, n)
    return size == n

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a, b = [], []
    for _ in range(2*n):
        ai = int(next(it)); bi = int(next(it))
        a.append(ai); b.append(bi)
    return n, a, b

def solve_case(n, a, b):
    t = build_earliest_times(a, b)
    m = 2*n
    # Quick impossibility check: even with all finite edges (T=INF), if no perfect matching, return -1
    adj_inf = build_graph_leq_T(t, INF_TIME)
    if not feasible_T(n, adj_inf, INF_TIME):
        return -1,
    # exponential search for high bound
    lo, hi = 0, 1
    while True:
        adj = build_graph_leq_T(t, hi)
        if feasible_T(n, adj, hi):
            break
        hi *= 2
        if hi > 2*10**12:
            # Should not happen if feasible at INF; cap for safety
            break
    # binary search
    resT = hi
    while lo <= hi:
        mid = (lo + hi)//2
        adj_mid = build_graph_leq_T(t, mid)
        if feasible_T(n, adj_mid, mid):
            resT = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return resT,

def main():
    inp = read_input()
    if inp is None:
        # tiny tests
        n = 1; a = [1,0]; b = [0,2]
        assert solve_case(n,a,b) == (2,)
        n = 1; a = [0,1]; b = [0,1]
        assert solve_case(n,a,b) == (-1,)
        print("OK")
        return
    n, a, b = inp
    ans = solve_case(n, a, b)
    if len(ans) == 1:
        if ans[0] == -1:
            print(-1)
        else:
            print(ans[0], n)  # E unknown in this approach; print n as a placeholder
    else:
        print(-1)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{- Same tiny checks as baseline when no input.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Binary Search on Time + Reachability Costs + Assignment}
\WHICHFORMULA{For fixed $T$, model edges usable by time $T$ via $G_T$. Compute shortest path distances $d_T(i,j)$ from each source $i$ to each target $j$ in $G_T$. Feasibility holds iff all $d_T(i,j)$ are finite for a perfect matching; the minimal number of exchanges at time $T$ is the minimum sum of $d_T(i,j)$ over a perfect matching — a classic assignment problem solvable by the Hungarian algorithm. Then binary search the minimal feasible $T$.}
\ASSUMPTIONS{Shortest path in unweighted digraph via BFS. Assignment with Hungarian algorithm on an $n \times n$ cost matrix.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $t_{uv}$ for all ordered pairs using the exact earliest-time formula.
\item Define $\text{build}(T)$ that builds adjacency of $G_T$ by including edges with $t_{uv}\le T$.
\item For a given $T$:
  \begin{itemize}
  \item For each source $i \in [1,n]$, BFS on $G_T$ to compute $d_T(i,\cdot)$, keep costs only for targets $j\in[n+1,2n]$.
  \item Build an $n \times n$ cost matrix $C$ with $C_{i,j-n}=d_T(i,j)$ or a large sentinel for unreachable.
  \item Run the Hungarian algorithm on $C$. If some row cannot be assigned finitely, $T$ is infeasible. Otherwise $E(T)$ is the optimal total cost.
  \end{itemize}
\item Exponentially search an upper bound on $T$ (if impossible even with all finite edges, return $-1$), then binary search the minimal feasible $T$, retaining the corresponding minimal $E$.}
\OPTIMALITY{Given $T$, each share can independently choose any shortest path to its assigned target. Since intermediate vertices have unlimited capacity, costs are separable across shares and the optimal total is exactly the minimum-cost perfect matching over the reachability distances. Minimizing $T$ first (binary search) respects the lexicographic objective: find the smallest $T$ enabling any perfect matching; among those, we compute the minimal $E$ at that $T$.}
\COMPLEXITY{Let $V=2n$, $E_T$ be edges in $G_T$.
\begin{BreakableEquation*}
\text{Per }T:\ \ n\ \text{BFS} = O\big(n(V+E_T)\big),\quad \text{Hungarian} = O(n^3).
\end{BreakableEquation*}
Binary search multiplies by $O(\log U)$, where $U$ is the time range. This is heavy for worst-case $n$, but fine for instructional and small tests.}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final: Binary search minimal T; then compute minimal E via Hungarian over BFS distances.
from collections import deque

INF_TIME = 10**18
INF_COST = 10**9

def ceil_div_pos(x, y):
    return (x + y - 1) // y  # x>0, y>0

def build_earliest_times(a, b):
    m = len(a)
    t = [[INF_TIME]*m for _ in range(m)]
    for u in range(m):
        for v in range(m):
            if u == v:
                t[u][v] = 0
                continue
            bu, bv = b[u], b[v]
            au, av = a[u], a[v]
            if bu >= bv:
                t[u][v] = 0
            elif au > av:
                t[u][v] = ceil_div_pos(bv - bu, au - av)
            else:
                t[u][v] = INF_TIME
    return t

def build_graph_leq_T(t, T):
    m = len(t)
    adj = [[] for _ in range(m)]
    for u in range(m):
        row = t[u]
        uu = adj[u]
        for v in range(m):
            if row[v] <= T:
                uu.append(v)
    return adj

def bfs_distances(adj, start, targets):
    n = len(adj)
    dist = [-1]*n
    dq = deque([start])
    dist[start] = 0
    while dq:
        u = dq.popleft()
        du = dist[u] + 1
        for v in adj[u]:
            if dist[v] == -1:
                dist[v] = du
                dq.append(v)
    # return distances to targets only
    return [dist[j] if dist[j] != -1 else INF_COST for j in targets]

def hungarian(cost):
    # cost: n x n non-negative
    n = len(cost)
    u = [0]*(n+1)
    v = [0]*(n+1)
    p = [0]*(n+1)
    way = [0]*(n+1)
    for i in range(1, n+1):
        p[0] = i
        j0 = 0
        minv = [INF_COST+1]*(n+1)
        used = [False]*(n+1)
        while True:
            used[j0] = True
            i0 = p[j0]
            delta = INF_COST+1
            j1 = 0
            for j in range(1, n+1):
                if not used[j]:
                    cur = cost[i0-1][j-1] - u[i0] - v[j]
                    if cur < minv[j]:
                        minv[j] = cur
                        way[j] = j0
                    if minv[j] < delta:
                        delta = minv[j]
                        j1 = j
            for j in range(0, n+1):
                if used[j]:
                    u[p[j]] += delta
                    v[j] -= delta
                else:
                    minv[j] -= delta
            j0 = j1
            if p[j0] == 0:
                break
        while True:
            j1 = way[j0]
            p[j0] = p[j1]
            j0 = j1
            if j0 == 0:
                break
    # recover matching and cost
    matchL = [-1]*n
    for j in range(1, n+1):
        if p[j] != 0:
            matchL[p[j]-1] = j-1
    total = 0
    for i in range(n):
        c = cost[i][matchL[i]]
        total += c
    return total, matchL

def check_minE_at_T(n, t, T):
    m = 2*n
    adj = build_graph_leq_T(t, T)
    targets = list(range(n, 2*n))
    cost = []
    feasible = True
    for i in range(n):
        row = bfs_distances(adj, i, targets)
        if min(row) >= INF_COST:
            feasible = False
        cost.append(row)
    if not feasible:
        return None
    total, _ = hungarian(cost)
    if total >= INF_COST:
        return None
    return total

def solve_all():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        # Self-tests
        # Test 1: simple equality at T=2
        n = 1
        a = [1, 0]; b = [0, 2]
        t = build_earliest_times(a, b)
        E = check_minE_at_T(n, t, 2); assert E == 1
        # Overall solve
        def full(n,a,b):
            t = build_earliest_times(a,b)
            # quick impossibility
            if check_minE_at_T(n, t, INF_TIME) is None:
                return -1, None
            lo, hi = 0, 1
            while check_minE_at_T(n, t, hi) is None:
                hi *= 2
                if hi > 2*10**12:
                    break
            ansT = hi
            while lo <= hi:
                mid = (lo + hi)//2
                if check_minE_at_T(n, t, mid) is not None:
                    ansT = mid
                    hi = mid - 1
                else:
                    lo = mid + 1
            ansE = check_minE_at_T(n, t, ansT)
            return ansT, ansE
        T,E = full(n,a,b)
        assert (T,E) == (2,1)
        # Test 2: impossible
        n=1; a=[0,1]; b=[0,1]
        T,E = full(n,a,b)
        assert T == -1
        print("OK")
        return
    it = iter(data)
    n = int(next(it))
    a = []
    b = []
    for _ in range(2*n):
        ai = int(next(it)); bi = int(next(it))
        a.append(ai); b.append(bi)
    t = build_earliest_times(a, b)
    # Quick impossibility
    if check_minE_at_T(n, t, INF_TIME) is None:
        print(-1)
        return
    # Exponential + binary search
    lo, hi = 0, 1
    while check_minE_at_T(n, t, hi) is None:
        hi *= 2
        if hi > 2*10**12:
            break
    ansT = hi
    while lo <= hi:
        mid = (lo + hi)//2
        if check_minE_at_T(n, t, mid) is not None:
            ansT = mid
            hi = mid - 1
        else:
            lo = mid + 1
    ansE = check_minE_at_T(n, t, ansT)
    print(ansT, ansE)

def main():
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three checks:
- A simple feasible case with $(T,E)=(2,1)$.
- An impossible case returns $-1$.
- The main path executes end-to-end on provided input.}
\RESULT{We output the minimal integer time $T$ and the minimal number of exchanges $E$ achievable at that time by optimally routing shares through $G_T$ and minimizing total path length.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-check earliest-time edges, BFS reachability, and Hungarian assignments on tiny handcrafted instances. Compare binary search endpoints and ensure monotonicity.}
\LINE{CROSS-CHECKS}{For small $n$, compare Approach A's $T$ with Approach C's $T$; ensure $E \ge n$ and that $E$ from Approach C is not larger than naive $n$.}
\LINE{EDGE-CASE GENERATOR}{Generate random tiny instances with $n \in \{1,2,3\}$ and random $a_i,b_i \in [0,5]$ to fuzz-test feasibility decisions and ensure consistency across approaches.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_cases():
    cases = []
    random.seed(0)
    # Simple equalities
    cases.append((1, [1,0], [0,2]))  # T=2
    # Impossible
    cases.append((1, [0,1], [0,1]))
    # Small randoms
    for _ in range(5):
        n = 2
        a = [random.randint(0,3) for _ in range(2*n)]
        b = [random.randint(0,3) for _ in range(2*n)]
        cases.append((n, a, b))
    return cases

def run_reference(n, a, b):
    # Use the final solver's core functions
    from collections import deque
    INF_TIME = 10**18
    INF_COST = 10**9
    def ceil_div_pos(x,y): return (x+y-1)//y
    def build_earliest_times(a,b):
        m=len(a); t=[[INF_TIME]*m for _ in range(m)]
        for u in range(m):
            for v in range(m):
                if u==v: t[u][v]=0; continue
                if b[u] >= b[v]: t[u][v]=0
                elif a[u] > a[v]: t[u][v]=ceil_div_pos(b[v]-b[u], a[u]-a[v])
        return t
    def build_graph_leq_T(t,T):
        m=len(t); adj=[[] for _ in range(m)]
        for u in range(m):
            au=adj[u]; row=t[u]
            for v in range(m):
                if row[v] <= T: au.append(v)
        return adj
    def bfs_dist(adj,s,targets):
        n=len(adj); d=[-1]*n; dq=deque([s]); d[s]=0
        while dq:
            u=dq.popleft()
            for v in adj[u]:
                if d[v]==-1: d[v]=d[u]+1; dq.append(v)
        return [d[j] if d[j]!=-1 else INF_COST for j in targets]
    def hungarian(cost):
        n=len(cost); INF=10**9
        u=[0]*(n+1); v=[0]*(n+1); p=[0]*(n+1); way=[0]*(n+1)
        for i in range(1,n+1):
            p[0]=i; j0=0; minv=[INF]*(n+1); used=[False]*(n+1)
            while True:
                used[j0]=True; i0=p[j0]; delta=INF; j1=0
                for j in range(1,n+1):
                    if not used[j]:
                        cur=cost[i0-1][j-1]-u[i0]-v[j]
                        if cur<minv[j]: minv[j]=cur; way[j]=j0
                        if minv[j]<delta: delta=minv[j]; j1=j
                for j in range(0,n+1):
                    if used[j]: u[p[j]]+=delta; v[j]-=delta
                    else: minv[j]-=delta
                j0=j1
                if p[j0]==0: break
            while True:
                j1=way[j0]; p[j0]=p[j1]; j0=j1
                if j0==0: break
        matchL=[-1]*n
        for j in range(1,n+1):
            if p[j]!=0: matchL[p[j]-1]=j-1
        total=0
        for i in range(n): total+=cost[i][matchL[i]]
        return total
    t=build_earliest_times(a,b)
    targets=list(range(n,2*n))
    def E_at(T):
        adj=build_graph_leq_T(t,T)
        cost=[bfs_dist(adj,i,targets) for i in range(n)]
        if any(min(row)>=INF_COST for row in cost): return None
        tot=hungarian(cost)
        if tot>=INF_COST: return None
        return tot
    if E_at(INF_TIME) is None: return -1, None
    lo,hi=0,1
    while E_at(hi) is None:
        hi*=2
        if hi>2*10**12: break
    ansT=hi
    while lo<=hi:
        mid=(lo+hi)//2
        if E_at(mid) is not None:
            ansT=mid; hi=mid-1
        else:
            lo=mid+1
    return ansT, E_at(ansT)

if __name__ == "__main__":
    for n,a,b in gen_cases():
        T,E = run_reference(n,a,b)
        print(n, a, b, "->", T, E)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Reference solution (educational): Binary search on time, Hungarian for minimal exchanges.
from collections import deque

INF_TIME = 10**18
INF_COST = 10**9

def ceil_div_pos(x, y):
    return (x + y - 1) // y  # for x>0, y>0

def build_earliest_times(a, b):
    m = len(a)
    t = [[INF_TIME]*m for _ in range(m)]
    for u in range(m):
        for v in range(m):
            if u == v:
                t[u][v] = 0
                continue
            bu, bv = b[u], b[v]
            au, av = a[u], a[v]
            if bu >= bv:
                t[u][v] = 0
            elif au > av:
                t[u][v] = ceil_div_pos(bv - bu, au - av)
            else:
                t[u][v] = INF_TIME
    return t

def build_graph_leq_T(t, T):
    m = len(t)
    adj = [[] for _ in range(m)]
    for u in range(m):
        row = t[u]
        uu = adj[u]
        for v in range(m):
            if row[v] <= T:
                uu.append(v)
    return adj

def bfs_distances(adj, start, targets):
    n = len(adj)
    dist = [-1]*n
    dq = deque([start])
    dist[start] = 0
    while dq:
        u = dq.popleft()
        du = dist[u] + 1
        for v in adj[u]:
            if dist[v] == -1:
                dist[v] = du
                dq.append(v)
    return [dist[j] if dist[j] != -1 else INF_COST for j in targets]

def hungarian(cost):
    n = len(cost)
    u = [0]*(n+1)
    v = [0]*(n+1)
    p = [0]*(n+1)
    way = [0]*(n+1)
    for i in range(1, n+1):
        p[0] = i
        j0 = 0
        minv = [INF_COST+1]*(n+1)
        used = [False]*(n+1)
        while True:
            used[j0] = True
            i0 = p[j0]
            delta = INF_COST+1
            j1 = 0
            for j in range(1, n+1):
                if not used[j]:
                    cur = cost[i0-1][j-1] - u[i0] - v[j]
                    if cur < minv[j]:
                        minv[j] = cur
                        way[j] = j0
                    if minv[j] < delta:
                        delta = minv[j]
                        j1 = j
            for j in range(0, n+1):
                if used[j]:
                    u[p[j]] += delta
                    v[j] -= delta
                else:
                    minv[j] -= delta
            j0 = j1
            if p[j0] == 0:
                break
        while True:
            j1 = way[j0]
            p[j0] = p[j1]
            j0 = j1
            if j0 == 0:
                break
    matchL = [-1]*n
    for j in range(1, n+1):
        if p[j] != 0:
            matchL[p[j]-1] = j-1
    total = 0
    for i in range(n):
        c = cost[i][matchL[i]]
        total += c
    return total, matchL

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = []
    b = []
    for _ in range(2*n):
        ai = int(next(it)); bi = int(next(it))
        a.append(ai); b.append(bi)
    return n, a, b

def minE_at_T(n, t, T):
    m = 2*n
    adj = build_graph_leq_T(t, T)
    targets = list(range(n, 2*n))
    cost = []
    for i in range(n):
        row = bfs_distances(adj, i, targets)
        if min(row) >= INF_COST:
            return None
        cost.append(row)
    total, _ = hungarian(cost)
    if total >= INF_COST:
        return None
    return total

def solve_all():
    inp = read_input()
    if inp is None:
        # Tiny asserts
        n = 1; a = [1,0]; b = [0,2]
        t = build_earliest_times(a, b)
        assert minE_at_T(n, t, 1) is None
        assert minE_at_T(n, t, 2) == 1
        n = 1; a = [0,1]; b = [0,1]
        t = build_earliest_times(a, b)
        assert minE_at_T(n, t, INF_TIME) is None
        print("OK")
        return
    n, a, b = inp
    t = build_earliest_times(a, b)
    # Quick impossibility
    if minE_at_T(n, t, INF_TIME) is None:
        print(-1)
        return
    # Exponential search
    lo, hi = 0, 1
    while minE_at_T(n, t, hi) is None:
        hi *= 2
        if hi > 2*10**12:
            break
    ansT = hi
    while lo <= hi:
        mid = (lo + hi)//2
        if minE_at_T(n, t, mid) is not None:
            ansT = mid
            hi = mid - 1
        else:
            lo = mid + 1
    ansE = minE_at_T(n, t, ansT)
    print(ansT, ansE)

def main():
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Binary search the earliest time $T$ such that sources can reach all targets in $G_T$; then minimize total exchanges via an assignment over shortest path lengths.}
\WHY{Time-dependent reachability with monotone constraints appears in advanced graph and flow problems. This combines bottleneck reachability, BFS layers, and bipartite assignment.}
\CHECKLIST{
- Compute $t_{uv}$ correctly with ceiling division.
- Build $G_T$ with edges $t_{uv}\le T$.
- BFS from each source for distances to targets.
- If any source cannot reach any target, infeasible.
- Run Hungarian; if finite, collect $E(T)$.
- Binary search on $T$; ensure monotonicity.}
\EDGECASES{
- $a_u=a_v$ and $b_u<b_v$: never reachable.
- $b_u=b_v$: immediate mutual edges at $T=0$.
- Large $a$ and $b$ values: avoid overflow by using Python integers or 64-bit in C++ with care.
- All sources initially below all targets but with larger slopes: need waiting.
- Multiple equal lines (same $(a,b)$): $t_{uv}=0$ both ways; distance $0$ between such types.
- Disconnected even at $T=\infty$: print $-1$.}
\PITFALLS{
- Using floor division instead of ceiling for earliest time.
- Assuming a single-time comparison $P_u(T)\ge P_v(T)$ is enough; chains at different times are necessary.
- Forgetting that exchanges can be done at any integer time up to $T$.
- Not handling ties correctly (both directions when equal).
- Double-counting exchanges: cost equals number of edges along the path.
- Hungarian with large sentinel values must not overflow; keep INF well above possible sums.}
\FAILMODES{Greedy matching without considering different distances can yield nonminimal $E$. Ignoring transitive reachability may falsely declare infeasibility. The proposed method survives by computing BFS distances and solving a global assignment.}
\ELI{You can hop from a more expensive stock to a cheaper one whenever allowed. By time $T$, think of a directed graph of allowed hops. Ensure each starting share can travel through this graph to a unique goal, and count how many hops in total. Find the smallest $T$ making this possible, then minimize the hops at that time.}
\NotePages{3}

\end{document}