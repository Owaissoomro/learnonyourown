% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Min Cost String}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1511/D}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Let us define the cost of a string $s$ as the number of index pairs $i$ and $j$ ($1 \le i < j < |s|$) such that $s_i = s_j$ and $s_{i+1} = s_{j+1}$.

You are given two positive integers $n$ and $k$. Among all strings with length $n$ that contain only the first $k$ characters of the Latin alphabet, find a string with minimum possible cost. If there are multiple such strings with minimum cost — find any of them.

Input: The only line contains two integers $n$ and $k$ ($1 \le n \le 2 \cdot 10^5; 1 \le k \le 26$).

Output: Print the string $s$ such that it consists of $n$ characters, each of its characters is one of the $k$ first Latin letters, and it has the minimum possible cost among all these strings. If there are multiple such strings — print any of them.}
\BREAKDOWN{We want to minimize duplicate bigrams in a length-$n$ string over an alphabet of size $k$. Model bigrams as directed edges in a $k$-node digraph and construct a walk that spreads usage of edges as evenly as possible. The classic optimal construction is a de Bruijn-like Eulerian cycle of order $2$.}
\ELI{Make a round-trip over all possible adjacent letter pairs exactly once, then repeat/truncate this cycle to length $n$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n$ and $k$ with $1 \le n \le 2 \cdot 10^5$ and $1 \le k \le 26$.}
\OUTPUTS{A string $s$ of length $n$ over the first $k$ lowercase Latin letters that minimizes the number of repeated adjacent-letter pairs. Any one minimizer is acceptable.}
\SAMPLES{
Input\\
7 2\\
Output\\
abbaaab\\
Explanation: The base cycle $abbaa$ contains every bigram from $\{a,b\}^2$ exactly once; repeating it and truncating to length $7$ yields a minimum-cost string.

Input\\
5 1\\
Output\\
aaaaa\\
Explanation: Only the letter $a$ is allowed, so the string is forced and optimal.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma = \{0,\ldots,k-1\}$ index the first $k$ letters. For a string $s$ of length $n$, define bigram counts $c_{ab}$ for $a,b \in \Sigma$ as the number of positions $i \in \{1,\ldots,n-1\}$ with $(s_i,s_{i+1})=(a,b)$. The objective is to minimize the number of pairs of equal bigrams, which equals $\sum_{a,b}\binom{c_{ab}}{2}$. The sequence of bigrams forms a length-$(n-1)$ walk in the complete directed multigraph $G$ on $\Sigma$ with one edge $a \to b$ for each pair $(a,b)$.}
\varmapStart
\var{s}{candidate string over the first $k$ letters}
\var{n}{target length of $s$}
\var{k}{alphabet size}
\var{c_{ab}}{count of bigram $(a,b)$ in $s$}
\varmapEnd
\GOVERN{
\[
\text{Minimize}\quad \sum_{a,b \in \Sigma} \binom{c_{ab}}{2}
\quad\text{subject to}\quad \sum_{b} c_{ab} - \sum_{b} c_{ba} \in \{-1,0,1\}\ \ \forall a,\ \ \sum_{a,b} c_{ab} = n-1,\ \ c_{ab} \in \mathbb{Z}_{\ge 0}.
\]
}
\ASSUMPTIONS{Indices are $1$-based for positions; letters are mapped $0 \mapsto a$, $1 \mapsto b$, etc. We consider the complete digraph on $k$ vertices.}
\INVARIANTS{
- The number of bigrams equals $n-1$.\\
- The bigrams trace a contiguous walk: consecutive bigrams overlap by one symbol.\\
- For fixed total $\sum_{a,b} c_{ab}$, the convexity of $\binom{x}{2}$ implies the sum is minimized when the $c_{ab}$ are as equal as constraints allow.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Generate a simple periodic pattern $abc\ldots$ over $k$ letters and repeat/truncate to length $n$. This is fast and always valid but not optimal in general.}
\ASSUMPTIONS{We only need to output some valid string; this baseline ignores the optimal-cost objective and serves as a sanity starter.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the base pattern $p = a,b,\ldots$ up to $k$ letters.
\item Repeat $p$ until reaching length at least $n$.
\item Truncate to exactly $n$.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(n)$ and space $S(n)=\Theta(1)$ aside from output.}
\[
\begin{aligned}
T(n) &= O(n) \\
S(n) &= O(1)
\end{aligned}
\]
\CORRECTNESS{The output string has length $n$ and uses only the first $k$ letters. It does not attempt to minimize cost.}
\EDGECASES{Handles $k=1$ by repeating $a$; handles $n=1$ by taking the first letter.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return None
    n = int(toks[0]); k = int(toks[1])
    return n, k

def solve_case(n, k):
    # Baseline periodic pattern: "abc...".
    base = ''.join(chr(ord('a') + i) for i in range(k))
    times = (n + len(base) - 1) // len(base)
    s = (base * times)[:n]
    return s

def solve_all():
    nk = read_input()
    if nk is None:
        # Self-checks when no stdin is provided
        assert solve_case(1, 1) == "a"
        assert solve_case(5, 1) == "aaaaa"
        s = solve_case(7, 2)
        assert len(s) == 7 and set(s) <= set("ab")
        print("OK")
        return
    n, k = nk
    print(solve_case(n, k))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Quick asserts on small $n,k$ ensure length and alphabet constraints.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy Bigram Balancing}
\WHICHFORMULA{Greedily choose the next letter to minimize the current count of the resulting bigram from the last letter, tie-breaking lexicographically. This attempts to equalize bigram usage.}
\ASSUMPTIONS{Maintain a $k \times k$ table of counts $c_{ab}$; start from $a$ and at each step choose $b$ minimizing $c_{ab}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $s = [a]$ and a zero matrix $c_{ab}$.
\item For $i=2$ to $n$: let $a$ be the last letter of $s$, choose $b \in [0,k-1]$ minimizing $c_{ab}$, append $b$, increment $c_{ab}$.
\item Convert indices to letters.
\end{algosteps}
\COMPLEXITY{Each step scans $k$ options: $T(n)=\Theta(nk)$, $S(n)=\Theta(k^2)$. For $k \le 26$, this is linear in $n$.}
\[
\begin{aligned}
T(n) &= O(nk) \\
S(n) &= O(k^2)
\end{aligned}
\]
\CORRECTNESS{This heuristic pushes the walk toward a near-Eulerian usage of edges, greatly reducing duplicate bigrams. It is not formally optimal but often matches the optimum.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return None
    n = int(toks[0]); k = int(toks[1])
    return n, k

def solve_case(n, k):
    if n == 0:
        return ""
    # Start from 'a'
    last = 0
    s = [last]
    counts = [[0]*k for _ in range(k)]
    for _ in range(1, n):
        # Choose b with minimal counts[last][b], tie-breaking by b
        best_b, best_c = 0, counts[last][0]
        for b in range(1, k):
            if counts[last][b] < best_c:
                best_b, best_c = b, counts[last][b]
        counts[last][best_b] += 1
        s.append(best_b)
        last = best_b
    return ''.join(chr(ord('a') + x) for x in s)

def solve_all():
    nk = read_input()
    if nk is None:
        # Tiny validations
        def cost(t):
            cnt = 0
            for i in range(len(t)-1):
                for j in range(i+1, len(t)-1):
                    if t[i]==t[j] and t[i+1]==t[j+1]:
                        cnt += 1
            return cnt
        s = solve_case(7, 2)
        assert len(s) == 7 and set(s) <= set("ab")
        # Check it never worse than baseline on tiny cases
        def baseline(n,k):
            base = ''.join(chr(ord('a')+i) for i in range(k))
            return (base * ((n+len(base)-1)//len(base)))[:n]
        for n in range(1, 8):
            for k in range(1, 4):
                assert cost(solve_case(n,k)) <= cost(baseline(n,k))
        print("OK")
        return
    n, k = nk
    print(solve_case(n, k))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Compares cost against the baseline on tiny inputs and checks alphabet/length.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Eulerian Cycle (de Bruijn of order $2$)}
\WHICHFORMULA{Construct an Eulerian cycle in the complete digraph on $k$ letters with one directed edge for each bigram $(a,b)$. Hierholzer's algorithm visits each edge exactly once, yielding a string of length $k^2+1$ whose bigrams are all distinct. Repeat and truncate to length $n$.}
\ASSUMPTIONS{The complete directed multigraph on $k$ vertices is strongly connected and Eulerian (in-degree equals out-degree at every vertex), so an Eulerian cycle exists from any start vertex.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a $k \times k$ boolean matrix $used$ to track whether edge $a \to b$ is traversed.
\item Depth-first search from $a$: for $b=0\ldots k-1$, if not used, mark $used[a][b]$, recurse at $b$, and append letter $b$ on backtrack.
\item After DFS, append the start letter $a$ to complete the cycle string of length $k^2+1$; repeat/truncate to length $n$.
\end{algosteps}
\OPTIMALITY{Because each bigram appears at most once per cycle, and the repeated pattern keeps bigram counts as balanced as possible, this construction minimizes $\sum_{a,b}\binom{c_{ab}}{2}$ for all $n$. Any other string induces at least as many duplicate bigram pairs.}
\COMPLEXITY{$T(n)=\Theta(k^2 + n)$, $S(n)=\Theta(k^2)$; DFS traverses $k^2$ edges once, then we fill $n$ characters.}
\[
\begin{aligned}
T(n) &= O(k^2) + O(n) \\
S(n) &= O(k^2)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return None
    n = int(toks[0]); k = int(toks[1])
    return n, k

def solve_case(n, k):
    # Build de Bruijn-like sequence of order 2 via Eulerian cycle.
    used = [[False]*k for _ in range(k)]
    ans = []

    sys.setrecursionlimit(1 << 20)

    def dfs(v):
        for b in range(k):
            if not used[v][b]:
                used[v][b] = True
                dfs(b)
                ans.append(chr(ord('a') + b))

    dfs(0)
    ans.append('a')  # starting vertex label
    base = ''.join(ans)  # length k^2 + 1
    # Repeat and truncate to n
    times = (n + len(base) - 1) // len(base)
    s = (base * times)[:n]
    return s

def solve_all():
    nk = read_input()
    if nk is None:
        # Local validations
        def cost(t):
            cnt = 0
            for i in range(len(t)-1):
                for j in range(i+1, len(t)-1):
                    if t[i]==t[j] and t[i+1]==t[j+1]:
                        cnt += 1
            return cnt
        # 1) Trivial alphabet
        assert solve_case(5,1) == "aaaaa"
        # 2) Small check vs exhaustive optimum on tiny n,k
        def brute(n,k):
            from itertools import product
            best = None
            best_s = None
            letters = [chr(ord('a')+i) for i in range(k)]
            for tup in product(letters, repeat=n):
                s = ''.join(tup)
                c = cost(s)
                if best is None or c < best:
                    best, best_s = c, s
            return best, best_s
        for n in range(1,6):
            for k in range(1,3):
                best, _ = brute(n,k)
                assert cost(solve_case(n,k)) == best
        # 3) Shape and alphabet check
        s = solve_case(7,2)
        assert len(s) == 7 and set(s) <= set("ab")
        print("OK")
        return
    n, k = nk
    print(solve_case(n, k))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Three asserts: exact optimality on tiny $(n \le 5,k \le 2)$ by brute force; trivial $k=1$; and a shape/alphabet check for $(n,k)=(7,2)$.}
\RESULT{Outputs any minimum-cost string; if multiple, any is acceptable. The produced string starts with $a$ and is derived from an Eulerian cycle over bigrams.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Property tests on small $(n,k)$ via brute force to confirm optimality; random spot checks for larger $n$ verifying bigram distribution balance; edge cases $k=1$, $n=1$.}
\LINE{CROSS-CHECKS}{Compare Approach B (greedy) cost to Approach C (optimal) on random small cases; they should match or Approach C be better.}
\LINE{EDGE-CASE GENERATOR}{Covers smallest/largest $k$, small $n$ for brute-force comparison, and larger $n$ for performance.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    # Small exhaustive domain
    for n in range(1, 6):
        for k in range(1, 3):
            yield n, k
    # Edge cases
    yield 1, 1
    yield 2, 26
    # Larger spot checks
    yield 100, 1
    yield 1000, 2
    yield 200000, 26

def cost(s):
    cnt = 0
    for i in range(len(s)-1):
        for j in range(i+1, len(s)-1):
            if s[i]==s[j] and s[i+1]==s[j+1]:
                cnt += 1
    return cnt
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return None
    n = int(toks[0]); k = int(toks[1])
    return n, k

def solve_case(n, k):
    used = [[False]*k for _ in range(k)]
    ans = []

    sys.setrecursionlimit(1 << 20)

    def dfs(v):
        for b in range(k):
            if not used[v][b]:
                used[v][b] = True
                dfs(b)
                ans.append(chr(ord('a') + b))

    dfs(0)
    ans.append('a')
    base = ''.join(ans)
    times = (n + len(base) - 1) // len(base)
    return (base * times)[:n]

def solve_all():
    nk = read_input()
    if nk is None:
        # Minimal smoke tests
        assert solve_case(5,1) == "aaaaa"
        s = solve_case(7,2)
        assert len(s) == 7 and set(s) <= set("ab")
        # Tiny optimality by brute force
        def cost(t):
            cnt = 0
            for i in range(len(t)-1):
                for j in range(i+1, len(t)-1):
                    if t[i]==t[j] and t[i+1]==t[j+1]:
                        cnt += 1
            return cnt
        from itertools import product
        for n in range(1, 5):
            for k in range(1, 3):
                letters = [chr(ord('a')+i) for i in range(k)]
                best = None
                for tup in product(letters, repeat=n):
                    c = cost(''.join(tup))
                    if best is None or c < best:
                        best = c
                assert cost(solve_case(n,k)) == best
        print("OK")
        return
    n, k = nk
    print(solve_case(n, k))

if __name__ == "__main__":
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Construct a de Bruijn-like cycle of all bigrams over $k$ letters via an Eulerian tour, then repeat/truncate to length $n$.}
\WHY{This pattern of constructing Eulerian tours in product graphs appears frequently in string construction and minimization of repeated substrings in interviews and contests.}
\CHECKLIST{
- Model bigrams as edges in a $k$-node digraph.\\
- Use Hierholzer's algorithm to traverse each edge once.\\
- Append edge labels on backtrack and the start node at the end.\\
- Repeat/truncate to length $n$.\\
- Sanity-check $k=1$, $n=1$.}
\EDGECASES{
- $k=1$: output $a^n$.\\
- $n=1$: any single letter $a$.\\
- $n \le k^2+1$: just take the prefix of the base cycle.\\
- Very large $n$: ensure efficient repeat/truncate.\\
- Recursion depth: safe for $k \le 26$; still set a higher limit.\\
- Alphabet bounds: only first $k$ letters.}
\PITFALLS{
- Appending in the wrong DFS order (must append on backtrack).\\
- Forgetting the final starting letter, producing length $k^2$ instead of $k^2+1$.\\
- Using visited vertices instead of visited edges.\\
- Mishandling $k=1$ special case (cycle still works).\\
- Off-by-one in repetition/truncation to length $n$.\\
- Not making recursion limit sufficient.}
\FAILMODES{Greedy or periodic constructions may concentrate bigrams and increase duplicate counts. The Eulerian approach guarantees each bigram appears uniformly, achieving minimum possible collisions.}
\ELI{Think of all adjacent-letter pairs as streets between $k$ intersections. Drive each street exactly once to make a loop. Now keep looping and stop after $n$ letters; you will have repeated pairs as little as possible.}
\NotePages{3}

\end{document}