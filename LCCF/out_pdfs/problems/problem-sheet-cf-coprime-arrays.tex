% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Coprime Arrays}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/915/G}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Let us call an array $a$ of size $n$ coprime iff $\gcd(a_1,a_2,\ldots,a_n)=1$, where $\gcd$ is the greatest common divisor of the arguments.

You are given two numbers $n$ and $k$. For each $i$ ($1 \le i \le k$) you have to determine the number of coprime arrays $a$ of size $n$ such that for every $j$ ($1 \le j \le n$) we have $1 \le a_j \le i$. Since the answers can be very large, you have to calculate them modulo $10^9 + 7$.

Input: The first line contains two integers $n$ and $k$ ($1 \le n,k \le 2\cdot 10^6$) — the size of the desired arrays and the maximum upper bound on elements, respectively.

Output: Since printing $2\cdot 10^6$ numbers may take a lot of time, you have to output the answer in such a way:

Let $b_i$ be the number of coprime arrays with elements in range $[1,i]$, taken modulo $10^9 + 7$. You have to print $\sum_{i=1}^{k}\bigl(b_i \oplus i\bigr)$, taken modulo $10^9 + 7$. Here $\oplus$ denotes bitwise xor operation (\^{} in C++ or Java, xor in Pascal).

Note (explanation of the example):

Since the number of coprime arrays is large, we will list the arrays that are non-coprime, but contain only elements in range $[1,i]$:

For $i=1$, the only array is coprime. $b_1=1$.

For $i=2$, array $[2,2,2]$ is not coprime. $b_2=7$.

For $i=3$, arrays $[2,2,2]$ and $[3,3,3]$ are not coprime. $b_3=25$.

For $i=4$, arrays $[2,2,2]$, $[3,3,3]$, $[2,2,4]$, $[2,4,2]$, $[2,4,4]$, $[4,2,2]$, $[4,2,4]$, $[4,4,2]$ and $[4,4,4]$ are not coprime. $b_4=55$.}
\BREAKDOWN{Compute, for every $i\in[1,k]$, the count of $n$-tuples in $[1,i]^n$ with gcd $1$, then aggregate $\sum (b_i \oplus i)$ modulo $10^9+7$. Use Möbius inversion to express $b_i$ and accumulate all $b_i$ efficiently across $i=1..k$.}
\ELI{Use the Möbius function: count tuples whose $\gcd$ equals $1$ by inclusion-exclusion over common divisors, and push each divisor's constant contribution into contiguous ranges of $i$ via difference-array range adds.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers: $n$ and $k$ with $1 \le n,k \le 2\cdot 10^6$.}
\OUTPUTS{Single integer: $\left(\sum_{i=1}^{k} (b_i \oplus i)\right) \bmod (10^9+7)$, where $b_i$ is the number of length-$n$ arrays over $[1,i]$ with gcd $1$, computed modulo $10^9+7$.}
\SAMPLES{Example for $n=3$, $k=4$: $b_1=1$, $b_2=7$, $b_3=25$, $b_4=55$, so the output is $(1\oplus 1)+(7\oplus 2)+(25\oplus 3)+(55\oplus 4)=0+5+26+51=82$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For $i\in[1,k]$, let $b_i = \#\{(a_1,\ldots,a_n)\in[1,i]^n : \gcd(a_1,\ldots,a_n)=1\}\bmod M$, with $M=10^9+7$. Using Möbius inversion with $\mu$, we have
\begin{BreakableEquation*}
b_i \equiv \sum_{d=1}^{i} \mu(d)\,\Bigl\lfloor \frac{i}{d}\Bigr\rfloor^n \pmod{M}.
\end{BreakableEquation*}
We require $S=\sum_{i=1}^{k} (b_i \oplus i) \bmod M$.}
\varmapStart
\var{n}{array length}
\var{k}{maximum upper bound across queries}
\var{M}{modulus $10^9+7$}
\var{\mu(d)}{Möbius function}
\var{b_i}{count of $n$-tuples over $[1,i]$ with gcd $1$ (mod $M$)}
\var{S}{requested output sum modulo $M$}
\varmapEnd
\GOVERN{
\[
b_i \equiv \sum_{d=1}^{i} \mu(d)\,\Bigl\lfloor \frac{i}{d}\Bigr\rfloor^n \pmod{M}, \qquad
S \equiv \sum_{i=1}^{k}\bigl( (b_i \bmod M) \oplus i \bigr) \pmod{M}.
\]
}
\ASSUMPTIONS{Arithmetic modulo $M$ is taken only for $b_i$ and the final sum $S$. Bitwise xor is performed on non-negative integers with unbounded width (standard integer semantics).}
\INVARIANTS{The difference-array accumulation maintains that after processing all $(d,t)$ pairs, the prefix sums at index $i$ equal $b_i$. The linear sieve correctly computes $\mu$ with $\sum_{d\mid m}\mu(d)=[m=1]$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly apply $b_i=\sum_{d=1}^{i}\mu(d)\,\lfloor i/d\rfloor^n$ for each $i$, recomputing the sum independently.}
\ASSUMPTIONS{We can precompute $\mu$ up to $k$ once. This approach is only feasible for small $k$ since it is $O(k^2)$ in the worst case.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $\mu(d)$ for $d\le k$ by linear sieve.
\item For each $i=1..k$: accumulate $b_i=\sum_{d=1}^{i}\mu(d)\,\lfloor i/d\rfloor^n \bmod M$ using fast modular exponentiation.
\item Output $S=\sum_{i=1}^{k} (b_i \oplus i) \bmod M$.
\end{algosteps}
\COMPLEXITY{Quadratic in $k$ due to the inner loop over $d\le i$ for each $i$.}
\[
\begin{aligned}
T(k) &= \sum_{i=1}^{k} O(i + \log n) \\
     &= O(k^2) \quad \text{(dominant term)} \\
S(k) &= O(k)\ \text{words (to store $\mu$ and a few scalars).}
\end{aligned}
\]
\CORRECTNESS{This is a direct evaluation of the Möbius inversion identity for each $i$, so it matches the definition of $b_i$.}
\EDGECASES{Handle $\mu(d)=0$ terms; $n=1$ gives $b_i=1$ for all $i\ge 1$; ensure modulo normalization for negative contributions.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
import sys

MOD = 10**9 + 7

def mobius_upto(n):
    mu = [0] * (n + 1)
    mu[1] = 1
    primes = []
    lp = [0] * (n + 1)
    for i in range(2, n + 1):
        if lp[i] == 0:
            lp[i] = i
            primes.append(i)
            mu[i] = -1
        for p in primes:
            v = i * p
            if v > n or p > lp[i]:
                break
            lp[v] = p
            if p == lp[i]:
                mu[v] = 0
                break
            else:
                mu[v] = -mu[i]
    return mu

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    return n, k

def solve_case(n, k):
    mu = mobius_upto(k)
    ans_xor_sum = 0
    for i in range(1, k + 1):
        bi = 0
        for d in range(1, i + 1):
            md = mu[d]
            if md == 0:
                continue
            t = i // d
            bi = (bi + (t * pow(t, n - 1, MOD) if n >= 1 else (1 if t == 0 else 0)) * md) % MOD
            # The above uses t^n; written as t * t^(n-1) to avoid pow(t, 0, MOD) special casing
        bi %= MOD
        ans_xor_sum = (ans_xor_sum + (bi ^ i)) % MOD
    return ans_xor_sum

def main():
    n, k = read_input()
    print(solve_case(n, k))

if __name__ == "__main__":
    # Tiny asserts (baseline is slow; use very small k)
    assert solve_case(1, 5) == (0 + 3 + 2 + 5 + 4) % MOD  # b_i = 1 for all i
    # For n=3, k=4 from the note: b=[1,7,25,55] -> XOR sum = 82
    assert solve_case(3, 4) == 82
    # Do not run main() for asserts
    pass
\end{minted}
\VALIDATION{Validated on $n=1$ (trivial), and the provided $n=3,k=4$ example.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-$i$ Quotient Grouping}
\WHICHFORMULA{Group divisors $d$ with the same quotient $q=\lfloor i/d\rfloor$, so the sum runs over $O(\sqrt{i})$ blocks: if $d\in[L,R]$, then $\lfloor i/d\rfloor=q$ is constant and contributes $\bigl(\sum_{d=L}^{R}\mu(d)\bigr)\cdot q^n$.}
\ASSUMPTIONS{Prefix sums $M(x)=\sum_{d\le x}\mu(d)$ are precomputed. Fast exponentiation computes $q^n \bmod M$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sieve $\mu$ up to $k$ and precompute prefix $M(x)$.
\item For each $i=1..k$: iterate $d$ by jumping to $R=\lfloor i/\lfloor i/d\rfloor\rfloor$, accumulate $(M(R)-M(d-1))\cdot \lfloor i/d\rfloor^n$.
\item Aggregate $S=\sum (b_i \oplus i) \bmod M$.
\end{algosteps}
\COMPLEXITY{Per $i$ cost $O(\sqrt{i})$ groups; total $\sum_{i=1}^{k} O(\sqrt{i}) = O(k^{3/2})$, improving on $O(k^2)$ but still too slow for the largest limits.}
\[
\begin{aligned}
T(k) &= \Theta\!\left(\sum_{i=1}^{k} \sqrt{i}\right) = \Theta(k^{3/2}), \\
S(k) &= O(k).
\end{aligned}
\]
\CORRECTNESS{Each block aggregates constant quotient $q$ with the correct total Möbius mass $M(R)-M(L-1)$, preserving the Möbius inversion identity.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
import sys

MOD = 10**9 + 7

def mobius_upto_with_prefix(n):
    mu = [0] * (n + 1)
    mu[1] = 1
    primes = []
    lp = [0] * (n + 1)
    for i in range(2, n + 1):
        if lp[i] == 0:
            lp[i] = i
            primes.append(i)
            mu[i] = -1
        for p in primes:
            v = i * p
            if v > n or p > lp[i]:
                break
            lp[v] = p
            if p == lp[i]:
                mu[v] = 0
                break
            else:
                mu[v] = -mu[i]
    pref = [0] * (n + 1)
    s = 0
    for i in range(1, n + 1):
        s += mu[i]
        pref[i] = s
    return mu, pref

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    return n, k

def solve_case(n, k):
    mu, pref = mobius_upto_with_prefix(k)
    ans_xor_sum = 0
    for i in range(1, k + 1):
        d = 1
        bi = 0
        while d <= i:
            q = i // d
            R = i // q
            mass = pref[R] - pref[d - 1] if d > 1 else pref[R]
            bi = (bi + (pow(q, n, MOD) * mass)) % MOD
            d = R + 1
        ans_xor_sum = (ans_xor_sum + (bi ^ i)) % MOD
    return ans_xor_sum

def main():
    n, k = read_input()
    print(solve_case(n, k))

if __name__ == "__main__":
    # Tiny tests only; this is O(k^{3/2})
    assert solve_case(1, 5) == (0 + 3 + 2 + 5 + 4) % MOD
    assert solve_case(3, 4) == 82
    pass
\end{minted}
\VALIDATION{Checked on the same tiny cases as Approach A.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Range-Add via Möbius Inversion}
\WHICHFORMULA{For fixed $d$, the term $\mu(d)\,\lfloor i/d\rfloor^n$ is constant for all $i$ in $[td, (t+1)d-1]$ with value $\mu(d)\,t^n$. We range-add this constant to all $i$ in that interval using a difference array, for every $d$ and $t=1..\lfloor k/d\rfloor$.}
\ASSUMPTIONS{Precompute $\mu$ up to $k$ by linear sieve and powers $t^n$ for $t\le k$. Use a difference array of length $k+2$ to apply $O(1)$ range updates; finalize $b_i$ by a single prefix sum.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sieve $\mu(1..k)$; precompute $p[t]=t^n \bmod M$ for $t=1..k$.
\item Initialize $\text{diff}[1..k+2]=0$.
\item For each $d=1..k$ with $\mu(d)\ne 0$: for each $t=1..\lfloor k/d\rfloor$, set $L=td$, $R=\min((t+1)d-1,k)$ and add $v=\mu(d)\cdot p[t]\bmod M$ to $\text{diff}[L]$ and subtract $v$ from $\text{diff}[R+1]$.
\item Recover $b_i$ by prefix sum: $b_i=(b_{i-1}+\text{diff}[i])\bmod M$.
\item Output $S=\sum_{i=1}^{k} (b_i \oplus i) \bmod M$.
\end{algosteps}
\OPTIMALITY{The double loop visits each pair $(d,t)$ with $td\le k$ once, i.e., $\sum_{d=1}^{k}\lfloor k/d\rfloor = k H_k = O(k\log k)$. This matches the natural Dirichlet hyperbola complexity and is optimal up to constant factors for enumerating all floor-division values.}
\COMPLEXITY{$O(k\log k)$ time and $O(k)$ memory (plus $O(k)$ for precomputed powers and $\mu$).}
\[
\begin{aligned}
T(k) &= O(k \log k) + O(k \log n) \text{ (for powers)} + O(k) \\
S(k) &= O(k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys

MOD = 10**9 + 7

def mobius_upto(n: int):
    mu = [0] * (n + 1)
    mu[1] = 1
    primes = []
    lp = [0] * (n + 1)
    for i in range(2, n + 1):
        if lp[i] == 0:
            lp[i] = i
            primes.append(i)
            mu[i] = -1
        for p in primes:
            v = i * p
            if v > n or p > lp[i]:
                break
            lp[v] = p
            if p == lp[i]:
                mu[v] = 0
                break
            else:
                mu[v] = -mu[i]
    return mu

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    return n, k

def solve_case(n: int, k: int) -> int:
    mu = mobius_upto(k)
    # Precompute t^n for t=1..k
    pw = [0] * (k + 1)
    for t in range(1, k + 1):
        pw[t] = pow(t, n, MOD)
    diff = [0] * (k + 3)
    for d in range(1, k + 1):
        md = mu[d]
        if md == 0:
            continue
        max_t = k // d
        for t in range(1, max_t + 1):
            L = t * d
            R = (t + 1) * d - 1
            if R > k:
                R = k
            val = (pw[t] * md) % MOD
            diff[L] = (diff[L] + val) % MOD
            diff[R + 1] = (diff[R + 1] - val) % MOD
    ans = 0
    cur = 0
    for i in range(1, k + 1):
        cur += diff[i]
        cur %= MOD
        bi = cur
        ans = (ans + (bi ^ i)) % MOD
    return ans

def main():
    n, k = read_input()
    print(solve_case(n, k))

if __name__ == "__main__":
    # Cross-check against a direct per-i Möbius evaluation for small sizes
    def direct(n, k):
        mu = mobius_upto(k)
        res = 0
        for i in range(1, k + 1):
            bi = 0
            for d in range(1, i + 1):
                if mu[d] == 0:
                    continue
                t = i // d
                bi = (bi + mu[d] * pow(t, n, MOD)) % MOD
            res = (res + (bi ^ i)) % MOD
        return res

    assert solve_case(1, 5) == (0 + 3 + 2 + 5 + 4) % MOD
    assert solve_case(3, 4) == 82
    # Random tiny check
    assert solve_case(2, 6) == direct(2, 6)
    # main() is not run during asserts
    pass
\end{minted}
\VALIDATION{Three asserts: (1) $n=1,k=5$ closed form; (2) example $n=3,k=4$ gives $82$; (3) random tiny cross-check vs direct evaluation for $(n,k)=(2,6)$.}
\RESULT{Outputs $\sum_{i=1}^{k} (b_i \oplus i) \bmod (10^9+7)$, where $b_i$ are computed via Möbius inversion with range-add accumulation.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover trivial cases ($n=1$), provided sample-like case ($n=3,k=4$), and a random tiny case cross-checked against a slower direct method.}
\LINE{CROSS-CHECKS}{Compare Approach C against a direct Möbius evaluation for small $k$; results must match exactly modulo $M$.}
\LINE{EDGE-CASE GENERATOR}{Generate tiny $(n,k)$ with $n\in\{1,2,3\}$ and $k\le 8$ to stress the boundary conditions, zero $\mu$ contributions, and range endpoints $R=\min((t+1)d-1,k)$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def tiny_cases():
    cases = []
    for n in [1, 2, 3]:
        for k in range(1, 9):
            cases.append((n, k))
    return cases

def run_cross_checks():
    from random import seed
    seed(0)
    MOD = 10**9 + 7

    def mobius_upto(n):
        mu = [0] * (n + 1)
        mu[1] = 1
        primes = []
        lp = [0] * (n + 1)
        for i in range(2, n + 1):
            if lp[i] == 0:
                lp[i] = i
                primes.append(i)
                mu[i] = -1
            for p in primes:
                v = i * p
                if v > n or p > lp[i]:
                    break
                lp[v] = p
                if p == lp[i]:
                    mu[v] = 0
                    break
                else:
                    mu[v] = -mu[i]
        return mu

    def solve_C(n, k):
        mu = mobius_upto(k)
        pw = [0] * (k + 1)
        for t in range(1, k + 1):
            pw[t] = pow(t, n, MOD)
        diff = [0] * (k + 3)
        for d in range(1, k + 1):
            md = mu[d]
            if md == 0:
                continue
            max_t = k // d
            for t in range(1, max_t + 1):
                L = t * d
                R = (t + 1) * d - 1
                if R > k:
                    R = k
                val = (pw[t] * md) % MOD
                diff[L] = (diff[L] + val) % MOD
                diff[R + 1] = (diff[R + 1] - val) % MOD
        ans = 0
        cur = 0
        for i in range(1, k + 1):
            cur = (cur + diff[i]) % MOD
            ans = (ans + (cur ^ i)) % MOD
        return ans

    def direct(n, k):
        mu = mobius_upto(k)
        res = 0
        for i in range(1, k + 1):
            bi = 0
            for d in range(1, i + 1):
                if mu[d] == 0:
                    continue
                bi = (bi + mu[d] * pow(i // d, n, MOD)) % MOD
            res = (res + (bi ^ i)) % MOD
        return res

    for n, k in tiny_cases():
        assert solve_C(n, k) == direct(n, k)
    return True
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys

MOD = 10**9 + 7

def mobius_upto(n: int):
    mu = [0] * (n + 1)
    mu[1] = 1
    primes = []
    lp = [0] * (n + 1)
    for i in range(2, n + 1):
        if lp[i] == 0:
            lp[i] = i
            primes.append(i)
            mu[i] = -1
        for p in primes:
            v = i * p
            if v > n or p > lp[i]:
                break
            lp[v] = p
            if p == lp[i]:
                mu[v] = 0
                break
            else:
                mu[v] = -mu[i]
    return mu

def solve_all(n: int, k: int) -> int:
    mu = mobius_upto(k)
    pw = [0] * (k + 1)
    for t in range(1, k + 1):
        pw[t] = pow(t, n, MOD)
    diff = [0] * (k + 3)
    for d in range(1, k + 1):
        md = mu[d]
        if md == 0:
            continue
        max_t = k // d
        for t in range(1, max_t + 1):
            L = t * d
            R = (t + 1) * d - 1
            if R > k:
                R = k
            val = (pw[t] * md) % MOD
            diff[L] = (diff[L] + val) % MOD
            diff[R + 1] = (diff[R + 1] - val) % MOD
    ans = 0
    cur = 0
    for i in range(1, k + 1):
        cur += diff[i]
        cur %= MOD
        ans = (ans + (cur ^ i)) % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    n = int(data[0]); k = int(data[1])
    return n, k

def main():
    n, k = read_input()
    print(solve_all(n, k))

if __name__ == "__main__":
    # Sanity asserts
    assert solve_all(1, 5) == (0 + 3 + 2 + 5 + 4) % MOD
    assert solve_all(3, 4) == 82
    print("OK", file=sys.stderr)
    # main()  # Disabled in self-check context
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count gcd-$1$ tuples over $[1,i]^n$ for all $i\le k$ via Möbius inversion, accumulated efficiently by range additions on contiguous $i$-intervals where $\lfloor i/d\rfloor$ is constant.}
\WHY{This pattern (Möbius + floor-division grouping) recurs in number-theory DP and counting problems where gcd or divisibility constraints appear across many bounds $i$.}
\CHECKLIST{
\begin{bullets}
\item Sieve $\mu$ correctly (linear sieve).
\item Precompute $t^n \bmod M$ for $t\le k$.
\item For each $d$, iterate $t=1..\lfloor k/d\rfloor$, range-add $\mu(d)\,t^n$ on $[td, \min((t+1)d-1,k)]$.
\item Prefix-sum difference array to get $b_i$.
\item Aggregate xor-sum and apply final modulo.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$: all $b_i=1$.
\item $k=1$: single value path.
\item $\mu(d)=0$: skip quickly.
\item Range tail when $(t+1)d-1>k$.
\item Modulo normalization after negative adds in difference array.
\item Large $n$ with $t=0$ never occurs since $t\ge 1$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using $b_i$ before prefix-summing diff.
\item Forgetting to cap $R$ at $k$.
\item Integer overflow in languages without big ints (use 64-bit and modulo).
\item Recomputing $t^n$ inside inner loops (precompute).
\item Off-by-one in intervals $[td,(t+1)d-1]$.
\item Misusing xor with modulo (apply xor to $b_i \bmod M$, then sum modulo).
\end{bullets}
}
\FAILMODES{Per-$i$ evaluation ($O(k^2)$) and per-$i$ quotient grouping ($O(k^{3/2})$) will time out for $k=2\cdot 10^6$. The range-add method survives due to $O(k\log k)$ iterations.}
\ELI{We count arrays that share a common divisor $d$ and subtract overlaps using the Möbius function. Each $d$ contributes a constant to long stretches of $i$, so we add that constant to the whole stretch at once, then sweep once to recover all answers.}
\NotePages{3}

\end{document}