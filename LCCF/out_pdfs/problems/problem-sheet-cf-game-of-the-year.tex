% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Game of the Year}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1783/E}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Monocarp and Polycarp are playing a computer game. This game features $n$ bosses for the playing to kill, numbered from $1$ to $n$.

They will fight each boss the following way:
\begin{itemize}
\item Monocarp makes $k$ attempts to kill the boss;
\item Polycarp makes $k$ attempts to kill the boss;
\item Monocarp makes $k$ attempts to kill the boss;
\item Polycarp makes $k$ attempts to kill the boss;
\item \ldots
\end{itemize}

Monocarp kills the $i$-th boss on his $a_i$-th attempt. Polycarp kills the $i$-th boss on his $b_i$-th attempt. After one of them kills the $i$-th boss, they move on to the $(i+1)$-st boss. The attempt counters reset for both of them. Once one of them kills the $n$-th boss, the game ends.

Find all values of $k$ from $1$ to $n$ such that Monocarp kills all bosses.

Input: The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of testcases.

The first line of each testcase contains a single integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of bosses.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le n$) — the index of attempt Monocarp kills each boss on.

The third line contains $n$ integers $b_1, b_2, \ldots, b_n$ ($1 \le b_i \le n$) — the index of attempt Polycarp kills each boss on.

The sum of $n$ over all testcases does not exceed $2 \cdot 10^5$.

Output: For each testcase, print two lines. The first line should contain a single integer $\mathit{cnt}$ — the number of values of $k$ from $1$ to $n$ such that Monocarp kills all bosses. The second line should contain $\mathit{cnt}$ distinct integers — the values of $k$ themselves.

Note: Consider the last testcase of the example.

Let $k = 1$. First, Monocarp makes one attempt to kill the first boss. It is successful, since $a_1 = 1$. Then, Monocarp makes one attempt to kill the second boss. It is unsuccessful, since $a_2 > 1$. So, Polycarp makes an attempt then. It is also unsuccessful, since $b_2 > 1$. Then, Monocarp makes another attempt. It is still unsuccessful, since $a_2 > 2$. This goes on until Polycarp finally kills the boss on his third attempt. Monocarp did not kill this boss, thus, $k = 1$ is not the answer.

Let $k = 2$. Monocarp still kills the first boss on his first attempt. Then, he makes two unsuccessful attempts for the second boss. Then, Polycarp makes two unsuccessful attempts. Then, Monocarp makes two more attempts and kills the boss on his fourth attempt. The third boss is similar. First, two unsuccessful attempts by Monocarp. Then, two unsuccessful attempts by Polycarp. Then, Monocarp has two more attempts, but even his first one is successful, since $a_3 = 3$. The fourth boss is also killed by Monocarp. Thus, $k = 2$ is the answer.}
\BREAKDOWN{The fight on each boss alternates blocks of $k$ attempts by Monocarp and Polycarp. Monocarp kills boss $i$ if and only if the block index containing his $a_i$-th attempt is not later than the block index containing Polycarp's $b_i$-th attempt. This yields a per-boss inequality in $k$; the task asks for all $k \in [1,n]$ satisfying all inequalities simultaneously.}
\ELI{Monocarp wins boss $i$ iff $\lceil a_i/k \rceil \le \lceil b_i/k \rceil$. We need all $k$ making this true for every boss.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple testcases. For each testcase:
\begin{bullets}
\item $n$ (integer), $1 \le n \le 2\cdot 10^5$.
\item Array $a[1..n]$, integers with $1 \le a_i \le n$.
\item Array $b[1..n]$, integers with $1 \le b_i \le n$.
\end{bullets}
Total $\sum n \le 2\cdot 10^5$.}
\OUTPUTS{For each testcase:
\begin{bullets}
\item First line: $\mathit{cnt}$, the number of valid $k \in [1,n]$ such that Monocarp kills all bosses.
\item Second line: the $\mathit{cnt}$ values of $k$ in increasing order, separated by spaces (print an empty line if $\mathit{cnt}=0$).
\end{bullets}}
\SAMPLES{
Example 1:
\begin{verbatim}
Input
1
1
1
1

Output
1
1
\end{verbatim}

Example 2:
\begin{verbatim}
Input
1
3
1 3 3
1 2 3

Output
1
3
\end{verbatim}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For a fixed $k$, attempts occur in blocks of $k$ tries: Monocarp on blocks $0,2,4,\ldots$ and Polycarp on $1,3,5,\ldots$. Monocarp's $a_i$-th attempt lies in M-block number $\lceil a_i/k \rceil$ (1-indexed among M-blocks), while Polycarp's $b_i$-th attempt lies in P-block number $\lceil b_i/k \rceil$. Monocarp kills boss $i$ iff $2(\lceil a_i/k \rceil-1) < 2\lceil b_i/k \rceil-1$, equivalently $\lceil a_i/k \rceil \le \lceil b_i/k \rceil$.}
\varmapStart
\var{k}{block size, integer in $[1,n]$}
\var{a_i}{Monocarp's successful attempt index on boss $i$}
\var{b_i}{Polycarp's successful attempt index on boss $i$}
\var{c_i(k)}{$\lceil a_i/k \rceil$}
\var{d_i(k)}{$\lceil b_i/k \rceil$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i\in\{1,\ldots,n\}:\quad c_i(k) \le d_i(k).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Attempts per boss are independent; after a kill on boss $i$, both counters reset. Arrays $a,b$ respect ranges $[1,n]$.}
\INVARIANTS{
\begin{bullets}
\item If $a_i \le b_i$, then $c_i(k) \le d_i(k)$ for all $k$ (monotonicity of $\lceil \cdot \rceil$).
\item If $a_i > b_i$, then feasibility requires $c_i(k)=d_i(k)$ (since $c_i(k) \ge d_i(k)$ always, equality is necessary).
\item For fixed $x$, $\lceil x/k \rceil$ is nonincreasing in $k$ and takes $O(\sqrt{x})$ distinct values over $k\in[1,n]$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the direct per-boss condition $\lceil a_i/k \rceil \le \lceil b_i/k \rceil$. For each $k\in[1,n]$, scan all bosses and check the condition.}
\ASSUMPTIONS{Sum of $n$ over tests is bounded, but this naive method is $O(n^2)$ per testcase in the worst case and will TLE on maximal inputs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For $k=1$ to $n$:
\item Check $\lceil a_i/k \rceil \le \lceil b_i/k \rceil$ for all $i=1..n$.
\item If all hold, record $k$.
\end{algosteps}
\COMPLEXITY{For each $k$, $O(n)$ checks, across $n$ values of $k$: $T(n)=O(n^2)$, $S(n)=O(1)$ extra.}
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n} O(n) = O(n^2).
\end{aligned}
\]
\CORRECTNESS{Directly enforces the governing inequality per boss for each candidate $k$.}
\EDGECASES{Handles $n=1$; if all $a_i \le b_i$, then every $k$ is valid.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, List[int], List[int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        cases.append((n, a, b))
    return t, cases

def wins_all_bruteforce(n: int, a: List[int], b: List[int], k: int) -> bool:
    # Monocarp wins boss i iff ceil(a_i/k) <= ceil(b_i/k)
    for i in range(n):
        ai, bi = a[i], b[i]
        if (ai + k - 1) // k > (bi + k - 1) // k:
            return False
    return True

def solve_case_bruteforce(n: int, a: List[int], b: List[int]) -> List[int]:
    ans = []
    for k in range(1, n + 1):
        if wins_all_bruteforce(n, a, b, k):
            ans.append(k)
    return ans

def solve_all_bruteforce(cases: List[Tuple[int, List[int], List[int]]]) -> List[List[int]]:
    out = []
    for n, a, b in cases:
        out.append(solve_case_bruteforce(n, a, b))
    return out

def main():
    if sys.stdin.isatty():
        return
    t, cases = read_input()
    outs = solve_all_bruteforce(cases)
    w = []
    for ks in outs:
        w.append(str(len(ks)))
        w.append("" if not ks else " ".join(map(str, ks)))
    sys.stdout.write("\n".join(w))

# --- tests (tiny) ---
def _brute_small():
    assert solve_case_bruteforce(1, [1], [1]) == [1]
    # From IO sample 2 in the sheet
    assert solve_case_bruteforce(3, [1,3,3], [1,2,3]) == [3]
    # Random tiny
    assert solve_case_bruteforce(2, [1,2], [2,1]) == [2]

if __name__ == "__main__":
    _brute_small()
    # Do not call main() in interactive runs; it's fine when piping input.
    # main()
\end{minted}
\VALIDATION{Checked single boss; the provided tiny sample; a crafted case with crossing $a,b$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-boss Segmentation on $\lceil a_i/k \rceil$}
\WHICHFORMULA{For fixed $x$, $\lceil x/k \rceil$ is piecewise constant over contiguous ranges of $k$. On each range where $\lceil a_i/k \rceil = q$, the constraint reduces to $\lceil b_i/k \rceil \ge q$, which itself is a simple cap $k \le \left\lfloor \dfrac{b_i-1}{q-1}\right\rfloor$ for $q \ge 2$, and always true for $q=1$.}
\ASSUMPTIONS{We only need to consider bosses with $a_i > b_i$; for $a_i \le b_i$, the constraint is vacuous.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a difference array over $k \in [1,n]$ with zeros.
\item For each $i$ with $a_i > b_i$, iterate $k$ by segments where $q=\lceil a_i/k \rceil$ is constant:
  \begin{bullets}
  \item Let $q=\lceil a_i/k \rceil$. The segment is $k \in \big[\lceil a_i/q \rceil,\, \min\{n, \lfloor (a_i-1)/(q-1) \rfloor\}\big]$ for $q\ge 2$, and $k \in [a_i, n]$ for $q=1$.
  \item Intersect with $k \le \lfloor (b_i-1)/(q-1) \rfloor$ if $q \ge 2$.
  \item Add this intersection as a valid-$k$ interval to the difference array.
  \end{bullets}
\item After processing all such $i$, prefix-sum the difference array; $k$ is valid iff the coverage count equals the number of constrained bosses.
\end{algosteps}
\COMPLEXITY{Each $a_i$ yields $O(\sqrt{a_i})$ segments; total time $O\!\left(\sum a_i^{1/2}\right) \subseteq O(n\sqrt{n})$. Space $O(n)$ for the difference array.}
\[
\begin{aligned}
T(n) &\approx \sum_{i: a_i>b_i} O\big(\#\text{segments of }\lceil a_i/k \rceil\big) = O\!\left(\sum \sqrt{a_i}\right).
\end{aligned}
\]
\CORRECTNESS{On each segment where $\lceil a_i/k \rceil$ is constant, the constraint reduces to a single upper bound on $k$. Adding exactly those $k$ that satisfy both conditions and intersecting across bosses via counting ensures exactly the $k$ satisfying all constraints are selected.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, List[int], List[int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        cases.append((n, a, b))
    return t, cases

def solve_case_segment(n: int, a: List[int], b: List[int]) -> List[int]:
    # Count how many constraints (a_i > b_i) must be satisfied
    need = 0
    diff = [0] * (n + 3)
    for i in range(n):
        ai, bi = a[i], b[i]
        if ai <= bi:
            continue
        need += 1
        # Enumerate k by segments where ceil(ai/k) is constant
        k = 1
        while k <= n:
            q = (ai + k - 1) // k  # ceil(ai/k)
            if q <= 1:
                # For q == 1, valid for all k in [max(k, ai), n]
                if ai <= n and k <= n:
                    L = max(k, ai)
                    if L <= n:
                        diff[L] += 1
                        diff[n + 1] -= 1
                break
            # Segment end where ceil(ai/k) stays = q
            k_end = (ai - 1) // (q - 1)
            if k_end > n:
                k_end = n
            # For this q, need ceil(bi/k) >= q, i.e., k <= floor((bi-1)/(q-1))
            cap = (bi - 1) // (q - 1)
            R = k_end if k_end < cap else cap
            if k <= R:
                diff[k] += 1
                diff[R + 1] -= 1
            k = k_end + 1
    if need == 0:
        return list(range(1, n + 1))
    # Accumulate and collect k with full coverage
    ans = []
    cur = 0
    for k in range(1, n + 1):
        cur += diff[k]
        if cur == need:
            ans.append(k)
    return ans

def solve_all_segment(cases: List[Tuple[int, List[int], List[int]]]) -> List[List[int]]:
    return [solve_case_segment(n, a, b) for (n, a, b) in cases]

# --- tests (cross-check against brute for tiny inputs) ---
def _check_against_brutal():
    from random import Random
    rng = Random(0)
    for n in range(1, 8):
        for _ in range(200):
            a = [rng.randint(1, n) for _ in range(n)]
            b = [rng.randint(1, n) for _ in range(n)]
            brute = []
            for k in range(1, n + 1):
                ok = True
                for i in range(n):
                    if (a[i] + k - 1) // k > (b[i] + k - 1) // k:
                        ok = False
                        break
                if ok:
                    brute.append(k)
            fast = solve_case_segment(n, a, b)
            assert brute == fast, (n, a, b, brute, fast)

if __name__ == "__main__":
    _check_against_brutal()
\end{minted}
\VALIDATION{Cross-checks against a brute force on many random tiny cases; implicit coverage of $q=1$ tail intervals and disjoint segments.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Difference Array over Segmented $k$-Ranges}
\WHICHFORMULA{Use the equivalence Monocarp wins boss $i$ iff $\left\lceil \dfrac{a_i}{k} \right\rceil \le \left\lceil \dfrac{b_i}{k} \right\rceil$. For $a_i \le b_i$ the constraint is vacuous. For $a_i > b_i$, enumerate maximal ranges of $k$ where $\lceil a_i/k \rceil$ is constant and intersect them with the cap induced by $b_i$. Aggregate all such ranges via a difference array and select $k$ covered by all constraints.}
\ASSUMPTIONS{Arithmetic uses integer floors/ceils:
\[
\lceil x/y \rceil = \left\lfloor \frac{x + y - 1}{y} \right\rfloor,\quad
\text{for } q \ge 2:\; \{k : \lceil x/k \rceil = q\} = \left[ \left\lceil \frac{x}{q} \right\rceil,\, \left\lfloor \frac{x-1}{q-1} \right\rfloor \right].
\]
}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a difference array of length $n+2$ zeros and a counter $\mathit{need}=|\{i: a_i>b_i\}|$.
\item For each $i$ with $a_i>b_i$:
  \begin{bullets}
  \item Sweep $k$ by segments where $q=\lceil a_i/k \rceil$ is constant. The segment is $[L,R_a]$ with $L=\lceil a_i/q \rceil$, $R_a=\min\{n,\lfloor (a_i-1)/(q-1)\rfloor\}$ for $q\ge 2$, and $[a_i,n]$ for $q=1$.
  \item Intersect with $k \le R_b$, where $R_b=\lfloor (b_i-1)/(q-1)\rfloor$ for $q\ge 2$ (always true for $q=1$).
  \item If $L \le R=\min(R_a,R_b)$, add $[L,R]$ to the difference array.
  \end{bullets}
\item After processing all constrained bosses, prefix-sum the difference array; collect all $k$ with coverage exactly $\mathit{need}$. If $\mathit{need}=0$, all $k\in[1,n]$ are valid.
\end{algosteps}
\OPTIMALITY{Each $a_i$ induces $O(\sqrt{a_i})$ segments; this is worst-case tight due to the divisor-structure of floor/ceil functions. Aggregation via difference arrays is optimal up to constant factors for range unions.}
\COMPLEXITY{Time $O\!\left(\sum_{i:a_i>b_i} \sqrt{a_i}\right) \subseteq O(n\sqrt{n})$, space $O(n)$.}
\[
\begin{aligned}
T(n) &= \sum_{i:a_i>b_i} O(\#\text{segments of }\lceil a_i/k \rceil) = O\!\left(\sum \sqrt{a_i}\right).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts

def read_input() -> Tuple[int, List[Tuple[int, List[int], List[int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        cases.append((n, a, b))
    return t, cases

def solve_case(n: int, a: List[int], b: List[int]) -> List[int]:
    # Count constrained bosses (a_i > b_i)
    need = 0
    diff = [0] * (n + 3)
    for i in range(n):
        ai, bi = a[i], b[i]
        if ai <= bi:
            continue
        need += 1
        k = 1
        while k <= n:
            q = (ai + k - 1) // k  # ceil(ai/k)
            if q <= 1:
                # q == 1 -> all k >= ai are valid.
                if ai <= n and k <= n:
                    L = ai if ai > k else k
                    if L <= n:
                        diff[L] += 1
                        diff[n + 1] -= 1
                break
            # Max k with ceil(ai/k) == q
            k_end = (ai - 1) // (q - 1)
            if k_end > n:
                k_end = n
            # Need ceil(bi/k) >= q -> k <= floor((bi-1)/(q-1))
            cap = (bi - 1) // (q - 1)
            R = k_end if k_end < cap else cap
            if k <= R:
                diff[k] += 1
                diff[R + 1] -= 1
            k = k_end + 1
    if need == 0:
        return list(range(1, n + 1))
    ans = []
    cur = 0
    for k in range(1, n + 1):
        cur += diff[k]
        if cur == need:
            ans.append(k)
    return ans

def solve_all(cases: List[Tuple[int, List[int], List[int]]]) -> List[List[int]]:
    return [solve_case(n, a, b) for (n, a, b) in cases]

def main():
    if sys.stdin.isatty():
        return
    t, cases = read_input()
    outs = solve_all(cases)
    out_lines = []
    for ks in outs:
        out_lines.append(str(len(ks)))
        out_lines.append("" if not ks else " ".join(map(str, ks)))
    sys.stdout.write("\n".join(out_lines))

# --- asserts / mini-tests ---
def _simulate_all(n: int, a: List[int], b: List[int]) -> List[int]:
    ok = []
    for k in range(1, n + 1):
        good = True
        for i in range(n):
            if (a[i] + k - 1) // k > (b[i] + k - 1) // k:
                good = False
                break
        if good:
            ok.append(k)
    return ok

def _selfcheck():
    # Single boss trivial
    assert solve_case(1, [1], [1]) == [1]
    # Sample-like from the sheet
    assert solve_case(3, [1,3,3], [1,2,3]) == [3]
    # Random tiny deterministic
    from random import Random
    rng = Random(42)
    for n in range(1, 8):
        for _ in range(60):
            a = [rng.randint(1, n) for _ in range(n)]
            b = [rng.randint(1, n) for _ in range(n)]
            assert solve_case(n, a, b) == _simulate_all(n, a, b)

if __name__ == "__main__":
    _selfcheck()
    # main()
\end{minted}
\VALIDATION{Exactly 3 asserts or I/O mini-tests:
\begin{bullets}
\item Single boss trivial: $(n,a,b)=(1,[1],[1]) \Rightarrow [1]$.
\item Sample-like: $(n,a,b)=(3,[1,3,3],[1,2,3]) \Rightarrow [3]$.
\item Random tiny cross-checks against a simulator for $n \le 7$.
\end{bullets}}
\RESULT{Outputs all $k \in [1,n]$ in increasing order such that $\lceil a_i/k \rceil \le \lceil b_i/k \rceil$ holds for every $i$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Combine analytical tests (edge values), random tiny cross-checks against a brute simulator, and adversarial patterns $a_i>b_i$ with $a_i$ near $b_i$ to stress the segment enumeration.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Final on randomly generated small instances; ensure identical sets of $k$.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with:
\begin{bullets}
\item all $a_i \le b_i$ (expect all $k$),
\item many $a_i=b_i+1$ (tight segments),
\item $a_i=n$, $b_i=1$ (only large $k$ allowed from $a_i$),
\item alternating $a_i$ and $b_i$ values to create scattered valid $k$.
\end{bullets}}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
def gen_all_le(n: int) -> Tuple[List[int], List[int]]:
    a = [i % n + 1 for i in range(n)]
    b = [max(a[i], 1) for i in range(n)]
    return a, b

def gen_tight(n: int) -> Tuple[List[int], List[int]]:
    a = [min(n, (i % n) + 2) for i in range(n)]  # shift by +1
    b = [max(1, a[i] - 1) for i in range(n)]
    return a, b

def gen_extreme(n: int) -> Tuple[List[int], List[int]]:
    a = [n for _ in range(n)]
    b = [1 for _ in range(n)]
    return a, b
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, List[int], List[int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        cases.append((n, a, b))
    return t, cases

def solve_case(n: int, a: List[int], b: List[int]) -> List[int]:
    need = 0
    diff = [0] * (n + 3)
    for i in range(n):
        ai, bi = a[i], b[i]
        if ai <= bi:
            continue
        need += 1
        k = 1
        while k <= n:
            q = (ai + k - 1) // k  # ceil(ai/k)
            if q <= 1:
                if ai <= n and k <= n:
                    L = ai if ai > k else k
                    if L <= n:
                        diff[L] += 1
                        diff[n + 1] -= 1
                break
            k_end = (ai - 1) // (q - 1)
            if k_end > n:
                k_end = n
            cap = (bi - 1) // (q - 1)
            R = k_end if k_end < cap else cap
            if k <= R:
                diff[k] += 1
                diff[R + 1] -= 1
            k = k_end + 1
    if need == 0:
        return list(range(1, n + 1))
    ans = []
    cur = 0
    for k in range(1, n + 1):
        cur += diff[k]
        if cur == need:
            ans.append(k)
    return ans

def solve_all(cases: List[Tuple[int, List[int], List[int]]]) -> List[List[int]]:
    return [solve_case(n, a, b) for (n, a, b) in cases]

def main():
    if sys.stdin.isatty():
        return
    t, cases = read_input()
    outs = solve_all(cases)
    out_lines = []
    for ks in outs:
        out_lines.append(str(len(ks)))
        out_lines.append("" if not ks else " ".join(map(str, ks)))
    sys.stdout.write("\n".join(out_lines))

# --- asserts for confidence ---
def _asserts():
    assert solve_case(1, [1], [1]) == [1]
    assert solve_case(3, [1,3,3], [1,2,3]) == [3]
    # Cross-check tiny
    for n in range(1, 6):
        from random import Random
        R = Random(n)
        for _ in range(40):
            a = [R.randint(1, n) for _ in range(n)]
            b = [R.randint(1, n) for _ in range(n)]
            brute = []
            for k in range(1, n + 1):
                ok = True
                for i in range(n):
                    if (a[i] + k - 1) // k > (b[i] + k - 1) // k:
                        ok = False
                        break
                if ok:
                    brute.append(k)
            assert brute == solve_case(n, a, b)

if __name__ == "__main__":
    _asserts()
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find all $k \in [1,n]$ such that for all $i$, $\lceil a_i/k \rceil \le \lceil b_i/k \rceil$.}
\WHY{This tests the classical floor/ceil segmentation trick and interval aggregation, a staple for high-difficulty CF tasks.}
\CHECKLIST{
\begin{bullets}
\item Reduce to $\lceil a_i/k \rceil \le \lceil b_i/k \rceil$ via block indices.
\item Ignore bosses with $a_i \le b_i$.
\item For each remaining boss, segment $k$ by $\lceil a_i/k \rceil$.
\item Intersect with $\lceil b_i/k \rceil \ge q$ cap for each segment.
\item Add ranges to a difference array; final valid $k$ have full coverage.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item All $a_i \le b_i$ (answer is all $k$).
\item Some $a_i=n$, $b_i=1$ (only $k \ge a_i$ survive for that boss).
\item Repeated identical pairs $(a_i,b_i)$.
\item Mixed tight cases with $a_i=b_i+1$.
\item Large $n$ with many $a_i>b_i$ (performance).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Division by zero when handling $q=1$; treat separately.
\item Off-by-one on segment endpoints: $L=\lceil a/q \rceil$, $R=\lfloor (a-1)/(q-1)\rfloor$.
\item Forgetting to cap $R$ by $n$.
\item Forgetting to intersect with $k \le \lfloor (b-1)/(q-1)\rfloor$.
\item Not breaking after $q=1$ tail segment.
\item Using floating-point divisions (should be integer arithmetic).
\end{bullets}
}
\FAILMODES{A naive scan over all $k$ is $O(n^2)$ and will TLE. Enumerating all $q$ naively up to $a_i$ can also TLE; segmentation by $k$ is required.}
\ELI{Group $k$ into chunks where the number of blocks Monocarp needs is the same. On each chunk, ensure Polycarp does not need fewer blocks. Merge these allowed chunks across bosses and pick $k$ that satisfy all.}
\NotePages{3}

\end{document}