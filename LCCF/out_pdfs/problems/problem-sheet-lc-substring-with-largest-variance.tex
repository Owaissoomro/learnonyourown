% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Substring With Largest Variance}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/substring-with-largest-variance/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{The variance of a string is defined as the largest difference between the number of occurrences of any two characters present in the string. Note the two characters may or may not be the same (if they are the same, the difference contributes 0).

Given a string $s$ consisting of lowercase English letters only, return the largest variance possible among all substrings of $s$.

A substring is a contiguous sequence of characters within a string.

Example 1:

Input: $s = \text{"aababbb"}$

Output: $3$

Explanation: All possible variances along with their respective substrings are listed below:
\begin{bullets}
\item Variance $0$ for substrings ``a'', ``aa'', ``ab'', ``abab'', ``aababb'', ``ba'', ``b'', ``bb'', and ``bbb''.
\item Variance $1$ for substrings ``aab'', ``aba'', ``abb'', ``aabab'', ``ababb'', ``aababbb'', and ``bab''.
\item Variance $2$ for substrings ``aaba'', ``ababbb'', ``abbb'', and ``babb''.
\item Variance $3$ for substring ``babbb''.
\end{bullets}
Since the largest possible variance is $3$, we return it.

Example 2:

Input: $s = \text{"abcde"}$

Output: $0$

Explanation: No letter occurs more than once in $s$, so the variance of every substring is $0$.

Constraints:
\begin{bullets}
\item $1 \le \lvert s\rvert \le 10^4$.
\item $s$ consists of lowercase English letters.
\end{bullets}}
\BREAKDOWN{We must find the maximum, over all substrings, of the difference between counts of two present characters. This can be reframed as maximizing $c_x - c_y$ over ordered pairs $(x,y)$ of distinct letters with both present in the substring.}
\ELI{For each ordered pair of letters, scan the string to find a substring where one letter outnumbers the other by as much as possible, ensuring both appear.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single string $s$ of lowercase English letters with $1 \le \lvert s\rvert \le 10^4$.}
\OUTPUTS{An integer equal to the maximum variance among all substrings of $s$.}
\SAMPLES{Example 1: Input $s=\text{"aababbb"}$, Output $3$.

Example 2: Input $s=\text{"abcde"}$, Output $0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma=\{a,\ldots,z\}$ and $s=s_1s_2\cdots s_n$, $s_i\in\Sigma$. For indices $1\le i\le j\le n$, define the substring $t=s[i..j]$. For letter $x\in\Sigma$, let $c_x(t)$ be its frequency in $t$. Define the variance of $t$ as
\begin{BreakableEquation*}
\mathrm{Var}(t)=\max_{\substack{x,y\in\Sigma\\x\ne y\\c_x(t)>0,\,c_y(t)>0}}\bigl(c_x(t)-c_y(t)\bigr),
\end{BreakableEquation*}
and the answer is $\max_{1\le i\le j\le n}\mathrm{Var}(s[i..j])$.}
\varmapStart
\var{s}{input string of length $n$}
\var{t}{a substring $s[i..j]$}
\var{c_x(t)}{count of letter $x$ in substring $t$}
\var{\Sigma}{alphabet of 26 lowercase letters}
\var{(x,y)}{ordered pair of distinct letters}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\max_{1\le i\le j\le n}\ \max_{\substack{x,y\in\Sigma\\x\ne y\\c_x(s[i..j])>0,\,c_y(s[i..j])>0}}\ \sum_{k=i}^j \Bigl(\mathbf{1}\{s_k=x\}-\mathbf{1}\{s_k=y\}\Bigr).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Only lowercase English letters appear. We consider ordered pairs $(x,y)$, so absolute values are not needed. Requiring both characters to be present avoids trivial all-one-letter substrings.}
\INVARIANTS{
\begin{bullets}
\item For fixed $(x,y)$, the objective over substrings is a maximum subarray problem on weights $+1$ for $x$, $-1$ for $y$, and $0$ otherwise, with the constraint that at least one $y$ appears in the chosen subarray.
\item The global optimum is the maximum over the 26\,$\times$\,25 ordered pairs.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute all substring frequencies using prefix sums, then compute $\max_{x\ne y}(c_x-c_y)$ per substring.}
\ASSUMPTIONS{Precompute prefix counts for each of the $26$ letters to allow $O(26)$ substring frequency queries.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build prefix counts $P[\ell][i]$ for each letter $\ell\in\Sigma$ and position $i$.
\item For each substring $[i..j]$, compute $c_\ell=P[\ell][j]-P[\ell][i-1]$.
\item If at least two distinct letters occur, take $\max_{x\ne y}(c_x-c_y)$ and update the global maximum.
\end{algosteps}
\COMPLEXITY{With $n=\lvert s\rvert$, there are $O(n^2)$ substrings, each evaluated in $O(26)$ time. Space for prefix sums is $O(26n)$.}
\[
\begin{aligned}
T(n) &= O(26n) + \sum_{i=1}^n\sum_{j=i}^n O(26) = O(26n^2) = O(n^2), \\
S(n) &= O(26n) = O(n).
\end{aligned}
\]
\CORRECTNESS{Every substring is evaluated exactly once and its letter counts are accurate by prefix sums; the maximum over ordered pairs captures the required variance.}
\EDGECASES{Strings with all identical letters yield $0$. Substrings must contain at least two distinct letters to contribute a positive value.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
import string

class Solution:
    def largestVariance(self, s: str) -> int:
        n = len(s)
        # prefix counts: 26 x (n+1)
        pref = [[0] * (n + 1) for _ in range(26)]
        def idx(ch: str) -> int:
            return ord(ch) - 97
        for i, ch in enumerate(s, 1):
            k = idx(ch)
            for a in range(26):
                pref[a][i] = pref[a][i - 1]
            pref[k][i] += 1

        ans = 0
        for i in range(1, n + 1):
            for j in range(i, n + 1):
                # counts for substring s[i-1:j]
                cnt = [pref[a][j] - pref[a][i - 1] for a in range(26)]
                # Consider only letters present
                present = [c for c in cnt if c > 0]
                if len(present) < 2:
                    continue
                # max over ordered pairs x != y of c_x - c_y equals max(c_x) - min(c_y),
                # but we must ensure distinct letters: handle directly.
                local = 0
                for a in range(26):
                    if cnt[a] == 0:
                        continue
                    for b in range(26):
                        if a == b or cnt[b] == 0:
                            continue
                        local = max(local, cnt[a] - cnt[b])
                ans = max(ans, local)
        return ans

# Basic asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.largestVariance("aababbb") == 3
    assert sol.largestVariance("abcde") == 0
    assert sol.largestVariance("aaaa") == 0
    assert sol.largestVariance("baaa") == 2
    # Small custom
    assert sol.largestVariance("aabb") in (1, )  # "aab" -> 1 or "abb" -> 1
    print("Baseline tests passed.")
\end{minted}
\VALIDATION{Validated on given samples and a few small custom cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{For each ordered pair $(x,y)$, run a constrained Kadane scan over $s$ with weights $+1$ for $x$, $-1$ for $y$, and $0$ otherwise, requiring at least one $y$ in the chosen subarray.}
\ASSUMPTIONS{We precompute global frequencies to skip pairs where one letter never appears. We gate resets by the number of remaining $y$ characters to ensure feasibility of including a $y$ later.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count frequency of each letter in $s$.
\item For each ordered pair $(x,y)$ with both present:
\begin{bullets}
\item Initialize $\text{diff}=0$, $\text{has\_y}=\text{False}$, $\text{remain\_y}=\text{freq}[y]$.
\item Scan $s$: add $+1$ on $x$, add $-1$ on $y$ (and mark $\text{has\_y}$, decrement $\text{remain\_y}$).
\item If $\text{has\_y}$, update answer with $\text{diff}$.
\item If $\text{diff}<0$ and $\text{remain\_y}>0$, reset $\text{diff}=0$, $\text{has\_y}=\text{False}$.
\end{bullets}
\item The maximum over all $(x,y)$ is the result.
\end{algosteps}
\COMPLEXITY{For each of at most $26\cdot 25$ ordered pairs we perform a single $O(n)$ scan.}
\[
\begin{aligned}
T(n) &= O(26\cdot 25\cdot n) = O(n), \\
S(n) &= O(1) \text{ beyond input and frequency array.}
\end{aligned}
\]
\CORRECTNESS{The scan implements a Kadane-like maximum subarray restricted to subarrays containing at least one $y$. The reset rule with remaining $y$ guarantees we do not discard the only $y$ that could make the substring valid. Considering ordered pairs captures both directions of the difference.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import string
from collections import Counter

class Solution:
    def largestVariance(self, s: str) -> int:
        freq = Counter(s)
        letters = [chr(c) for c in range(ord('a'), ord('z') + 1)]
        best = 0
        for a in letters:
            if freq[a] == 0:
                continue
            for b in letters:
                if a == b or freq[b] == 0:
                    continue
                diff = 0
                has_b = False
                remain_b = freq[b]
                for ch in s:
                    if ch == a:
                        diff += 1
                    if ch == b:
                        diff -= 1
                        has_b = True
                        remain_b -= 1
                    if has_b:
                        if diff > best:
                            best = diff
                    # If diff is hurting us and there is a future b to include, reset.
                    if diff < 0 and remain_b > 0:
                        diff = 0
                        has_b = False
        return best

# Asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.largestVariance("aababbb") == 3
    assert sol.largestVariance("abcde") == 0
    assert sol.largestVariance("aaaa") == 0
    assert sol.largestVariance("baaa") == 2
    assert sol.largestVariance("aabb") == 1
    print("Improved tests passed.")
\end{minted}
\VALIDATION{Checks include symmetric cases and degenerate all-same-letter inputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Kadane over all ordered letter pairs with remaining-count gating is optimal: it reduces the problem to $26\cdot 25$ constrained maximum subarray computations.}
\ASSUMPTIONS{Alphabet is fixed at size $26$, and substrings must include both letters for a positive variance; ordered pairs handle directionality without absolute values.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute global frequencies of letters in $s$.
\item For each ordered pair $(x,y)$ with nonzero frequencies, run the gated Kadane scan as in Approach B.
\item Track the overall maximum.
\end{algosteps}
\OPTIMALITY{Any substring optimizing $\mathrm{Var}$ for some unordered pair $\{x,y\}$ also optimizes $c_x-c_y$ or $c_y-c_x$ for an ordered pair. The Kadane procedure yields the exact maximum of the linear form over contiguous segments subject to containing at least one $y$, enforced by the reset rule with remaining $y$. Summing over a constant factor of pairs yields a linear-time algorithm in $n$.}
\COMPLEXITY{With $L=26$:}
\[
\begin{aligned}
T(n) &= O(L(L-1)\cdot n)=O(n),\\
S(n) &= O(L)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from collections import Counter

class Solution:
    def largestVariance(self, s: str) -> int:
        freq = Counter(s)
        letters = [chr(c) for c in range(ord('a'), ord('z') + 1)]
        ans = 0
        for a in letters:
            if freq[a] == 0:
                continue
            for b in letters:
                if a == b or freq[b] == 0:
                    continue
                # Kadane-like scan requiring at least one b
                diff = 0
                has_b = False
                remain_b = freq[b]
                for ch in s:
                    if ch == a:
                        diff += 1
                    if ch == b:
                        diff -= 1
                        has_b = True
                        remain_b -= 1
                    if has_b and diff > ans:
                        ans = diff
                    # If diff is negative and there is a future b, we can restart later
                    if diff < 0 and remain_b > 0:
                        diff = 0
                        has_b = False
        return ans

# Exactly 3 asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.largestVariance("aababbb") == 3
    assert sol.largestVariance("abcde") == 0
    assert sol.largestVariance("baaa") == 2
    print("Final submission tests passed.")
\end{minted}
\VALIDATION{Three asserts: the two provided samples and one asymmetric case where the best substring starts with the minority letter.}
\RESULT{Return the single integer maximum variance. No tie-breaking is needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on samples; property tests comparing the optimal algorithm with the baseline brute force for random small strings; adversarial patterns like alternating letters and runs.}
\LINE{CROSS-CHECKS}{Compare outputs of the baseline $O(n^2)$ method and the optimal $O(n)$-per-pair method on randomly generated strings over small alphabets.}
\LINE{EDGE-CASE GENERATOR}{Generate strings with single character, two characters with unbalanced counts, fully balanced alternating patterns, and runs with a single outlier.}
\begin{minted}{python}
import random
from collections import Counter

class Baseline:
    def largestVariance(self, s: str) -> int:
        n = len(s)
        pref = [[0] * (n + 1) for _ in range(26)]
        def idx(ch: str) -> int:
            return ord(ch) - 97
        for i, ch in enumerate(s, 1):
            for a in range(26):
                pref[a][i] = pref[a][i - 1]
            pref[idx(s[i-1])][i] += 1
        best = 0
        for i in range(1, n + 1):
            for j in range(i, n + 1):
                cnt = [pref[a][j] - pref[a][i - 1] for a in range(26)]
                # Need both letters present
                for a in range(26):
                    if cnt[a] == 0:
                        continue
                    for b in range(26):
                        if a == b or cnt[b] == 0:
                            continue
                        best = max(best, cnt[a] - cnt[b])
        return best

class Optimal:
    def largestVariance(self, s: str) -> int:
        freq = Counter(s)
        letters = [chr(c) for c in range(ord('a'), ord('z') + 1)]
        ans = 0
        for a in letters:
            if freq[a] == 0:
                continue
            for b in letters:
                if a == b or freq[b] == 0:
                    continue
                diff = 0
                has_b = False
                remain_b = freq[b]
                for ch in s:
                    if ch == a:
                        diff += 1
                    if ch == b:
                        diff -= 1
                        has_b = True
                        remain_b -= 1
                    if has_b and diff > ans:
                        ans = diff
                    if diff < 0 and remain_b > 0:
                        diff = 0
                        has_b = False
        return ans

def gen_cases():
    cases = []
    # Edge cases
    cases += ["a", "aaaa", "ab", "ba", "aab", "bba", "ababab", "aababbb", "abcde"]
    # Random small over 'abc'
    random.seed(123)
    for n in range(1, 9):
        for _ in range(20):
            s = "".join(random.choice("abc") for _ in range(n))
            cases.append(s)
    return cases

if __name__ == "__main__":
    base = Baseline()
    opt = Optimal()
    for s in gen_cases():
        b = base.largestVariance(s)
        o = opt.largestVariance(s)
        assert b == o, (s, b, o)
    print("Cross-checks passed on generated cases.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from collections import Counter

class Solution:
    def largestVariance(self, s: str) -> int:
        freq = Counter(s)
        letters = [chr(c) for c in range(ord('a'), ord('z') + 1)]
        ans = 0
        for a in letters:
            if freq[a] == 0:
                continue
            for b in letters:
                if a == b or freq[b] == 0:
                    continue
                diff = 0
                has_b = False
                remain_b = freq[b]
                for ch in s:
                    if ch == a:
                        diff += 1
                    if ch == b:
                        diff -= 1
                        has_b = True
                        remain_b -= 1
                    if has_b and diff > ans:
                        ans = diff
                    if diff < 0 and remain_b > 0:
                        diff = 0
                        has_b = False
        return ans

if __name__ == "__main__":
    sol = Solution()
    # Smoke tests
    assert sol.largestVariance("aababbb") == 3
    assert sol.largestVariance("abcde") == 0
    assert sol.largestVariance("baaa") == 2
    print("Reference solution tests passed.")
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the difference in counts of two distinct letters over all substrings, ensuring both letters appear.}
\WHY{Tests ability to reduce to Kadane with constraints and to reason over ordered letter pairs efficiently.}
\CHECKLIST{
\begin{bullets}
\item Reframe as ordered pairs $(x,y)$ and maximize $c_x-c_y$.
\item Precompute letter frequencies to skip impossible pairs.
\item Run gated Kadane per pair; update only after seeing at least one $y$.
\item Reset only when $\text{diff}<0$ and a future $y$ remains.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All characters identical $\Rightarrow 0$.
\item String length $1$.
\item Two-letter strings like ``ab'' and ``ba''.
\item Highly unbalanced counts, e.g., ``aaaaab''.
\item Alternating patterns ``ababab''.
\item Long runs with a single outlier, e.g., ``bbbbba''.
\item Letters missing for a pair: skip quickly.
\item Result can be $0$ even for long strings with dispersed letters.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to require presence of both letters in the substring.
\item Using absolute difference without ordered-pair handling.
\item Resetting the Kadane state even when no future $y$ remains.
\item Not iterating ordered pairs; missing the reverse direction.
\item Off-by-one in prefix sums for baseline.
\item Counting updates before ensuring at least one $y$.
\item Mishandling ties or empty substrings (disallow empty).
\item Assuming negative best for a pair; overall max is nonnegative.
\end{bullets}}
\FAILMODES{Naive Kadane without the ``at least one $y$'' constraint overcounts substrings lacking $y$. One-direction-only scans without the remaining-$y$ guard can miss cases where the only $y$ is at the tail. The improved method survives by enforcing feasibility through the remaining-count rule and checking both orderings.}
\ELI{Turn the problem into many small two-letter games: for each ordered pair, walk the string, gaining a point on $x$ and losing a point on $y$, but only score when you have seen at least one $y$. If your score goes negative and there is another $y$ ahead, reset and try again. Take the best over all pairs.}
\NotePages{3}

\end{document}