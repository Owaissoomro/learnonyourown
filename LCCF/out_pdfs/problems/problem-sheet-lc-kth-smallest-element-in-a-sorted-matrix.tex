% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Kth Smallest Element in a Sorted Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given an $n \times n$ matrix where each of the rows and columns is sorted in ascending order, return the $k$th smallest element in the matrix. Note that it is the $k$th smallest element in the sorted order, not the $k$th distinct element. You must find a solution with a memory complexity better than $O(n^2)$. 

\textbf{Example 1:} Input: matrix $=$ [[1,5,9],[10,11,13],[12,13,15]], $k=8$. Output: 13. Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13.

\textbf{Example 2:} Input: matrix $=$ [[-5]], $k=1$. Output: -5.

\textbf{Constraints:}
\begin{bullets}
\item $n == \text{matrix.length} == \text{matrix[i].length}$.
\item $1 \le n \le 300$.
\item $-10^9 \le \text{matrix}[i][j] \le 10^9$.
\item All rows and columns are guaranteed to be sorted in non-decreasing order.
\item $1 \le k \le n^2$.
\end{bullets}

\textbf{Follow up:}
\begin{bullets}
\item Could you solve the problem with constant memory, i.e., $O(1)$ space?
\item Could you solve the problem in $O(n)$ time? See \url{http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf}.
\end{bullets}
}
\BREAKDOWN{Reduce to finding the $k$th order statistic under the special structure that rows and columns are sorted. Use either a heap to merge $n$ sorted lists or binary search on value space with a monotone counting function. Ensure space usage is better than $O(n^2)$.}
\ELI{Count how many entries are $\le$ a guess and binary-search the value that has at least $k$ entries below it.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{matrix: list of $n$ lists of length $n$ of integers; each row and column non-decreasing. $1 \le n \le 300$. Values in $[-10^9,10^9]$. Integer $k$ with $1 \le k \le n^2$.}
\OUTPUTS{Return the integer that is the $k$th smallest element when all $n^2$ elements are considered with multiplicity.}
\SAMPLES{Example 1: matrix $=$ [[1,5,9],[10,11,13],[12,13,15]], $k=8$ $\rightarrow$ 13. Example 2: matrix $=$ [[-5]], $k=1$ $\rightarrow$ -5.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in \mathbb{Z}^{n \times n}$ with $A_{i,1} \le \cdots \le A_{i,n}$ and $A_{1,j} \le \cdots \le A_{n,j}$ for all $i,j$. Define the multiset $S = \{A_{i,j} : 1 \le i,j \le n\}$ with multiplicity. We seek the $k$th order statistic of $S$. Equivalently, find the minimum $x$ such that at least $k$ elements of $A$ are $\le x$.}
\varmapStart
\var{n}{matrix dimension}
\var{k}{desired rank in $S$}
\var{A_{i,j}}{matrix entry at row $i$, column $j$}
\var{c(x)}{count of elements in $A$ that are $\le x$}
\varmapEnd
\GOVERN{
\[
  \text{Answer} = \min\{x \in \mathbb{Z} : c(x) \ge k\}, \quad
  c(x) = \sum_{j=1}^{n} \max\{i \in \{0,\ldots,n\} : A_{i,j} \le x\}.
\]
}
\ASSUMPTIONS{Indices are 0-based or 1-based consistently; rows and columns are sorted non-decreasing; $k$ is feasible since $1 \le k \le n^2$.}
\INVARIANTS{
\begin{bullets}
\item Monotonicity: If $x \le y$, then $c(x) \le c(y)$.
\item Bounding: $\min A \le \text{Answer} \le \max A$.
\item Staircase scan counts each column at most once per row transition, giving $O(n)$ time for $c(x)$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Flatten all $n^2$ elements and sort; the $k$th smallest is at index $k-1$.}
\ASSUMPTIONS{Sufficient memory to hold $n^2$ values; acceptable for understanding but violates the stated memory better-than-$O(n^2)$ requirement.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Flatten the matrix into a single list of length $n^2$.
\item Sort the list in non-decreasing order.
\item Return the element at position $k-1$.
\end{algosteps}
\COMPLEXITY{Sorting $n^2$ items costs $O(n^2 \log(n^2)) = O(n^2 \log n)$ time and $O(n^2)$ extra space.}
\[
\begin{aligned}
T(n) &= \Theta(n^2 \log(n^2)) = \Theta(n^2 \log n), \\
S(n) &= \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{Sorting imposes a total order on all elements with multiplicity; selecting index $k-1$ yields the $k$th smallest by definition.}
\EDGECASES{Single element $n=1$; all equal elements; negative values; $k=1$ and $k=n^2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        # Flatten and sort
        flat = [x for row in matrix for x in row]
        flat.sort()
        return flat[k - 1]

# Baseline sanity checks
s = Solution()
assert s.kthSmallest([[1,5,9],[10,11,13],[12,13,15]], 8) == 13
assert s.kthSmallest([[-5]], 1) == -5
assert s.kthSmallest([[1,2],[3,4]], 3) == 3
\end{minted}
\VALIDATION{The asserts above cover: sample 1, sample 2, and a small $2 \times 2$ with $k=3$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Treat each row as a sorted list and perform a $k$-step multiway merge using a min-heap of size at most $n$.}
\ASSUMPTIONS{Rows are individually sorted; pushing the next element from a row after popping its current head preserves correctness.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a min-heap with the first element of each row as tuples $(\text{value}, \text{row}, \text{col})$.
\item Repeat $k-1$ times: pop the smallest tuple; if there is a next column in that row, push it.
\item The top of the heap is now the $k$th smallest; return its value.
\end{algosteps}
\COMPLEXITY{Each pop and optional push costs $O(\log n)$; after $k$ iterations, overall time is $O(k \log n)$ and space $O(n)$.}
\[
\begin{aligned}
T(n) &\le O(k \log n), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Invariant: the heap always contains the smallest unseen candidates across rows. Extracting the minimum $k-1$ times advances the global order correctly.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        h: List[Tuple[int,int,int]] = []
        for r in range(n):
            if matrix[r]:
                heapq.heappush(h, (matrix[r][0], r, 0))
        # Pop k-1 times
        for _ in range(k - 1):
            val, r, c = heapq.heappop(h)
            if c + 1 < n:
                heapq.heappush(h, (matrix[r][c + 1], r, c + 1))
        return heapq.heappop(h)[0]

# Improved approach checks
s = Solution()
assert s.kthSmallest([[1,5,9],[10,11,13],[12,13,15]], 8) == 13
assert s.kthSmallest([[-5]], 1) == -5
assert s.kthSmallest([[1,2],[3,4]], 3) == 3
\end{minted}
\VALIDATION{Covers samples and a $2 \times 2$ matrix; also implicitly validates heap progress with duplicates.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Binary search on the value domain $[\min A, \max A]$; use a staircase scan to count $c(x)$, the number of entries $\le x$, in $O(n)$ time.}
\ASSUMPTIONS{Rows and columns are non-decreasing; thus $c(x)$ is monotone in $x$, enabling binary search.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set $\ell = A_{1,1}$ and $r = A_{n,n}$.
\item While $\ell < r$: let $m = \lfloor(\ell + r)/2\rfloor$; compute $c(m)$ by scanning from bottom-left, moving up if value $> m$ and right otherwise.
\item If $c(m) \ge k$, set $r = m$; else set $\ell = m + 1$. Return $\ell$.
\end{algosteps}
\OPTIMALITY{Each count takes $O(n)$ time and binary search needs $O(\log(\max A - \min A))$ steps; space is $O(1)$. This meets the follow-up goal of constant extra memory and typically outperforms heap when $k$ is large.}
\COMPLEXITY{Time $O\!\left(n \log(\text{range})\right)$, space $O(1)$.}
\[
\begin{aligned}
T(n) &= O\!\big(n \cdot \log(\max A - \min A + 1)\big), \\
S(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        def count_le(x: int) -> int:
            # Count elements <= x using a staircase from bottom-left
            i, j, cnt = n - 1, 0, 0
            while i >= 0 and j < n:
                if matrix[i][j] <= x:
                    cnt += i + 1
                    j += 1
                else:
                    i -= 1
            return cnt

        lo, hi = matrix[0][0], matrix[-1][-1]
        while lo < hi:
            mid = (lo + hi) // 2
            if count_le(mid) >= k:
                hi = mid
            else:
                lo = mid + 1
        return lo

# Exactly 3 validation asserts
s = Solution()
assert s.kthSmallest([[1,5,9],[10,11,13],[12,13,15]], 8) == 13
assert s.kthSmallest([[-5]], 1) == -5
assert s.kthSmallest([[1,2],[3,4]], 3) == 3
\end{minted}
\VALIDATION{Three asserts: both samples and a $2 \times 2$ case where the answer is not on the diagonal.}
\RESULT{Returns the integer $x$ such that exactly $k-1$ elements are $< x$ and at least one element is $= x$ (with multiplicity), i.e., the $k$th element of the multiset in sorted order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on boundary sizes ($n=1$, $k=1$, $k=n^2$), duplicates-heavy matrices, strictly increasing matrices, and mixed negatives/positives. Cross-validate against a trusted baseline on many tiny cases.}
\LINE{CROSS-CHECKS}{For small $n \le 4$, compare the optimal method with the baseline sorter for all $k \in [1,n^2]$.}
\LINE{EDGE-CASE GENERATOR}{Generate monotone matrices deterministically (no randomness) by using $A_{i,j} = base + \alpha i + \beta j$ and optionally clamping duplicates.}
\begin{minted}{python}
from typing import List, Tuple

def gen_matrix(n: int, base: int = -3, a: int = 2, b: int = 3) -> List[List[int]]:
    # Deterministic generator of an n x n non-decreasing matrix
    return [[base + a * i + b * j for j in range(n)] for i in range(n)]

def baseline_kth(matrix: List[List[int]], k: int) -> int:
    flat = [x for row in matrix for x in row]
    flat.sort()
    return flat[k - 1]

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        def count_le(x: int) -> int:
            i, j, cnt = n - 1, 0, 0
            while i >= 0 and j < n:
                if matrix[i][j] <= x:
                    cnt += i + 1
                    j += 1
                else:
                    i -= 1
            return cnt
        lo, hi = matrix[0][0], matrix[-1][-1]
        while lo < hi:
            mid = (lo + hi) // 2
            if count_le(mid) >= k:
                hi = mid
            else:
                lo = mid + 1
        return lo

# Cross-checks on small sizes
for n in range(1, 5):
    M = gen_matrix(n)
    for k in range(1, n*n + 1):
        assert Solution().kthSmallest(M, k) == baseline_kth(M, k)

# Duplicates-heavy matrix
Mdup = [
    [1, 2, 2, 3],
    [2, 2, 3, 3],
    [2, 3, 3, 4],
    [3, 3, 4, 5],
]
for k in range(1, 16+1):
    assert Solution().kthSmallest(Mdup, k) == baseline_kth(Mdup, k)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        def count_le(x: int) -> int:
            # Count elements <= x in O(n) using the sorted structure
            i, j, cnt = n - 1, 0, 0
            while i >= 0 and j < n:
                if matrix[i][j] <= x:
                    cnt += i + 1
                    j += 1
                else:
                    i -= 1
            return cnt

        lo, hi = matrix[0][0], matrix[-1][-1]
        while lo < hi:
            mid = (lo + hi) // 2
            if count_le(mid) >= k:
                hi = mid
            else:
                lo = mid + 1
        return lo

# Final quick checks
s = Solution()
assert s.kthSmallest([[1,5,9],[10,11,13],[12,13,15]], 8) == 13
assert s.kthSmallest([[-5]], 1) == -5
assert s.kthSmallest([[1,2],[3,4]], 4) == 4
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the $k$th smallest in a matrix with rows and columns sorted.}
\WHY{Common interview test of leveraging structure: either heap-merge $n$ sorted lists or binary-search the answer using a monotone count.}
\CHECKLIST{
\begin{bullets}
\item Confirm rows and columns are sorted non-decreasing.
\item Choose method: heap if $k$ is small; value binary search otherwise.
\item Implement staircase count correctly from bottom-left or top-right.
\item Handle duplicates; ensure count uses $\le$ not $<$.
\item Verify bounds: initialize $\ell=\min A$, $r=\max A$.
\item Careful with $k$ off-by-one: return index $k-1$ in flat sort; stop after $k-1$ pops in heap.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$, arbitrary value.
\item All entries identical.
\item Negative and positive mix.
\item $k=1$ and $k=n^2$.
\item Highly skewed ranges (large gaps).
\item Many duplicates concentrated in a corner.
\item Non-square inputs are out of scope but ensure code assumes $n \times n$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one in heap pops or in selecting $k-1$ index.
\item Using $<$ instead of $\le$ in counting, shifting answer upward.
\item Counting scan starting at wrong corner without consistent moves can double-count or miss elements.
\item Binary search termination with $\ell \le r$ loop and mid update causing infinite loop; prefer $\ell < r$.
\item Pushing all $n^2$ elements into heap defeats space constraint.
\item Assuming strict increase; duplicates break naive row/column skipping.
\end{bullets}
}
\FAILMODES{Flatten-and-sort exceeds the memory goal; naive per-row binary searches per value without staircase can cost $O(n \log n)$ per check and still be fine but more complex. The value-BS plus staircase survives duplicates and extremes.}
\ELI{Because the matrix grows to the right and down, for any guess $x$ you can quickly count how many values are at most $x$ by walking a single path. Searching the smallest $x$ with at least $k$ elements beneath it gives the answer with tiny extra memory.}
\NotePages{3}

\end{document}