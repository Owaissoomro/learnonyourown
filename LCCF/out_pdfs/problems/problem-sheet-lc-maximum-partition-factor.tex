% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximum Partition Factor}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximum-partition-factor/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a 2D integer array \texttt{points}, where \texttt{points[i] = [x\_i, y\_i]} represents the coordinates of the $i$th point on the Cartesian plane. The Manhattan distance between two points $[x_i, y_i]$ and $[x_j, y_j]$ is $\lvert x_i - x_j\rvert + \lvert y_i - y_j\rvert$.

Split the $n$ points into exactly two non-empty groups. The partition factor of a split is the minimum Manhattan distance among all unordered pairs of points that lie in the same group. Return the maximum possible partition factor over all valid splits.

Note: A group of size $1$ contributes no intra-group pairs. When $n = 2$ (both groups size $1$), there are no intra-group pairs, so define the partition factor as $0$.

Example 1:

Input: \texttt{points = [[0,0],[0,2],[2,0],[2,2]]}

Output: \texttt{4}

Explanation: We split the points into two groups: $\{\,[0, 0], [2, 2]\,\}$ and $\{\,[0, 2], [2, 0]\,\}$. In each group, the only pair has Manhattan distance $4$. The partition factor is $\min(4, 4) = 4$, which is maximal.

Example 2:

Input: \texttt{points = [[0,0],[0,1],[10,0]]}

Output: \texttt{11}

Explanation: We split the points into two groups: $\{\,[0, 1], [10, 0]\,\}$ and $\{\,[0, 0]\,\}$. The first group has only one pair at distance $11$; the second group is a singleton. The partition factor of this split is $11$, which is maximal.

Constraints:
\begin{bullets}
\item $2 \le \texttt{points.length} \le 500$,
\item $\texttt{points[i]} = [x_i, y_i]$,
\item $-10^8 \le x_i, y_i \le 10^8$.
\end{bullets}}
\BREAKDOWN{We want to maximize the minimum intra-group Manhattan distance over a 2-partition. For any threshold $D$, forbid any same-group pair with distance $< D$. This induces a graph where edges represent forbidden pairs. The split is feasible if and only if this graph is bipartite. Thus we can binary search the largest $D$ such that the forbidden-edge graph is bipartite, with a special-case definition when $n=2$.}
\ELI{Make a graph connecting pairs that are too close; if you can 2-color that graph, you can split the points so every same-group pair is far enough. Push the threshold up as far as bipartiteness allows.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{points} of length $n$ with entries \texttt{[x\_i, y\_i]} where $-10^8 \le x_i, y_i \le 10^8$.}
\OUTPUTS{An integer: the maximum partition factor as defined. For $n=2$, return $0$.}
\SAMPLES{
Example A: \texttt{points = [[0,0],[0,2],[2,0],[2,2]]} $\to$ \texttt{4}.

Example B: \texttt{points = [[0,0],[0,1],[10,0]]} $\to$ \texttt{11}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $P=\{p_1,\ldots,p_n\}$ with $p_i=(x_i,y_i)$. For threshold $D\in\mathbb{Z}_{\ge 0}$, define the forbidden graph $G_D=(V,E_D)$ with $V=[n]$ and
\begin{BreakableEquation*}
E_D=\bigl\{\{i,j\}\subseteq V:\ \lvert x_i-x_j\rvert+\lvert y_i-y_j\rvert < D\bigr\}.
\end{BreakableEquation*}
A split into two groups corresponds to a $2$-coloring of $V$. The split is valid at level $D$ iff no forbidden edge is monochromatic, i.e., $G_D$ is bipartite. We seek $\max D$ such that $G_D$ is bipartite, with the convention that when $n=2$ the answer is $0$.}
\varmapStart
\var{n}{number of points}
\var{d(i,j)}{Manhattan distance between $p_i$ and $p_j$}
\var{G_D}{graph on $[n]$ with edges for pairs with $d(i,j)<D$}
\var{D^\star}{maximum feasible threshold}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Feasible}(D)\iff G_D\text{ is bipartite},\qquad D^\star=\max\{D\in\mathbb{Z}_{\ge 0}: G_D\ \text{is bipartite}\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Coordinates are integers; distances are integers. For $n\ge 3$, $G_{M+1}$ with $M=\max_{i<j}d(i,j)$ is $K_n$ and thus non-bipartite, ensuring a finite upper bound. For $n=2$, define the answer as $0$.}
\INVARIANTS{
\begin{bullets}
\item Monotonicity: If $G_D$ is bipartite, then $G_{D'}$ is bipartite for all $0\le D'\le D$ (edge set shrinks as $D$ decreases).
\item Any $2$-coloring of $G_D$ produces two groups whose intra-group distances are all $\ge D$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate every non-trivial bipartition of $[n]$ and compute its partition factor (minimum intra-group distance over both groups). Take the maximum.}
\ASSUMPTIONS{Viable only for very small $n$ due to $O(2^n)$ partitions. Useful for validation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute all pairwise Manhattan distances $d(i,j)$.
\item For each non-empty proper subset $S\subset [n]$, form groups $S$ and $\overline{S}$.
\item For each group, compute its minimum pair distance (or $+\infty$ if size $<2$). The split score is the minimum of the two group minima. Track the maximum over all splits.
\end{algosteps}
\COMPLEXITY{Let $m=\binom{n}{2}$. Precompute distances in $O(m)$. There are $2^{n-1}-1$ unique unordered splits; each needs scanning pairs inside both groups in $O(m)$ worst-case.}
\[
\begin{aligned}
T(n) &\in \Theta\bigl(2^n\cdot n^2\bigr),\quad S(n)\in \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{By definition, we inspect every valid split and compute its partition factor exactly, thus the maximum found is correct.}
\EDGECASES{Handle $n=2$ by returning $0$. Duplicated points lead to $0$ if at least one group must contain two identical points.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution_Brute:
    def maximumPartitionFactor(self, points: List[List[int]]) -> int:
        n = len(points)
        if n == 2:
            return 0
        # Precompute pairwise Manhattan distances
        dist = [[0]*n for _ in range(n)]
        for i in range(n):
            xi, yi = points[i]
            for j in range(i+1, n):
                xj, yj = points[j]
                d = abs(xi - xj) + abs(yi - yj)
                dist[i][j] = dist[j][i] = d

        # Enumerate all non-empty proper subsets; avoid double counting by forcing bit 0 in S
        best = 0
        fullmask = (1 << n) - 1
        for mask in range(1, 1 << n):
            if not (mask & 1):  # impose canonicalization: group containing index 0
                continue
            if mask == fullmask:
                continue
            # group A: mask; group B: complement
            def group_min(mask_val: int) -> int:
                # return +inf if group size < 2
                if mask_val == 0 or mask_val & (mask_val - 1) == 0:
                    return 10**30
                mn = 10**30
                # iterate pairs in group
                idxs = [i for i in range(n) if (mask_val >> i) & 1]
                L = len(idxs)
                for a in range(L):
                    ia = idxs[a]
                    for b in range(a+1, L):
                        ib = idxs[b]
                        if dist[ia][ib] < mn:
                            mn = dist[ia][ib]
                            if mn == 0:
                                return 0
                return mn

            a_min = group_min(mask)
            b_min = group_min(fullmask ^ mask)
            score = a_min if a_min < b_min else b_min
            if score > best:
                best = score
        return best

# Tiny sanity checks for brute force
def _bf():
    S = Solution_Brute()
    assert S.maximumPartitionFactor([[0,0],[0,2],[2,0],[2,2]]) == 4
    assert S.maximumPartitionFactor([[0,0],[0,1],[10,0]]) == 11
    assert S.maximumPartitionFactor([[0,0],[0,0]]) == 0

_bf()
\end{minted}
\VALIDATION{Verified on the two examples and a duplicate-points edge case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search on Threshold + Bipartite Check}
\WHICHFORMULA{For a threshold $D$, forbid pairs with distance $< D$ by adding edges to $G_D$; feasibility reduces to testing if $G_D$ is bipartite. Monotonicity over $D$ enables binary search.}
\ASSUMPTIONS{Graph bipartiteness via BFS/DFS in $O(n^2)$ per check since $n\le 500$; distances computed on the fly.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n=2$, return $0$.
\item Let $M=\max_{i<j} d(i,j)$. Binary search $D\in[0, M+1]$, maintaining feasibility at the low end.
\item For a candidate $D$, build implicit edges for pairs with $d(i,j)<D$ and test bipartiteness via BFS coloring.
\item Return the maximum feasible $D$.
\end{algosteps}
\COMPLEXITY{Each feasibility check scans all $\binom{n}{2}$ pairs; binary search takes $O(\log M)$ iterations.}
\[
\begin{aligned}
T(n) &\in O\bigl(n^2\log M\bigr),\quad S(n)\in O(n).
\end{aligned}
\]
\CORRECTNESS{If $G_D$ is bipartite, its two color classes are independent sets at level $D$, so every intra-group pair has distance $\ge D$. The monotone edge-addition as $D$ increases implies a single threshold for infeasibility, so binary search locates the maximal feasible $D$. The $n=2$ convention is handled explicitly.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Deque
from collections import deque

class Solution_Improved:
    def maximumPartitionFactor(self, points: List[List[int]]) -> int:
        n = len(points)
        if n == 2:
            return 0

        def man(i: int, j: int) -> int:
            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])

        # Determine max distance to bound search
        M = 0
        for i in range(n):
            for j in range(i+1, n):
                d = man(i, j)
                if d > M:
                    M = d

        def feasible(D: int) -> bool:
            # Check if G_D is bipartite (edges on pairs with dist < D)
            color = [-1] * n
            for s in range(n):
                if color[s] != -1:
                    continue
                color[s] = 0
                q: Deque[int] = deque([s])
                while q:
                    u = q.popleft()
                    cu = color[u]
                    for v in range(n):
                        if v == u:
                            continue
                        if man(u, v) < D:
                            if color[v] == -1:
                                color[v] = cu ^ 1
                                q.append(v)
                            elif color[v] == cu:
                                return False
            return True

        lo, hi = 0, M + 1  # invariant: feasible(lo)=True, feasible(hi)=False (for n>=3)
        # Ensure the invariant hi is infeasible for n>=3 (K_n is not bipartite).
        # For completeness, if by any chance feasible(hi) is True (only when n<=2), we still handle n=2 earlier.
        while lo + 1 < hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                lo = mid
            else:
                hi = mid
        return lo

# Sanity checks
def _imp():
    S = Solution_Improved()
    assert S.maximumPartitionFactor([[0,0],[0,2],[2,0],[2,2]]) == 4
    assert S.maximumPartitionFactor([[0,0],[0,1],[10,0]]) == 11
    assert S.maximumPartitionFactor([[0,0],[0,0]]) == 0

_imp()
\end{minted}
\VALIDATION{Checked on examples and duplicate-points case. The feasibility function is stress-free at $n\le 500$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Binary Search over Precomputed Distances + Bipartite Coloring}
\WHICHFORMULA{Precompute all pairwise distances once, reuse them in feasibility checks. Optionally binary search over integer $D\in[0,M+1]$, or over sorted unique distances with equivalent complexity.}
\ASSUMPTIONS{Distances are integers. For $n\ge 3$, $G_{M+1}$ is $K_n$ and non-bipartite.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n=2$, return $0$.
\item Precompute the $n\times n$ matrix $d(i,j)$ and $M=\max_{i<j}d(i,j)$.
\item Binary search integer $D\in[0,M+1]$.
\item For each $D$, test $G_D$ bipartiteness using BFS with adjacency defined by $d(i,j)<D$.
\item Return the largest feasible $D$.
\end{algosteps}
\OPTIMALITY{Each feasibility check is $O(n^2)$ in the worst case and uses no extra heavy data structures. With $n\le 500$, this meets tight practical limits while being conceptually minimal. Any exact method must, in general, inspect enough pairwise relations to prevent forbidden pairs, giving an $\Omega(n^2)$ information-theoretic lower bound in dense regimes.}
\COMPLEXITY{Precompute distances in $O(n^2)$. Binary search uses $O(\log M)$ checks; each check is $O(n^2)$.}
\[
\begin{aligned}
T(n) &\in O\bigl(n^2 + n^2\log M\bigr)=O\bigl(n^2\log M\bigr),\quad S(n)\in O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Deque
from collections import deque

class Solution:
    def maximumPartitionFactor(self, points: List[List[int]]) -> int:
        n = len(points)
        if n == 2:
            return 0

        # Precompute distance matrix and maximum distance
        dist = [[0]*n for _ in range(n)]
        M = 0
        for i in range(n):
            xi, yi = points[i]
            for j in range(i+1, n):
                xj, yj = points[j]
                d = abs(xi - xj) + abs(yi - yj)
                dist[i][j] = dist[j][i] = d
                if d > M:
                    M = d

        def feasible(D: int) -> bool:
            # Check if the graph with edges for dist < D is bipartite
            color = [-1] * n
            for s in range(n):
                if color[s] != -1:
                    continue
                color[s] = 0
                q: Deque[int] = deque([s])
                while q:
                    u = q.popleft()
                    cu = color[u]
                    row = dist[u]
                    for v in range(n):
                        if v == u:
                            continue
                        if row[v] < D:
                            if color[v] == -1:
                                color[v] = cu ^ 1
                                q.append(v)
                            elif color[v] == cu:
                                return False
            return True

        lo, hi = 0, M + 1
        # Binary search for maximum feasible D
        while lo + 1 < hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                lo = mid
            else:
                hi = mid
        return lo

# Exactly 3 asserts (examples and a custom edge case)
if __name__ == "__main__":
    sol = Solution()
    assert sol.maximumPartitionFactor([[0,0],[0,2],[2,0],[2,2]]) == 4
    assert sol.maximumPartitionFactor([[0,0],[0,1],[10,0]]) == 11
    assert sol.maximumPartitionFactor([[0,0],[0,0]]) == 0
\end{minted}
\VALIDATION{Three asserts covering two examples and a duplicate-points edge case.}
\RESULT{Returns the largest integer $D$ such that the graph on points with edges between pairs at distance $<D$ is bipartite, with the convention that for $n=2$ the answer is $0$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests include examples, duplicate-points clusters, random small sets cross-checked against brute force, and boundary cases with collinear or widely separated points.}
\LINE{CROSS-CHECKS}{For $n\le 14$, compare the baseline brute force result with the optimal method on random instances to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generates adversarial patterns: all equal points; star-shaped layouts; grid corners; near-duplicate perturbations; mixed scales.}
\begin{minted}{python}
from typing import List
import random

def man(a, b):
    return abs(a[0]-b[0]) + abs(a[1]-b[1])

def brute(points: List[List[int]]) -> int:
    n = len(points)
    if n == 2:
        return 0
    # Precompute distances
    dist = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            d = man(points[i], points[j])
            dist[i][j] = dist[j][i] = d
    best = 0
    full = (1<<n)-1
    for mask in range(1, 1<<n):
        if not (mask & 1):
            continue
        if mask == full:
            continue
        def gmin(m):
            if m == 0 or (m & (m-1)) == 0:
                return 10**30
            idx = [i for i in range(n) if (m>>i)&1]
            ans = 10**30
            for i in range(len(idx)):
                for j in range(i+1, len(idx)):
                    ans = min(ans, dist[idx[i]][idx[j]])
                    if ans == 0:
                        return 0
            return ans
        score = min(gmin(mask), gmin(full ^ mask))
        best = max(best, score)
    return best

def check_random():
    from collections import deque
    # Use the final optimized Solution
    S = Solution()
    for n in range(3, 12):
        for _ in range(40):
            pts = []
            for _k in range(n):
                x = random.randint(-5, 5)
                y = random.randint(-5, 5)
                pts.append([x, y])
            b = brute(pts)
            o = S.maximumPartitionFactor(pts)
            assert b == o, (pts, b, o)

if __name__ == "__main__":
    # Run the randomized cross-check on small cases
    check_random()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Deque
from collections import deque

class Solution:
    def maximumPartitionFactor(self, points: List[List[int]]) -> int:
        n = len(points)
        if n == 2:
            return 0

        # Precompute distance matrix and maximum distance
        dist = [[0]*n for _ in range(n)]
        M = 0
        for i in range(n):
            xi, yi = points[i]
            for j in range(i+1, n):
                xj, yj = points[j]
                d = abs(xi - xj) + abs(yi - yj)
                dist[i][j] = dist[j][i] = d
                if d > M:
                    M = d

        def feasible(D: int) -> bool:
            # Check if the graph with edges for dist < D is bipartite
            color = [-1] * n
            for s in range(n):
                if color[s] != -1:
                    continue
                color[s] = 0
                q: Deque[int] = deque([s])
                while q:
                    u = q.popleft()
                    cu = color[u]
                    row = dist[u]
                    for v in range(n):
                        if v == u:
                            continue
                        if row[v] < D:
                            if color[v] == -1:
                                color[v] = cu ^ 1
                                q.append(v)
                            elif color[v] == cu:
                                return False
            return True

        lo, hi = 0, M + 1
        while lo + 1 < hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                lo = mid
            else:
                hi = mid
        return lo

if __name__ == "__main__":
    sol = Solution()
    assert sol.maximumPartitionFactor([[0,0],[0,2],[2,0],[2,2]]) == 4
    assert sol.maximumPartitionFactor([[0,0],[0,1],[10,0]]) == 11
    assert sol.maximumPartitionFactor([[0,0],[0,0]]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the smallest same-group Manhattan distance by two-coloring the forbidden-edges graph and binary searching the largest feasible threshold.}
\WHY{Transforms a geometric partitioning objective into a pure graph property (bipartiteness), a common trick in advanced interview problems.}
\CHECKLIST{
\begin{bullets}
\item Build thresholded forbidden graph $G_D$.
\item Check bipartiteness via BFS/DFS.
\item Binary search $D$ with monotonic feasibility.
\item Special-case $n=2\to 0$ by definition.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=2$ must return $0$ regardless of coordinates.
\item Many identical points: answer is $0$ when at least one group must contain two identical points.
\item All points very far apart: large $D$ until adding all edges breaks bipartiteness.
\item Star or chain layouts that are bipartite at certain thresholds.
\item Points forming odd cycles under threshold edges (drive the limit).
\item Negative coordinates and large magnitudes (distance arithmetic only).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting the $n=2$ convention yields overestimation.
\item Misinterpreting threshold inequality: edges are for $d(i,j) < D$, not $\le D$.
\item Not resetting colors across components in bipartite check.
\item Integer overflow in other languages (use Python int here).
\item Off-by-one in binary search bounds; ensure invariant feasible(lo), infeasible(hi).
\item Building explicit dense adjacency lists repeatedly without reuse can be slow; precompute distances.
\end{bullets}}
\FAILMODES{A naive greedy split can easily fail on patterns that induce odd cycles under certain thresholds. The bipartite test protects against these by construction.}
\ELI{Connect any pair of points that are too close for your target threshold. If you can color the graph with two colors so connected points differ, the split works. Increase the threshold until that becomes impossible.}
\NotePages{3}

\end{document}