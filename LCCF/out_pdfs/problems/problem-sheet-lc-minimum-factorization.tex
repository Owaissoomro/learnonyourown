% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Factorization}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-factorization/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given a positive integer $a$. Find the smallest positive integer $b$ (in usual decimal order) such that the product of the digits of $b$ equals $a$. If no such $b$ exists or if the answer exceeds the $32$-bit signed integer range $\left[{-}2^{31},\,2^{31}{-}1\right]$, return $0$.

Notes:
\begin{bullets}
\item The digit product of an integer is the product of its base-$10$ digits; for example, the digit product of $135$ is $1\times 3\times 5=15$.
\item By convention, if $a<10$, the answer is $a$ itself, since $a$ is already a single digit whose digit product equals $a$.
\end{bullets}}
\BREAKDOWN{We must express $a$ as a product of digits from $2$ to $9$. If possible, assemble these digits into the numerically smallest integer $b$ (i.e., digits sorted ascending). If not possible or if $b>2^{31}{-}1$, return $0$.}
\ELI{Break $a$ into factors between $2$ and $9$; if you can, put those digits in increasing order to get the smallest number; otherwise return $0$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $a$ with $1\le a\le 2^{31}{-}1$.}
\OUTPUTS{Return the smallest positive integer $b$ whose decimal-digit product equals $a$; return $0$ if it does not exist or if $b>2^{31}{-}1$.}
\SAMPLES{
\begin{bullets}
\item Input: $a=48$; Output: $68$ \quad (since $6\times 8=48$ and $68$ is the smallest such integer).
\item Input: $a=11$; Output: $0$ \quad (no product of digits $2{\ldots}9$ can make the prime $11$).
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $a\in\mathbb{Z}_{>0}$. Find a multiset $D\subseteq\{2,3,4,5,6,7,8,9\}$ (with repetition) such that $\prod_{d\in D} d=a$. Among all such $D$, minimize the base-$10$ integer $b$ obtained by concatenating the elements of $D$ in nondecreasing order. If no such $D$ exists, output $0$.}
\varmapStart
\var{a}{given positive integer target product}
\var{D}{multiset of digits in $\{2,\ldots,9\}$ whose product equals $a$}
\var{b}{integer formed by sorting $D$ ascending and concatenating}
\var{M}{limit $2^{31}{-}1$ for overflow checking}
\varmapEnd
\GOVERN{
\[
\exists D\subseteq\{2,\ldots,9\} \text{ (multiset) such that }\prod\nolimits_{d\in D} d=a,\quad
b=\sum_{i=1}^{|D|} d_{(i)}\cdot 10^{|D|-i},
\]
\begin{BreakableEquation*}
\text{with } d_{(1)}\le d_{(2)}\le\cdots\le d_{(|D|)},\quad \text{and minimize } b.
\end{BreakableEquation*}
}
\ASSUMPTIONS{
\begin{bullets}
\item Base-$10$ representation; digits are in $\{0,1,\ldots,9\}$ and factors must be in $\{2,\ldots,9\}$ since $1$ does not reduce $a$ and $0$ annihilates the product.
\item If $a<10$, the minimal $b$ equals $a$.
\item Overflow threshold $M=2^{31}{-}1$.
\end{bullets}
}
\INVARIANTS{
\begin{bullets}
\item Greedy division by larger digits (from $9$ down to $2$) preserves feasibility: whenever $d\mid a$, replacing $a$ by $a/d$ and recording $d$ keeps the target product achievable.
\item Minimizing $b$ among fixed multiset size is achieved by sorting digits ascending before concatenation.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Backtracking search over digits $9$ down to $2$ to factor $a$; collect digits when divisible, recurse, and track the best numeric result.}
\ASSUMPTIONS{Search space may explode, but small test cases finish quickly. We prune when the partial product exceeds $a$ or $a$ is not divisible by the next candidate factor.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $a<10$, return $a$.
\item Define recursive DFS(idx, cur\_a, path): try digits $d$ from $9$ down to $2$, ensuring $d\mid \text{cur\_a}$; divide cur\_a by $d$, append $d$, and recurse allowing reuse of $d$.
\item When cur\_a becomes $1$, form the candidate number by sorting path ascending and concatenating; update the best if smaller and within $[0,M]$.
\end{algosteps}
\COMPLEXITY{Exponential in the worst case due to combinatorial branching; space proportional to recursion depth (at most the number of collected digits).}
\[
\begin{aligned}
T(n) &\in O(8^{k}) \text{ in the worst case, where $k$ is the number of digit factors},\\
S(n) &\in O(k).
\end{aligned}
\]
\CORRECTNESS{The DFS explores all multisets of digits whose product divides $a$ and reaches exactly those with product $a$. Sorting collected digits ascending yields the minimal numeric value among permutations of the same multiset. Tracking the global minimum ensures the smallest feasible $b$ is returned.}
\EDGECASES{Handle $a<10$ directly; if no factorization exists, return $0$; enforce $b\le M$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def smallestFactorization(self, a: int) -> int:
        M = 2**31 - 1
        if a < 10:
            return a
        best = None

        # DFS with pruning; try larger digits first to reduce 'a' quickly
        def dfs(start_digit: int, cur_a: int, path: list):
            nonlocal best
            if cur_a == 1:
                # Build number from sorted ascending digits to minimize value
                digits = sorted(path)
                val = 0
                for d in digits:
                    # overflow-safe assemble
                    if val > (M - d) // 10:
                        return
                    val = val * 10 + d
                if best is None or val < best:
                    best = val
                return
            # If best already 0, it's minimal only if no factorization exists; cannot short-circuit otherwise
            for d in range(start_digit, 1, -1):
                if cur_a % d == 0:
                    path.append(d)
                    dfs(d, cur_a // d, path)  # allow reuse of 'd'
                    path.pop()

        dfs(9, a, [])
        return best if best is not None else 0


# Basic asserts for sanity
if __name__ == "__main__":
    s = Solution()
    assert s.smallestFactorization(48) == 68
    assert s.smallestFactorization(15) == 35
    assert s.smallestFactorization(11) == 0
    assert s.smallestFactorization(1) == 1
\end{minted}
\VALIDATION{Checked typical cases: composite $a$ like $48$ and $15$, prime $a=11$ (no solution), and base case $a=1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy Factor Extraction}
\WHICHFORMULA{Repeatedly divide $a$ by the largest possible digit in $\{9,\ldots,2\}$, collecting digits. This minimizes the number of digits; fewer digits with the same product enable a smaller numeric value after sorting ascending.}
\ASSUMPTIONS{If after greedy extraction $a>1$, no combination of digits $2$ to $9$ can produce the original $a$. Sorting collected digits ascending yields the minimum integer for that multiset.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $a<10$, return $a$.
\item For $d$ from $9$ down to $2$: while $d\mid a$, divide $a$ by $d$ and push $d$ to the digit list.
\item If after the loop $a>1$, return $0$.
\item Sort the digits ascending and assemble the number; if it exceeds $2^{31}{-}1$, return $0$.
\end{algosteps}
\COMPLEXITY{Division loop visits each factor extraction once; at most $O(\log a)$ extractions because each digit factor $\ge 2$.}
\[
\begin{aligned}
T(n) &\in O(\log a),\\
S(n) &\in O(\log a) \text{ for storing digits (worst case many 2s)}.
\end{aligned}
\]
\CORRECTNESS{Using larger digits first minimizes the number of digits, which is necessary to minimize the resultant integer. Among equal-length solutions, ascending order of digits gives the smallest numeric value. If any prime factor $>9$ remains, no valid digit multiset exists.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def smallestFactorization(self, a: int) -> int:
        M = 2**31 - 1
        if a < 10:
            return a
        digits = []
        for d in range(9, 1, -1):
            while a % d == 0:
                digits.append(d)
                a //= d
        if a != 1:
            return 0
        digits.sort()
        val = 0
        for d in digits:
            if val > (M - d) // 10:
                return 0
            val = val * 10 + d
        return val


# Basic asserts for sanity
if __name__ == "__main__":
    s = Solution()
    assert s.smallestFactorization(48) == 68
    assert s.smallestFactorization(15) == 35
    assert s.smallestFactorization(11) == 0
    assert s.smallestFactorization(1) == 1
\end{minted}
\VALIDATION{Confirms behavior on composite, prime, and base cases; checks overflow via guarded assembly path.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Greedy Factorization with Monotone Assembly}
\WHICHFORMULA{Same greedy factor extraction ($9\to 2$), but assemble the result directly in ascending order with tight overflow checks. This is optimal in both time and result minimality.}
\ASSUMPTIONS{Applicable for all $a\in[1,2^{31}{-}1]$. The greedy correctness follows from minimizing digit count and then lexicographically minimizing digits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Handle $a<10$ immediately.
\item Extract factors $9$ down to $2$ into a list.
\item If leftover $a>1$, return $0$.
\item Sort digits ascending; accumulate into $b$, checking $b\le 2^{31}{-}1$ at each step.
\end{algosteps}
\OPTIMALITY{Any valid factorization induces a multiset of digits with the same product. Using the largest digits reduces multiset cardinality; fewer digits yield strictly smaller minimal concatenations than any factorization with more digits. Thus the greedy multiset dominates. Sorting ascending yields the smallest integer for that multiset.}
\COMPLEXITY{Linear in the number of extracted digits and constant passes over $\{9,\ldots,2\}$.}
\[
\begin{aligned}
T(n) &\in O(\log a),\quad S(n)\in O(\log a).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def smallestFactorization(self, a: int) -> int:
        M = 2**31 - 1
        if a < 10:
            return a
        out = []
        for d in range(9, 1, -1):
            while a % d == 0:
                out.append(d)
                a //= d
        if a != 1:
            return 0
        out.sort()
        ans = 0
        for d in out:
            if ans > (M - d) // 10:
                return 0
            ans = ans * 10 + d
        return ans


# Exactly 3 asserts
if __name__ == "__main__":
    s = Solution()
    assert s.smallestFactorization(48) == 68
    assert s.smallestFactorization(1) == 1
    assert s.smallestFactorization(11) == 0
\end{minted}
\VALIDATION{Three asserts cover composite case ($48\mapsto 68$), identity base case ($1\mapsto 1$), and impossibility (prime $11\mapsto 0$).}
\RESULT{Return the smallest integer $b$ with digit product $a$, or $0$ if impossible or exceeding $2^{31}{-}1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests should cover: $a<10$; prime $a$; products needing repeated same digits (e.g., $a=2^k$); mixed factors (e.g., $a=2^3\cdot 5^3=1000$); near-overflow assembly paths.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (DFS) and Approach C (Greedy) for small random $a\le 1000$; they must match.}
\LINE{EDGE-CASE GENERATOR}{Generate $a$ as products of random digits in $\{2,\ldots,9\}$ ensuring known solutions; include primes to force $0$.}
\begin{minted}{python}
import random

def brute_smallest_factorization(a: int) -> int:
    M = 2**31 - 1
    if a < 10:
        return a
    best = None
    def dfs(start_d, cur, path):
        nonlocal best
        if cur == 1:
            v = 0
            for d in sorted(path):
                if v > (M - d) // 10:
                    return
                v = v * 10 + d
            if best is None or v < best:
                best = v
            return
        for d in range(start_d, 1, -1):
            if cur % d == 0:
                path.append(d)
                dfs(d, cur // d, path)
                path.pop()
    dfs(9, a, [])
    return best if best is not None else 0

class Solution:
    def smallestFactorization(self, a: int) -> int:
        M = 2**31 - 1
        if a < 10:
            return a
        digs = []
        for d in range(9, 1, -1):
            while a % d == 0:
                digs.append(d)
                a //= d
        if a != 1:
            return 0
        digs.sort()
        v = 0
        for d in digs:
            if v > (M - d) // 10:
                return 0
            v = v * 10 + d
        return v

if __name__ == "__main__":
    # Deterministic edge tests
    sol = Solution()
    assert sol.smallestFactorization(1) == 1
    assert sol.smallestFactorization(15) == 35
    assert sol.smallestFactorization(48) == 68
    assert sol.smallestFactorization(11) == 0
    # Cross-check random composite instances
    rng = random.Random(0)
    for _ in range(200):
        # Build a as product of 1..6 random digits from 2..9
        cnt = rng.randint(1, 6)
        a = 1
        for __ in range(cnt):
            a *= rng.randint(2, 9)
        assert sol.smallestFactorization(a) == brute_smallest_factorization(a)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def smallestFactorization(self, a: int) -> int:
        M = 2**31 - 1
        if a < 10:
            return a
        digits = []
        for d in range(9, 1, -1):
            while a % d == 0:
                digits.append(d)
                a //= d
        if a != 1:
            return 0
        digits.sort()
        ans = 0
        for d in digits:
            if ans > (M - d) // 10:
                return 0
            ans = ans * 10 + d
        return ans


if __name__ == "__main__":
    s = Solution()
    assert s.smallestFactorization(48) == 68
    assert s.smallestFactorization(15) == 35
    assert s.smallestFactorization(11) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Factor the target into digits $9\to 2$, then sort digits ascending and assemble with overflow checks; otherwise return $0$.}
\WHY{This pattern tests number theory factorization, greedy reasoning, and careful integer assembly with overflow constraints.}
\CHECKLIST{
\begin{bullets}
\item If $a<10$, return $a$.
\item Extract factors from $9$ down to $2$.
\item If leftover $a>1$, return $0$.
\item Sort digits ascending.
\item Assemble safely; if overflow, return $0$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $a=1$.
\item $a$ prime and $>9$ (e.g., $11$) $\Rightarrow 0$.
\item Powers like $a=2^k$ or $a=3^k$ producing many small digits.
\item Mixed factors $a=2^3\cdot 5^3=1000$ $\Rightarrow 5558$.
\item $a$ already single digit $<10$.
\item Near-overflow result where appending last digit would exceed $2^{31}{-}1$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to return $a$ when $a<10$.
\item Assembling digits in descending order (produces larger number).
\item Not checking overflow on each append.
\item Allowing digit $1$ in factorization (does not reduce $a$).
\item Not sorting digits before concatenation.
\item Using floating-point or strings without careful bounds can mask overflow issues.
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item Naive search by incrementing $b$ and checking digit product times out quickly.
\item BFS on products without pruning explodes combinatorially.
\item Missing overflow check yields wrong nonzero answers when the true answer is $0$.
\end{bullets}
}
\ELI{Try to divide $a$ by big digits like $9,8,\ldots,2$. If anything is left that is not $1$, it is impossible. Otherwise, sort the digits you found from small to big and write them next to each other; if the number is too large for a $32$-bit signed int, return $0$.}
\NotePages{3}

\end{document}