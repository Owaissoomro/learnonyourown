% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Big Countries}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/big-countries/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Table: \texttt{World}

\begin{tabular}{ll}
\texttt{+-------------+---------+} & \\
\texttt{| Column Name | Type    |} & \\
\texttt{+-------------+---------+} & \\
\texttt{| name        | varchar |} & \\
\texttt{| continent   | varchar |} & \\
\texttt{| area        | int     |} & \\
\texttt{| population  | int     |} & \\
\texttt{| gdp         | bigint  |} & \\
\texttt{+-------------+---------+} &
\end{tabular}

\begin{itemize}
\item \texttt{name} is the primary key (column with unique values) for this table.
\item Each row of this table gives information about the name of a country, the continent to which it belongs, its area, the population, and its GDP value.
\end{itemize}

A country is \textbf{big} if:
\begin{itemize}
\item it has an area of at least three million (i.e., \texttt{3000000 km\^{}2}), or
\item it has a population of at least twenty-five million (i.e., \texttt{25000000}).
\end{itemize}

Write a solution to find the name, population, and area of the \textbf{big countries}. Return the result table in \textbf{any order}. The result format is in the following example.

\textbf{Example 1:}

\textbf{Input:}

World table:
\begin{tabular}{l}
\texttt{+-------------+-----------+---------+------------+--------------+}\\
\texttt{| name        | continent | area    | population | gdp          |}\\
\texttt{+-------------+-----------+---------+------------+--------------+}\\
\texttt{| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |}\\
\texttt{| Albania     | Europe    | 28748   | 2831741    | 12960000000  |}\\
\texttt{| Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |}\\
\texttt{| Andorra     | Europe    | 468     | 78115      | 3712000000   |}\\
\texttt{| Angola      | Africa    | 1246700 | 20609294   | 100990000000 |}\\
\texttt{+-------------+-----------+---------+------------+--------------+}
\end{tabular}

\textbf{Output:}
\begin{tabular}{l}
\texttt{+-------------+------------+---------+}\\
\texttt{| name        | population | area    |}\\
\texttt{+-------------+------------+---------+}\\
\texttt{| Afghanistan | 25500100   | 652230  |}\\
\texttt{| Algeria     | 37100000   | 2381741 |}\\
\texttt{+-------------+------------+---------+}
\end{tabular}
}
\BREAKDOWN{We need to filter rows from the \texttt{World} table where either the area is at least 3{,}000{,}000 or the population is at least 25{,}000{,}000, and then project only the \texttt{name}, \texttt{population}, and \texttt{area} columns.}
\ELI{Pick countries whose area is huge or whose population is huge, and list their name, population, and area.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Relational table \texttt{World} with schema:
\begin{itemize}
\item \texttt{name}: string, unique, non-null.
\item \texttt{continent}: string.
\item \texttt{area}: integer, non-negative.
\item \texttt{population}: integer, non-negative.
\item \texttt{gdp}: 64-bit integer, non-negative.
\end{itemize}
Valid rows represent countries.}
\OUTPUTS{A result relation with columns \texttt{name} (string), \texttt{population} (int), \texttt{area} (int) for all rows where \texttt{area} $\ge 3{,}000{,}000$ or \texttt{population} $\ge 25{,}000{,}000$. Order can be arbitrary.}
\SAMPLES{Example consistent with platform:

Input table includes Afghanistan, Albania, Algeria, Andorra, Angola as in the statement. Output includes Afghanistan and Algeria with their \texttt{name}, \texttt{population}, and \texttt{area}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $C$ be the finite set of countries. Each $c \in C$ has attributes $\mathrm{name}(c)$, $\mathrm{area}(c) \in \mathbb{Z}_{\ge 0}$, and $\mathrm{pop}(c) \in \mathbb{Z}_{\ge 0}$. We want the set
\begin{BreakableEquation*}
S \coloneqq \{\,(\mathrm{name}(c), \mathrm{pop}(c), \mathrm{area}(c)) : c \in C,\ \mathrm{area}(c) \ge 3{,}000{,}000 \ \lor\ \mathrm{pop}(c) \ge 25{,}000{,}000 \,\}.
\end{BreakableEquation*} }
\varmapStart
\var{C}{set of countries (rows of \texttt{World})}
\var{\mathrm{area}(c)}{area attribute of country $c$}
\var{\mathrm{pop}(c)}{population attribute of country $c$}
\var{S}{result set of projected tuples meeting the predicate}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall c \in C:\ c \in \text{Big} \iff \big(\mathrm{area}(c) \ge 3{,}000{,}000\big) \lor \big(\mathrm{pop}(c) \ge 25{,}000{,}000\big).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Names are unique; areas and populations are integers in valid ranges; no duplicate rows.}
\INVARIANTS{
\begin{itemize}
\item Projection: Only the fields \texttt{name}, \texttt{population}, \texttt{area} appear in the output.
\item Predicate preservation: Every output row satisfies the big-country predicate.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct scan and filter over all rows, checking $\mathrm{area} \ge 3{,}000{,}000$ or $\mathrm{pop} \ge 25{,}000{,}000$, then projecting columns.}
\ASSUMPTIONS{Input is an in-memory list of row dictionaries mimicking the table.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an empty list for results.
\item For each row, if \texttt{row["area"] $\ge$ 3000000} or \texttt{row["population"] $\ge$ 25000000}, append \{\texttt{name}, \texttt{population}, \texttt{area}\}.
\item Return the result list.
\end{algosteps}
\COMPLEXITY{Let $n$ be the number of rows. One pass with $O(1)$ work per row.}
\[
\begin{aligned}
T(n) &= O(n),\\
S(n) &= O(k) \text{ for } k \text{ matches (output size)}.
\end{aligned}
\]
\CORRECTNESS{Every row is examined exactly once and included iff the predicate holds, and only the required columns are returned, so the output matches the model.}
\EDGECASES{Rows with area or population exactly on the threshold; empty table; all rows failing or all passing.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def bigCountries(self, world):
        """
        world: list[dict], each with keys: 'name','continent','area','population','gdp'
        returns: list[dict] with keys: 'name','population','area' for big countries
        """
        res = []
        for row in world:
            area = int(row.get('area', 0))
            pop = int(row.get('population', 0))
            if area >= 3_000_000 or pop >= 25_000_000:
                res.append({
                    'name': row['name'],
                    'population': pop,
                    'area': area,
                })
        return res

# Tiny tests (from the example)
if __name__ == "__main__":
    world = [
        {'name':'Afghanistan','continent':'Asia','area':652230,'population':25500100,'gdp':20343000000},
        {'name':'Albania','continent':'Europe','area':28748,'population':2831741,'gdp':12960000000},
        {'name':'Algeria','continent':'Africa','area':2381741,'population':37100000,'gdp':188681000000},
        {'name':'Andorra','continent':'Europe','area':468,'population':78115,'gdp':3712000000},
        {'name':'Angola','continent':'Africa','area':1246700,'population':20609294,'gdp':100990000000},
    ]
    sol = Solution()
    out = sol.bigCountries(world)
    names = sorted([r['name'] for r in out])
    assert names == ['Afghanistan', 'Algeria']
    # Threshold checks
    assert Solution().bigCountries([{'name':'X','continent':'','area':3000000,'population':0,'gdp':0}])[0]['name'] == 'X'
    assert Solution().bigCountries([{'name':'Y','continent':'','area':0,'population':25000000,'gdp':0}])[0]['name'] == 'Y'
\end{minted}
\VALIDATION{Checked example names; verified inclusion at exact thresholds.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{List Comprehension \& Projection}
\WHICHFORMULA{Use a single-pass list comprehension with tuple unpacking to reduce boilerplate and potential mistakes, equivalent logic.}
\ASSUMPTIONS{Same input representation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate over rows using a comprehension.
\item Filter with the predicate in-line.
\item Construct projected dicts in-place.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline, with lower Python overhead in practice.}
\[
\begin{aligned}
T(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Identical predicate and projection guarantee the same set as the model.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def bigCountries(self, world):
        return [
            {'name': r['name'], 'population': int(r.get('population', 0)), 'area': int(r.get('area', 0))}
            for r in world
            if int(r.get('area', 0)) >= 3_000_000 or int(r.get('population', 0)) >= 25_000_000
        ]

# Checks on edge inputs
if __name__ == "__main__":
    sol = Solution()
    # Empty input
    assert sol.bigCountries([]) == []
    # All pass
    w = [{'name':'A','continent':'','area':4000000,'population':1,'gdp':0},
         {'name':'B','continent':'','area':1,'population':99999999,'gdp':0}]
    assert sorted([x['name'] for x in sol.bigCountries(w)]) == ['A','B']
\end{minted}
\VALIDATION{Validated empty input and all-pass scenarios.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{SQL Selection and Projection}
\WHICHFORMULA{Express as a single SQL query with selection and projection:
\begin{BreakableEquation*}
\texttt{SELECT name, population, area FROM World WHERE area >= 3000000 OR population >= 25000000;}
\end{BreakableEquation*}
This is optimal in standard RDBMS with proper indexing on \texttt{area} and \texttt{population}.}
\ASSUMPTIONS{Database can use indexes on \texttt{area} and/or \texttt{population} to short-circuit scans; result order is arbitrary.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Use a WHERE predicate with a disjunction on thresholds.
\item Project only required columns.
\item Let the DB optimizer choose an index or scan strategy.
\end{algosteps}
\OPTIMALITY{Given that every qualifying row must be examined or retrieved via an index satisfying the predicate, the query is optimal in the relational algebra sense (single selection + projection).}
\COMPLEXITY{Without indexes: $O(n)$ scan. With bitmap or B-tree indexes on \texttt{area} and \texttt{population}: $O(m \log n)$ to locate matches, where $m$ is the number of qualifying rows, often near $O(m)$ with index range scans and merges.}
\[
\begin{aligned}
T(n) &= \Theta(n) \text{ (heap scan) } \quad \text{or} \quad O(\log n + m) \text{ (index-assisted)},\\
S(n) &= \Theta(m) \text{ (output)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def bigCountries(self, world):
        """
        Return big countries (name, population, area).
        This mirrors the SQL:
        SELECT name, population, area
        FROM World
        WHERE area >= 3000000 OR population >= 25000000;
        """
        return [
            {'name': r['name'], 'population': int(r.get('population', 0)), 'area': int(r.get('area', 0))}
            for r in world
            if int(r.get('area', 0)) >= 3_000_000 or int(r.get('population', 0)) >= 25_000_000
        ]

if __name__ == "__main__":
    # Exactly 3 asserts
    sol = Solution()
    # 1) Sample-like
    world = [
        {'name':'Afghanistan','continent':'Asia','area':652230,'population':25500100,'gdp':20343000000},
        {'name':'Algeria','continent':'Africa','area':2381741,'population':37100000,'gdp':188681000000},
        {'name':'Andorra','continent':'Europe','area':468,'population':78115,'gdp':3712000000},
    ]
    assert sorted([x['name'] for x in sol.bigCountries(world)]) == ['Afghanistan', 'Algeria']
    # 2) Threshold area
    assert sol.bigCountries([{'name':'ThA','continent':'','area':3000000,'population':1,'gdp':0}])[0]['name'] == 'ThA'
    # 3) Threshold population
    assert sol.bigCountries([{'name':'ThP','continent':'','area':1,'population':25000000,'gdp':0}])[0]['name'] == 'ThP'
\end{minted}
\VALIDATION{Three asserts cover example behavior and both threshold edges.}
\RESULT{Return all countries with \texttt{area} $\ge 3{,}000{,}000$ or \texttt{population} $\ge 25{,}000{,}000$, projected to \texttt{name}, \texttt{population}, \texttt{area}, in any order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: empty input; all-pass; none-pass; exact thresholds; mixed data. Property: every output row satisfies the predicate; every input row satisfying the predicate appears once with correct projection.}
\LINE{CROSS-CHECKS}{Compare outputs from Approaches A, B, and C on randomly generated datasets to ensure identical sets of names and aligned fields.}
\LINE{EDGE-CASE GENERATOR}{Create rows around thresholds (just below and just above), very large values, and zeroes.}
\begin{minted}{python}
import random

def gen_world(n, seed=0):
    random.seed(seed)
    res = []
    for i in range(n):
        area = random.choice([0, 2999999, 3000000, 3000001, random.randint(0, 10_000_000)])
        pop = random.choice([0, 24_999_999, 25_000_000, 25_000_001, random.randint(0, 100_000_000)])
        res.append({'name': f'C{i}', 'continent': 'X', 'area': area, 'population': pop, 'gdp': 0})
    return res

class A:
    def bigCountries(self, world):
        res = []
        for row in world:
            if int(row.get('area', 0)) >= 3_000_000 or int(row.get('population', 0)) >= 25_000_000:
                res.append({'name': row['name'], 'population': int(row.get('population', 0)), 'area': int(row.get('area', 0))})
        return res

class B:
    def bigCountries(self, world):
        return [{'name': r['name'], 'population': int(r.get('population', 0)), 'area': int(r.get('area', 0))}
                for r in world
                if int(r.get('area', 0)) >= 3_000_000 or int(r.get('population', 0)) >= 25_000_000]

class C:
    def bigCountries(self, world):
        return [{'name': r['name'], 'population': int(r.get('population', 0)), 'area': int(r.get('area', 0))}
                for r in world
                if int(r.get('area', 0)) >= 3_000_000 or int(r.get('population', 0)) >= 25_000_000]

if __name__ == "__main__":
    world = gen_world(100, seed=42)
    outA = sorted(A().bigCountries(world), key=lambda x: x['name'])
    outB = sorted(B().bigCountries(world), key=lambda x: x['name'])
    outC = sorted(C().bigCountries(world), key=lambda x: x['name'])
    assert outA == outB == outC
    # None-pass
    world2 = [{'name':'Z','continent':'','area':1,'population':1,'gdp':0}]
    assert A().bigCountries(world2) == B().bigCountries(world2) == C().bigCountries(world2) == []
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def bigCountries(self, world):
        """
        Return [{'name', 'population', 'area'}, ...] for countries with
        area >= 3_000_000 or population >= 25_000_000.
        """
        return [
            {'name': r['name'], 'population': int(r.get('population', 0)), 'area': int(r.get('area', 0))}
            for r in world
            if int(r.get('area', 0)) >= 3_000_000 or int(r.get('population', 0)) >= 25_000_000
        ]

if __name__ == "__main__":
    # Quick sanity checks
    sol = Solution()
    assert sol.bigCountries([]) == []
    data = [
        {'name':'A','continent':'','area':3000000,'population':0,'gdp':0},
        {'name':'B','continent':'','area':0,'population':25000000,'gdp':0},
        {'name':'C','continent':'','area':1,'population':1,'gdp':0},
    ]
    out = sorted([x['name'] for x in sol.bigCountries(data)])
    assert out == ['A','B']
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Filter by a disjunctive threshold on \texttt{area} or \texttt{population}, and project three columns.}
\WHY{Common SQL screening question testing selection, projection, and correct use of OR vs AND.}
\CHECKLIST{
\begin{itemize}
\item Use OR, not AND.
\item Include only \texttt{name}, \texttt{population}, \texttt{area}.
\item Do not assume any specific ordering unless required.
\item Handle exact thresholds ($\ge$).
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item Exactly 3{,}000{,}000 area.
\item Exactly 25{,}000{,}000 population.
\item Very large values within 64-bit limits.
\item Empty input table.
\item All rows pass or none pass.
\item Duplicate-like rows should not occur due to primary key, but projection may hide uniqueness if mis-joined.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Using AND instead of OR.
\item Returning extra columns like \texttt{continent} or \texttt{gdp}.
\item Accidentally filtering with strict $>$ instead of $\ge$.
\item Assuming stable ordering without ORDER BY.
\item Type coercion issues if fields are strings in a loader context.
\item Misspelling column names.
\end{itemize}
}
\FAILMODES{A weaker approach that uses AND misses valid big countries. Approaches here use the correct disjunction and projection, ensuring completeness and soundness.}
\ELI{Grab all countries that are either very large by land or very large by people, then show their names with their size and population. It is a straightforward filter with an OR.}
\NotePages{3}

\end{document}