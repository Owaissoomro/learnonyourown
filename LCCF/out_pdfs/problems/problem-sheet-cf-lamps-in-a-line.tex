% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lamps in a Line}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/100/E}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{There are $n$ lamps in a line. The lamps are numbered $1$ to $n$ from left to right. There are also $n$ keys. When key number $i$ is pressed, all lamps number $x$ such that $i \mid x$ change their state.

For two integer numbers $a$ and $b$, we say $a \mid b$ if and only if there exists an integer $c$ such that $a \times c = b$.

Amirali likes to play with the keys. He randomly pressed $k$ keys and wants to know the final state of the lamps. Help him by writing a Pike piece of code to solve this task.

Input:
The first line of input contains a single integer $n$, the number of lamps ($1 \le n \le 10^5$).

The following line contains $n$ words. The $i$-th word describes the initial state of lamp number $i$ (see samples for details).

The following line contains a single integer $k$ ($1 \le k \le 10^4$), the number of times a key is pressed. Then in the next line come $k$ integers in range $[1, n]$ which are the numbers of the pressed keys. Keys may repeat.

Output:
Write $n$ words to output. Describe the final state of the lamps. See samples for more details. Assume the states are the words ``on'' and ``off''.}
\BREAKDOWN{Compute, for each lamp index $x$, the parity of the number of pressed keys $i$ dividing $x$. Toggle the lamp that many times starting from its initial state.}
\ELI{A lamp $x$ flips once for every pressed key that divides $x$; so it flips as many times as the number of divisors among the pressed keys, and we only care about odd or even.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case:
\begin{bullets}
\item Integer $n$ with $1 \le n \le 10^5$.
\item A line with $n$ words, each either ``on'' or ``off'', describing initial states from lamp $1$ to lamp $n$.
\item Integer $k$ with $1 \le k \le 10^4$.
\item A line with $k$ integers in $[1,n]$, the pressed key numbers (repetitions allowed).
\end{bullets}}
\OUTPUTS{One line with $n$ words separated by single spaces: the final state of lamps $1$ through $n$, each either ``on'' or ``off''.}
\SAMPLES{Example 1:
\begin{tcolorbox}
Input\\
5\\
off on off on off\\
2\\
2 3\\
Output\\
off off on off off
\end{tcolorbox}
Example 2:
\begin{tcolorbox}
Input\\
4\\
off off off off\\
3\\
1 2 2\\
Output\\
on on on on
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let initial states be a vector $s \in \{0,1\}^n$ where $1$ denotes ``on''. Let $c \in \mathbb{N}^n$ count how many times each key is pressed, and let $\bar{c} \in \{0,1\}^n$ be the parity vector with $\bar{c}_i \equiv c_i \bmod 2$. The action of key $i$ toggles all indices $x$ with $i \mid x$.}
\varmapStart
\var{n}{number of lamps and keys}
\var{s_x}{initial state bit of lamp $x$ ($1$ for ``on'', $0$ for ``off'')}
\var{c_i}{number of presses of key $i$}
\var{\bar{c}_i}{parity of $c_i$}
\var{f_x}{final state bit of lamp $x$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
f_x \equiv s_x \oplus \left(\sum_{i \mid x} \bar{c}_i \right) \bmod 2,\quad x=1,\ldots,n.
\end{BreakableEquation*}
}
\ASSUMPTIONS{States are binary words ``on''/``off''. Keys may repeat; only parity matters. Indices are $1$-based.}
\INVARIANTS{
\begin{bullets}
\item Flips compose modulo $2$: two flips restore the original state.
\item Presses of keys with even count have no effect; only odd counts matter.
\item The divisor relation is fixed and independent of press order.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{For each lamp $x$, count how many of the $k$ pressed keys divide $x$ by checking all $k$ keys, then toggle $x$ that many times.}
\ASSUMPTIONS{Use direct divisibility checks; treat the states as bits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$, the initial words, $k$, and the sequence of pressed keys.
\item For each lamp index $x=1..n$, compute $t_x := \bigl|\{j \in [1..k]:~\text{key}_j \mid x\}\bigr|$ by scanning all $k$ keys.
\item Set final $f_x = s_x \oplus (t_x \bmod 2)$ and print as words.
\end{algosteps}
\COMPLEXITY{This checks divisibility $n \times k$ times.}
\[
\begin{aligned}
T(n) &= \Theta(nk) \quad \text{(too slow for } n=10^5,~k=10^4\text{)} \\
S(n) &= \Theta(n + k).
\end{aligned}
\]
\CORRECTNESS{Directly implements $f_x \equiv s_x \oplus \sum_{j=1}^k [\text{key}_j \mid x] \bmod 2$.}
\EDGECASES{Repeated keys; all lamps initially the same; $k=1$; $n=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str) -> Tuple[int, List[str], int, List[int]]:
    it = iter(data.strip().split())
    n = int(next(it))
    states = [next(it) for _ in range(n)]
    k = int(next(it))
    keys = [int(next(it)) for _ in range(k)]
    return n, states, k, keys

def words_to_bits(words: List[str]) -> List[int]:
    def w2b(w: str) -> int:
        wlow = w.lower()
        if wlow in ("on", "1", "true", "yes", "y"):
            return 1
        return 0
    return [w2b(w) for w in words]

def bits_to_words(bits: List[int], on_word: str = "on", off_word: str = "off") -> List[str]:
    return [on_word if b & 1 else off_word for b in bits]

def solve_case_baseline(n: int, words: List[str], k: int, keys: List[int]) -> List[str]:
    s = words_to_bits(words)
    # Count toggles per lamp by scanning all presses
    out = [0] * n
    for x in range(1, n + 1):
        flips = 0
        for key in keys:
            if x % key == 0:
                flips ^= 1
        out[x - 1] = s[x - 1] ^ flips
    return bits_to_words(out)

def solve_all_baseline(data: str) -> str:
    n, states, k, keys = read_input(data)
    ans = solve_case_baseline(n, states, k, keys)
    return " ".join(ans)

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    sys.setrecursionlimit(1 << 25)
    out = solve_all_baseline(data)
    sys.stdout.write(out)

# Assertions (unit tests)
def _test():
    # Example 1
    data = "5\noff on off on off\n2\n2 3\n"
    assert solve_all_baseline(data) == "off off on off off"
    # Repeated keys cancel if even
    data = "4\noff off off off\n3\n1 2 2\n"
    assert solve_all_baseline(data) == "on on on on"
    # Single lamp
    data = "1\non\n1\n1\n"
    assert solve_all_baseline(data) == "off"

_test()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The asserts above check a simple divisor mix, repeated keys, and $n=1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Aggregate by Key and Sieve Multiples}
\WHICHFORMULA{Aggregate the parity of presses for each key $i$ once, then toggle all multiples $j=i,2i,\ldots$ only when the parity is odd. This replaces $nk$ checks by a harmonic-series sum of updates.}
\ASSUMPTIONS{Only parity matters; order is irrelevant. Use a sieve-like loop over multiples.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build an array $\bar{c}[1..n]$ where $\bar{c}[i]$ is the parity of presses of key $i$.
\item Initialize final bits $f$ as the initial bits $s$.
\item For each $i$ with $\bar{c}[i]=1$, toggle $f[j]$ for all multiples $j=i,2i,\ldots,\le n$.
\item Convert bits back to words and print.
\end{algosteps}
\COMPLEXITY{The total toggles are $\sum_{i:\bar{c}[i]=1} \lfloor n/i \rfloor \le n \sum_{i=1}^n \tfrac{1}{i} = O(n \log n)$.}
\[
\begin{aligned}
T(n) &= O(n \log n + k), \\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Toggling multiples for each key with odd parity implements $f_x \equiv s_x \oplus \sum_{i \mid x} \bar{c}_i \bmod 2$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str) -> Tuple[int, List[str], int, List[int]]:
    it = iter(data.strip().split())
    n = int(next(it))
    states = [next(it) for _ in range(n)]
    k = int(next(it))
    keys = [int(next(it)) for _ in range(k)]
    return n, states, k, keys

def words_to_bits(words: List[str]) -> List[int]:
    def w2b(w: str) -> int:
        return 1 if w.lower() in ("on", "1", "true", "yes", "y") else 0
    return [w2b(w) for w in words]

def bits_to_words(bits: List[int]) -> List[str]:
    return ["on" if (b & 1) else "off" for b in bits]

def solve_case_improved(n: int, words: List[str], k: int, keys: List[int]) -> List[str]:
    s = words_to_bits(words)
    f = s[:]  # final bits
    parity = [0] * (n + 1)
    for key in keys:
        if 1 <= key <= n:
            parity[key] ^= 1
    for i in range(1, n + 1):
        if parity[i]:
            for j in range(i, n + 1, i):
                f[j - 1] ^= 1
    return bits_to_words(f)

def solve_all_improved(data: str) -> str:
    n, states, k, keys = read_input(data)
    ans = solve_case_improved(n, states, k, keys)
    return " ".join(ans)

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    sys.setrecursionlimit(1 << 25)
    out = solve_all_improved(data)
    sys.stdout.write(out)

# Assertions (unit tests)
def _test():
    data = "5\noff on off on off\n2\n2 3\n"
    assert solve_all_improved(data) == "off off on off off"
    data = "4\noff off off off\n3\n1 2 2\n"
    assert solve_all_improved(data) == "on on on on"
    data = "6\non on on on on on\n3\n2 3 6\n"
    # Key 2 toggles 2,4,6; 3 toggles 3,6; 6 toggles 6 -> net: 2,3,4 flip; 6 flips 3 times -> off
    assert solve_all_improved(data) == "on off off off on off"

_test()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The asserts cover divisor overlap, repeated keys parity, and a case where a lamp is toggled by multiple keys including repeats.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divisor-Sum Parity via Multiples Sweep}
\WHICHFORMULA{Equivalent to Approach B; this is asymptotically optimal for this input model: $O(n \log n)$ from the harmonic series bound is tight in the worst case when many parities are $1$.}
\ASSUMPTIONS{No faster algorithm can avoid touching all affected multiples when $\Theta(n)$ parity entries are $1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse input; map words to bits.
\item Compute parity of key presses per index.
\item Sweep $i=1..n$; if parity is $1$, toggle all multiples.
\end{algosteps}
\OPTIMALITY{A lower bound follows since for inputs where $\bar{c}_i=1$ for all $i \le n$, any correct algorithm must affect all pairs $(i,j)$ with $i \mid j$, whose count is $\sum_{i=1}^n \lfloor n/i \rfloor = \Theta(n \log n)$.}
\COMPLEXITY{Same as Approach B.}
\[
\begin{aligned}
T(n) &= \Theta(n \log n + k),\quad S(n)=\Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[str], int, List[int]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    states = [next(it) for _ in range(n)]
    k = int(next(it))
    keys = [int(next(it)) for _ in range(k)]
    return n, states, k, keys

def words_to_bits(words: List[str]) -> List[int]:
    return [1 if w.lower() == "on" else 0 for w in words]

def bits_to_words(bits: List[int]) -> List[str]:
    return ["on" if (b & 1) else "off" for b in bits]

def solve_case(n: int, words: List[str], k: int, keys: List[int]) -> List[str]:
    s = words_to_bits(words)
    f = s[:]
    parity = [0] * (n + 1)
    for key in keys:
        if 1 <= key <= n:
            parity[key] ^= 1
    for i in range(1, n + 1):
        if parity[i]:
            for j in range(i, n + 1, i):
                f[j - 1] ^= 1
    return bits_to_words(f)

def solve_all() -> None:
    n, states, k, keys = read_input()
    ans = solve_case(n, states, k, keys)
    print(" ".join(ans))

# Tests (run before solving; no output if all pass)
def _self_test():
    from io import StringIO
    def solve_io(s: str) -> str:
        n, states, k, keys = _read_from_str(s)
        return " ".join(solve_case(n, states, k, keys))
    def _read_from_str(s: str):
        data = s.strip().split()
        it = iter(data)
        n = int(next(it))
        states = [next(it) for _ in range(n)]
        k = int(next(it))
        keys = [int(next(it)) for _ in range(k)]
        return n, states, k, keys

    # 1) Sample-like
    s = "5\noff on off on off\n2\n2 3\n"
    assert solve_io(s) == "off off on off off"
    # 2) Repeats
    s = "4\noff off off off\n3\n1 2 2\n"
    assert solve_io(s) == "on on on on"
    # 3) Edge: n=1
    s = "1\noff\n4\n1 1 1 1\n"
    assert solve_io(s) == "off"

_self_test()

def main():
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts: sample-like case, repeated key parity, and $n=1$ with even total toggles.}
\RESULT{Print the final states as ``on''/``off'' for lamps $1$ to $n$, space-separated.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: divisor coverage, parity cancellation with repeated keys, smallest $n$, all keys pressed once, and random small cross-checks between approaches.}
\LINE{CROSS-CHECKS}{For random $n \le 30$, random initial states and key presses, verify that Baseline and Improved outputs match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate cases with $k=0$ equivalent parity (all keys pressed twice), $n=1$, keys out of range (ignored), and all lamps initially equal.}
\begin{minted}{python}
import random

def gen_case(n: int, k: int):
    states = [random.choice(["on", "off"]) for _ in range(n)]
    keys = [random.randint(1, n) for _ in range(k)]
    return n, states, k, keys

def solve_baseline_api(n, states, k, keys):
    # From Approach A
    def w2b(w): return 1 if w == "on" else 0
    s = list(map(w2b, states))
    out = [0]*n
    for x in range(1, n+1):
        flips = 0
        for key in keys:
            if x % key == 0:
                flips ^= 1
        out[x-1] = s[x-1] ^ flips
    return ["on" if b else "off" for b in out]

def solve_improved_api(n, states, k, keys):
    # From Approach B/C
    s = [1 if w == "on" else 0 for w in states]
    f = s[:]
    parity = [0]*(n+1)
    for key in keys:
        if 1 <= key <= n:
            parity[key] ^= 1
    for i in range(1, n+1):
        if parity[i]:
            for j in range(i, n+1, i):
                f[j-1] ^= 1
    return ["on" if b else "off" for b in f]

def cross_check(trials=200):
    for _ in range(trials):
        n = random.randint(1, 40)
        k = random.randint(0, 80)
        n, states, k, keys = gen_case(n, k)
        a = solve_baseline_api(n, states, k, keys)
        b = solve_improved_api(n, states, k, keys)
        assert a == b

if __name__ == "__main__":
    random.seed(0)
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[str], int, List[int]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    states = [next(it) for _ in range(n)]
    k = int(next(it))
    keys = [int(next(it)) for _ in range(k)]
    return n, states, k, keys

def words_to_bits(words: List[str]) -> List[int]:
    return [1 if w.lower() == "on" else 0 for w in words]

def bits_to_words(bits: List[int]) -> List[str]:
    return ["on" if (b & 1) else "off" for b in bits]

def solve_case(n: int, words: List[str], k: int, keys: List[int]) -> List[str]:
    s = words_to_bits(words)
    f = s[:]
    parity = [0] * (n + 1)
    for key in keys:
        if 1 <= key <= n:
            parity[key] ^= 1
    for i in range(1, n + 1):
        if parity[i]:
            for j in range(i, n + 1, i):
                f[j - 1] ^= 1
    return bits_to_words(f)

def main():
    n, states, k, keys = read_input()
    ans = solve_case(n, states, k, keys)
    print(" ".join(ans))

# Inline sanity tests (do not print anything)
def _test():
    s = "5\noff on off on off\n2\n2 3\n"
    n, states, k, keys = _read_from_str(s)
    assert " ".join(solve_case(n, states, k, keys)) == "off off on off off"
    s = "4\noff off off off\n3\n1 2 2\n"
    n, states, k, keys = _read_from_str(s)
    assert " ".join(solve_case(n, states, k, keys)) == "on on on on"
    s = "1\non\n1\n1\n"
    n, states, k, keys = _read_from_str(s)
    assert " ".join(solve_case(n, states, k, keys)) == "off"

def _read_from_str(s: str):
    it = iter(s.strip().split())
    n = int(next(it))
    states = [next(it) for _ in range(n)]
    k = int(next(it))
    keys = [int(next(it)) for _ in range(k)]
    return n, states, k, keys

_test()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Toggle each lamp based on the parity of pressed keys that divide its index; implement via a multiples sweep.}
\WHY{Classic divisor-multiples structure appears in interview tasks testing harmonic-series reasoning and bitwise parity.}
\CHECKLIST{
\begin{bullets}
\item Map ``on''/``off'' to bits.
\item Count key press parity per index.
\item Sweep $i=1..n$: if parity is $1$, toggle multiples $j=i,2i,\ldots$.
\item Convert bits back to words and print.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Repeated keys (even repeats cancel).
\item $n=1$.
\item $k=1$.
\item All lamps initially ``off'' or all ``on''.
\item Large $n$ near $10^5$.
\item Keys equal to $n$ and keys equal to $1$.
\item Inputs where every key is pressed once.
\item Keys outside $[1,n]$ (ignore if present).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one between $1$-based lamp indices and $0$-based arrays.
\item Forgetting to reduce press counts modulo $2$.
\item Misparsing the lines; read tokens globally to handle arbitrary line breaks.
\item Assuming order matters; it does not.
\item Outputting extra spaces or newlines contrary to format.
\item Using $O(nk)$ brute force, which times out.
\end{bullets}}
\FAILMODES{Baseline $O(nk)$ fails for $n=10^5$, $k=10^4$ due to time. The improved method survives worst-case by $O(n \log n)$.}
\ELI{Count which keys matter (odd number of presses). For each such key, flip every lamp whose index is a multiple of that key. Only whether a lamp is flipped an odd number of times changes its final on/off state.}
\NotePages{3}

\end{document}