% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Power Transmission (Hard Edition)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1163/C2}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{This problem is the same as the previous one, but has larger constraints.

It was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.

At the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates $(x_i, y_i)$. Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.

Selena thinks that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?

Input: The first line contains a single integer $n$ ($2 \le n \le 1000$) — the number of electric poles.

Each of the following $n$ lines contains two integers $x_i$, $y_i$ ($-10^4 \le x_i, y_i \le 10^4$) — the coordinates of the poles.

It is guaranteed that all of these $n$ points are distinct.

Output: Print a single integer — the number of pairs of wires that are intersecting.

Note: In the first example:

In the second example:

Note that the three poles $(0, 0)$, $(0, 2)$ and $(0, 4)$ are connected by a single wire.

In the third example:}
\BREAKDOWN{We must count unique lines induced by the point set and then count unordered pairs of those lines that intersect. Two lines intersect if and only if they are not parallel. Thus, from counts per slope class, we can derive the answer.}
\ELI{Count all unique wires, group by direction, and subtract parallel pairs from all pairs.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{$n$ — integer; then $n$ pairs $(x_i,y_i)$ with integers in the range $[-10^4,10^4]$. All points are distinct; $2 \le n \le 1000$.}
\OUTPUTS{A single integer: the number of unordered pairs of distinct wires (unique lines through at least two points) that intersect.}
\SAMPLES{Example 1 (no parallel lines among the 3 wires):
\[
\begin{aligned}
\text{input:}&\quad 3\\
&\quad 0~0\\
&\quad 1~0\\
&\quad 0~1\\
\text{output:}&\quad 3
\end{aligned}
\]
Example 2 (all three points collinear, one wire only):
\[
\begin{aligned}
\text{input:}&\quad 3\\
&\quad 0~0\\
&\quad 0~2\\
&\quad 0~4\\
\text{output:}&\quad 0
\end{aligned}
\]}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a finite set $P \subset \mathbb{Z}^2$ with $\lvert P \rvert = n$, define $\mathcal{L}$ as the set of all distinct geometric lines in $\mathbb{R}^2$ that contain at least two points from $P$. Let $L=\lvert \mathcal{L}\rvert$. Partition $\mathcal{L}$ by slope (direction) into classes $\{\mathcal{L}_s\}_s$ with sizes $m_s=\lvert\mathcal{L}_s\rvert$. The required count is the number of unordered pairs of lines in $\mathcal{L}$ with different slopes.}
\varmapStart
\var{P}{set of input points}
\var{\mathcal{L}}{set of unique lines determined by $P$}
\var{L}{number of unique lines}
\var{m_s}{number of lines in slope class $s$}
\var{\text{ans}}{number of intersecting unordered line pairs}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{ans} = \binom{L}{2} - \sum_{s}\binom{m_s}{2}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Lines are undirected and coincident lines are counted once. Slopes are treated via a normalized direction vector $(\Delta x,\Delta y)$ with $\gcd(\lvert\Delta x\rvert,\lvert\Delta y\rvert)=1$ and a fixed sign convention ($\Delta x>0$ or $\Delta x=0$ and $\Delta y>0$).}
\INVARIANTS{For a fixed normalized direction $(d_x,d_y)$, the quantity $k=d_y\cdot x - d_x\cdot y$ is constant across all points $(x,y)$ on the same line, giving a unique identifier $(d_x,d_y,k)$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all $\binom{n}{2}$ point pairs, build a canonical line key, deduplicate in a global set, then group by slope and apply $\binom{L}{2}-\sum_s\binom{m_s}{2}$.}
\ASSUMPTIONS{Canonical line key $(d_x,d_y,k)$ with $k=d_y x - d_x y$ using reduced direction $(d_x,d_y)$ as slope representative.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each pair of points $(p_i,p_j)$, compute $\Delta x$, $\Delta y$, reduce to $(d_x,d_y)$ with sign convention.
\item Compute $k=d_y\cdot x_i - d_x\cdot y_i$ and insert key $(d_x,d_y,k)$ into a set of lines.
\item Count $L$ as the set size; tally $m_s$ by slope $(d_x,d_y)$; compute $\text{ans}=\binom{L}{2}-\sum_s\binom{m_s}{2}$.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(n^2\log n)$ from hashing and reductions; space $S(n)=\Theta(L)$ with $L\le \binom{n}{2}$.}
\[
\begin{aligned}
T(n) &\approx \binom{n}{2}\cdot O(1)\quad\text{amortized hashing} \\
S(n) &= O(L)\le O(n^2).
\end{aligned}
\]
\CORRECTNESS{Each geometric line through input points yields identical $(d_x,d_y,k)$ for any generating pair, so it appears once in the set. Lines with different slopes intersect; parallel lines do not. Subtracting parallel pairs from all unordered pairs gives the number of intersections.}
\EDGECASES{All points collinear ($L=1$); duplicate slopes with many offsets (many parallel lines); vertical lines handled by $(d_x,d_y)=(0,1)$; horizontal by $(1,0)$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from math import gcd
from collections import defaultdict
import sys

def _normalize_dir(dx: int, dy: int):
    if dx == 0 and dy == 0:
        return (0, 0)
    g = gcd(abs(dx), abs(dy))
    dx //= g
    dy //= g
    if dx < 0 or (dx == 0 and dy < 0):
        dx = -dx
        dy = -dy
    return (dx, dy)

def _line_key(p, q):
    dx = q[0] - p[0]
    dy = q[1] - p[1]
    dx, dy = _normalize_dir(dx, dy)
    # invariant along the line for this normalized direction
    k = dy * p[0] - dx * p[1]
    return (dx, dy, k)

def _read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    return pts

def read_input():
    data = sys.stdin.buffer.read().decode()
    if not data.strip():
        return None
    return _read_input(data)

def solve_case(points):
    n = len(points)
    lines = set()
    for i in range(n):
        xi, yi = points[i]
        for j in range(i+1, n):
            key = _line_key(points[i], points[j])
            lines.add(key)
    slope_count = defaultdict(int)
    for dx, dy, k in lines:
        slope_count[(dx, dy)] += 1
    L = len(lines)
    total_pairs = L * (L - 1) // 2
    parallel_pairs = sum(c * (c - 1) // 2 for c in slope_count.values())
    return total_pairs - parallel_pairs

def solve_all(points):
    return solve_case(points)

def main():
    pts = read_input()
    if pts is None:
        # Self-tests
        assert _normalize_dir(2, 2) == (1, 1)
        assert _normalize_dir(-2, -2) == (1, 1)
        assert _normalize_dir(0, -7) == (0, 1)
        # Triangle: 3 intersecting pairs
        tri = [(0, 0), (1, 0), (0, 1)]
        assert solve_case(tri) == 3
        # Collinear vertical: 0 intersections
        col = [(0, 0), (0, 2), (0, 4)]
        assert solve_case(col) == 0
        # Rectangle corners: 13
        rect = [(0, 0), (1, 0), (1, 1), (0, 1)]
        assert solve_case(rect) == 13
        return
    ans = solve_all(pts)
    print(ans)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Sanity checks on triangles, collinear sets, and rectangles exercise vertical/horizontal/diagonal slopes and deduplication.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Avoid storing every line triplet globally; instead, group on the fly by slope $(d_x,d_y)$ into a map of sets of offsets $k$. This reduces overhead when counting $m_s$ and $L$.}
\ASSUMPTIONS{Same canonical direction; use per-slope set of integer offsets $k=d_y x - d_x y$ to deduplicate lines within the slope.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a dictionary $M$ from slope to set of $k$.
\item For each pair $(p_i,p_j)$, compute $(d_x,d_y)$ and $k$, insert $k$ into $M[(d_x,d_y)]$.
\item Compute $m_s=\lvert M[s]\rvert$, $L=\sum_s m_s$, and return $\binom{L}{2}-\sum_s\binom{m_s}{2}$.
\end{algosteps}
\COMPLEXITY{Same $\Theta(n^2)$ pairs, but memory is organized per slope, and $L$ and $\{m_s\}$ are obtained without a second pass over a global set.}
\[
\begin{aligned}
T(n) &= \Theta(n^2) \\
S(n) &= \Theta\Big(\sum_s m_s\Big) = \Theta(L) \le \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{Within a fixed slope, $k$ uniquely identifies parallel translates; distinct slopes guarantee intersection.}
\textbf{Code (Improved)}
\begin{minted}{python}
from math import gcd
from collections import defaultdict
import sys

def _normalize_dir(dx: int, dy: int):
    if dx == 0 and dy == 0:
        return (0, 0)
    g = gcd(abs(dx), abs(dy))
    dx //= g
    dy //= g
    if dx < 0 or (dx == 0 and dy < 0):
        dx = -dx
        dy = -dy
    return (dx, dy)

def _pair_slope_k(p, q):
    dx = q[0] - p[0]
    dy = q[1] - p[1]
    dx, dy = _normalize_dir(dx, dy)
    k = dy * p[0] - dx * p[1]
    return (dx, dy, k)

def _read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    return pts

def read_input():
    data = sys.stdin.buffer.read().decode()
    if not data.strip():
        return None
    return _read_input(data)

def solve_case(points):
    n = len(points)
    slope_to_ks = defaultdict(set)
    for i in range(n):
        pi = points[i]
        for j in range(i+1, n):
            pj = points[j]
            dx, dy, k = _pair_slope_k(pi, pj)
            slope_to_ks[(dx, dy)].add(k)
    counts = [len(s) for s in slope_to_ks.values()]
    L = sum(counts)
    total_pairs = L * (L - 1) // 2
    parallel_pairs = sum(c * (c - 1) // 2 for c in counts)
    return total_pairs - parallel_pairs

def solve_all(points):
    return solve_case(points)

def main():
    pts = read_input()
    if pts is None:
        # Self-tests
        tri = [(0, 0), (1, 0), (0, 1)]
        assert solve_case(tri) == 3
        col = [(0, 0), (0, 2), (0, 4)]
        assert solve_case(col) == 0
        rect = [(0, 0), (1, 0), (1, 1), (0, 1)]
        assert solve_case(rect) == 13
        # Random-like simple check: two parallel lines with 2 points each
        pts2 = [(0, 0), (1, 0), (0, 1), (1, 1)]
        # Unique lines: y=0, y=1, x=0, x=1, y=x, y=1-x -> 6, answer 13
        assert solve_case(pts2) == 13
        return
    print(solve_all(pts))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge inputs with vertical-only, horizontal-only, and mixed slopes; duplicates across many pairs still dedupe correctly via per-slope $k$ sets.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use integer-normalized direction vectors and per-slope integer offsets to deduplicate lines in $O(n^2)$ without floating point; compute $L$ and $\{m_s\}$ in one pass and apply $\binom{L}{2}-\sum_s\binom{m_s}{2}$.}
\ASSUMPTIONS{All coordinates are integers and $n\le 1000$, so $\Theta(n^2)$ processing is feasible; integer arithmetic prevents precision issues.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each unordered pair of distinct points, compute reduced direction $(d_x,d_y)$ and offset $k=d_y x - d_x y$.
\item Insert $k$ into a set keyed by the slope $(d_x,d_y)$; after all pairs, let $m_s$ be the size of each set and $L=\sum_s m_s$.
\item Return $\binom{L}{2}-\sum_s\binom{m_s}{2}$.
\end{algosteps}
\OPTIMALITY{Any algorithm must examine $\Omega(L)$ lines; since $L\le \binom{n}{2}$ and $n\le 1000$, an $O(n^2)$ approach is tight up to constants. Integer normalization yields canonical representatives, guaranteeing no overcount or undercount.}
\COMPLEXITY{Time $T(n)=\Theta(n^2)$; space $S(n)=\Theta(L)\le \Theta(n^2)$.}
\[
\begin{aligned}
T(n) &= \sum_{i<j} O(1) = \Theta(n^2),\\
S(n) &= \Theta\Big(\sum_s m_s\Big)=\Theta(L)\le \Theta\big(\tfrac{n(n-1)}{2}\big).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from math import gcd
from collections import defaultdict
import sys

def normalize_dir(dx: int, dy: int):
    g = gcd(abs(dx), abs(dy))
    dx //= g
    dy //= g
    if dx < 0 or (dx == 0 and dy < 0):
        dx = -dx
        dy = -dy
    return (dx, dy)

def solve_case(points):
    n = len(points)
    slope_to_ks = defaultdict(set)
    for i in range(n):
        xi, yi = points[i]
        for j in range(i+1, n):
            xj, yj = points[j]
            dx = xj - xi
            dy = yj - yi
            dx, dy = normalize_dir(dx, dy)
            k = dy * xi - dx * yi
            slope_to_ks[(dx, dy)].add(k)
    counts = [len(s) for s in slope_to_ks.values()]
    L = sum(counts)
    total_pairs = L * (L - 1) // 2
    parallel_pairs = sum(c * (c - 1) // 2 for c in counts)
    return total_pairs - parallel_pairs

def read_input():
    data = sys.stdin.buffer.read().decode().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    return pts

def solve_all():
    pts = read_input()
    if pts is None:
        # Self-tests (exactly 3 asserts)
        assert solve_case([(0, 0), (1, 0), (0, 1)]) == 3
        assert solve_case([(0, 0), (0, 2), (0, 4)]) == 0
        assert solve_case([(0, 0), (1, 0), (1, 1), (0, 1)]) == 13
        return
    print(solve_case(pts))

def main():
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts: triangle (3), vertical collinear (0), unit square corners (13).}
\RESULT{Print the number of unordered intersecting wire pairs, i.e., pairs of unique lines with different slopes.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: normalization invariants; collinear degeneracy; mixed slope classes; stress on small grids where the answer can be reasoned.}
\LINE{CROSS-CHECKS}{Cross-validate Baseline vs Improved vs Final on the same tiny cases to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate collinear sets, random small subsets of grid points, and repeated slopes with different offsets to test deduplication.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from itertools import product, combinations

def gen_collinear(n, x=0, y0=0, step=1, vertical=True):
    if vertical:
        return [(x, y0 + i*step) for i in range(n)]
    else:
        return [(y0 + i*step, x) for i in range(n)]

def gen_grid_points(w, h):
    return [(x, y) for x, y in product(range(w), range(h))]

def brute_unique_lines(points):
    # For cross-checking: same as Approach A
    from math import gcd
    def norm(dx, dy):
        g = gcd(abs(dx), abs(dy))
        dx //= g; dy //= g
        if dx < 0 or (dx == 0 and dy < 0):
            dx, dy = -dx, -dy
        return dx, dy
    def key(p, q):
        dx, dy = norm(q[0]-p[0], q[1]-p[1])
        k = dy*p[0] - dx*p[1]
        return (dx, dy, k)
    S = set()
    n = len(points)
    for i in range(n):
        for j in range(i+1, n):
            S.add(key(points[i], points[j]))
    return S

def count_intersections(points):
    S = brute_unique_lines(points)
    from collections import Counter
    cnt = Counter((dx, dy) for (dx, dy, k) in S)
    L = len(S)
    total = L*(L-1)//2
    par = sum(c*(c-1)//2 for c in cnt.values())
    return total - par

# Tiny regression suite
assert count_intersections([(0,0),(1,0),(0,1)]) == 3
assert count_intersections(gen_collinear(5)) == 0
assert count_intersections([(0,0),(1,0),(1,1),(0,1)]) == 13
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final CF-ready solution (stdin -> stdout), with asserts guarded when no input.
from math import gcd
from collections import defaultdict
import sys

def normalize_dir(dx: int, dy: int):
    g = gcd(abs(dx), abs(dy))
    dx //= g
    dy //= g
    if dx < 0 or (dx == 0 and dy < 0):
        dx = -dx
        dy = -dy
    return (dx, dy)

def solve_case(points):
    n = len(points)
    slope_to_ks = defaultdict(set)
    for i in range(n):
        xi, yi = points[i]
        for j in range(i+1, n):
            xj, yj = points[j]
            dx, dy = normalize_dir(xj - xi, yj - yi)
            k = dy * xi - dx * yi
            slope_to_ks[(dx, dy)].add(k)
    counts = [len(s) for s in slope_to_ks.values()]
    L = sum(counts)
    total_pairs = L * (L - 1) // 2
    parallel_pairs = sum(c * (c - 1) // 2 for c in counts)
    return total_pairs - parallel_pairs

def read_input():
    data = sys.stdin.buffer.read().decode().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    return pts

def main():
    pts = read_input()
    if pts is None:
        # Quick local asserts (no output)
        assert solve_case([(0, 0), (1, 0), (0, 1)]) == 3
        assert solve_case([(0, 0), (0, 2), (0, 4)]) == 0
        assert solve_case([(0, 0), (1, 0), (1, 1), (0, 1)]) == 13
        return
    print(solve_case(pts))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count unique lines induced by the points, group by slope, and subtract parallel pairs from all line pairs.}
\WHY{This pattern (normalize direction, deduplicate by integer invariants) is common in geometry counting problems with large constraints.}
\CHECKLIST{%
\begin{bullets}
\item Normalize direction by $\gcd$ and fix sign.
\item Use integer invariant $k=d_y x - d_x y$ for per-slope deduplication.
\item Count $m_s$ per slope; compute $L=\sum_s m_s$.
\item Answer via $\binom{L}{2}-\sum_s\binom{m_s}{2}$.
\item Watch vertical/horizontal special cases in normalization.
\end{bullets}}
\EDGECASES{%
\begin{bullets}
\item All points collinear $\Rightarrow L=1$, answer $0$.
\item Many points on the same vertical line.
\item Many parallel lines with distinct offsets.
\item Duplicate pairs generating the same line; ensure dedup.
\item $n=2$ $\Rightarrow L=1$, answer $0$.
\item Points with negative coordinates and mixed quadrants.
\end{bullets}}
\PITFALLS{%
\begin{bullets}
\item Forgetting sign convention for direction leads to double-counted slopes.
\item Using floats for slope/intercept causes precision bugs.
\item Not reducing by $\gcd$ yields distinct keys for the same line.
\item Overflow in other languages if not using 64-bit for counts.
\item Mishandling $(0,0)$ direction (should never occur for distinct points).
\item Mixing ordered vs unordered pairs; final pairs are unordered.
\end{bullets}}
\FAILMODES{Inputs with many collinearities or dense grids break solutions that store duplicate lines or use non-canonical representations. Integer-normalized keys survive these adversarials.}
\ELI{Represent each wire by a reduced direction and an integer offset; wires with the same direction are parallel. Count all wires, subtract the parallel pairs, and you get the number of intersections.}
\NotePages{3}

\end{document}