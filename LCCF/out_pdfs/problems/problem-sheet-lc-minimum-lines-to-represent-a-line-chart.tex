% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Lines to Represent a Line Chart}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given a 2D integer array \texttt{stockPrices} where \texttt{stockPrices[i] = [day\_i, price\_i]} indicates the price of the stock on day \texttt{day\_i} is \texttt{price\_i}. A line chart is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points.

Return the minimum number of lines needed to represent the line chart.

Example 1:

Input: \texttt{stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]}

Output: \texttt{3}

Explanation: The following 3 lines can be drawn to represent the line chart:
\begin{itemize}
\item Line 1 from $(1,7)$ to $(4,4)$ passing through $(1,7)$, $(2,6)$, $(3,5)$, and $(4,4)$.
\item Line 2 from $(4,4)$ to $(5,4)$.
\item Line 3 from $(5,4)$ to $(8,1)$ passing through $(5,4)$, $(6,3)$, $(7,2)$, and $(8,1)$.
\end{itemize}
It can be shown that it is not possible to represent the line chart using fewer than 3 lines.

Example 2:

Input: \texttt{stockPrices = [[3,4],[1,2],[7,8],[2,3]]}

Output: \texttt{1}

Explanation: The line chart can be represented with a single straight line through all points when ordered by day.

Constraints:
\begin{itemize}
\item $1 \le \lvert \texttt{stockPrices}\rvert \le 10^5$
\item $\texttt{stockPrices[i].length} = 2$
\item $1 \le \texttt{day\_i}, \texttt{price\_i} \le 10^9$
\item All \texttt{day\_i} are distinct.
\end{itemize}}
\BREAKDOWN{Sort points by day; connect adjacent points; count how many maximal consecutive segments share the same slope. Use cross-multiplication to compare slopes exactly without floating-point error.}
\ELI{Walk along days in order; every time the slope changes, start a new line.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode function: \texttt{minimumLines(stockPrices: List[List[int]]) -> int}. The input is a list of distinct-day pairs $[d_i, p_i]$ with $1 \le d_i, p_i \le 10^9$ and $1 \le n \le 10^5$.}
\OUTPUTS{Return the minimum number of straight line segments required to draw the polyline when points are sorted by day and connected adjacently. If $n \le 1$, return $0$; if $n=2$, return $1$.}
\SAMPLES{Example A: \texttt{[[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]} $\to$ \texttt{3}. Example B: \texttt{[[3,4],[1,2],[7,8],[2,3]]} $\to$ \texttt{1}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the points sorted by day be $(x_1,y_1),\ldots,(x_n,y_n)$ with $x_1 < \cdots < x_n$. Define segment slopes between consecutive points as $\Delta y_i = y_{i+1}-y_i$, $\Delta x_i = x_{i+1}-x_i$ for $i=1,\ldots,n-1$. The desired answer is the count of maximal runs of equal slopes among consecutive segments.}
\varmapStart
\var{n}{number of points}
\var{(x_i,y_i)}{the $i$-th point after sorting by day}
\var{\Delta x_i,\ \Delta y_i}{differences between consecutive points}
\var{\text{ans}}{number of line segments drawn}
\varmapEnd
\GOVERN{
\[
\text{ans} =
\begin{cases}
0, & n \le 1,\\
1 + \sum\limits_{i=2}^{n-1} \mathbf{1}\Big( \Delta y_i \cdot \Delta x_{i-1} \ne \Delta y_{i-1} \cdot \Delta x_i \Big), & n \ge 2,
\end{cases}
\]
}
\ASSUMPTIONS{Days are strictly increasing after sorting; thus $\Delta x_i > 0$. Equality of rational slopes is tested via exact integer cross-multiplication to avoid precision issues.}
\INVARIANTS{While scanning from left to right, the current active line maintains a constant slope; a new line is started exactly when the next segment's slope differs by the cross-product test.}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============
% (If you add any Formula pages above, no extra notes are required unless desired.)

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Extend from each starting point as far right as possible while all subsequent points remain collinear with the start.}
\ASSUMPTIONS{Sort by day; use integer cross-products for exact collinearity checks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort points by day ascending.
\item Initialize $i=0$ and \texttt{lines}=0.
\item While $i < n-1$: start a new line at $i$; advance $j$ as far as possible such that $(x_j,y_j)$ and $(x_{j+1},y_{j+1})$ are collinear with $(x_i,y_i)$ by cross-products; set $i \gets j$.
\end{algosteps}
\COMPLEXITY{Worst-case $O(n^2)$ comparisons when slopes keep changing minimally; $O(1)$ extra space aside from sorting.}
\[
\begin{aligned}
T(n) &= O(n \log n) \text{ for sorting} + O(n^2) \text{ for nested extension in worst case},\\
S(n) &= O(1) \text{ auxiliary (in-place sort acceptable)}.
\end{aligned}
\]
\CORRECTNESS{Each iteration forms one maximal collinear block starting at $i$; the while-extension stops exactly before the first slope change, ensuring minimal count by greedy maximal extension.}
\EDGECASES{$n \in \{0,1\}$ yields 0; $n=2$ yields 1; plateaus (horizontal $\Delta y=0$) are handled; large coordinates are safe via Python big integers.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class SolutionBaseline:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        pts = sorted(stockPrices)  # sort by day
        n = len(pts)
        if n <= 1:
            return 0
        lines = 0
        i = 0
        while i < n - 1:
            lines += 1
            j = i + 1
            # Extend as far as all points remain collinear with anchor i
            while j + 1 < n:
                x0, y0 = pts[i]
                x1, y1 = pts[j]
                x2, y2 = pts[j + 1]
                # Check collinearity of (x0,y0), (x1,y1), (x2,y2)
                if (y1 - y0) * (x2 - x0) == (y2 - y0) * (x1 - x0):
                    j += 1
                else:
                    break
            i = j
        return lines

# Tiny tests
if __name__ == "__main__":
    sb = SolutionBaseline()
    assert sb.minimumLines([[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]) == 3
    assert sb.minimumLines([[3,4],[1,2],[7,8],[2,3]]) == 1
    assert sb.minimumLines([[1,1]]) == 0
\end{minted}
\VALIDATION{Checked sample cases and single-point trivial case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Normalized Slope Tracking}
\WHICHFORMULA{Track the reduced slope vector $(\Delta x/\gcd,\ \Delta y/\gcd)$ between consecutive points; increment when the reduced slope changes.}
\ASSUMPTIONS{Sorting by day; $\Delta x>0$ ensures a canonical orientation, so simply dividing by $\gcd(|\Delta x|,|\Delta y|)$ normalizes the slope.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort the points by day.
\item If $n \le 1$ return $0$; else initialize \texttt{lines}$=1$ and store the reduced slope of segment $[1] \to [2]$.
\item For each $i=2$ to $n-1$, compute reduced slope of segment $[i] \to [i+1]$ and compare to previous; increment \texttt{lines} on change.
\end{algosteps}
\COMPLEXITY{One pass after sorting: $O(n \log n)$ total due to sort; per-step work $O(\log C)$ for \texttt{gcd}, where $C$ bounds coordinate differences.}
\[
\begin{aligned}
T(n) &= O(n \log n) + O(n \log C),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Reduced slope equality is equivalent to rational slope equality, so counting runs of identical reduced slopes yields the minimal segment partition.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from math import gcd

class SolutionGCD:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        pts = sorted(stockPrices)
        n = len(pts)
        if n <= 1:
            return 0
        # Initial slope
        dx = pts[1][0] - pts[0][0]
        dy = pts[1][1] - pts[0][1]
        g = gcd(abs(dx), abs(dy))
        pdx, pdy = dx // g, dy // g
        lines = 1
        for i in range(1, n - 1):
            dx = pts[i + 1][0] - pts[i][0]
            dy = pts[i + 1][1] - pts[i][1]
            g = gcd(abs(dx), abs(dy))
            ndx, ndy = dx // g, dy // g
            if ndx != pdx or ndy != pdy:
                lines += 1
                pdx, pdy = ndx, ndy
        return lines

# Tiny tests
if __name__ == "__main__":
    sg = SolutionGCD()
    assert sg.minimumLines([[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]) == 3
    assert sg.minimumLines([[3,4],[1,2],[7,8],[2,3]]) == 1
    assert sg.minimumLines([[1,1],[2,1]]) == 1
\end{minted}
\VALIDATION{Verified on the two samples and a horizontal segment case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-Pass Cross-Multiplication After Sorting}
\WHICHFORMULA{Count changes in consecutive-segment slopes using integer cross-products: $\Delta y_i \cdot \Delta x_{i-1} \ne \Delta y_{i-1} \cdot \Delta x_i$.}
\ASSUMPTIONS{Days are distinct; sorting gives strictly increasing $x$. Integer arithmetic prevents precision loss and overflow concerns in Python.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort points by day ascending.
\item If $n \le 1$, return $0$; else initialize \texttt{lines}$=1$.
\item For $i=2$ to $n-1$, compute $\Delta x_{i-1}, \Delta y_{i-1}$ and $\Delta x_i, \Delta y_i$. If cross-products differ, increment \texttt{lines}.
\end{algosteps}
\OPTIMALITY{Single pass after sort; any solution must at least inspect all points and identify slope changes. This achieves the minimal number by greedily merging maximal runs of equal slopes.}
\COMPLEXITY{$O(n \log n)$ time due to sorting and $O(n)$ scan; $O(1)$ extra space.}
\[
\begin{aligned}
T(n) &= O(n \log n),\quad S(n)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        pts = sorted(stockPrices)
        n = len(pts)
        if n <= 1:
            return 0
        lines = 1
        for i in range(2, n):
            x0, y0 = pts[i - 2]
            x1, y1 = pts[i - 1]
            x2, y2 = pts[i]
            dy1 = y1 - y0
            dx1 = x1 - x0
            dy2 = y2 - y1
            dx2 = x2 - x1
            if dy2 * dx1 != dy1 * dx2:
                lines += 1
        return lines

# Exactly 3 asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumLines([[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]) == 3
    assert sol.minimumLines([[3,4],[1,2],[7,8],[2,3]]) == 1
    assert sol.minimumLines([[1,1]]) == 0
\end{minted}
\VALIDATION{Ran the provided examples and a single-point case.}
\RESULT{Return the minimal number of straight segments needed; ties do not arise because the count is uniquely determined by slope changes in day order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: trivial sizes ($n=0,1,2$), monotone slope sequences, horizontal and vertical-like differences (vertical segments cannot occur due to distinct days), alternating slopes, and long collinear runs.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Optimal on small crafted sets; ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate sequences with: all collinear; single plateau; multiple plateaus; alternating up/down; random-ish arithmetic sequences ensuring distinct days.}
\begin{minted}{python}
from typing import List
from random import Random

def gen_cases() -> List[List[List[int]]]:
    cases = []
    # trivial
    cases.append([])
    cases.append([[1, 5]])
    cases.append([[2, 3], [1, 1]])
    # all collinear y = 2x + 1
    cases.append([[i, 2*i + 1] for i in range(1, 8)])
    # plateau then down
    cases.append([[1,5],[2,5],[3,5],[4,3],[5,1]])
    # alternating slopes
    cases.append([[1,1],[2,3],[3,2],[4,4],[5,3],[6,5]])
    # random-ish but deterministic via LCG
    rng = Random(12345)
    days = list(range(1, 21))
    prices = []
    cur = 100
    for _ in days:
        cur += rng.randrange(-3, 4)
        prices.append(cur)
    cases.append([[d, p] for d, p in zip(days, prices)])
    return cases

# Reference solution (Optimal)
class Reference:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        pts = sorted(stockPrices)
        n = len(pts)
        if n <= 1:
            return 0
        lines = 1
        for i in range(2, n):
            x0, y0 = pts[i - 2]
            x1, y1 = pts[i - 1]
            x2, y2 = pts[i]
            dy1 = y1 - y0
            dx1 = x1 - x0
            dy2 = y2 - y1
            dx2 = x2 - x1
            if dy2 * dx1 != dy1 * dx2:
                lines += 1
        return lines

# Cross-check with baseline on small cases
if __name__ == "__main__":
    from math import isfinite
    rb = Reference()
    from typing import Tuple

    # Reuse Baseline
    class SolutionBaseline:
        def minimumLines(self, stockPrices: List[List[int]]) -> int:
            pts = sorted(stockPrices)
            n = len(pts)
            if n <= 1:
                return 0
            lines = 0
            i = 0
            while i < n - 1:
                lines += 1
                j = i + 1
                while j + 1 < n:
                    x0, y0 = pts[i]
                    x1, y1 = pts[j]
                    x2, y2 = pts[j + 1]
                    if (y1 - y0) * (x2 - x0) == (y2 - y0) * (x1 - x0):
                        j += 1
                    else:
                        break
                i = j
            return lines

    sb = SolutionBaseline()
    for case in gen_cases():
        assert rb.minimumLines(case) == sb.minimumLines(case)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        pts = sorted(stockPrices)
        n = len(pts)
        if n <= 1:
            return 0
        lines = 1
        for i in range(2, n):
            x0, y0 = pts[i - 2]
            x1, y1 = pts[i - 1]
            x2, y2 = pts[i]
            dy1 = y1 - y0
            dx1 = x1 - x0
            dy2 = y2 - y1
            dx2 = x2 - x1
            if dy2 * dx1 != dy1 * dx2:
                lines += 1
        return lines

if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumLines([[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]) == 3
    assert sol.minimumLines([[3,4],[1,2],[7,8],[2,3]]) == 1
    assert sol.minimumLines([[1,1]]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort by day, then count slope changes via integer cross-multiplication.}
\WHY{A classic adjacent-slope-run counting pattern; tests slope equality robustly without floats.}
\CHECKLIST{%
\begin{bullets}
\item Sort by day strictly ascending.
\item Handle $n \le 1 \Rightarrow 0$, $n=2 \Rightarrow 1$.
\item Initialize answer to $1$ when $n \ge 2$.
\item Use cross-products to compare slopes exactly.
\item Increment count only when consecutive slopes differ.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item Single point $\to 0$ lines.
\item Two points $\to 1$ line.
\item Long collinear run $\to 1$ line.
\item Plateaus (horizontal segments) merged correctly.
\item Large coordinates up to $10^9$.
\item Unequal day gaps; ensure only adjacency matters.
\item Negative slope sequences.
\item Mixed slopes with repeated changes.
\item Duplicate prices allowed; duplicate days not allowed.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to sort by day leads to wrong adjacency.
\item Using floats for slope comparison causing precision errors.
\item Off-by-one when initializing answer or loop starting at $i=2$.
\item Not handling $n \le 1$ correctly.
\item Integer overflow in fixed-width languages if multiplying without 64-bit; use Python big ints or 128-bit in C++.
\item Normalizing slope with \texttt{gcd} but mishandling sign; here $\Delta x>0$ avoids sign ambiguity.
\item Treating non-adjacent collinearity; only adjacent edges matter.
\item Miscounting when three consecutive points are collinear; should not increment.
\end{bullets}
}
\FAILMODES{Greedy that checks non-adjacent collinearity or unsorted input will overcount lines. The cross-product adjacency scan is invariant to day gaps and robust to equal prices.}
\ELI{Draw the points in time order and connect neighbors. If the direction of movement stays the same, keep the same line; whenever the direction changes, start a new one. Count how many times that happens plus one.}
\NotePages{3}

\end{document}