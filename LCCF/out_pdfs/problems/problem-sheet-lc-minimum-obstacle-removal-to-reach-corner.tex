% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Obstacle Removal to Reach Corner}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a 0-indexed 2D integer array \texttt{grid} of size $m \times n$. Each cell has one of two values:
\begin{bullets}
\item \texttt{0} represents an empty cell,
\item \texttt{1} represents an obstacle that may be removed.
\end{bullets}
You can move up, down, left, or right from and to an empty cell. Return the minimum number of obstacles to remove so you can move from the upper left corner $(0,0)$ to the lower right corner $(m-1,n-1)$.

Example 1:

Input: \texttt{grid = [[0,1,1],[1,1,0],[1,1,0]]}\\
Output: \texttt{2}\\
Explanation: We can remove the obstacles at $(0,1)$ and $(0,2)$ to create a path from $(0,0)$ to $(2,2)$. It can be shown that we need to remove at least 2 obstacles, so we return 2. Note that there may be other ways to remove 2 obstacles to create a path.

Example 2:

Input: \texttt{grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]}\\
Output: \texttt{0}\\
Explanation: We can move from $(0,0)$ to $(2,4)$ without removing any obstacles, so we return 0.

Constraints:
\begin{bullets}
\item $m = \texttt{len(grid)}$,
\item $n = \texttt{len(grid[i])}$,
\item $1 \le m,n \le 10^5$,
\item $2 \le m \times n \le 10^5$,
\item $\texttt{grid}[i][j] \in \{0,1\}$,
\item $\texttt{grid}[0][0] = \texttt{grid}[m-1][n-1] = 0$.
\end{bullets}}
\BREAKDOWN{Model the grid as a graph with 4-neighbor moves and edge cost equal to the obstacle indicator of the destination cell. Compute the minimum cost from $(0,0)$ to $(m-1,n-1)$.}
\ELI{Treat empty steps as cost 0 and obstacle steps as cost 1, then find the cheapest path using 0--1 BFS or Dijkstra.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of lists \texttt{grid} representing an $m \times n$ binary matrix:
\begin{bullets}
\item Type: \texttt{List[List[int]]}.
\item Values: each cell is $0$ (empty) or $1$ (obstacle).
\item Bounds: $1 \le m,n \le 10^5$ and $2 \le m \times n \le 10^5$; corners are empty.
\end{bullets}}
\OUTPUTS{An integer: the minimum number of obstacles to remove to reach $(m-1,n-1)$ from $(0,0)$ using 4-directional moves.}
\SAMPLES{
Example A: \texttt{grid = [[0,1,1],[1,1,0],[1,1,0]]} $\to$ \texttt{2}

Example B: \texttt{grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]} $\to$ \texttt{0}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the grid define a directed graph $G=(V,E)$ with $V=\{(i,j): 0 \le i < m, 0 \le j < n\}$ and edges between 4-neighbors. For an edge from $(i,j)$ to $(i',j')$, define cost $w((i,j)\to(i',j'))=\texttt{grid}[i'][j'] \in \{0,1\}$. Seek the minimum path cost from $s=(0,0)$ to $t=(m-1,n-1)$.}
\varmapStart
\var{m,n}{grid dimensions}
\var{G=(V,E)}{grid graph with 4-neighborhood}
\var{w(e)}{edge weight in $\{0,1\}$ equal to destination cell value}
\var{s,t}{source $(0,0)$ and target $(m-1,n-1)$}
\var{d(u)}{shortest-path distance from $s$ to node $u$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
d(s) &= 0,\\
d(u) &= \min_{(v,u)\in E}\bigl(d(v) + w(v\to u)\bigr)\quad \text{for } u\in V,\\
\text{Answer} &= d(t).
\end{aligned}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item 4-neighbor moves only.
\item Start and end cells are empty, so a feasible path exists in the graph sense (though may require removals).
\item Edge costs are nonnegative and integral ($0$ or $1$), enabling 0--1 BFS.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item For Dijkstra/0--1 BFS, once a node is popped/finalized, its $d(u)$ is minimal.
\item Distances are monotone nondecreasing along any path extension.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Single-source shortest path on a nonnegative weighted grid using Dijkstra with a min-heap.}
\ASSUMPTIONS{Treat moving into an obstacle as paying cost $1$ (removal), into empty as cost $0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $d[i][j]\gets\infty$, set $d[0][0]\gets 0$; push $(0,0,0)$ into a min-heap keyed by cost.
\item While heap nonempty, pop $(c,i,j)$. If $c>d[i][j]$, continue. For each neighbor $(x,y)$, let $nc=c+\texttt{grid}[x][y]$. Relax if $nc<d[x][y]$ and push.
\item Return $d[m-1][n-1]$.
\end{algosteps}
\COMPLEXITY{Binary-heap Dijkstra on $|V|=mn$, $|E|\approx 4mn$:
\[
\begin{aligned}
T(n) &\in O\big((mn)\log(mn) + (4mn)\log(mn)\big) = O\big(mn\log(mn)\big),\\
S(n) &\in O(mn).
\end{aligned}
\]
}
\CORRECTNESS{Dijkstra is correct on graphs with nonnegative edge weights; each relaxation maintains $d(u)$ as an upper bound on the true shortest distance, and nodes are finalized in nondecreasing order of true distance.}
\EDGECASES{
\begin{bullets}
\item Single row or column.
\item All zeros (answer $0$).
\item Narrow corridors requiring selective removals.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Deque, Tuple
import heapq

class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        INF = 10**9
        dist = [[INF] * n for _ in range(m)]
        dist[0][0] = 0
        pq: List[Tuple[int, int, int]] = [(0, 0, 0)]  # (cost, r, c)
        DIRS = ((1, 0), (-1, 0), (0, 1), (0, -1))

        while pq:
            c, r, q = heapq.heappop(pq)
            if c != dist[r][q]:
                continue
            if (r, q) == (m - 1, n - 1):
                return c
            for dr, dq in DIRS:
                nr, nq = r + dr, q + dq
                if 0 <= nr < m and 0 <= nq < n:
                    nc = c + grid[nr][nq]
                    if nc < dist[nr][nq]:
                        dist[nr][nq] = nc
                        heapq.heappush(pq, (nc, nr, nq))
        return dist[m - 1][n - 1]

if __name__ == "__main__":
    s = Solution()
    assert s.minimumObstacles([[0,1,1],[1,1,0],[1,1,0]]) == 2
    assert s.minimumObstacles([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]) == 0
    # Additional tiny check
    assert s.minimumObstacles([[0]]) == 0
\end{minted}
\VALIDATION{Cross-check the two examples and a trivial $1\times1$ grid.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use 0--1 BFS with a deque because edge costs are $0$ or $1$, eliminating heap $\log$ factors.}
\ASSUMPTIONS{Weights are binary $\{0,1\}$; pushing front for $0$-cost edges and back for $1$-cost edges preserves correctness.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize distance grid with $\infty$; set $d[0][0]\gets 0$; deque $\gets [(0,0)]$.
\item Pop from left; for each neighbor, compute $nd=d[r][c]+\texttt{grid}[nr][nc]$; if improved, update and pushleft if $0$-cost, else pushright.
\item Stop when target is popped or deque empties; return $d[m-1][n-1]$.
\end{algosteps}
\COMPLEXITY{Each edge is processed a constant number of times; each vertex enters deque at most twice:
\[
\begin{aligned}
T(n) &\in O(mn),\\
S(n) &\in O(mn).
\end{aligned}
\]
}
\CORRECTNESS{Standard 0--1 BFS invariant: the deque maintains nodes in nondecreasing tentative distance; front pops finalize minimal distance under binary weights.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Deque
from collections import deque

class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        INF = 10**9
        dist = [[INF] * n for _ in range(m)]
        dist[0][0] = 0
        dq: Deque[tuple[int, int]] = deque()
        dq.append((0, 0))
        DIRS = ((1, 0), (-1, 0), (0, 1), (0, -1))

        while dq:
            r, c = dq.popleft()
            if (r, c) == (m - 1, n - 1):
                return dist[r][c]
            for dr, dc in DIRS:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n:
                    w = grid[nr][nc]
                    nd = dist[r][c] + w
                    if nd < dist[nr][nc]:
                        dist[nr][nc] = nd
                        if w == 0:
                            dq.appendleft((nr, nc))
                        else:
                            dq.append((nr, nc))
        return dist[m - 1][n - 1]

if __name__ == "__main__":
    s = Solution()
    assert s.minimumObstacles([[0,1,1],[1,1,0],[1,1,0]]) == 2
    assert s.minimumObstacles([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]) == 0
    # Edge: single row
    assert s.minimumObstacles([[0,0,1,0,0]]) == 0
\end{minted}
\VALIDATION{Check examples and a single-row case with a bypass available (cost $0$).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{0--1 BFS on the grid graph is optimal for binary edge weights and runs in linear time.}
\ASSUMPTIONS{All moves cost $0$ or $1$; the grid fits in memory with $m \times n \le 10^5$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $d$ with $\infty$, $d[0][0]\gets 0$, deque with $(0,0)$.
\item Pop-left; for each neighbor, relax and pushleft on $0$-cost, pushright on $1$-cost edges.
\item When $(m-1,n-1)$ is popped or queue drains, return $d[m-1][n-1]$.
\end{algosteps}
\OPTIMALITY{Lower bound equals the shortest-path cost in the defined graph. 0--1 BFS attains this bound by exploring vertices in nondecreasing distance order without heap overhead; thus time is $O(mn)$ and tight up to constants.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &\in O(mn),\quad S(n) \in O(mn).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Deque
from collections import deque

class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        INF = 10**9
        dist = [[INF] * n for _ in range(m)]
        dist[0][0] = 0
        dq: Deque[tuple[int, int]] = deque([(0, 0)])
        DIRS = ((1, 0), (-1, 0), (0, 1), (0, -1))

        while dq:
            r, c = dq.popleft()
            if (r, c) == (m - 1, n - 1):
                return dist[r][c]
            drc = dist[r][c]
            for dr, dc in DIRS:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n:
                    w = grid[nr][nc]
                    nd = drc + w
                    if nd < dist[nr][nc]:
                        dist[nr][nc] = nd
                        if w == 0:
                            dq.appendleft((nr, nc))
                        else:
                            dq.append((nr, nc))
        return dist[m - 1][n - 1]

if __name__ == "__main__":
    s = Solution()
    # 1) Provided examples
    assert s.minimumObstacles([[0,1,1],[1,1,0],[1,1,0]]) == 2
    assert s.minimumObstacles([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]) == 0
    # 2) Narrow corridor requiring removals
    assert s.minimumObstacles([[0,1,1,1],[0,0,0,1],[1,1,0,0]]) == 1
\end{minted}
\VALIDATION{Exactly three asserts: both official examples and a crafted corridor where exactly one removal is optimal.}
\RESULT{Returns the minimum number of obstacles to remove to enable a 4-directional path from the top-left to the bottom-right cell.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small grids; properties:
\begin{bullets}
\item All-zero grids return $0$.
\item Symmetry under transposition preserves answer.
\item Adding a wall of ones across a cut increases the answer by at least $1$ unless a detour exists.
\end{bullets}}
\LINE{CROSS-CHECKS}{Compare Dijkstra (Approach A) and 0--1 BFS (Approach B/C) on random $m \times n \le 6$ grids; answers must match.}
\LINE{EDGE-CASE GENERATOR}{Generate degenerate lines, checkerboards, and random sparse/dense obstacle fields to stress transitions between $0$ and $1$ costs.}
\begin{minted}{python}
from typing import List
import random

def gen_grid(m: int, n: int, p_one: float, seed: int = 0) -> List[List[int]]:
    rnd = random.Random(seed)
    g = [[1 if rnd.random() < p_one else 0 for _ in range(n)] for _ in range(m)]
    g[0][0] = 0
    g[m-1][n-1] = 0
    return g

# Tiny cross-check harness
def brute_dijkstra(grid: List[List[int]]) -> int:
    import heapq
    m, n = len(grid), len(grid[0])
    INF = 10**9
    dist = [[INF]*n for _ in range(m)]
    dist[0][0] = 0
    pq = [(0, 0, 0)]
    DIRS = ((1,0),(-1,0),(0,1),(0,-1))
    while pq:
        c, r, c2 = heapq.heappop(pq)
        if c != dist[r][c2]:
            continue
        if (r, c2) == (m-1, n-1):
            return c
        for dr, dc in DIRS:
            nr, nc = r+dr, c2+dc
            if 0 <= nr < m and 0 <= nc < n:
                ncst = c + grid[nr][nc]
                if ncst < dist[nr][nc]:
                    dist[nr][nc] = ncst
                    heapq.heappush(pq, (ncst, nr, nc))
    return dist[m-1][n-1]

def zero_one_bfs(grid: List[List[int]]) -> int:
    from collections import deque
    m, n = len(grid), len(grid[0])
    INF = 10**9
    dist = [[INF]*n for _ in range(m)]
    dist[0][0] = 0
    dq = deque([(0,0)])
    DIRS = ((1,0),(-1,0),(0,1),(0,-1))
    while dq:
        r, c = dq.popleft()
        if (r, c) == (m-1, n-1):
            return dist[r][c]
        for dr, dc in DIRS:
            nr, nc = r+dr, c+dc
            if 0 <= nr < m and 0 <= nc < n:
                w = grid[nr][nc]
                nd = dist[r][c] + w
                if nd < dist[nr][nc]:
                    dist[nr][nc] = nd
                    if w == 0:
                        dq.appendleft((nr, nc))
                    else:
                        dq.append((nr, nc))
    return dist[m-1][n-1]

def self_test():
    # Random small cases cross-check
    for m in range(1, 5):
        for n in range(1, 5):
            for seed in range(10):
                g = gen_grid(m, n, p_one=0.4, seed=seed)
                assert brute_dijkstra(g) == zero_one_bfs(g)
    print("Cross-checks passed.")

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Deque
from collections import deque

class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        INF = 10**9
        dist = [[INF] * n for _ in range(m)]
        dist[0][0] = 0
        dq: Deque[tuple[int, int]] = deque([(0, 0)])
        DIRS = ((1, 0), (-1, 0), (0, 1), (0, -1))

        while dq:
            r, c = dq.popleft()
            if (r, c) == (m - 1, n - 1):
                return dist[r][c]
            base = dist[r][c]
            for dr, dc in DIRS:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n:
                    w = grid[nr][nc]
                    nd = base + w
                    if nd < dist[nr][nc]:
                        dist[nr][nc] = nd
                        if w == 0:
                            dq.appendleft((nr, nc))
                        else:
                            dq.append((nr, nc))
        return dist[m - 1][n - 1]

if __name__ == "__main__":
    s = Solution()
    assert s.minimumObstacles([[0,1,1],[1,1,0],[1,1,0]]) == 2
    assert s.minimumObstacles([[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]) == 0
    assert s.minimumObstacles([[0]]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the minimum number of obstacles to remove, i.e., the shortest path with binary edge costs on a grid.}
\WHY{A classic reduction to shortest paths that tests recognition of 0--1 BFS and careful grid handling.}
\CHECKLIST{
\begin{bullets}
\item Model moves and costs correctly (cost is on entering the neighbor).
\item Choose 0--1 BFS for binary costs.
\item Initialize distances and early exit when reaching target.
\item Guard bounds on neighbors.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $1\times1$ grid.
\item Single row or column.
\item All zeros vs. all ones except endpoints.
\item Multiple equal-cost routes.
\item Narrow passages and dead ends.
\item Large rectangular grids near the $10^5$ cell limit.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Charging the cost of the current cell instead of the destination.
\item Using standard BFS (incorrect with cost-$1$ edges).
\item Forgetting to push to the front on $0$-cost transitions in 0--1 BFS.
\item Not checking stale distances when using a heap-based approach.
\item Overflows not an issue in Python, but be careful with large sentinels and comparisons.
\item Early return only after popping the target from deque (guarantees minimality).
\end{bullets}}
\FAILMODES{
\begin{bullets}
\item Greedy local removal counts can fail on mazes with backtracking; shortest path methods avoid this.
\item Plain BFS miscounts when any $1$-cost edge exists; 0--1 BFS/Dijkstra survive due to proper ordering.
\end{bullets}}
\ELI{Think of walking on tiles: stepping onto a rock costs $1$, onto floor costs $0$. Always choose the path with the least total rock steps. 0--1 BFS finds this cheapest route efficiently.}
\NotePages{3}

\end{document}