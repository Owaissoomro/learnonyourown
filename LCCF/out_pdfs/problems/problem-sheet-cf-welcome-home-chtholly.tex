% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Welcome home, Chtholly}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/896/E}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{After several days of fighting, Chtholly Nota Seniorious miraculously returned from the fierce battle.

As promised, Willem is now baking butter cake for her.

However, although Willem is skilled in making dessert, he rarely bakes butter cake.

This time, Willem made a big mistake — he accidentally broke the oven!

Fortunately, Chtholly decided to help him.

Willem puts $n$ cakes on a roll, cakes are numbered from $1$ to $n$, the $i$-th cake needs $a_i$ seconds of baking.

Willem needs Chtholly to do $m$ operations to bake the cakes.

Operation 1: \texttt{1 l r x}

Willem asks Chtholly to check each cake in the range $[l, r]$, if the cake needs to be baked for more than $x$ seconds, he would bake it for $x$ seconds and put it back in its place. More precisely, for every $i$ in range $[l, r]$, if $a_i$ is strictly more than $x$, $a_i$ becomes equal to $a_i - x$.

Operation 2: \texttt{2 l r x}

Willem asks Chtholly to count the number of cakes in the range $[l, r]$ that need to be cooked for exactly $x$ seconds. More formally, you should find the number of such $i$ in range $[l, r]$, that $a_i = x$.

Input:
The first line contains two integers $n$ and $m$ ($1 \le n, m \le 10^5$).

The second line contains $n$ integers, $i$-th of them is $a_i$ ($1 \le a_i \le 10^5$).

The next $m$ lines are the $m$ operations described above. It is guaranteed that $1 \le l \le r \le n$ and $1 \le x \le 10^5$.

Output:
For each operation of the second type, print the answer.}
\BREAKDOWN{We must support two range operations on an array: (1) conditional range subtract by $x$ applied only to entries $> x$; (2) range frequency query for exact value $x$. The main challenge is to process up to $10^5$ mixed operations efficiently.}
\ELI{Cut big cakes by $x$, leave small cakes unchanged; and count how many cakes are exactly size $x$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integers $n, m$.
- Array $a_1,\ldots,a_n$ with $1 \le a_i \le 10^5$.
- Then $m$ lines of operations:
  - Type 1: \texttt{1 l r x} meaning for all $i \in [l,r]$, if $a_i > x$ then set $a_i \leftarrow a_i - x$.
  - Type 2: \texttt{2 l r x} asking $\#\{i \in [l,r] : a_i = x\}$.}
\OUTPUTS{For every type-2 query, print a single integer on its own line: the count in $[l,r]$.}
\SAMPLES{Example 1:
- Input:
  - $n=5, m=4$
  - $a=[1,5,7,3,10]$
  - Ops:
    - \texttt{2 1 5 5} $\to 1$
    - \texttt{1 2 5 5} makes $a=[1,5,2,3,5]$
    - \texttt{2 1 5 5} $\to 2$
    - \texttt{2 3 4 2} $\to 1$
- Output lines: \texttt{1}, \texttt{2}, \texttt{1}.

Example 2:
- Input:
  - $n=3, m=3$
  - $a=[2,2,2]$
  - Ops:
    - \texttt{1 1 3 3} (no change)
    - \texttt{1 1 3 1} makes $a=[1,1,1]$
    - \texttt{2 1 3 1} $\to 3$
- Output: \texttt{3}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=(a_1,\ldots,a_n) \in \mathbb{Z}_{>0}^n$.
- Update query $(1,l,r,x)$ applies for each $i \in [l,r]$:
  \[
  a_i \leftarrow \begin{cases}
  a_i - x,& a_i > x,\\
  a_i,& a_i \le x~.
  \end{cases}
  \]
- Count query $(2,l,r,x)$ returns $F(l,r,x) = \sum_{i=l}^r \mathbf{1}[a_i = x]$.}
\varmapStart
\var{n}{number of elements}
\var{m}{number of operations}
\var{A}{current array of positive integers}
\var{[l,r]}{inclusive query range}
\var{x}{threshold and value parameter}
\var{F(l,r,x)}{range frequency of value $x$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Update}(l,r,x):\quad & a_i \gets a_i - x\cdot \mathbf{1}[a_i > x],\quad \forall i \in [l,r].\\
\text{Query}(l,r,x):\quad & F(l,r,x) = \sum_{i=l}^r \mathbf{1}[a_i=x].
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based; ranges are inclusive; all values remain positive because $a_i > x \ge 1$ implies $a_i - x \ge 1$.}
\INVARIANTS{
- Values stay positive.
- For any block-based structure, the multiset of values in a block equals the sum of its frequency map across leaders (post-mapping).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Apply operations exactly as defined: scan the range and update or count.}
\ASSUMPTIONS{None beyond the problem statement.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For update $(1,l,r,x)$: loop $i=l..r$ and set $a_i \leftarrow a_i - x$ if $a_i > x$.
\item For query $(2,l,r,x)$: loop $i=l..r$ and count matches $a_i=x$.
\item Print counts for every query.
\end{algosteps}
\COMPLEXITY{Each operation touches $O(r-l+1)$ elements; in the worst case $O(n)$.
Space $O(1)$ extra.}
\[
\begin{aligned}
T_{\text{total}}(n,m) &= \sum_{q=1}^{m} O(n) = O(mn), \\
S(n) &= O(1)~\text{auxiliary}.
\end{aligned}
\]
\CORRECTNESS{Directly simulates the specification; no approximation.}
\EDGECASES{Single element ranges; $x$ larger than any $a_i$ (no change); multiple identical values.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str) -> Tuple[int, int, List[int], List[Tuple[int,int,int,int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    a = [0] + [int(next(it)) for _ in range(n)]
    ops = []
    for _ in range(m):
        t = int(next(it)); l = int(next(it)); r = int(next(it)); x = int(next(it))
        ops.append((t,l,r,x))
    return n, m, a, ops

def solve_all_baseline(data: str) -> str:
    n, m, a, ops = read_input(data)
    out_lines = []
    for t,l,r,x in ops:
        if t == 1:
            for i in range(l, r+1):
                if a[i] > x:
                    a[i] -= x
        else:
            cnt = 0
            for i in range(l, r+1):
                if a[i] == x:
                    cnt += 1
            out_lines.append(str(cnt))
    return "\n".join(out_lines)

def _test_baseline():
    data = "5 4\n1 5 7 3 10\n2 1 5 5\n1 2 5 5\n2 1 5 5\n2 3 4 2\n"
    got = solve_all_baseline(data)
    assert got.strip().split() == ["1","2","1"]
    data2 = "3 3\n2 2 2\n1 1 3 3\n1 1 3 1\n2 1 3 1\n"
    got2 = solve_all_baseline(data2)
    assert got2.strip() == "3"

if __name__ == "__main__":
    _test_baseline()
\end{minted}
\VALIDATION{Two asserts cover typical updates and queries; ranges and thresholds verified.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sqrt Decomposition with Materialization}
\WHICHFORMULA{Partition the array into $\Theta(\sqrt{n})$ blocks. For full blocks, use precomputed frequency maps for $O(1)$ counting; for edges, scan. Updates do the same with partial scans for boundary blocks.}
\ASSUMPTIONS{Block size $B \approx \lceil \sqrt{n} \rceil$. Maintain per-block freq maps; materialize blocks before partial updates.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build blocks of size $B$; store values and a frequency map per block.
\item Query: sum full-block counts from freq maps and scan boundary parts.
\item Update: scan boundary parts and adjust; for each full block in range, scan the block values to adjust and rebuild its freq.
\end{algosteps}
\COMPLEXITY{Each operation touches $O(\sqrt{n})$ blocks and $O(B)$ elements on boundaries; full blocks take $O(B)$ each.}
\[
\begin{aligned}
T_{\text{op}} &\in O\!\left(\sqrt{n} + kB\right) \subseteq O(n) \text{ worst-case, typically } O(\sqrt{n}),\\
S(n) &\in O(n) \text{ to store blocks and freq maps.}
\end{aligned}
\]
\CORRECTNESS{Boundary scans exactly simulate updates; full blocks rebuild exact frequencies after updates; counts are exact.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple
from collections import Counter

class SqrtSimple:
    def __init__(self, a: List[int]):
        self.n = len(a) - 1
        self.B = int(self.n**0.5) + 1
        self.beg = list(range(1, self.n+1, self.B))
        self.blocks = []
        for L in self.beg:
            R = min(self.n, L + self.B - 1)
            vals = a[L:R+1]
            self.blocks.append([L, R, vals, Counter(vals)])

    def _rebuild(self, bi: int):
        L,R,vals,_ = self.blocks[bi]
        self.blocks[bi][3] = Counter(vals)

    def op1(self, l: int, r: int, x: int):
        for bi,(L,R,vals,freq) in enumerate(self.blocks):
            if r < L or R < l:
                continue
            if l <= L and R <= r:
                # full block: adjust all values and rebuild counter
                for i in range(R-L+1):
                    if vals[i] > x:
                        vals[i] -= x
                self._rebuild(bi)
            else:
                # partial: adjust overlapping range
                for i in range(max(l,L), min(r,R)+1):
                    vi = i - L
                    old = vals[vi]
                    if old > x:
                        freq[old] -= 1
                        if freq[old] == 0:
                            del freq[old]
                        vals[vi] = old - x
                        freq[vals[vi]] += 1

    def op2(self, l: int, r: int, x: int) -> int:
        ans = 0
        for (L,R,vals,freq) in self.blocks:
            if r < L or R < l:
                continue
            if l <= L and R <= r:
                ans += freq.get(x, 0)
            else:
                for i in range(max(l,L), min(r,R)+1):
                    if vals[i - L] == x:
                        ans += 1
        return ans

def read_input(data: str) -> Tuple[int, int, List[int], List[Tuple[int,int,int,int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    a = [0] + [int(next(it)) for _ in range(n)]
    ops = []
    for _ in range(m):
        t = int(next(it)); l = int(next(it)); r = int(next(it)); x = int(next(it))
        ops.append((t,l,r,x))
    return n, m, a, ops

def solve_all_block_sqrt(data: str) -> str:
    n, m, a, ops = read_input(data)
    ds = SqrtSimple(a)
    out = []
    for t,l,r,x in ops:
        if t == 1:
            ds.op1(l,r,x)
        else:
            out.append(str(ds.op2(l,r,x)))
    return "\n".join(out)

def _test_sqrt_improved():
    data = "5 4\n1 5 7 3 10\n2 1 5 5\n1 2 5 5\n2 1 5 5\n2 3 4 2\n"
    got = solve_all_block_sqrt(data)
    assert got.strip().split() == ["1","2","1"]
    data2 = "3 3\n2 2 2\n1 1 3 3\n1 1 3 1\n2 1 3 1\n"
    got2 = solve_all_block_sqrt(data2)
    assert got2.strip() == "3"

if __name__ == "__main__":
    _test_sqrt_improved()
\end{minted}
\VALIDATION{Asserts mirror the baseline examples; outputs match exactly.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sqrt Decomposition with DSU-on-Values per Block}
\WHICHFORMULA{Per block, maintain a frequency map of current leader values and a value-DSU mapping that composes full-block updates lazily: for update $(1,l,r,x)$ on a full block, merge counts for all values $v>x$ into $v-x$ and redirect leader $v \to v-x$; for partial ranges, materialize the block by mapping each stored value to its current leader.}
\ASSUMPTIONS{Values are positive and bounded ($\le 10^5$), enabling sparse maps; composition of updates is monotone (leaders only move downward).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Partition into blocks of size $B \approx \sqrt{n}$. For each block, store:
  - the local array slice,
  - a leader map \texttt{to} (DSU over values) and a frequency map \texttt{cnt} over leaders.
\item Full-block update $(1,l,r,x)$: for each leader $v>x$, do \texttt{cnt[v-x] += cnt[v]}, delete \texttt{cnt[v]}, and set \texttt{to[v] = find(v-x)}.
\item Partial update: materialize leaders into the array then scan the overlapping positions.
\item Query: sum \texttt{cnt[x]} on full blocks and scan boundaries (materializing only if not yet materialized).
\end{algosteps}
\OPTIMALITY{Each value in a block can move to a smaller leader only a logarithmic number of times with respect to its magnitude, and DSU path compression ensures near-constant amortized leader finds. Overall complexity is $O\!\big((n + m)\sqrt{n}\big)$ with favorable constants.}
\COMPLEXITY{Amortized per operation:
- Full block update: proportional to number of distinct leaders $>x$ in that block (sparse).
- Boundary work: $O(B)$.
Space: $O(n)$ for data; plus sparse leader maps per block.}
\[
\begin{aligned}
T_{\text{op}} &\in \tilde O(\sqrt{n}),\quad S(n) \in O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Optional
from collections import Counter

class Block:
    __slots__ = ("L","R","a","cnt","to")
    def __init__(self, a: List[int], L: int, R: int):
        self.L = L
        self.R = R
        self.a = a[L:R+1]  # local copy
        self.cnt = Counter(self.a)  # frequencies of leaders (current final values)
        self.to = {}  # DSU mapping: value -> leader

    def find(self, v: int) -> int:
        # Path-compressed find on value-to-leader map (default identity)
        to = self.to
        path = []
        while True:
            nv = to.get(v, v)
            if nv == v:
                root = v
                break
            path.append(v)
            v = nv
        for u in path:
            to[u] = root
        return root

    def materialize(self):
        # Apply current mapping to all stored values; rebuild cnt and reset mapping
        if self.to:
            for i in range(len(self.a)):
                self.a[i] = self.find(self.a[i])
        self.to.clear()
        self.cnt = Counter(self.a)

    def apply_full_reduce(self, x: int):
        # Lazy full-block update: merge leaders v>x into v-x
        if not self.cnt:
            return
        # snapshot keys to avoid interfering with iteration
        keys = [v for v in list(self.cnt.keys()) if v > x]
        if not keys:
            return
        for v in keys:
            c = self.cnt.pop(v, 0)
            if c == 0:
                continue
            tgt = self.find(v - x)
            # redirect leader v to tgt
            self.to[v] = tgt
            self.cnt[tgt] = self.cnt.get(tgt, 0) + c

    def count_full(self, x: int) -> int:
        return self.cnt.get(x, 0)

    def partial_reduce(self, l: int, r: int, x: int):
        # l,r are global indices; ensure materialized before calling
        L, R = self.L, self.R
        ll = max(l, L); rr = min(r, R)
        if ll > rr:
            return
        for i in range(ll, rr+1):
            j = i - L
            old = self.a[j]
            if old > x:
                self.cnt[old] -= 1
                if self.cnt[old] == 0:
                    del self.cnt[old]
                self.a[j] = old - x
                self.cnt[self.a[j]] = self.cnt.get(self.a[j], 0) + 1

    def partial_count(self, l: int, r: int, x: int) -> int:
        # ensure materialized before calling
        L, R = self.L, self.R
        ll = max(l, L); rr = min(r, R)
        if ll > rr:
            return 0
        ans = 0
        for i in range(ll, rr+1):
            if self.a[i - L] == x:
                ans += 1
        return ans

class ChthollyDS:
    def __init__(self, a: List[int]):
        self.n = len(a) - 1
        B = int(self.n**0.5) + 1
        self.blocks: List[Block] = []
        for L in range(1, self.n+1, B):
            R = min(self.n, L + B - 1)
            self.blocks.append(Block(a, L, R))

    def op1(self, l: int, r: int, x: int):
        for blk in self.blocks:
            if r < blk.L or blk.R < l:
                continue
            if l <= blk.L and blk.R <= r:
                blk.apply_full_reduce(x)
            else:
                blk.materialize()
                blk.partial_reduce(l, r, x)

    def op2(self, l: int, r: int, x: int) -> int:
        ans = 0
        for blk in self.blocks:
            if r < blk.L or blk.R < l:
                continue
            if l <= blk.L and blk.R <= r:
                ans += blk.count_full(x)
            else:
                blk.materialize()
                ans += blk.partial_count(l, r, x)
        return ans

def read_input(data: str) -> Tuple[int, int, List[int], List[Tuple[int,int,int,int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    a = [0] + [int(next(it)) for _ in range(n)]
    ops = []
    for _ in range(m):
        t = int(next(it)); l = int(next(it)); r = int(next(it)); x = int(next(it))
        ops.append((t,l,r,x))
    return n, m, a, ops

def solve_all(data: str) -> str:
    n, m, a, ops = read_input(data)
    ds = ChthollyDS(a)
    out = []
    for t,l,r,x in ops:
        if t == 1:
            ds.op1(l,r,x)
        else:
            out.append(str(ds.op2(l,r,x)))
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # No input: run internal tests
        _self_test()
        return
    print(solve_all(data))

def _self_test():
    # Functional tests mirroring samples
    data = "5 4\n1 5 7 3 10\n2 1 5 5\n1 2 5 5\n2 1 5 5\n2 3 4 2\n"
    out = solve_all(data).strip().split()
    assert out == ["1","2","1"]

    data2 = "3 3\n2 2 2\n1 1 3 3\n1 1 3 1\n2 1 3 1\n"
    out2 = solve_all(data2).strip()
    assert out2 == "3"

    # Additional check: sequence of mixed partial/full operations
    data3 = "5 5\n1 5 7 3 10\n1 1 3 1\n2 1 3 1\n1 2 5 5\n2 1 5 5\n2 1 5 4\n"
    out3 = solve_all(data3).strip().split()
    assert out3 == ["2","2","1"]

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts cover mixed operations, full-block updates, and partial boundary handling.}
\RESULT{For each type-2 query, we output the exact count of entries equal to $x$ in the given range, one per line, in the same order as queries.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for:
- No-op updates ($x$ above all values).
- Full-block updates followed by partial queries.
- Partial updates intersecting two blocks.
- Repeated compositions to test DSU mapping chains.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Optimal on random tiny arrays ($n \le 30$, $m \le 50$). The results must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial cases: all values equal; strictly increasing; all equal to $x$; alternating values $x$ and $x+1$; frequent updates with $x=1$ to stress many small decrements.}
\begin{minted}{python}
import random

def gen_case(n: int, m: int, vmax: int = 20) -> str:
    a = [random.randint(1, vmax) for _ in range(n)]
    ops = []
    for _ in range(m):
        t = random.randint(1, 2)
        l = random.randint(1, n)
        r = random.randint(l, n)
        x = random.randint(1, vmax)
        ops.append((t,l,r,x))
    s = [f"{n} {m}", " ".join(map(str, a))]
    s += [f"{t} {l} {r} {x}" for (t,l,r,x) in ops]
    return "\n".join(s) + "\n"

def cross_check_once():
    from collections import deque
    data = gen_case(20, 40, vmax=15)
    b = solve_all_baseline(data)
    i = solve_all_block_sqrt(data)
    o = solve_all(data)
    assert b.strip().split() == i.strip().split() == o.strip().split()

def run_cross_checks(trials: int = 30):
    for _ in range(trials):
        cross_check_once()

if __name__ == "__main__":
    # Run limited cross-checks when executed directly
    run_cross_checks(10)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple
from collections import Counter

class Block:
    __slots__ = ("L","R","a","cnt","to")
    def __init__(self, a: List[int], L: int, R: int):
        self.L = L
        self.R = R
        self.a = a[L:R+1]
        self.cnt = Counter(self.a)
        self.to = {}

    def find(self, v: int) -> int:
        to = self.to
        path = []
        while True:
            nv = to.get(v, v)
            if nv == v:
                root = v
                break
            path.append(v)
            v = nv
        for u in path:
            to[u] = root
        return root

    def materialize(self):
        if self.to:
            for i in range(len(self.a)):
                self.a[i] = self.find(self.a[i])
        self.to.clear()
        self.cnt = Counter(self.a)

    def apply_full_reduce(self, x: int):
        if not self.cnt:
            return
        keys = [v for v in list(self.cnt.keys()) if v > x]
        if not keys:
            return
        for v in keys:
            c = self.cnt.pop(v, 0)
            if c == 0:
                continue
            tgt = self.find(v - x)
            self.to[v] = tgt
            self.cnt[tgt] = self.cnt.get(tgt, 0) + c

    def count_full(self, x: int) -> int:
        return self.cnt.get(x, 0)

    def partial_reduce(self, l: int, r: int, x: int):
        L, R = self.L, self.R
        ll = max(l, L); rr = min(r, R)
        if ll > rr:
            return
        for i in range(ll, rr+1):
            j = i - L
            old = self.a[j]
            if old > x:
                self.cnt[old] -= 1
                if self.cnt[old] == 0:
                    del self.cnt[old]
                self.a[j] = old - x
                self.cnt[self.a[j]] = self.cnt.get(self.a[j], 0) + 1

    def partial_count(self, l: int, r: int, x: int) -> int:
        L, R = self.L, self.R
        ll = max(l, L); rr = min(r, R)
        if ll > rr:
            return 0
        ans = 0
        for i in range(ll, rr+1):
            if self.a[i - L] == x:
                ans += 1
        return ans

class ChthollyDS:
    def __init__(self, a: List[int]):
        self.n = len(a) - 1
        B = int(self.n**0.5) + 1
        self.blocks: List[Block] = []
        for L in range(1, self.n+1, B):
            R = min(self.n, L + B - 1)
            self.blocks.append(Block(a, L, R))

    def op1(self, l: int, r: int, x: int):
        for blk in self.blocks:
            if r < blk.L or blk.R < l:
                continue
            if l <= blk.L and blk.R <= r:
                blk.apply_full_reduce(x)
            else:
                blk.materialize()
                blk.partial_reduce(l, r, x)

    def op2(self, l: int, r: int, x: int) -> int:
        ans = 0
        for blk in self.blocks:
            if r < blk.L or blk.R < l:
                continue
            if l <= blk.L and blk.R <= r:
                ans += blk.count_full(x)
            else:
                blk.materialize()
                ans += blk.partial_count(l, r, x)
        return ans

def read_input(data: str) -> Tuple[int, int, List[int], List[Tuple[int,int,int,int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    a = [0] + [int(next(it)) for _ in range(n)]
    ops = []
    for _ in range(m):
        t = int(next(it)); l = int(next(it)); r = int(next(it)); x = int(next(it))
        ops.append((t,l,r,x))
    return n, m, a, ops

def solve_all(data: str) -> str:
    n, m, a, ops = read_input(data)
    ds = ChthollyDS(a)
    out = []
    for t,l,r,x in ops:
        if t == 1:
            ds.op1(l,r,x)
        else:
            out.append(str(ds.op2(l,r,x)))
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain range updates counting exact values with conditional subtract; use block DSU-on-values to compose full-block updates lazily.}
\WHY{This pattern appears in hard range-query problems with non-linear updates where lazy linear tags do not suffice.}
\CHECKLIST{
- Partition into blocks and build freq maps.
- For full blocks: merge leaders $v>x \to v-x$.
- For edges: materialize before per-element work.
- For queries: sum full-block counts and scan edges.}
\EDGECASES{
- $x$ larger than all values in a block (no-op).
- $x=1$ repeated many times.
- All elements equal to $x$.
- Single-element ranges.
- Updates that touch only block boundaries.
- Many distinct values per block (ensure sparse maps).}
\PITFALLS{
- Forgetting to materialize before partial updates/queries causes stale values.
- Not redirecting leader map for $v$ when merging into $v-x$.
- Double-counting when moving counts; always pop then add.
- Leaving zero-count entries in maps; clean them.
- Path compression missing causes slow finds.
- Mixing 0-based and 1-based indices.}
\FAILMODES{Simpler sqrt that fully materializes every full-block update degrades to $O(n)$ per op. The DSU-on-values avoids touching elements for full-block updates, preserving near $O(\sqrt{n})$ performance.}
\ELI{Chop big values by $x$ but leave small ones; to go fast, split the array into chunks. For whole chunks, just keep a tally of how many of each value you have and remap those tallies when you chop. For partial chunks, first apply the remapping and then touch the few elements you need.}
\NotePages{3}

\end{document}