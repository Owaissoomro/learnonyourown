% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Odd-Even Subsequence}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1370/D}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{Ashish has an array $a$ of size $n$.

A subsequence of $a$ is defined as a sequence that can be obtained from $a$ by deleting some elements (possibly none), without changing the order of the remaining elements.

Consider a subsequence $s$ of $a$. He defines the cost of $s$ as the minimum between:
\begin{bullets}
\item The maximum among all elements at odd indices of $s$.
\item The maximum among all elements at even indices of $s$.
\end{bullets}
Note that the index of an element is its index in $s$, rather than its index in $a$. The positions are numbered from $1$. So, the cost of $s$ is equal to $ \min\bigl(\max(s_1, s_3, s_5, \ldots),~ \max(s_2, s_4, s_6, \ldots)\bigr)$.

For example, the cost of $\{7, 5, 6\}$ is $\min\bigl( \max(7, 6),~ \max(5) \bigr) = \min(7, 5) = 5$.

Help him find the minimum cost of a subsequence of size $k$.

Input: The first line contains two integers $n$ and $k$ ($2 \le k \le n \le 2 \cdot 10^5$) — the size of the array $a$ and the size of the subsequence.

The next line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^9$) — the elements of the array $a$.

Output: Output a single integer — the minimum cost of a subsequence of size $k$.

Note: In the first test, consider the subsequence $s = \{1, 3\}$. Here the cost is equal to $\min(\max(1), \max(3)) = 1$.

In the second test, consider the subsequence $s = \{1, 2, 4\}$. Here the cost is equal to $\min(\max(1, 4), \max(2)) = 2$.

In the fourth test, consider the subsequence $s = \{3, 50, 2, 4\}$. Here the cost is equal to $\min(\max(3, 2), \max(50, 4)) = 3$.}
\BREAKDOWN{We must choose $k$ elements forming a subsequence and minimize the smaller of the two maxima over odd vs.\ even positions in that subsequence. Observe that cost $\le x$ iff there exists a length-$k$ subsequence where either all odd-positioned picks are $\le x$ or all even-positioned picks are $\le x$. This yields a monotone predicate in $x$ checked greedily.}
\ELI{Binary search the answer $x$ and greedily see if we can alternate picks so that one parity's picks are always $\le x$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item Integers $n, k$ with $2 \le k \le n \le 2\cdot 10^5$.
\item Array $a$ of length $n$ with $1 \le a_i \le 10^9$.
\end{bullets}}
\OUTPUTS{One integer: the minimal possible cost of a subsequence of size $k$.}
\SAMPLES{
Example 1: $n=2, k=2, a=[1,3] \Rightarrow 1$ (pick $\{1,3\}$, cost $\min(\max(1),\max(3))=1$).

Example 2: $n=4, k=3, a=[1,2,4,7] \Rightarrow 2$ (pick $\{1,2,4\}$, cost $\min(\max(1,4),\max(2))=2$).
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $a\in\mathbb{Z}_{>0}^n$ and $k$, select indices $1 \le i_1 < \cdots < i_k \le n$ to form $s_j=a_{i_j}$. Define
\begin{BreakableEquation*}
\text{cost}(s)=\min\Bigl(\max_{j\ \text{odd}} s_j,\ \max_{j\ \text{even}} s_j\Bigr).
\end{BreakableEquation*}
Goal: minimize $\text{cost}(s)$ over all size-$k$ subsequences.}
\varmapStart
\var{n}{array length}
\var{k}{required subsequence length}
\var{a_i}{array elements}
\var{x}{candidate cost threshold}
\var{p}{parity role: which positions must be $\le x$}
\varmapEnd
\GOVERN{
\[
\exists s\ \text{with }|s|=k\ \land\ \text{cost}(s)\le x
\iff
\Bigl(\exists s:\ \forall j \text{ odd},~ s_j\le x\Bigr)\ \lor\ \Bigl(\exists s:\ \forall j \text{ even},~ s_j\le x\Bigr).
\]
Greedy alternation feasibility test realizes each disjunct. The predicate in $x$ is monotone nondecreasing, enabling binary search on $x$.
}
\ASSUMPTIONS{Positions are $1$-indexed within the subsequence; ties in values are allowed; no reordering of $a$.}
\INVARIANTS{
\begin{bullets}
\item Greedy alternation: whenever the current position is unconstrained, always take the next element to maximize length; when constrained, take the next element $\le x$ if available.
\item Monotonicity: if feasible for $x$, feasible for any $y\ge x$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate candidate thresholds $x$ from the set of array values, sorted ascending. For each $x$, test feasibility via greedy alternation for both parity patterns. Return the first feasible $x$.}
\ASSUMPTIONS{The optimal cost must be one of the $a_i$ values since it is the minimum of maxima drawn from elements.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Extract and sort the unique values of $a$ as candidates.
\item For each candidate $x$ in ascending order, run the greedy feasibility test twice: odd-constrained and even-constrained.
\item Return the first $x$ that yields length $\ge k$ in either pattern.
\end{algosteps}
\COMPLEXITY{Let $u$ be the number of unique values. Each feasibility test is $O(n)$, so the overall is $O(u\cdot n)$ time and $O(1)$ extra space beyond input. In worst case $u=n$, hence $O(n^2)$.}
\[
\begin{aligned}
T(n) &= \sum_{x\in \text{uniq}(a)} O(n) \\
     &= O(u\cdot n) \le O(n^2).
\end{aligned}
\]
\CORRECTNESS{If $x$ is feasible, greedy alternation finds a size-$k$ subsequence satisfying the parity constraint because picking earlier never reduces the ability to complete future alternations. Since candidates are tried in nondecreasing order, the first feasible $x$ is optimal.}
\EDGECASES{All equal elements; strictly increasing/decreasing arrays; $k$ even vs.\ odd; feasibility hinging on starting parity.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return data

def can_with_threshold(a, k, x):
    # Pattern 1: constrain odd positions (first pick must be <= x)
    cnt = 0
    need_constrained = True  # True means current pick must be <= x
    for v in a:
        if need_constrained:
            if v <= x:
                cnt += 1
                need_constrained = not need_constrained
        else:
            cnt += 1
            need_constrained = not need_constrained
    if cnt >= k:
        return True
    # Pattern 2: constrain even positions (first pick unconstrained)
    cnt = 0
    need_constrained = False
    for v in a:
        if need_constrained:
            if v <= x:
                cnt += 1
                need_constrained = not need_constrained
        else:
            cnt += 1
            need_constrained = not need_constrained
    return cnt >= k

def solve_case_baseline(n, k, a):
    vals = sorted(set(a))
    for x in vals:
        if can_with_threshold(a, k, x):
            return x
    # Should always return before here
    return max(a)

def solve_all_baseline(tokens):
    it = iter(tokens)
    try:
        n = int(next(it))
    except StopIteration:
        return None
    k = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    ans = solve_case_baseline(n, k, a)
    return str(ans)

def main():
    tokens = read_input()
    if not tokens:
        # Self-tests
        assert can_with_threshold([1, 3], 2, 1) is True
        assert solve_case_baseline(2, 2, [1, 3]) == 1
        assert solve_case_baseline(4, 3, [1, 2, 4, 7]) == 2
        assert solve_case_baseline(4, 4, [3, 50, 2, 4]) == 3
        # Edge parities
        assert solve_case_baseline(5, 3, [5, 4, 3, 2, 1]) == 2
        print("OK")
        return
    out = solve_all_baseline(tokens)
    if out is not None:
        sys.stdout.write(out + "\n")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked on small cases and parity-sensitive examples; baseline agrees with the greedy feasibility expectations.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Observe that feasibility in $x$ is monotone: if feasible for $x$, then feasible for any $y \ge x$. Therefore, binary search on $x \in [1, \max(a)]$ with the same $O(n)$ feasibility test yields $O(n \log V)$ where $V\le 10^9$.}
\ASSUMPTIONS{The greedy alternation feasibility is linear and deterministic; $x$ ranges over integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set $\ell=1$, $r=\max(a)$.
\item While $\ell<r$, let $m=\lfloor(\ell+r)/2\rfloor$ and test feasibility at $m$.
\item If feasible, set $r=m$; else set $\ell=m+1$.
\item Return $\ell$.
\end{algosteps}
\COMPLEXITY{Each step costs $O(n)$ and there are $O(\log V)$ steps.}
\[
\begin{aligned}
T(n) &= O(n \log V), \quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Monotonicity of the predicate combined with standard binary search yields the minimal feasible threshold. Greedy ensures feasibility is detected whenever it exists.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return data

def can_with_threshold(a, k, x):
    cnt = 0
    need_constrained = True
    for v in a:
        if need_constrained:
            if v <= x:
                cnt += 1
                need_constrained = not need_constrained
        else:
            cnt += 1
            need_constrained = not need_constrained
    if cnt >= k:
        return True
    cnt = 0
    need_constrained = False
    for v in a:
        if need_constrained:
            if v <= x:
                cnt += 1
                need_constrained = not need_constrained
        else:
            cnt += 1
            need_constrained = not need_constrained
    return cnt >= k

def solve_case_improved(n, k, a):
    lo, hi = 1, max(a)
    while lo < hi:
        mid = (lo + hi) // 2
        if can_with_threshold(a, k, mid):
            hi = mid
        else:
            lo = mid + 1
    return lo

def solve_all_improved(tokens):
    it = iter(tokens)
    try:
        n = int(next(it))
    except StopIteration:
        return None
    k = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    ans = solve_case_improved(n, k, a)
    return str(ans)

def main():
    tokens = read_input()
    if not tokens:
        # Self-tests
        assert solve_case_improved(2, 2, [1, 3]) == 1
        assert solve_case_improved(4, 3, [1, 2, 4, 7]) == 2
        assert solve_case_improved(4, 4, [3, 50, 2, 4]) == 3
        assert solve_case_improved(5, 3, [5, 4, 3, 2, 1]) == 2
        print("OK")
        return
    out = solve_all_improved(tokens)
    if out is not None:
        sys.stdout.write(out + "\n")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Validated against baseline logic on the same crafted tests; identical answers with asymptotically better performance.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the monotone binary search with a single, branchless-style greedy pass that evaluates both parities efficiently. This achieves the known optimal $O(n \log V)$ for this decision+search framework.}
\ASSUMPTIONS{Threshold feasibility is monotone; greedy alternation is tight; the answer lies between $1$ and $\max(a)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define a feasibility tester that counts the maximum alternation length when odd positions are constrained, and when even positions are constrained.
\item Binary search the minimal $x$ that makes either count $\ge k$.
\item Output that $x$.
\end{algosteps}
\OPTIMALITY{Any comparison-based search over $x\in[1,\max(a)]$ with only feasibility queries needs $\Omega(\log V)$ queries in the worst case, and each query requires scanning $a$ at least once in the worst case, implying $\Omega(n \log V)$ time; the algorithm matches this bound.}
\COMPLEXITY{
\begin{BreakableEquation*}
T(n)=O(n\log V),\quad S(n)=O(1).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return data

def can_with_threshold(a, k, x):
    # Constrain odd positions
    cnt = 0
    need_constrained = True
    for v in a:
        if need_constrained:
            if v <= x:
                cnt += 1
                need_constrained = not need_constrained
        else:
            cnt += 1
            need_constrained = not need_constrained
    if cnt >= k:
        return True
    # Constrain even positions
    cnt = 0
    need_constrained = False
    for v in a:
        if need_constrained:
            if v <= x:
                cnt += 1
                need_constrained = not need_constrained
        else:
            cnt += 1
            need_constrained = not need_constrained
    return cnt >= k

def solve_case(n, k, a):
    lo, hi = 1, max(a)
    while lo < hi:
        mid = (lo + hi) // 2
        if can_with_threshold(a, k, mid):
            hi = mid
        else:
            lo = mid + 1
    return lo

def solve_all(tokens):
    it = iter(tokens)
    try:
        n = int(next(it))
    except StopIteration:
        return None
    k = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    ans = solve_case(n, k, a)
    return str(ans)

def _self_tests():
    # Basic from notes
    assert solve_case(2, 2, [1, 3]) == 1
    assert solve_case(4, 3, [1, 2, 4, 7]) == 2
    assert solve_case(4, 4, [3, 50, 2, 4]) == 3
    # Parity-sensitive
    assert solve_case(5, 4, [5, 1, 5, 1, 5]) == 1
    # Compare to baseline on small randoms
    import random
    random.seed(7)
    for _ in range(50):
        n = random.randint(2, 10)
        k = random.randint(2, n)
        a = [random.randint(1, 20) for _ in range(n)]
        # Baseline via unique-scan
        vals = sorted(set(a))
        ans_b = None
        for x in vals:
            if can_with_threshold(a, k, x):
                ans_b = x
                break
        assert ans_b == solve_case(n, k, a)

def main():
    tokens = read_input()
    if not tokens:
        _self_tests()
        print("OK")
        return
    out = solve_all(tokens)
    if out is not None:
        sys.stdout.write(out + "\n")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 checks:
\begin{bullets}
\item $(n,k,a)=(2,2,[1,3]) \Rightarrow 1$.
\item $(n,k,a)=(4,3,[1,2,4,7]) \Rightarrow 2$.
\item $(n,k,a)=(4,4,[3,50,2,4]) \Rightarrow 3$.
\end{bullets}}
\RESULT{The printed integer is the minimal threshold $x$ such that a length-$k$ subsequence exists with either all odd or all even positions $\le x$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted arrays (monotone, alternating, equal), parity sensitivity ($k$ odd/even), and randomized cross-checks versus a baseline unique-scan.}
\LINE{CROSS-CHECKS}{Compare the improved/optimal binary search against the baseline over many small random instances with a fixed seed for determinism.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with extremes: all equal; alternating small/large; strictly increasing; strictly decreasing; random with bounded range.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_all_equal(n, val):
    return [val] * n

def gen_alternating(n, low, high):
    a = []
    for i in range(n):
        a.append(low if i % 2 == 0 else high)
    return a

def gen_increasing(n, start=1, step=1):
    return [start + i * step for i in range(n)]

def gen_decreasing(n, start=100, step=1):
    return [start - i * step for i in range(n)]

def gen_random(n, lo=1, hi=20, seed=0):
    random.seed(seed)
    return [random.randint(lo, hi) for _ in range(n)]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return data

def can_with_threshold(a, k, x):
    cnt = 0
    need_constrained = True
    for v in a:
        if need_constrained:
            if v <= x:
                cnt += 1
                need_constrained = not need_constrained
        else:
            cnt += 1
            need_constrained = not need_constrained
    if cnt >= k:
        return True
    cnt = 0
    need_constrained = False
    for v in a:
        if need_constrained:
            if v <= x:
                cnt += 1
                need_constrained = not need_constrained
        else:
            cnt += 1
            need_constrained = not need_constrained
    return cnt >= k

def solve_case(n, k, a):
    lo, hi = 1, max(a)
    while lo < hi:
        mid = (lo + hi) // 2
        if can_with_threshold(a, k, mid):
            hi = mid
        else:
            lo = mid + 1
    return lo

def solve_all(tokens):
    it = iter(tokens)
    try:
        n = int(next(it))
    except StopIteration:
        return None
    k = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return str(solve_case(n, k, a))

def _self_tests():
    assert solve_case(2, 2, [1, 3]) == 1
    assert solve_case(4, 3, [1, 2, 4, 7]) == 2
    assert solve_case(4, 4, [3, 50, 2, 4]) == 3

def main():
    tokens = read_input()
    if not tokens:
        _self_tests()
        print("OK")
        return
    out = solve_all(tokens)
    if out is not None:
        sys.stdout.write(out + "\n")

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Binary search the minimal threshold $x$ for which an alternating greedy pick can reach $k$ while constraining one parity to be $\le x$.}
\WHY{Classic CF pattern: monotone predicate over a numeric threshold with greedy feasibility; appears frequently in selection and subsequence problems.}
\CHECKLIST{
\begin{bullets}
\item Define the feasibility predicate correctly for both starting parities.
\item Prove monotonicity in $x$.
\item Implement linear-time greedy alternation.
\item Binary search over $[1, \max(a)]$.
\item Handle $k$ odd/even uniformly.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All elements equal.
\item Strictly increasing or decreasing arrays.
\item $k$ equals $n$.
\item $k$ even vs.\ odd.
\item Feasible only with starting-unconstrained pattern.
\item Large values up to $10^9$ with small $n$.
\item Repeated values with gaps just above/below $x$.
\item Arrays where only every other element is small.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to try both parity patterns.
\item Off-by-one in alternation toggling.
\item Using non-monotone predicate and still binary searching.
\item Binary searching over array indices instead of value range or unique set.
\item Mishandling empty-input run in local testing.
\item Integer overflow not an issue in Python, but beware in other languages.
\end{bullets}}
\FAILMODES{Greedy that requires both parities $\le x$ will fail; scanning only one starting parity misses valid solutions; linear scan of the whole numeric range $[1,10^9]$ is too slow. The presented solution avoids all these by using the correct predicate and binary search.}
\ELI{We try a guess $x$ and see if we can pick $k$ items alternatingly while keeping either the odd or the even picks at most $x$. If we can, we try smaller $x$; if not, we try bigger $x$. This quickly converges to the smallest possible $x$.}
\NotePages{3}

\end{document}