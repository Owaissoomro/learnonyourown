% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Equal LCM Subsets}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1656/H}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{You are given two sets of positive integers $A$ and $B$. You have to find two non-empty subsets $S_A \subseteq A$, $S_B \subseteq B$ so that the least common multiple (LCM) of the elements of $S_A$ is equal to the least common multiple (LCM) of the elements of $S_B$.

Input:
The input consists of multiple test cases. The first line of the input contains one integer $t$ ($1 \le t \le 200$), the number of test cases.

For each test case, there is one line containing two integers $n, m$ ($1 \le n, m \le 1000$), the sizes of the sets $A$ and $B$, respectively.

The next line contains $n$ distinct integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 4 \cdot 10^{36}$), the elements of $A$.

The next line contains $m$ distinct integers $b_1, b_2, \ldots, b_m$ ($1 \le b_i \le 4 \cdot 10^{36}$), the elements of $B$.

The sum of $n$ for all test cases and the sum of $m$ for all test cases is at most $1000$.

Output:
For each test case, if there do not exist two subsets with equal least common multiple, output one line with NO.

Otherwise, output one line with YES, followed by a line with two integers $|S_A|, |S_B|$ ($1 \le |S_A| \le n$, $1 \le |S_B| \le m$), the sizes of the subsets $S_A$ and $S_B$.

The next line should contain $|S_A|$ integers $x_1, x_2, \ldots, x_{|S_A|}$, the elements of $S_A$, followed by a line with $|S_B|$ integers $y_1, y_2, \ldots, y_{|S_B|}$, the elements of $S_B$. If there are multiple possible pairs of subsets, you can print any.}
\BREAKDOWN{We must decide whether there exist non-empty subsets with equal LCMs and explicitly output such subsets. The key is to prune elements that cannot be matched in prime-power coverage by the opposite side using only $\gcd$ and $\mathrm{lcm}$ over pairwise $\gcd$s, avoiding factorization and enormous LCMs.}
\ELI{Iteratively delete any number whose prime-power content cannot be supplied by the other side; whatever remains has equal LCM on both sides.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n, m$ with $1 \le n, m \le 1000$. Then $n$ distinct $a_i$ and $m$ distinct $b_j$ with $1 \le a_i, b_j \le 4 \cdot 10^{36}$. The sums $\sum n \le 1000$, $\sum m \le 1000$.}
\OUTPUTS{For each test case, print NO if impossible. Otherwise print:
\begin{bullets}
\item YES
\item a line with $|S_A|~|S_B|$
\item a line with $|S_A|$ integers of subset $S_A$
\item a line with $|S_B|$ integers of subset $S_B$
\end{bullets}
Any valid pair is acceptable.}
\SAMPLES{Example 1:
\begin{tcolorbox}
Input
\begin{verbatim}
3
1 2
4
2 8
1 2
6
2 3
2 2
4 9
6 10
\end{verbatim}
Output
\begin{verbatim}
NO
YES
1 2
6
2 3
NO
\end{verbatim}
\end{tcolorbox}
Explanation: In test 1, no equal LCM subsets exist. In test 2, $\mathrm{lcm}(\{6\})=\mathrm{lcm}(\{2,3\})=6$. In test 3, no equal LCM subsets exist.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=\{a_1,\ldots,a_n\}$, $B=\{b_1,\ldots,b_m\}$. Define active subsets $A'\subseteq A$, $B'\subseteq B$ that we iteratively prune. For $x\in\mathbb{N}$ let $v_p(x)$ denote $p$-adic valuation. We seek non-empty $S_A\subseteq A$, $S_B\subseteq B$ with $\max_{x\in S_A} v_p(x)=\max_{y\in S_B} v_p(y)$ for all primes $p$.}
\varmapStart
\var{A,B}{input sets}
\var{G_{ij}}{$\gcd(a_i,b_j)$}
\var{C_A(i)}{$\mathrm{lcm}_{b_j\in B'} \gcd(a_i,b_j)$}
\var{C_B(j)}{$\mathrm{lcm}_{a_i\in A'} \gcd(b_j,a_i)$}
\var{A',B'}{surviving elements after pruning}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
C_A(i) &= \mathrm{lcm}_{b_j\in B'} \gcd(a_i,b_j),\\
C_B(j) &= \mathrm{lcm}_{a_i\in A'} \gcd(b_j,a_i).
\end{aligned}
\]
}
\ASSUMPTIONS{Numbers are positive integers. We never factor; only $\gcd$ and $\mathrm{lcm}$ are used. Note $C_A(i)\mid a_i$ and $C_B(j)\mid b_j$.}
\INVARIANTS{
\begin{bullets}
\item If $a_i\in A'$ then for every prime $p$, there exists some $b_j\in B'$ with $v_p(b_j)\ge v_p(a_i)$ (since $v_p(C_A(i))=v_p(a_i)$).
\item Symmetrically for $b_j\in B'$.
\item When pruning stabilizes, $\mathrm{lcm}(A')=\mathrm{lcm}(B')$ coordinatewise in prime valuations.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all non-empty subsets and compare LCMs using $\mathrm{lcm}(x,y)=x\cdot y/\gcd(x,y)$.}
\ASSUMPTIONS{Only feasible for tiny $n,m$ (e.g., $\le 15$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all non-empty masks of $A$, compute their LCMs.
\item Enumerate all non-empty masks of $B$, compute their LCMs.
\item Check for any matching LCM; reconstruct corresponding subsets.
\end{algosteps}
\COMPLEXITY{Exponential in $n+m$.}
\[
\begin{aligned}
T(n,m) &= O(2^n n + 2^m m) \\
S(n,m) &= O(2^n + 2^m) \text{ in worst memoization}
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration guarantees coverage of all subset pairs.}
\EDGECASES{Singleton subsets; repeated primes; co-prime elements; very large integers.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple, Dict

def lcm(a: int, b: int) -> int:
    return a // math.gcd(a, b) * b

def lcm_list(nums: List[int]) -> int:
    cur = 1
    for x in nums:
        cur = lcm(cur, x)
    return cur

def brute_equal_lcm_subsets(a: List[int], b: List[int]) -> Tuple[bool, List[int], List[int]]:
    n, m = len(a), len(b)
    # Only attempt brute force for tiny sizes
    if n > 15 or m > 15:
        return False, [], []
    lcmA: Dict[int, List[int]] = {}
    for mask in range(1, 1 << n):
        subset = [a[i] for i in range(n) if (mask >> i) & 1]
        LA = lcm_list(subset)
        if LA not in lcmA:
            lcmA[LA] = subset
    for mask in range(1, 1 << m):
        subset = [b[j] for j in range(m) if (mask >> j) & 1]
        LB = lcm_list(subset)
        if LB in lcmA:
            return True, lcmA[LB], subset
    return False, [], []

def read_input(data: bytes):
    it = iter(data.split())
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        A = [int(next(it)) for _ in range(n)]
        B = [int(next(it)) for _ in range(m)]
        cases.append((A, B))
    return t, cases

def solve_case(a: List[int], b: List[int]) -> str:
    ok, SA, SB = brute_equal_lcm_subsets(a, b)
    if not ok:
        return "NO"
    out = []
    out.append("YES")
    out.append(f"{len(SA)} {len(SB)}")
    out.append(" ".join(str(x) for x in SA))
    out.append(" ".join(str(x) for x in SB))
    return "\n".join(out)

def solve_all(data: bytes) -> str:
    t, cases = read_input(data)
    out_lines = []
    for A, B in cases:
        out_lines.append(solve_case(A, B))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.buffer.read()
    if not data:
        return
    print(solve_all(data))

if __name__ == "__main__":
    # Tiny self-checks for baseline
    assert brute_equal_lcm_subsets([6], [2, 3])[0] is True
    assert brute_equal_lcm_subsets([4], [2, 8])[0] is False
    # Run main for I/O
    main()
\end{minted}
\VALIDATION{Checks: [6] vs [2,3] is YES; [4] vs [2,8] is NO.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Precompute Pairwise gcd and Prune via Coverage}
\WHICHFORMULA{For each $a_i$, compute $C_A(i)=\mathrm{lcm}_j \gcd(a_i,b_j)$; if $C_A(i)\ne a_i$, $a_i$ cannot be part of any valid solution. Similarly for $b_j$. Iterate pruning until stable.}
\ASSUMPTIONS{No factorization; only $\gcd$ and $\mathrm{lcm}$ over divisors of inputs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $G_{ij}=\gcd(a_i,b_j)$ for all pairs.
\item Maintain active sets $A',B'$. Repeatedly:
\begin{bullets}
\item Remove any $a_i$ with $\mathrm{lcm}_{b_j\in B'} G_{ij} \ne a_i$.
\item Remove any $b_j$ with $\mathrm{lcm}_{a_i\in A'} G_{ij} \ne b_j$.
\end{bullets}
\item If either side empties, answer is NO; else survivors themselves witness equal LCMs.
\end{algosteps}
\COMPLEXITY{Each pass scans $O(nm)$ pairs; at most $n+m$ removals. Total $O(nm(n+m))$ gcd/lcm ops; with $\sum(n+m)\le 2000$, this is practical.}
\[
\begin{aligned}
T &\approx O(n m (n+m)), \quad S = O(nm).
\end{aligned}
\]
\CORRECTNESS{If $a_i$ survives, then for each prime $p\mid a_i$, some $b_j$ has $v_p(b_j)\ge v_p(a_i)$. The symmetric condition holds for $b_j$. Thus the prime-wise maxima over survivors are equal, hence LCMs are equal.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

def lcm(a: int, b: int) -> int:
    return a // math.gcd(a, b) * b

def equal_lcm_subsets(a: List[int], b: List[int]) -> Tuple[bool, List[int], List[int]]:
    n, m = len(a), len(b)
    G = [[0] * m for _ in range(n)]
    for i in range(n):
        ai = a[i]
        for j in range(m):
            G[i][j] = math.gcd(ai, b[j])
    actA = [True] * n
    actB = [True] * m
    cntA, cntB = n, m
    changed = True
    while changed:
        changed = False
        # Pass over A
        for i in range(n):
            if not actA[i]:
                continue
            li = 1
            for j in range(m):
                if not actB[j]:
                    continue
                g = G[i][j]
                if g != 1:
                    li = lcm(li, g)
                    if li == a[i]:
                        break
            if li != a[i]:
                actA[i] = False
                cntA -= 1
                changed = True
        if cntA == 0 or cntB == 0:
            break
        # Pass over B
        for j in range(m):
            if not actB[j]:
                continue
            lj = 1
            for i in range(n):
                if not actA[i]:
                    continue
                g = G[i][j]
                if g != 1:
                    lj = lcm(lj, g)
                    if lj == b[j]:
                        break
            if lj != b[j]:
                actB[j] = False
                cntB -= 1
                changed = True
        if cntA == 0 or cntB == 0:
            break
    if cntA == 0 or cntB == 0:
        return False, [], []
    SA = [a[i] for i in range(n) if actA[i]]
    SB = [b[j] for j in range(m) if actB[j]]
    return True, SA, SB

def read_input(data: bytes):
    it = iter(data.split())
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        A = [int(next(it)) for _ in range(n)]
        B = [int(next(it)) for _ in range(m)]
        cases.append((A, B))
    return t, cases

def solve_case(a: List[int], b: List[int]) -> str:
    ok, SA, SB = equal_lcm_subsets(a, b)
    if not ok:
        return "NO"
    out = []
    out.append("YES")
    out.append(f"{len(SA)} {len(SB)}")
    out.append(" ".join(str(x) for x in SA))
    out.append(" ".join(str(x) for x in SB))
    return "\n".join(out)

def solve_all(data: bytes) -> str:
    t, cases = read_input(data)
    out_lines = []
    for A, B in cases:
        out_lines.append(solve_case(A, B))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.buffer.read()
    if not data:
        return
    print(solve_all(data))

if __name__ == "__main__":
    # Validate core properties
    ok, SA, SB = equal_lcm_subsets([6], [2, 3])
    assert ok and (SA == [6] and SB == [2, 3] or (SA, SB) == ([6], [2, 3]))
    ok2, _, _ = equal_lcm_subsets([4], [2, 8])
    assert not ok2
    # Run I/O
    main()
\end{minted}
\VALIDATION{Edge checks: [6] vs [2,3] yields YES; [4] vs [2,8] yields NO; symmetric cases behave consistently.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Prime-Power Coverage via lcm-of-gcd Pruning}
\WHICHFORMULA{Use $C_A(i)=\mathrm{lcm}_{b_j\in B'} \gcd(a_i,b_j)$ and symmetrically $C_B(j)$; iteratively remove uncovered elements until fixed point.}
\ASSUMPTIONS{All computations are on divisors of inputs; no factorization and no gigantic LCMs are formed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $G_{ij}=\gcd(a_i,b_j)$ for all pairs $(i,j)$.
\item Initialize $A'=A$, $B'=B$.
\item Repeat until no removals:
\begin{bullets}
\item Remove any $a_i$ with $\mathrm{lcm}_{b_j\in B'} G_{ij} \ne a_i$ from $A'$.
\item Remove any $b_j$ with $\mathrm{lcm}_{a_i\in A'} G_{ij} \ne b_j$ from $B'$.
\end{bullets}
\item If either side is empty, print NO. Otherwise print YES and output $A',B'$.
\end{algosteps}
\OPTIMALITY{If any solution exists, none of its elements can be pruned by the rule, so the fixed point is a superset of some valid witness. Conversely, at the fixed point, both sides have matching prime-wise maxima, so their LCMs are equal.}
\COMPLEXITY{$O(nm(n+m))$ gcd/lcm operations across all test cases with $\sum(n+m)\le 2000$. Memory $O(nm)$.}
\[
\begin{aligned}
T &\le O(nm) \text{ per pass} \times O(n+m) \text{ passes}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

def lcm(a: int, b: int) -> int:
    return a // math.gcd(a, b) * b

def equal_lcm_subsets(a: List[int], b: List[int]) -> Tuple[bool, List[int], List[int]]:
    n, m = len(a), len(b)
    # Precompute pairwise gcds
    G = [[0] * m for _ in range(n)]
    for i in range(n):
        ai = a[i]
        for j in range(m):
            G[i][j] = math.gcd(ai, b[j])
    actA = [True] * n
    actB = [True] * m
    cntA, cntB = n, m
    changed = True
    while changed:
        changed = False
        # Prune A by coverage from current B
        for i in range(n):
            if not actA[i]:
                continue
            li = 1
            for j in range(m):
                if not actB[j]:
                    continue
                g = G[i][j]
                if g != 1:
                    li = lcm(li, g)
                    if li == a[i]:
                        break
            if li != a[i]:
                actA[i] = False
                cntA -= 1
                changed = True
        if cntA == 0 or cntB == 0:
            break
        # Prune B by coverage from current A
        for j in range(m):
            if not actB[j]:
                continue
            lj = 1
            for i in range(n):
                if not actA[i]:
                    continue
                g = G[i][j]
                if g != 1:
                    lj = lcm(lj, g)
                    if lj == b[j]:
                        break
            if lj != b[j]:
                actB[j] = False
                cntB -= 1
                changed = True
        if cntA == 0 or cntB == 0:
            break
    if cntA == 0 or cntB == 0:
        return False, [], []
    SA = [a[i] for i in range(n) if actA[i]]
    SB = [b[j] for j in range(m) if actB[j]]
    return True, SA, SB

def read_input(data: bytes):
    it = iter(data.split())
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        A = [int(next(it)) for _ in range(n)]
        B = [int(next(it)) for _ in range(m)]
        cases.append((A, B))
    return t, cases

def solve_case(a: List[int], b: List[int]) -> str:
    ok, SA, SB = equal_lcm_subsets(a, b)
    if not ok:
        return "NO"
    out = []
    out.append("YES")
    out.append(f"{len(SA)} {len(SB)}")
    out.append(" ".join(str(x) for x in SA))
    out.append(" ".join(str(x) for x in SB))
    return "\n".join(out)

def solve_all(data: bytes) -> str:
    t, cases = read_input(data)
    out_lines = []
    for A, B in cases:
        out_lines.append(solve_case(A, B))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.buffer.read()
    if not data:
        return
    print(solve_all(data))

if __name__ == "__main__":
    # Exactly 3 asserts / mini-tests
    ok, SA, SB = equal_lcm_subsets([6], [2, 3])
    def lcm_list(v: List[int]) -> int:
        cur = 1
        for x in v:
            cur = lcm(cur, x)
        return cur
    assert ok and lcm_list(SA) == lcm_list(SB) == 6
    assert equal_lcm_subsets([4], [2, 8])[0] is False
    assert equal_lcm_subsets([2, 3], [6])[0] is True
    main()
\end{minted}
\VALIDATION{Three asserts:
\begin{bullets}
\item $[6]$ vs $[2,3]$ yields equal LCM $6$.
\item $[4]$ vs $[2,8]$ is impossible.
\item $[2,3]$ vs $[6]$ is possible.
\end{bullets}}
\RESULT{If YES, the printed survivors $A',B'$ satisfy $\mathrm{lcm}(A')=\mathrm{lcm}(B')$, and both are non-empty. Any such pair is accepted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for core pruning; random small cases compared to brute force; crafted adversarial cases with high powers and co-prime mixes.}
\LINE{CROSS-CHECKS}{Compare Improved/Optimal pruning vs brute force on small $n,m$; ensure agreement on YES/NO and that LCMs match when YES.}
\LINE{EDGE-CASE GENERATOR}{Generate mixtures of primes and powers: singletons, pure powers, co-prime sets, overlapping prime supports, and cases forcing cascading deletions.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random, math
from typing import List, Tuple

def gen_powers(prime: int, exps: List[int]) -> List[int]:
    return [prime ** e for e in exps]

def gen_mixed() -> Tuple[List[int], List[int]]:
    A = [2, 3, 4, 9, 6, 10]
    B = [2, 8, 3, 9, 6, 15]
    return A, B

def slow_bruteforce(a: List[int], b: List[int]) -> bool:
    from itertools import combinations
    def lcm(a: int, b: int) -> int:
        return a // math.gcd(a, b) * b
    def lcm_list(v: List[int]) -> int:
        cur = 1
        for x in v:
            cur = lcm(cur, x)
        return cur
    n, m = len(a), len(b)
    for r in range(1, n+1):
        for SA in combinations(a, r):
            LA = lcm_list(list(SA))
            for s in range(1, m+1):
                for SB in combinations(b, s):
                    if LA == lcm_list(list(SB)):
                        return True
    return False
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

def lcm(a: int, b: int) -> int:
    return a // math.gcd(a, b) * b

def equal_lcm_subsets(a: List[int], b: List[int]) -> Tuple[bool, List[int], List[int]]:
    n, m = len(a), len(b)
    G = [[0] * m for _ in range(n)]
    for i in range(n):
        ai = a[i]
        for j in range(m):
            G[i][j] = math.gcd(ai, b[j])
    actA = [True] * n
    actB = [True] * m
    cntA, cntB = n, m
    changed = True
    while changed:
        changed = False
        for i in range(n):
            if not actA[i]:
                continue
            li = 1
            for j in range(m):
                if not actB[j]:
                    continue
                g = G[i][j]
                if g != 1:
                    li = lcm(li, g)
                    if li == a[i]:
                        break
            if li != a[i]:
                actA[i] = False
                cntA -= 1
                changed = True
        if cntA == 0 or cntB == 0:
            break
        for j in range(m):
            if not actB[j]:
                continue
            lj = 1
            for i in range(n):
                if not actA[i]:
                    continue
                g = G[i][j]
                if g != 1:
                    lj = lcm(lj, g)
                    if lj == b[j]:
                        break
            if lj != b[j]:
                actB[j] = False
                cntB -= 1
                changed = True
        if cntA == 0 or cntB == 0:
            break
    if cntA == 0 or cntB == 0:
        return False, [], []
    SA = [a[i] for i in range(n) if actA[i]]
    SB = [b[j] for j in range(m) if actB[j]]
    return True, SA, SB

def read_input(data: bytes):
    it = iter(data.split())
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        A = [int(next(it)) for _ in range(n)]
        B = [int(next(it)) for _ in range(m)]
        cases.append((A, B))
    return t, cases

def solve_case(a: List[int], b: List[int]) -> str:
    ok, SA, SB = equal_lcm_subsets(a, b)
    if not ok:
        return "NO"
    out = []
    out.append("YES")
    out.append(f"{len(SA)} {len(SB)}")
    out.append(" ".join(str(x) for x in SA))
    out.append(" ".join(str(x) for x in SB))
    return "\n".join(out)

def solve_all(data: bytes) -> str:
    t, cases = read_input(data)
    out_lines = []
    for A, B in cases:
        out_lines.append(solve_case(A, B))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.buffer.read()
    if not data:
        return
    print(solve_all(data))

if __name__ == "__main__":
    # Reference asserts
    def lcm_list(v: List[int]) -> int:
        cur = 1
        for x in v:
            cur = lcm(cur, x)
        return cur
    ok, SA, SB = equal_lcm_subsets([6], [2, 3])
    assert ok and lcm_list(SA) == lcm_list(SB) == 6
    assert equal_lcm_subsets([4], [2, 8])[0] is False
    assert equal_lcm_subsets([2, 3], [6])[0] is True
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Iteratively prune elements not prime-power-coverable by the other side via $\mathrm{lcm}$ of pairwise $\gcd$s; survivors have equal LCM.}
\WHY{Classic high-rated CF pattern: avoid factorization and gigantic LCMs using $\gcd$-only reasoning and fixed-point pruning.}
\CHECKLIST{
\begin{bullets}
\item Precompute all $\gcd(a_i,b_j)$.
\item Maintain active masks for $A$ and $B$.
\item Loop: prune $A$ by $C_A(i)$, prune $B$ by $C_B(j)$.
\item Early exit if a side empties.
\item Output survivors if non-empty.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item One side initially empty after pruning.
\item Elements equal to $1$.
\item All numbers pairwise co-prime across sides.
\item Large prime powers (coverage must match exponents).
\item Cascading deletions where removal on one side invalidates the other.
\item Duplicated prime supports but distinct magnitudes.
\item Singletons: $[x]$ vs subset combining multiple co-primes to match $x$.
\item Very large integers (ensure only divisors via $\gcd$ are lcm'ed).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Computing global LCMs of entire sets (can explode in size).
\item Forgetting that $C_A(i)$ must be recomputed wrt current active $B'$.
\item Not breaking early when $C_A(i)$ reaches $a_i$.
\item Mixing product-based coverage instead of $\mathrm{lcm}$ of pairwise $\gcd$s.
\item Using 64-bit types; use arbitrary-precision integers.
\item Off-by-one in I/O across multiple tests.
\item Not handling $1$ correctly (always removable unless matched by $1$ on the other side).
\end{bullets}
}
\FAILMODES{Brute force times out; product-based heuristics give false positives due to additive prime exponents; factoring is infeasible for $4\cdot 10^{36}$. The pruning approach survives all such traps.}
\ELI{Keep only numbers whose every prime-power chunk can be supplied by the other side (possibly by different numbers). After repeatedly removing unsupported numbers, what remains, if any, matches exactly in LCM.}
\NotePages{3}

\end{document}