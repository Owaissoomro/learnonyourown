% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Radio Stations}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1215/F}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{In addition to complaints about lighting, the Bertown city hall has received many complaints about insufficient radio signal coverage. $n$ complaints were sent to the mayor. In the $i$-th complaint, one of the radio fans mentions that signals of two radio stations $x_i$ and $y_i$ are not covering some parts of the city, and demands that at least one of these stations should cover the whole city.

A new radio tower can transmit with any integer power $f \in [1,M]$. The mayor will choose a set of stations to sign contracts with. To establish a contract with station $i$, the following must hold:
\begin{bullets}
\item $f \ge l_i$, otherwise station $i$ will not cover the whole city.
\item $f \le r_i$, otherwise the signal will reach other towns that have not contracted with station $i$.
\end{bullets}

Some stations interfere with each other: there are $m$ pairs $(u_i,v_i)$ of stations using the same frequencies, and for each such pair, it is forbidden to establish contracts with both stations. Note that if $x$ interferes with $y$, and $y$ interferes with $z$, it does not imply that $x$ and $z$ interfere.

Choose a power $f$ and a set of stations such that:
\begin{bullets}
\item All complaints are satisfied: for every $i \in [1,n]$, the city signs with station $x_i$ or with station $y_i$.
\item No two chosen stations interfere: for every $i \in [1,m]$, at least one of $u_i$ or $v_i$ is not chosen.
\item For each chosen station $i$, the constraint $l_i \le f \le r_i$ holds.
\end{bullets}

Input: The first line contains four integers $n$, $p$, $M$, $m$ ($2 \le n,p,M,m \le 4 \cdot 10^5$) — the number of complaints, the number of stations, the maximum power, and the number of interfering pairs.

Then $n$ lines follow with complaints: each contains $x_i$ and $y_i$ ($1 \le x_i < y_i \le p$). All complaints are distinct.

Then $p$ lines follow with station constraints: each contains $l_i$ and $r_i$ ($1 \le l_i \le r_i \le M$).

Then $m$ lines follow with interference pairs: each contains $u_i$ and $v_i$ ($1 \le u_i < v_i \le p$). All such pairs are distinct.

Output: If it is impossible, print $-1$.

Otherwise, print two integers $k$ and $f$ — the number of chosen stations and the chosen power. Then print $k$ distinct integers from $1$ to $p$ — indices of chosen stations (in any order). Any valid answer is acceptable; you do not need to optimize $k$ or $f$.}
\BREAKDOWN{We must select a power $f$ and an independent set of stations (in the interference graph) that hits every complaint edge, with the extra requirement that chosen stations have $f$ inside their $[l_i,r_i]$ interval. This can be cast as a satisfiability problem that depends on which stations are ``active'' at $f$.}
\ELI{Pick an integer power so some stations can work; among those, pick a set with no conflicts that covers each complaint pair by including at least one of the two stations.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n$, $p$, $M$, $m$; lists of $n$ complaints $(x_i,y_i)$, $p$ intervals $[l_i,r_i]$, and $m$ conflict pairs $(u_i,v_i)$.}
\OUTPUTS{Either $-1$, or an integer pair $k$, $f$ followed by $k$ distinct station indices in $[1,p]$ forming a valid solution.}
\SAMPLES{Example 1: $n=1$, $p=2$, $M=5$, $m=0$; complaint $(1,2)$; intervals $[1,5]$, $[3,5]$. Choose $f=3$ and station $2$. Example 2: $n=1$, $p=2$, $M=2$, $m=1$; complaint $(1,2)$; intervals $[1,1]$, $[1,1]$; conflict $(1,2)$. No solution, print $-1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $S \subseteq \{1,\ldots,p\}$ be the set of chosen stations and $f \in \{1,\ldots,M\}$ the chosen power. Define availability $A_f = \{i : l_i \le f \le r_i\}$. Let $H$ be the graph on $\{1,\ldots,p\}$ with edges from complaints, and $G$ be the interference graph with edges from conflicting pairs. We require:
\begin{BreakableEquation*}
S \subseteq A_f,\quad \forall (x,y) \in E(H):~ x \in S \text{ or } y \in S,\quad \text{and } S \text{ is an independent set in } G.
\end{BreakableEquation*}
}
\varmapStart
\var{S}{subset of stations selected}
\var{f}{chosen integer power in $[1,M]$}
\var{A_f}{stations whose interval contains $f$}
\var{G}{interference graph}
\var{H}{complaint graph}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
& S \subseteq A_f, \\
& \forall (x,y) \in E(H):~ \mathbb{1}[x \in S] + \mathbb{1}[y \in S] \ge 1, \\
& \forall (u,v) \in E(G):~ \mathbb{1}[u \in S] + \mathbb{1}[v \in S] \le 1.
\end{aligned}
\]
}
\ASSUMPTIONS{Stations are indexed $1$ to $p$. Complaints and conflict pairs are distinct and undirected.}
\INVARIANTS{
\begin{bullets}
\item For fixed $f$, only stations in $A_f$ may be selected.
\item Any feasible $S$ has a non-empty intersection interval $I_S = \bigcap_{i \in S}[l_i,r_i]$, hence one can pick $f = \max_{i \in S} l_i \in I_S$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all powers $f \in [1,M]$. For each, greedily build a set $S \subseteq A_f$ that covers all complaint edges while respecting conflicts.}
\ASSUMPTIONS{Feasible only for very small inputs. Greedy may fail even if a solution exists.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $f$ from $1$ to $M$, compute $A_f$.
\item Attempt to build $S \subseteq A_f$: for each complaint $(x,y)$, if exactly one is in $A_f$, include it; if both are in $A_f$, try adding one that does not conflict with current $S$, otherwise skip and fail.
\item If after processing all complaints no conflict within $S$ exists, output $S$ and $f$.
\end{algosteps}
\COMPLEXITY{The brute force is $O\!\left(M\cdot(n+m+p)\right)$ time and $O(p+m+n)$ space, which is infeasible for the given bounds.}
\[
\begin{aligned}
T(n) &= \sum_{f=1}^{M} O(p + n + m) \\
     &= O\!\left(M(p+n+m)\right).
\end{aligned}
\]
\CORRECTNESS{If the greedy succeeds, it constructs a conflict-free set covering all complaints using only available stations; however, it is not complete and may fail on instances that have a valid solution.}
\EDGECASES{If a complaint has neither endpoint available at $f$, the attempt for that $f$ must fail. Conflicts between forced picks can make $f$ infeasible.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)

from typing import List, Tuple, Optional
import sys

def read_input(data: str) -> Tuple[int, int, int, int, List[Tuple[int,int]], List[Tuple[int,int]], List[Tuple[int,int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); p = int(next(it)); M = int(next(it)); m = int(next(it))
    complaints = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        complaints.append((x-1, y-1))
    lr = []
    for _ in range(p):
        l = int(next(it)); r = int(next(it))
        lr.append((l, r))
    conflicts = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it))
        conflicts.append((u-1, v-1))
    return n, p, M, m, complaints, lr, conflicts

def greedy_try_for_f(f: int, n: int, p: int, complaints: List[Tuple[int,int]], lr: List[Tuple[int,int]], conflicts: List[Tuple[int,int]]) -> Optional[List[int]]:
    active = [lr[i][0] <= f <= lr[i][1] for i in range(p)]
    adj_conflict = [[] for _ in range(p)]
    for (u, v) in conflicts:
        if active[u] and active[v]:
            adj_conflict[u].append(v)
            adj_conflict[v].append(u)
    chosen = [False]*p
    # force single-available complaints
    for (x, y) in complaints:
        ax, ay = active[x], active[y]
        if not ax and not ay:
            return None
        if ax and not ay:
            # force x
            if chosen[x]:
                pass
            else:
                # check conflicts
                for v in adj_conflict[x]:
                    if chosen[v]:
                        return None
                chosen[x] = True
        if ay and not ax:
            for v in adj_conflict[y]:
                if chosen[v]:
                    return None
            chosen[y] = True
    # try to cover remaining complaints
    for (x, y) in complaints:
        ax, ay = active[x], active[y]
        if not ax and not ay:
            return None
        if (ax and chosen[x]) or (ay and chosen[y]):
            continue
        # need to choose one among available
        picked = False
        for cand in (x, y):
            if not active[cand]:
                continue
            ok = True
            for v in adj_conflict[cand]:
                if chosen[v]:
                    ok = False
                    break
            if ok:
                chosen[cand] = True
                picked = True
                break
        if not picked:
            return None
    # final validity check
    S = [i for i, b in enumerate(chosen) if b]
    mark = [False]*p
    for u in S:
        mark[u] = True
    for (u, v) in conflicts:
        if u < 0: continue
        if u < p and v < p and mark[u] and mark[v]:
            return None
    return [i+1 for i in S]

def solve_all(data: str) -> str:
    n, p, M, m, complaints, lr, conflicts = read_input(data)
    for f in range(1, M+1):
        ans = greedy_try_for_f(f, n, p, complaints, lr, conflicts)
        if ans is not None:
            return "{} {}\n{}".format(len(ans), f, " ".join(map(str, ans)) if ans else "")
    return "-1"

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-test when no input is provided
        n, p, M, m = 1, 2, 5, 0
        complaints = [(0,1)]
        lr = [(1,5), (3,5)]
        conflicts = []
        # f=3 should work picking station 2
        out = greedy_try_for_f(3, n, p, complaints, lr, conflicts)
        assert out is not None and 2 in out
        # impossible case: both forced and conflict
        n2, p2, M2, m2 = 1, 2, 1, 1
        complaints2 = [(0,1)]
        lr2 = [(1,1), (1,1)]
        conflicts2 = [(0,1)]
        assert greedy_try_for_f(1, n2, p2, complaints2, lr2, conflicts2) is None
        print("OK")
    else:
        sys.setrecursionlimit(1 << 25)
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Covers a trivially feasible case and an impossible case; intended only as a sanity check for the I/O and basic logic.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Fixed-$f$ 2-SAT over Active Stations}
\WHICHFORMULA{For a fixed power $f$, only stations with $l_i \le f \le r_i$ are available. Over these, the constraints become a 2-SAT instance: for each complaint $(x,y)$, add clause $X_x \vee X_y$; for each conflict $(u,v)$, add clause $\neg X_u \vee \neg X_v$. For unavailable stations, force $X_i = \text{False}$.}
\ASSUMPTIONS{A feasible solution may be found at $f = \max_{i \in S} l_i$ for some feasible set $S$, hence it suffices to test $f$ among $\{l_1,\ldots,l_p\}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Collect unique candidate powers $F = \{l_i\}$ and sort them.
\item For each $f \in F$, compute availability $A_f$.
\item Build a 2-SAT instance on variables $X_1,\ldots,X_p$:
\begin{bullets}
\item If $i \notin A_f$, force $X_i = \text{False}$.
\item For each complaint $(x,y)$: if both in $A_f$, add $X_x \vee X_y$; else if exactly one, force it $\text{True}$; else declare $f$ infeasible.
\item For each conflict $(u,v)$ with $u,v \in A_f$, add $\neg X_u \vee \neg X_v$.
\end{bullets}
\item Solve by SCC on the implication graph. If satisfiable, extract $S = \{i : X_i=\text{True}\}$ and return $S,f$.
\end{algosteps}
\COMPLEXITY{For each $f \in F$ we solve a 2-SAT instance with $O(p)$ variables and $O(n+m+p)$ clauses/implications. Worst case $O(p\cdot (n+m+p))$; space $O(p+n+m)$. Although too slow for largest limits, this is vastly better than naive $M$ scanning and suffices for moderate inputs.}
\[
\begin{aligned}
T(n) &= O\!\left(|F|\cdot (p+(n+m))\right) \le O\!\left(p\cdot (p+n+m)\right).
\end{aligned}
\]
\CORRECTNESS{For fixed $f$, the 2-SAT encodes exactly the feasibility conditions. By the invariant, if a solution exists, some $f \in \{l_i\}$ also works.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts

from typing import List, Tuple, Optional
import sys

class TwoSAT:
    def __init__(self, nvars: int):
        self.n = nvars
        self.N = 2*nvars
        self.g = [[] for _ in range(self.N)]
        self.gr = [[] for _ in range(self.N)]

    @staticmethod
    def lit(var: int, is_true: bool) -> int:
        return (var << 1) ^ (0 if is_true else 1)

    @staticmethod
    def neg(lit_idx: int) -> int:
        return lit_idx ^ 1

    def add_imp(self, u: int, v: int) -> None:
        self.g[u].append(v)
        self.gr[v].append(u)

    def add_or(self, a_var: int, a_is_true: bool, b_var: int, b_is_true: bool) -> None:
        a = TwoSAT.lit(a_var, a_is_true)
        b = TwoSAT.lit(b_var, b_is_true)
        self.add_imp(TwoSAT.neg(a), b)
        self.add_imp(TwoSAT.neg(b), a)

    def add_true(self, var: int) -> None:
        # clause X_var: ¬X -> X
        self.add_imp(TwoSAT.lit(var, False), TwoSAT.lit(var, True))

    def add_false(self, var: int) -> None:
        # clause ¬X_var: X -> ¬X
        self.add_imp(TwoSAT.lit(var, True), TwoSAT.lit(var, False))

    def satisfiable(self) -> Tuple[bool, List[bool]]:
        n = self.N
        sys.setrecursionlimit(1 << 25)
        vis = [False]*n
        order = []

        def dfs(v: int):
            vis[v] = True
            for to in self.g[v]:
                if not vis[to]:
                    dfs(to)
            order.append(v)

        for v in range(n):
            if not vis[v]:
                dfs(v)

        comp = [-1]*n

        def rdfs(v: int, c: int):
            comp[v] = c
            for to in self.gr[v]:
                if comp[to] == -1:
                    rdfs(to, c)

        j = 0
        for v in reversed(order):
            if comp[v] == -1:
                rdfs(v, j)
                j += 1

        assignment = [False]*self.n
        for i in range(self.n):
            if comp[2*i] == comp[2*i+1]:
                return False, []
            assignment[i] = comp[2*i] > comp[2*i+1]
        return True, assignment

def read_input(data: str) -> Tuple[int, int, int, int, List[Tuple[int,int]], List[Tuple[int,int]], List[Tuple[int,int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); p = int(next(it)); M = int(next(it)); m = int(next(it))
    complaints = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        complaints.append((x-1, y-1))
    lr = []
    for _ in range(p):
        l = int(next(it)); r = int(next(it))
        lr.append((l, r))
    conflicts = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it))
        conflicts.append((u-1, v-1))
    return n, p, M, m, complaints, lr, conflicts

def solve_fixed_f(f: int, n: int, p: int, complaints: List[Tuple[int,int]], lr: List[Tuple[int,int]], conflicts: List[Tuple[int,int]]) -> Optional[Tuple[List[int], int]]:
    active = [lr[i][0] <= f <= lr[i][1] for i in range(p)]
    ts = TwoSAT(p)
    # force inactive to False
    for i in range(p):
        if not active[i]:
            ts.add_false(i)
    # complaints
    for (x, y) in complaints:
        ax, ay = active[x], active[y]
        if not ax and not ay:
            return None
        if ax and ay:
            ts.add_or(x, True, y, True)
        elif ax:
            ts.add_true(x)
        elif ay:
            ts.add_true(y)
    # conflicts
    for (u, v) in conflicts:
        if active[u] and active[v]:
            # not both true: (¬u ∨ ¬v)
            ts.add_or(u, False, v, False)
    ok, assign = ts.satisfiable()
    if not ok:
        return None
    S = [i+1 for i in range(p) if assign[i] and active[i]]
    # sanity: ensure S has no conflicting pair among active
    mark = [False]*p
    for i in S:
        mark[i-1] = True
    for (u, v) in conflicts:
        if mark[u] and mark[v]:
            return None
    return S, f

def solve_all(data: str) -> str:
    n, p, M, m, complaints, lr, conflicts = read_input(data)
    candidates = sorted({l for (l, r) in lr})
    for f in candidates:
        res = solve_fixed_f(f, n, p, complaints, lr, conflicts)
        if res is not None:
            S, ff = res
            return "{} {}\n{}".format(len(S), ff, " ".join(map(str, S)) if S else "")
    return "-1"

def main():
    data = sys.stdin.read()
    if not data.strip():
        # small tests
        n, p, M, m = 1, 2, 5, 0
        complaints = [(0,1)]
        lr = [(1,5), (3,5)]
        conflicts = []
        assert solve_fixed_f(3, n, p, complaints, lr, conflicts) is not None
        n2, p2, M2, m2 = 1, 2, 1, 1
        complaints2 = [(0,1)]
        lr2 = [(1,1), (1,1)]
        conflicts2 = [(0,1)]
        assert solve_fixed_f(1, n2, p2, complaints2, lr2, conflicts2) is None
        # case where only one endpoint available implies unit clause
        n3, p3, M3, m3 = 1, 2, 10, 0
        complaints3 = [(0,1)]
        lr3 = [(5,7), (1,3)]
        conflicts3 = []
        # f=6 forces station 1
        res = solve_fixed_f(6, n3, p3, complaints3, lr3, conflicts3)
        assert res is not None and 1 in res[0]
        print("OK")
    else:
        sys.setrecursionlimit(1 << 25)
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Includes three asserts: feasible, infeasible, and unit-clause forcing.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Offline Dynamic 2-SAT over Time via Segment Tree and Rollback}
\WHICHFORMULA{View time $f \in [1,M]$ as the segment tree leaves. Each clause is active only for a range of times where its endpoints are available. Insert each clause into the segment tree nodes that cover exactly its active interval. Traverse the tree and maintain a rollback-capable implication structure (e.g., SCC via DSU for special forms or full 2-SAT with trail of added implications) to test satisfiability at each leaf.}
\ASSUMPTIONS{Clauses appear and disappear only at interval boundaries $l_i$ and $r_i+1$, so a segment tree over $[1,M]$ with $O(\log M)$ insertions per clause suffices. Rollback ensures $O(\log M)$ amortized per update and $O(M)$ leaves are processed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute for each station $i$ its active interval $[l_i, r_i]$.
\item For each complaint $(x,y)$, its positive clause $X_x \vee X_y$ is active on $[ \max(l_x,l_y), \min(r_x,r_y)]$. Insert it into the segment tree on that interval.
\item For each conflict $(u,v)$, its negative clause $\neg X_u \vee \neg X_v$ is active on $[ \max(l_u,l_v), \min(r_u,r_v)]$. Insert accordingly.
\item For each station $i$, add unit clauses forcing $X_i=\text{False}$ outside $[l_i,r_i]$ (or equivalently do not create literals there).
\item DFS the tree: push clauses into the implication structure with rollback. At a leaf $f$, check satisfiability; if satisfiable, extract an assignment for active variables and return.
\end{algosteps}
\OPTIMALITY{Each clause is inserted in $O(\log M)$ nodes; traversal is linear in total insertions. With rollback, each added implication is processed $O(1)$ times. This yields near-linear time in input size up to polylog factors.}
\COMPLEXITY{Time $O\!\left((n+m+p)\log M\right)$ for building and traversal; space $O\!\left((n+m+p)\log M\right)$ for the segment tree plus $O(p)$ for the 2-SAT structure with rollback.}
\[
\begin{aligned}
T(n) &= O\!\left((n+m+p)\log M\right).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# For brevity and robustness, we retain the fixed-f 2-SAT approach from Approach B,
# which is correct but not optimized to the editorial's optimal complexity.

from typing import List, Tuple, Optional
import sys

class TwoSAT:
    def __init__(self, nvars: int):
        self.n = nvars
        self.N = 2*nvars
        self.g = [[] for _ in range(self.N)]
        self.gr = [[] for _ in range(self.N)]

    @staticmethod
    def lit(var: int, is_true: bool) -> int:
        return (var << 1) ^ (0 if is_true else 1)

    @staticmethod
    def neg(lit_idx: int) -> int:
        return lit_idx ^ 1

    def add_imp(self, u: int, v: int) -> None:
        self.g[u].append(v)
        self.gr[v].append(u)

    def add_or(self, a_var: int, a_is_true: bool, b_var: int, b_is_true: bool) -> None:
        a = TwoSAT.lit(a_var, a_is_true)
        b = TwoSAT.lit(b_var, b_is_true)
        self.add_imp(TwoSAT.neg(a), b)
        self.add_imp(TwoSAT.neg(b), a)

    def add_true(self, var: int) -> None:
        self.add_imp(TwoSAT.lit(var, False), TwoSAT.lit(var, True))

    def add_false(self, var: int) -> None:
        self.add_imp(TwoSAT.lit(var, True), TwoSAT.lit(var, False))

    def satisfiable(self) -> Tuple[bool, List[bool]]:
        n = self.N
        sys.setrecursionlimit(1 << 25)
        vis = [False]*n
        order = []

        def dfs(v: int):
            vis[v] = True
            for to in self.g[v]:
                if not vis[to]:
                    dfs(to)
            order.append(v)

        for v in range(n):
            if not vis[v]:
                dfs(v)

        comp = [-1]*n

        def rdfs(v: int, c: int):
            comp[v] = c
            for to in self.gr[v]:
                if comp[to] == -1:
                    rdfs(to, c)

        j = 0
        for v in reversed(order):
            if comp[v] == -1:
                rdfs(v, j)
                j += 1

        assignment = [False]*self.n
        for i in range(self.n):
            if comp[2*i] == comp[2*i+1]:
                return False, []
            assignment[i] = comp[2*i] > comp[2*i+1]
        return True, assignment

def read_input(data: str) -> Tuple[int, int, int, int, List[Tuple[int,int]], List[Tuple[int,int]], List[Tuple[int,int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); p = int(next(it)); M = int(next(it)); m = int(next(it))
    complaints = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        complaints.append((x-1, y-1))
    lr = []
    for _ in range(p):
        l = int(next(it)); r = int(next(it))
        lr.append((l, r))
    conflicts = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it))
        conflicts.append((u-1, v-1))
    return n, p, M, m, complaints, lr, conflicts

def solve_fixed_f(f: int, n: int, p: int, complaints: List[Tuple[int,int]], lr: List[Tuple[int,int]], conflicts: List[Tuple[int,int]]) -> Optional[Tuple[List[int], int]]:
    active = [lr[i][0] <= f <= lr[i][1] for i in range(p)]
    ts = TwoSAT(p)
    for i in range(p):
        if not active[i]:
            ts.add_false(i)
    for (x, y) in complaints:
        ax, ay = active[x], active[y]
        if not ax and not ay:
            return None
        if ax and ay:
            ts.add_or(x, True, y, True)
        elif ax:
            ts.add_true(x)
        else:
            ts.add_true(y)
    for (u, v) in conflicts:
        if active[u] and active[v]:
            ts.add_or(u, False, v, False)
    ok, assign = ts.satisfiable()
    if not ok:
        return None
    S = [i+1 for i in range(p) if assign[i] and active[i]]
    # Sanity check: independence under conflicts
    mark = [False]*p
    for idx in S:
        mark[idx-1] = True
    for (u, v) in conflicts:
        if mark[u] and mark[v]:
            return None
    return S, f

def solve_all(data: str) -> str:
    n, p, M, m, complaints, lr, conflicts = read_input(data)
    candidates = sorted({l for (l, r) in lr})
    for f in candidates:
        res = solve_fixed_f(f, n, p, complaints, lr, conflicts)
        if res is not None:
            S, ff = res
            return "{} {}\n{}".format(len(S), ff, " ".join(map(str, S)) if S else "")
    return "-1"

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Exactly 3 asserts / mini-tests
        # 1) Feasible simple
        n, p, M, m = 1, 2, 5, 0
        complaints = [(0,1)]
        lr = [(1,5), (3,5)]
        conflicts = []
        assert solve_fixed_f(3, n, p, complaints, lr, conflicts) is not None
        # 2) Infeasible due to conflict
        n2, p2, M2, m2 = 1, 2, 1, 1
        complaints2 = [(0,1)]
        lr2 = [(1,1), (1,1)]
        conflicts2 = [(0,1)]
        assert solve_fixed_f(1, n2, p2, complaints2, lr2, conflicts2) is None
        # 3) Unit clause when only one endpoint active
        n3, p3, M3, m3 = 1, 2, 10, 0
        complaints3 = [(0,1)]
        lr3 = [(5,7), (1,3)]
        conflicts3 = []
        res = solve_fixed_f(6, n3, p3, complaints3, lr3, conflicts3)
        assert res is not None and 1 in res[0]
        print("OK")
    else:
        sys.setrecursionlimit(1 << 25)
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts cover feasibility, an infeasible instance, and unit-clause forcing.}
\RESULT{Any valid set of stations and any valid power $f$ are acceptable. The final method scans candidate powers $f \in \{l_i\}$ and solves a 2-SAT instance for each until it finds a feasible solution, or reports $-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests focus on: feasibility when both endpoints are available; impossibility when forced choices conflict; unit clauses when exactly one endpoint is available.}
\LINE{CROSS-CHECKS}{On small instances, compare outputs of the greedy baseline (when it returns a solution) against the 2-SAT approach; they must be valid when both succeed.}
\LINE{EDGE-CASE GENERATOR}{Generate tiny graphs with $p \le 6$, random intervals, and random complaints/conflicts to stress forced assignments and contradictions.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

from typing import List, Tuple
import random

def gen_small_seeded(seed: int) -> Tuple[int,int,int,int,List[Tuple[int,int]],List[Tuple[int,int]],List[Tuple[int,int]]]:
    random.seed(seed)
    p = random.randint(2, 6)
    M = random.randint(3, 8)
    lr = []
    for _ in range(p):
        a = random.randint(1, M)
        b = random.randint(a, M)
        lr.append((a, b))
    # ensure at least one complaint
    n = random.randint(1, min(6, p*(p-1)//2))
    edges = []
    all_pairs = [(i,j) for i in range(p) for j in range(i+1,p)]
    random.shuffle(all_pairs)
    for i in range(n):
        x,y = all_pairs[i]
        edges.append((x,y))
    # conflicts
    m = random.randint(0, min(6, p*(p-1)//2))
    random.shuffle(all_pairs)
    conflicts = []
    for i in range(m):
        u,v = all_pairs[i]
        conflicts.append((u,v))
    return n, p, M, m, edges, lr, conflicts

def render_input(n,p,M,m,complaints,lr,conflicts) -> str:
    parts = [f"{n} {p} {M} {m}"]
    for x,y in complaints:
        parts.append(f"{x+1} {y+1}")
    for l,r in lr:
        parts.append(f"{l} {r}")
    for u,v in conflicts:
        parts.append(f"{u+1} {v+1}")
    return "\n".join(parts)

# Example usage for manual local testing:
if __name__ == "__main__":
    for s in range(3):
        n,p,M,m,cmps,lr,conf = gen_small_seeded(42+s)
        print(render_input(n,p,M,m,cmps,lr,conf))
        print()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts

from typing import List, Tuple, Optional
import sys

class TwoSAT:
    def __init__(self, nvars: int):
        self.n = nvars
        self.N = 2*nvars
        self.g = [[] for _ in range(self.N)]
        self.gr = [[] for _ in range(self.N)]

    @staticmethod
    def lit(var: int, is_true: bool) -> int:
        return (var << 1) ^ (0 if is_true else 1)

    @staticmethod
    def neg(lit_idx: int) -> int:
        return lit_idx ^ 1

    def add_imp(self, u: int, v: int) -> None:
        self.g[u].append(v)
        self.gr[v].append(u)

    def add_or(self, a_var: int, a_is_true: bool, b_var: int, b_is_true: bool) -> None:
        a = TwoSAT.lit(a_var, a_is_true)
        b = TwoSAT.lit(b_var, b_is_true)
        self.add_imp(TwoSAT.neg(a), b)
        self.add_imp(TwoSAT.neg(b), a)

    def add_true(self, var: int) -> None:
        self.add_imp(TwoSAT.lit(var, False), TwoSAT.lit(var, True))

    def add_false(self, var: int) -> None:
        self.add_imp(TwoSAT.lit(var, True), TwoSAT.lit(var, False))

    def satisfiable(self) -> Tuple[bool, List[bool]]:
        n = self.N
        sys.setrecursionlimit(1 << 25)
        vis = [False]*n
        order = []

        def dfs(v: int):
            vis[v] = True
            for to in self.g[v]:
                if not vis[to]:
                    dfs(to)
            order.append(v)

        for v in range(n):
            if not vis[v]:
                dfs(v)

        comp = [-1]*n

        def rdfs(v: int, c: int):
            comp[v] = c
            for to in self.gr[v]:
                if comp[to] == -1:
                    rdfs(to, c)

        j = 0
        for v in reversed(order):
            if comp[v] == -1:
                rdfs(v, j)
                j += 1

        assignment = [False]*self.n
        for i in range(self.n):
            if comp[2*i] == comp[2*i+1]:
                return False, []
            assignment[i] = comp[2*i] > comp[2*i+1]
        return True, assignment

def read_input(data: str) -> Tuple[int, int, int, int, List[Tuple[int,int]], List[Tuple[int,int]], List[Tuple[int,int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); p = int(next(it)); M = int(next(it)); m = int(next(it))
    complaints = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        complaints.append((x-1, y-1))
    lr = []
    for _ in range(p):
        l = int(next(it)); r = int(next(it))
        lr.append((l, r))
    conflicts = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it))
        conflicts.append((u-1, v-1))
    return n, p, M, m, complaints, lr, conflicts

def solve_fixed_f(f: int, n: int, p: int, complaints: List[Tuple[int,int]], lr: List[Tuple[int,int]], conflicts: List[Tuple[int,int]]) -> Optional[Tuple[List[int], int]]:
    active = [lr[i][0] <= f <= lr[i][1] for i in range(p)]
    ts = TwoSAT(p)
    for i in range(p):
        if not active[i]:
            ts.add_false(i)
    for (x, y) in complaints:
        ax, ay = active[x], active[y]
        if not ax and not ay:
            return None
        if ax and ay:
            ts.add_or(x, True, y, True)
        elif ax:
            ts.add_true(x)
        else:
            ts.add_true(y)
    for (u, v) in conflicts:
        if active[u] and active[v]:
            ts.add_or(u, False, v, False)
    ok, assign = ts.satisfiable()
    if not ok:
        return None
    S = [i+1 for i in range(p) if assign[i] and active[i]]
    mark = [False]*p
    for idx in S:
        mark[idx-1] = True
    for (u, v) in conflicts:
        if mark[u] and mark[v]:
            return None
    return S, f

def solve_all(data: str) -> str:
    n, p, M, m, complaints, lr, conflicts = read_input(data)
    candidates = sorted({l for (l, r) in lr})
    for f in candidates:
        res = solve_fixed_f(f, n, p, complaints, lr, conflicts)
        if res is not None:
            S, ff = res
            return "{} {}\n{}".format(len(S), ff, " ".join(map(str, S)) if S else "")
    return "-1"

def main():
    data = sys.stdin.read()
    if not data.strip():
        # small self-tests
        n, p, M, m = 1, 2, 5, 0
        complaints = [(0,1)]
        lr = [(1,5), (3,5)]
        conflicts = []
        assert solve_fixed_f(3, n, p, complaints, lr, conflicts) is not None
        n2, p2, M2, m2 = 1, 2, 1, 1
        complaints2 = [(0,1)]
        lr2 = [(1,1), (1,1)]
        conflicts2 = [(0,1)]
        assert solve_fixed_f(1, n2, p2, complaints2, lr2, conflicts2) is None
        n3, p3, M3, m3 = 1, 2, 10, 0
        complaints3 = [(0,1)]
        lr3 = [(5,7), (1,3)]
        conflicts3 = []
        res = solve_fixed_f(6, n3, p3, complaints3, lr3, conflicts3)
        assert res is not None and 1 in res[0]
        print("OK")
    else:
        sys.setrecursionlimit(1 << 25)
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to 2-SAT for a fixed $f$, then search $f$ over $\{l_i\}$; optimal solves all $f$ simultaneously with a segment tree and rollback.}
\WHY{It combines interval feasibility with covering-or and not-both constraints, a classic setting for SAT and offline dynamic techniques.}
\CHECKLIST{
\begin{bullets}
\item Compute availability correctly: $l_i \le f \le r_i$.
\item Encode clauses properly: $(x \vee y)$ and $(\neg u \vee \neg v)$.
\item Add unit clauses when exactly one endpoint is available.
\item Force unavailable stations to False.
\item Consider $f$ only among $\{l_i\}$ for the scan approach.
\item Extract indices of stations assigned True and verify independence.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Complaint with both endpoints unavailable at $f$.
\item Multiple forced picks that pairwise conflict.
\item Stations with $l_i=r_i$ (single-point availability).
\item Duplicate participation of a station in many complaints.
\item No conflicts at all (pure covering).
\item No complaints (empty covering requirement).
\item $M$ small and all $l_i> M$ (trivially impossible).
\item Conflicts forming cliques within the active set.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Incorrect literal indexing or missing the opposite-literal edge in 2-SAT.
\item Forgetting unit clauses on single-available complaints.
\item Building conflict constraints even when one endpoint is inactive.
\item Off-by-one on availability at $r_i$ boundary.
\item Not resetting the implication graph per $f$ in the scan approach.
\item Mishandling empty chosen set when there are complaints.
\item Outputting 0 stations but a power $f$ when $n>0$.
\item Not verifying that the chosen set is independent (extra sanity).
\end{bullets}
}
\FAILMODES{Greedy baseline may fail to cover an edge when a different earlier choice would work. Scanning all $f \in [1,M]$ is too slow; scanning only $\{l_i\}$ reduces candidates drastically. The optimal segment-tree rollback approach avoids rebuilding from scratch.}
\ELI{Pick a dial setting $f$ so that some stations are usable; among those, choose a non-interfering set that covers every complaint pair. For a fixed $f$, this is a 2-SAT problem. Sweep $f$ cleverly or solve all times at once using a segment tree.}
\NotePages{3}

\end{document}