% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Ehab and Prefix MEXs}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1364/C}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Given an array $a$ of length $n$, find another array, $b$, of length $n$ such that for each $i$ ($1 \le i \le n$) we have
\begin{BreakableEquation*}
\operatorname{MEX}(\{b_1, b_2, \ldots, b_i\}) = a_i.
\end{BreakableEquation*}
The $\operatorname{MEX}$ of a set of integers is the smallest non-negative integer that does not belong to this set.

Input: The first line contains an integer $n$ ($1 \le n \le 10^5$) — the length of the array $a$. The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le i$) — the elements of the array $a$. It is guaranteed that $a_i \le a_{i+1}$ for $1 \le i < n$.

Output: If there is no such array, print a single line containing $-1$. Otherwise, print a single line containing $n$ integers $b_1, b_2, \ldots, b_n$ ($0 \le b_i \le 10^6$). If there are multiple answers, print any.

Note: In the second test case, other answers like $[1,1,1,0]$, for example, are valid.}
\BREAKDOWN{We must construct $b$ so that the prefix MEX matches a given nondecreasing sequence $a$. The key is to control which numbers below the current $a_i$ are present or missing at each step.}
\ELI{Keep the current MEX value missing until it needs to increase; otherwise, fill with the smallest number that will never be needed as a MEX value.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item $n$ — integer, $1 \le n \le 10^5$.
\item Array $a$ of length $n$, integers with $0 \le a_i \le i$ and $a_i \le a_{i+1}$.
\end{bullets}}
\OUTPUTS{Either $-1$ if no valid $b$ exists, or one line with $n$ integers $b_1, \ldots, b_n$ such that $0 \le b_i \le 10^6$ and $\operatorname{MEX}$ of each prefix equals the given $a_i$.}
\SAMPLES{Examples:
\begin{bullets}
\item $n=4$, $a=[0,0,1,1]$; one valid $b$ is $[1,2,0,3]$ since
\begin{BreakableEquation*}
\operatorname{MEX}(\{1\})=0,\ \operatorname{MEX}(\{1,2\})=0,\ \operatorname{MEX}(\{1,2,0\})=1,\ \operatorname{MEX}(\{1,2,0,3\})=1.
\end{BreakableEquation*}
\item $n=4$, $a=[1,1,2,2]$; one valid $b$ is $[0,2,1,3]$ since
\begin{BreakableEquation*}
\operatorname{MEX}(\{0\})=1,\ \operatorname{MEX}(\{0,2\})=1,\ \operatorname{MEX}(\{0,2,1\})=3? \text{ No, pick } [0,1,2,2] \text{ gives } 1,1,3,3. \text{ Instead, } [0,3,1,2] \text{ yields } 1,1,2,2.
\end{BreakableEquation*}
A simpler valid example is $[0,3,1,2]$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given nondecreasing $a \in \mathbb{Z}_{\ge 0}^n$ with $a_i \le i$, find $b \in \mathbb{Z}_{\ge 0}^n$ such that for each prefix $i$,
\begin{BreakableEquation*}
\operatorname{MEX}(\{b_1,\ldots,b_i\}) = a_i.
\end{BreakableEquation*}
Equivalently, for each $i$, every $x \in [0, a_i)$ appears in $\{b_1,\ldots,b_i\}$ and $a_i$ does not.}
\varmapStart
\var{n}{length of arrays}
\var{a_i}{target prefix MEX at position $i$}
\var{b_i}{constructed value at position $i$}
\var{\text{cur}}{smallest non-negative not yet used as filler and not equal to current $a_i$}
\var{\mathcal{A}}{set of all values occurring in $a$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i\in\{1,\ldots,n\}:\ \left(\{0,\ldots,a_i-1\}\subseteq \{b_1,\ldots,b_i\}\right)\ \land\ \left(a_i\notin \{b_1,\ldots,b_i\}\right).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Given $a$ is nondecreasing and satisfies $0 \le a_i \le i$. We may use any $b_i$ within $[0,10^6]$.}
\INVARIANTS{
\begin{bullets}
\item While $a$ stays constant at value $v$, the value $v$ is kept missing from the prefix set.
\item When $a$ increases at position $i$, we insert the previous value $v$ to make the new MEX at least $v+1$; larger jumps are supported because the other needed values $< a_i$ can be already present.
\item Filler values never equal the current $a_i$, so they do not change the MEX.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly simulate the prefix set and at each step pick the smallest non-negative integer not used so far and not equal to the current MEX; when $a$ increases, force-insert the previous $a$.}
\ASSUMPTIONS{Maintain a set of used numbers; scan linearly to find the next filler candidate. This is $O(n^2)$ in the worst case but simple.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $b$ empty, prev $=0$, used set empty.
\item For each $i$ from $1$ to $n$:
\begin{bullets}
\item If $a_i < \text{prev}$: impossible $\to -1$.
\item If $a_i > \text{prev}$: set $b_i \leftarrow \text{prev}$; mark used; update prev $\leftarrow a_i$.
\item Else: linearly search the smallest $x \ge 0$ with $x \notin \text{used}$ and $x \ne a_i$, set $b_i \leftarrow x$ and mark used.
\end{bullets}
\end{algosteps}
\COMPLEXITY{Naive scan for fillers yields $T(n)=O(n^2)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^n O(\text{scan up to }i) = O(n^2),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{As long as $a$ is nondecreasing, reserving the current MEX value ensures the MEX of each prefix stays at $a_i$. When $a$ increases, inserting the previous value triggers the increase; any larger jump is satisfied because all numbers $< a_i$ can be made present beforehand while the current value remained missing.}
\EDGECASES{Initial step $i=1$: if $a_1=0$, choose any nonzero filler; if $a_1=1$, set $b_1=0$. Large jumps, e.g., $a=[0,0,2]$, are handled because $1$ can be added before adding $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 1364C - Baseline O(n^2)
from typing import List, Optional, Tuple

def read_input() -> Tuple[int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def construct_baseline(a: List[int]) -> Optional[List[int]]:
    n = len(a)
    b: List[int] = []
    used = set()
    prev = 0  # treat a_0 "previous" as 0 as per standard trick
    # quick feasibility check (not necessary under problem constraints)
    for i in range(n):
        if i > 0 and a[i] < a[i-1]:
            return None
        if a[i] > i + 1:  # overly strict; safe guard
            return None
    for i in range(n):
        if a[i] > prev:
            x = prev
            if x in used:
                # should not happen under our construction
                return None
            b.append(x)
            used.add(x)
            prev = a[i]
        else:
            # find smallest non-negative not in used and != a[i]
            x = 0
            while x in used or x == a[i]:
                x += 1
            b.append(x)
            used.add(x)
    return b

def solve_case(n: int, a: List[int]) -> Optional[List[int]]:
    return construct_baseline(a)

def main():
    n, a = read_input()
    if n == 0 and not a:
        return
    res = solve_case(n, a)
    if res is None:
        print(-1)
    else:
        print(*res)

if __name__ == "__main__":
    # tiny asserts
    def mex(arr: List[int]) -> int:
        s = set(arr)
        m = 0
        while m in s:
            m += 1
        return m
    def check(a: List[int]):
        b = construct_baseline(a)
        assert b is not None
        for i in range(1, len(a)+1):
            assert mex(b[:i]) == a[i-1]
    check([0])
    check([1])
    check([0,0,1,1])
    check([1,1,2,2])
    # Uncomment to run interactively:
    # main()
    pass
\end{minted}
\VALIDATION{Checked tiny arrays where $a$ is constant, increases by one, and jumps. Verified prefix MEX equals target.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Heap of Non-$a$ Values}
\WHICHFORMULA{Precompute the set $\mathcal{A}=\{a_i\}$ and maintain a min-heap of nonnegative integers not in $\mathcal{A}$. When $a$ is constant, pop from the heap; when $a$ increases, output the previous $a$. This gives $O(n\log n)$.}
\ASSUMPTIONS{There are always enough non-$\mathcal{A}$ values among $\{0,1,\ldots,n+1\}$ to serve as fillers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build set $\mathcal{A}$ of all values in $a$.
\item Initialize a min-heap $H$ with all $x \in \{0,1,\ldots,n+1\}$ such that $x \notin \mathcal{A}$.
\item Set $\text{prev}=0$. For $i=1..n$:
\begin{bullets}
\item If $a_i<\text{prev}$, return impossible.
\item If $a_i>\text{prev}$, set $b_i\leftarrow \text{prev}$ and update $\text{prev}\leftarrow a_i$.
\item Else, set $b_i\leftarrow \operatorname{pop}(H)$.
\end{bullets}
\end{algosteps}
\COMPLEXITY{Heap operations dominate: $T(n)=O(n\log n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n\log n),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Values popped from $H$ never equal any $a_i$, so they cannot equal the current MEX; thus they do not change the MEX when $a$ is constant. When $a$ increases, outputting the previous MEX value inserts the last missing element needed to jump to the required new MEX. Because $\mathcal{A}$ is fixed, we never accidentally consume a reserved value.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF 1364C - Improved O(n log n) using a min-heap of values not in A
from typing import List, Optional, Tuple
import heapq

def read_input() -> Tuple[int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def construct_heap(a: List[int]) -> Optional[List[int]]:
    n = len(a)
    A = set(a)
    H = []
    # include up to n+1 to guarantee enough fillers
    for x in range(0, n + 2):
        if x not in A:
            H.append(x)
    heapq.heapify(H)
    b: List[int] = [0] * n
    prev = 0
    # feasibility check (optional under CF constraints)
    for i in range(n):
        if i > 0 and a[i] < a[i-1]:
            return None
    for i in range(n):
        if a[i] > prev:
            # output previous mex to enable increase
            b[i] = prev
            prev = a[i]
        else:
            if not H:
                return None
            b[i] = heapq.heappop(H)
    return b

def solve_case(n: int, a: List[int]) -> Optional[List[int]]:
    return construct_heap(a)

def main():
    n, a = read_input()
    if n == 0 and not a:
        return
    res = solve_case(n, a)
    if res is None:
        print(-1)
    else:
        print(*res)

if __name__ == "__main__":
    # tiny asserts
    def mex(arr: List[int]) -> int:
        s = set(arr)
        m = 0
        while m in s:
            m += 1
        return m
    def check(a: List[int]):
        b = construct_heap(a)
        assert b is not None
        for i in range(1, len(a)+1):
            assert mex(b[:i]) == a[i-1]
    check([0])
    check([1])
    check([0,0,1,1])
    check([1,1,2,2])
    # main()
    pass
\end{minted}
\VALIDATION{Validated on constant, increasing-by-one, and jump cases. The heap never yields an $a_i$, thus fillers cannot disturb the prefix MEX.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Greedy with Precomputed Non-$a$ Pool}
\WHICHFORMULA{Exactly the heap-based greedy: reserve the current MEX value by never using it as a filler; place it exactly when $a$ increases.}
\ASSUMPTIONS{Nondecreasing $a$ with $a_i \le i$ ensures feasibility. Using the pool $\{0,\ldots,n+1\}\setminus \mathcal{A}$ is sufficient to supply all fillers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $\mathcal{A}=\{a_i\}$; initialize a min-heap $H$ with $\{0,\ldots,n+1\}\setminus \mathcal{A}$.
\item Set $\text{prev}=0$.
\item For $i=1..n$: if $a_i>\text{prev}$ then $b_i\leftarrow \text{prev}$ and $\text{prev}\leftarrow a_i$; else $b_i\leftarrow \operatorname{pop}(H)$.
\end{algosteps}
\OPTIMALITY{Any valid construction must keep the current MEX value missing while $a$ is constant and include it exactly when $a$ increases. Using the smallest available non-$\mathcal{A}$ filler is greedy and safe; any other choice of a non-$\mathcal{A}$ value remains valid. The time is $O(n\log n)$, which is optimal up to logarithmic factors for comparison-based priority selection.}
\COMPLEXITY{$T(n)=O(n\log n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n\log n),\\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF 1364C - Final solution (O(n log n))
from typing import List, Optional, Tuple
import sys, heapq

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_all(n: int, a: List[int]) -> Optional[List[int]]:
    # Feasibility quick check; CF guarantees these but we keep it.
    for i in range(1, n):
        if a[i] < a[i-1]:
            return None
    A = set(a)
    H = [x for x in range(0, n + 2) if x not in A]
    heapq.heapify(H)
    b = [0] * n
    prev = 0
    for i in range(n):
        if a[i] > prev:
            b[i] = prev
            prev = a[i]
        else:
            if not H:
                return None
            b[i] = heapq.heappop(H)
    return b

def main():
    n, a = read_input()
    if n == 0:
        return
    res = solve_all(n, a)
    if res is None:
        print(-1)
    else:
        print(*res)

if __name__ == "__main__":
    # exact 3 asserts
    def mex(arr: List[int]) -> int:
        s = set(arr)
        m = 0
        while m in s:
            m += 1
        return m
    def verify(a: List[int]):
        b = solve_all(len(a), a)
        assert b is not None
        for i in range(1, len(a)+1):
            assert mex(b[:i]) == a[i-1]
    verify([0,0,1,1])
    verify([1,1,2,2])
    verify([0,1,2,2,3,3])
    # main()
    pass
\end{minted}
\VALIDATION{Three asserts cover constant, repeated, and stepwise-increasing $a$.}
\RESULT{Outputs any valid $b$ with $0 \le b_i \le 10^6$ or $-1$ if impossible (should not occur under the given constraints).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Property-check the prefix MEX condition on random and edge arrays $a$ that satisfy nondecreasing and $a_i \le i$. Include constant zeros, strictly increasing, and large jumps.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved on small random inputs by verifying the prefix MEX matches $a$ for both constructions.}
\LINE{EDGE-CASE GENERATOR}{Generate monotone $a$ with patterns: all zeros, alternating increases, plateau then big jump, and maximal distinct values $0,1,\ldots$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_zero(n: int) -> List[int]:
    return [0]*n

def gen_strict_increase(n: int) -> List[int]:
    # a[0] in {0,1}, then increase as much as allowed (by at most 1 per step due to <= i)
    a = [0]
    for i in range(1, n):
        a.append(min(a[-1]+1, i))
    return a

def gen_big_jump(n: int) -> List[int]:
    # plateau at 0, then jump near the end
    a = [0]*(n//2)
    target = min(n//2 + 1, n)
    # fill rest with target (nondecreasing; target <= i holds near end)
    for i in range(n//2, n):
        a.append(target if target <= i+1 else i+1)
    return a[:n]

def check_prefix_mex(a: List[int], b: List[int]) -> bool:
    s = set()
    j = 0
    for i, x in enumerate(b):
        s.add(x)
        m = 0
        while m in s:
            m += 1
        if m != a[i]:
            return False
    return True

def small_cross_check():
    random.seed(0)
    for n in range(1, 50):
        for _ in range(50):
            # build a random nondecreasing a with a[i] <= i+1
            a = [random.randint(0, 1)]
            for i in range(1, n):
                lo = a[-1]
                hi = i  # a_i <= i
                a.append(random.randint(lo, hi))
            from heapq import heapify, heappop
            # use Approach B construct
            A = set(a)
            H = [x for x in range(0, n+2) if x not in A]
            heapify(H)
            prev = 0
            b = []
            ok = True
            for i in range(n):
                if a[i] > prev:
                    b.append(prev)
                    prev = a[i]
                else:
                    if not H:
                        ok = False; break
                    b.append(heappop(H))
            assert ok and check_prefix_mex(a, b)
    return True

assert small_cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# CF 1364C - Reference submission (greedy with heap of non-a values)
import sys, heapq

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_all(n, a):
    for i in range(1, n):
        if a[i] < a[i-1]:
            return None
    A = set(a)
    H = [x for x in range(0, n + 2) if x not in A]
    heapq.heapify(H)
    b = [0]*n
    prev = 0
    for i in range(n):
        if a[i] > prev:
            b[i] = prev
            prev = a[i]
        else:
            if not H:
                return None
            b[i] = heapq.heappop(H)
    return b

def main():
    n, a = read_input()
    res = solve_all(n, a)
    if res is None:
        print(-1)
    else:
        print(*res)

if __name__ == "__main__":
    # simple asserts
    def mex(arr):
        s = set(arr); m = 0
        while m in s: m += 1
        return m
    def verify(a):
        b = solve_all(len(a), a); assert b is not None
        for i in range(1, len(a)+1):
            assert mex(b[:i]) == a[i-1]
    verify([0,0,1,1])
    verify([1,1,2,2])
    verify([0,1,1,2,3,3])
    # main()
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reserve the current MEX value while $a$ is flat; emit it exactly when $a$ increases; otherwise, fill with a value that never equals any $a_i$.}
\WHY{Controlling prefix MEX is a common trick in constructive problems; this one appears in mid-level CF rounds and interviews to test greedy reasoning.}
\CHECKLIST{
\begin{bullets}
\item Build $\mathcal{A}=\{a_i\}$.
\item Initialize heap with $\{0,\ldots,n+1\}\setminus \mathcal{A}$.
\item Iterate, tracking prev MEX; on increase, output prev; otherwise pop from heap.
\item Print $-1$ only if $a$ decreases or heap exhausts (should not happen with valid $a$).
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$, $a=[0]$ or $a=[1]$.
\item Long plateau at $0$.
\item Immediate increase: $a=[1,1,\ldots]$.
\item Large jump after plateau: $a=[0,0,0,k,k,\ldots]$.
\item Nearly all values appear in $a$: use $n+1$ as filler.
\item Verify bounds: ensure $b_i \le 10^6$ (true since we only use up to $n+1$ and $n\le 10^5$).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Initializing prev incorrectly (use $0$, not $-1$).
\item Accidentally using current $a_i$ as a filler, which would increase MEX prematurely.
\item Forgetting to include $n+1$ in the heap, causing empty heap when $\mathcal{A}=\{0,\ldots,n\}$.
\item Not handling $a$ that decreases (should emit $-1$).
\item Using $ display math in code comments or text (avoid; use $...$ or \begin{BreakableEquation*}
...
\end{BreakableEquation*}).
\item Overflows or negative values (not applicable here).
\end{bullets}}
\FAILMODES{A naive filler that scans integers and accidentally places the current $a_i$ will break the MEX. The heap approach survives because it never contains any $a_i$.}
\ELI{Keep one special number missing (the current MEX). When it is time for the MEX to go up, we add that missing number. Everything else we add is a safe number that will never be a MEX target, so it does not change the MEX.}
\NotePages{3}

\end{document}