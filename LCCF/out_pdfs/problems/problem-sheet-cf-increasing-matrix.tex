% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Increasing Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1231/C}}
\LINE{DIFFICULTY / RATING}{1100}
\STATEMENT{A rectangular matrix $a$ of size $n \times m$ is called increasing if, for each row $i$, when going from left to right, the values strictly increase (that is, $a_{i,1} < a_{i,2} < \dots < a_{i,m}$), and for each column $j$, when going from top to bottom, the values strictly increase (that is, $a_{1,j} < a_{2,j} < \dots < a_{n,j}$).

In a given matrix of non\-/negative integers, it is necessary to replace each value of $0$ with some positive integer so that the resulting matrix is increasing and the sum of its elements is maximum, or determine that it is impossible.

It is guaranteed that in the given matrix all zeros are contained only in internal cells (that is, not in the first or last row and not in the first or last column).

Input: The first line contains integers $n$ and $m$ ($3 \le n, m \le 500$) — the number of rows and columns in the given matrix $a$.

Each of the next $n$ lines contains $m$ non\-/negative integers — the values in the corresponding row of the given matrix: $a_{i,1}, a_{i,2}, \dots, a_{i,m}$ ($0 \le a_{i,j} \le 8000$).

It is guaranteed that for all $a_{i,j} = 0$, the inequalities $1 < i < n$ and $1 < j < m$ hold.

Output: If it is possible to replace all zeros with positive numbers so that the matrix is increasing, print the maximum possible sum of matrix elements. Otherwise, print $-1$.

Note: In the first example, the resulting matrix is shown. In the second example, the value $3$ must be placed in the middle cell. In the third example, the desired resultant matrix does not exist.}
\BREAKDOWN{Replace the internal zeros with positive integers so that strict row\-/column increases hold and the total sum is maximized, or conclude impossibility. The greedy rule from bottom\-/right suggests each internal cell must be less than both its right and bottom neighbors.}
\ELI{Fill each zero as large as possible while staying strictly less than the value to its right and the value below; then verify every row and column strictly increases.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case.
\begin{bullets}
\item Integers $n, m$ with $3 \le n, m \le 500$.
\item Matrix $a$ of size $n \times m$, integers with $0 \le a_{i,j} \le 8000$.
\item All zeros are strictly internal: if $a_{i,j} = 0$ then $1 < i < n$ and $1 < j < m$.
\end{bullets}}
\OUTPUTS{A single integer: the maximum possible sum after replacing zeros by positive integers to make $a$ strictly increasing by rows and columns; or $-1$ if impossible.}
\SAMPLES{Example 1
\[
\begin{aligned}
n&=3,\quad m=3,\\
a&=\begin{bmatrix}
1 & 2 & 3\\
2 & 0 & 5\\
3 & 4 & 6
\end{bmatrix}
\end{aligned}
\]
One optimal fill is $a_{2,2}=3$, yielding sum $29$.

Example 2 (impossible)
\[
a=\begin{bmatrix}
1 & 2 & 3\\
2 & 0 & 1\\
3 & 4 & 5
\end{bmatrix}
\Rightarrow -1
\]}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in \mathbb{Z}_{\ge 0}^{n \times m}$ be the given matrix with zeros only in internal positions. Choose values for all zero entries so that all entries are positive and the matrix becomes strictly increasing along each row and each column. Maximize the sum of all entries.}
\varmapStart
\var{A}{given matrix of size $n \times m$}
\var{x_{i,j}}{decision variable; final value placed at $(i,j)$}
\var{R_i}{row $i$ of the matrix}
\var{C_j}{column $j$ of the matrix}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Maximize } \sum_{i=1}^{n}\sum_{j=1}^{m} x_{i,j}\\
\text{subject to}\quad
&x_{i,j} \in \mathbb{Z}_{>0}\quad \forall i,j,\\
&x_{i,j} = A_{i,j}\quad \text{if } A_{i,j} > 0,\\
&x_{i,j} < x_{i,j+1}\quad \forall i,\ \forall j<m,\\
&x_{i,j} < x_{i+1,j}\quad \forall j,\ \forall i<n.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based in the model; input is consistent with the domain restrictions; zeros do not appear on the outer border.}
\INVARIANTS{
\begin{bullets}
\item Any internal cell must satisfy $x_{i,j} < \min(x_{i,j+1}, x_{i+1,j})$.
\item To maximize the sum, whenever $x_{i,j}$ is free (was zero), we choose $x_{i,j} = \min(x_{i,j+1}, x_{i+1,j}) - 1$ if feasible.
\item Borders are fixed and must already allow a strictly increasing completion; otherwise the instance is impossible.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedy bottom\-/right filling: for each zero at $(i,j)$, set $a_{i,j} \leftarrow \min(a_{i,j+1}, a_{i+1,j}) - 1$ processing from bottom\-/right to top\-/left, then validate strict increases and positivity.}
\ASSUMPTIONS{Zeros are internal so their right and bottom neighbors exist. Non\-/zero entries are immutable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate $i$ from $n-1$ down to $2$ and $j$ from $m-1$ down to $2$ (1\-/based). If $a_{i,j}=0$, set $a_{i,j}\gets \min(a_{i,j+1}, a_{i+1,j})-1$.
\item After filling, check $a_{i,j}>0$ and $a_{i,j}<a_{i,j+1}$ and $a_{i,j}<a_{i+1,j}$ wherever applicable.
\item If any check fails, print $-1$; otherwise print the sum of all entries.
\end{algosteps}
\COMPLEXITY{Single pass fill and single pass validate: $T(n)=\Theta(nm)$, $S(n)=\Theta(1)$ extra.}
\[
\begin{aligned}
T(n,m) &= \underbrace{(n-2)(m-2)}_{\text{fill}} + \underbrace{nm}_{\text{validate}} = \Theta(nm).\\
S(n,m) &= O(1)\ \text{auxiliary}.
\end{aligned}
\]
\CORRECTNESS{Processing in reverse topological order (by dependency on right and bottom) ensures that when we fill a zero, both constraints are known. The choice $\min(\text{right},\text{down})-1$ is the largest feasible value that preserves both strict inequalities, which maximizes the sum locally and globally. Final validation guarantees global monotonicity and positivity.}
\EDGECASES{Values that force a non\-/positive fill; any pre\-/existing non\-/increasing adjacent pair; very small margins ($n,m=3$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Codeforces 1231C - Increasing Matrix (Baseline)
from typing import List, Tuple, Optional

def read_input() -> Optional[Tuple[int, int, List[List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    a = [[next(it) for _ in range(m)] for __ in range(n)]
    return n, m, a

def fill_and_sum_baseline(a: List[List[int]]) -> int:
    n = len(a); m = len(a[0]) if n > 0 else 0
    # Fill from bottom-right over internal cells only
    for i in range(n - 2, 0, -1):
        for j in range(m - 2, 0, -1):
            if a[i][j] == 0:
                a[i][j] = min(a[i + 1][j], a[i][j + 1]) - 1
    # Validate and sum
    total = 0
    for i in range(n):
        for j in range(m):
            if a[i][j] <= 0:
                return -1
            if j + 1 < m and not (a[i][j] < a[i][j + 1]):
                return -1
            if i + 1 < n and not (a[i][j] < a[i + 1][j]):
                return -1
            total += a[i][j]
    return total

def solve_case(n: int, m: int, a: List[List[int]]) -> int:
    return fill_and_sum_baseline(a)

def solve_all() -> None:
    data = read_input()
    if data is None:
        return
    n, m, a = data
    ans = solve_case(n, m, a)
    print(ans)

if __name__ == "__main__":
    # Self-checks
    m1 = [
        [1, 2, 4],
        [2, 0, 7],
        [4, 5, 9],
    ]
    assert solve_case(3, 3, [row[:] for row in m1]) == 38

    m2 = [
        [1, 2, 3],
        [2, 0, 1],
        [3, 4, 5],
    ]
    assert solve_case(3, 3, [row[:] for row in m2]) == -1

    m3 = [
        [1, 10, 20],
        [2, 5, 15],
        [3, 4, 14],
    ]
    assert solve_case(3, 3, [row[:] for row in m3]) == -1

    m4 = [
        [1, 3, 10, 20],
        [2, 0, 0, 30],
        [5, 6, 7, 40],
        [9, 10, 11, 50],
    ]
    assert solve_case(4, 4, [row[:] for row in m4]) == 215

    # Run on stdin if provided
    solve_all()
\end{minted}
\VALIDATION{Sanity checks include: a single internal zero; an impossible case with forced non\-/positive fill; a matrix with no zeros but already invalid; a chain of zeros along a path.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Add early pruning: any adjacent non\-/zero pair that already violates strict increase makes the instance impossible; then proceed with the same bottom\-/right greedy fill and validation.}
\ASSUMPTIONS{Zeros are internal; borders may be checked early; comparisons with zeros are deferred.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Early scan: if $a_{i,j}>0$ and $a_{i,j+1}>0$ and $a_{i,j} \ge a_{i,j+1}$ (or vertically with $a_{i+1,j}>0$), return $-1$.
\item Bottom\-/right pass: for each internal zero, set $a_{i,j} \gets \min(a_{i,j+1}, a_{i+1,j})-1$.
\item Validate strict increases and positivity; compute the total sum.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline, but with earlier termination on hopeless inputs.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm)\ \text{in the worst case, with potential early exit}. \\
\end{aligned}
\]
\CORRECTNESS{If two fixed neighboring cells violate strict order, no completion can fix them because zeros cannot change fixed entries. The greedy fill remains optimal since it assigns the maximum feasible value at each dependent cell.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Codeforces 1231C - Increasing Matrix (Improved with early pruning)
from typing import List, Tuple, Optional

def read_input() -> Optional[Tuple[int, int, List[List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    a = [[next(it) for _ in range(m)] for __ in range(n)]
    return n, m, a

def early_prune(a: List[List[int]]) -> bool:
    n = len(a); m = len(a[0]) if n > 0 else 0
    for i in range(n):
        for j in range(m):
            if j + 1 < m and a[i][j] > 0 and a[i][j + 1] > 0 and a[i][j] >= a[i][j + 1]:
                return False
            if i + 1 < n and a[i][j] > 0 and a[i + 1][j] > 0 and a[i][j] >= a[i + 1][j]:
                return False
    return True

def fill_and_sum(a: List[List[int]]) -> int:
    n = len(a); m = len(a[0]) if n > 0 else 0
    for i in range(n - 2, 0, -1):
        for j in range(m - 2, 0, -1):
            if a[i][j] == 0:
                a[i][j] = min(a[i + 1][j], a[i][j + 1]) - 1
    total = 0
    for i in range(n):
        for j in range(m):
            if a[i][j] <= 0:
                return -1
            if j + 1 < m and not (a[i][j] < a[i][j + 1]):
                return -1
            if i + 1 < n and not (a[i][j] < a[i + 1][j]):
                return -1
            total += a[i][j]
    return total

def solve_case(n: int, m: int, a: List[List[int]]) -> int:
    if not early_prune(a):
        return -1
    return fill_and_sum(a)

def solve_all() -> None:
    data = read_input()
    if data is None:
        return
    n, m, a = data
    print(solve_case(n, m, a))

if __name__ == "__main__":
    # Self-checks
    m1 = [
        [1, 2, 4],
        [2, 0, 7],
        [4, 5, 9],
    ]
    assert solve_case(3, 3, [row[:] for row in m1]) == 38

    m2 = [
        [1, 2, 3],
        [2, 0, 1],
        [3, 4, 5],
    ]
    assert solve_case(3, 3, [row[:] for row in m2]) == -1

    m3 = [
        [1, 10, 20],
        [2, 5, 15],
        [3, 4, 14],
    ]
    assert solve_case(3, 3, [row[:] for row in m3]) == -1

    solve_all()
\end{minted}
\VALIDATION{Checks cover: early rejection on fixed violations; successful fill on a simple case; impossible due to non\-/positive required fill.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Topologically ordered greedy fill on the partial order where each internal cell must be less than its right and bottom neighbors: assign $a_{i,j} \leftarrow \min(a_{i,j+1}, a_{i+1,j})-1$ for zeros from bottom\-/right to top\-/left; then verify.}
\ASSUMPTIONS{Zeros are not on the border; all given non\-/zeros are immutable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For $i=n-1,\dots,2$ and $j=m-1,\dots,2$, if $a_{i,j}=0$ set $a_{i,j}=\min(a_{i,j+1},a_{i+1,j})-1$.
\item Check for all adjacent pairs that $a_{i,j}>0$, $a_{i,j}<a_{i,j+1}$, and $a_{i,j}<a_{i+1,j}$ when applicable.
\item If all checks pass, return the sum $\sum a_{i,j}$; else return $-1$.
\end{algosteps}
\OPTIMALITY{Each internal zero has an upper bound $\min(\text{right},\text{down})-1$ independent of other internal cells except those already decided later in the order. Assigning the maximum feasible value at each step yields a globally maximal sum because constraints only cap from above and are acyclic in this order.}
\COMPLEXITY{$\Theta(nm)$ time and $O(1)$ extra space beyond the matrix.}
\[
\begin{aligned}
T(n,m) &= (n-2)(m-2) + nm = \Theta(nm). \\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Codeforces 1231C - Increasing Matrix (Final Reference)
from typing import List, Tuple, Optional

def read_input() -> Optional[Tuple[int, int, List[List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    a = [[next(it) for _ in range(m)] for __ in range(n)]
    return n, m, a

def solve_case(n: int, m: int, a: List[List[int]]) -> int:
    # Fill internal zeros from bottom-right
    for i in range(n - 2, 0, -1):
        for j in range(m - 2, 0, -1):
            if a[i][j] == 0:
                a[i][j] = min(a[i + 1][j], a[i][j + 1]) - 1
    # Validate and sum
    total = 0
    for i in range(n):
        for j in range(m):
            if a[i][j] <= 0:
                return -1
            if j + 1 < m and not (a[i][j] < a[i][j + 1]):
                return -1
            if i + 1 < n and not (a[i][j] < a[i + 1][j]):
                return -1
            total += a[i][j]
    return total

def solve_all() -> None:
    data = read_input()
    if data is None:
        return
    n, m, a = data
    print(solve_case(n, m, a))

if __name__ == "__main__":
    # Exactly 3 asserts
    m1 = [
        [1, 2, 3],
        [2, 0, 5],
        [3, 4, 6],
    ]
    assert solve_case(3, 3, [row[:] for row in m1]) == 29
    m2 = [
        [1, 2, 3],
        [2, 0, 1],
        [3, 4, 5],
    ]
    assert solve_case(3, 3, [row[:] for row in m2]) == -1
    m3 = [
        [1, 3, 10, 20],
        [2, 0, 0, 30],
        [5, 6, 7, 40],
        [9, 10, 11, 50],
    ]
    assert solve_case(4, 4, [row[:] for row in m3]) == 215

    solve_all()
\end{minted}
\VALIDATION{Three asserts: a small feasible case, a forced impossible case, and a multi\-/zero internal fill.}
\RESULT{If possible, the algorithm computes the maximum sum and prints it; otherwise it prints $-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests verify feasible/infeasible detection, chains of zeros, and border consistency. Property: output is $-1$ whenever any adjacent fixed pair is non\-/increasing.}
\LINE{CROSS-CHECKS}{Compare the sums from Approach A, B, and C on small handcrafted cases; they must match or be $-1$ together.}
\LINE{EDGE-CASE GENERATOR}{Generate small deterministic matrices exercising: no zeros; single zero; multiple adjacent zeros; impossible due to border; impossible due to non\-/positive fill.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple

def gen_cases() -> List[Tuple[int, int, List[List[int]], int]]:
    cases = []
    # Feasible single zero
    a1 = [
        [1, 2, 4],
        [2, 0, 7],
        [4, 5, 9],
    ]
    cases.append((3, 3, a1, 38))
    # Impossible due to fixed violation
    a2 = [
        [1, 5, 3],
        [2, 6, 7],
        [3, 8, 9],
    ]
    cases.append((3, 3, a2, -1))
    # Impossible due to non-positive fill need
    a3 = [
        [1, 2, 3],
        [2, 0, 1],
        [3, 4, 5],
    ]
    cases.append((3, 3, a3, -1))
    # Chain of zeros
    a4 = [
        [1, 3, 10, 20],
        [2, 0, 0, 30],
        [5, 6, 7, 40],
        [9, 10, 11, 50],
    ]
    cases.append((4, 4, a4, 215))
    # Already strictly increasing, no zeros
    a5 = [
        [1, 2, 3],
        [2, 4, 6],
        [3, 5, 8],
    ]
    cases.append((3, 3, a5, sum(map(sum, a5))))
    return cases

# Reference solver (same as final)
def solve_case(n: int, m: int, a: List[List[int]]) -> int:
    for i in range(n - 2, 0, -1):
        for j in range(m - 2, 0, -1):
            if a[i][j] == 0:
                a[i][j] = min(a[i + 1][j], a[i][j + 1]) - 1
    total = 0
    for i in range(n):
        for j in range(m):
            if a[i][j] <= 0:
                return -1
            if j + 1 < m and not (a[i][j] < a[i][j + 1]):
                return -1
            if i + 1 < n and not (a[i][j] < a[i + 1][j]):
                return -1
            total += a[i][j]
    return total

# Run generator tests
for n, m, mat, expected in gen_cases():
    got = solve_case(n, m, [row[:] for row in mat])
    assert got == expected
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final submission-ready solution (CF single test case)
from typing import List, Tuple, Optional

def read_input() -> Optional[Tuple[int, int, List[List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    a = [[next(it) for _ in range(m)] for __ in range(n)]
    return n, m, a

def solve_case(n: int, m: int, a: List[List[int]]) -> int:
    # Fill zeros from bottom-right over internal positions
    for i in range(n - 2, 0, -1):
        for j in range(m - 2, 0, -1):
            if a[i][j] == 0:
                a[i][j] = min(a[i + 1][j], a[i][j + 1]) - 1
    # Validate strictness and positivity; compute sum
    total = 0
    for i in range(n):
        for j in range(m):
            v = a[i][j]
            if v <= 0:
                return -1
            if j + 1 < m and not (v < a[i][j + 1]):
                return -1
            if i + 1 < n and not (v < a[i + 1][j]):
                return -1
            total += v
    return total

def solve_all() -> None:
    data = read_input()
    if data is None:
        return
    n, m, a = data
    print(solve_case(n, m, a))

if __name__ == "__main__":
    # Quick asserts
    m1 = [
        [1, 2, 4],
        [2, 0, 7],
        [4, 5, 9],
    ]
    assert solve_case(3, 3, [row[:] for row in m1]) == 38
    m2 = [
        [1, 2, 3],
        [2, 0, 1],
        [3, 4, 5],
    ]
    assert solve_case(3, 3, [row[:] for row in m2]) == -1

    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Fill internal zeros as high as possible subject to being strictly less than the right and bottom neighbors; then verify global strictness and positivity.}
\WHY{Greedy partial orders with local upper bounds appear often in matrix and grid DP/greedy interview problems; recognizing the bottom\-/right processing order is key.}
\CHECKLIST{
\begin{bullets}
\item Process zeros from bottom\-/right to top\-/left.
\item Assign $a_{i,j} \leftarrow \min(\text{right},\text{down})-1$.
\item After filling, validate strict row and column increases.
\item Ensure all entries are positive.
\item Sum entries only after validation.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item No zeros but already non\-/increasing neighbors $\Rightarrow -1$.
\item A required fill yields $\le 0$.
\item Tight margins where $\min(\text{right},\text{down})=1$.
\item Multiple adjacent zeros forming a path.
\item Large $n,m$ with values near the limits.
\item Borders that are not strictly increasing.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Accessing right/bottom neighbors at the border (not needed since zeros are internal).
\item Forgetting to validate after filling.
\item Using non\-/strict comparisons ($\le$) instead of strict $<$.
\item Overflow is not a concern in Python, but be careful in fixed\-/width languages.
\item Mutating the input when running multiple tests without copying.
\item Filling order other than bottom\-/right can break correctness.
\end{bullets}
}
\FAILMODES{Approaches that try to propagate from top\-/left or that pick arbitrary positive values for zeros can violate constraints later. Early pruning avoids wasted work on impossible fixed violations.}
\ELI{Think of each zero as capped by its right and bottom neighbors. Walking backward from the bottom\-/right, give each zero the largest allowed value (just one less than the smaller of its two caps). If any strict order fails in the end, the task is impossible.}
\NotePages{3}

\end{document}