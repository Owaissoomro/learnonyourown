% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Modified GCD}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/75/C}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Well, here is another math class task. In mathematics, GCD is the greatest common divisor, and it is an easy task to calculate the GCD between two positive integers.

A common divisor for two positive numbers is a number which both numbers are divisible by.

But your teacher wants to give you a harder task, in this task you have to find the greatest common divisor $d$ between two integers $a$ and $b$ that is in a given range from $low$ to $high$ (inclusive), i.e. $low \le d \le high$. It is possible that there is no common divisor in the given range.

You will be given the two integers $a$ and $b$, then $n$ queries. Each query is a range from $low$ to $high$ and you have to answer each query.

Input:
The first line contains two integers $a$ and $b$, the two integers as described above ($1 \le a, b \le 10^9$). The second line contains one integer $n$, the number of queries ($1 \le n \le 10^4$). Then $n$ lines follow, each line contains one query consisting of two integers, $low$ and $high$ ($1 \le low \le high \le 10^9$).

Output:
Print $n$ lines. The $i$-th of them should contain the result of the $i$-th query in the input. If there is no common divisor in the given range for any query, you should print $-1$ as a result for this query.}
\BREAKDOWN{Compute $g=\gcd(a,b)$ once. Precompute all divisors of $g$ and sort them. For each query $[L,H]$, find the largest divisor $d$ with $L \le d \le H$ using binary search; otherwise answer $-1$.}
\ELI{All answers are divisors of $\gcd(a,b)$; just pick the biggest one within the asked interval.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $a,b$ with $1 \le a,b \le 10^9$. Then integer $n$ with $1 \le n \le 10^4$. Then $n$ ranges $[low,high]$ with $1 \le low \le high \le 10^9$.}
\OUTPUTS{For each query $[low,high]$, print the maximum common divisor $d$ of $a$ and $b$ that lies in the range, or $-1$ if none exists. One answer per line.}
\SAMPLES{Example 1:
Input
9 27
3
1 2
2 8
5 10

Output
1
3
9

Explanation: $\gcd(9,27)=9$ with divisors $\{1,3,9\}$.

Example 2:
Input
12 18
4
1 1
2 2
7 8
8 12

Output
1
2
-1
6

Explanation: $\gcd(12,18)=6$ with divisors $\{1,2,3,6\}$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $a,b \in \mathbb{Z}_{>0}$ and $n$ intervals $[L_i,H_i]$, let $g=\gcd(a,b)$ and $D=\{d \in \mathbb{Z}_{>0} : d \mid g\}$. For each query $i$, output $\max\{d \in D : L_i \le d \le H_i\}$ or $-1$ if the set is empty.}
\varmapStart
\var{a,b}{input integers}
\var{g}{the value $\gcd(a,b)$}
\var{D}{set of positive divisors of $g$}
\var{[L,H]}{a query interval}
\var{ans}{the maximum $d \in D$ with $L \le d \le H$, or $-1$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
g &= \gcd(a,b), \\
D &= \{d \in \mathbb{Z}_{>0} : d \mid g\}, \\
\text{For query }[L,H]:\quad ans &= 
\begin{cases}
\max \left( D \cap [L,H] \right), & \text{if } D \cap [L,H] \ne \varnothing,\\
-1, & \text{otherwise.}
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{All inputs are integers within the specified ranges; $D$ is finite with $\lvert D \rvert = O(\sqrt{g})$. Intervals are inclusive and independent per query.}
\INVARIANTS{The set of valid answers across all queries is a subset of $D$. Sorting $D$ once allows binary search per query without affecting correctness.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Scan downwards from $H$ to $L$ and return the first $d$ dividing both $a$ and $b$.}
\ASSUMPTIONS{Suitable only for very small intervals; serves as a correctness baseline and a cross-check oracle for tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $a,b$, number of queries $n$, and the intervals.
\item For each query $[L,H]$, iterate $d$ from $H$ down to $L$.
\item If $a \bmod d = 0$ and $b \bmod d = 0$, output $d$; if none found, output $-1$.
\end{algosteps}
\COMPLEXITY{In the worst case, per query cost is $O(H-L+1)$ divisions, which is prohibitive for large ranges. Space is $O(1)$.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} O(H_i - L_i + 1), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Every common divisor in the interval will be checked; the downward scan ensures the first hit is the maximum.}
\EDGECASES{Single-point intervals $L=H$; $g=1$; intervals entirely above $g$; intervals below the smallest divisor 1.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, int, List[Tuple[int, int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    a = int(next(it))
    b = int(next(it))
    n = int(next(it))
    qs = []
    for _ in range(n):
        L = int(next(it)); H = int(next(it))
        qs.append((L, H))
    return a, b, qs

def brute_answer(a: int, b: int, L: int, H: int) -> int:
    for d in range(H, L - 1, -1):
        if a % d == 0 and b % d == 0:
            return d
    return -1

def solve_all(a: int, b: int, queries: List[Tuple[int, int]]) -> List[int]:
    return [brute_answer(a, b, L, H) for (L, H) in queries]

def main() -> None:
    if sys.stdin.isatty():
        # Self-checks (deterministic, small)
        a, b, qs = read_input("9 27\n3\n1 2\n2 8\n5 10\n")
        ans = solve_all(a, b, qs)
        assert ans == [1, 3, 9]
        a, b, qs = read_input("12 18\n4\n1 1\n2 2\n7 8\n8 12\n")
        ans = solve_all(a, b, qs)
        assert ans == [1, 2, -1, 6]
        # Edge: no divisor in range
        a, b, qs = read_input("14 25\n2\n2 3\n5 6\n")
        assert solve_all(a, b, qs) == [-1, -1]
        print("OK")
    else:
        a, b, qs = read_input()
        out = solve_all(a, b, qs)
        print("\n".join(map(str, out)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Cross-checked on two crafted examples and a case with no valid divisor.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Precompute Divisors of $\gcd$ + Binary Search}
\WHICHFORMULA{Any answer must divide $g=\gcd(a,b)$. Precompute all divisors of $g$ in $O(\sqrt{g})$, sort them, and per query select the largest $\le H$ and check if it is $\ge L$ using binary search.}
\ASSUMPTIONS{We can afford $O(\sqrt{g})$ preprocessing once; number of divisors is typically small.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $g=\gcd(a,b)$.
\item Enumerate all divisors of $g$ by iterating $i=1$ to $\lfloor \sqrt{g} \rfloor$ and collecting $i$ and $g/i$ when divisible; sort ascending.
\item For each $[L,H]$, binary search the largest divisor $\le H$; if it is also $\ge L$, output it; else output $-1$.
\end{algosteps}
\COMPLEXITY{Preprocessing $O(\sqrt{g})$; sorting $O(d \log d)$ with $d=\lvert D \rvert$; each query $O(\log d)$. This dominates the baseline for wide intervals.}
\[
\begin{aligned}
T(n) &= O(\sqrt{g} + d\log d + n\log d),\quad d=\tau(g),\\
S(n) &= O(d).
\end{aligned}
\]
\CORRECTNESS{Every valid answer lies in $D$. Binary search finds the maximum element of $D$ not exceeding $H$; verifying it is at least $L$ ensures it lies inside the interval.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple
from math import gcd
import bisect

def read_input(data: str = None) -> Tuple[int, int, List[Tuple[int, int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    a = int(next(it)); b = int(next(it))
    n = int(next(it))
    qs = [(int(next(it)), int(next(it))) for _ in range(n)]
    return a, b, qs

def divisors_sorted(x: int) -> List[int]:
    small, large = [], []
    i = 1
    while i * i <= x:
        if x % i == 0:
            small.append(i)
            if i * i != x:
                large.append(x // i)
        i += 1
    large.reverse()
    return small + large

def solve_all(a: int, b: int, queries: List[Tuple[int, int]]) -> List[int]:
    g = gcd(a, b)
    D = divisors_sorted(g)  # ascending
    res = []
    for L, H in queries:
        idx = bisect.bisect_right(D, H) - 1
        if idx >= 0 and D[idx] >= L:
            res.append(D[idx])
        else:
            res.append(-1)
    return res

def main() -> None:
    if sys.stdin.isatty():
        # Unit tests
        assert divisors_sorted(1) == [1]
        assert divisors_sorted(9) == [1, 3, 9]
        assert divisors_sorted(36) == [1,2,3,4,6,9,12,18,36]
        a, b, qs = read_input("9 27\n3\n1 2\n2 8\n5 10\n")
        assert solve_all(a, b, qs) == [1, 3, 9]
        a, b, qs = read_input("12 18\n4\n1 1\n2 2\n7 8\n8 12\n")
        assert solve_all(a, b, qs) == [1, 2, -1, 6]
        print("OK")
    else:
        a, b, qs = read_input()
        out = solve_all(a, b, qs)
        print("\n".join(map(str, out)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked divisor generation and query answers on crafted cases. Edge cases: $g=1$; $L>g$; $H<1$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Precompute Divisors of $\gcd$ + Per-Query Binary Search}
\WHICHFORMULA{Same as Approach B; this is optimal under comparison-based querying given we can only return divisors of $g$.}
\ASSUMPTIONS{Applies to all inputs; handles up to $10^4$ queries efficiently.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $g=\gcd(a,b)$ once.
\item Build sorted list $D$ of all divisors of $g$ in ascending order.
\item For each $[L,H]$, locate the rightmost index with $D[idx] \le H$ and check if $D[idx] \ge L$; print $D[idx]$ or $-1$.
\end{algosteps}
\OPTIMALITY{The output must be a divisor of $g$; any algorithm must distinguish among $\tau(g)$ candidates. With $O(\sqrt{g})$ preprocessing, $O(\log \tau(g))$ per query is asymptotically optimal for ordered access.}
\COMPLEXITY{Preprocessing $O(\sqrt{g})$; per query $O(\log \tau(g))$ time and $O(1)$ extra space.}
\[
\begin{aligned}
T(n) &= O(\sqrt{g} + \tau(g)\log \tau(g) + n \log \tau(g)).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple
from math import gcd
import bisect

def read_input(data: str = None) -> Tuple[int, int, List[Tuple[int, int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    a = int(next(it)); b = int(next(it))
    n = int(next(it))
    qs = [(int(next(it)), int(next(it))) for _ in range(n)]
    return a, b, qs

def divisors_sorted(x: int) -> List[int]:
    # Enumerate divisors in O(sqrt(x)) and return sorted ascending
    small, large = [], []
    i = 1
    while i * i <= x:
        if x % i == 0:
            small.append(i)
            if i * i != x:
                large.append(x // i)
        i += 1
    large.reverse()
    return small + large

def solve_all(a: int, b: int, queries: List[Tuple[int, int]]) -> List[int]:
    g = gcd(a, b)
    D = divisors_sorted(g)
    res = []
    for L, H in queries:
        idx = bisect.bisect_right(D, H) - 1
        if idx >= 0 and D[idx] >= L:
            res.append(D[idx])
        else:
            res.append(-1)
    return res

def main() -> None:
    if sys.stdin.isatty():
        # Exact 3 asserts
        assert divisors_sorted(100) == [1,2,4,5,10,20,25,50,100]
        a, b, qs = read_input("18 24\n3\n1 2\n3 5\n6 10\n")
        assert solve_all(a, b, qs) == [2, 3, 6]
        a, b, qs = read_input("7 13\n2\n1 1\n2 10\n")
        assert solve_all(a, b, qs) == [1, -1]
        print("OK")
    else:
        a, b, qs = read_input()
        out = solve_all(a, b, qs)
        print("\n".join(map(str, out)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts on divisor listing, and two multi-query scenarios with differing gcd values.}
\RESULT{For each interval, the printed value is the largest divisor of $\gcd(a,b)$ within $[L,H]$, or $-1$ if none exists.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test divisor enumeration; verify answers on small exhaustive grids by cross-checking brute force vs. optimal on small $a,b \le 60$ and short intervals.}
\LINE{CROSS-CHECKS}{Compare baseline brute outputs to optimal outputs for small inputs to ensure exact agreement.}
\LINE{EDGE-CASE GENERATOR}{Deterministic sweeps covering $g=1$, prime $g$, perfect square $g$, and intervals below, within, and above $g$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from math import gcd
import bisect

def brute_answer(a: int, b: int, L: int, H: int) -> int:
    for d in range(H, L - 1, -1):
        if a % d == 0 and b % d == 0:
            return d
    return -1

def divisors_sorted(x: int):
    small, large = [], []
    i = 1
    while i * i <= x:
        if x % i == 0:
            small.append(i)
            if i * i != x:
                large.append(x // i)
        i += 1
    large.reverse()
    return small + large

def optimal_answer(a: int, b: int, L: int, H: int) -> int:
    g = gcd(a, b)
    D = divisors_sorted(g)
    idx = bisect.bisect_right(D, H) - 1
    if idx >= 0 and D[idx] >= L:
        return D[idx]
    return -1

def cross_check_small():
    for a in range(1, 61):
        for b in range(1, 61):
            for L in range(1, 21):
                for H in range(L, min(25, L + 6) + 1):
                    br = brute_answer(a, b, L, H)
                    op = optimal_answer(a, b, L, H)
                    assert br == op, (a, b, L, H, br, op)
    return True

if __name__ == "__main__":
    assert divisors_sorted(1) == [1]
    assert divisors_sorted(49) == [1,7,49]
    assert cross_check_small()
    print("All deterministic cross-checks passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple
from math import gcd
import bisect

def read_input(data: str = None) -> Tuple[int, int, List[Tuple[int, int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    a = int(next(it)); b = int(next(it))
    n = int(next(it))
    qs = [(int(next(it)), int(next(it))) for _ in range(n)]
    return a, b, qs

def divisors_sorted(x: int) -> List[int]:
    small, large = [], []
    i = 1
    while i * i <= x:
        if x % i == 0:
            small.append(i)
            if i * i != x:
                large.append(x // i)
        i += 1
    large.reverse()
    return small + large

def solve_all(a: int, b: int, queries: List[Tuple[int, int]]) -> List[int]:
    g = gcd(a, b)
    D = divisors_sorted(g)  # ascending sorted divisors
    ans = []
    for L, H in queries:
        idx = bisect.bisect_right(D, H) - 1
        if idx >= 0 and D[idx] >= L:
            ans.append(D[idx])
        else:
            ans.append(-1)
    return ans

def main() -> None:
    if sys.stdin.isatty():
        # Quick sanity asserts
        a, b, qs = read_input("9 27\n3\n1 2\n2 8\n5 10\n")
        assert solve_all(a, b, qs) == [1, 3, 9]
        a, b, qs = read_input("100 80\n3\n1 1\n2 3\n50 100\n")
        # gcd(100,80)=20 divisors [1,2,4,5,10,20]
        assert solve_all(a, b, qs) == [1, 2, 20]
        a, b, qs = read_input("7 13\n1\n2 10\n")
        assert solve_all(a, b, qs) == [-1]
        print("OK")
    else:
        a, b, qs = read_input()
        out = solve_all(a, b, qs)
        print("\n".join(map(str, out)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Precompute divisors of $\gcd(a,b)$, then per query pick the largest divisor within the interval via binary search.}
\WHY{Classic CF pattern: reduce to $\gcd$ structure, leverage divisor enumeration and binary search for many range queries.}
\CHECKLIST{
\begin{bullets}
\item Compute $g=\gcd(a,b)$ once.
\item Enumerate divisors in $O(\sqrt{g})$ and sort ascending.
\item For each $[L,H]$, find rightmost $\le H$ in $D$.
\item Verify candidate $\ge L$; else answer $-1$.
\item Print answers, one per line.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $g=1$; only possible answer is $1$ if $L \le 1 \le H$.
\item Interval above all divisors, e.g., $L>g$.
\item Interval below $1$ cannot occur due to constraints; still handle robustly.
\item Perfect square $g$; avoid duplicate middle divisor.
\item Very many queries ($n=10^4$); ensure per-query $O(\log d)$.
\item Large $a,b$ ($10^9$); ensure no overflow, use integer math.
\item Single point interval $L=H$.
\item Intervals where $H$ equals a divisor exactly vs. just below it.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to reverse the high-half divisor list, leading to unsorted $D$.
\item Double-inserting the square root divisor when $i^2=g$.
\item Off-by-one in binary search (use $bisect\_right$ then subtract 1).
\item Using naive scan per query causing TLE.
\item Misreading input or accidentally mixing spaces and newlines.
\item Printing extra spaces or missing newlines between answers.
\item Using floating-point sqrt; prefer integer loop with $i*i \le g$.
\item Not handling $g=0$ (cannot happen here since $a,b \ge 1$).
\end{bullets}
}
\FAILMODES{The brute-force approach fails when $H-L$ is large (e.g., wide intervals near $10^9$). The divisor precomputation with binary search remains fast regardless of interval width.}
\ELI{All answers come from a small set: the divisors of $\gcd(a,b)$. Build that set once, then for each question, choose the biggest number in the set that fits the range; if none fits, say $-1$.}
\NotePages{3}

\end{document}