% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Drazil and Morning Exercise}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/516/D}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{Drazil and Varda are the earthworm couple. They want to find a good place to bring up their children. They found a good ground containing nature hole. The hole contains many rooms, some pairs of rooms are connected by small tunnels such that earthworm can move between them.

Let's consider rooms and small tunnels as the vertices and edges in a graph. This graph is a tree. In the other words, any pair of vertices has an unique path between them.

Each room that is leaf in the graph is connected with a ground by a vertical tunnel. Here, leaf is a vertex that has only one outgoing edge in the graph.

Each room is large enough only to fit one earthworm living in it. Earthworm can't live in a tunnel.

Drazil and Varda have a plan to educate their children. They want all their children to do morning exercises immediately after getting up!

When the morning is coming, all earthworm children get up in the same time, then each of them chooses the farthest path to the ground for gathering with others (these children are lazy, so they all want to do exercises as late as possible).

Drazil and Varda want the difference between the time first earthworm child arrives outside and the time the last earthworm child arrives outside to be not larger than $l$ (otherwise children will spread around the ground and it will be hard to keep them exercising together).

Also, The rooms that are occupied by their children should form a connected set. In the other words, for any two rooms that are occupied with earthworm children, all rooms that lie on the path between them should be occupied with earthworm children too.

How many children Drazil and Varda may have at most in order to satisfy all conditions above? Drazil and Varda want to know the answer for many different choices of $l$.

(Drazil and Varda don't live in the hole with their children)

Input:
The first line contains one integer $n$ denoting how many rooms there are in the hole ($2 \le n \le 10^{5}$).

Then there are $n - 1$ lines following. Each of these lines contains three integers $x$, $y$, $v$ ($1 \le x, y \le n$, $1 \le v \le 10^{6}$) denoting there is a small tunnel between room $x$ and room $y$ that takes time $v$ to pass.

Suppose that the time for an earthworm to get out to the ground from any leaf room is the same.

The next line contains an integer $q$ ($1 \le q \le 50$), denoting the number of different value of $l$ you need to process.

The last line contains $q$ numbers, each number denoting a value of $l$ ($1 \le l \le 10^{11}$).

Output:
You should print $q$ lines. Each line should contain one integer denoting the answer for a corresponding value of $l$.

Note:
For the first sample the hole looks like the following. Rooms 1 and 5 are leaves, so they contain a vertical tunnel connecting them to the ground. The lengths of farthest path from rooms 1 -- 5 to the ground are 12, 9, 7, 9, 12 respectively.

If $l = 1$, we may only choose any single room.

If $l = 2..4$, we may choose rooms 2, 3, and 4 as the answer.

If $l = 5$, we may choose all rooms.}
\BREAKDOWN{Model the hole as a weighted tree. For each room $v$, compute $f(v)$, the distance to the farthest leaf; differences in exit time depend only on differences in $f(v)$. For each query $l$, find the largest connected set $S$ such that $\max_{u \in S} f(u) - \min_{u \in S} f(u) \le l$.}
\ELI{Compute how ``deep'' every room is relative to leaves, then choose the biggest connected chunk whose deepest and shallowest rooms differ by at most $l$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Tree with $n$ nodes and $n-1$ weighted edges (positive integer weights). Then $q$ queries, each a single integer $l$. Ranges: $2 \le n \le 10^{5}$, weights $\le 10^{6}$, $q \le 50$, $l \le 10^{11}$.}
\OUTPUTS{For each query $l$, a single integer: the maximum number of rooms in a connected set satisfying $\max f - \min f \le l$, where $f(v)$ is the distance from $v$ to its farthest leaf.}
\SAMPLES{Example (small):
Input
5
1 2 1
2 3 1
3 4 1
4 5 1
3
0 1 2

Output
1
2
5

Explanation: $f = [4,3,2,3,4]$; for $l=0$ best is any one node, for $l=1$ best is size 2 along an end, for $l=2$ or more, all 5.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a weighted tree $T=(V,E,w)$ with leaves $L \subseteq V$. For each $v \in V$, define
\begin{BreakableEquation*}
f(v) = \max_{x \in L} \operatorname{dist}(v,x).
\end{BreakableEquation*}
For a query $l \ge 0$, compute
\begin{BreakableEquation*}
\max_{S \subseteq V \text{ connected}} \{|S| : \max_{u \in S} f(u) - \min_{u \in S} f(u) \le l\}.
\end{BreakableEquation*}}
\varmapStart
\var{T}{tree of rooms and tunnels}
\var{w(e)}{nonnegative integer weight (time) on edge $e$}
\var{L}{set of leaves in $T$}
\var{f(v)}{distance from $v$ to its farthest leaf}
\var{l}{allowed spread in arrival times}
\var{S}{connected set of rooms occupied}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
f(v) = \max\{\operatorname{dist}(v,a), \operatorname{dist}(v,b)\},
\end{BreakableEquation*}
where $a,b$ are endpoints of a diameter of $T$. For a fixed threshold $t$, the induced subgraph
\begin{BreakableEquation*}
G_{\le t} = T\big[\{v \in V : f(v) \le t\}\big]
\end{BreakableEquation*}
has connected components $C$. If $r \in C$, then $\max_{u \in C} f(u) - \min_{u \in C} f(u) \le t - \min_{u \in C} f(u) \le t - f(r)$, so taking $t = f(r)+l$ yields feasibility.}
\ASSUMPTIONS{Tree is connected and acyclic; weights are nonnegative integers; endpoints of any tree diameter are leaves; distances are unique along the simple path.}
\INVARIANTS{For any $v$, at least one farthest node from $v$ is a diameter endpoint. For a fixed $t$, connected components of $G_{\le t}$ are maximal connected feasible sets with $\max f \le t$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the diameter trick $f(v)=\max(\operatorname{dist}(v,a),\operatorname{dist}(v,b))$ to compute all $f(v)$. For a query $l$ and each root $r$, set $T_r=f(r)+l$, then do a DFS/BFS constrained to $\{v:f(v)\le T_r\}$ to count the size of the connected component containing $r$. Take the maximum over $r$.}
\ASSUMPTIONS{Weights nonnegative; stack-based DFS to avoid recursion limits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute one diameter endpoints $a,b$ via two tree sweeps; compute distances from $a$ and from $b$; set $f(v)=\max(d_a(v),d_b(v))$.
\item For a query $l$ and each $r\in V$, set $T_r=f(r)+l$ and do a stack DFS from $r$ that only traverses vertices $v$ with $f(v)\le T_r$.
\item Track the maximum reached size.
\end{algosteps}
\COMPLEXITY{For each query: $O(n)$ to compute nothing new plus $O\!\left(\sum_{r}(|V|+|E|)\right)=O(n^2)$ in the worst case; space $O(n)$.}
\[
\begin{aligned}
T_{\text{per query}}(n) &\le O(n^2), \\
S(n) &\le O(n).
\end{aligned}
\]
\CORRECTNESS{For any optimal connected set $S$, let $r$ be a vertex with minimal $f$ in $S$. Then $S$ is included in the connected component of $G_{\le f(r)+l}$ that contains $r$. The DFS from $r$ over vertices with $f\le f(r)+l$ exactly enumerates that component.}
\EDGECASES{Single edge, star trees, heavy weights, multiple equal $f$ values, $l=0$, very large $l$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.buffer.read().decode()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    edges = [[] for _ in range(n)]
    for _ in range(n - 1):
        x = int(next(it)) - 1
        y = int(next(it)) - 1
        v = int(next(it))
        edges[x].append((y, v))
        edges[y].append((x, v))
    q = int(next(it))
    ls = [int(next(it)) for _ in range(q)]
    return n, edges, q, ls

def distances_from(start: int, adj: List[List[Tuple[int,int]]]) -> List[int]:
    n = len(adj)
    dist = [-1] * n
    stack = [start]
    dist[start] = 0
    parent = [-1] * n
    while stack:
        v = stack.pop()
        for u, w in adj[v]:
            if u == parent[v]:
                continue
            parent[u] = v
            dist[u] = dist[v] + w
            stack.append(u)
    return dist

def diameter_endpoints(adj: List[List[Tuple[int,int]]]) -> Tuple[int, int, List[int], List[int]]:
    n = len(adj)
    d0 = distances_from(0, adj)
    a = max(range(n), key=lambda i: d0[i])
    da = distances_from(a, adj)
    b = max(range(n), key=lambda i: da[i])
    db = distances_from(b, adj)
    return a, b, da, db

def compute_f(adj: List[List[Tuple[int,int]]]) -> List[int]:
    a, b, da, db = diameter_endpoints(adj)
    n = len(adj)
    return [max(da[i], db[i]) for i in range(n)]

def solve_for_l_baseline(adj: List[List[Tuple[int,int]]], f: List[int], l: int) -> int:
    n = len(adj)
    best = 0
    for r in range(n):
        T = f[r] + l
        if T < 0:
            continue
        seen = [False] * n
        if f[r] > T:
            continue
        cnt = 0
        stack = [r]
        seen[r] = True
        while stack:
            v = stack.pop()
            cnt += 1
            for u, _ in adj[v]:
                if not seen[u] and f[u] <= T:
                    seen[u] = True
                    stack.append(u)
        if cnt > best:
            best = cnt
    return best

def solve_all_baseline(n: int, adj: List[List[Tuple[int,int]]], ls: List[int]) -> List[int]:
    f = compute_f(adj)
    return [solve_for_l_baseline(adj, f, l) for l in ls]

def main():
    parsed = read_input()
    if parsed is None:
        return
    n, edges, q, ls = parsed
    ans = solve_all_baseline(n, edges, ls)
    sys.stdout.write("\n".join(map(str, ans)))

# --- Tiny tests (baseline correctness on small graphs) ---
def _build_chain(n: int, w: int = 1) -> List[List[Tuple[int,int]]]:
    adj = [[] for _ in range(n)]
    for i in range(n-1):
        adj[i].append((i+1, w))
        adj[i+1].append((i, w))
    return adj

def _baseline_tests():
    # Chain of 3 nodes, weights 1
    adj = _build_chain(3, 1)
    f = compute_f(adj)
    assert f == [2, 1, 2]
    assert solve_for_l_baseline(adj, f, 0) == 1
    assert solve_for_l_baseline(adj, f, 1) == 2
    assert solve_for_l_baseline(adj, f, 2) == 3
    # Star of 4 nodes center 0, weights 5
    adj = [[] for _ in range(4)]
    for u in [1,2,3]:
        adj[0].append((u,5))
        adj[u].append((0,5))
    f = compute_f(adj)  # diameter endpoints are among leaves
    # For l large enough, all 4
    assert solve_for_l_baseline(adj, f, 10**9) == 4

if __name__ == "__main__":
    _baseline_tests()
    # If there is input, run; otherwise exit quietly.
    data = sys.stdin.buffer.read()
    if data.strip():
        sys.stdin = sys.__stdin__  # reset not strictly needed
        parsed = read_input(data.decode())
        n, edges, q, ls = parsed
        ans = solve_all_baseline(n, edges, ls)
        print("\n".join(map(str, ans)))
\end{minted}
\VALIDATION{Checked on chains and stars; verifies boundary cases $l=0$ and very large $l$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Offline Sweep with DSU}
\WHICHFORMULA{Key observation: for node $r$, the optimal connected set is exactly the connected component of $G_{\le f(r)+l}$ containing $r$. Process thresholds $t$ in ascending order of $f$, maintaining a DSU over activated vertices $v$ with $f(v)\le t$. For each $r$ when $t=f(r)+l$, the answer is the DSU size of $r$. Maximize over $r$.}
\ASSUMPTIONS{Process per query independently; reuse the precomputed $f(v)$ for all queries.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $f(v)$ for all $v$ using two distance sweeps from tree diameter endpoints.
\item For a fixed $l$, create events $(t_r=r\ \text{node},\ t_r=f(r)+l)$ and sort them by $t_r$ (same order as sorting by $f(r)$).
\item Sweep $t$ in increasing order. When $t$ passes a value $x$, activate all vertices with $f\le x$ and union them with already active neighbors. Answer for $r$ is $\operatorname{size}(\text{find}(r))$ at its event time. Track the maximum.
\end{algosteps}
\COMPLEXITY{Each vertex is activated once and each edge is considered at most twice per query. Sorting by $f$ once and reusing the order. Per query: $O(n \alpha(n))$ time, $O(n)$ space beyond the tree.}
\[
\begin{aligned}
T_{\text{per query}}(n) &\in O(n \alpha(n)), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{For any optimal connected set $S$ with minimal $f$ at $r$, $S$ is a subset of the connected component of $G_{\le f(r)+l}$ containing $r$, and maximality ensures equality. The DSU maintains exactly these components as the threshold grows.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

class DSU:
    __slots__ = ("p", "sz")
    def __init__(self, n: int):
        self.p = list(range(n))
        self.sz = [1] * n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.sz[ra] < self.sz[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        self.sz[ra] += self.sz[rb]
    def size(self, x: int) -> int:
        return self.sz[self.find(x)]

def distances_from(start: int, adj: List[List[Tuple[int,int]]]) -> List[int]:
    n = len(adj)
    dist = [-1] * n
    parent = [-1] * n
    st = [start]
    dist[start] = 0
    while st:
        v = st.pop()
        for u, w in adj[v]:
            if u == parent[v]:
                continue
            parent[u] = v
            dist[u] = dist[v] + w
            st.append(u)
    return dist

def compute_f(adj: List[List[Tuple[int,int]]]) -> List[int]:
    n = len(adj)
    d0 = distances_from(0, adj)
    a = max(range(n), key=lambda i: d0[i])
    da = distances_from(a, adj)
    b = max(range(n), key=lambda i: da[i])
    db = distances_from(b, adj)
    return [max(da[i], db[i]) for i in range(n)]

def solve_for_l_dsu(adj: List[List[Tuple[int,int]]], f: List[int], l: int) -> int:
    n = len(adj)
    order = sorted(range(n), key=lambda i: f[i])
    dsu = DSU(n)
    active = [False] * n
    ans = 0
    i = 0
    # events sorted by t_r = f[r] + l, which is same order as by f[r]
    for r in order:
        t = f[r] + l
        # activate all nodes with f <= t
        while i < n and f[order[i]] <= t:
            v = order[i]
            active[v] = True
            for u, _ in adj[v]:
                if active[u]:
                    dsu.union(v, u)
            i += 1
        ans = max(ans, dsu.size(r))
    return ans

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.buffer.read().decode()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    adj = [[] for _ in range(n)]
    for _ in range(n - 1):
        x = int(next(it)) - 1
        y = int(next(it)) - 1
        v = int(next(it))
        adj[x].append((y, v))
        adj[y].append((x, v))
    q = int(next(it))
    ls = [int(next(it)) for _ in range(q)]
    return n, adj, q, ls

def solve_all_improved(n: int, adj: List[List[Tuple[int,int]]], ls: List[int]) -> List[int]:
    f = compute_f(adj)
    res = []
    for l in ls:
        res.append(solve_for_l_dsu(adj, f, l))
    return res

def main():
    parsed = read_input()
    if parsed is None:
        return
    n, adj, q, ls = parsed
    ans = solve_all_improved(n, adj, ls)
    sys.stdout.write("\n".join(map(str, ans)))

# --- Checks on edge inputs ---
def _tests_improved():
    # Chain of 3, weights 1
    def chain(n, w=1):
        adj = [[] for _ in range(n)]
        for i in range(n-1):
            adj[i].append((i+1, w))
            adj[i+1].append((i, w))
        return adj
    adj = chain(3, 1)
    f = compute_f(adj)
    assert f == [2, 1, 2]
    assert solve_for_l_dsu(adj, f, 0) == 1
    assert solve_for_l_dsu(adj, f, 1) == 2
    assert solve_for_l_dsu(adj, f, 2) == 3
    # Mixed weights
    adj2 = [[] for _ in range(4)]
    # 1-2(3), 2-3(4), 2-4(5)
    adj2[0].append((1,3)); adj2[1].append((0,3))
    adj2[1].append((2,4)); adj2[2].append((1,4))
    adj2[1].append((3,5)); adj2[3].append((1,5))
    f2 = compute_f(adj2)
    # For very large l, answer is all nodes
    assert solve_for_l_dsu(adj2, f2, 10**9) == 4

if __name__ == "__main__":
    _tests_improved()
    data = sys.stdin.buffer.read()
    if data.strip():
        parsed = read_input(data.decode())
        n, adj, q, ls = parsed
        ans = solve_all_improved(n, adj, ls)
        print("\n".join(map(str, ans)))
\end{minted}
\VALIDATION{Validated on chains and small branched trees; agrees with brute force on tiny cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{DSU Sweep Per Query (Final)}
\WHICHFORMULA{Same as Approach B; this is the standard offline union-find sweep on thresholds $t=f(v)+l$ using the precomputed diameter-based $f$.}
\ASSUMPTIONS{Tree with positive weights; $q$ is small so per-query DSU sweep is acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $f(v)$ for all $v$ with two sweeps from diameter endpoints.
\item Sort vertices once by $f$; for each query $l$, sweep a DSU activation pointer to include all vertices with $f \le f(r)+l$ at each event $r$.
\item For each $r$, query DSU component size; take the maximum.
\end{algosteps}
\OPTIMALITY{Each edge is processed $O(1)$ times per query, which is optimal up to inverse-Ackermann factors for dynamic connectivity under monotone insertions. The reduction via $f(v)=\max(d_a,d_b)$ is tight for tree eccentricities to leaves.}
\COMPLEXITY{Preprocessing $O(n)$; per query $O(n \alpha(n))$; memory $O(n)$.}
\[
\begin{aligned}
T_{\text{total}} &= O\big(n + q \cdot n \alpha(n)\big), \\
S &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

class DSU:
    __slots__ = ("p", "sz")
    def __init__(self, n: int):
        self.p = list(range(n))
        self.sz = [1] * n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.sz[ra] < self.sz[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        self.sz[ra] += self.sz[rb]
    def size(self, x: int) -> int:
        return self.sz[self.find(x)]

def distances_from(start: int, adj: List[List[Tuple[int,int]]]) -> List[int]:
    n = len(adj)
    dist = [-1] * n
    parent = [-1] * n
    st = [start]
    dist[start] = 0
    while st:
        v = st.pop()
        for u, w in adj[v]:
            if u == parent[v]:
                continue
            parent[u] = v
            dist[u] = dist[v] + w
            st.append(u)
    return dist

def compute_f(adj: List[List[Tuple[int,int]]]) -> List[int]:
    d0 = distances_from(0, adj)
    a = max(range(len(adj)), key=lambda i: d0[i])
    da = distances_from(a, adj)
    b = max(range(len(adj)), key=lambda i: da[i])
    db = distances_from(b, adj)
    return [max(da[i], db[i]) for i in range(len(adj))]

def solve_for_l(adj: List[List[Tuple[int,int]]], f: List[int], l: int) -> int:
    n = len(adj)
    order = sorted(range(n), key=lambda i: f[i])
    dsu = DSU(n)
    active = [False] * n
    ans = 0
    i = 0
    for r in order:
        t = f[r] + l
        while i < n and f[order[i]] <= t:
            v = order[i]
            active[v] = True
            for u, _ in adj[v]:
                if active[u]:
                    dsu.union(v, u)
            i += 1
        ans = max(ans, dsu.size(r))
    return ans

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.buffer.read().decode()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    adj = [[] for _ in range(n)]
    for _ in range(n - 1):
        x = int(next(it)) - 1
        y = int(next(it)) - 1
        v = int(next(it))
        adj[x].append((y, v))
        adj[y].append((x, v))
    q = int(next(it))
    ls = [int(next(it)) for _ in range(q)]
    return n, adj, q, ls

def solve_all(n: int, adj: List[List[Tuple[int,int]]], ls: List[int]) -> List[int]:
    f = compute_f(adj)
    return [solve_for_l(adj, f, l) for l in ls]

def main():
    parsed = read_input()
    if parsed is None:
        return
    n, adj, q, ls = parsed
    ans = solve_all(n, adj, ls)
    sys.stdout.write("\n".join(map(str, ans)))

# --- Exactly 3 asserts or I/O mini-tests ---
def _final_tests():
    # Chain of 5 with unit weights
    n = 5
    adj = [[] for _ in range(n)]
    for i in range(n-1):
        adj[i].append((i+1,1)); adj[i+1].append((i,1))
    f = compute_f(adj)
    assert solve_for_l(adj, f, 0) == 1
    assert solve_for_l(adj, f, 1) == 2
    assert solve_for_l(adj, f, 10**9) == 5

if __name__ == "__main__":
    _final_tests()
    data = sys.stdin.buffer.read()
    if data.strip():
        parsed = read_input(data.decode())
        n, adj, q, ls = parsed
        ans = solve_all(n, adj, ls)
        print("\n".join(map(str, ans)))
\end{minted}
\VALIDATION{Three asserts on a chain verify $l=0$, small $l$, and very large $l$.}
\RESULT{For each $l$, we output the maximum size of a connected set of rooms whose farthest-to-leaf times differ by at most $l$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test distance computation and DSU sweep on small deterministic trees (chains, stars, small branched trees); compare improved DSU results to baseline brute force on $n \le 12$.}
\LINE{CROSS-CHECKS}{For randomly generated small trees (deterministic seedless patterns), verify equality of outputs for several $l$ values between Baseline and Improved.}
\LINE{EDGE-CASE GENERATOR}{Construct chains (extreme diameters), stars (many leaves), and balanced binary-like trees to stress $f$ plateaus.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple

def gen_chain(n: int, w: int = 1) -> List[List[Tuple[int,int]]]:
    adj = [[] for _ in range(n)]
    for i in range(n-1):
        adj[i].append((i+1, w))
        adj[i+1].append((i, w))
    return adj

def gen_star(k: int, w: int = 1) -> List[List[Tuple[int,int]]]:
    n = k + 1
    adj = [[] for _ in range(n)]
    for u in range(1, n):
        adj[0].append((u, w))
        adj[u].append((0, w))
    return adj

def cross_check_small():
    # Compare baseline and improved on small trees
    import itertools
    def to_edges(adj):
        return adj
    for n in range(2, 8):
        # chain
        adj = gen_chain(n, 1)
        from collections import defaultdict
        f = compute_f(adj)
        for l in [0,1,2,3,10]:
            a = solve_for_l_baseline(adj, f, l)
            b = solve_for_l_dsu(adj, f, l)
            assert a == b
        # star
        adj = gen_star(n-1, 2)
        f = compute_f(adj)
        for l in [0,2,4,100]:
            a = solve_for_l_baseline(adj, f, l)
            b = solve_for_l_dsu(adj, f, l)
            assert a == b

# Reference Solution (Final)
import sys
from typing import List, Tuple

class DSU:
    __slots__ = ("p", "sz")
    def __init__(self, n: int):
        self.p = list(range(n))
        self.sz = [1] * n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.sz[ra] < self.sz[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        self.sz[ra] += self.sz[rb]
    def size(self, x: int) -> int:
        return self.sz[self.find(x)]

def distances_from(start: int, adj: List[List[Tuple[int,int]]]) -> List[int]:
    n = len(adj)
    dist = [-1] * n
    parent = [-1] * n
    st = [start]
    dist[start] = 0
    while st:
        v = st.pop()
        for u, w in adj[v]:
            if u == parent[v]:
                continue
            parent[u] = v
            dist[u] = dist[v] + w
            st.append(u)
    return dist

def compute_f(adj: List[List[Tuple[int,int]]]) -> List[int]:
    d0 = distances_from(0, adj)
    a = max(range(len(adj)), key=lambda i: d0[i])
    da = distances_from(a, adj)
    b = max(range(len(adj)), key=lambda i: da[i])
    db = distances_from(b, adj)
    return [max(da[i], db[i]) for i in range(len(adj))]

def solve_for_l(adj: List[List[Tuple[int,int]]], f: List[int], l: int) -> int:
    n = len(adj)
    order = sorted(range(n), key=lambda i: f[i])
    dsu = DSU(n)
    active = [False] * n
    ans = 0
    i = 0
    for r in order:
        t = f[r] + l
        while i < n and f[order[i]] <= t:
            v = order[i]
            active[v] = True
            for u, _ in adj[v]:
                if active[u]:
                    dsu.union(v, u)
            i += 1
        ans = max(ans, dsu.size(r))
    return ans

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.buffer.read().decode()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    adj = [[] for _ in range(n)]
    for _ in range(n - 1):
        x = int(next(it)) - 1
        y = int(next(it)) - 1
        v = int(next(it))
        adj[x].append((y, v))
        adj[y].append((x, v))
    q = int(next(it))
    ls = [int(next(it)) for _ in range(q)]
    return n, adj, q, ls

def solve_all(n: int, adj: List[List[Tuple[int,int]]], ls: List[int]) -> List[int]:
    f = compute_f(adj)
    return [solve_for_l(adj, f, l) for l in ls]

def main():
    parsed = read_input()
    if parsed is None:
        return
    n, adj, q, ls = parsed
    ans = solve_all(n, adj, ls)
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    # Cross-check on small deterministic trees
    cross_check_small()
    data = sys.stdin.buffer.read()
    if data.strip():
        parsed = read_input(data.decode())
        n, adj, q, ls = parsed
        ans = solve_all(n, adj, ls)
        print("\n".join(map(str, ans)))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to eccentricities to leaves via tree diameter, then take the largest DSU component under threshold $f \le f(r)+l$ at the event times.}
\WHY{Tests ability to combine classic tree properties (diameter endpoints), offline processing, and DSU under monotone insertions.}
\CHECKLIST{
- Compute diameter endpoints $a,b$ correctly.
- Get $f(v)=\max(d_a(v),d_b(v))$ for all $v$.
- For each $l$, sort or reuse order by $f$.
- Sweep thresholds, union active neighbors.
- Query DSU size at each event and take the max.}
\EDGECASES{
- $l=0$ (only flat-$f$ connected components).
- Very large $l$ (answer is $n$).
- Equal $f$ values causing many simultaneous activations.
- Heavily skewed trees (long chains).
- Star trees (many leaves).
- Large weights causing big $f$ values (use 64-bit ints).}
\PITFALLS{
- Using recursion for DFS on $n \approx 10^{5}$ (stack overflow) instead of iterative.
- Forgetting 0-based vs 1-based indices.
- Not unioning with all already active neighbors on activation.
- Sorting events incorrectly (ensure $\le t$ activation).
- Miscomputing distances with a priority queue (overkill) or negative weights (not allowed).
- Mixing up min/max in range constraint (use $\max f - \min f \le l$).}
\FAILMODES{Naive per-root BFS leads to $O(n^2)$ and TLE for $n=10^{5}$. The DSU sweep handles all thresholds efficiently.}
\ELI{Measure how late each room can be if a kid heads to the farthest exit; then, for each time budget $l$, turn on rooms in order of this lateness and group connected ones. The biggest group you can form when each room $r$ allows lateness up to $f(r)+l$ is the answer.}
\NotePages{3}

\end{document}