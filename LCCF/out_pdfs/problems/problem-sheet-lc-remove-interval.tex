% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Remove Interval}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/remove-interval/}}
\LINE{DIFFICULTY / RATING}{Medium}
\STATEMENT{You are given a list of pairwise disjoint, sorted integer intervals $\textit{intervals}$, where each interval is written as $[l, r)$ meaning $l \le x < r$. You are also given a single interval $\textit{toBeRemoved} = [L, R)$.

Remove the intersection of $\textit{toBeRemoved}$ from every interval in $\textit{intervals}$ and return the resulting list of intervals, also expressed as half-open intervals $[a, b)$ with $a < b$. Intervals that become empty after removal should be omitted.

Constraints:
\begin{bullets}
\item $1 \le \lvert \textit{intervals} \rvert \le 10^4$
\item Intervals are pairwise disjoint and sorted by starting point.
\item $-10^9 \le l < r \le 10^9$; $-10^9 \le L < R \le 10^9$.
\end{bullets}}
\BREAKDOWN{Scan the intervals once, and for each interval subtract its overlap with $[L, R)$. At most two pieces can remain from any interval: a left piece before $L$ and a right piece after $R$. Append only non-empty pieces.}
\ELI{Each original interval can be cut into a left chunk before $L$ and a right chunk after $R$; keep the chunks that have positive length.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode function signature in Python: \texttt{class Solution:\newline\quad def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -$>$ List[List[int]]}. The input \texttt{intervals} is a list of integer pairs $[l, r)$, pairwise disjoint and sorted by $l$. The input \texttt{toBeRemoved} is a single integer pair $[L, R)$.}
\OUTPUTS{Return a new list of integer pairs, each a half-open interval $[a, b)$ with $a < b$, representing the set difference $\bigcup \textit{intervals} \setminus [L, R)$. Preserve overall ascending order by start.}
\SAMPLES{
Example 1:\newline
Input: \texttt{intervals = [[0,2],[3,4],[5,7]], toBeRemoved = [1,6]}\newline
Output: \texttt{[[0,1],[6,7]]}\newline
Explanation: $[0,2)$ loses $[1,2)$ leaving $[0,1)$; $[3,4)$ is fully removed; $[5,7)$ loses $[5,6)$ leaving $[6,7)$.

Example 2:\newline
Input: \texttt{intervals = [[0,5]], toBeRemoved = [2,3]}\newline
Output: \texttt{[[0,2],[3,5]]}\newline
Explanation: Cutting out $[2,3)$ from $[0,5)$ leaves two pieces.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathcal{I} = \{[l_i, r_i)\}_{i=1}^n$ be disjoint half-open intervals with $l_1 < r_1 \le l_2 < r_2 \le \ldots \le l_n < r_n$. Let $B = [L, R)$. We want the ordered multiset of non-empty intervals forming $\left(\bigcup_{i=1}^n [l_i, r_i)\right) \setminus B$.}
\varmapStart
\var{\mathcal{I}}{input set of disjoint intervals}
\var{[l_i, r_i)}{the $i$-th input interval}
\var{B = [L, R)}{the interval to remove}
\var{\mathcal{O}}{output list of remaining intervals in ascending order}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i \in \{1,\ldots,n\}:\quad [l_i, r_i) \setminus [L, R) \;=\; \bigcup \left(\;X_i \cup Y_i\;\right)
\end{BreakableEquation*}
with pieces
\[
X_i =
\begin{cases}
[l_i, \min(r_i, L)) & \text{if } l_i < L \\
\varnothing & \text{otherwise}
\end{cases}
\quad\text{and}\quad
Y_i =
\begin{cases}
[\max(l_i, R), r_i) & \text{if } R < r_i \\
\varnothing & \text{otherwise.}
\end{cases}
\]
Keep only non-empty pieces $[a,b)$ where $a < b$.}
\ASSUMPTIONS{Intervals are half-open; endpoints are integers; input intervals are disjoint and sorted; $L < R$.}
\INVARIANTS{ 
\begin{bullets}
\item Output remains sorted because each produced piece preserves the original order.
\item No overlaps are introduced: a left piece ends at $\le L$ and a right piece starts at $\ge R$.
\item Each input interval contributes at most two output pieces.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate positional relations between $[l, r)$ and $[L, R)$: no overlap, fully inside, fully covering, or partial overlaps on left/right. Append resulting fragments explicitly.}
\ASSUMPTIONS{Half-open intervals; integer endpoints; stability of order.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize empty list \texttt{out}.
\item For each $[l, r)$ in \texttt{intervals}, compare to $[L, R)$:
\begin{bullets}
\item If $r \le L$ or $R \le l$: append $[l, r)$ unchanged.
\item Else if $l < L$ and $R < r$: append $[l, L)$ and $[R, r)$.
\item Else if $l < L < r \le R$: append $[l, L)$.
\item Else if $L \le l < R < r$: append $[R, r)$.
\item Else (fully removed): append nothing.
\end{bullets}
\item Return \texttt{out}.
\end{algosteps}
\COMPLEXITY{Single pass; constant work per interval.}
\[
\begin{aligned}
T(n) &= \Theta(n), \\
S(n) &= \Theta(1)\ \text{auxiliary} \quad (\Theta(n)\ \text{for output}).
\end{aligned}
\]
\CORRECTNESS{Case analysis covers all relative orders of endpoints. Disjointness and ordering of inputs ensure outputs stay ordered and non-overlapping.}
\EDGECASES{Touching boundaries ($r=L$ or $R=l$) produce no overlap; intervals fully swallowed by $[L,R)$; $[L,R)$ outside the hull of all intervals.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -> List[List[int]]:
        L, R = toBeRemoved
        out: List[List[int]] = []
        for l, r in intervals:
            # No overlap
            if r <= L or R <= l:
                out.append([l, r])
                continue
            # Partial overlaps or covering
            if l < L and R < r:
                out.append([l, L])
                out.append([R, r])
            elif l < L < r <= R:
                out.append([l, L])
            elif L <= l < R < r:
                out.append([R, r])
            else:
                # fully removed: L <= l and r <= R
                pass
        return out

if __name__ == "__main__":
    s = Solution()
    assert s.removeInterval([[0,2],[3,4],[5,7]], [1,6]) == [[0,1],[6,7]]
    assert s.removeInterval([[0,5]], [2,3]) == [[0,2],[3,5]]
    # touching boundaries: no removal occurs on touch
    assert s.removeInterval([[0,1],[2,3]], [1,2]) == [[0,1],[2,3]]
\end{minted}
\VALIDATION{Checked canonical examples; verified touching endpoints; verified full cover and disjoint cases by inspection.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Arithmetic Trimming Using Clamps}
\WHICHFORMULA{Use clamp-based construction of at most two fragments per interval: left piece $[l, \min(r, L))$ if $l < L$, and right piece $[\max(l, R), r)$ if $R < r$, skipping empty pieces. This removes explicit multi-branch case analysis.}
\ASSUMPTIONS{Same half-open model; intervals disjoint and sorted.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{out}.
\item For each $[l, r)$:
\begin{bullets}
\item If $l < L$: set $a=l$, $b=\min(r,L)$; if $a < b$, append $[a,b)$.
\item If $R < r$: set $a=\max(l,R)$, $b=r$; if $a < b$, append $[a,b)$.
\end{bullets}
\item Return \texttt{out}.
\end{algosteps}
\COMPLEXITY{Same asymptotics but with fewer branches and simpler conditions; $T(n)=\Theta(n)$, $S(n)=\Theta(1)$ auxiliary.}
\[
\begin{aligned}
T(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Direct from the set identity $[l,r)\setminus[L,R) = ([l,\min(r,L)) \cap \mathbb{R}) \cup ([\max(l,R),r) \cap \mathbb{R})$, with empty intervals discarded.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -> List[List[int]]:
        L, R = toBeRemoved
        out: List[List[int]] = []
        for l, r in intervals:
            if l < L:
                a, b = l, min(r, L)
                if a < b:
                    out.append([a, b])
            if R < r:
                a, b = max(l, R), r
                if a < b:
                    out.append([a, b])
        return out

if __name__ == "__main__":
    s = Solution()
    # Disjoint: unchanged
    assert s.removeInterval([[0,1],[3,5]], [1,3]) == [[0,1],[3,5]]
    # Fully covered interval disappears
    assert s.removeInterval([[0,10]], [0,10]) == []
    # Partial trims on both sides
    assert s.removeInterval([[0,10]], [2,8]) == [[0,2],[8,10]]
\end{minted}
\VALIDATION{Verified disjoint, identical, and strict interior removal; boundaries handled by half-open comparisons.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-Pass Streaming With At-Most-Two Fragments Per Interval}
\WHICHFORMULA{Stream intervals once and emit up to two fragments using clamp operations; this is optimal in time and space for comparison-based processing.}
\ASSUMPTIONS{Half-open intervals; $n$ up to $10^4$; integer endpoints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize empty output.
\item For each $[l,r)$ in order:
\begin{bullets}
\item If $l < L$, emit $[l, \min(r,L))$ if non-empty.
\item If $R < r$, emit $[\max(l,R), r)$ if non-empty.
\end{bullets}
\item Return the collected fragments.
\end{algosteps}
\OPTIMALITY{A lower bound of $\Omega(n)$ follows because each input interval may affect the output and must be inspected. The method achieves $O(n)$ time and $O(1)$ extra space beyond the output, thus optimal.}
\COMPLEXITY{Linear time and constant auxiliary space.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S(n)=\Theta(1)\ \text{auxiliary}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -> List[List[int]]:
        L, R = toBeRemoved
        res: List[List[int]] = []
        for l, r in intervals:
            if l < L:
                a, b = l, min(r, L)
                if a < b:
                    res.append([a, b])
            if R < r:
                a, b = max(l, R), r
                if a < b:
                    res.append([a, b])
        return res

if __name__ == "__main__":
    s = Solution()
    assert s.removeInterval([[0,2],[3,4],[5,7]], [1,6]) == [[0,1],[6,7]]
    assert s.removeInterval([[0,5]], [2,3]) == [[0,2],[3,5]]
    assert s.removeInterval([[0,1],[2,3]], [1,2]) == [[0,1],[2,3]]
\end{minted}
\VALIDATION{Exactly three asserts: canonical mixed case; two-piece split; touching boundary with no removal.}
\RESULT{Returns the list of remaining half-open intervals $[a,b)$ in ascending order after removing $[L,R)$ from each input interval.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for: no overlap; full coverage; left-only overlap; right-only overlap; two-piece split; touching boundaries; multiple intervals across the removal interval; negative endpoints.}
\LINE{CROSS-CHECKS}{Cross-validate the optimized method against a simple but equivalent trimming routine on a deterministic set of crafted inputs. Ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate deterministic families: evenly spaced disjoint intervals; shifted copies; various $[L,R)$ including outside, inside, touching, and spanning multiple intervals.}
\begin{minted}{python}
from typing import List, Tuple

def naive_remove(intervals: List[List[int]], B: List[int]) -> List[List[int]]:
    L, R = B
    out: List[List[int]] = []
    for l, r in intervals:
        # Emit pointwise-trimmed pieces without assuming cases
        if l < L:
            a, b = l, min(r, L)
            if a < b:
                out.append([a, b])
        if R < r:
            a, b = max(l, R), r
            if a < b:
                out.append([a, b])
    return out

class Solution:
    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -> List[List[int]]:
        L, R = toBeRemoved
        res: List[List[int]] = []
        for l, r in intervals:
            if l < L:
                a, b = l, min(r, L)
                if a < b:
                    res.append([a, b])
            if R < r:
                a, b = max(l, R), r
                if a < b:
                    res.append([a, b])
        return res

def generate_cases() -> List[Tuple[List[List[int]], List[int]]]:
    cases: List[Tuple[List[List[int]], List[int]]] = []
    # Basic families
    cases.append(([[0,2],[3,4],[5,7]], [1,6]))
    cases.append(([[0,5]], [2,3]))
    cases.append(([[0,1],[2,3]], [1,2]))
    cases.append(([[0,10]], [0,10]))
    cases.append(([[0,10]], [-5,0]))
    cases.append(([[0,10]], [10,15]))
    cases.append(([[0,2],[4,6],[8,10]], [2,8]))
    # Negative endpoints and shifts
    cases.append(([[ -10,-5],[0,5],[10,15]], [-7,12]))
    # Tight overlaps
    cases.append(([[0,3],[5,9]], [3,5]))
    # Multiple contained intervals
    cases.append(([[0,1],[2,4],[6,7],[9,12]], [1,10]))
    return cases

if __name__ == "__main__":
    sol = Solution()
    for intervals, B in generate_cases():
        assert sol.removeInterval(intervals, B) == naive_remove(intervals, B)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -> List[List[int]]:
        L, R = toBeRemoved
        res: List[List[int]] = []
        for l, r in intervals:
            if l < L:
                a, b = l, min(r, L)
                if a < b:
                    res.append([a, b])
            if R < r:
                a, b = max(l, R), r
                if a < b:
                    res.append([a, b])
        return res

if __name__ == "__main__":
    s = Solution()
    # Sanity checks
    assert s.removeInterval([[0,2],[3,4],[5,7]], [1,6]) == [[0,1],[6,7]]
    assert s.removeInterval([[0,5]], [2,3]) == [[0,2],[3,5]]
    assert s.removeInterval([[0,1],[2,3]], [1,2]) == [[0,1],[2,3]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Subtract the interval $[L,R)$ from each disjoint input interval and return the non-empty remainders in order.}
\WHY{Appears in interval arithmetic, timeline editing, calendar systems, and sweep-line preprocessing; tests understanding of interval relations and boundary handling.}
\CHECKLIST{
\begin{bullets}
\item Read endpoints and confirm half-open semantics.
\item For each $[l,r)$, compute left piece with $\min(r,L)$ and right piece with $\max(l,R)$.
\item Append only if $a < b$.
\item Maintain input order; do not merge across the removed gap.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Touching boundaries: $r=L$ or $R=l$ means no overlap.
\item Full cover: $L \le l$ and $r \le R$ yields no output.
\item Left-only overlap: $l < L < r \le R$.
\item Right-only overlap: $L \le l < R < r$.
\item Split both sides: $l < L$ and $R < r$.
\item Outside hull: $R \le l_1$ or $L \ge r_n$ leaves all unchanged.
\item Negative or large endpoints.
\item Single interval inputs.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using closed-interval comparisons and off-by-one errors with integers.
\item Emitting empty segments when $a=b$.
\item Reordering outputs relative to inputs.
\item Accidentally merging the two pieces of a split interval.
\item Forgetting that at most two pieces can result from one interval.
\item Mishandling equalities in comparisons ($\le$ vs $<$).
\end{bullets}}
\FAILMODES{Case-by-case implementations that miss a boundary equality can drop or add zero-length intervals. The clamp-based method uniformly handles all cases and discards empty pieces.}
\ELI{Cut a rectangular hole $[L,R)$ out of each bar $[l,r)$. If a bar sticks out on the left or right, keep those sticking-out parts. If it is entirely under the hole, it disappears.}
\NotePages{3}

\end{document}