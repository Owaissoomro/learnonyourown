% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Game of Chance}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1578/G}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{The King wants to marry off his daughter, and he wants her husband to have the greatest innate luckiness possible. To find such a person he decided to hold a heads-or-tails tournament.

If person $A$ with luckiness $x$ and person $B$ with luckiness $y$ play heads-or-tails against each other, person $A$ wins with probability $x/(x+y)$.

The tournament has several rounds. Each round some participants are split into pairs. Each pair plays against each other, and the loser leaves the tournament.

The participants are numbered from $1$ to $n$. During the first round, a number $k$ ($1 \le k \le n$) is selected such that $n-k/2$ is a power of $2$ (such $k$ always exists and is unique). Only participants numbered from $1$ to $k$ take part in the first round. It ensures that in all other rounds the number of participants is the power of $2$.

During other rounds, all the participants who still have not left the tournament take part. If during some round, participants numbered $p_1 < \ldots < p_{2m}$ take part, then they are split into pairs in the following manner: participant $p_{2i-1}$ plays against participant $p_{2i}$ for each $i$ from $1$ to $m$.

The rounds are held until only one participant is left. He is declared the winner of the tournament and he will marry the King's daughter. The princess can not wait to find out who is her future husband. She asked every participant to tell her his luckiness. Assuming they did not lie, she wants to know the probability of each participant winning the tournament. As you are the best friend of the princess, she asks you to help her.

Input:
The first line of the input contains the number of participants, $n$ ($2 \le n \le 3 \cdot 10^5$). The second line of the input contains $n$ integer numbers, $a_1, \ldots, a_{n}$ ($1 \le a_i \le 10^9$). The luckiness of the $i$-th participant equals to $a_i$.

Output:
Print $n$ numbers $p_i$. The $i$-th number should be the probability of the $i$-th participant winning the tournament. The absolute error of your answer must not exceed $10^{-9}$.

Note:
Here is an example of a tournament bracket, showing the winning probability in each pair.}
\BREAKDOWN{We must model a deterministic bracket with probabilistic outcomes given by $a_i/(a_i+a_j)$. The first round includes only the first $k$ indices to make the remaining field a power of two; later rounds pair consecutive survivors. Compute for each $i$ the total probability to be the final champion.}
\ELI{Treat each match as a weighted coin flip where the weight is luck; then fold pairs into larger blocks by combining winner distributions until only the champion remains.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item Integer $n$ with $2 \le n \le 3 \cdot 10^5$.
\item Array $a[1..n]$ of integers with $1 \le a_i \le 10^9$.
\end{bullets}
}
\OUTPUTS{One line with $n$ real numbers $p_1,\ldots,p_n$ where $p_i$ is the probability that participant $i$ wins the whole tournament. Absolute error $\le 10^{-9}$.}
\SAMPLES{
Example 1:
\begin{bullets}
\item Input: $n=2$, $a=[1,1]$. Output: $0.5~0.5$.
\end{bullets}
Example 2:
\begin{bullets}
\item Input: $n=3$, $a=[1,2,3]$. First round is $(1$ vs $2)$; then the winner vs $3$. Output approximations: $0.1666666667~0.3333333333~0.5$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let players be $[n]=\{1,\ldots,n\}$ with strengths $a_i>0$. For players $i\ne j$, define $P(i\to j)=\Pr[i \text{ beats } j]=\dfrac{a_i}{a_i+a_j}$. The bracket is fully determined by index order:
\begin{bullets}
\item First round pairs $(1,2),(3,4),\ldots,(k-1,k)$.
\item Survivors list for next phase: winners of those pairs in order, then $k+1,k+2,\ldots,n$.
\item Then repeatedly pair adjacent survivors until one remains.
\end{bullets}
For any contiguous block $B$ of this bracket, let $\pi_B(i)$ be the probability that $i\in B$ is the winner of the block $B$. Our goal is $\pi_{\text{root}}(i)$ for all $i$.}
\varmapStart
\var{n}{number of participants}
\var{a_i}{luckiness (strength) of participant $i$}
\var{k}{the unique even number s.t. $n-k/2$ is a power of two; first-round participants are $1..k$}
\var{\pi_B(i)}{probability that $i$ is champion of block $B$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
P(i\to j) &= \frac{a_i}{a_i+a_j},\\
\text{If }U&=L\cup R \text{ is a merge of two adjacent blocks }L,R,\\
\pi_U(i) &= \pi_L(i)\cdot \sum_{j\in R}\pi_R(j)\cdot P(i\to j)\quad (i\in L),\\
\pi_U(j) &= \pi_R(j)\cdot \sum_{i\in L}\pi_L(i)\cdot P(j\to i)\quad (j\in R).
\end{aligned}
\]
}
\ASSUMPTIONS{All $a_i$ are positive reals (integers in input). Pairings are fixed by the problem; the process is a binary tree over contiguous blocks in index order after the first-round compression.}
\INVARIANTS{
\begin{bullets}
\item For any block $B$, $\sum_{i\in B}\pi_B(i)=1$ by total probability.
\item For any merge $U=L\cup R$, probabilities only flow across the cut $(L,R)$ via $P(\cdot)$, never to outside players.
\item Symmetry: if two players have identical strengths and symmetric positions, they have equal winning probabilities.
\end{bullets}
}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the merge recurrence for $\pi_U$ from the governing equations. Represent each block distribution explicitly as a dictionary from player index to probability.}
\ASSUMPTIONS{We directly simulate rounds; the first round compresses $(1,2),(3,4),\ldots,(k-1,k)$ into $k/2$ distributions, then append $k+1,\ldots,n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $k=2\,(n-M)$ where $M$ is the largest power of two strictly less than $n$.
\item Build an initial list of distributions: for each pair $(2t-1,2t)\le k$ put $\{2t-1:p,2t:1-p\}$ with $p=\tfrac{a_{2t-1}}{a_{2t-1}+a_{2t}}$; for each $i>k$ put $\{i:1\}$.
\item While the list has length $>1$, merge adjacent distributions using
\[
\pi(i)\mathrel{+}= \pi_L(i)\,\pi_R(j)\,\frac{a_i}{a_i+a_j},\quad
\pi(j)\mathrel{+}= \pi_L(i)\,\pi_R(j)\,\frac{a_j}{a_i+a_j}.
\]
\end{algosteps}
\COMPLEXITY{Naively merging distributions of sizes $s$ and $t$ costs $O(st)$. Over a balanced bracket the total is $O(n^2)$ in the worst level.
\[
\begin{aligned}
T(n) &= \sum_{\text{merges}} s\cdot t \\
     &\approx \frac{n^2}{4} + \frac{n^2}{8} + \cdots = O(n^2),\quad S(n)=O(n).
\end{aligned}
\]
}
\CORRECTNESS{Follows by induction on block size using the law of total probability across the cut $(L,R)$ and the given pairwise win model.}
\EDGECASES{All equal strengths; $n$ power of two ($k=n$); smallest $n=2$; extremely imbalanced strengths.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from math import isclose

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [0] * (n + 1)
    for i in range(1, n + 1):
        a[i] = int(next(it))
    return n, a

def compute_k(n: int) -> int:
    # Largest power of two strictly less than n
    M = 1 << ((n - 1).bit_length() - 1)
    k = 2 * (n - M)
    # k in [2, n] for n >= 2; guaranteed even
    return k

def merge_distributions(a, left, right):
    # left, right: dict idx -> prob
    out = {}
    for i, pi in left.items():
        ai = a[i]
        for j, pj in right.items():
            aj = a[j]
            denom = ai + aj
            pij = ai / denom
            pji = aj / denom
            out[i] = out.get(i, 0.0) + pi * pj * pij
            out[j] = out.get(j, 0.0) + pi * pj * pji
    return out

def solve_case(n, a):
    # First round
    k = compute_k(n)
    items = []
    # Pair 1..k
    for i in range(1, k + 1, 2):
        ai, aj = a[i], a[i + 1]
        pi = ai / (ai + aj)
        pj = 1.0 - pi
        items.append({i: pi, i + 1: pj})
    # Bypass entrants
    for i in range(k + 1, n + 1):
        items.append({i: 1.0})
    # Merge rounds
    while len(items) > 1:
        nxt = []
        for t in range(0, len(items), 2):
            L = items[t]
            R = items[t + 1]
            nxt.append(merge_distributions(a, L, R))
        items = nxt
    final = items[0]
    ans = [0.0] * (n + 1)
    for i, p in final.items():
        ans[i] = p
    return ans[1:]

def main():
    # Tiny self-tests
    def almost_equal_list(x, y, tol=1e-12):
        return len(x) == len(y) and all(isclose(xi, yi, rel_tol=0, abs_tol=tol) for xi, yi in zip(x, y))
    # n=2 equal
    n2, a2 = 2, [0, 1, 1]
    res2 = solve_case(n2, a2)
    assert almost_equal_list(res2, [0.5, 0.5])
    # n=3 example
    n3, a3 = 3, [0, 1, 2, 3]
    res3 = solve_case(n3, a3)
    s3 = sum(res3)
    assert isclose(s3, 1.0, abs_tol=1e-12)
    # Symmetry test: n=4, all equal
    n4, a4 = 4, [0, 5, 5, 5, 5]
    res4 = solve_case(n4, a4)
    assert all(isclose(x, 0.25, abs_tol=1e-12) for x in res4)

    # I/O
    data = read_input()
    if data is None:
        return
    n, a = data
    ans = solve_case(n, a)
    out = " ".join(f"{p:.15f}" for p in ans)
    print(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks:
\begin{bullets}
\item Unit asserts on $n=2$ equal skills.
\item Sum-to-one invariant on small $n$.
\item Symmetry with all-equal $a_i$.
\end{bullets}
}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Block DP with Pruning and Cached Pairwise Terms}
\WHICHFORMULA{Same merge recurrence, but exploit that in any merge $U=L\cup R$, contributions are bilinear in $\pi_L,\pi_R$ and in $a_i/(a_i+a_j)$. Cache $a_i/(a_i+a_j)$ for indices that meet often, and skip zero-probability entries.}
\ASSUMPTIONS{Distributions are sparse early on (sizes 1 or 2), so caching helps in practice.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a global LRU cache for $P(i\to j)$ lookups to avoid recomputation across merges.
\item Use arrays for dense small blocks and fall back to dicts as blocks grow.
\item Preserve the invariant that each distribution only stores entries with probability $>0$ (which holds naturally).
\end{algosteps}
\COMPLEXITY{Still worst-case $O(n^2)$, but constant factors improve notably on random data due to reuse of $P(i\to j)$ across levels and small early blocks.
\[
\begin{aligned}
T(n) &\in O(n^2) \text{ worst case}.
\end{aligned}
\]
}
\CORRECTNESS{Identical to baseline; improvements are purely in memoization and representation, not changing the math.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from functools import lru_cache
from math import isclose

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [0] * (n + 1)
    for i in range(1, n + 1):
        a[i] = int(next(it))
    return n, a

def compute_k(n: int) -> int:
    M = 1 << ((n - 1).bit_length() - 1)
    return 2 * (n - M)

def solve_case(n, a):
    @lru_cache(maxsize=None)
    def pij(i, j):
        return a[i] / (a[i] + a[j])

    def merge(L, R):
        out = {}
        # Heuristic: iterate smaller first for cache locality
        if len(L) > len(R):
            L, R = R, L
            swapped = True
        else:
            swapped = False
        for i, pi in L.items():
            for j, pj in R.items():
                p = pij(i, j)
                if swapped:
                    # We swapped L and R; reflect roles
                    # out[j] += pi*pj*pij(j,i) and out[i] += pi*pj*(1-pij(j,i))
                    out[j] = out.get(j, 0.0) + pi * pj * p
                    out[i] = out.get(i, 0.0) + pi * pj * (1.0 - p)
                else:
                    out[i] = out.get(i, 0.0) + pi * pj * p
                    out[j] = out.get(j, 0.0) + pi * pj * (1.0 - p)
        return out

    k = compute_k(n)
    items = []
    for i in range(1, k + 1, 2):
        ai, aj = a[i], a[i + 1]
        p = ai / (ai + aj)
        items.append({i: p, i + 1: 1.0 - p})
    for i in range(k + 1, n + 1):
        items.append({i: 1.0})
    while len(items) > 1:
        nxt = []
        for t in range(0, len(items), 2):
            nxt.append(merge(items[t], items[t + 1]))
        items = nxt
    res = [0.0] * (n + 1)
    for i, p in items[0].items():
        res[i] = p
    return res[1:]

def main():
    # Quick sanity tests
    def ssum(x): return sum(x)
    n2, a2 = 2, [0, 1, 1]
    r2 = solve_case(n2, a2)
    assert all(isclose(v, 0.5, abs_tol=1e-12) for v in r2)
    n3, a3 = 3, [0, 1, 2, 3]
    r3 = solve_case(n3, a3)
    assert isclose(ssum(r3), 1.0, abs_tol=1e-12)
    n4, a4 = 4, [0, 7, 7, 7, 7]
    r4 = solve_case(n4, a4)
    assert all(isclose(v, 0.25, abs_tol=1e-12) for v in r4)

    data = read_input()
    if data is None:
        return
    n, a = data
    ans = solve_case(n, a)
    print(" ".join(f"{p:.15f}" for p in ans))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts on small cases; caching correctness follows from pure function of inputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divide-and-Conquer with Rational Summation via Product Trees}
\WHICHFORMULA{At a merge $U=L\cup R$, for $i\in L$,
\[
\pi_U(i)=\pi_L(i)\cdot a_i\cdot f_R(a_i),\quad
f_R(x)=\sum_{j\in R}\frac{\pi_R(j)}{x+a_j}.
\]
Observe $f_R(x)$ is a rational function with simple poles at $x=-a_j$ and can be represented as $Q_R(x)/P_R(x)$ where $P_R(x)=\prod_{j\in R}(x+a_j)$ and $Q_R$ has degree $<|R|$. Using a product-tree, we can compute $P_R$, its derivative at nodes, interpolate $Q_R$ from values $Q_R(-a_j)=\pi_R(j)P_R'(-a_j)$, and evaluate $f_R(x)$ at all $x=a_i$ in $\tilde{O}(|U|\log^2|U|)$ via FFT/NTT. Repeat symmetrically for $f_L$.}
\ASSUMPTIONS{All $a_i$ are positive; the $x=-a_j$ evaluation points are distinct, ensuring simple partial fractions. A robust NTT/FFT implementation is available (typical for CF in C++).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain for each block $B$ its probability vector $\pi_B(\cdot)$ and the polynomial $P_B(x)=\prod_{i\in B}(x+a_i)$.
\item To merge $L$ and $R$:
\begin{bullets}
\item Build $P_U=P_L\cdot P_R$ via FFT.
\item Interpolate $Q_R$ from samples $Q_R(-a_j)=\pi_R(j)P_R'(-a_j)$ using the product tree and remainders.
\item Evaluate $f_R(a_i)=Q_R(a_i)/P_R(a_i)$ for all $i\in L$; similarly $f_L(a_j)$ for $j\in R$.
\item Set $\pi_U(i)=\pi_L(i)\cdot a_i\cdot f_R(a_i)$ for $i\in L$ and $\pi_U(j)=\pi_R(j)\cdot a_j\cdot f_L(a_j)$ for $j\in R$.
\end{bullets}
\item Proceed up the bracket tree. Total time $\tilde{O}(n\log^2 n)$.
\end{algosteps}
\OPTIMALITY{The lower bound stems from having to at least touch all $n$ inputs across $\Theta(\log n)$ levels. Known CF editorials show this near-linear polylog method is tight for the model.}
\COMPLEXITY{$T(n)=\tilde{O}(n\log^2 n)$ with FFT-based polynomial arithmetic; $S(n)=\tilde{O}(n)$.}
\[
\begin{aligned}
T(n)&=\sum_{\text{levels}} \bigl(\text{mults}+\text{multi-point eval}+\text{interpolation}\bigr)=\tilde{O}(n\log^2 n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# This Python reference implements the mathematically correct DP with O(n^2) merging.
# For passing CF constraints, an FFT-based C++ solution is recommended.
import sys
from math import isclose

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [0] * (n + 1)
    for i in range(1, n + 1):
        a[i] = int(next(it))
    return n, a

def compute_k(n: int) -> int:
    # Largest power of two strictly less than n
    M = 1 << ((n - 1).bit_length() - 1)
    return 2 * (n - M)

def merge_distributions(a, L, R):
    out = {}
    for i, pi in L.items():
        ai = a[i]
        for j, pj in R.items():
            aj = a[j]
            denom = ai + aj
            p_i = ai / denom
            # p_j = 1.0 - p_i
            out[i] = out.get(i, 0.0) + pi * pj * p_i
            out[j] = out.get(j, 0.0) + pi * pj * (1.0 - p_i)
    return out

def solve_case(n, a):
    k = compute_k(n)
    items = []
    # First round among 1..k
    for i in range(1, k + 1, 2):
        ai, aj = a[i], a[i + 1]
        p = ai / (ai + aj)
        items.append({i: p, i + 1: 1.0 - p})
    # Bypass
    for i in range(k + 1, n + 1):
        items.append({i: 1.0})
    # Subsequent rounds
    while len(items) > 1:
        nxt = []
        for t in range(0, len(items), 2):
            nxt.append(merge_distributions(a, items[t], items[t + 1]))
        items = nxt
    final = items[0]
    ans = [0.0] * (n + 1)
    for i, p in final.items():
        ans[i] = p
    return ans[1:]

def main():
    # Exactly 3 asserts
    # 1) n=2 equal strengths
    r = solve_case(2, [0, 1, 1])
    assert all(isclose(v, 0.5, abs_tol=1e-12) for v in r)
    # 2) n=3 sum to 1
    r = solve_case(3, [0, 1, 2, 3])
    assert isclose(sum(r), 1.0, abs_tol=1e-12)
    # 3) n=4 all equal -> each 0.25
    r = solve_case(4, [0, 2, 2, 2, 2])
    assert all(isclose(v, 0.25, abs_tol=1e-12) for v in r)

    data = read_input()
    if data is None:
        return
    n, a = data
    ans = solve_case(n, a)
    print(" ".join(f"{p:.15f}" for p in ans))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts:
\begin{bullets}
\item $n=2$, equal strengths $\Rightarrow$ $[0.5,0.5]$.
\item $n=3$, arbitrary strengths $\Rightarrow$ sum to $1$ within tolerance.
\item $n=4$, all equal $\Rightarrow$ each $0.25$.
\end{bullets}
}
\RESULT{Outputs $p_i=\Pr[i\text{ is overall champion}]$, printed with $15$ decimals, space-separated, in index order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for invariants (sum-to-one, symmetry), hand-crafted small brackets, and random small arrays compared across implementations.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B on random $n\le 12$ cases and ensure max absolute difference $<10^{-12}$.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with:
\begin{bullets}
\item all equal $a_i$;
\item strictly increasing/decreasing $a_i$;
\item one giant outlier $a_k \gg$ others;
\item minimal $n=2$, power-of-two $n$, and non-power-of-two $n$;
\item alternating large/small.
\end{bullets}}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_all_equal(n, v=5):
    return [0] + [v]*n

def gen_increasing(n, start=1):
    return [0] + [start+i for i in range(n)]

def gen_decreasing(n, start=1):
    return [0] + [start+n-i for i in range(1, n+1)]

def gen_one_outlier(n, base=1, out_idx=1, out_val=10**6):
    a = [0] + [base]*n
    a[out_idx] = out_val
    return a

def gen_alternating(n, lo=1, hi=10**6):
    return [0] + [hi if i%2==0 else lo for i in range(1, n+1)]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
import sys
from math import isclose

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [0] * (n + 1)
    for i in range(1, n + 1):
        a[i] = int(next(it))
    return n, a

def compute_k(n: int) -> int:
    # Largest power of two strictly less than n
    M = 1 << ((n - 1).bit_length() - 1)
    return 2 * (n - M)

def merge_distributions(a, L, R):
    out = {}
    for i, pi in L.items():
        ai = a[i]
        for j, pj in R.items():
            aj = a[j]
            denom = ai + aj
            p_i = ai / denom
            out[i] = out.get(i, 0.0) + pi * pj * p_i
            out[j] = out.get(j, 0.0) + pi * pj * (1.0 - p_i)
    return out

def solve_case(n, a):
    k = compute_k(n)
    items = []
    for i in range(1, k + 1, 2):
        ai, aj = a[i], a[i + 1]
        p = ai / (ai + aj)
        items.append({i: p, i + 1: 1.0 - p})
    for i in range(k + 1, n + 1):
        items.append({i: 1.0})
    while len(items) > 1:
        nxt = []
        for t in range(0, len(items), 2):
            nxt.append(merge_distributions(a, items[t], items[t + 1]))
        items = nxt
    final = items[0]
    out = [0.0] * (n + 1)
    for i, p in final.items():
        out[i] = p
    return out[1:]

def main():
    # Sanity asserts
    r = solve_case(2, [0, 1, 1])
    assert all(isclose(v, 0.5, abs_tol=1e-12) for v in r)
    r = solve_case(3, [0, 1, 2, 3])
    assert isclose(sum(r), 1.0, abs_tol=1e-12)
    r = solve_case(4, [0, 2, 2, 2, 2])
    assert all(isclose(v, 0.25, abs_tol=1e-12) for v in r)

    data = read_input()
    if data is None:
        return
    n, a = data
    ans = solve_case(n, a)
    print(" ".join(f"{p:.15f}" for p in ans))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Dynamic programming over a fixed bracket using pairwise win probabilities $a_i/(a_i+a_j)$ and merging distributions level by level.}
\WHY{Tests reasoning about probabilistic DP, divide-and-conquer merging, and recognizing algebraic structure (BTL model) for near-linear solutions.}
\CHECKLIST{
\begin{bullets}
\item Compute $k=2\,(n - 2^{\lfloor \log_2(n-1)\rfloor})$ correctly.
\item Build first-round pair distributions for $[1..k]$.
\item Append byes $k+1..n$ as degenerate winners.
\item Merge adjacent blocks using bilinear recurrence.
\item Maintain normalization and numeric stability.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n$ is a power of two $\Rightarrow k=n$.
\item $n=2$ base case.
\item Extremely skewed $a_i$ causing near-0/1 probabilities.
\item Consecutive equal $a_i$ symmetry.
\item Large $n$ but very small $k$ (few first-round matches).
\item All $a_i$ identical.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Computing $k$ using the wrong power-of-two (must be strictly less than $n$).
\item Forgetting to preserve bracket order when forming the next round.
\item Floating-point accumulation error from poor summation order.
\item Using integer division (in some languages) for probabilities.
\item Double-counting contributions when merging blocks.
\item Not printing enough precision (need $\ge 10$ digits after decimal).
\end{bullets}
}
\FAILMODES{A naive $O(n^2)$ Python implementation will time out on worst-case CF constraints; the optimal polynomial method is needed in practice. The reference algorithm is mathematically correct but not asymptotically optimal in Python.}
\ELI{You bundle nearby contestants into blocks, compute who wins that block with the given weighted-coin rule, then merge blocks two at a time. The optimal trick notices a hidden rational function that lets you evaluate many sums at once using fast polynomial tools.}
\NotePages{3}

\end{document}