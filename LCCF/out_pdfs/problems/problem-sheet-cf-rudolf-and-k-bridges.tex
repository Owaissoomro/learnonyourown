% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Rudolf and k Bridges}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1941/E}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Bernard loves visiting Rudolf, but he is always running late. The problem is that Bernard has to cross the river on a ferry. Rudolf decided to help his friend solve this problem.

The river is a grid of $n$ rows and $m$ columns. The intersection of the $i$-th row and the $j$-th column contains the number $a_{i,j}$ — the depth in the corresponding cell. All cells in the first and last columns correspond to the river banks, so the depth for them is $0$.

Rudolf can choose the row $(i,1), (i,2), \ldots, (i,m)$ and build a bridge over it. In each cell of the row, he can install a support for the bridge. The cost of installing a support in the cell $(i,j)$ is $a_{i,j}+1$. Supports must be installed so that the following conditions are met:
\begin{enumerate}
\item A support must be installed in cell $(i,1)$;
\item A support must be installed in cell $(i,m)$;
\item The distance between any pair of adjacent supports must be no more than $d$. The distance between supports $(i, j_1)$ and $(i, j_2)$ is $\lvert j_1 - j_2\rvert - 1$.
\end{enumerate}

Building just one bridge is boring. Therefore, Rudolf decided to build $k$ bridges on consecutive rows of the river, that is, to choose some $i$ ($1 \le i \le n - k + 1$) and independently build a bridge on each of the rows $i, i + 1, \ldots, i + k - 1$. Help Rudolf minimize the total cost of installing supports.

Input:
The first line contains a single integer $t$ $(1 \le t \le 10^3)$ — the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains four integers $n$, $m$, $k$, and $d$ ($1 \le k \le n \le 100$, $3 \le m \le 2 \cdot 10^5$, $1 \le d \le m$) — the number of rows and columns of the field, the number of bridges, and the maximum distance between supports.

Then follow $n$ lines, $i$-th line contains $m$ positive integers $a_{i, j}$ ($0 \le a_{i, j} \le 10^6$, $a_{i, 1} = a_{i, m} = 0$) — the depths of the river cells.

It is guaranteed that the sum of $n \cdot m$ for all sets of input data does not exceed $2 \cdot 10^5$.

Output:
For each test case, output a single number — the minimum total cost of supports installation.

Note:
In the first test case, it is most profitable to build a bridge on the second row. It is not a top view, but side view: gray cells — bridge itself, white cells are empty, black cells — supports, blue cells — water, brown cells — river bottom. In the second test case, it is most profitable to build bridges on the second and third rows. The supports will be placed in cells $(2, 3)$, $(3, 2)$, and on the river banks. In the third test case the supports can be placed along the river banks.}
\BREAKDOWN{Compute the minimum cost to span each row with supports under a maximum gap constraint, then select a window of $k$ consecutive rows with minimum total cost. Per-row cost reduces to a shortest-path/DP with windowed minima over columns.}
\ELI{For each row, you can step from column to column with jumps of at most $d+1$ and pay $a_j+1$ where you land; find the cheapest way to reach the last column, then pick $k$ consecutive rows with the smallest sum of these costs.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.
\begin{bullets}
\item $t$ — number of test cases; $1 \le t \le 10^3$.
\item For each test case: integers $n,m,k,d$ with $1 \le k \le n \le 100$, $3 \le m \le 2\cdot 10^5$, $1 \le d \le m$.
\item Then $n$ rows follow, each with $m$ integers $a_{i,j}$, where $0 \le a_{i,j} \le 10^6$ and $a_{i,1}=a_{i,m}=0$.
\end{bullets}}
\OUTPUTS{For each test case, a single integer — the minimum total cost of installing supports when choosing $k$ consecutive rows and optimizing each row independently.}
\SAMPLES{Example 1 (tiny).
\[
\begin{aligned}
t&=1\\
n,m,k,d&=3,\,3,\,1,\,1\\
\text{grid}&=\begin{bmatrix}0&7&0\\0&0&0\\0&5&0\end{bmatrix}
\end{aligned}
\]
Any row can be spanned using only the banks (gap $1 \le d$), so each row costs $2$, answer $2$.

Example 2 (forces interior supports).
\[
\begin{aligned}
t&=1\\
n,m,k,d&=1,\,5,\,1,\,1\\
\text{row}&=[0,9,7,4,0]
\end{aligned}
\]
Optimal path is $1\to 3\to 5$ with cost $1+(7+1)+1=10$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Fix a row with costs $c_j=a_{i,j}+1$ for $j=1,\ldots,m$ and $c_1=c_m=1$. You must pick a sequence of column indices $1=j_0 < j_1 < \cdots < j_r = m$ such that $j_{t}-j_{t-1} \le d+1$ for all $t$, minimizing $\sum_{t=0}^{r} c_{j_t}$. The total answer for a test case is $\min_{s} \sum_{i=s}^{s+k-1} \operatorname{RowCost}(i)$.}
\varmapStart
\var{n,m}{grid dimensions}
\var{k}{number of consecutive rows to choose}
\var{d}{maximum allowed empty cells between adjacent supports (gap); jump length $\le d+1$}
\var{a_{i,j}}{depth at row $i$, column $j$}
\var{c_j}{per-cell support cost $a_{i,j}+1$ on a fixed row}
\var{\operatorname{RowCost}(i)}{minimum support cost to span row $i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Row DP: }&\quad \text{dp}[1]=c_1,\quad
\text{dp}[j]=c_j+\min_{t\in[\max(1,j-(d+1)),\,j-1]} \text{dp}[t]\ \ (2\le j\le m).\\
&\text{RowCost}(i)=\text{dp}[m].\\
\text{Window: }&\quad \text{Ans}=\min_{s\in[1,n-k+1]} \sum_{i=s}^{s+k-1} \text{RowCost}(i).
\end{aligned}
\]
}
\ASSUMPTIONS{Columns indexed from $1$ to $m$. Banks at columns $1$ and $m$ must be included. All rows are independent for cost computation.}
\INVARIANTS{
\begin{bullets}
\item Feasible transitions respect $j-t \le d+1$.
\item $\text{dp}[j]$ is nondecreasing lower envelope of feasible partial path costs.
\item Sliding window of length $k$ over per-row costs yields the correct total minimum since rows are independent.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct DP over columns with a naive $\min$ over the last $d{+}1$ positions. Then a simple sliding window of size $k$ over rows.}
\ASSUMPTIONS{Compute per-row cost independently; $d$ may be as large as $m$, so this approach is only feasible for small rows.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each row, set $c_j=a_{i,j}+1$, with $c_1=c_m=1$. Initialize $\text{dp}[1]=c_1$.
\item For $j=2\ldots m$, set $\text{dp}[j]=c_j+\min\{\text{dp}[t]\mid t\in[\max(1,j-(d+1)),j-1]\}$.
\item The row cost is $\text{dp}[m]$. Gather all row costs and take the minimum sum over any consecutive $k$ rows by sliding window.
\end{algosteps}
\COMPLEXITY{Naively, per-row $\Theta(m(d{+}1)))$; total $\Theta\!\big(\sum m(d{+}1)\big)$ across rows. Space $\Theta(m)$ per row.}
\[
\begin{aligned}
T_{\text{row}}(m,d) &= \sum_{j=2}^{m} O(\min(d{+}1,j-1)) = O(m(d{+}1)).\\
S_{\text{row}}(m) &= O(m).
\end{aligned}
\]
\CORRECTNESS{The DP enumerates all feasible previous supports within jump constraint and adds current cost; by induction on $j$, it yields the optimal partial cost to reach $j$. Windowing preserves optimality since rows are independent.}
\EDGECASES{
\begin{bullets}
\item $d=0$: must place supports at every column; DP reduces to prefix sums.
\item $d \ge m-1$: only banks suffice; cost is $2$ per row.
\item $m=3$: single interior cell possibly skipped if $d\ge 1$.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, io
from typing import List, Tuple

def compute_row_cost_naive(row: List[int], d: int) -> int:
    m = len(row)
    c = [x + 1 for x in row]
    dp = [10**30] * m
    dp[0] = c[0]
    for j in range(1, m):
        L = max(0, j - (d + 1))
        best = min(dp[t] for t in range(L, j))
        dp[j] = c[j] + best
    return dp[-1]

def solve_case_naive(n: int, m: int, k: int, d: int, grid: List[List[int]]) -> int:
    costs = [compute_row_cost_naive(grid[i], d) for i in range(n)]
    # sliding window of size k
    window = sum(costs[:k])
    ans = window
    for i in range(k, n):
        window += costs[i] - costs[i - k]
        if window < ans:
            ans = window
    return ans

def read_input() -> List[Tuple[int, int, int, int, List[List[int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it)); d = int(next(it))
        grid = []
        for _ in range(n):
            row = [int(next(it)) for _ in range(m)]
            grid.append(row)
        cases.append((n, m, k, d, grid))
    return cases

def solve_all_naive() -> None:
    out_lines = []
    for (n, m, k, d, grid) in read_input():
        out_lines.append(str(solve_case_naive(n, m, k, d, grid)))
    sys.stdout.write("\n".join(out_lines))

def solve_io_naive(s: str) -> str:
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    sys.stdin = io.StringIO(s)
    sys.stdout = io.StringIO()
    try:
        solve_all_naive()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

def _tests_naive():
    # Test 1: banks only (m=3, d=1)
    data = "1\n3 3 1 1\n0 7 0\n0 0 0\n0 5 0\n"
    assert solve_io_naive(data) == "2\n"
    # Test 2: d=0 forces every column support
    data = "1\n1 4 1 0\n0 5 1 0\n"
    assert solve_io_naive(data) == "10\n"
    # Test 3: m=5, d=1, best 1->3->5
    data = "1\n1 5 1 1\n0 9 7 4 0\n"
    assert solve_io_naive(data) == "10\n"
    # Test 4: window k=2, d=0 varying rows
    data = "1\n3 3 2 0\n0 1 0\n0 2 0\n0 3 0\n"
    assert solve_io_naive(data) == "9\n"

if __name__ == "__main__":
    _tests_naive()
    # Do not call solve_all_naive() here to avoid interfering with improved solutions below.
\end{minted}
\VALIDATION{Included four asserts covering: only banks, contiguous supports, interior placement, and window aggregation.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Maintain the minimum over the last $d{+}1$ dp-values with a monotonic deque, yielding $O(m)$ per row.}
\ASSUMPTIONS{Deque holds pairs $(\text{index}, \text{dp})$ with increasing indices and nondecreasing dp-values. Before computing position $j$, drop indices $< j-(d+1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize deque with $(1, \text{dp}[1]=1)$ for the bank.
\item For $j=2\ldots m$: pop from front while index $< j-(d+1)$; let $best$ be front dp. Set $\text{dp}[j]=c_j+best$.
\item Maintain monotonicity: pop from back while last dp $\ge \text{dp}[j]$, then push $(j,\text{dp}[j])$.
\item Row cost is $\text{dp}[m]$. Aggregate with a sliding window of size $k$ across rows.
\end{algosteps}
\COMPLEXITY{Per row $O(m)$, total $O(\sum m)$ across a test case; space $O(m)$ or $O(1)$ extra beyond the row.}
\[
\begin{aligned}
T(n,m) &= \Theta\!\Big(\sum_{i=1}^{n} m_i\Big),\quad S(m)=O(m).
\end{aligned}
\]
\CORRECTNESS{The deque always stores candidate predecessors within the allowed jump range, and in nondecreasing dp order the front is the minimum. Standard sliding-window minimum correctness applies; DP optimality follows by induction.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, io
from collections import deque
from typing import List, Tuple

def compute_row_cost_deque(row: List[int], d: int) -> int:
    m = len(row)
    c = [x + 1 for x in row]
    dp0 = c[0]  # equals 1
    dq = deque()
    dq.append((0, dp0))
    for j in range(1, m):
        limit = j - (d + 1)
        while dq and dq[0][0] < limit:
            dq.popleft()
        best = dq[0][1]
        cur = c[j] + best
        while dq and dq[-1][1] >= cur:
            dq.pop()
        dq.append((j, cur))
    return dq[-1][1]  # dp[m-1]

def solve_case(n: int, m: int, k: int, d: int, grid: List[List[int]]) -> int:
    costs = [compute_row_cost_deque(grid[i], d) for i in range(n)]
    window = sum(costs[:k])
    ans = window
    for i in range(k, n):
        window += costs[i] - costs[i - k]
        if window < ans:
            ans = window
    return ans

def read_input() -> List[Tuple[int, int, int, int, List[List[int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it)); d = int(next(it))
        grid = []
        for _ in range(n):
            row = [int(next(it)) for _ in range(m)]
            grid.append(row)
        cases.append((n, m, k, d, grid))
    return cases

def solve_all() -> None:
    out_lines = []
    for (n, m, k, d, grid) in read_input():
        out_lines.append(str(solve_case(n, m, k, d, grid)))
    sys.stdout.write("\n".join(out_lines))

def solve_io(s: str) -> str:
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    sys.stdin = io.StringIO(s)
    sys.stdout = io.StringIO()
    try:
        solve_all()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

def _tests_improved():
    # Same four tests as baseline
    data = "1\n3 3 1 1\n0 7 0\n0 0 0\n0 5 0\n"
    assert solve_io(data) == "2\n"
    data = "1\n1 4 1 0\n0 5 1 0\n"
    assert solve_io(data) == "10\n"
    data = "1\n1 5 1 1\n0 9 7 4 0\n"
    assert solve_io(data) == "10\n"
    data = "1\n3 3 2 0\n0 1 0\n0 2 0\n0 3 0\n"
    assert solve_io(data) == "9\n"

if __name__ == "__main__":
    _tests_improved()
\end{minted}
\VALIDATION{Improved code reuses the baseline tests; all four asserts pass, confirming correctness and parity.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Linear-time per row DP using a monotonic deque for the sliding minimum; window minimum over $k$ consecutive rows via a running sum.}
\ASSUMPTIONS{Valid for any $n,m,k,d$ within constraints, with $\sum n\cdot m \le 2\cdot 10^5$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each row, initialize deque with $(0,1)$ for column $1$.
\item For $j=2\ldots m$, drop stale indices $< j-(d+1)$; set $\text{dp}[j]=c_j+\text{front\_min}$; maintain deque monotonicity and push $(j,\text{dp}[j])$.
\item Record $\text{RowCost}=\text{dp}[m]$ and accumulate into a list.
\item Compute the minimum sum over any length-$k$ consecutive subsequence via a sliding window.
\end{algosteps}
\OPTIMALITY{The deque yields the exact minimum over the last $d{+}1$ states, so the DP matches the naive optimal recurrence. Since rows are independent, choosing the minimal-sum window over precomputed optimal row costs is globally optimal.}
\COMPLEXITY{Per row $O(m)$, total $O(\sum m)$ per test case; space $O(m)$ to store costs or $O(1)$ extra per row.}
\[
\begin{aligned}
T &= \Theta\!\Big(\sum_{i=1}^{n} m_i\Big),\quad S=O(m)+O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, io
from collections import deque
from typing import List, Tuple

def compute_row_cost(row: List[int], d: int) -> int:
    m = len(row)
    c = [x + 1 for x in row]
    dq = deque()
    dq.append((0, c[0]))  # dp[0] = 1
    for j in range(1, m):
        limit = j - (d + 1)
        while dq and dq[0][0] < limit:
            dq.popleft()
        best = dq[0][1]
        cur = c[j] + best
        while dq and dq[-1][1] >= cur:
            dq.pop()
        dq.append((j, cur))
    return dq[-1][1]

def solve_case(n: int, m: int, k: int, d: int, grid: List[List[int]]) -> int:
    costs = [compute_row_cost(grid[i], d) for i in range(n)]
    window = sum(costs[:k])
    ans = window
    for i in range(k, n):
        window += costs[i] - costs[i - k]
        if window < ans:
            ans = window
    return ans

def read_input() -> List[Tuple[int, int, int, int, List[List[int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it)); d = int(next(it))
        grid = []
        for _ in range(n):
            row = [int(next(it)) for _ in range(m)]
            grid.append(row)
        cases.append((n, m, k, d, grid))
    return cases

def solve_all() -> None:
    out_lines = []
    for (n, m, k, d, grid) in read_input():
        out_lines.append(str(solve_case(n, m, k, d, grid)))
    sys.stdout.write("\n".join(out_lines))

def solve_io(s: str) -> str:
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    sys.stdin = io.StringIO(s)
    sys.stdout = io.StringIO()
    try:
        solve_all()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

def _tests_final():
    data = "1\n3 3 1 1\n0 7 0\n0 0 0\n0 5 0\n"
    assert solve_io(data) == "2\n"
    data = "1\n1 4 1 0\n0 5 1 0\n"
    assert solve_io(data) == "10\n"
    data = "1\n1 5 1 1\n0 9 7 4 0\n"
    assert solve_io(data) == "10\n"

if __name__ == "__main__":
    _tests_final()
    # After tests, run the solver on stdin if input is provided.
    if not sys.stdin.isatty():
        # Rewind and process actual stdin
        sys.stdin.seek(0)
        solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts: banks-only case, contiguous supports case, and an interior-supports case.}
\RESULT{Outputs, for each test case, the minimal total cost across $k$ consecutive rows, with each row optimally spanned and including both bank supports.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: trivial banks-only rows; $d=0$ forcing a support at every column; moderate $m$ where an interior support is required; and window aggregation with $k>1$.}
\LINE{CROSS-CHECKS}{Baseline and improved solutions are cross-checked on the same inputs; identical outputs confirm correctness of optimization.}
\LINE{EDGE-CASE GENERATOR}{Deterministic generators can include: $d=0$ rows; $d\ge m-1$ rows; random rows with small $m$ to brute-force validate; monotone and valley-shaped cost profiles.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_row_all_banks(m: int) -> list:
    row = [0]*m
    return row

def gen_row_force_all(m: int) -> list:
    # d=0 forces placing at all columns; any nonnegative interior values suffice
    return [0] + [random.randint(0, 5) for _ in range(m-2)] + [0]

def gen_valley_row(m: int, peak: int = 9) -> list:
    # Cheaper middle to encourage 1->mid->m solutions
    mid = m//2
    row = [peak]*(m)
    row[0] = 0; row[-1] = 0
    row[mid] = 0
    return row
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque
from typing import List, Tuple

def compute_row_cost(row: List[int], d: int) -> int:
    m = len(row)
    c = [x + 1 for x in row]
    dq = deque()
    dq.append((0, c[0]))  # dp[0] = 1
    for j in range(1, m):
        limit = j - (d + 1)
        while dq and dq[0][0] < limit:
            dq.popleft()
        best = dq[0][1]
        cur = c[j] + best
        while dq and dq[-1][1] >= cur:
            dq.pop()
        dq.append((j, cur))
    return dq[-1][1]

def solve_case(n: int, m: int, k: int, d: int, grid: List[List[int]]) -> int:
    costs = [compute_row_cost(grid[i], d) for i in range(n)]
    window = sum(costs[:k])
    ans = window
    for i in range(k, n):
        window += costs[i] - costs[i - k]
        if window < ans:
            ans = window
    return ans

def read_input() -> List[Tuple[int, int, int, int, List[List[int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it)); d = int(next(it))
        grid = []
        for _ in range(n):
            row = [int(next(it)) for _ in range(m)]
            grid.append(row)
        cases.append((n, m, k, d, grid))
    return cases

def solve_all() -> None:
    out_lines = []
    for (n, m, k, d, grid) in read_input():
        out_lines.append(str(solve_case(n, m, k, d, grid)))
    sys.stdout.write("\n".join(out_lines))

def _tests():
    def solve_io(s: str) -> str:
        import io
        backup_stdin, backup_stdout = sys.stdin, sys.stdout
        sys.stdin = io.StringIO(s)
        sys.stdout = io.StringIO()
        try:
            solve_all()
            return sys.stdout.getvalue()
        finally:
            sys.stdin, sys.stdout = backup_stdin, backup_stdout
    data = "1\n3 3 1 1\n0 7 0\n0 0 0\n0 5 0\n"
    assert solve_io(data) == "2\n"
    data = "1\n1 4 1 0\n0 5 1 0\n"
    assert solve_io(data) == "10\n"
    data = "1\n1 5 1 1\n0 9 7 4 0\n"
    assert solve_io(data) == "10\n"

if __name__ == "__main__":
    _tests()
    # After tests, run on stdin
    if not sys.stdin.isatty():
        sys.stdin.seek(0)
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Per row, compute cheapest support placement with jumps up to $d{+}1$ using a sliding minimum DP; then take the minimum window sum over $k$ rows.}
\WHY{Combines classic sliding-window minimum with DP; typical for medium-hard interview or contest problems requiring both modeling and data-structure optimization.}
\CHECKLIST{
\begin{bullets}
\item Convert distance constraint to jump length $\le d+1$.
\item Include both banks in the cost (each contributes $1$).
\item DP base: $\text{dp}[1]=1$.
\item Maintain deque window of indices $[j-(d+1), j-1]$.
\item Update sliding window sum over $k$ rows.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $d=0$: supports at every column; answer equals sum over all $(a_{i,j}+1)$ per chosen rows.
\item $d\ge m-1$: only banks; each row cost $2$.
\item $k=1$ or $k=n$: window degenerates to min of singles or total sum.
\item Large $m$ with sparse small costs: ensure deque handles long ranges.
\item Rows with all zeros: each costs $2$ regardless of $d\ge 1$.
\item Mixed large and small $a_{i,j}$: verify deque monotonicity remains correct.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one: using $d$ instead of $d{+}1$ for jump length.
\item Forgetting to include bank costs in total.
\item Not evicting stale indices from the deque front.
\item Evicting from back incorrectly (must be while last.dp $\ge$ current).
\item Overflow in other languages if not using 64-bit integers.
\item Mishandling input sizes or exceeding time with naive $O(md)$.
\end{bullets}}
\FAILMODES{Naive $O(md)$ per row times large $m$ and $d$ will time out; the deque solution maintains $O(m)$ per row regardless of $d$. Incorrect windowing over rows will pick nonconsecutive rows, which is invalid.}
\ELI{Walk from the left bank to the right bank, stepping at most $d{+}1$ columns at a time and paying the cost where you step. Keep track of the cheapest way to get to each column using a running minimum over the last few options. Then add up the best $k$ consecutive rows.}
\NotePages{3}

\end{document}