% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Heaven Tour}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/187/E}}
\LINE{DIFFICULTY / RATING}{2900}
\STATEMENT{The story was not finished as PMP thought. God offered him one more chance to reincarnate and come back to life. But before he can come back, God told him that PMP should ask $n$ great men including prominent programmers about their life experiences.

The men are standing on a straight line. They are numbered $1$ through $n$ from left to right. The coordinate of the $i$-th man is $x_i$ ($x_i < x_{i + 1},~ i < n$). PMP should visit all these people one by one in arbitrary order. Each man should be visited exactly once. At the beginning of his tour, he starts at location of $s$-th man and asks him about his experiences.

Each time PMP wants to change his location, he should give a ticket to an angel and the angel carries him to his destination. Angels take PMP from one location, fly to his destination and put him down there. Nobody else is visited in this movement. Moving from $i$-th man to $j$-th man, takes $\lvert x_i - x_j\rvert$ time. PMP can get back to life as soon as he visits all men.

There are two types of angels: Some angels are going to the right and they only accept right tickets. Others are going to the left and they only accept left tickets. There are an unlimited number of angels of each type. PMP has $l$ left tickets and $n - 1 - l$ right tickets.

PMP wants to get back to life as soon as possible to be able to compete in this year's final instead of the final he missed last year. He wants to know the quickest way to visit all the men exactly once. He also needs to know the exact sequence of moves he should make.

Input:
The first line of input contains three space-separated integers $n$, $l$, $s$ ($2 \le n \le 10^5$, $0 \le l < n$, $1 \le s \le n$) — the number of people to visit, the number of left tickets PMP got, and initial location of PMP. Next line contains $n$ space-separated integers. The $i$-th integer in this line is $x_i$ ($0 \le x_1 < x_2 < \ldots < x_n \le 10^9$) — the location of $i$-th man.

Output:
If PMP cannot visit all men with the tickets he got print $-1$ in the only line of output. Otherwise, in the first line you should print the minimum time PMP can visit all men. In the second line you should print $n - 1$ integers that are the numbers of the men that PMP should visit in order in one optimal solution. If there are multiple answers, output any of them.

Please do not use the \%lld specifier to read or write $64$-bit integers in C++. It is preferred to use \texttt{cin}, \texttt{cout} streams or the \%I64d specifier.

Note:
Let us remind here, a great contestant of all times, who left us about a year ago. May Renat Mullakhanov rest in peace.}
\BREAKDOWN{We must find a permutation of $\{1,\ldots,n\}$ starting from $s$ that visits each exactly once, uses exactly $l$ moves to the left (destination index smaller than the source), and minimizes the sum of Euclidean distances on the line. Output the minimum total time and one optimal visiting order.}
\ELI{We stand on sorted points; at each step we may jump to any unvisited point left or right, but we have a fixed budget of left-vs-right moves; choose an order minimizing total travel distance while matching the exact count of left moves.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- $n$ (integer), $l$ (integer), $s$ (integer).
- Positions $x_1,\ldots,x_n$ in strictly increasing order.}
\OUTPUTS{Either:
- Print $-1$ if no permutation exists with exactly $l$ left moves, or
- First line: minimal total time (as an integer).
- Second line: $n-1$ integers, the sequence of indices visited after starting at $s$.}
\SAMPLES{Example 1:
- Input: $n=3$, $l=1$, $s=2$, $x=[0,10,20]$.
- Output: $30$ on first line; one valid order is $1~3$.

Example 2:
- Input: $n=2$, $l=0$, $s=1$, $x=[5,8]$.
- Output: $3$ on first line; order $2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let points lie on the real line with coordinates $x_1<\cdots<x_n$. We seek a permutation $\pi$ of $\{1,\ldots,n\}$ with $\pi_1=s$ that minimizes
\begin{BreakableEquation*}
\sum_{t=1}^{n-1} \lvert x_{\pi_{t+1}} - x_{\pi_t}\rvert
\end{BreakableEquation*}
subject to the constraint that the number of indices $t$ with $\pi_{t+1}<\pi_t$ equals exactly $l$.}
\varmapStart
\var{n}{number of men}
\var{l}{exact number of left moves required}
\var{s}{starting index}
\var{x_i}{coordinate of the $i$-th man; strictly increasing}
\var{\pi}{visiting order, $\pi_1=s$}
\var{L,R}{current visited interval endpoints in index space}
\var{t}{count of left moves used so far}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Minimize}\quad & \sum_{t=1}^{n-1} \lvert x_{\pi_{t+1}} - x_{\pi_t}\rvert \\
\text{Subject to}\quad & \pi \text{ is a permutation with } \pi_1=s,\\
& \#\{t: \pi_{t+1} < \pi_t\} = l.
\end{aligned}
\]
}
\ASSUMPTIONS{Coordinates are integers but only order matters for direction; movement cost is additive and nonnegative.}
\INVARIANTS{
- In an optimal solution, after $k$ steps, the set of visited indices forms a contiguous interval $[L..R]$ in index space; you always jump to the current leftmost or rightmost unvisited index.
- Every move either extends to $L-1$ (a left move) or $R+1$ (a right move).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Dynamic programming on intervals: states represent the visited contiguous block $[i..j]$, whether we stand at $i$ or $j$, and how many left moves we have used so far.}
\ASSUMPTIONS{We only transition to the current leftmost or rightmost unvisited point; this covers all optimal solutions for line metrics.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize DP at $[s..s]$ with cost $0$ and $t=0$ left moves used.
\item For each interval length $\ell$ from $1$ to $n-1$, relax transitions to $(i-1,j)$ by moving left and to $(i,j+1)$ by moving right, updating the left-move counter $t$ accordingly.
\item Keep predecessor pointers to reconstruct the visiting order.
\item Among final states $(1,n)$ with exactly $t=l$, take the minimum-cost solution.
\end{algosteps}
\COMPLEXITY{Let states be $(i,j,\text{side},t)$. In the worst case the number of states is $O(n^3)$; each state has $O(1)$ transitions. Time $O(n^3)$, space $O(n^3)$ in the naive map; with rolling layers we cut working memory to $O(n^2)$ plus predecessor map.}
\[
\begin{aligned}
T(n) &= O(n^3), \\
S(n) &= O(n^2) \text{ (rolling layers) } \text{ to } O(n^3) \text{ (full table)}.
\end{aligned}
\]
\CORRECTNESS{By the line metric exchange argument, an optimal tour always visits extremes of the remaining unvisited set. The DP enumerates all such extreme-only tours with exact left-move counts, hence finds the optimum if one exists.}
\EDGECASES{Single step ($n=2$); $s=1$ or $s=n$; $l=0$ or $l=n-1$; large coordinate gaps.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 187E "Heaven Tour" (baseline DP over intervals with left-move count)
# API: read_input(), solve_case(), solve_all(), main() + asserts

from typing import List, Tuple, Optional, Dict
import sys

State = Tuple[int, int, int, int]  # (i, j, side, t_left)
# side = 0 means at i, side = 1 means at j

def read_input() -> Tuple[int, int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0, []
    it = iter(data)
    n = int(next(it))
    l = int(next(it))
    s = int(next(it))
    xs = [0] + [int(next(it)) for _ in range(n)]
    return n, l, s, xs

def solve_case(n: int, l: int, s: int, xs: List[int]) -> Optional[Tuple[int, List[int]]]:
    if n == 0:
        return None
    # DP by interval length
    INF = 10**30
    # dp_curr and dp_next: dict from State to cost
    dp_curr: Dict[State, int] = {}
    pred: Dict[State, Tuple[State, int]] = {}  # state -> (prev_state, moved_to_index)
    # initialize at [s..s]
    base0 = (s, s, 0, 0)
    base1 = (s, s, 1, 0)
    dp_curr[base0] = 0
    dp_curr[base1] = 0
    # We allow both sides at start; keep no predecessor for bases

    for length in range(1, n):  # we will expand until interval size becomes length+1
        dp_next: Dict[State, int] = {}
        next_pred: Dict[State, Tuple[State, int]] = {}
        for (i, j, side, t_left), cost in dp_curr.items():
            cur_idx = i if side == 0 else j
            # move to left extreme i-1 if exists
            if i > 1:
                ni, nj, nside = i - 1, j, 0
                nt = t_left + 1  # moving to smaller index => left move
                nd = cost + (xs[cur_idx] - xs[ni])
                st = (ni, nj, nside, nt)
                if nd < dp_next.get(st, INF):
                    dp_next[st] = nd
                    next_pred[st] = ((i, j, side, t_left), ni)
            # move to right extreme j+1 if exists
            if j < n:
                ni, nj, nside = i, j + 1, 1
                nt = t_left  # moving to larger index => right move
                nd = cost + (xs[nj] - xs[cur_idx])
                st = (ni, nj, nside, nt)
                if nd < dp_next.get(st, INF):
                    dp_next[st] = nd
                    next_pred[st] = ((i, j, side, t_left), nj)
        dp_curr = dp_next
        # merge new predecessors
        pred.update(next_pred)

    # Among final states (1, n, side, l), take min over side
    best_cost = INF
    best_state: Optional[State] = None
    for side in (0, 1):
        st = (1, n, side, l)
        if st in dp_curr and dp_curr[st] < best_cost:
            best_cost = dp_curr[st]
            best_state = st

    if best_state is None or best_cost >= INF:
        return None

    # Reconstruct moves (n-1 moves)
    order_rev: List[int] = []
    st = best_state
    # We expanded exactly n-1 times; backtrack until we reach one of the base states
    for _ in range(n - 1):
        prev = pred.get(st)
        if prev is None:
            # Should not happen if DP constructed correctly
            return None
        pst, moved_to = prev
        order_rev.append(moved_to)
        st = pst
    order_rev.reverse()
    return best_cost, order_rev

def solve_all() -> None:
    n, l, s, xs = read_input()
    if n == 0:
        return
    ans = solve_case(n, l, s, xs)
    out_lines: List[str] = []
    if ans is None:
        out_lines.append("-1")
    else:
        cost, order = ans
        out_lines.append(str(cost))
        out_lines.append(" ".join(map(str, order)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Tiny unit tests (do not print during CF run)
    def run_test(n, l, s, xs, expect_cost=None, expect_len=None):
        res = solve_case(n, l, s, [0]+xs)
        if res is None:
            assert expect_cost is None, "Expected a solution"
            return
        cost, order = res
        if expect_cost is not None:
            assert cost == expect_cost, (cost, expect_cost)
        if expect_len is not None:
            assert len(order) == expect_len
        # Validate left moves count
        left_moves = sum(1 for i in range(len(order)) if (order[i] < (s if i == 0 else order[i-1])))
        assert left_moves == l, (left_moves, l)
        # Validate uniqueness and start
        seen = set([s])
        prev = s
        for v in order:
            assert 1 <= v <= n and v not in seen
            seen.add(v)
            prev = v
        assert len(seen) == n

    # 1) Simple three points
    run_test(3, 1, 2, [0, 10, 20], expect_cost=30, expect_len=2)
    # 2) Two points start at left end with 0 left moves
    run_test(2, 0, 1, [5, 8], expect_cost=3, expect_len=1)
    # 3) Four points with big gap; minimal cost known 102 for s=2, l=1
    res = solve_case(4, 1, 2, [0, 1, 100, 101])
    assert res is not None and res[0] == 102
    solve_all()
\end{minted}
\VALIDATION{Included asserts check:
- Minimal example correctness and left-move counting.
- Edge case $n=2$.
- Case with widely separated clusters that stresses choosing extremes.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized DP with Rolling Layers}
\WHICHFORMULA{We keep only the current and next layer by interval length, dramatically reducing memory, and we store compact predecessor pointers for reconstruction.}
\ASSUMPTIONS{Optimal tours on a line always expand the visited contiguous block by one element at each step; transitions are only to current extremes.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a map for states of a fixed interval length and produce the next length by two transitions per state.
\item Store only better costs for each state and track the immediate predecessor to enable backtracking.
\item At the end, choose the best final state with exact $l$ left moves and reconstruct the order.}
\item Complexity remains $O(n^3)$ in the worst case but with much smaller working RAM; practical for small to medium $n$. 
\end{algosteps}
\COMPLEXITY{Same asymptotic time as baseline; memory reduced to $O(n^2)$ plus a predecessor map updated once per state.}
\[
\begin{aligned}
T(n) &= O(n^3) \\
S(n) &= O(n^2).
\end{aligned}
\]
\CORRECTNESS{Identical state space and transitions to the baseline ensure the same optimality guarantees.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; uses rolling layers and predecessors

from typing import List, Tuple, Optional, Dict
import sys

State = Tuple[int, int, int, int]  # (i, j, side, t_left)

def read_input() -> Tuple[int, int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0, []
    it = iter(data)
    n = int(next(it)); l = int(next(it)); s = int(next(it))
    xs = [0] + [int(next(it)) for _ in range(n)]
    return n, l, s, xs

def solve_case(n: int, l: int, s: int, xs: List[int]) -> Optional[Tuple[int, List[int]]]:
    if n <= 0:
        return None
    INF = 10**30
    dp_curr: Dict[State, int] = {(s, s, 0, 0): 0, (s, s, 1, 0): 0}
    pred: Dict[State, Tuple[State, int]] = {}
    for _len in range(1, n):
        dp_next: Dict[State, int] = {}
        next_pred: Dict[State, Tuple[State, int]] = {}
        for (i, j, side, t_left), cost in dp_curr.items():
            cur = i if side == 0 else j
            # expand left
            if i > 1:
                ni, nj, nside, nt = i - 1, j, 0, t_left + 1
                nd = cost + (xs[cur] - xs[ni])
                st = (ni, nj, nside, nt)
                if nd < dp_next.get(st, INF):
                    dp_next[st] = nd
                    next_pred[st] = ((i, j, side, t_left), ni)
            # expand right
            if j < n:
                ni, nj, nside, nt = i, j + 1, 1, t_left
                nd = cost + (xs[nj] - xs[cur])
                st = (ni, nj, nside, nt)
                if nd < dp_next.get(st, INF):
                    dp_next[st] = nd
                    next_pred[st] = ((i, j, side, t_left), nj)
        dp_curr = dp_next
        pred.update(next_pred)

    INF = 10**30
    best_state = None
    best_cost = INF
    for side in (0, 1):
        st = (1, n, side, l)
        if st in dp_curr and dp_curr[st] < best_cost:
            best_cost = dp_curr[st]; best_state = st
    if best_state is None:
        return None

    # Reconstruct
    order_rev: List[int] = []
    st = best_state
    for _ in range(n - 1):
        pst, move_to = pred[st]
        order_rev.append(move_to)
        st = pst
    order_rev.reverse()
    return best_cost, order_rev

def solve_all() -> None:
    n, l, s, xs = read_input()
    if n == 0:
        return
    ans = solve_case(n, l, s, xs)
    if ans is None:
        print(-1)
    else:
        cost, order = ans
        print(cost)
        print(" ".join(map(str, order)))

if __name__ == "__main__":
    # Checks
    res = solve_case(3, 1, 2, [0, 10, 20])
    assert res is not None and res[0] == 30 and len(res[1]) == 2
    res = solve_case(2, 0, 1, [5, 8])
    assert res is not None and res[0] == 3 and res[1] == [2]
    res = solve_case(4, 1, 2, [0, 1, 100, 101])
    assert res is not None and res[0] == 102
    solve_all()
\end{minted}
\VALIDATION{Edge inputs validated: minimal $n$, clustered coordinates, and left-move counting against $l$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Interval DP with Exact Left-Move Accounting}
\WHICHFORMULA{Use the extremes-only DP with rolling layers and predecessor reconstruction. This method is exact; on real CF constraints it would need advanced pruning or greedy-with-feasibility.}
\ASSUMPTIONS{Line metric; optimal tours visit extremes; exact left moves enforced by state dimension $t$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize at $[s..s]$ with both sides allowed.
\item For each interval length, relax moving to the left or right extreme, updating distance and left-move counter.
\item Choose the best final state with $t=l$ and reconstruct the path from predecessors.
\end{algosteps}
\OPTIMALITY{Among extreme-only tours, this DP explores all possibilities and selects the minimal total distance satisfying the exact left-move count; by the exchange argument on the line, no non-extreme jump yields a better solution.}
\COMPLEXITY{Time $O(n^3)$, space $O(n^2)$ rolling plus predecessor pointers.}
\[
\begin{aligned}
T(n) &= O(n^3).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# Final reference: exact DP over intervals with left-move count and path reconstruction.

from typing import List, Tuple, Optional, Dict
import sys

State = Tuple[int, int, int, int]  # (i, j, side, t_left)

def read_input() -> Tuple[int, int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0, []
    it = iter(data)
    n = int(next(it)); l = int(next(it)); s = int(next(it))
    xs = [0] + [int(next(it)) for _ in range(n)]
    return n, l, s, xs

def solve_case(n: int, l: int, s: int, xs: List[int]) -> Optional[Tuple[int, List[int]]]:
    if n <= 0:
        return None
    INF = 10**30
    dp_curr: Dict[State, int] = {(s, s, 0, 0): 0, (s, s, 1, 0): 0}
    pred: Dict[State, Tuple[State, int]] = {}
    for _len in range(1, n):
        dp_next: Dict[State, int] = {}
        next_pred: Dict[State, Tuple[State, int]] = {}
        for (i, j, side, t_left), cost in dp_curr.items():
            cur = i if side == 0 else j
            # expand to left extreme
            if i > 1:
                ni, nj, nside, nt = i - 1, j, 0, t_left + 1
                nd = cost + (xs[cur] - xs[ni])
                st = (ni, nj, nside, nt)
                if nd < dp_next.get(st, INF):
                    dp_next[st] = nd
                    next_pred[st] = ((i, j, side, t_left), ni)
            # expand to right extreme
            if j < n:
                ni, nj, nside, nt = i, j + 1, 1, t_left
                nd = cost + (xs[nj] - xs[cur])
                st = (ni, nj, nside, nt)
                if nd < dp_next.get(st, INF):
                    dp_next[st] = nd
                    next_pred[st] = ((i, j, side, t_left), nj)
        dp_curr = dp_next
        pred.update(next_pred)

    INF = 10**30
    best_state = None
    best_cost = INF
    for side in (0, 1):
        st = (1, n, side, l)
        if st in dp_curr and dp_curr[st] < best_cost:
            best_cost = dp_curr[st]
            best_state = st
    if best_state is None:
        return None

    # reconstruct the order
    order_rev: List[int] = []
    st = best_state
    for _ in range(n - 1):
        pst, move_to = pred[st]
        order_rev.append(move_to)
        st = pst
    order_rev.reverse()
    return best_cost, order_rev

def solve_all() -> None:
    n, l, s, xs = read_input()
    if n == 0:
        return
    res = solve_case(n, l, s, xs)
    if res is None:
        print(-1)
    else:
        cost, order = res
        print(cost)
        print(" ".join(map(str, order)))

if __name__ == "__main__":
    # Exactly 3 asserts or I/O mini-tests
    r = solve_case(3, 1, 2, [0, 10, 20]); assert r is not None and r[0] == 30
    r = solve_case(2, 0, 1, [5, 8]); assert r is not None and r[0] == 3 and r[1] == [2]
    r = solve_case(4, 1, 2, [0, 1, 100, 101]); assert r is not None and r[0] == 102
    solve_all()
\end{minted}
\VALIDATION{Three asserts verifying costs and orders on small crafted cases.}
\RESULT{If feasible, we output the exact minimum travel time and one visiting order that uses exactly $l$ left moves; otherwise, print $-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny arrays, random small instances comparing to a slower verifier, and cases with extreme gaps to ensure the DP chooses extremes correctly.}
\LINE{CROSS-CHECKS}{Compare solutions with different $l$ on the same coordinates; ensure the left-move count computed from the output order matches $l$.}
\LINE{EDGE-CASE GENERATOR}{Generate $x_i$ as arithmetic progressions and as two distant clusters to stress jump decisions.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_arith(n: int, start: int = 0, step: int = 1) -> List[int]:
    return [start + i * step for i in range(n)]

def gen_clusters(n_left: int, n_right: int, gap: int = 10**6) -> List[int]:
    left = [i for i in range(n_left)]
    right = [gap + i for i in range(n_right)]
    return left + right

def count_left_moves(order: List[int], s: int) -> int:
    prev = s; cnt = 0
    for v in order:
        if v < prev: cnt += 1
        prev = v
    return cnt

def brute_verify(n: int, l: int, s: int, xs: List[int]) -> Tuple[int, List[int]]:
    # Simple brute on very small n: try all permutations that start at s.
    import itertools
    best = None
    indices = list(range(1, n+1))
    for perm in itertools.permutations([i for i in indices if i != s]):
        seq = list(perm)
        # compute left moves
        prev = s
        lm = 0
        cost = 0
        ok = True
        for v in seq:
            cost += abs(xs[prev] - xs[v])
            if v < prev: lm += 1
            prev = v
        if lm != l: 
            continue
        if best is None or cost < best[0]:
            best = (cost, seq)
    return best if best is not None else (-1, [])

# Quick self-check (small only)
if __name__ == "__main__":
    xs = [0] + gen_arith(4, 0, 1)
    from collections import defaultdict
    # nothing printed; intended for offline experimentation
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution (same as Approach C). Single-case CF format.

from typing import List, Tuple, Optional, Dict
import sys

State = Tuple[int, int, int, int]  # (i, j, side, t_left)

def read_input() -> Tuple[int, int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0, []
    it = iter(data)
    n = int(next(it)); l = int(next(it)); s = int(next(it))
    xs = [0] + [int(next(it)) for _ in range(n)]
    return n, l, s, xs

def solve_case(n: int, l: int, s: int, xs: List[int]) -> Optional[Tuple[int, List[int]]]:
    if n <= 0:
        return None
    INF = 10**30
    dp_curr: Dict[State, int] = {(s, s, 0, 0): 0, (s, s, 1, 0): 0}
    pred: Dict[State, Tuple[State, int]] = {}
    for _len in range(1, n):
        dp_next: Dict[State, int] = {}
        next_pred: Dict[State, Tuple[State, int]] = {}
        for (i, j, side, t_left), cost in dp_curr.items():
            cur = i if side == 0 else j
            if i > 1:
                ni, nj, nside, nt = i - 1, j, 0, t_left + 1
                nd = cost + (xs[cur] - xs[ni])
                st = (ni, nj, nside, nt)
                if nd < dp_next.get(st, INF):
                    dp_next[st] = nd
                    next_pred[st] = ((i, j, side, t_left), ni)
            if j < n:
                ni, nj, nside, nt = i, j + 1, 1, t_left
                nd = cost + (xs[nj] - xs[cur])
                st = (ni, nj, nside, nt)
                if nd < dp_next.get(st, INF):
                    dp_next[st] = nd
                    next_pred[st] = ((i, j, side, t_left), nj)
        dp_curr = dp_next
        pred.update(next_pred)

    best_state = None
    best_cost = 10**30
    for side in (0, 1):
        st = (1, n, side, l)
        if st in dp_curr and dp_curr[st] < best_cost:
            best_cost = dp_curr[st]
            best_state = st
    if best_state is None:
        return None

    order_rev: List[int] = []
    st = best_state
    for _ in range(n - 1):
        pst, move_to = pred[st]
        order_rev.append(move_to)
        st = pst
    order_rev.reverse()
    return best_cost, order_rev

def solve_all() -> None:
    n, l, s, xs = read_input()
    if n == 0:
        return
    res = solve_case(n, l, s, xs)
    if res is None:
        print(-1)
    else:
        cost, order = res
        print(cost)
        print(" ".join(map(str, order)))

if __name__ == "__main__":
    # Sanity asserts for tiny inputs
    r = solve_case(3, 1, 2, [0, 10, 20]); assert r is not None and r[0] == 30
    r = solve_case(2, 0, 1, [5, 8]); assert r is not None and r[0] == 3 and r[1] == [2]
    r = solve_case(4, 1, 2, [0, 1, 100, 101]); assert r is not None and r[0] == 102
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{DP over contiguous intervals with a left-move counter finds the optimal sequence consistent with ticket constraints.}
\WHY{This pattern appears when cost is metric on a line and constraints concern only the direction of steps; interviews test interval-DP modeling and path reconstruction.}
\CHECKLIST{
- Sort and index positions; keep $x_i$ as given since input is already sorted.
- Model visited set as contiguous interval $[i..j]$ in index space.
- State includes which end we stand on and the number of left moves used.
- Transition only to current extremes; update cost and left counter.
- Select final state with $t=l$; reconstruct order.}
\EDGECASES{
- $n=2$ minimal case.
- $s=1$ or $s=n$ (all moves go in one direction, except one big jump if needed).
- $l=0$ or $l=n-1$.
- Large coordinate gaps to ensure correct distance accumulation.
- Duplicate checks: ensure visiting exactly once, no revisits.
- Infeasible $l$ leading to output $-1$.}
\PITFALLS{
- Forgetting that moving from the right end to the left extreme is a left move regardless of distance.
- Miscomputing distances: always use coordinates of the current endpoint to target extreme.
- Not initializing both side-states at $[s..s]$; missing optimal paths.
- Dropping predecessor updates when improving a state's cost.
- Memory blow-up if keeping full $O(n^3)$ tables; use rolling layers.}
\FAILMODES{Greedy without feasibility can mismatch the required left-move count. Pure bitonic sweeps that revisit interior points are invalid because intermediate nodes are not visited when passed. The DP formulation avoids both pitfalls.}
\ELI{Stand at one of the two edges of the already-visited block. At each step, you may grab the next person on the far left or far right. Keep track of how many times you move to the left. Try all such choices with DP and take the cheapest one that uses exactly the number of left tickets you have.}
\NotePages{3}

\end{document}