% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Greatest Common Divisor Traversal}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/greatest-common-divisor-traversal/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a 0-indexed integer array \texttt{nums}, and you are allowed to traverse between its indices. You can traverse between index $i$ and index $j$ with $i \ne j$ if and only if $\gcd(\texttt{nums}[i], \texttt{nums}[j]) > 1$, where $\gcd$ is the greatest common divisor.

Your task is to determine if for every pair of indices $i$ and $j$ in \texttt{nums}, where $i < j$, there exists a sequence of traversals that can take us from $i$ to $j$.

Return \texttt{true} if it is possible to traverse between all such pairs of indices, or \texttt{false} otherwise.

Examples:
\begin{bullets}
\item Input: \texttt{nums = [2, 3, 6]}. Output: \texttt{true}. Explanation: $(0,1)$ via $0 \to 2 \to 1$ since $\gcd(2,6)=2>1$ and $\gcd(6,3)=3>1$; $(0,2)$ direct, $(1,2)$ direct.
\item Input: \texttt{nums = [3, 9, 5]}. Output: \texttt{false}. Explanation: cannot connect $0$ to $2$.
\item Input: \texttt{nums = [4, 3, 12, 8]}. Output: \texttt{true}. A valid traversal exists for every pair.
\end{bullets}

Constraints: $1 \le \texttt{nums.length} \le 10^5$, and $1 \le \texttt{nums}[i] \le 10^5$.}
\BREAKDOWN{Model indices as vertices of a graph with an edge between $i$ and $j$ if $\gcd(\texttt{nums}[i], \texttt{nums}[j])>1$. The question is whether this graph is connected. Use prime factorization to avoid $O(n^2)$ edge checks.}
\ELI{Connect indices that share at least one prime factor; the array is traversable iff all indices belong to a single connected component.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{On LeetCode, a single list \texttt{nums} of integers with $1 \le \lvert\texttt{nums}\rvert \le 10^5$ and $1 \le \texttt{nums}[i] \le 10^5$.}
\OUTPUTS{Return a boolean \texttt{True}/\texttt{False}: whether every pair of indices can be connected via steps that only move between indices whose values have $\gcd>1$.}
\SAMPLES{
\begin{bullets}
\item \texttt{[2, 3, 6]} $\to$ \texttt{True}
\item \texttt{[3, 9, 5]} $\to$ \texttt{False}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{0,\ldots,n-1\}$ index \texttt{nums}. Define an undirected graph $G=(V,E)$ with $(i,j)\in E$ iff $\gcd(\texttt{nums}[i],\texttt{nums}[j])>1$. Decide if $G$ is connected.}
\varmapStart
\var{n}{array length $\lvert\texttt{nums}\rvert$}
\var{\texttt{nums}[i]}{value at index $i$}
\var{P(x)}{set of distinct prime factors of $x$}
\var{\text{spf}}{smallest prime factor array up to $\max(\texttt{nums})$}
\var{U}{disjoint-set union (union-find) structure over vertices}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Connected}(G) \iff \forall i,j\in V,~\exists\text{ path } i=v_0\sim v_1\sim\cdots\sim v_k=j \text{ with } \gcd(\texttt{nums}[v_t],\texttt{nums}[v_{t+1]})>1.
\end{BreakableEquation*}
Equivalently, if we connect all indices sharing a common prime $p$, then $G$ is connected iff all indices lie in one DSU set.
}
\ASSUMPTIONS{If $n=1$ the answer is \texttt{True}. If any value equals $1$ and $n>1$, the answer is \texttt{False} since $\gcd(1,x)=1$ for all $x$. Factorization uses $\text{spf}$ in $O(\log \text{maxA})$ per number after an $O(\text{maxA}\log\log \text{maxA})$ sieve.}
\INVARIANTS{
\begin{bullets}
\item Union-by-prime invariant: all indices whose values share a prime $p$ are in the same DSU component.
\item Connectivity invariant: BFS/DSU processes never split components; unions only merge components.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Build the explicit graph by testing every pair $(i,j)$ and add edge if $\gcd(\texttt{nums}[i],\texttt{nums}[j])>1$. Then run one BFS/DFS from $0$ and check whether all $n$ vertices are visited.}
\ASSUMPTIONS{Use $\gcd$ in $O(\log \text{maxA})$ time per pair. Early exits: if $n=1$ return \texttt{True}; if any value is $1$ and $n>1$, return \texttt{False}.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Handle edge cases: $n=1 \Rightarrow \texttt{True}$; if any $\texttt{nums}[i]=1$ and $n>1 \Rightarrow \texttt{False}$.
\item For all pairs $0\le i<j<n$, add an undirected edge if $\gcd(\texttt{nums}[i],\texttt{nums}[j])>1$.
\item BFS from $0$ over the built adjacency; return whether visit count equals $n$.
\end{algosteps}
\COMPLEXITY{For $n$ elements, we check $\binom{n}{2}$ pairs. Each $\gcd$ is $O(\log \text{maxA})$. Building adjacency is $O(n^2\log \text{maxA})$ and BFS is $O(n^2)$.}
\[
\begin{aligned}
T(n) &\in \Theta\!\big(n^2 \log \text{maxA}\big) \\
S(n) &\in \Theta(n^2) \text{ in the worst case (dense graph).}
\end{aligned}
\]
\CORRECTNESS{Edges match the problem predicate exactly; connectivity of the undirected graph is necessary and sufficient for universal traversability.}
\EDGECASES{Single element; presence of any $1$ with $n>1$; all pairwise coprime primes; repeated equal numbers; large identical numbers forming a clique.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
from math import gcd
from collections import deque

class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 1:
            return True
        # If any value is 1 (and n>1), cannot connect it to others.
        if any(x == 1 for x in nums):
            return False
        # Build explicit graph by pairwise gcd>1
        adj = [[] for _ in range(n)]
        for i in range(n):
            for j in range(i + 1, n):
                if gcd(nums[i], nums[j]) > 1:
                    adj[i].append(j)
                    adj[j].append(i)
        # BFS/DFS from node 0
        q = deque([0])
        vis = [False] * n
        vis[0] = True
        count = 1
        while q:
            u = q.popleft()
            for v in adj[u]:
                if not vis[v]:
                    vis[v] = True
                    count += 1
                    q.append(v)
        return count == n

# Tiny self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.canTraverseAllPairs([2, 3, 6]) is True
    assert s.canTraverseAllPairs([3, 9, 5]) is False
    assert s.canTraverseAllPairs([4, 3, 12, 8]) is True
\end{minted}
\VALIDATION{Baseline passes the provided examples and trivially handles $n=1$ and presence of $1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Graph Traversal via Prime Buckets}
\WHICHFORMULA{Avoid $O(n^2)$ pairs by factoring each number and using prime buckets. BFS from $0$, and when visiting an index with prime factor $p$, enqueue all indices in the bucket of $p$ exactly once.}
\ASSUMPTIONS{Precompute smallest-prime-factor (SPF) up to $M=\max(\texttt{nums})$. For each number, extract its distinct primes in $O(\log M)$. Maintain a boolean \texttt{usedPrime[p]} to expand each prime bucket at most once.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Edge cases: if $n=1$ return \texttt{True}. If any value is $1$ and $n>1$, return \texttt{False}.
\item Build SPF up to $M=\max(\texttt{nums})$.
\item For each index $i$, factor $\texttt{nums}[i]$ into distinct primes $P_i$ using SPF; append $i$ to \texttt{bucket[p]} for $p\in P_i$.
\item BFS from $0$. When popping $i$, for each $p\in P_i$ not yet \texttt{usedPrime[p]}, enqueue all indices in \texttt{bucket[p]} and mark \texttt{usedPrime[p]}.
\item Return \texttt{True} iff all $n$ indices are visited.
\end{algosteps}
\COMPLEXITY{Each index is enqueued at most once; each prime bucket is expanded once. Factorization is near-linear overall.}
\[
\begin{aligned}
T(n) &\in O\!\big(M\log\log M + \sum_{i=1}^n \log M + n + \sum_p \lvert\text{bucket}[p]\rvert\big)
      \subseteq O\!\big(M\log\log M + n\log M\big), \\
S(n) &\in O(M + n).
\end{aligned}
\]
\CORRECTNESS{Two indices connect iff there exists a chain of shared primes. Expanding each prime bucket once simulates edges induced by shared primes without missing any path while preventing quadratic repetition.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from collections import deque, defaultdict

class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 1:
            return True
        if any(x == 1 for x in nums):
            return False

        M = max(nums)
        # SPF sieve
        spf = list(range(M + 1))
        for i in range(2, int(M**0.5) + 1):
            if spf[i] == i:
                step = i
                start = i * i
                for j in range(start, M + 1, step):
                    if spf[j] == j:
                        spf[j] = i

        def distinct_primes(x: int) -> List[int]:
            res = []
            last = 0
            while x > 1:
                p = spf[x]
                if p != last:
                    res.append(p)
                    last = p
                x //= p
            return res

        # Build prime buckets
        bucket = defaultdict(list)
        primes_of = []
        for i, x in enumerate(nums):
            ps = distinct_primes(x)
            primes_of.append(ps)
            for p in ps:
                bucket[p].append(i)

        usedPrime = set()
        vis = [False] * n
        q = deque([0])
        vis[0] = True
        seen = 1

        while q:
            u = q.popleft()
            for p in primes_of[u]:
                if p in usedPrime:
                    continue
                usedPrime.add(p)
                for v in bucket[p]:
                    if not vis[v]:
                        vis[v] = True
                        seen += 1
                        q.append(v)
        return seen == n

# Self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.canTraverseAllPairs([2, 3, 6]) is True
    assert s.canTraverseAllPairs([3, 9, 5]) is False
    assert s.canTraverseAllPairs([4, 3, 12, 8]) is True
    assert s.canTraverseAllPairs([1]) is True
    assert s.canTraverseAllPairs([1, 2]) is False
\end{minted}
\VALIDATION{Covers samples and edge cases: single element, presence of $1$, and general cases with chained connectivity.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{DSU via Shared Prime Factors}
\WHICHFORMULA{Use union-find (DSU). For each prime $p$, union all indices whose values contain $p$. Finally, check if all indices share the same representative.}
\ASSUMPTIONS{SPF sieve enables $O(\log M)$ factorization per number; union-find with path compression and union by size/rank yields near-linear time. If any value is $1$ (and $n>1$), return \texttt{False}.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Handle $n=1 \Rightarrow \texttt{True}$; any $1$ with $n>1 \Rightarrow \texttt{False}$.
\item Build SPF up to $M=\max(\texttt{nums})$.
\item For each index $i$, compute distinct primes $P_i$.
\item Maintain a map \texttt{leader[p]} of prime to first index seen; for each $p\in P_i$, if unseen set \texttt{leader[p]}$=i$, else union $(i,\texttt{leader[p]})$.
\item Return whether all indices have the same DSU root as index $0$.
\end{algosteps}
\OPTIMALITY{Every valid traversal path factors through shared primes, and the DSU unions exactly capture the transitive closure of “shares a prime”. Any algorithm must examine enough information to distinguish prime-sharing structure; with SPF precomputed, DSU attains near-linear time and is standard-optimal for this connectivity task.}
\COMPLEXITY{Sieve $O(M\log\log M)$; factorization $O(n\log M)$; unions/finds are amortized inverse-Ackermann.}
\[
\begin{aligned}
T(n) &\in O\!\big(M\log\log M + n\log M + n\,\alpha(n)\big), \\
S(n) &\in O(M + n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 1:
            return True
        if any(x == 1 for x in nums):
            return False

        M = max(nums)
        # SPF sieve
        spf = list(range(M + 1))
        for i in range(2, int(M**0.5) + 1):
            if spf[i] == i:
                step = i
                start = i * i
                for j in range(start, M + 1, step):
                    if spf[j] == j:
                        spf[j] = i

        def distinct_primes(x: int):
            res = []
            last = 0
            while x > 1:
                p = spf[x]
                if p != last:
                    res.append(p)
                    last = p
                x //= p
            return res

        # DSU
        parent = list(range(n))
        size = [1] * n

        def find(a: int) -> int:
            while parent[a] != a:
                parent[a] = parent[parent[a]]
                a = parent[a]
            return a

        def union(a: int, b: int) -> None:
            ra, rb = find(a), find(b)
            if ra == rb:
                return
            if size[ra] < size[rb]:
                ra, rb = rb, ra
            parent[rb] = ra
            size[ra] += size[rb]

        leader = {}
        for i, x in enumerate(nums):
            for p in distinct_primes(x):
                if p not in leader:
                    leader[p] = i
                else:
                    union(i, leader[p])

        root0 = find(0)
        for i in range(1, n):
            if find(i) != root0:
                return False
        return True

# Exactly 3 asserts
if __name__ == "__main__":
    s = Solution()
    assert s.canTraverseAllPairs([2, 3, 6]) is True
    assert s.canTraverseAllPairs([3, 9, 5]) is False
    assert s.canTraverseAllPairs([4, 3, 12, 8]) is True
\end{minted}
\VALIDATION{Three asserts match the samples.}
\RESULT{Return \texttt{True} iff all indices belong to the same DSU component formed by shared-prime unions; otherwise \texttt{False}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on samples; edge cases with $n=1$; arrays containing $1$; arrays of pairwise coprime primes; chains connected via shared primes; large identical values.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (brute) vs. B/C on small random inputs ($n\le 40$) to ensure agreement.}
\LINE{EDGE-CASE GENERATOR}{Produce random arrays over small primes, include $1$s, and purely prime arrays to stress connectivity boundaries.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_ones(n: int) -> List[int]:
    return [1] * n

def gen_all_same(n: int, x: int) -> List[int]:
    return [x] * n

def gen_pairwise_primes(n: int, start_prime: int = 2) -> List[int]:
    # simple list of first n primes (deterministic small sieve)
    limit = 1000
    sieve = [True] * (limit + 1)
    primes = []
    for i in range(2, limit + 1):
        if sieve[i]:
            primes.append(i)
            for j in range(i * i, limit + 1, i):
                sieve[j] = False
        if len(primes) >= n:
            break
    return primes[:n]

def gen_chained(n: int) -> List[int]:
    # Make a chain: numbers share a prime with the next
    # e.g., 6=2*3, 10=2*5, 15=3*5, 14=2*7, 21=3*7, ...
    vals = [6, 10, 15, 14, 21, 35, 22, 33, 26, 39]
    res = []
    while len(res) < n:
        res.extend(vals)
    return res[:n]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 1:
            return True
        if any(x == 1 for x in nums):
            return False

        M = max(nums)
        # Build SPF sieve
        spf = list(range(M + 1))
        for i in range(2, int(M**0.5) + 1):
            if spf[i] == i:
                step = i
                start = i * i
                for j in range(start, M + 1, step):
                    if spf[j] == j:
                        spf[j] = i

        def distinct_primes(x: int):
            res = []
            last = 0
            while x > 1:
                p = spf[x]
                if p != last:
                    res.append(p)
                    last = p
                x //= p
            return res

        # DSU
        parent = list(range(n))
        size = [1] * n

        def find(a: int) -> int:
            while parent[a] != a:
                parent[a] = parent[parent[a]]
                a = parent[a]
            return a

        def union(a: int, b: int) -> None:
            ra, rb = find(a), find(b)
            if ra == rb:
                return
            if size[ra] < size[rb]:
                ra, rb = rb, ra
            parent[rb] = ra
            size[ra] += size[rb]

        leader = {}
        for i, x in enumerate(nums):
            for p in distinct_primes(x):
                if p not in leader:
                    leader[p] = i
                else:
                    union(i, leader[p])

        root0 = find(0)
        for i in range(1, n):
            if find(i) != root0:
                return False
        return True

# Final quick asserts
if __name__ == "__main__":
    s = Solution()
    assert s.canTraverseAllPairs([2, 3, 6]) is True
    assert s.canTraverseAllPairs([3, 9, 5]) is False
    assert s.canTraverseAllPairs([4, 3, 12, 8]) is True
    assert s.canTraverseAllPairs([1]) is True
    assert s.canTraverseAllPairs([1, 1]) is False
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Check if the index graph defined by $\gcd>1$ edges is connected; solve with SPF factorization and DSU.}
\WHY{A common pattern: transform a numeric relation (sharing a prime) into graph connectivity and use DSU/BFS with prime buckets.}
\CHECKLIST{
\begin{bullets}
\item Handle $n=1$ early.
\item If any value equals $1$ and $n>1$, return \texttt{False}.
\item Build SPF up to $\max(\texttt{nums})$.
\item Use distinct prime factors only.
\item Union indices via shared primes or BFS via prime buckets.
\item Verify all nodes share the same root / are visited.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ $\Rightarrow$ \texttt{True}.
\item Any $1$ present with $n>1$ $\Rightarrow$ \texttt{False}.
\item All numbers equal (non-1) $\Rightarrow$ \texttt{True}.
\item Pairwise coprime primes like $[2,3,5]$ $\Rightarrow$ \texttt{False}.
\item Chained connectivity: $[6,10,15]$ $\Rightarrow$ \texttt{True}.
\item Large repeated primes ensuring a bridge.
\item Numbers with large prime squared (still one prime factor).
\item Mixed small/large primes near the sieve bound.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to treat $1$ as isolated.
\item Using non-distinct prime factors causing redundant work.
\item Missing path compression/union-by-size leading to TLE.
\item Sieve up to wrong bound (must be $\max(\texttt{nums})$).
\item Off-by-one errors in sieve loops.
\item Not marking prime buckets as used in BFS approach, causing quadratic behavior.
\item Assuming direct edges are necessary; chains via primes suffice.
\item Handling empty buckets or numbers equal to prime itself.
\end{bullets}
}
\FAILMODES{Brute force may TLE on $n=10^5$. Prime-bucket BFS or DSU remains near-linear. Inputs of many distinct primes break pairwise approaches but are handled cleanly by DSU.}
\ELI{Treat each prime as a ``hub''. If every index can reach the same hub network by shared primes, the graph is connected. DSU or prime-bucket BFS captures this efficiently.}
\NotePages{3}

\end{document}