% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Same Sum Blocks (Hard)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1141/F2}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{This problem is given in two editions, which differ exclusively in the constraints on the number $n$.

You are given an array of integers $a[1], a[2], \dots, a[n]$. A block is a sequence of contiguous (consecutive) elements $a[l], a[l+1], \dots, a[r]$ ($1 \le l \le r \le n$). Thus, a block is defined by a pair of indices $(l, r)$.

Find a set of blocks $(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$ such that:
\begin{bullets}
\item They do not intersect (i.e., they are disjoint). Formally, for each pair of blocks $(l_i, r_i)$ and $(l_j, r_j)$ where $i \ne j$ either $r_i < l_j$ or $r_j < l_i$.
\item For each block the sum of its elements is the same. Formally,
\begin{BreakableEquation*}
a[l_1]+a[l_1+1]+\dots+a[r_1]=a[l_2]+a[l_2+1]+\dots+a[r_2]=\dots=a[l_k]+a[l_k+1]+\dots+a[r_k].
\end{BreakableEquation*}
\item The number of the blocks in the set is maximum. Formally, there does not exist a set of blocks $(l_1', r_1'), (l_2', r_2'), \dots, (l_{k'}', r_{k'}')$ satisfying the above two requirements with $k' > k$.
\end{bullets}

The picture in the original statement corresponds to the first example. Blue boxes illustrate blocks.

Write a program to find such a set of blocks.

Input:
The first line contains integer $n$ ($1 \le n \le 1500$) — the length of the given array. The second line contains the sequence of elements $a[1], a[2], \dots, a[n]$ ($-10^5 \le a_i \le 10^5$).

Output:
In the first line print the integer $k$ ($1 \le k \le n$). The following $k$ lines should contain blocks, one per line. In each line print a pair of indices $l_i, r_i$ ($1 \le l_i \le r_i \le n$) — the bounds of the $i$-th block. You can print blocks in any order. If there are multiple answers, print any of them.}
\BREAKDOWN{Compute, for each possible subarray sum, the maximum number of pairwise disjoint subarrays having that sum. Among all sums, output the corresponding set with maximum cardinality.}
\ELI{Group subarrays by their sum; for each group, greedily take non-overlapping ones by earliest finishing time, and pick the largest group.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer $n$; then $n$ integers $a_1,\dots,a_n$ with $1 \le n \le 1500$ and $-10^5 \le a_i \le 10^5$.}
\OUTPUTS{First line: $k$ — the maximum number of pairwise disjoint subarrays with equal sum. Next $k$ lines: pairs $l~r$ (1-indexed, inclusive) for the chosen blocks, in any order.}
\SAMPLES{Example 1: $n=5$, $a=[1,2,1,2,1]$. One valid output is $k=3$ with blocks $(1,1),(3,3),(5,5)$ (sum $=1$).

Example 2: $n=4$, $a=[-1,1,-1,1]$. One valid output is $k=2$ with blocks $(1,2),(3,4)$ (sum $=0$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $a \in \mathbb{Z}^n$ and define prefix sums $p_0=0$, $p_i=p_{i-1}+a_i$. A block $(l,r)$ has sum $s(l,r)=p_r-p_{l-1}$. We seek a sum value $S$ and a maximum-cardinality subset $\mathcal{B}\subseteq\{(l,r):1\le l\le r\le n,\ s(l,r)=S\}$ with pairwise disjoint intervals.}
\varmapStart
\var{n}{array length}
\var{a_i}{array elements}
\var{p_i}{prefix sums}
\var{S}{candidate common sum of chosen blocks}
\var{\mathcal{B}}{selected pairwise disjoint blocks}
\varmapEnd
\GOVERN{
\[
\max_{S\in\mathbb{Z}}\ \max_{\mathcal{B}}\ |\mathcal{B}|\quad\text{s.t.}\quad
\forall (l,r)\in\mathcal{B}:\ p_r-p_{l-1}=S,\ \text{and intervals in }\mathcal{B}\text{ are disjoint.}
\]
}
\ASSUMPTIONS{Indices are 1-based; disjointness means no shared positions; any valid maximum is acceptable.}
\INVARIANTS{
\begin{bullets}
\item For fixed $S$, selecting intervals by increasing $r$ and taking any with $l$ greater than the last chosen $r$ is optimal (interval scheduling by earliest finish).
\item For fixed right endpoint $r$ and fixed sum $S$, among intervals ending at $r$ with sum $S$, keeping the one with largest $l$ never hurts the greedy schedule.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all $O(n^2)$ subarrays, group by sum, and for each sum sort intervals by $r$ and greedily select non-overlapping ones.}
\ASSUMPTIONS{Feasible since $n \le 1500$–$2000$ in this family; Python may require minor care but remains acceptable for the stated $n \le 1500$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a dictionary $G$ mapping sum $S$ to list of all intervals $(l,r)$ with $s(l,r)=S$.
\item For each $S$, sort $G[S]$ by increasing $r$; greedily pick intervals with $l>r_{\text{last}}$.
\item Keep the sum yielding the largest picked set; output its picked intervals.
\end{algosteps}
\COMPLEXITY{For building $G$ we have $O(n^2)$ intervals; sorting per sum totals $O(n^2\log n)$ in the worst case; the greedy pass is $O(n^2)$.}
\[
\begin{aligned}
T(n) &= O(n^2) \text{ to enumerate} + O(n^2\log n) \text{ to sort} + O(n^2) \text{ to select} \\
     &= O(n^2\log n),\quad S(n)=O(n^2) \text{ intervals stored.}
\end{aligned}
\]
\CORRECTNESS{For each fixed sum, the classical interval scheduling by earliest finishing time maximizes the count of disjoint intervals. Taking the best among sums yields a globally optimal answer.}
\EDGECASES{All $a_i=0$; negative values; single element; multiple optimal sums; identical intervals.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Dict

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def greedy_disjoint(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    # intervals given as (l, r), 1-indexed
    intervals.sort(key=lambda x: x[1])  # sort by r
    res = []
    last_r = 0
    for l, r in intervals:
        if l > last_r:
            res.append((l, r))
            last_r = r
    return res

def solve_case_baseline(a: List[int]) -> List[Tuple[int, int]]:
    n = len(a)
    # Group all subarrays by sum
    groups: Dict[int, List[Tuple[int, int]]] = {}
    pref = [0] * (n + 1)
    for i in range(1, n + 1):
        pref[i] = pref[i - 1] + a[i - 1]
    for l in range(1, n + 1):
        for r in range(l, n + 1):
            s = pref[r] - pref[l - 1]
            groups.setdefault(s, []).append((l, r))
    best: List[Tuple[int, int]] = []
    for s, ivs in groups.items():
        picked = greedy_disjoint(ivs[:])
        if len(picked) > len(best):
            best = picked
    return best

def solve_all_baseline(n: int, a: List[int]) -> str:
    ivs = solve_case_baseline(a)
    out_lines = [str(len(ivs))]
    for l, r in ivs:
        out_lines.append(f"{l} {r}")
    return "\n".join(out_lines)

def main():
    n, a = read_input()
    if n == 0:
        # Self-test
        def check(a: List[int], expected_k: int):
            res = solve_case_baseline(a)
            # Verify disjointness and equal sums
            if not res:
                assert expected_k == 0
                return
            sums = [sum(a[l-1:r]) for (l, r) in res]
            assert all(s == sums[0] for s in sums)
            # Check disjointness
            res_sorted = sorted(res)
            last_r = 0
            for l, r in res_sorted:
                assert l > last_r
                last_r = r
            assert len(res) == expected_k
        check([1, 2, 1, 2, 1], 3)
        check([-1, 1, -1, 1], 2)
        check([5], 1)
        print("OK")
    else:
        sys.stdout.write(solve_all_baseline(n, a))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{On $[1,2,1,2,1]$ returns $3$ intervals of sum $1$. On $[-1,1,-1,1]$ returns $2$ intervals of sum $0$. Single element returns $1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-Right Endpoint De-duplication}
\WHICHFORMULA{Avoid duplicate intervals of the same sum ending at the same right endpoint by keeping only the one with largest $l$ (closest to $r$). This preserves optimality under the greedy-by-$r$ selection and reduces constant factors.}
\ASSUMPTIONS{For a fixed $r$ and sum $S$, keeping the interval with the largest $l$ never reduces the maximum achievable count in earliest-finish-time scheduling.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $r$ from $1$ to $n$, scan $l$ from $r$ down to $1$, accumulating $s=\sum_{i=l}^r a_i$.
\item Use a local hash map to ensure each sum $s$ contributes at most one interval ending at $r$; the first time we see $s$ in this reverse scan corresponds to the largest $l$.
\item Append these $(l,r)$ to the global group for $s$. After processing all $r$, for each sum run greedy by $r$ and pick the best set.
\end{algosteps}
\COMPLEXITY{Still $O(n^2)$ sums visited in the worst case, but fewer stored intervals and no per-sum duplicates per $r$, so sorting and selection are faster in practice.}
\[
\begin{aligned}
T(n) &= O(n^2) \text{ generation } + O(n^2\log n) \text{ grouping/sorting in worst case},\quad S(n)=O(n^2).
\end{aligned}
\]
\CORRECTNESS{For each sum, earliest-finish greedy is optimal. Per-right dedup keeps the most right-leaning interval among those ending at the same $r$ and sharing the sum, which dominates any other choice in the greedy order.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Dict

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def greedy_disjoint(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    intervals.sort(key=lambda x: x[1])
    res = []
    last_r = 0
    for l, r in intervals:
        if l > last_r:
            res.append((l, r))
            last_r = r
    return res

def solve_case_improved(a: List[int]) -> List[Tuple[int, int]]:
    n = len(a)
    groups: Dict[int, List[Tuple[int, int]]] = {}
    for r in range(1, n + 1):
        s = 0
        seen: Dict[int, int] = {}
        for l in range(r, 0, -1):
            s += a[l - 1]
            if s not in seen:
                seen[s] = l  # keep the largest l for this sum at this r
        for s_val, l_val in seen.items():
            groups.setdefault(s_val, []).append((l_val, r))
    best: List[Tuple[int, int]] = []
    for s, ivs in groups.items():
        picked = greedy_disjoint(ivs[:])
        if len(picked) > len(best):
            best = picked
    return best

def solve_all_improved(n: int, a: List[int]) -> str:
    ivs = solve_case_improved(a)
    out_lines = [str(len(ivs))]
    for l, r in ivs:
        out_lines.append(f"{l} {r}")
    return "\n".join(out_lines)

def main():
    n, a = read_input()
    if n == 0:
        def verify(a: List[int]):
            res = solve_case_improved(a)
            if not res:
                return
            sums = [sum(a[l-1:r]) for (l, r) in res]
            assert all(s == sums[0] for s in sums)
            res_sorted = sorted(res)
            last_r = 0
            for l, r in res_sorted:
                assert l > last_r
                last_r = r
        verify([1, 2, 1, 2, 1])
        verify([-1, 1, -1, 1])
        verify([5])
        print("OK")
    else:
        sys.stdout.write(solve_all_improved(n, a))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks pass on crafted arrays with alternating signs, singletons, and repeated small patterns.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Group-by-Sum with Earliest-Finish Greedy}
\WHICHFORMULA{Compute, per sum, a near-minimal representative set of candidate intervals via per-right de-duplication; then apply the optimal interval scheduling greedy by increasing right endpoint and choose the best sum.}
\ASSUMPTIONS{Constraints allow $O(n^2)$ enumeration; interval scheduling greedy is optimal for maximizing the number of disjoint intervals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each right endpoint $r$, scan leftwards, accumulate sums, and record at most one $(l,r)$ per distinct sum at this $r$ (the one with largest $l$).
\item For each sum $S$, sort its intervals by $r$ and greedily pick non-overlapping ones.
\item Keep the sum with the largest picked set; output those intervals.
\end{algosteps}
\OPTIMALITY{For a fixed $S$, earliest-finish greedy is optimal for maximizing the count of disjoint intervals. Since different sums produce disjoint candidate sets, taking the best over all sums yields the global optimum. The per-right de-duplication preserves the greedy optimum as it cannot reduce the greedy count for that sum.}
\COMPLEXITY{Total enumeration is $O(n^2)$, sorting across all sums is $O(n^2\log n)$ in the worst case, and selection is $O(n^2)$.}
\[
\begin{aligned}
T(n) &= O(n^2\log n),\quad S(n)=O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Dict

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def greedy_disjoint(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    intervals.sort(key=lambda x: x[1])
    res: List[Tuple[int, int]] = []
    last_r = 0
    for l, r in intervals:
        if l > last_r:
            res.append((l, r))
            last_r = r
    return res

def solve_case(a: List[int]) -> List[Tuple[int, int]]:
    n = len(a)
    groups: Dict[int, List[Tuple[int, int]]] = {}
    for r in range(1, n + 1):
        s = 0
        seen: Dict[int, int] = {}
        for l in range(r, 0, -1):
            s += a[l - 1]
            if s not in seen:
                seen[s] = l  # keep largest l for sum s ending at r
        for s_val, l_val in seen.items():
            groups.setdefault(s_val, []).append((l_val, r))
    best: List[Tuple[int, int]] = []
    for s_val, ivs in groups.items():
        picked = greedy_disjoint(ivs[:])
        if len(picked) > len(best):
            best = picked
    return best

def solve_all(n: int, a: List[int]) -> str:
    ivs = solve_case(a)
    out_lines = [str(len(ivs))]
    for l, r in ivs:
        out_lines.append(f"{l} {r}")
    return "\n".join(out_lines)

def _check_solution(a: List[int], ivs: List[Tuple[int, int]]) -> None:
    if not ivs:
        return
    sums = [sum(a[l-1:r]) for (l, r) in ivs]
    assert all(s == sums[0] for s in sums)
    last_r = 0
    for l, r in sorted(ivs):
        assert l > last_r
        last_r = r

def main():
    n, a = read_input()
    if n == 0:
        # Tests
        res = solve_case([1, 2, 1, 2, 1])
        _check_solution([1, 2, 1, 2, 1], res)
        assert len(res) == 3
        res = solve_case([-1, 1, -1, 1])
        _check_solution([-1, 1, -1, 1], res)
        assert len(res) == 2
        res = solve_case([5])
        _check_solution([5], res)
        assert len(res) == 1
        print("OK")
    else:
        sys.stdout.write(solve_all(n, a))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts are executed when no input is provided: on $[1,2,1,2,1]$ expecting $k=3$; on $[-1,1,-1,1]$ expecting $k=2$; on $[5]$ expecting $k=1$.}
\RESULT{Outputs a maximum-size set of pairwise disjoint blocks with equal sum (any order acceptable).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for correctness properties: equal sums across chosen intervals; pairwise disjointness; counts on crafted arrays. Randomized small $n$ cross-check between baseline and final.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A and C on random arrays with $n\le 40$ to ensure identical $k$, and verify all properties.}
\LINE{EDGE-CASE GENERATOR}{Generates all-zeros arrays, strictly increasing, alternating $\pm 1$, singletons, and arrays with repeated small patterns to stress many equal-sum subarrays.}
\begin{minted}{python}
import random
from typing import List, Tuple

def brute_force_answer(a: List[int]) -> int:
    # Return only k for quick cross-check
    n = len(a)
    groups = {}
    pref = [0]*(n+1)
    for i in range(1, n+1):
        pref[i] = pref[i-1] + a[i-1]
    for l in range(1, n+1):
        for r in range(l, n+1):
            s = pref[r] - pref[l-1]
            groups.setdefault(s, []).append((l, r))
    def greedy(ivs):
        ivs = sorted(ivs, key=lambda x: x[1])
        k = 0
        last = 0
        for l, r in ivs:
            if l > last:
                k += 1
                last = r
        return k
    best = 0
    for s, ivs in groups.items():
        best = max(best, greedy(ivs))
    return best

def final_answer_k(a: List[int]) -> int:
    from sys import setrecursionlimit
    setrecursionlimit(1_000_000)
    # Use the final solve_case from Approach C
    def solve_case(a: List[int]) -> List[Tuple[int, int]]:
        n = len(a)
        groups = {}
        for r in range(1, n + 1):
            s = 0
            seen = {}
            for l in range(r, 0, -1):
                s += a[l - 1]
                if s not in seen:
                    seen[s] = l
            for s_val, l_val in seen.items():
                groups.setdefault(s_val, []).append((l_val, r))
        def greedy(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
            intervals.sort(key=lambda x: x[1])
            res = []
            last_r = 0
            for l, r in intervals:
                if l > last_r:
                    res.append((l, r))
                    last_r = r
            return res
        best = []
        for s_val, ivs in groups.items():
            picked = greedy(ivs[:])
            if len(picked) > len(best):
                best = picked
        return best
    return len(solve_case(a))

def run_random_tests():
    random.seed(0)
    for n in range(1, 35):
        for _ in range(50):
            a = [random.randint(-3, 3) for _ in range(n)]
            assert final_answer_k(a) == brute_force_answer(a)
    print("Cross-check passed")

if __name__ == "__main__":
    run_random_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Dict

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def greedy_disjoint(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    intervals.sort(key=lambda x: x[1])
    res: List[Tuple[int, int]] = []
    last_r = 0
    for l, r in intervals:
        if l > last_r:
            res.append((l, r))
            last_r = r
    return res

def solve_case(a: List[int]) -> List[Tuple[int, int]]:
    n = len(a)
    groups: Dict[int, List[Tuple[int, int]]] = {}
    for r in range(1, n + 1):
        s = 0
        seen: Dict[int, int] = {}
        for l in range(r, 0, -1):
            s += a[l - 1]
            if s not in seen:
                seen[s] = l
        for s_val, l_val in seen.items():
            groups.setdefault(s_val, []).append((l_val, r))
    best: List[Tuple[int, int]] = []
    for s_val, ivs in groups.items():
        picked = greedy_disjoint(ivs[:])
        if len(picked) > len(best):
            best = picked
    return best

def solve_all(n: int, a: List[int]) -> str:
    ivs = solve_case(a)
    out_lines = [str(len(ivs))]
    for l, r in ivs:
        out_lines.append(f"{l} {r}")
    return "\n".join(out_lines)

def _self_test():
    def check(a: List[int], k_expected: int):
        res = solve_case(a)
        # same sum
        sums = [sum(a[l-1:r]) for (l, r) in res]
        assert all(s == sums[0] for s in sums)
        # disjoint
        last = 0
        for l, r in sorted(res):
            assert l > last
            last = r
        assert len(res) == k_expected
    check([1, 2, 1, 2, 1], 3)
    check([-1, 1, -1, 1], 2)
    check([5], 1)

def main():
    n, a = read_input()
    if n == 0:
        _self_test()
        print("OK")
    else:
        sys.stdout.write(solve_all(n, a))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Group subarrays by sum; per sum, select maximum number of disjoint intervals via earliest-finish greedy; choose the best sum.}
\WHY{Tests interval scheduling, prefix sums, and hashing — a common combination in medium-hard interviews and contests.}
\CHECKLIST{
\begin{bullets}
\item Build prefix sums or accumulate on the fly.
\item For each right endpoint, de-duplicate sums.
\item For each sum, sort intervals by $r$.
\item Greedily pick $l>r_{\text{last}}$.
\item Track and output the best set.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All zeros: many equal-sum intervals; result can be $\lceil n/1 \rceil$ with singletons.
\item Negatives present: sums can repeat nontrivially.
\item Single element: always $k=1$.
\item Multiple optimal sums: any is acceptable.
\item Ties in $r$: de-dup per $r$ prevents redundant candidates.
\item Repeated numbers: many identical sums; ensure stability of greedy selection.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting 1-based output while computing 0-based.
\item Not de-duplicating sums per right endpoint causes unnecessary work and may alter greedy behavior.
\item Sorting by $l$ instead of $r$ breaks optimality.
\item Using $l \ge r_{\text{last}}$ instead of $l > r_{\text{last}}$ allows overlap at boundary.
\item Integer overflow in languages without big integers (not an issue in Python).
\item Printing intervals in construction order instead of the chosen set.
\end{bullets}
}
\FAILMODES{Naive random selection within a sum can miss the optimal count; sorting by length or by $l$ is incorrect. The presented method withstands adversarial arrays with many repeated sums.}
\ELI{We try every possible common sum by scanning all subarrays. For each sum, we take as many non-overlapping subarrays as possible by always ending as early as we can. Finally, we pick the sum that gives us the most such subarrays.}
\NotePages{3}

\end{document}