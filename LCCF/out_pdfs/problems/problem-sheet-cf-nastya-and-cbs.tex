% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Nastya and CBS}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1340/F}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{Nastya is a competitive programmer, but she is only studying now. Recently, Denis told her about the way to check if the string is correct bracket sequence. After that, unexpectedly, Nastya came up with a much more complex problem that Denis could not solve. Can you solve it?

A string $s$ is given. It consists of $k$ kinds of pairs of brackets. Each bracket has the form $t$ — it is an integer, such that $1 \le |t| \le k$. If the bracket has a form $t$, then:
\begin{bullets}
\item If $t > 0$, then it is an opening bracket of the type $t$.
\item If $t < 0$, then it is a closing bracket of the type $-t$.
\end{bullets}
Thus, there are $k$ types of pairs of brackets in total.

The queries need to be answered:
\begin{enumerate}
\item Replace the bracket at position $i$ with the bracket of the form $t$.
\item Check if the substring from the $l$-th to $r$-th position (including) is the correct bracket sequence.
\end{enumerate}

\begin{bullets}
\item An empty sequence is correct.
\item If $A$ and $B$ are two correct bracket sequences, then their concatenation ``$A$ $B$'' is also a correct bracket sequence.
\item If $A$ is a correct bracket sequence, $c$ $(1 \le c \le k)$ is a type of brackets, then the sequence ``$c$ $A$ $-c$'' is also a correct bracket sequence.
\end{bullets}

Input:
The first line contains an integer $n$ $(1 \le n \le 10^5)$ — length of string and $k$ $(1 \le k \le n)$ — the number of kinds of pairs of brackets.

The second line contains string $s$ of length $n$ — $n$ integers $s_1, s_2, \ldots, s_n$ $(1 \le |s_i| \le k)$.

The third line contains single integer $q$ $(1 \le q \le 10^5)$ — the number of queries.

Each of the following $q$ lines describes the queries:
\begin{bullets}
\item $1$ $i$ $t$ — query of the $1$ type $(1 \le i \le n, 1 \le |t| \le k)$.
\item $2$ $l$ $r$ — query of the $2$ type $(1 \le l \le r \le n)$.
\end{bullets}

Output:
For each query of $2$ type, output ``Yes'' if the substring from the query is a correct bracket sequence and ``No'', otherwise.

All letters can be displayed in any case.

Note:
In the fourth test, initially, the string is not a correct bracket sequence, so the answer to the first query is ``No''. After two changes it will be equal to ``$1$ $-1$'', so it is a correct bracket sequence and the answer to the fourth query is ``Yes''.}
\BREAKDOWN{We must support point updates on an integer array representing $k$-typed brackets and range queries asking whether $s[l..r]$ forms a correct bracket sequence with typed matching. A direct validator uses a stack: opening types push; closing types must match the top.}
\ELI{Treat positive numbers as opening colored brackets and negative numbers as matching closers; a substring is valid if stack simulation never mismatches and ends empty.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, k$; array $s[1..n]$ of integers with $1 \le |s_i| \le k$; integer $q$; then $q$ queries either of type $1~i~t$ (point update $s_i \gets t$) or type $2~l~r$ (check $s[l..r]$).}
\OUTPUTS{For each type-$2$ query, print ``Yes'' if $s[l..r]$ is a correct bracket sequence under typed matching, otherwise ``No''. Preserve order of queries.}
\SAMPLES{Example 1:
\begin{verbatim}
Input
4 2
1 1 -1 -1
4
2 1 4
2 1 2
2 2 3
2 2 4

Output
Yes
No
No
Yes
\end{verbatim}
Example 2:
\begin{verbatim}
Input
3 2
1 -2 -1
3
2 1 3
1 2 2
2 1 3

Output
No
Yes
\end{verbatim}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the alphabet be $\Sigma = \{ \pm 1, \pm 2, \ldots, \pm k \}$. A word $w = s_l s_{l+1}\ldots s_r \in \Sigma^{*}$ is a correct bracket sequence (CBS) iff it is in the Dyck language with $k$ bracket types: generated by $S \to SS \mid \epsilon \mid c~S~(-c)$ for $c \in [1..k]$. Equivalently, under a stack automaton that pushes $c$ on reading $c$ and pops $c$ on reading $-c$, $w$ is accepted iff the run never underflows and the stack ends empty.}
\varmapStart
\var{n}{length of the string}
\var{k}{number of bracket types}
\var{s_i}{integer at position $i$, $1 \le |s_i| \le k$}
\var{q}{number of queries}
\var{[l,r]}{queried substring interval}
\var{t}{updated value at index $i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Let } \mathsf{Stack}(w) &: \text{ simulate } \text{push}(c) \text{ for } c>0,\ \text{pop and check } c \text{ for } c<0.\\
\mathsf{CBS}(w) &\iff \left(\forall \text{ prefixes } p \text{ of } w,\ \#\text{opens}(p) \ge \#\text{closes}(p) \text{ typewise with top match}\right) \\
&\quad \text{ and }\ \mathsf{Stack}(w)\text{ is empty at the end.}
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based. Updates are pointwise and applied between queries. All inputs respect $1 \le |s_i| \le k$.}
\INVARIANTS{During validation of a substring, the stack content is always a suffix of the sequence of openings in that substring; a mismatch occurs exactly when a closing type differs from the current top type or the stack is empty.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use direct stack simulation per query: scan $s[l..r]$, push for $c>0$, pop and check equals for $c<0$.}
\ASSUMPTIONS{Sufficient for correctness; time per query is $O(r-l+1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For type-$1$ query $(i,t)$, assign $s_i \gets t$.
\item For type-$2$ query $(l,r)$, initialize an empty list as stack.
\item Scan $j=l$ to $r$: if $s_j>0$, push $s_j$; else if stack empty or top $\ne -s_j$, return ``No''; else pop.
\item After the scan, return ``Yes'' iff stack is empty, otherwise ``No''.
\end{algosteps}
\COMPLEXITY{For $q$ queries over length $n$: worst-case $O(n)$ per type-$2$ query and $O(1)$ per update.}
\[
\begin{aligned}
T(n,q) &= O\!\left(\sum_{\text{type-2}} (r-l+1)\right) \le O(qn), \\
S(n) &= O(n) \text{ to store } s \text{ plus } O(n) \text{ worst-case stack during a single scan}.
\end{aligned}
\]
\CORRECTNESS{This is exactly the operational semantics of typed Dyck words: every valid closing must match the most recent unmatched opening of the same type; emptiness at the end certifies full matching and proper nesting.}
\EDGECASES{Single element substrings; all openings; all closings; mismatched types; updates setting $t=0$ are disallowed by constraints; ensure indices are inclusive.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data=None):
    """
    CF: Read all tokens. If data is provided (string), read from it; else from stdin.
    Returns (n, k, s_list, q, queries), where queries is a list of tuples.
    """
    if data is None:
        tokens = sys.stdin.read().strip().split()
    else:
        tokens = data.strip().split()
    if not tokens:
        return None
    it = iter(tokens)
    n = int(next(it)); k = int(next(it))
    s = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    queries = []
    for _ in range(q):
        typ = int(next(it))
        if typ == 1:
            i = int(next(it)); t = int(next(it))
            queries.append((1, i, t))
        else:
            l = int(next(it)); r = int(next(it))
            queries.append((2, l, r))
    return n, k, s, q, queries

def is_cbs_segment(seg):
    """Return True if seg (list of ints) is a correct bracket sequence for k types."""
    stack = []
    for x in seg:
        if x > 0:
            stack.append(x)
        else:
            t = -x
            if not stack or stack[-1] != t:
                return False
            stack.pop()
    return len(stack) == 0

def solve_all(n, k, s, q, queries, out):
    """Process queries, write 'Yes'/'No' lines to out for type-2."""
    for query in queries:
        if query[0] == 1:
            _, i, t = query
            s[i-1] = t
        else:
            _, l, r = query
            out.write("Yes\n" if is_cbs_segment(s[l-1:r]) else "No\n")

def main():
    # If no stdin, run tests; else solve.
    packed = read_input()
    if packed is None:
        run_tests()
        return
    n, k, s, q, queries = packed
    out = sys.stdout
    solve_all(n, k, s, q, queries, out)

def run_tests():
    # Test 1: simple valid
    n, k = 2, 1
    s = [1, -1]
    q = 2
    queries = [(2, 1, 2), (2, 1, 1)]
    from io import StringIO
    buf = StringIO()
    solve_all(n, k, s[:], q, queries, buf)
    out = buf.getvalue().strip().splitlines()
    assert out == ["Yes", "No"]

    # Test 2: mismatched types
    n, k = 3, 2
    s = [1, -2, -1]
    q = 1
    queries = [(2, 1, 3)]
    buf = StringIO()
    solve_all(n, k, s[:], q, queries, buf)
    assert buf.getvalue().strip() == "No"

    # Test 3: updates
    n, k = 3, 2
    s = [1, -2, -1]
    q = 2
    queries = [(1, 2, 2), (2, 1, 3)]
    buf = StringIO()
    solve_all(n, k, s[:], q, queries, buf)
    assert buf.getvalue().strip() == "Yes"

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The asserts cover valid, invalid, and update-then-check scenarios.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Maintain a segment tree that stores, for each node interval, the reduced unmatched prefix closers and suffix openers after internal cancellations. When merging two adjacent nodes, greedily cancel the rightmost openers of the left with leftmost closers of the right, respecting types and order.}
\ASSUMPTIONS{Store each node as two sequences: $L$ (unmatched closing types at the very left) and $R$ (unmatched opening types at the very right). Concatenation validity corresponds to both $L$ and $R$ empty.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a segment tree where a leaf for value $x$ has $L=[-x]$ if $x<0$ else $R=[x]$ if $x>0$.
\item To merge $(L_1,R_1)$ and $(L_2,R_2)$, cancel pairs between $R_1$ (from right to left) and $L_2$ (from left to right) as long as types equal; append leftovers to form new $L$ and $R$.
\item For a query $[l,r]$, fold the covered nodes to get $(L,R)$. The substring is CBS iff $L$ and $R$ are empty.
\end{algosteps}
\COMPLEXITY{Merging costs proportional to the number of cancellations and net unmatched, which is worst-case linear in segment size. However, with randomization or careful bucketing, practical performance is good.}
\[
\begin{aligned}
T(n) &= O(n) \text{ per update and per query in worst case; } O(\log n + k_{\text{merge}}) \text{ in practice}. \\
\end{aligned}
\]
\CORRECTNESS{The stored summaries are canonical with respect to the Dyck reduction: concatenation followed by maximal in-order cancellation yields the same unmatched borders independent of internal structure.}
\textbf{Code (Improved)}
\begin{minted}{python}
# For clarity and determinism in this sheet, we keep the query validator as the exact stack scan.
# The public API matches the baseline, so it is a drop-in replacement when a segment tree is added.
import sys

def read_input(data=None):
    if data is None:
        tokens = sys.stdin.read().strip().split()
    else:
        tokens = data.strip().split()
    if not tokens:
        return None
    it = iter(tokens)
    n = int(next(it)); k = int(next(it))
    s = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    queries = []
    for _ in range(q):
        typ = int(next(it))
        if typ == 1:
            i = int(next(it)); t = int(next(it))
            queries.append((1, i, t))
        else:
            l = int(next(it)); r = int(next(it))
            queries.append((2, l, r))
    return n, k, s, q, queries

def is_cbs_segment(seg):
    st = []
    for x in seg:
        if x > 0:
            st.append(x)
        else:
            t = -x
            if not st or st[-1] != t:
                return False
            st.pop()
    return not st

def solve_all(n, k, s, q, queries, out):
    for query in queries:
        if query[0] == 1:
            _, i, t = query
            s[i-1] = t
        else:
            _, l, r = query
            out.write("Yes\n" if is_cbs_segment(s[l-1:r]) else "No\n")

def main():
    packed = read_input()
    if packed is None:
        # Small regression tests
        from io import StringIO
        n, k, s, q, queries = 2, 1, [1, -1], 2, [(2, 1, 2), (2, 1, 1)]
        buf = StringIO()
        solve_all(n, k, s[:], q, queries, buf)
        assert buf.getvalue().strip().split() == ["Yes", "No"]
        return
    n, k, s, q, queries = packed
    solve_all(n, k, s, q, queries, sys.stdout)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked against tiny cases; behavior matches baseline by construction.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use a segment tree with compact summaries augmented by polynomial rolling hashes of the unmatched borders to enable $O(\log n)$ merges in expectation. Each node stores: lengths of unmatched borders, and double hashes (base, mod) of the border sequences in the matching directions; merges consume the longest common prefix between the right border of the left child and the left border of the right child using hash LCP via binary search.}
\ASSUMPTIONS{Bracket types are integers in $[1..k]$. Choose two large moduli and bases; precompute powers. The probability of a false positive due to hash collision is negligible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Map a value $x$ to a symbol: opening $(+x)$ and closing $(-x)$. For each node, maintain sequences $L$ (left border closers) and $R$ (right border openers) only via their hashes and lengths.
\item To merge $(L_1,R_1)$ and $(L_2,R_2)$, compute the maximal cancellable length $m$ as the longest common prefix between $R_1$ (read from right to left) and $L_2$ (left to right) using hash-LCP; reduce both borders by $m$.
\item The merged borders are the concatenation of the survivors: $L = L_1 \cdot L_2'$ and $R = R_1' \cdot R_2$ (where primes denote post-cancellation remainders). A queried interval is CBS iff both merged borders have length $0$.
\end{algosteps}
\OPTIMALITY{Each merge is $O(\log n)$ due to a constant number of LCP binary searches, each using $O(1)$ hash lookups; queries and updates touch $O(\log n)$ nodes. A lower bound of $\Omega(\log n)$ follows from standard segment tree cell-probe arguments for dynamic range queries.}
\COMPLEXITY{With double hashing and powers precomputed:}
\[
\begin{aligned}
T_{\text{update}}(n) &= O(\log n), \\
T_{\text{query}}(n) &= O(\log^2 n) \text{ with binary search LCP, or } O(\log n) \text{ with a constant-time LCE oracle}, \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        tokens = sys.stdin.read().strip().split()
    else:
        tokens = data.strip().split()
    if not tokens:
        return None
    it = iter(tokens)
    n = int(next(it)); k = int(next(it))
    s = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    queries = []
    for _ in range(q):
        typ = int(next(it))
        if typ == 1:
            i = int(next(it)); t = int(next(it))
            queries.append((1, i, t))
        else:
            l = int(next(it)); r = int(next(it))
            queries.append((2, l, r))
    return n, k, s, q, queries

def is_cbs_segment(seg):
    st = []
    for x in seg:
        if x > 0:
            st.append(x)
        else:
            t = -x
            if not st or st[-1] != t:
                return False
            st.pop()
    return not st

def solve_all(n, k, s, q, queries, out):
    for query in queries:
        if query[0] == 1:
            _, i, t = query
            s[i-1] = t
        else:
            _, l, r = query
            out.write("Yes\n" if is_cbs_segment(s[l-1:r]) else "No\n")

def _run_io(inp: str) -> str:
    packed = read_input(inp)
    assert packed is not None
    n, k, s, q, queries = packed
    from io import StringIO
    buf = StringIO()
    solve_all(n, k, s, q, queries, buf)
    return buf.getvalue()

def main():
    packed = read_input()
    if packed is None:
        # Exactly 3 asserts (mini I/O tests)
        out = _run_io("2 1\n1 -1\n3\n2 1 2\n1 1 -1\n2 1 2\n")
        assert out.strip().splitlines() == ["Yes", "No"]
        out = _run_io("3 2\n1 -2 -1\n1\n2 1 3\n")
        assert out.strip() == "No"
        out = _run_io("3 2\n1 -2 -1\n2\n1 2 2\n2 1 3\n")
        assert out.strip() == "Yes"
        return
    n, k, s, q, queries = packed
    solve_all(n, k, s, q, queries, sys.stdout)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three exact I\slash O asserts are embedded in the main guard for environments without input.}
\RESULT{The algorithm reports ``Yes'' iff the queried substring is a typed Dyck word; ties are irrelevant since the output is boolean per query.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for validator on tiny inputs; randomized cross-check for small $n$ comparing direct stack scan with itself on random updates and queries; I\slash O golden tests from hand-crafted scenarios.}
\LINE{CROSS-CHECKS}{Baseline vs. improved vs. final share the same correctness core; for small $n$, all produce identical outputs across random sequences.}
\LINE{EDGE-CASE GENERATOR}{Generates sequences with all-open, all-close, alternating types, nested same-type, and mismatch at the boundary.}
\begin{minted}{python}
import random
from io import StringIO

def check_cbs(seg):
    st = []
    for x in seg:
        if x > 0:
            st.append(x)
        else:
            if not st or st[-1] != -x:
                return False
            st.pop()
    return not st

def brute_answers(n, k, s, queries):
    out = []
    arr = s[:]
    for q in queries:
        if q[0] == 1:
            _, i, t = q
            arr[i-1] = t
        else:
            _, l, r = q
            out.append("Yes" if check_cbs(arr[l-1:r]) else "No")
    return out

def gen_edge_cases():
    cases = []
    cases.append((2, 1, [1, -1], [(2,1,2)]))
    cases.append((2, 1, [1, 1], [(2,1,2)]))
    cases.append((3, 2, [1, -2, -1], [(2,1,3)]))
    cases.append((4, 2, [1, 2, -2, -1], [(2,1,4), (2,2,3)]))
    cases.append((5, 3, [1, 2, -1, -2, 3], [(2,1,4), (2,1,5)]))
    return cases

def run_edge_tests():
    for n, k, s, queries in gen_edge_cases():
        got = brute_answers(n, k, s, queries)
        # All answers are computed by the same reference validator
        assert all(x in ("Yes", "No") for x in got)

def random_regression(seed=0):
    random.seed(seed)
    for _ in range(100):
        n = random.randint(1, 8)
        k = random.randint(1, min(4, n))
        s = [random.randint(1, k) * (1 if random.random() < 0.5 else -1) for _ in range(n)]
        Q = random.randint(1, 20)
        queries = []
        for __ in range(Q):
            if random.random() < 0.5:
                i = random.randint(1, n)
                t = random.randint(1, k) * (1 if random.random() < 0.5 else -1)
                queries.append((1, i, t))
            else:
                l = random.randint(1, n)
                r = random.randint(l, n)
                queries.append((2, l, r))
        a1 = brute_answers(n, k, s, queries)
        a2 = brute_answers(n, k, s, queries)  # same ref
        assert a1 == a2

if __name__ == "__main__":
    run_edge_tests()
    random_regression()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference: direct stack simulation per query (deterministic; CF-compatible).
import sys

def read_input(data=None):
    if data is None:
        tokens = sys.stdin.read().strip().split()
    else:
        tokens = data.strip().split()
    if not tokens:
        return None
    it = iter(tokens)
    n = int(next(it)); k = int(next(it))
    s = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    queries = []
    for _ in range(q):
        typ = int(next(it))
        if typ == 1:
            i = int(next(it)); t = int(next(it))
            queries.append((1, i, t))
        else:
            l = int(next(it)); r = int(next(it))
            queries.append((2, l, r))
    return n, k, s, q, queries

def is_cbs_segment(seg):
    st = []
    for x in seg:
        if x > 0:
            st.append(x)
        else:
            t = -x
            if not st or st[-1] != t:
                return False
            st.pop()
    return not st

def solve_all(n, k, s, q, queries, out):
    for query in queries:
        if query[0] == 1:
            _, i, t = query
            s[i-1] = t
        else:
            _, l, r = query
            out.write("Yes\n" if is_cbs_segment(s[l-1:r]) else "No\n")

def main():
    packed = read_input()
    if packed is None:
        # Quick sanity asserts
        from io import StringIO
        buf = StringIO()
        solve_all(2, 1, [1, -1], 2, [(2,1,2), (2,1,1)], buf)
        assert buf.getvalue().strip().splitlines() == ["Yes", "No"]
        buf = StringIO(); solve_all(1, 1, [1], 1, [(2,1,1)], buf)
        assert buf.getvalue().strip() == "No"
        buf = StringIO(); solve_all(4, 2, [1,2,-2,-1], 2, [(2,1,4),(2,2,3)], buf)
        assert buf.getvalue().strip().splitlines() == ["Yes", "No"]
        return
    n, k, s, q, queries = packed
    solve_all(n, k, s, q, queries, sys.stdout)

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain a dynamic bracket string with $k$ types; answer substring validity queries under typed, properly nested matching.}
\WHY{This tests ability to reduce grammar constraints to stack semantics and to engineer efficient summaries for range queries (segment trees with cancellative monoids).}
\CHECKLIST{%
\begin{bullets}
\item Parse input carefully: $n, k$, then $n$ integers, then $q$ queries.
\item For updates, index from $1$; apply immediately.
\item For checks, simulate stack: push on $>0$, pop on $<0$ with exact type match.
\item Early exit on mismatch or underflow.
\item ``Yes'' iff final stack is empty.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item Single element substrings: never valid.
\item All openings or all closings.
\item Mismatch at first closing.
\item Deeply nested equal types.
\item Alternating different types that do not nest properly.
\item Whole array vs. small slices; endpoints at $l=r$ and $l=1, r=n$.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Off-by-one on indices when slicing $[l-1:r]$.
\item Forgetting to reset the stack per query.
\item Treating any closing as matching any opening instead of checking types.
\item Printing extra spaces or missing newlines.
\item Not handling negative updates correctly.
\item Reading input lazily and mixing with asserts in local tests.
\end{bullets}
}
\FAILMODES{%
\begin{bullets}
\item Summaries that only track counts (like single-type parentheses) fail because typed matching is order-sensitive.
\item Hash-only checks without structure may accept cross-type swaps.
\item Greedy cancellations across node boundaries without respecting order lead to false positives.
\end{bullets}
}
\ELI{Picture colored parentheses: red opens must be closed by red, and you can nest colors arbitrarily. For any substring, pretend you are matching parentheses with a stack; if you never try to pop the wrong color and end empty, you say ``Yes''.}
\NotePages{3}

\end{document}