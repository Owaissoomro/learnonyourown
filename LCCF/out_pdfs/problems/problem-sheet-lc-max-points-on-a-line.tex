% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Max Points on a Line}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/max-points-on-a-line/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given an array of points where \(\text{points}[i] = [x_i, y_i]\) represents a point on the X--Y plane, return the maximum number of points that lie on the same straight line.

Examples:

Input: \texttt{points = [[1,1],[2,2],[3,3]]}

Output: \texttt{3}

Input: \texttt{points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]}

Output: \texttt{4}

Constraints:
\begin{bullets}
\item \(1 \le \text{points.length} \le 300\).
\item \(\text{points}[i].\text{length} = 2\).
\item \(-10^4 \le x_i, y_i \le 10^4\).
\item All the points are unique.
\end{bullets}}
\BREAKDOWN{Model collinearity and count, for each anchor point, how many other points share the same line. Use a canonical slope representation to aggregate counts, with careful handling of vertical and horizontal lines.}
\ELI{Fix a point, bucket all other points by their reduced slope to it, and take the largest bucket size plus one.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list \(\text{points}\) of length \(n\) with entries \(\text{points}[i] = [x_i, y_i]\), where \(x_i,y_i\in\mathbb{Z}\), \(1 \le n \le 300\), and \(-10^4 \le x_i, y_i \le 10^4\). All points are distinct.}
\OUTPUTS{A single integer: the maximum number of points from \(\text{points}\) that are collinear (lie on the same straight line).}
\SAMPLES{Example 1: Input \texttt{[[1,1],[2,2],[3,3]]} \(\to\) Output \texttt{3}. Example 2: Input \texttt{[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]} \(\to\) Output \texttt{4}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a finite set \(P=\{(x_i,y_i)\}_{i=1}^n \subset \mathbb{Z}^2\), compute
\begin{BreakableEquation*}
\max_{L} \left|\{p\in P: p\in L\}\right|,
\end{BreakableEquation*}
where \(L\) ranges over all straight lines in \(\mathbb{R}^2\). Two points determine a unique line; three points are collinear iff the oriented area of the triangle they form is zero.}
\varmapStart
\var{n}{number of points}
\var{(x_i,y_i)}{integer coordinates of point \(i\)}
\var{L}{a line in \(\mathbb{R}^2\)}
\var{(d_y,d_x)}{reduced slope representation via \(\gcd\)}
\varmapEnd
\GOVERN{
\[
\text{Collinearity criterion: }\quad
\forall i,j,k:\quad
(y_k - y_i)(x_j - x_i) - (x_k - x_i)(y_j - y_i) = 0.
\]
}
\ASSUMPTIONS{All coordinates are integers; points are pairwise distinct; integer arithmetic is exact, so cross-products detect collinearity without precision loss.}
\INVARIANTS{
\begin{bullets}
\item Slope normalization invariant: if \((d_y,d_x)\) represents a slope, we store it reduced by \(g=\gcd(|d_y|,|d_x|)\) with a fixed sign convention (e.g., \(d_x>0\); vertical \((1,0)\); horizontal \((0,1)\)).
\item For a fixed anchor point \(i\), points sharing the same reduced slope to \(i\) lie on one line through \(i\).
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the area-zero test for collinearity. For every unordered pair \((i,j)\), count how many \(k\) satisfy \((y_k - y_i)(x_j - x_i) = (x_k - x_i)(y_j - y_i)\).}
\ASSUMPTIONS{Coordinates fit in Python integers; all points are unique (so trivial duplicates do not need special handling).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If \(n \le 2\), return \(n\).
\item For each pair \((i,j)\) with \(i<j\), initialize \(\text{cnt}=2\).
\item For every \(k\ne i,j\), increment \(\text{cnt}\) if the cross-product equality holds.
\item Track the maximum \(\text{cnt}\) across all pairs.
\end{algosteps}
\COMPLEXITY{Brute force examines all \(O(n^2)\) pairs and for each scans all \(O(n)\) points.}
\[
\begin{aligned}
T(n) &= \Theta(n^2)\cdot \Theta(n) \;=\; \Theta(n^3),\\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Every maximal collinear set contains at least one defining pair; counting all points collinear with that pair yields its cardinality. Taking the maximum over all pairs returns the desired maximum.}
\EDGECASES{Handle \(n=1\) and \(n=2\); vertical and horizontal lines are correctly handled by the cross-product test without division.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 2:
            return n
        ans = 2
        for i in range(n):
            xi, yi = points[i]
            for j in range(i + 1, n):
                xj, yj = points[j]
                dx = xj - xi
                dy = yj - yi
                cnt = 2
                for k in range(n):
                    if k == i or k == j:
                        continue
                    xk, yk = points[k]
                    # Collinearity: (yk - yi)*dx == (xk - xi)*dy
                    if (yk - yi) * dx == (xk - xi) * dy:
                        cnt += 1
                if cnt > ans:
                    ans = cnt
        return ans

# Basic asserts
assert Solution().maxPoints([[1,1],[2,2],[3,3]]) == 3
assert Solution().maxPoints([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) == 4
assert Solution().maxPoints([[0,0]]) == 1
assert Solution().maxPoints([[0,0],[0,1]]) == 2
\end{minted}
\VALIDATION{Checked the two given examples; also validated single-point and vertical-line cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Hashing by Reduced Slope}
\WHICHFORMULA{Fix an anchor \(i\). Bucket other points by reduced slope \((d_y,d_x)\) computed via \(\gcd\). The largest bucket size plus one (the anchor) gives the best line through \(i\). Take the maximum over anchors.}
\ASSUMPTIONS{Use integer arithmetic only; slopes are canonically reduced. Treat vertical as \((1,0)\), horizontal as \((0,1)\), and otherwise enforce \(d_x>0\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each anchor \(i\), reset a hash map \(\text{cnt}\).
\item For each \(j>i\), compute \((d_y,d_x)\) between \(i\) and \(j\), reduce by \(\gcd\) and normalize sign.
\item Increment \(\text{cnt}[(d_y,d_x)]\).
\item The best through \(i\) is \(1 + \max \text{cnt}[\cdot]\); update global maximum.
\end{algosteps}
\COMPLEXITY{Each pair is processed once with \(O(1)\) amortized map operations.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \\
S(n) &= \Theta(n)\ \text{for the per-anchor map}.
\end{aligned}
\]
\CORRECTNESS{For a fixed anchor, equal reduced slopes imply collinearity on the same line through the anchor. Reduction by \(\gcd\) and a fixed sign convention ensures identical lines map to identical keys.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from math import gcd
from collections import defaultdict

class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 2:
            return n

        def norm(dy: int, dx: int) -> tuple[int, int]:
            if dx == 0:
                return (1, 0)  # vertical
            if dy == 0:
                return (0, 1)  # horizontal
            g = gcd(abs(dy), abs(dx))
            dy //= g
            dx //= g
            if dx < 0:
                dx = -dx
                dy = -dy
            return (dy, dx)

        ans = 1
        for i in range(n):
            cnt = defaultdict(int)
            xi, yi = points[i]
            for j in range(i + 1, n):
                xj, yj = points[j]
                dy = yj - yi
                dx = xj - xi
                key = norm(dy, dx)
                cnt[key] += 1
            if cnt:
                ans = max(ans, 1 + max(cnt.values()))
            else:
                ans = max(ans, 1)  # single point case
        return ans

# Asserts
assert Solution().maxPoints([[1,1],[2,2],[3,3]]) == 3
assert Solution().maxPoints([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) == 4
# Vertical and horizontal
assert Solution().maxPoints([[0,0],[0,2],[0,5],[1,1]]) == 3
assert Solution().maxPoints([[0,0],[2,0],[5,0],[1,1]]) == 3
\end{minted}
\VALIDATION{Validated on sample cases and both vertical/horizontal dominant sets.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{O(n\^2) with Early Pruning and Canonical Slope}
\WHICHFORMULA{Same reduced-slope hashing as Approach B, plus safe pruning: if the current best is already \(\ge n-i\) or \(> \lfloor n/2 \rfloor\), no later anchor can beat it.}
\ASSUMPTIONS{All integer arithmetic; same canonical slope rules. Pruning does not change the worst-case asymptotic but can speed up typical cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \(\text{best}=1\).
\item For anchor \(i\) from \(0\) to \(n-1\): if \(\text{best} \ge n-i\) or \(\text{best} > \lfloor n/2 \rfloor\), break.
\item Hash slopes for \(j>i\) as in Approach B; update \(\text{best}\) with \(1+\max\) bucket size.
\item Return \(\text{best}\).
\end{algosteps}
\OPTIMALITY{Any optimal line must pass through some anchor; hashing attains the lower bound of examining all pairs up to constant factors. The pruning is safe and cannot skip a better answer.}
\COMPLEXITY{Same asymptotics as Approach B; fewer iterations in practice.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \\
S(n) &= \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from math import gcd
from collections import defaultdict

class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 2:
            return n

        def norm(dy: int, dx: int) -> tuple[int, int]:
            if dx == 0:
                return (1, 0)  # vertical
            if dy == 0:
                return (0, 1)  # horizontal
            g = gcd(abs(dy), abs(dx))
            dy //= g
            dx //= g
            if dx < 0:
                dx = -dx
                dy = -dy
            return (dy, dx)

        best = 1
        for i in range(n):
            # Pruning: if remaining points cannot beat current best, break.
            if best >= n - i or best > n // 2:
                break
            cnt = defaultdict(int)
            xi, yi = points[i]
            for j in range(i + 1, n):
                xj, yj = points[j]
                key = norm(yj - yi, xj - xi)
                cnt[key] += 1
            if cnt:
                best = max(best, 1 + max(cnt.values()))
        return best

# Exactly 3 asserts
assert Solution().maxPoints([[1,1],[2,2],[3,3]]) == 3
assert Solution().maxPoints([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) == 4
assert Solution().maxPoints([[0,0],[0,1],[0,2],[2,2],[4,4]]) == 4
\end{minted}
\VALIDATION{Three asserts: the two official examples and a mixed set with vertical and diagonal lines yielding 4.}
\RESULT{Return the maximum cardinality of a collinear subset of the given points (no tie-breaking required).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: trivial sizes (\(n\in\{1,2\}\)), all vertical or horizontal sets, diagonal lines, and mixed configurations. Random small cases can be cross-checked by comparing the O(\(n^3\)) baseline and the O(\(n^2\)) method on the same inputs.}
\LINE{CROSS-CHECKS}{For small \(n\le 8\), enumerate random integer points in a bounded box and assert that Approach B/C equals Approach A.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial patterns: many identical slopes from one anchor; nearly all random but with a hidden line; vertical or horizontal dominance.}
\begin{minted}{python}
from typing import List
from math import gcd
from collections import defaultdict
import random

def brute_max_points(points: List[List[int]]) -> int:
    n = len(points)
    if n <= 2:
        return n
    ans = 2
    for i in range(n):
        xi, yi = points[i]
        for j in range(i + 1, n):
            xj, yj = points[j]
            dx = xj - xi
            dy = yj - yi
            cnt = 2
            for k in range(n):
                if k == i or k == j:
                    continue
                xk, yk = points[k]
                if (yk - yi) * dx == (xk - xi) * dy:
                    cnt += 1
            ans = max(ans, cnt)
    return ans

class ReferenceSolution:
    def maxPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 2:
            return n

        def norm(dy: int, dx: int) -> tuple[int, int]:
            if dx == 0:
                return (1, 0)
            if dy == 0:
                return (0, 1)
            g = gcd(abs(dy), abs(dx))
            dy //= g
            dx //= g
            if dx < 0:
                dx = -dx
                dy = -dy
            return (dy, dx)

        best = 1
        for i in range(n):
            if best >= n - i or best > n // 2:
                break
            cnt = defaultdict(int)
            xi, yi = points[i]
            for j in range(i + 1, n):
                xj, yj = points[j]
                cnt[norm(yj - yi, xj - xi)] += 1
            if cnt:
                best = max(best, 1 + max(cnt.values()))
        return best

def gen_points(n: int, coord: int = 10) -> List[List[int]]:
    seen = set()
    pts = []
    while len(pts) < n:
        x = random.randint(-coord, coord)
        y = random.randint(-coord, coord)
        if (x, y) not in seen:
            seen.add((x, y))
            pts.append([x, y])
    return pts

# Cross-check small randoms
random.seed(0)
for _ in range(50):
    pts = gen_points(random.randint(1, 8), 5)
    assert ReferenceSolution().maxPoints(pts) == brute_max_points(pts)

# Directed tests
assert ReferenceSolution().maxPoints([[1,1],[2,2],[3,3]]) == 3
assert ReferenceSolution().maxPoints([[0,0],[0,1],[0,2],[2,2],[4,4]]) == 4
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from math import gcd
from collections import defaultdict

class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 2:
            return n

        def norm(dy: int, dx: int) -> tuple[int, int]:
            if dx == 0:
                return (1, 0)  # vertical
            if dy == 0:
                return (0, 1)  # horizontal
            g = gcd(abs(dy), abs(dx))
            dy //= g
            dx //= g
            if dx < 0:
                dx = -dx
                dy = -dy
            return (dy, dx)

        best = 1
        for i in range(n):
            if best >= n - i or best > n // 2:
                break
            cnt = defaultdict(int)
            xi, yi = points[i]
            for j in range(i + 1, n):
                xj, yj = points[j]
                key = norm(yj - yi, xj - xi)
                cnt[key] += 1
            if cnt:
                best = max(best, 1 + max(cnt.values()))
        return best

# Minimal sanity asserts
assert Solution().maxPoints([[1,1],[2,2],[3,3]]) == 3
assert Solution().maxPoints([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) == 4
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count, for each anchor, how many points share the same reduced slope to it; return the maximum bucket size plus one.}
\WHY{A canonical interview task testing robust hashing with number theory (gcd), handling degenerates (vertical/horizontal), and avoiding floating-point errors.}
\CHECKLIST{
\begin{bullets}
\item Use integer cross-products or reduced integer slopes; never floats.
\item Normalize slope signs consistently; fix vertical/horizontal sentinels.
\item Reset the map per anchor; add 1 for the anchor to bucket max.
\item Early pruning to save time in practice.
\item Handle \(n\le 2\) directly.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item \(n=1\) returns \(1\); \(n=2\) returns \(2\).
\item All points on a vertical line.
\item All points on a horizontal line.
\item Many points share the same diagonal slope.
\item Mix with no 3 collinear; answer is \(2\).
\item Large coordinates with negative values.
\item Anchors late in the loop when best is already large (pruning).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to reduce by \(\gcd\) causes distinct keys for the same line.
\item Inconsistent sign normalization (e.g., allowing both \((1,-1)\) and \((-1,1)\)).
\item Division-based slopes risking precision or division-by-zero.
\item Not resetting the hashmap per anchor.
\item Off-by-one: forgetting to add the anchor to the bucket count.
\item Overflow in languages with fixed-width integers when using cross-products.
\item Mishandling vertical/horizontal special cases.
\end{bullets}
}
\FAILMODES{Float-based approaches can fail on near-parallel lines or large coordinates. Non-reduced slope hashing overcounts distinct buckets and returns too small an answer.}
\ELI{Lines are determined by their slope from a fixed starting point. By counting how many points have the same reduced slope from each point, we find the most crowded line. Integer math keeps it exact and fast.}
\NotePages{3}

\end{document}