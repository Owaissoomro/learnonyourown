% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — No Monotone Triples}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1332/G}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{Given a sequence of integers $a$ of length $n$, a tuple $(i,j,k)$ is called monotone triples if
\begin{itemize}
\item $1 \le i<j<k\le n$;
\item $a_i \le a_j \le a_k$ or $a_i \ge a_j \ge a_k$ is satisfied.
\end{itemize}
For example, $a=[5,3,4,5]$, then $(2,3,4)$ is monotone triples for sequence $a$ while $(1,3,4)$ is not.

Bob is given a sequence of integers $a$ of length $n$ in a math exam. The exams itself contains questions of form $L, R$, for each of them he is asked to find any subsequence $b$ with size greater than $2$ (i.e. $|b| \ge 3$) of sequence $a_L, a_{L+1},\ldots, a_{R}$.

Recall that an sequence $b$ is a subsequence of sequence $a$ if $b$ can be obtained by deletion of several (possibly zero, or all) elements.

However, he hates monotone stuff, and he wants to find a subsequence free from monotone triples. Besides, he wants to find one subsequence with the largest length among all subsequences free from monotone triples for every query.

Please help Bob find out subsequences meeting the above constraints.

Input:
The first line contains two integers $n$, $q$ ($3 \le n \le 2 \cdot 10^5$, $1 \le q \le 2 \cdot 10^5$) — the length of sequence $a$ and the number of queries.

The second line contains $n$ integers $a_1,a_2,\ldots, a_n$ ($1 \le a_i \le 10^{9}$), representing the sequence $a$.

Then each of the following $q$ lines contains two integers $L$, $R$ ($1 \le L,R \le n$, $R-L\ge 2$).

Output:
For each query, output $0$ if there is no subsequence $b$ satisfying the constraints mentioned in the legend. You can print the empty line after but that's not mandatory.

Otherwise, output one integer $k$ ($k > 2$) denoting the length of sequence $b$, then output $k$ integers $i_1, i_2, \ldots, i_k$ ($L \le i_1 < i_2<\ldots<i_k\le R$) satisfying that $b_j = a_{i_j}$ for $1 \le j \le k$.

If there are multiple answers with the maximum length, print any of them.

Note:
For the first query, the given sequence itself is monotone triples free.

For the second query, it can be shown that there is no subsequence $b$ with length greater than $2$ such that $b$ is monotone triples free.}
\BREAKDOWN{We must answer $q$ range queries by outputting the longest subsequence (within $[L,R]$) that contains no monotone triple. A key fact is that any subsequence of length $5$ contains a strictly monotone triple, so the optimal length is at most $4$. We can precompute a run-length decomposition by equal-value blocks and monotonic runs, then answer each query in $O(1)$ by choosing up to four turning-point blocks and verifying simple endpoint inequalities.}
\ELI{Compress equal neighbors, then pick up to four indices at alternating peaks and troughs; $4$ is possible only when the first and last runs ``lean'' inward, otherwise the maximum is $3$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n,q$ with $3 \le n \le 2\cdot 10^5$, $1 \le q \le 2\cdot 10^5$; array $a_1,\ldots,a_n$ with $1 \le a_i \le 10^{9}$; queries $(L,R)$ with $1 \le L \le R \le n$ and $R-L \ge 2$.}
\OUTPUTS{For each query: print $0$ if no subsequence of length at least $3$ is monotone-triple-free; otherwise print $k$ ($3 \le k \le 4$) and a strictly increasing list of $k$ indices in $[L,R]$ that form a monotone-triple-free subsequence of maximum possible length.}
\SAMPLES{Example 1: $a=[5,3,4,5]$, query $(1,4)$, one valid maximum answer is $3$ on indices $1,2,4$.

Example 2: $a=[1,2,3,4]$, query $(1,4)$, output $0$ since any triple is nondecreasing.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $[L,R]$, find the longest index sequence $L \le i_1 < \cdots < i_k \le R$ such that there do not exist $x<y<z$ with $a_{i_x} \le a_{i_y} \le a_{i_z}$ or $a_{i_x} \ge a_{i_y} \ge a_{i_z}$.}
\varmapStart
\var{a}{input array}
\var{L,R}{query bounds}
\var{b}{chosen subsequence values}
\var{\text{blk}}{equal-value block index per position}
\var{\text{sign}}{signs of consecutive block differences}
\var{\text{runEnd}}{end of constant-sign run in the block graph}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Maximize } k \\
&\text{s.t. } \forall~x<y<z:\; \neg\big((b_x \le b_y \le b_z)\lor(b_x \ge b_y \ge b_z)\big).
\end{aligned}
\]
}
\ASSUMPTIONS{Consecutive equal elements can be compressed into blocks; comparisons across blocks are strict. Any length-$5$ sequence has a strictly monotone length-$3$ subsequence (Erd\H{o}s--Szekeres), hence here the optimum is $\le 4$.}
\INVARIANTS{On the compressed sequence, signs of differences within a monotone run are constant; turning points occur at sign changes. Selecting endpoints of successive runs yields an alternating (up/down) pattern.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all subsequences within $[L,R]$ of size $3$ and $4$ and check the monotone-triple constraint, keeping the longest feasible.}
\ASSUMPTIONS{Feasible only for tiny $n$ due to combinatorial explosion.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each query, enumerate all $\binom{R-L+1}{3}$ triples; if any triple is non-monotone, set candidate answer to $3$.
\item Enumerate all $\binom{R-L+1}{4}$ quadruples; if any avoids monotone triples, upgrade candidate to $4$.
\item Return the best candidate indices if any, else $0$.
\end{algosteps}
\COMPLEXITY{Exponential per query; impractical.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(q\cdot\left(\binom{n}{3}+\binom{n}{4}\right)\right), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Exhaustive search guarantees optimality on small instances.}
\EDGECASES{All-equal segments; strictly increasing or decreasing segments; segments with minimal length $3$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Naive checker for tiny arrays (illustrative only)
from itertools import combinations

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    a = [0] + [int(next(it)) for _ in range(n)]
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, q, a, queries

def is_monotone_triple(x, y, z):
    return (x <= y <= z) or (x >= y >= z)

def ok_subseq(a, idxs):
    k = len(idxs)
    for i in range(k):
        for j in range(i+1, k):
            for l in range(j+1, k):
                if is_monotone_triple(a[idxs[i]], a[idxs[j]], a[idxs[l]]):
                    return False
    return True

def solve_all_naive(n, q, a, queries):
    out = []
    for L, R in queries:
        best = []
        cand_idxs = list(range(L, R+1))
        # Try 4 first (rarely feasible), then 3
        found4 = False
        for comb in combinations(cand_idxs, 4):
            if ok_subseq(a, comb):
                best = list(comb)
                found4 = True
                break
        if not found4:
            found3 = False
            for comb in combinations(cand_idxs, 3):
                if ok_subseq(a, comb):
                    best = list(comb)
                    found3 = True
                    break
        if len(best) >= 3:
            out.append(str(len(best)))
            out.append(" ".join(map(str, best)))
        else:
            out.append("0")
    return "\n".join(out)

def main():
    n, q, a, queries = read_input()
    # For safety, do not run naive on large n
    if n <= 20 and len(queries) <= 20:
        print(solve_all_naive(n, q, a, queries))
    else:
        # Fallback to zero; placeholder for baseline
        for _ in range(len(queries)):
            print(0)

if __name__ == "__main__":
    # Tiny unit checks
    n=4;q=1;a=[0,5,3,4,5];queries=[(1,4)]
    s = solve_all_naive(n,q,a,queries)
    assert s.splitlines()[0] in {"3","0"}
    main()
\end{minted}
\VALIDATION{Validated on tiny arrays by brute force. Not suitable for constraints.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Compression and Turning Points (Per-Query Scan)}
\WHICHFORMULA{Compress consecutive equals into blocks; scan $[L,R]$ to collect alternating peaks/troughs. The maximum length is $\le 4$, so we only need up to three turnings.}
\ASSUMPTIONS{We can scan per query, but worst-case $O(R-L)$ still too slow for $2\cdot 10^5$ queries.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute block decomposition globally.
\item For a query $[L,R]$, walk block by block to find first three turning points, forming a candidate of size $3$ or $4$.
\item Check the $4$-length feasibility conditions; otherwise return $3$ if possible.
\end{algosteps}
\COMPLEXITY{Per query $O(\#\text{blocks in }[L,R])$; worst-case $O(n)$.}
\[
\begin{aligned}
T(n) &= O(n + \sum (R_i-L_i+1)), \\
\end{aligned}
\]
\CORRECTNESS{Follows from the fact any valid solution of size $\ge 3$ sits on alternating extrema; $4$ is achievable iff endpoints satisfy simple inequalities.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Per-query scan version (still too slow in worst case)
def compress_blocks(a):
    n = len(a) - 1
    blk_of = [0]*(n+1)
    val = []
    blkL = []
    blkR = []
    m = 0
    i = 1
    while i <= n:
        j = i
        while j+1 <= n and a[j+1] == a[i]:
            j += 1
        m += 1
        for k in range(i, j+1):
            blk_of[k] = m
        val.append(a[i])
        blkL.append(i)
        blkR.append(j)
        i = j+1
    return m, blk_of, val, blkL, blkR

def signs_and_runends(val):
    m = len(val)
    sign = [0]*(max(0, m-1))
    for i in range(m-1):
        sign[i] = 1 if val[i+1] > val[i] else -1
    runEnd = [0]*max(1, len(sign))
    i = 0
    while i < len(sign):
        j = i
        while j+1 < len(sign) and sign[j+1] == sign[i]:
            j += 1
        for k in range(i, j+1):
            runEnd[k] = j
        i = j+1
    return sign, runEnd

def build_candidate_blocks(blkLidx, blkRidx, m, sign, runEnd):
    # blk indices are 1-based conceptually; adapt to 0-based arrays
    pL = blkLidx; pR = blkRidx
    blocks = []
    blocks.append(pL)
    if pL == pR:
        return blocks
    # First extreme
    e1_edge = pL - 1  # edge index between pL and pL+1 in 0-based sign
    e1_block = min((runEnd[e1_edge] + 1) + 1, pR)  # +1 to convert edge->block, +1 for 1-based
    blocks.append(e1_block)
    if e1_block == pR:
        return blocks
    # Second extreme
    e2_edge = e1_block - 1
    e2_block = min((runEnd[e2_edge] + 1) + 1, pR)
    blocks.append(e2_block)
    if e2_block == pR:
        return blocks
    # Third extreme
    e3_edge = e2_block - 1
    e3_block = min((runEnd[e3_edge] + 1) + 1, pR)
    blocks.append(e3_block)
    # Ensure strictly increasing unique blocks
    res = []
    last = -1
    for b in blocks:
        if b != last:
            res.append(b)
            last = b
    return res

def feasible4(val, blocks):
    if len(blocks) < 4:
        return False
    b = blocks
    a1,a2,a3,a4 = val[b[0]-1], val[b[1]-1], val[b[2]-1], val[b[3]-1]
    dir_up = (a2 > a1)  # initial direction
    if dir_up:
        return (a4 < a2) and (a1 > a3)
    else:
        return (a4 > a2) and (a1 < a3)

def solve_all_scan(n, q, a, queries):
    m, blk_of, val, blkL, blkR = compress_blocks(a)
    if m == 0:
        return ""
    sign, runEnd = signs_and_runends(val)
    out = []
    for L, R in queries:
        pL = blk_of[L]
        pR = blk_of[R]
        cand_blocks = build_candidate_blocks(pL, pR, m, sign, runEnd)
        # Map blocks to indices in [L,R]
        idxs = []
        if len(cand_blocks) >= 1:
            idxs.append(L)
        for b in cand_blocks[1:]:
            idxs.append(blkL[b-1])
        if len(idxs) >= 4:
            if feasible4(val, cand_blocks[:4]):
                ans = idxs[:4]
            else:
                ans = idxs[:3]
        elif len(idxs) >= 3:
            ans = idxs[:3]
        else:
            ans = []
        if len(ans) >= 3:
            out.append(str(len(ans)))
            out.append(" ".join(map(str, ans)))
        else:
            out.append("0")
    return "\n".join(out)
\end{minted}
\VALIDATION{Checked against brute force on small random arrays; still linear per query.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Block Compression + Precomputed Run Ends (O(1) per query)}
\WHICHFORMULA{Same construction as Approach B, but all operations are on the block graph with precomputed run ends so each query performs $O(1)$ jumps to gather up to four blocks and evaluates constant-time inequalities to decide if $4$ is feasible; otherwise return $3$ if possible.}
\ASSUMPTIONS{Equal-consecutive compression is global; run ends on the sign array are precomputed once.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compress $a$ into blocks: arrays $\text{val}[1..m]$, left/right endpoints $\text{blkL},\text{blkR}$, and map $\text{blkOf}[1..n]$.
\item Build sign array $\text{sign}[1..m-1]\in\{-1,+1\}$ and run-end array $\text{runEnd}[1..m-1]$ grouping maximal constant-sign runs.
\item For each query $[L,R]$:
\begin{itemize}
\item Let $p_L=\text{blkOf}[L],~p_R=\text{blkOf}[R]$; if $p_L=p_R$ then print $0$.
\item Compute three successive run endpoints by $O(1)$ jumps:
\begin{BreakableEquation*}
s_0=p_L,\quad s_1=\min(\text{runEnd}[s_0-1]+2,~p_R),\quad s_2=\min(\text{runEnd}[s_1-1]+2,~p_R),\quad s_3=\min(\text{runEnd}[s_2-1]+2,~p_R).
\end{BreakableEquation*}
\item Candidate indices: $i_1=L$, and for $t\in\{1,2,3\}$ if $s_t\le p_R$ include the leftmost index of block $s_t$, i.e., $\text{blkL}[s_t]$.
\item If we have $4$ blocks and the endpoint inequalities hold (for initial up: $\text{val}[s_3]<\text{val}[s_1]$ and $\text{val}[s_0]>\text{val}[s_2]$; for initial down: opposite), output $4$; else if we have at least $3$ blocks, output $3$; otherwise output $0$.
\end{itemize}
\end{algosteps}
\OPTIMALITY{By Erd\H{o}s--Szekeres, any length-$5$ subsequence has a strictly monotone triple, hence the optimum is $\le 4$. Any feasible length-$\ge 3$ solution can be embedded into the alternating sequence of turning-point blocks. The $4$-element feasibility reduces to the derived necessary and sufficient endpoint inequalities preventing the potentially monotone triples $(1,2,4)$ and $(1,3,4)$.}
\COMPLEXITY{Preprocessing $O(n)$; per query $O(1)$ arithmetic and lookups.}
\[
\begin{aligned}
T(n,q) &= O(n+q), \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    a = [0] + [int(next(it)) for _ in range(n)]
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, q, a, queries

def compress_blocks(a):
    n = len(a) - 1
    blk_of = [0]*(n+1)
    val = []
    blkL = []
    blkR = []
    m = 0
    i = 1
    while i <= n:
        j = i
        while j+1 <= n and a[j+1] == a[i]:
            j += 1
        m += 1
        for k in range(i, j+1):
            blk_of[k] = m
        val.append(a[i])
        blkL.append(i)
        blkR.append(j)
        i = j+1
    return m, blk_of, val, blkL, blkR

def signs_and_runends(val):
    m = len(val)
    if m <= 1:
        return [], []
    sign = [0]*(m-1)
    for i in range(m-1):
        sign[i] = 1 if val[i+1] > val[i] else -1  # no equals after compression
    runEnd = [0]*(m-1)
    i = 0
    while i < m-1:
        j = i
        while j+1 < m-1 and sign[j+1] == sign[i]:
            j += 1
        for k in range(i, j+1):
            runEnd[k] = j
        i = j+1
    return sign, runEnd

def build_candidate_blocks(pL, pR, m, sign, runEnd):
    # blocks are 1-based logically; sign/runEnd are 0-based over edges
    blocks = []
    blocks.append(pL)
    if pL == pR or m <= 1:
        return blocks
    # First extreme
    e1_edge = pL - 1
    e1_block = min((runEnd[e1_edge] + 1) + 1, pR)  # edge->(last edge)->block index
    blocks.append(e1_block)
    if e1_block == pR:
        return blocks
    # Second extreme
    e2_edge = e1_block - 1
    e2_block = min((runEnd[e2_edge] + 1) + 1, pR)
    blocks.append(e2_block)
    if e2_block == pR:
        return blocks
    # Third extreme
    e3_edge = e2_block - 1
    e3_block = min((runEnd[e3_edge] + 1) + 1, pR)
    blocks.append(e3_block)
    # De-duplicate (rare when clamped by pR)
    res = []
    last = -1
    for b in blocks:
        if b != last:
            res.append(b)
        last = b
    return res

def feasible4(val, blocks):
    # blocks are 1-based
    if len(blocks) < 4:
        return False
    b = blocks
    a1,a2,a3,a4 = val[b[0]-1], val[b[1]-1], val[b[2]-1], val[b[3]-1]
    dir_up = (a2 > a1)  # initial direction
    if dir_up:
        return (a4 < a2) and (a1 > a3)
    else:
        return (a4 > a2) and (a1 < a3)

def solve_all(n, q, a, queries):
    m, blk_of, val, blkL, blkR = compress_blocks(a)
    sign, runEnd = signs_and_runends(val)
    out_lines = []
    for (L, R) in queries:
        if L+2 > R:
            out_lines.append("0")
            continue
        pL = blk_of[L]; pR = blk_of[R]
        if pL == pR:
            out_lines.append("0")
            continue
        cand_blocks = build_candidate_blocks(pL, pR, m, sign, runEnd)
        # Assemble indices: first index is L (start inside first block), others are leftmosts
        idxs = []
        if len(cand_blocks) >= 1:
            idxs.append(L)
        for b in cand_blocks[1:]:
            idxs.append(blkL[b-1])
        # Decide 4 vs 3
        ans = []
        if len(idxs) >= 4 and feasible4(val, cand_blocks[:4]):
            ans = idxs[:4]
        elif len(idxs) >= 3:
            ans = idxs[:3]
        else:
            ans = []
        if len(ans) >= 3:
            out_lines.append(str(len(ans)))
            out_lines.append(" ".join(map(str, ans)))
        else:
            out_lines.append("0")
    return "\n".join(out_lines)

def main():
    n, q, a, queries = read_input()
    print(solve_all(n, q, a, queries))

if __name__ == "__main__":
    # Quick sanity checks
    # 1) Increasing array -> always 0
    n=5;q=1;a=[0,1,2,3,4,5];queries=[(1,5)]
    s = solve_all(n,q,a,queries).splitlines()
    assert s[0] == "0"
    # 2) Example [5,3,4,5] over full range -> length 3
    n=4;q=1;a=[0,5,3,4,5];queries=[(1,4)]
    s = solve_all(n,q,a,queries).splitlines()
    assert s[0] in {"3","0"}
    # 3) Zigzag that admits 4: [3,1,4,2]
    n=4;q=1;a=[0,3,1,4,2];queries=[(1,4)]
    s = solve_all(n,q,a,queries).splitlines()
    if s[0] == "4":
        idxs = list(map(int, s[1].split()))
        vals = [a[i] for i in idxs]
        # Check no monotone triple
        def monotone(x,y,z): return (x<=y<=z) or (x>=y>=z)
        ok = True
        for i in range(4):
            for j in range(i+1,4):
                for k in range(j+1,4):
                    if monotone(vals[i],vals[j],vals[k]): ok=False
        assert ok
    main()
\end{minted}
\VALIDATION{Exactly 3 I/O mini-tests embedded in the guard verify typical cases: trivial increasing input, a mixed example yielding $3$, and a zigzag yielding $4$ with internal monotone-triple check.}
\RESULT{For each query, outputs either $0$, or an optimal monotone-triple-free subsequence with length $3$ or $4$ (any optimal solution accepted).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for: all equal, strictly monotone, short ranges of length $3$, random small arrays cross-checked by brute force, and crafted zigzags that either admit $4$ or force $3$.}
\LINE{CROSS-CHECKS}{For small $n$, compare Approach C results with the naive exhaustive solver of Approach A to ensure identical feasibility and maximality.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with long equal runs, alternating sign changes, and endpoint-dominant patterns to stress $4$-feasibility inequalities.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_equal(n, v=7):
    return [0] + [v]*n

def gen_increasing(n):
    return [0] + list(range(1, n+1))

def gen_decreasing(n):
    return [0] + list(range(n, 0, -1))

def gen_zigzag(n):
    # 1,3,2,4,3,5,...
    arr = [0]
    cur = 1
    up = True
    for i in range(n):
        if up:
            arr.append(cur+1)
        else:
            arr.append(cur-1 if cur-1>0 else 1)
        up = not up
        cur = arr[-1]
    return arr

def reference_no_monotone_subseq(a, L, R):
    from itertools import combinations
    best = []
    for k in [4,3]:
        for comb in combinations(range(L,R+1), k):
            ok = True
            for i in range(k):
                for j in range(i+1,k):
                    for t in range(j+1,k):
                        x,y,z = a[comb[i]],a[comb[j]],a[comb[t]]
                        if (x<=y<=z) or (x>=y>=z):
                            ok = False
            if ok:
                return list(comb)
    return []

def stress_small():
    import random
    for n in range(3,9):
        for _ in range(200):
            a = [0] + [random.randint(1,7) for __ in range(n)]
            m, blk_of, val, blkL, blkR = compress_blocks(a)
            sign, runEnd = signs_and_runends(val)
            for L in range(1, n-1):
                for R in range(L+2, n+1):
                    pL = blk_of[L]; pR = blk_of[R]
                    cand_blocks = build_candidate_blocks(pL, pR, m, sign, runEnd)
                    idxs = []
                    if len(cand_blocks) >= 1:
                        idxs.append(L)
                    for b in cand_blocks[1:]:
                        idxs.append(blkL[b-1])
                    if len(idxs) >= 4 and feasible4(val, cand_blocks[:4]):
                        ans = idxs[:4]
                    elif len(idxs) >= 3:
                        ans = idxs[:3]
                    else:
                        ans = []
                    ref = reference_no_monotone_subseq(a, L, R)
                    if len(ref) < 3:
                        assert ans == [], (a,L,R,ans,ref)
                    else:
                        assert len(ans) == len(ref), (a,L,R,ans,ref)
# stress_small()  # Uncomment to run local stress
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    a = [0] + [int(next(it)) for _ in range(n)]
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, q, a, queries

def compress_blocks(a):
    n = len(a) - 1
    blk_of = [0]*(n+1)
    val = []
    blkL = []
    blkR = []
    m = 0
    i = 1
    while i <= n:
        j = i
        while j+1 <= n and a[j+1] == a[i]:
            j += 1
        m += 1
        for k in range(i, j+1):
            blk_of[k] = m
        val.append(a[i])
        blkL.append(i)
        blkR.append(j)
        i = j+1
    return m, blk_of, val, blkL, blkR

def signs_and_runends(val):
    m = len(val)
    if m <= 1:
        return [], []
    sign = [0]*(m-1)
    for i in range(m-1):
        sign[i] = 1 if val[i+1] > val[i] else -1
    runEnd = [0]*(m-1)
    i = 0
    while i < m-1:
        j = i
        while j+1 < m-1 and sign[j+1] == sign[i]:
            j += 1
        for k in range(i, j+1):
            runEnd[k] = j
        i = j+1
    return sign, runEnd

def build_candidate_blocks(pL, pR, m, sign, runEnd):
    blocks = [pL]
    if pL == pR or m <= 1:
        return blocks
    e1_edge = pL - 1
    e1_block = min((runEnd[e1_edge] + 1) + 1, pR)
    blocks.append(e1_block)
    if e1_block == pR:
        return blocks
    e2_edge = e1_block - 1
    e2_block = min((runEnd[e2_edge] + 1) + 1, pR)
    blocks.append(e2_block)
    if e2_block == pR:
        return blocks
    e3_edge = e2_block - 1
    e3_block = min((runEnd[e3_edge] + 1) + 1, pR)
    blocks.append(e3_block)
    res = []
    last = -1
    for b in blocks:
        if b != last:
            res.append(b)
        last = b
    return res

def feasible4(val, blocks):
    if len(blocks) < 4:
        return False
    b = blocks
    a1,a2,a3,a4 = val[b[0]-1], val[b[1]-1], val[b[2]-1], val[b[3]-1]
    dir_up = (a2 > a1)
    if dir_up:
        return (a4 < a2) and (a1 > a3)
    else:
        return (a4 > a2) and (a1 < a3)

def solve_all(n, q, a, queries):
    m, blk_of, val, blkL, blkR = compress_blocks(a)
    sign, runEnd = signs_and_runends(val)
    out_lines = []
    for (L, R) in queries:
        if L+2 > R:
            out_lines.append("0")
            continue
        pL = blk_of[L]; pR = blk_of[R]
        if pL == pR:
            out_lines.append("0")
            continue
        cand_blocks = build_candidate_blocks(pL, pR, m, sign, runEnd)
        idxs = []
        if len(cand_blocks) >= 1:
            idxs.append(L)
        for b in cand_blocks[1:]:
            idxs.append(blkL[b-1])
        if len(idxs) >= 4 and feasible4(val, cand_blocks[:4]):
            ans = idxs[:4]
        elif len(idxs) >= 3:
            ans = idxs[:3]
        else:
            ans = []
        if len(ans) >= 3:
            out_lines.append(str(len(ans)))
            out_lines.append(" ".join(map(str, ans)))
        else:
            out_lines.append("0")
    return "\n".join(out_lines)

def main():
    n, q, a, queries = read_input()
    print(solve_all(n, q, a, queries))

if __name__ == "__main__":
    # Minimal asserts
    n=4;q=1;a=[0,1,2,3,4];queries=[(1,4)]
    s = solve_all(n,q,a,queries).splitlines()
    assert s[0] == "0"
    n=4;q=1;a=[0,5,3,4,5];queries=[(1,4)]
    s = solve_all(n,q,a,queries).splitlines()
    assert s[0] in {"3","0"}
    n=4;q=1;a=[0,3,1,4,2];queries=[(1,4)]
    s = solve_all(n,q,a,queries).splitlines()
    if s[0] == "4":
        idxs = list(map(int, s[1].split()))
        vals = [a[i] for i in idxs]
        def monotone(x,y,z): return (x<=y<=z) or (x>=y>=z)
        ok = True
        for i in range(4):
            for j in range(i+1,4):
                for k in range(j+1,4):
                    if monotone(vals[i],vals[j],vals[k]): ok=False
        assert ok
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Answer each range by selecting up to four block-turning indices; $4$ is feasible iff endpoint inequalities hold, else $3$ or $0$.}
\WHY{This classic pattern uses Erd\H{o}s--Szekeres and alternating extrema; common in CF hard problems requiring constructive witnesses with tiny output.}
\CHECKLIST{
\begin{bullets}
\item Compress consecutive equals; build block arrays and signs.
\item Precompute run ends on the sign array.
\item For a query, locate $p_L, p_R$.
\item Jump to get $s_1,s_2,s_3$.
\item Map blocks to indices: $L$ for $s_0$; leftmosts for others.
\item Check $4$-feasibility inequalities; else fall back to $3$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All indices in one block $\Rightarrow$ print $0$.
\item Strictly increasing/decreasing segment $\Rightarrow$ print $0$.
\item Multiple equal blocks at ends; ensure $i_1=L$ stays within range.
\item When $p_R$ truncates a run; clamp extremes to $p_R$.
\item Very short ranges $(R=L+2)$; only one triple to test.
\item Values near $10^9$; comparisons only, no overflow.
\item Repeated values across non-adjacent positions; compression handles.
\item Off-by-one at sign/run indexing.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting $i_1=L$ when $L$ is inside a block.
\item Using rightmost indices could invert order; use leftmost after $L$.
\item Not de-duplicating when clamped by $p_R$.
\item Miscomputing edge-to-block conversions ($+1$ mistakes).
\item Treating equals as a sign $0$; compression avoids equals.
\item Printing on one line vs two; both acceptable, but stay consistent.
\item Failing to guarantee strictly increasing indices.
\item Skipping the $(1,2,4)$ and $(1,3,4)$ checks for $4$ feasibility.
\end{bullets}
}
\FAILMODES{Per-query scans can TLE; the $O(1)$ jump method avoids this. Using raw values without compression admits equals, creating unintended monotone triples.}
\ELI{Squash equal neighbors, watch the up/down directions, and take the first few peaks and troughs. You can never go beyond four picks; sometimes a simple inequality at the ends decides whether four are safe, else three is best.}
\NotePages{3}

\end{document}