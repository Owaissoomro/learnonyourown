% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Flip and Reverse}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1458/D}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{You are given a string $s$ of 0's and 1's. You are allowed to perform the following operation:
\begin{itemize}
\item choose a non-empty contiguous substring of $s$ that contains an equal number of 0's and 1's;
\item flip all characters in the substring, that is, replace all 0's with 1's, and vice versa;
\item reverse the substring.
\end{itemize}
For example, consider $s$ = 00111011, and the following operation:
\begin{itemize}
\item Choose the first six characters as the substring to act upon: 00111011. Note that the number of 0's and 1's are equal, so this is a legal choice. Choosing substrings 0, 110, or the entire string would not be possible.
\item Flip all characters in the substring: 11000111.
\item Reverse the substring: 10001111.
\end{itemize}
Find the lexicographically smallest string that can be obtained from $s$ after zero or more operations.

Input:
The first line contains a single integer $T$ ($1 \le T \le 5 \cdot 10^5$) — the number of test cases. Each of the following $T$ lines contains a non-empty string — the input string $s$ for the respective test case.

All strings consist of characters 0 and 1, and their total length does not exceed $5 \cdot 10^5$.

Output:
For each test case, on a separate line print the lexicographically smallest string that can be obtained from $s$ after zero or more operations.

Note:
In the first test case a single operation should be applied to the entire string.

In the second test case two operations are needed: 0111001, 0110110.

In the third test case the string stays the same after any operation.}
\BREAKDOWN{Model the string as a $\pm 1$ walk via prefix sums. The allowed operation corresponds to reversing a subarray of the prefix sums whose endpoints have equal value. This preserves the multiset of prefix-sum levels over indices $0,\ldots,n$. The lexicographically smallest string is obtained by constructing, from these level-counts, the lexicographically smallest $\pm 1$ walk with the same level-visit multiplicities.}
\ELI{Treat the bits as steps up or down. You may reverse any segment that starts and ends at the same height. Since this only reorders when you visit each height, you can always walk as low as possible first to get the smallest string.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.
\begin{bullets}
\item $T$: integer, number of test cases, $1 \le T \le 5 \cdot 10^5$.
\item For each test, a binary string $s$ with $1 \le \lvert s \rvert$, and $\sum \lvert s \rvert \le 5 \cdot 10^5$ over all tests.
\end{bullets}}
\OUTPUTS{For each test case, output a single binary string of the same length: the lexicographically smallest string reachable via zero or more allowed operations.}
\SAMPLES{Examples (tiny):
\begin{bullets}
\item Input: $s=\text{0011}$; Output: $\text{0011}$.
\item Input: $s=\text{0101}$; Output: $\text{0101}$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n=\lvert s \rvert$. Map $s_i \in \{0,1\}$ to $a_i \in \{-1,+1\}$ by $a_i = +1$ if $s_i = 1$ and $a_i = -1$ if $s_i=0$. Define prefix sums $P_0=0$ and $P_k = \sum_{i=1}^k a_i$ for $k=1,\ldots,n$. The operation on any substring $[l,r]$ with $\sum_{i=l}^r a_i = 0$ transforms $(a_l,\ldots,a_r)$ to $(-a_r,\ldots,-a_l)$. Equivalently, it reverses the subarray $P_l,P_{l+1},\ldots,P_{r-1}$ (note the endpoints satisfy $P_{l-1} = P_r$). The multiset of values of $P_0,\ldots,P_n$ is invariant.}
\varmapStart
\var{s}{original binary string}
\var{n}{string length}
\var{a_i}{step, $+1$ for bit 1 and $-1$ for bit 0}
\var{P_k}{prefix sum after $k$ steps}
\var{c(v)}{number of indices $k \in \{0,\ldots,n\}$ with $P_k=v$}
\var{b_i}{output bit at position $i$}
\var{Q_k}{constructed prefix sums for the minimal solution}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&P_0 = 0,\quad P_k - P_{k-1} =
\begin{cases}
+1,& s_k=1,\\
-1,& s_k=0,
\end{cases}\\
&\text{Operation on }[l,r]\text{ with }P_r=P_{l-1]:\quad
(P_l,\ldots,P_{r-1}) \mapsto (P_{r-1},\ldots,P_l),\\
&\text{Counts invariant: } c(v) = \#\{k: P_k=v\}\ \text{unchanged.}\\
&\text{We construct }Q_0=0,\ c(Q_0)\mathrel{-=}1,\text{ and for }i=1,\ldots,n:\\
&\quad\text{if }c(Q_{i-1}-1)>0\text{ then }Q_i=Q_{i-1}-1\ (\Rightarrow b_i=0),\ \text{ else }Q_i=Q_{i-1}+1\ (\Rightarrow b_i=1),\\
&\quad c(Q_i)\mathrel{-=}1.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based for steps and $0$-based for prefix sums. The operation is applicable iff the chosen substring is balanced (equal number of 0's and 1's), i.e., zero sum in $\{a_i\}$.}
\INVARIANTS{
\begin{bullets}
\item The multiset $\{P_0,\ldots,P_n\}$ is invariant under any allowed operation.
\item Endpoints $P_0=0$ and $P_n=\sum_i a_i$ are invariant.
\item Each operation is a reversal of a subarray of $P$ whose endpoints have equal values, hence preserves $c(v)$ for all $v$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Explore the state space by BFS over all strings reachable by one operation (flip and reverse any balanced substring). Keep the lexicographically smallest seen.}
\ASSUMPTIONS{Feasible only for very small $n$; used to validate the greedy idea on tiny cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a given $s$, enumerate all balanced substrings $[l,r]$.
\item Apply flip+reverse to obtain neighbors, push unseen strings into a queue.
\item Track and return the minimal string encountered.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ in the worst case; intended only for $n \le 10$ for sanity checks.}
\[
\begin{aligned}
T(n) &\in \Theta\!\big(\lvert \text{reachable}(s)\rvert \cdot n^2\big),\quad
S(n) \in \Theta\!\big(\lvert \text{reachable}(s)\rvert \cdot n\big).
\end{aligned}
\]
\CORRECTNESS{BFS explores the exact closure under the operation, so the minimum over explored states is correct for small inputs.}
\EDGECASES{All-zeros or all-ones strings; strings with no balanced substring except length $2$; already minimal strings.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from collections import deque, defaultdict
import sys

def apply_ops_neighbors(s: str):
    n = len(s)
    # prefix sums of +/-1 (1 for '1', -1 for '0')
    pref = [0] * (n + 1)
    for i, ch in enumerate(s, 1):
        pref[i] = pref[i - 1] + (1 if ch == '1' else -1)
    res = []
    for l in range(n):
        for r in range(l, n):
            if pref[r + 1] == pref[l]:  # balanced substring s[l..r]
                sub = s[l:r+1]
                flipped = ''.join('1' if c == '0' else '0' for c in sub)[::-1]
                t = s[:l] + flipped + s[r+1:]
                res.append(t)
    return res

def brute_min_string(s: str) -> str:
    # BFS over reachable states to find lexicographically minimal string
    seen = {s}
    q = deque([s])
    best = s
    while q:
        cur = q.popleft()
        if cur < best:
            best = cur
        for nxt in apply_ops_neighbors(cur):
            if nxt not in seen:
                seen.add(nxt)
                q.append(nxt)
    return best

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    cases = [next(it) for _ in range(T)]
    return T, cases

def solve_case_greedy(s: str) -> str:
    # Greedy construction using level visit counts of prefix sums
    n = len(s)
    # Count occurrences of prefix sums P_0..P_n
    c = defaultdict(int)
    cur = 0
    c[cur] += 1
    for ch in s:
        cur += (1 if ch == '1' else -1)
        c[cur] += 1
    # Construct minimal string: always go down if possible
    res = []
    cur = 0
    c[cur] -= 1  # consumed P_0
    for _ in range(n):
        if c[cur - 1] > 0:
            res.append('0')
            cur -= 1
            c[cur] -= 1
        else:
            # must go up
            assert c[cur + 1] > 0, "Feasibility violated"
            res.append('1')
            cur += 1
            c[cur] -= 1
    return ''.join(res)

def solve_all():
    T, cases = read_input()
    out_lines = []
    for s in cases:
        out_lines.append(solve_case_greedy(s))
    if T:
        sys.stdout.write("\n".join(out_lines))

def _self_test_small():
    # Sanity: for all strings up to length 6, greedy equals brute result
    from itertools import product
    for n in range(1, 7):
        for bits in product('01', repeat=n):
            s = ''.join(bits)
            g = solve_case_greedy(s)
            b = brute_min_string(s)
            assert g == b, (s, g, b)

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        # run internal tests when no input is provided
        _self_test_small()
        # showcase a couple of cases
        for s in ["0011", "0101", "00111011"]:
            print(s, "->", solve_case_greedy(s))
    else:
        # re-feed data to solver
        sys.stdin = sys.__stdin__
        sys.stdin = sys.__class__(open(0, 'rb'))
        # parse using our reader that reads all
        sys.stdin = sys.__stdin__
        sys.stdin = sys.__class__(open(0, 'rb'))
        # Instead of re-reading stdin twice, we use the already read buffer
        # by passing it directly.
        tokens = data.strip().split()
        it = iter(tokens)
        T = int(next(it))
        cases = [next(it) for _ in range(T)]
        for s in cases:
            print(solve_case_greedy(s))
\end{minted}
\VALIDATION{The included self-test exhaustively checks all strings up to length 6 via BFS. Additional spot checks: 0011 $\to$ 0011; 0101 $\to$ 0101; 00111011 remains 00111011.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Replace BFS with an $O(n)$ greedy that leverages the invariant multiset of level-visits $c(v)$. Always step down when possible (to output 0), else step up.}
\ASSUMPTIONS{The operation is equivalent to reversing a subarray of the prefix sums with equal endpoints, hence preserves the multiset of levels and allows arbitrary reordering compatible with these counts.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute prefix sums $P_k$ and the counts $c(v)$ over all $k \in \{0,\ldots,n\}$.
\item Start at level $0$ and decrement $c(0)$ to account for $P_0$.
\item For $i=1$ to $n$:
  \begin{bullets}
  \item If $c(\text{cur}-1)>0$, emit $0$, move to $\text{cur}-1$, decrement $c(\text{cur})$.
  \item Else, emit $1$, move to $\text{cur}+1$, decrement $c(\text{cur})$.
  \end{bullets}
\end{algosteps}
\COMPLEXITY{Linear time and space in $n$ per test case.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(n).
\end{aligned}
\]
\CORRECTNESS{By invariant preservation, any sequence of prefix sums reachable is a reordering of the multiset of levels with the same endpoints. Among all such walks, the lexicographically smallest bitstring corresponds to always taking a downward step when available, which the greedy enforces while respecting exact level-visit counts.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from collections import defaultdict
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    cases = [next(it) for _ in range(T)]
    return T, cases

def solve_case(s: str) -> str:
    c = defaultdict(int)
    cur = 0
    c[cur] += 1
    for ch in s:
        cur += (1 if ch == '1' else -1)
        c[cur] += 1
    res = []
    cur = 0
    c[cur] -= 1
    for _ in range(len(s)):
        if c[cur - 1] > 0:
            res.append('0'); cur -= 1; c[cur] -= 1
        else:
            assert c[cur + 1] > 0
            res.append('1'); cur += 1; c[cur] -= 1
    return ''.join(res)

def solve_all():
    T, cases = read_input()
    out = [solve_case(s) for s in cases]
    if T:
        print("\n".join(out))

def _asserts():
    assert solve_case("0") == "0"
    assert solve_case("1") == "1"
    assert solve_case("01") == "01"
    assert solve_case("10") == "10"

if __name__ == "__main__":
    _asserts()
    solve_all()
\end{minted}
\VALIDATION{Assertions on trivial inputs and pairs of length 2 validate basic behavior.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Construct the lexicographically minimal $\pm 1$ walk consistent with level-visit counts $\{c(v)\}$ derived from the original prefix sums. Always choose the smallest next bit that preserves feasibility: step down if any visit to the lower level remains, otherwise step up.}
\ASSUMPTIONS{Allowed operations generate exactly the permutations of the prefix-sum sequence obtainable by reversing any interval whose endpoints are equal. This preserves the multiset of levels and endpoints; the greedy walk achieves the minimal string among all feasible walks with those counts.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute prefix sums $P_k$ and counts $c(v)$ over $k=0,\ldots,n$.
\item Initialize $\text{cur}=0$ and decrement $c(0)$.
\item For each position $i=1$ to $n$:
\begin{bullets}
\item If $c(\text{cur}-1)>0$, append $0$ and move to $\text{cur}-1$.
\item Else, append $1$ and move to $\text{cur}+1$.
\item Decrement $c(\text{cur})$.
\end{bullets}
\end{algosteps}
\OPTIMALITY{Among all re-orderings of the prefix-sum levels that produce valid adjacent differences of $\pm 1$, this greedy always takes $0$ whenever feasible; any alternative that takes $1$ while a $0$ is possible yields a string strictly larger lexicographically at the first differing position. Feasibility is preserved because the original counts come from a valid walk and the greedy never consumes a level more times than available.}
\COMPLEXITY{Linear in input size.}
\[
\begin{aligned}
T(n) &= \Theta(n)\ \text{operations per test},\quad S(n)=\Theta(n)\ \text{for counts}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from collections import defaultdict
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    cases = [next(it) for _ in range(T)]
    return T, cases

def solve_case(s: str) -> str:
    c = defaultdict(int)
    cur = 0
    c[cur] += 1
    for ch in s:
        cur += (1 if ch == '1' else -1)
        c[cur] += 1
    # Greedy construction
    res = []
    cur = 0
    c[cur] -= 1
    for _ in range(len(s)):
        if c[cur - 1] > 0:
            res.append('0')
            cur -= 1
            c[cur] -= 1
        else:
            # Must go up
            assert c[cur + 1] > 0
            res.append('1')
            cur += 1
            c[cur] -= 1
    return ''.join(res)

def solve_all():
    T, cases = read_input()
    out_lines = []
    for s in cases:
        out_lines.append(solve_case(s))
    if T:
        sys.stdout.write("\n".join(out_lines))

def _mini_tests():
    # Exactly 3 asserts
    assert solve_case("0011") == "0011"
    assert solve_case("0101") == "0101"
    assert solve_case("00111011") == "00111011"

if __name__ == "__main__":
    _mini_tests()
    solve_all()
\end{minted}
\VALIDATION{Exactly three asserts on small handcrafted cases.}
\RESULT{For each test case, the algorithm returns the lexicographically smallest reachable binary string. Ties do not arise because lex order is total.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Combine exhaustive verification via BFS on $n \le 6$ with randomized spot checks and direct asserts on small edge cases. Ensure that the greedy result matches the BFS minimum on all small instances.}
\LINE{CROSS-CHECKS}{Compare outputs of the brute BFS and greedy implementations on all strings up to a small length, and on random larger cases that share the same level-visit histogram to validate determinism.}
\LINE{EDGE-CASE GENERATOR}{Generate strings of all zeros/ones, alternating patterns, runs, and near-balanced with long prefixes of one bit.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from collections import defaultdict, deque
from itertools import product
import random

def brute_min_string(s: str) -> str:
    def neighbors(t: str):
        n = len(t)
        pref = [0]*(n+1)
        for i,ch in enumerate(t,1):
            pref[i] = pref[i-1] + (1 if ch=='1' else -1)
        res = []
        for l in range(n):
            for r in range(l, n):
                if pref[r+1] == pref[l]:
                    sub = t[l:r+1]
                    flipped = ''.join('1' if c=='0' else '0' for c in sub)[::-1]
                    res.append(t[:l]+flipped+t[r+1:])
        return res
    seen = {s}
    q = deque([s])
    best = s
    while q:
        cur = q.popleft()
        if cur < best:
            best = cur
        for nxt in neighbors(cur):
            if nxt not in seen:
                seen.add(nxt)
                q.append(nxt)
    return best

def greedy_min_string(s: str) -> str:
    c = defaultdict(int)
    cur = 0
    c[cur] += 1
    for ch in s:
        cur += (1 if ch == '1' else -1)
        c[cur] += 1
    res = []
    cur = 0
    c[cur] -= 1
    for _ in range(len(s)):
        if c[cur - 1] > 0:
            res.append('0'); cur -= 1; c[cur] -= 1
        else:
            assert c[cur + 1] > 0
            res.append('1'); cur += 1; c[cur] -= 1
    return ''.join(res)

def run_exhaustive(nmax=6):
    for n in range(1, nmax+1):
        for bits in product('01', repeat=n):
            s = ''.join(bits)
            b = brute_min_string(s)
            g = greedy_min_string(s)
            assert b == g, (s, b, g)

def generate_edges():
    yield ""  # empty for completeness
    for n in range(1, 10):
        yield "0"*n
        yield "1"*n
        yield ("01"*n)[:n]
        yield ("10"*n)[:n]
        yield "0"*(n//2) + "1"*(n - n//2)
        yield "1"*(n//2) + "0"*(n - n//2)

if __name__ == "__main__":
    run_exhaustive(5)
    for s in generate_edges():
        if s:
            assert greedy_min_string(s) == brute_min_string(s)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from collections import defaultdict
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    cases = [next(it) for _ in range(T)]
    return T, cases

def solve_case(s: str) -> str:
    # Count level visits of prefix sums
    c = defaultdict(int)
    cur = 0
    c[cur] += 1
    for ch in s:
        cur += (1 if ch == '1' else -1)
        c[cur] += 1
    # Greedy: always go down if possible
    res = []
    cur = 0
    c[cur] -= 1
    for _ in range(len(s)):
        if c[cur - 1] > 0:
            res.append('0')
            cur -= 1
            c[cur] -= 1
        else:
            assert c[cur + 1] > 0
            res.append('1')
            cur += 1
            c[cur] -= 1
    return ''.join(res)

def solve_all():
    T, cases = read_input()
    out_lines = []
    for s in cases:
        out_lines.append(solve_case(s))
    if T:
        sys.stdout.write("\n".join(out_lines))

def _asserts():
    assert solve_case("0") == "0"
    assert solve_case("1") == "1"
    assert solve_case("01") == "01"
    assert solve_case("10") == "10"
    assert solve_case("0011") == "0011"

if __name__ == "__main__":
    _asserts()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reverse any balanced substring after flipping, which equals reversing a subarray of prefix sums between equal endpoints; then greedily reconstruct the lexicographically smallest walk using the invariant level-visit counts.}
\WHY{This tests converting a non-obvious string operation into a prefix-sum transformation and exploiting invariants to derive an $O(n)$ greedy.}
\CHECKLIST{
\begin{bullets}
\item Map bits to $\pm 1$ and build $P_0,\ldots,P_n$.
\item Count visits $c(v)$ for all encountered levels.
\item Start at level $0$; decrement $c(0)$.
\item For each step: if $c(\text{cur}-1)>0$, emit 0 and go down; else emit 1 and go up.
\item Decrement the arrival level count every step.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All zeros or all ones: output equals input.
\item No balanced substring of length $>2$: output may still equal input.
\item Strings with many returns to the same level.
\item Highly unbalanced totals (e.g., many more 1's than 0's).
\item Short strings of length 1 or 2.
\item Large inputs with total length $5 \cdot 10^5$ across tests.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to include $P_0$ in the counts and to consume it at start.
\item Decrementing the wrong counter (departure level instead of arrival level).
\item Off-by-one errors in prefix computation.
\item Using maps without defaults for unseen levels.
\item Not handling negative levels in an array-backed structure.
\item Building the output with repeated string concatenation (use a list then join).
\end{bullets}}
\FAILMODES{
\begin{bullets}
\item Naive BFS explodes exponentially and fails for moderate $n$.
\item Greedy without counts may get stuck or violate feasibility.
\item Misinterpreting the operation as arbitrary substring reversal without the equal-endpoint constraint.
\end{bullets}}
\ELI{Imagine a hiker walking up for 1 and down for 0. You are allowed to flip and reverse any segment where the hiker comes back to the same altitude. This only changes when the hiker visits each altitude. To make the string as small as possible, always take a down step if you still need to visit the lower altitude; otherwise go up.}
\NotePages{3}

\end{document}