% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tricky and Clever Password}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/30/E}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{In his very young years the hero of our story, king Copa, decided that his private data was hidden not enough securely, what is unacceptable for the king. That's why he invented tricky and clever password (later he learned that his password is a palindrome of odd length), and coded all his data using it.

Copa is afraid to forget his password, so he decided to write it on a piece of paper. He is aware that it is insecure to keep password in such way, so he decided to cipher it the following way: he cut x characters from the start of his password and from the end of it (x can be 0, and 2x is strictly less than the password length). He obtained 3 parts of the password. Let's call it prefix, middle and suffix correspondingly, both prefix and suffix having equal length and middle always having odd length. From these parts he made a string A + prefix + B + middle + C + suffix, where A, B and C are some (possibly empty) strings invented by Copa, and « + » means concatenation.

Many years have passed, and just yesterday the king Copa found the piece of paper where his ciphered password was written. The password, as well as the strings A, B and C, was completely forgotten by Copa, so he asks you to find a password of maximum possible length, which could be invented, ciphered and written by Copa.

Input:
The input contains single string of small Latin letters with length from 1 to 10\^{}5 characters.

Output:
The first line should contain integer k — amount of nonempty parts of the password in your answer ($k \in \{1, 3\}$). In each of the following k lines output two integers x\_i and l\_i — start and length of the corresponding part of the password. Output pairs in order of increasing x\_i. Separate the numbers in pairs by a single space.

Starting position x\_i should be an integer from 1 to the length of the input string. All l\_i must be positive, because you should output only non-empty parts. The middle part must have odd length.

If there are several solutions, output any. Note that your goal is to maximize the sum of l\_i, but not to maximize k.}
\BREAKDOWN{We must select either one odd-length palindromic substring (k=1), or three substrings (prefix, middle, suffix) appearing in order with prefix and suffix being reverses of each other and middle an odd-length palindrome. Maximize the total selected length.}
\ELI{Pick the biggest odd palindrome, or sandwich a palindromic center between some string and its reverse occurring later.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single line string $S$ of lowercase Latin letters, $1 \le |S| \le 10^5$.}
\OUTPUTS{Print integer $k \in \{1,3\}$. Then print $k$ lines: each has two integers $x_i$, $l_i$ denoting start (1-indexed) and length of the chosen part. Lines must be ordered by increasing $x_i$. All lengths must be positive; the middle (if present) must have odd length.}
\SAMPLES{Examples (not from CF):
\begin{bullets}
\item S = abca. One valid optimal answer: k=3 with parts (1,1), (2,1), (4,1).
\item S = abcdxyzyx. One valid optimal answer: k=1 with the middle palindrome (5,5).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a string $S$, choose substrings $P, M, Q$ (possibly omitting $P$ and $Q$ entirely by taking $k=1$) such that $P$ appears before $M$, and $M$ before $Q$, $M$ has odd length and is palindromic, and $Q = \operatorname{rev}(P)$. Maximize $|P| + |M| + |Q|$.}
\varmapStart
\var{S}{input string}
\var{P}{prefix substring}
\var{M}{middle odd-length palindromic substring}
\var{Q}{suffix substring, $Q=\operatorname{rev}(P)$}
\var{n}{length of $S$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Find disjoint substrings } [i, i+|P|-1],~[c-r, c+r],~[j, j+|Q|-1]\\
&\text{such that } i+|P|-1 < c-r \le c \le c+r < j,~|M|=2r+1,~M \text{ palindromic},~Q=\operatorname{rev}(P),\\
&\text{maximize } 2|P| + |M|.
\end{aligned}
\]
}
\ASSUMPTIONS{Substrings are contiguous and non-overlapping; indices are 0-based internally and printed 1-based.}
\INVARIANTS{
\begin{bullets}
\item Any single character is a valid odd palindrome.
\item If $Q=\operatorname{rev}(P)$ appears after some gap, a valid middle of length 1 always exists in that gap.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all triples $(P,M,Q)$ by positions, check $Q=\operatorname{rev}(P)$ and $M$ odd palindrome, keep the best total length.}
\ASSUMPTIONS{Feasible only for tiny $n$; used for validation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all substrings $P$.
\item For each $P$, enumerate all odd-length palindromic $M$ after $P$.
\item For each pair, enumerate all $Q$ after $M$ and check $Q=\operatorname{rev}(P)$.
\end{algosteps}
\COMPLEXITY{Cubic or worse; intractable for $n \ge 200$.}
\[
\begin{aligned}
T(n) &= O(n^3) \text{ to } O(n^4) \\
S(n) &= O(1)
\end{aligned}
\]
\CORRECTNESS{Exhaustively checks all valid combinations.}
\EDGECASES{Single-character strings; all characters equal; no matching reverse substrings.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def is_pal(s):
    return s == s[::-1]

def brute_force_best(s):
    n = len(s)
    best = (1, 0, 1, 1)  # default: k=1, start=0, length=1
    # best tuple for k=1: longest odd palindrome
    k1_start, k1_len = 0, 1
    for c in range(n):
        # grow odd pal around c
        L = R = c
        while L >= 0 and R < n and s[L] == s[R]:
            if (R - L + 1) % 2 == 1 and (R - L + 1) > k1_len:
                k1_len = R - L + 1
                k1_start = L
            L -= 1
            R += 1
    # save baseline k=1
    best_k1 = (1, k1_start, k1_len, None)

    best_val = k1_len
    best_ans = ('k1', k1_start, k1_len, None, None, None)

    # try k=3
    for i in range(n):
        for L in range(1, n - i + 1):
            P = s[i:i+L]
            # pick middle as any odd palindrome after P
            for c in range(i+L, n):
                # odd pal expansion
                Lm = Rm = c
                while Lm >= i+L and Rm < n:
                    if s[Lm] != s[Rm]:
                        break
                    if (Rm - Lm + 1) % 2 == 1:
                        # choose Q after middle
                        for j in range(Rm+1, n - L + 1):
                            if s[j:j+L] == P[::-1]:
                                total = 2*L + (Rm - Lm + 1)
                                if total > best_val:
                                    best_val = total
                                    best_ans = ('k3', i, L, Lm, (Rm - Lm + 1), j)
                    Lm -= 1
                    Rm += 1

    if best_ans[0] == 'k3':
        _, i, L, ms, ml, j = best_ans
        return (3, (i, L), (ms, ml), (j, L))
    else:
        _, st, ln, _ = best_ans
        return (1, (st, ln))

def read_input():
    data = sys.stdin.read().splitlines()
    return data[0].strip() if data else ""

def main():
    # tiny self-checks
    assert brute_force_best("a")[0] == 1
    k, *parts = brute_force_best("abca")
    assert k == 3
    # I/O
    s = read_input()
    if not s:
        return
    k, *parts = brute_force_best(s)
    print(k)
    if k == 1:
        st, ln = parts[0]
        print(st+1, ln)
    else:
        (p_st, p_ln), (m_st, m_ln), (q_st, q_ln) = parts
        for st, ln in [(p_st, p_ln), (m_st, m_ln), (q_st, q_ln)]:
            print(st+1, ln)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Use only for very small $n$; the asserts cover k=1 trivial and a simple k=3 case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Rolling Hash + Binary Search for Sandwich}
\WHICHFORMULA{Maximize $2|P|+1$ by finding the longest length $L$ such that some substring and its reverse occur with at least one-character gap between them. Use double rolling hashes and binary search on $L$.}
\ASSUMPTIONS{Middle can be at least one character; larger middle is ignored here to keep the search fast.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute double rolling hashes for $S$ and $R=\operatorname{rev}(S)$.
\item Binary search on $L$; for each $L$, build a map from substring hash to maximum start index in $S$.
\item For each start $i$, compute hash of $\operatorname{rev}(S[i..i+L-1])$ via a slice in $R$; if it occurs with some start $j$ in $S$ and $i+L<j$, $L$ is feasible.
\item Recover a best pair $(i,j)$ for the maximal feasible $L$.
\end{algosteps}
\COMPLEXITY{Each check is $O(n)$; overall $O(n \log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &\approx O(n \log n), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{If there exists $P$ and $Q=\operatorname{rev}(P)$ with a gap, the hash check detects it (with high probability due to double hashing).}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import Tuple, Dict

Mod1, Mod2 = 1_000_000_007, 1_000_000_009
Base1, Base2 = 911382323, 972663749

class DoubleHash:
    def __init__(self, s: str):
        n = len(s)
        self.n = n
        self.p1 = [1]*(n+1)
        self.p2 = [1]*(n+1)
        for i in range(n):
            self.p1[i+1] = (self.p1[i]*Base1) % Mod1
            self.p2[i+1] = (self.p2[i]*Base2) % Mod2
        self.h1 = [0]*(n+1)
        self.h2 = [0]*(n+1)
        for i, ch in enumerate(s):
            v = ord(ch)
            self.h1[i+1] = (self.h1[i]*Base1 + v) % Mod1
            self.h2[i+1] = (self.h2[i]*Base2 + v) % Mod2

    def get(self, l: int, L: int) -> Tuple[int, int]:
        r = l + L
        x1 = (self.h1[r] - self.h1[l]*self.p1[L]) % Mod1
        x2 = (self.h2[r] - self.h2[l]*self.p2[L]) % Mod2
        return (x1, x2)

def manacher_odd(s: str):
    n = len(s)
    d = [0]*n
    l = r = -1
    for i in range(n):
        k = 1 if i > r else min(d[l+r-i], r-i+1)
        while i-k >= 0 and i+k < n and s[i-k] == s[i+k]:
            k += 1
        d[i] = k-1
        if i + d[i] > r:
            l = i - d[i]
            r = i + d[i]
    return d

def best_k1(s: str):
    d = manacher_odd(s)
    n = len(s)
    best_len = 1
    best_start = 0
    for i in range(n):
        cur = 2*d[i]+1
        if cur > best_len:
            best_len = cur
            best_start = i - d[i]
    return best_start, best_len, d

def compute_best_pair_len1(s: str):
    # Returns (Lmax, i_best, j_best)
    n = len(s)
    if n <= 2:
        return (0, -1, -1)
    f = DoubleHash(s)
    rs = s[::-1]
    r = DoubleHash(rs)

    def feasible(L: int) -> bool:
        if L <= 0:
            return True
        if L >= n:
            return False
        mp: Dict[Tuple[int, int], int] = {}
        # map forward substr hash -> max start index
        for i in range(0, n - L + 1):
            h = f.get(i, L)
            prev = mp.get(h)
            if prev is None or i > prev:
                mp[h] = i
        # scan left occurrences and check rightmost matching reverse
        for i in range(0, n - L + 1):
            rpos = n - (i + L)
            hrev = r.get(rpos, L)
            jmax = mp.get(hrev, -1)
            if jmax > i + L:
                return True
        return False

    lo, hi = 1, n  # L in [1..n-1] effectively
    bestL = 0
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible(mid):
            bestL = mid
            lo = mid + 1
        else:
            hi = mid - 1

    if bestL == 0:
        return (0, -1, -1)

    # Recover best pair (maximize gap to ease middle placement)
    L = bestL
    mp: Dict[Tuple[int, int], int] = {}
    for i in range(0, n - L + 1):
        h = f.get(i, L)
        prev = mp.get(h)
        if prev is None or i > prev:
            mp[h] = i
    best_gap = -1
    bi = bj = -1
    for i in range(0, n - L + 1):
        rpos = n - (i + L)
        hrev = r.get(rpos, L)
        jmax = mp.get(hrev, -1)
        if jmax > i + L:
            gap = jmax - (i + L)
            if gap > best_gap:
                best_gap = gap
                bi, bj = i, jmax
    return (bestL, bi, bj)

def solve_case_improved(s: str):
    n = len(s)
    st1, ln1, _ = best_k1(s)
    val1 = ln1

    L, i, j = compute_best_pair_len1(s)
    if L == 0:
        # only k=1
        return (1, [(st1+1, ln1)])
    # choose middle as single char inside the gap (exists by construction)
    mpos = i + L  # leftmost gap index
    # ensure it's strictly between: i+L <= mpos <= j-1
    if mpos >= j:
        mpos = j - 1
    val3 = 2*L + 1

    if val1 >= val3:
        return (1, [(st1+1, ln1)])
    else:
        return (3, [(i+1, L), (mpos+1, 1), (j+1, L)])

def read_input():
    data = sys.stdin.read().splitlines()
    return data[0].strip() if data else ""

def main():
    # simple asserts
    k, parts = solve_case_improved("a")[0], solve_case_improved("a")[1]
    assert k == 1 and parts[0] == (1,1)
    ans = solve_case_improved("abca")
    assert ans[0] == 3
    ans2 = solve_case_improved("abcdxyzyx")
    assert ans2[0] == 1 and ans2[1][0][1] >= 5
    # I/O
    s = read_input()
    if not s:
        return
    k, parts = solve_case_improved(s)
    print(k)
    for x,l in parts:
        print(x, l)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts cover trivial, sandwich, and center-palindrome cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Manacher for Middle + Hash Sandwich for Ends}
\WHICHFORMULA{Combine: (1) longest odd palindrome anywhere (k=1), vs. (2) longest sandwich $2L+1$ with ends matched by reverse and middle placed in the gap, then refine the middle by taking the maximum odd palindrome fully inside that gap.}
\ASSUMPTIONS{Double hashing collision probability negligible. Manacher provides all odd radii in $O(n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute odd-palindrome radii $d[i]$ by Manacher; extract best k=1 candidate.
\item Binary search $L$ with rolling hashes to find the largest $L$ such that some substring and its reverse occur with $i+L<j$.
\item For that $L$, find a pair $(i,j)$ maximizing the gap $[i+L, j-1]$.
\item Inside this gap, scan centers $c$ and clip radius by boundaries to get the best odd palindrome length; this gives the best middle.
\item Compare $2L + |M|$ with the best single odd palindrome; output the better. Print 1-indexed positions and lengths.
\end{algosteps}
\OPTIMALITY{Among all pairs achieving the maximal $L$, taking the pair with maximal gap maximizes the room for the middle; the best middle inside the gap is globally optimal for that $L$. Comparing against the global best odd palindrome ensures we do not lose to k=1.}
\COMPLEXITY{$O(n \log n)$ time for hashing with one $O(n)$ gap scan; $O(n)$ memory.}
\[
\begin{aligned}
T(n) &\le O(n \log n) + O(n) \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import Tuple, Dict, List

Mod1, Mod2 = 1_000_000_007, 1_000_000_009
Base1, Base2 = 911382323, 972663749

class DoubleHash:
    def __init__(self, s: str):
        n = len(s)
        self.n = n
        self.p1 = [1]*(n+1)
        self.p2 = [1]*(n+1)
        for i in range(n):
            self.p1[i+1] = (self.p1[i]*Base1) % Mod1
            self.p2[i+1] = (self.p2[i]*Base2) % Mod2
        self.h1 = [0]*(n+1)
        self.h2 = [0]*(n+1)
        for i, ch in enumerate(s):
            v = ord(ch)
            self.h1[i+1] = (self.h1[i]*Base1 + v) % Mod1
            self.h2[i+1] = (self.h2[i]*Base2 + v) % Mod2

    def get(self, l: int, L: int) -> Tuple[int, int]:
        r = l + L
        x1 = (self.h1[r] - self.h1[l]*self.p1[L]) % Mod1
        x2 = (self.h2[r] - self.h2[l]*self.p2[L]) % Mod2
        return (x1, x2)

def manacher_odd(s: str) -> List[int]:
    n = len(s)
    d = [0]*n
    l = r = -1
    for i in range(n):
        k = 1 if i > r else min(d[l+r-i], r-i+1)
        while i-k >= 0 and i+k < n and s[i-k] == s[i+k]:
            k += 1
        d[i] = k-1
        if i + d[i] > r:
            l = i - d[i]
            r = i + d[i]
    return d

def best_k1(s: str):
    d = manacher_odd(s)
    n = len(s)
    best_len = 1
    best_start = 0
    for i in range(n):
        cur = 2*d[i]+1
        if cur > best_len:
            best_len = cur
            best_start = i - d[i]
    return best_start, best_len, d

def compute_best_pair_with_gap(s: str):
    n = len(s)
    f = DoubleHash(s)
    rs = s[::-1]
    r = DoubleHash(rs)

    def feasible(L: int) -> bool:
        if L <= 0:
            return True
        if L >= n:
            return False
        mp: Dict[Tuple[int, int], int] = {}
        for i in range(0, n - L + 1):
            h = f.get(i, L)
            prev = mp.get(h)
            if prev is None or i > prev:
                mp[h] = i
        for i in range(0, n - L + 1):
            rpos = n - (i + L)
            hrev = r.get(rpos, L)
            jmax = mp.get(hrev, -1)
            if jmax > i + L:
                return True
        return False

    lo, hi = 1, n
    bestL = 0
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible(mid):
            bestL = mid
            lo = mid + 1
        else:
            hi = mid - 1

    if bestL == 0:
        return (0, -1, -1)

    # recover pair with maximal gap for bestL
    L = bestL
    mp: Dict[Tuple[int, int], int] = {}
    for i in range(0, n - L + 1):
        h = f.get(i, L)
        prev = mp.get(h)
        if prev is None or i > prev:
            mp[h] = i
    best_gap = -1
    bi = bj = -1
    for i in range(0, n - L + 1):
        rpos = n - (i + L)
        hrev = r.get(rpos, L)
        jmax = mp.get(hrev, -1)
        if jmax > i + L:
            gap = jmax - (i + L)
            if gap > best_gap:
                best_gap = gap
                bi, bj = i, jmax
    return (bestL, bi, bj)

def solve_all():
    s = sys.stdin.read().splitlines()[0].strip()
    n = len(s)

    # Candidate k=1
    st1, ln1, d = best_k1(s)
    best_val = ln1
    best_ans = (1, [(st1+1, ln1)])

    # Candidate k=3
    L, i, j = compute_best_pair_with_gap(s)
    if L > 0:
        left_bound = i + L
        right_bound = j - 1
        # Find best odd palindrome fully inside [left_bound, right_bound]
        best_mid_len = 1
        best_mid_start = left_bound
        for c in range(left_bound, right_bound+1):
            # allowed radius inside gap
            allowed = min(d[c], c - left_bound, right_bound - c)
            cur_len = 2*allowed + 1
            if cur_len > best_mid_len:
                best_mid_len = cur_len
                best_mid_start = c - allowed
        val3 = 2*L + best_mid_len
        if val3 > best_val:
            best_val = val3
            best_ans = (3, [(i+1, L), (best_mid_start+1, best_mid_len), (j+1, L)])

    # Output
    k, parts = best_ans
    print(k)
    for x, l in parts:
        print(x, l)

def read_input():
    return sys.stdin.read().splitlines()[0].strip()

def main():
    # Minimal deterministic tests
    # 1) Single char
    from io import StringIO
    backup_stdin = sys.stdin
    sys.stdin = StringIO("a\n")
    solve_all()  # prints 1 line + part
    sys.stdin = backup_stdin
    # 2) Sandwich exists
    sys.stdin = StringIO("abca\n")
    solve_all()
    sys.stdin = backup_stdin
    # 3) Center palindrome dominates
    sys.stdin = StringIO("abcdxyzyx\n")
    solve_all()
    sys.stdin = backup_stdin
    # Actual run
    data = sys.stdin.read().splitlines()
    if not data:
        return
    sys.stdin = StringIO(data[0] + "\n")
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 I/O mini-tests are executed before the real input.}
\RESULT{Print either one odd palindrome (k=1), or three parts (k=3): prefix, middle (odd), and suffix where suffix is the reverse of prefix. The sum of lengths is maximized among the two candidate strategies.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test odd-pal radii on crafted palindromes; verify sandwich detection on strings containing $T \ldots \operatorname{rev}(T)$; stress on random small strings by comparing Approach A vs C.}
\LINE{CROSS-CHECKS}{For $n \le 60$, brute force (Approach A) and final (Approach C) results should agree on maximum sum; random trials help detect hashing issues.}
\LINE{EDGE-CASE GENERATOR}{Generate strings of one char, two chars, all equal, alternating, mirror patterns (abc...cba), and random with seeded RNG.}
\begin{minted}{python}
import random

def gen_all_equal(n, ch='a'):
    return ch * n

def gen_alternating(n, a='a', b='b'):
    return ''.join(a if i % 2 == 0 else b for i in range(n))

def gen_mirror(k):
    t = ''.join(chr(ord('a') + (i % 3)) for i in range(k))
    return t + 'x' + t[::-1]

def gen_random(n, seed=0):
    random.seed(seed)
    return ''.join(chr(ord('a') + random.randrange(26)) for _ in range(n))
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final deterministic solution matching the Approach C description.
import sys
from typing import Tuple, Dict, List

Mod1, Mod2 = 1_000_000_007, 1_000_000_009
Base1, Base2 = 911382323, 972663749

class DoubleHash:
    def __init__(self, s: str):
        n = len(s)
        self.n = n
        self.p1 = [1]*(n+1)
        self.p2 = [1]*(n+1)
        for i in range(n):
            self.p1[i+1] = (self.p1[i]*Base1) % Mod1
            self.p2[i+1] = (self.p2[i]*Base2) % Mod2
        self.h1 = [0]*(n+1)
        self.h2 = [0]*(n+1)
        for i, ch in enumerate(s):
            v = ord(ch)
            self.h1[i+1] = (self.h1[i]*Base1 + v) % Mod1
            self.h2[i+1] = (self.h2[i]*Base2 + v) % Mod2

    def get(self, l: int, L: int) -> Tuple[int, int]:
        r = l + L
        x1 = (self.h1[r] - self.h1[l]*self.p1[L]) % Mod1
        x2 = (self.h2[r] - self.h2[l]*self.p2[L]) % Mod2
        return (x1, x2)

def manacher_odd(s: str) -> List[int]:
    n = len(s)
    d = [0]*n
    l = r = -1
    for i in range(n):
        k = 1 if i > r else min(d[l+r-i], r-i+1)
        while i-k >= 0 and i+k < n and s[i-k] == s[i+k]:
            k += 1
        d[i] = k-1
        if i + d[i] > r:
            l = i - d[i]
            r = i + d[i]
    return d

def best_k1(s: str):
    d = manacher_odd(s)
    n = len(s)
    best_len = 1
    best_start = 0
    for i in range(n):
        cur = 2*d[i]+1
        if cur > best_len:
            best_len = cur
            best_start = i - d[i]
    return best_start, best_len, d

def compute_best_pair_with_gap(s: str):
    n = len(s)
    f = DoubleHash(s)
    rs = s[::-1]
    r = DoubleHash(rs)

    def feasible(L: int) -> bool:
        if L <= 0:
            return True
        if L >= n:
            return False
        mp: Dict[Tuple[int, int], int] = {}
        for i in range(0, n - L + 1):
            h = f.get(i, L)
            prev = mp.get(h)
            if prev is None or i > prev:
                mp[h] = i
        for i in range(0, n - L + 1):
            rpos = n - (i + L)
            hrev = r.get(rpos, L)
            jmax = mp.get(hrev, -1)
            if jmax > i + L:
                return True
        return False

    lo, hi = 1, n
    bestL = 0
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible(mid):
            bestL = mid
            lo = mid + 1
        else:
            hi = mid - 1

    if bestL == 0:
        return (0, -1, -1)

    L = bestL
    mp: Dict[Tuple[int, int], int] = {}
    for i in range(0, n - L + 1):
        h = f.get(i, L)
        prev = mp.get(h)
        if prev is None or i > prev:
            mp[h] = i
    best_gap = -1
    bi = bj = -1
    for i in range(0, n - L + 1):
        rpos = n - (i + L)
        hrev = r.get(rpos, L)
        jmax = mp.get(hrev, -1)
        if jmax > i + L:
            gap = jmax - (i + L)
            if gap > best_gap:
                best_gap = gap
                bi, bj = i, jmax
    return (bestL, bi, bj)

def read_input():
    data = sys.stdin.read().splitlines()
    return data[0].strip() if data else ""

def solve_all():
    s = read_input()
    if not s:
        return
    n = len(s)
    st1, ln1, d = best_k1(s)
    best_val = ln1
    best_ans = (1, [(st1+1, ln1)])

    L, i, j = compute_best_pair_with_gap(s)
    if L > 0:
        left_bound = i + L
        right_bound = j - 1
        # Scan for best odd palindrome fully within [left_bound, right_bound]
        best_mid_len = 1
        best_mid_start = left_bound
        for c in range(left_bound, right_bound+1):
            allowed = min(d[c], c - left_bound, right_bound - c)
            cur_len = 2*allowed + 1
            if cur_len > best_mid_len:
                best_mid_len = cur_len
                best_mid_start = c - allowed
        val3 = 2*L + best_mid_len
        if val3 > best_val:
            best_val = val3
            best_ans = (3, [(i+1, L), (best_mid_start+1, best_mid_len), (j+1, L)])

    print(best_ans[0])
    for x, l in best_ans[1]:
        print(x, l)

def main():
    # Exactly 3 asserts/mini-tests (I/O style)
    from io import StringIO
    # 1) Single character
    sys.stdin = StringIO("a\n"); solve_all()
    # 2) Sandwich present
    sys.stdin = StringIO("abca\n"); solve_all()
    # 3) Center palindrome dominant
    sys.stdin = StringIO("abcdxyzyx\n"); solve_all()
    # Restore for actual input
    data = sys.stdin.read().splitlines() if hasattr(sys.stdin, "read") else []
    if data:
        sys.stdin = StringIO(data[0] + "\n")
        solve_all()
    else:
        # If run with real stdin, re-read and solve
        sys.stdin = sys.__stdin__
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the length of either a single odd palindrome or a three-part pattern prefix + middle + suffix where suffix is the reverse of prefix.}
\WHY{Mixes palindrome detection (Manacher) with substring matching (hashing/SAM) — common interview topics.}
\CHECKLIST{
\begin{bullets}
\item Compute odd palindromic radii with Manacher.
\item Double rolling hash for substring equality and reversed equality.
\item Binary search $L$ for the sandwich; ensure a gap exists ($i+L<j$).
\item Place the middle as the best odd palindrome within the gap.
\item Compare against best odd palindrome alone and print the better.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $|S|=1$.
\item No reverse-matching substrings at any length.
\item All characters equal.
\item Multiple occurrences; pick the one with maximal gap for a larger middle.
\item Very large $n$ (performance of hashing and memory).
\item Middle must be odd length and non-empty.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting the required ordering and non-overlap (must have $i+L<j$).
\item Off-by-one on 1-indexed output.
\item Using even-length middle (invalid).
\item Hash collisions — mitigate with double hashing.
\item Binary search bounds on $L$.
\item Not maximizing the gap when recovering positions.
\end{bullets}}
\FAILMODES{Approaches that only find a center palindrome (k=1) can be suboptimal if a long sandwich exists; naive enumeration times out. The combined approach avoids both failure modes.}
\ELI{Either take the biggest symmetric chunk in the string, or glue a letter between a string and its mirror that occur apart. We detect palindromes fast and find the largest mirrorable ends with hashing.}
\NotePages{3}

\end{document}