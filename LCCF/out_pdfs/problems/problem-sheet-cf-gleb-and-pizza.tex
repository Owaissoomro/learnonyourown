% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Gleb And Pizza}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/842/B}}
\LINE{DIFFICULTY / RATING}{1100}
\STATEMENT{Gleb ordered pizza home. When the courier delivered the pizza, he was very upset, because several pieces of sausage lay on the crust, and he does not really like the crust.

The pizza is a circle of radius $r$ and center at the origin. Pizza consists of the main part — circle of radius $r - d$ with center at the origin, and crust around the main part of the width $d$. Pieces of sausage are also circles. The radius of the $i$-th piece of the sausage is $r_i$, and the center is given as a pair $(x_i, y_i)$.

Gleb asks you to help determine the number of pieces of sausage caught on the crust. A piece of sausage got on the crust, if it completely lies on the crust.

Input:
First string contains two integer numbers $r$ and $d$ ($0 \le d < r \le 500$) — the radius of pizza and the width of crust.

Next line contains one integer number $n$ — the number of pieces of sausage ($1 \le n \le 10^5$).

Each of next $n$ lines contains three integer numbers $x_i$, $y_i$ and $r_i$ ($-500 \le x_i, y_i \le 500$, $0 \le r_i \le 500$), where $x_i$ and $y_i$ are coordinates of the center of $i$-th piece of sausage, $r_i$ — radius of $i$-th piece of sausage.

Output:
Output the number of pieces of sausage that lay on the crust.

Note:
Below is a picture explaining the first example. Circles of green color denote pieces of sausage lying on the crust.}
\BREAKDOWN{Model pizza as an annulus with inner radius $r-d$ and outer radius $r$. Count sausage circles that lie entirely within the annulus: their farthest point is inside the outer circle and their nearest point is outside the inner circle.}
\ELI{A sausage slice counts if it fits fully in the ring between radii $r-d$ and $r$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case.\\
1) Integers $r,d$ with $0 \le d < r \le 500$.\\
2) Integer $n$ with $1 \le n \le 10^5$.\\
3) For each piece $i=1..n$: integers $x_i, y_i, r_i$ with $-500 \le x_i, y_i \le 500$ and $0 \le r_i \le 500$.}
\OUTPUTS{One integer: the number of sausage pieces that lie completely on the crust (the annulus between radii $r-d$ and $r$), with boundary counted as inside.}
\SAMPLES{Example 1 (platform-style):\\
Input\\
$5~2$\\
$3$\\
$0~0~1$\\
$3~0~1$\\
$4~0~1$\\
Output\\
$1$\\[4pt]
Example 2:\\
Input\\
$10~3$\\
$4$\\
$7~0~2$\\
$8~0~1$\\
$10~0~0$\\
$6~0~2$\\
Output\\
$2$}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the crust be the annulus $\{(x,y):~ r-d \le \sqrt{x^2+y^2} \le r\}$. For each sausage circle $C_i$ with center $c_i=(x_i,y_i)$ and radius $r_i$, we ask whether $C_i \subseteq \{(x,y):~ r-d \le \sqrt{x^2+y^2} \le r\}$. Count how many satisfy this predicate.}
\varmapStart
\var{r}{pizza outer radius}
\var{d}{crust width; inner radius is $a=r-d$}
\var{a}{inner radius $r-d$}
\var{b}{outer radius $r$}
\var{(x_i,y_i)}{center of piece $i$}
\var{r_i}{radius of piece $i$}
\var{t_i}{distance of center to origin, $t_i=\sqrt{x_i^2+y_i^2}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Piece } i \text{ lies fully on crust} \iff
\begin{cases}
t_i - r_i \ge a,\\
t_i + r_i \le b,
\end{cases}
\quad\text{where } a=r-d,\; b=r.
\end{aligned}
\]
Equivalently, using $t_i \ge 0$,
\[
\begin{aligned}
x_i^2 + y_i^2 \ge (a + r_i)^2 \quad\text{and}\quad
b - r_i \ge 0 \;\text{ and }\; x_i^2 + y_i^2 \le (b - r_i)^2.
\end{aligned}
\]
}
\ASSUMPTIONS{Boundary is inclusive. All inputs are integers within the stated bounds. Single test case.}
\INVARIANTS{Distances are non-negative: $t_i \ge 0$. If $b - r_i < 0$ then the outer-containment constraint is impossible; otherwise squared comparisons are safe.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the direct geometric conditions $t_i - r_i \ge r-d$ and $t_i + r_i \le r$ per piece, computing $t_i=\sqrt{x_i^2+y_i^2}$ in floating point.}
\ASSUMPTIONS{Double precision is sufficient for exact comparisons at these small magnitudes (values up to about $10^3$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $r,d$; set $a=r-d$, $b=r$.
\item For each piece, compute $t=\sqrt{x^2+y^2}$ and check $t - r_i \ge a$ and $t + r_i \le b$.
\item Count the number of pieces satisfying both and print the count.
\end{algosteps}
\COMPLEXITY{One pass over $n$ pieces, $O(1)$ work each.}
\[
\begin{aligned}
T(n) &= O(n),\\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{The checks are exactly the definitions of full containment between two concentric circles with inclusive boundaries.}
\EDGECASES{Degenerate crust ($d=0$) allows only zero-radius pieces centered exactly at radius $r$. Large $r_i$ may immediately fail the outer bound. Centers at origin are handled by the same inequalities.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math, io

def count_on_crust_float(r, d, pieces):
    a, b = r - d, r
    cnt = 0
    for x, y, ri in pieces:
        t = math.hypot(x, y)
        if t - ri >= a and t + ri <= b:
            cnt += 1
    return cnt

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    r = int(next(it)); d = int(next(it))
    n = int(next(it))
    pieces = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it)); ri = int(next(it))
        pieces.append((x, y, ri))
    return r, d, n, pieces

def solve_all(r, d, n, pieces):
    return str(count_on_crust_float(r, d, pieces))

def main():
    # Self-checks
    r, d, n, pieces = read_input("5 2\n3\n0 0 1\n3 0 1\n4 0 1\n")
    assert solve_all(r, d, n, pieces) == "1"
    r, d, n, pieces = read_input("10 3\n4\n7 0 2\n8 0 1\n10 0 0\n6 0 2\n")
    assert solve_all(r, d, n, pieces) == "2"
    r, d, n, pieces = read_input("5 5\n1\n0 0 0\n")  # impossible (d<r violated in real IO), but check logic
    assert count_on_crust_float(5, 5, [(0, 0, 0)]) == 0

    # Actual solve
    r, d, n, pieces = read_input()
    print(solve_all(r, d, n, pieces))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked two crafted samples and a degenerate logic guard.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Avoid floating point entirely by using squared distances with careful handling of the outer bound: require $b-r_i \ge 0$ and compare $x^2+y^2$ against $(a+r_i)^2$ and $(b-r_i)^2$.}
\ASSUMPTIONS{All inputs are integers; comparisons in $\mathbb{Z}$ eliminate precision concerns.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $a=r-d$ and $b=r$.
\item For each piece, compute $s=x^2+y^2$.
\item Check $s \ge (a+r_i)^2$ and $b-r_i \ge 0$ and $s \le (b-r_i)^2$; count if true.
\end{algosteps}
\COMPLEXITY{Same $O(n)$ time and $O(1)$ space; slightly faster in practice by avoiding $\sqrt{\cdot}$.}
\[
\begin{aligned}
T(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{If $b-r_i<0$ then $t+r_i\le b$ is impossible. Otherwise $t\ge 0$ allows squaring the two inequalities safely, yielding exactly the integer checks used.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, io

def count_on_crust_int(r, d, pieces):
    a, b = r - d, r
    cnt = 0
    for x, y, ri in pieces:
        s = x * x + y * y
        inner = a + ri
        outer = b - ri
        if outer < 0:
            continue
        if s >= inner * inner and s <= outer * outer:
            cnt += 1
    return cnt

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    r = int(next(it)); d = int(next(it))
    n = int(next(it))
    pieces = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it)); ri = int(next(it))
        pieces.append((x, y, ri))
    return r, d, n, pieces

def solve_all(r, d, n, pieces):
    return str(count_on_crust_int(r, d, pieces))

def main():
    # Self-checks
    r, d, n, pieces = read_input("5 2\n3\n0 0 1\n3 0 1\n4 0 1\n")
    assert solve_all(r, d, n, pieces) == "1"
    r, d, n, pieces = read_input("10 3\n4\n7 0 2\n8 0 1\n10 0 0\n6 0 2\n")
    assert solve_all(r, d, n, pieces) == "2"
    r, d, n, pieces = read_input("3 0\n3\n3 0 0\n0 0 1\n0 3 0\n")
    # Only points exactly on radius 3 with ri=0 count: here two such points
    assert solve_all(r, d, n, pieces) == "2"

    # Actual solve
    r, d, n, pieces = read_input()
    print(solve_all(r, d, n, pieces))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Covers exact-boundary cases and degenerate crust width.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Final method is the integer arithmetic check derived from the annulus containment conditions: compare $x^2+y^2$ to $(r-d+r_i)^2$ and $(r-r_i)^2$ with the guard $r-r_i \ge 0$.}
\ASSUMPTIONS{Single pass suffices; no need for sorting or advanced data structures.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read inputs; set $a=r-d$ and $b=r$.
\item For each piece, compute $s=x^2+y^2$, set $L=(a+r_i)^2$, $U=(b-r_i)^2$, and check $b-r_i \ge 0$ and $L \le s \le U$.
\item Count and print the total.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must inspect each piece at least once, so $O(n)$ is optimal. Arithmetic per item is $O(1)$ with minimal constants.}
\COMPLEXITY{Linear time, constant space.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S(n) = \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    r = int(next(it)); d = int(next(it))
    n = int(next(it))
    pieces = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it)); ri = int(next(it))
        pieces.append((x, y, ri))
    return r, d, n, pieces

def count_on_crust(r, d, pieces):
    a, b = r - d, r
    cnt = 0
    for x, y, ri in pieces:
        s = x * x + y * y
        inner = a + ri
        outer = b - ri
        if outer < 0:
            continue
        if s >= inner * inner and s <= outer * outer:
            cnt += 1
    return cnt

def solve_all(r, d, n, pieces):
    return str(count_on_crust(r, d, pieces))

def main():
    # Internal tests (do not affect stdin consumption)
    r, d, n, pieces = read_input("5 2\n3\n0 0 1\n3 0 1\n4 0 1\n")
    assert solve_all(r, d, n, pieces) == "1"
    r, d, n, pieces = read_input("10 3\n4\n7 0 2\n8 0 1\n10 0 0\n6 0 2\n")
    assert solve_all(r, d, n, pieces) == "2"
    r, d, n, pieces = read_input("7 1\n3\n6 0 1\n7 0 0\n5 0 2\n")
    # Only first two fit fully: (6,0,1) and (7,0,0)
    assert solve_all(r, d, n, pieces) == "2"

    # Actual solve
    r, d, n, pieces = read_input()
    print(solve_all(r, d, n, pieces))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts included with varied boundary coverage; after tests, the program reads stdin and prints the answer.}
\RESULT{Print the count of pieces whose disks lie entirely within the annulus $[r-d,\,r]$ (inclusive).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the core predicate with near-boundary cases: inner boundary touch, outer boundary touch, impossible outer fit ($r_i>r$), center at origin, and degenerate crust $d=0$.}
\LINE{CROSS-CHECKS}{Compare float-based baseline vs int-based improved on random small cases to ensure exact agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate random $(x,y)$ with small ranges, random $r_i$, and randomly choose $r,d$; verify the two implementations match for many trials.}
\begin{minted}{python}
import random, math

def float_pred(r, d, x, y, ri):
    a, b = r - d, r
    t = math.hypot(x, y)
    return (t - ri >= a) and (t + ri <= b)

def int_pred(r, d, x, y, ri):
    a, b = r - d, r
    s = x*x + y*y
    inner = a + ri
    outer = b - ri
    if outer < 0:
        return False
    return (s >= inner*inner) and (s <= outer*outer)

def cross_check_trials(trials=2000):
    for _ in range(trials):
        r = random.randint(1, 20)
        d = random.randint(0, r-1)
        x = random.randint(-25, 25)
        y = random.randint(-25, 25)
        ri = random.randint(0, 25)
        assert float_pred(r, d, x, y, ri) == int_pred(r, d, x, y, ri)
    return True

assert cross_check_trials(1000)

# Reference solution (ready to submit if tests are removed)
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    r = int(next(it)); d = int(next(it))
    n = int(next(it))
    pieces = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it)); ri = int(next(it))
        pieces.append((x, y, ri))
    return r, d, n, pieces

def count_on_crust(r, d, pieces):
    a, b = r - d, r
    cnt = 0
    for x, y, ri in pieces:
        s = x * x + y * y
        inner = a + ri
        outer = b - ri
        if outer < 0:
            continue
        if s >= inner * inner and s <= outer * outer:
            cnt += 1
    return cnt

def solve_all(r, d, n, pieces):
    return str(count_on_crust(r, d, pieces))

def main():
    # Tiny smoketest
    r, d, n, pieces = read_input("5 2\n3\n0 0 1\n3 0 1\n4 0 1\n")
    assert solve_all(r, d, n, pieces) == "1"
    # Run
    r, d, n, pieces = read_input()
    print(solve_all(r, d, n, pieces))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count circles fully contained in an annulus by checking nearest and farthest distances to the origin against inner and outer radii.}
\WHY{A classic geometry filter used in many interview problems to test careful handling of boundaries and precision.}
\CHECKLIST{%
\begin{bullets}
\item Compute $a=r-d$, $b=r$.
\item For each piece, compute $s=x^2+y^2$.
\item Guard: if $b-r_i<0$ then it cannot fit.
\item Check $s \ge (a+r_i)^2$ and $s \le (b-r_i)^2$.
\item Count inclusively on equality.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $d=0$ (degenerate annulus).
\item $r_i=0$ on boundaries $t=a$ or $t=b$.
\item $r_i=b$ (outer fit impossible unless $t=0$, but inner will fail unless $d=0$ and also $r=0$, which is excluded).
\item Center at origin $(0,0)$.
\item Large $r_i$ close to $b$.
\item Points exactly at thresholds to confirm inclusive comparisons.
\item Negative coordinates for centers.
\item Maximum magnitudes ($\pm 500$) to confirm no overflow in 32-bit Python ints (safe).
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Squaring the outer inequality without guarding $b-r_i \ge 0$ (admits false positives).
\item Using strict inequalities and excluding boundary cases incorrectly.
\item Floating-point rounding causing off-by-one near thresholds.
\item Misreading input order or mixing up $d$ and $r$.
\item Forgetting that $n$ can be up to $10^5$ (ensure $O(n)$).
\item Overflow in languages with fixed-width ints if not careful (use 64-bit).
\end{bullets}
}
\FAILMODES{Inputs where $r_i$ is large relative to $r$ can break naive squared checks without the $b-r_i$ guard; integer method here survives by explicit guard and exact arithmetic.}
\ELI{We just make sure each sausage circle fits entirely within the ring. Its closest point to the center must be outside the inner circle, and its farthest point must be inside the outer circle. Count how many satisfy both.}
\NotePages{3}

\end{document}