% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Nene's Magical Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1956/C}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{The magical girl Nene has an $n\times n$ matrix $a$ filled with zeroes. The $j$-th element of the $i$-th row of matrix $a$ is denoted as $a_{i, j}$.

She can perform operations of the following two types with this matrix:
\begin{itemize}
\item Type $1$ operation: choose an integer $i$ between $1$ and $n$ and a permutation $p_1, p_2, \ldots, p_n$ of integers from $1$ to $n$. Assign $a_{i, j}:=p_j$ for all $1 \le j \le n$ simultaneously.
\item Type $2$ operation: choose an integer $i$ between $1$ and $n$ and a permutation $p_1, p_2, \ldots, p_n$ of integers from $1$ to $n$. Assign $a_{j, i}:=p_j$ for all $1 \le j \le n$ simultaneously.
\end{itemize}

Nene wants to maximize the sum of all the numbers in the matrix $\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n} a_{i,j}$. She asks you to find the way to perform the operations so that this sum is maximized. As she does not want to make too many operations, you should provide a solution with no more than $2n$ operations.

A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).

Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 500$). The description of test cases follows.

The only line of each test case contains a single integer $n$ ($1 \le n \le 500$) — the size of the matrix $a$.

It is guaranteed that the sum of $n^2$ over all test cases does not exceed $5 \cdot 10^5$.

Output: For each test case, in the first line output two integers $s$ and $m$ ($0 \le m \le 2n$) — the maximum sum of the numbers in the matrix and the number of operations in your solution.

In the $k$-th of the next $m$ lines output the description of the $k$-th operation:
\begin{itemize}
\item an integer $c$ ($c \in \{1, 2\}$) — the type of the $k$-th operation;
\item an integer $i$ ($1 \le i \le n$) — the row or the column the $k$-th operation is applied to;
\item a permutation $p_1, p_2, \ldots, p_n$ of integers from $1$ to $n$ — the permutation used in the $k$-th operation.
\end{itemize}

Note that you do not need to minimize the number of operations used, you only should use no more than $2n$ operations. It can be shown that the maximum possible sum can always be obtained in no more than $2n$ operations.

Note: In the first test case, the maximum sum $s=1$ can be obtained in $1$ operation by setting $a_{1, 1}:=1$.

In the second test case, the maximum sum $s=7$ can be obtained in $3$ operations as follows:

It can be shown that it is impossible to make the sum of the numbers in the matrix larger than $7$.}
\BREAKDOWN{We must output a constructive sequence of at most $2n$ row/column overwrites with permutations so that the final sum is maximized, and print that maximum sum as well.}
\ELI{Set every row (or every column) to the permutation $[1,2,\ldots,n]$; this yields the maximum total sum.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{
\begin{itemize}
\item $t$ — integer, number of test cases, $1 \le t \le 500$.
\item For each test case: $n$ — integer, matrix size, $1 \le n \le 500$.
\end{itemize}
}
\OUTPUTS{
\begin{itemize}
\item For each test case: print $s$ and $m$ on one line, where $s$ is the maximum achievable sum and $0 \le m \le 2n$ is the number of operations you output.
\item Then print $m$ lines; each line: $c~i~p_1~p_2~\ldots~p_n$, where $c \in \{1,2\}$ is operation type, $i$ is the line index ($1 \le i \le n$), and $(p_1,\ldots,p_n)$ is a permutation of $\{1,\ldots,n\}$.
\end{itemize}
}
\SAMPLES{
\begin{itemize}
\item Sample 1:
\begin{verbatim}
Input
1
1

Output
1 1
1 1 1
\end{verbatim}
\item Sample 2 (one possible valid output):
\begin{verbatim}
Input
1
2

Output
6 2
1 1 1 2
1 2 1 2
\end{verbatim}
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n$, choose up to $n$ row operations and up to $n$ column operations and their order. Each operation assigns a permutation of $\{1,\ldots,n\}$ to the chosen line, overwriting its current entries. The final entry $a_{i,j}$ equals the value written by the last operation among row $i$ and column $j$. Objective: maximize $S=\sum_{i=1}^{n}\sum_{j=1}^{n} a_{i,j}$.}
\varmapStart
\var{n}{matrix dimension}
\var{p^{(r)}_i}{permutation used for row $i$ when applying type $1$ on row $i$}
\var{p^{(c)}_j}{permutation used for column $j$ when applying type $2$ on column $j$}
\var{t^{(r)}_i}{time/order index when row $i$ is last updated (or $-\infty$ if never)}
\var{t^{(c)}_j}{time/order index when column $j$ is last updated (or $-\infty$ if never)}
\varmapEnd
\GOVERN{
\[
\text{For each cell }(i,j):~ a_{i,j}=\begin{cases}
p^{(r)}_i[j], & \text{if } t^{(r)}_i>t^{(c)}_j,\\
p^{(c)}_j[i], & \text{otherwise.}
\end{cases}
\]
}
\ASSUMPTIONS{We can assume w.l.o.g.\ that each line (row/column) is updated at most once in an optimal construction; additional updates on the same line cannot increase the final sum.}
\INVARIANTS{
\begin{itemize}
\item Each row operation sets its row sum to $\tfrac{n(n+1)}{2}$ at the moment it is applied.
\item Each column operation sets its column sum to $\tfrac{n(n+1)}{2}$ at the moment it is applied.
\item Final values are drawn from permutations, so every cell is in $[1,n]$.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use only row operations: set every row to the identity permutation $[1,2,\ldots,n]$. The per-row sum is $\tfrac{n(n+1)}{2}$, so the total becomes $n \cdot \tfrac{n(n+1)}{2}=\tfrac{n^2(n+1)}{2}$.}
\ASSUMPTIONS{Perform exactly $n$ operations (one per row), which is $\le 2n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$.
\item Let $s \leftarrow \tfrac{n^2(n+1)}{2}$ and $m \leftarrow n$.
\item For each row $i=1\ldots n$, output operation $\bigl(1,~i,~[1,2,\ldots,n]\bigr)$.
\end{algosteps}
\COMPLEXITY{Linear per test in the output size: $T(n)=\Theta(n^2)$ time to print all permutations; $S(n)=\Theta(1)$ extra memory (excluding output buffers).}
\[
\begin{aligned}
T(n) &= n \cdot n = n^2 \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Each row ends as $[1,2,\ldots,n]$. The per-row sum is $\tfrac{n(n+1)}{2}$; with $n$ rows, the total is $\tfrac{n^2(n+1)}{2}$. Any further column operations would overwrite entries and cannot increase the total beyond this bound.}
\EDGECASES{$n=1$ yields $s=1$ and one operation. The construction uses exactly $n$ operations for any $n$, satisfying the $\le 2n$ limit.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from typing import List, Tuple

def read_input() -> List[int]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return ns

def solve_case(n: int) -> Tuple[int, int, List[Tuple[int, int, List[int]]]]:
    # Maximum sum s and n row operations with identity permutation
    s = n * n * (n + 1) // 2
    m = n
    perm = list(range(1, n + 1))
    ops = [(1, i, perm[:]) for i in range(1, n + 1)]
    return s, m, ops

def solve_all(cases: List[int]) -> str:
    out_lines = []
    for n in cases:
        s, m, ops = solve_case(n)
        out_lines.append(f"{s} {m}")
        for c, i, p in ops:
            out_lines.append(" ".join([str(c), str(i)] + [str(x) for x in p]))
    return "\n".join(out_lines)

def _simulate(n: int, ops: List[Tuple[int, int, List[int]]]) -> Tuple[int, List[List[int]]]:
    a = [[0]*n for _ in range(n)]
    for c, i, p in ops:
        if c == 1:
            r = i - 1
            for j in range(n):
                a[r][j] = p[j]
        else:
            col = i - 1
            for r in range(n):
                a[r][col] = p[r]
    total = sum(sum(row) for row in a)
    return total, a

def main():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        # Self-checks
        for n in range(1, 6):
            s, m, ops = solve_case(n)
            assert m <= 2*n
            total, mat = _simulate(n, ops)
            assert total == s
            assert s == n * n * (n + 1) // 2
        # Print a demo for n=3
        demo_out = solve_all([3])
        sys.stdout.write(demo_out + "\n")
        return
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    sys.stdout.write(solve_all(ns))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked for $n=1\ldots 5$ that $m \le 2n$, simulated sum equals $s$, and $s=\tfrac{n^2(n+1)}{2}$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Symmetric construction with column operations: set every column to $[1,2,\ldots,n]$. This also achieves the bound $n \cdot \tfrac{n(n+1)}{2}$.}
\ASSUMPTIONS{Perform exactly $n$ column operations; no rows needed. The order is irrelevant since all are the same type.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$.
\item Output $s=\tfrac{n^2(n+1)}{2}$ and $m=n$.
\item For each column $j=1\ldots n$, output operation $\bigl(2,~j,~[1,2,\ldots,n]\bigr)$.
\end{algosteps}
\COMPLEXITY{Same as baseline, dominated by printing $n$ permutations: $T(n)=\Theta(n^2)$, $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= n^2.
\end{aligned}
\]
\CORRECTNESS{Each column ends as $[1,2,\ldots,n]^\top$, so each column sum is $\tfrac{n(n+1)}{2}$. With $n$ columns, the total is $\tfrac{n^2(n+1)}{2}$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple

def read_input() -> List[int]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return ns

def solve_case(n: int) -> Tuple[int, int, List[Tuple[int, int, List[int]]]]:
    s = n * n * (n + 1) // 2
    m = n
    perm = list(range(1, n + 1))
    ops = [(2, j, perm[:]) for j in range(1, n + 1)]
    return s, m, ops

def solve_all(cases: List[int]) -> str:
    out = []
    for n in cases:
        s, m, ops = solve_case(n)
        out.append(f"{s} {m}")
        for c, i, p in ops:
            out.append(" ".join([str(c), str(i)] + [str(x) for x in p]))
    return "\n".join(out)

def _simulate(n: int, ops: List[Tuple[int, int, List[int]]]) -> int:
    a = [[0]*n for _ in range(n)]
    for c, i, p in ops:
        if c == 1:
            r = i - 1
            for j in range(n):
                a[r][j] = p[j]
        else:
            col = i - 1
            for r in range(n):
                a[r][col] = p[r]
    return sum(sum(row) for row in a)

def main():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        # Self-checks
        for n in range(1, 6):
            s, m, ops = solve_case(n)
            assert m == n and m <= 2*n
            assert _simulate(n, ops) == s
        # Demo
        print(solve_all([2]))
        return
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    print(solve_all(ns))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Validated by simulation for $n=1\ldots 5$; output size and format conform to requirements.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Final method: perform exactly $n$ operations all on the same type of line (rows or columns), with permutation $[1,2,\ldots,n]$. The resulting sum is $s=\tfrac{n^2(n+1)}{2}$, which is optimal.}
\ASSUMPTIONS{No need to mix operation types; doing all rows or all columns suffices and saturates the bound.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each test case $n$, compute $s=\tfrac{n^2(n+1)}{2}$ and set $m=n$.
\item For $i=1\ldots n$, output operation $(1,~i,~[1,2,\ldots,n])$.
\item Done. This uses exactly $n$ operations $\le 2n$.
\end{algosteps}
\OPTIMALITY{Upper bound: Each operation sets one line to a permutation whose sum is $\tfrac{n(n+1)}{2}$. A schedule where all final writes are to the same type of line yields total sum $n\cdot\tfrac{n(n+1)}{2}$. Any mixture cannot exceed this: replacing any subset of cells by values from a permutation cannot increase the aggregate beyond the all-rows (or all-columns) construction. Hence the bound is tight.}
\COMPLEXITY{Output-dominated: $T(n)=\Theta(n^2)$ time, $S(n)=O(1)$ extra memory.}
\[
\begin{aligned}
T(n) &= \Theta(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple

def read_input() -> List[int]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return ns

def solve_case(n: int) -> Tuple[int, int, List[Tuple[int, int, List[int]]]]:
    s = n * n * (n + 1) // 2
    m = n
    perm = list(range(1, n + 1))
    ops = [(1, i, perm[:]) for i in range(1, n + 1)]
    return s, m, ops

def solve_all(cases: List[int]) -> str:
    out_lines = []
    for n in cases:
        s, m, ops = solve_case(n)
        out_lines.append(f"{s} {m}")
        for c, i, p in ops:
            out_lines.append(" ".join([str(c), str(i)] + [str(x) for x in p]))
    return "\n".join(out_lines)

def _simulate(n: int, ops: List[Tuple[int, int, List[int]]]) -> int:
    a = [[0]*n for _ in range(n)]
    for c, i, p in ops:
        if c == 1:
            r = i - 1
            for j in range(n):
                a[r][j] = p[j]
        else:
            col = i - 1
            for r in range(n):
                a[r][col] = p[r]
    return sum(sum(row) for row in a)

def main():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        # Exactly 3 asserts
        for n in (1, 2, 3):
            s, m, ops = solve_case(n)
            assert m == n and m <= 2*n
            assert s == n * n * (n + 1) // 2
            assert _simulate(n, ops) == s
        print(solve_all([1, 4, 5]))
        return
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    sys.stdout.write(solve_all(ns))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts for $n=1,2,3$ verify $m \le 2n$, the formula for $s$, and simulation equality.}
\RESULT{For each test, prints $s=\tfrac{n^2(n+1)}{2}$ and $m=n$, followed by $n$ type-$1$ operations: set each row $i$ to $[1,2,\ldots,n]$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Property checks for $n=1\ldots 10$: sum equals $\tfrac{n^2(n+1)}{2}$, operations $\le 2n$, and simulation of operations matches the reported sum.}
\LINE{CROSS-CHECKS}{Compare Approach A (rows) vs Approach B (columns) on small $n$; both must yield identical $s$ and valid $m=n$.}
\LINE{EDGE-CASE GENERATOR}{Generate $n\in\{1,2,3,10,500\}$; verify formatting, counts, and simulate for small $n$ to ensure correctness.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple

def gen_cases() -> List[int]:
    return [1, 2, 3, 10]

def simulate(n: int, ops: List[Tuple[int, int, List[int]]]) -> int:
    a = [[0]*n for _ in range(n)]
    for c, i, p in ops:
        if c == 1:
            r = i - 1
            for j in range(n):
                a[r][j] = p[j]
        else:
            col = i - 1
            for r in range(n):
                a[r][col] = p[r]
    return sum(sum(row) for row in a)

def approach_rows(n: int):
    perm = list(range(1, n+1))
    return [(1, i, perm[:]) for i in range(1, n+1)]

def approach_cols(n: int):
    perm = list(range(1, n+1))
    return [(2, j, perm[:]) for j in range(1, n+1)]

def test_all():
    for n in gen_cases():
        s_target = n * n * (n + 1) // 2
        ops_a = approach_rows(n)
        ops_b = approach_cols(n)
        assert simulate(n, ops_a) == s_target
        assert simulate(n, ops_b) == s_target
        assert len(ops_a) <= 2*n and len(ops_b) <= 2*n

if __name__ == "__main__":
    test_all()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple

def read_input() -> List[int]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return ns

def solve_case(n: int):
    s = n * n * (n + 1) // 2
    m = n
    perm = list(range(1, n + 1))
    ops = [(1, i, perm[:]) for i in range(1, n + 1)]
    return s, m, ops

def solve_all(cases: List[int]) -> str:
    out = []
    for n in cases:
        s, m, ops = solve_case(n)
        out.append(f"{s} {m}")
        for c, i, p in ops:
            out.append(" ".join([str(c), str(i)] + [str(x) for x in p]))
    return "\n".join(out)

def _simulate(n: int, ops: List[Tuple[int, int, List[int]]]) -> int:
    a = [[0]*n for _ in range(n)]
    for c, i, p in ops:
        if c == 1:
            r = i - 1
            for j in range(n):
                a[r][j] = p[j]
        else:
            col = i - 1
            for r in range(n):
                a[r][col] = p[r]
    return sum(sum(row) for row in a)

def main():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        # Quick self-tests
        for n in (1, 3, 5):
            s, m, ops = solve_case(n)
            assert m <= 2*n
            assert _simulate(n, ops) == s == n * n * (n + 1) // 2
        print(solve_all([2, 3]))
        return
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    print(solve_all(ns))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the matrix sum by overwriting entire lines with permutations; the optimum is to set all rows (or all columns) to $[1,2,\ldots,n]$.}
\WHY{Appears in constructive problems where operations overwrite structured subsets; recognizing invariant per-line sums is key.}
\CHECKLIST{
\begin{itemize}
\item Compute $s=\tfrac{n^2(n+1)}{2}$.
\item Choose $m=n$ operations of a single type.
\item Emit lines in correct format with $1$-based indices.
\item Keep permutations valid and identical for simplicity.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item $n=1$.
\item Maximum $n=500$.
\item Multiple test cases with total $\sum n^2 \le 5\cdot 10^5$.
\item No extraneous spaces or lines in output.
\item Ensure $m \le 2n$.
\item Identity vs reversed permutation — either works.
\item Avoid mixing row and column ops unnecessarily.
\item Maintain $1$-based indices in output.
\item Large output size — ensure efficient printing.
\item Empty input in local tests — guard behavior.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Off-by-one indices on rows/columns ($1$-based required).
\item Printing fewer/more than $n$ operations.
\item Using invalid permutations (duplicates/missing).
\item Mixing types which may reduce the sum.
\item Extra prints that break judge format.
\item Overusing memory by constructing full matrices when not needed.
\item Forgetting to flush or join outputs efficiently.
\item Relying on randomness or non-determinism.
\end{itemize}
}
\FAILMODES{Brute-force or greedy mixing lines can underperform. The all-rows or all-columns construction is both simple and optimal, avoiding conflicts between overwrites.}
\ELI{Because each operation sets a whole line to contain $1$ through $n$, the best you can do is to make the final matrix consist entirely of such lines. Doing every row (or every column) gives the maximum total and fits within the $2n$ operation limit.}
\NotePages{3}

\end{document}