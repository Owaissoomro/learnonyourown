% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Number of Operations to Satisfy Conditions}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-number-of-operations-to-satisfy-conditions/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given a 2D matrix \texttt{grid} of size $m \times n$. In one \textbf{operation}, you can change the value of \textbf{any} cell to \textbf{any} non-negative number. You need to perform some \textbf{operations} such that each cell \texttt{grid[i][j]} is:
\begin{bullets}
\item Equal to the cell below it, i.e. $\texttt{grid[i][j]} = \texttt{grid[i + 1][j]}$ (if it exists).
\item Different from the cell to its right, i.e. $\texttt{grid[i][j]} \ne \texttt{grid[i][j + 1]}$ (if it exists).
\end{bullets}
Return the \textbf{minimum} number of operations needed.

\textbf{Example 1:} \\
\textbf{Input:} \texttt{grid = [[1,0,2],[1,0,2]]} \\
\textbf{Output:} \texttt{0} \\
\textbf{Explanation:} All the cells in the matrix already satisfy the properties.

\textbf{Example 2:} \\
\textbf{Input:} \texttt{grid = [[1,1,1],[0,0,0]]} \\
\textbf{Output:} \texttt{3} \\
\textbf{Explanation:} The matrix becomes \texttt{[[1,0,1],[1,0,1]]} which satisfies the properties, by doing these 3 operations:
\begin{bullets}
\item Change \texttt{grid[1][0]} to 1.
\item Change \texttt{grid[0][1]} to 0.
\item Change \texttt{grid[1][2]} to 1.
\end{bullets}

\textbf{Example 3:} \\
\textbf{Input:} \texttt{grid = [[1],[2],[3]]} \\
\textbf{Output:} \texttt{2} \\
\textbf{Explanation:} There is a single column. We can change the value to 1 in each cell using 2 operations.

\textbf{Constraints:}
\begin{bullets}
\item $1 \le n, m \le 1000$
\item $0 \le \texttt{grid[i][j]} \le 9$
\end{bullets}}
\BREAKDOWN{Vertical constraint forces each column to be constant after operations. Horizontal constraint then requires adjacent columns to take different constant values. Minimize the number of cell changes by optimally choosing a digit for each column.}
\ELI{Make every column a single digit, and adjacent columns must use different digits; pick digits to minimize how many cells you change.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of lists \texttt{grid} with $m$ rows and $n$ columns, where $1 \le m,n \le 1000$ and each entry is an integer in $[0,9]$.}
\OUTPUTS{Return an integer: the minimum number of operations (cell changes) to make each column constant and adjacent columns different.}
\SAMPLES{\begin{bullets}
\item Input: \texttt{[[1,0,2],[1,0,2]]} $\to$ Output: \texttt{0}.
\item Input: \texttt{[[1,1,1],[0,0,0]]} $\to$ Output: \texttt{3}.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $m,n$ be dimensions. Let the digit alphabet be $D=\{0,1,\ldots,9\}$. For each column $j\in\{0,\ldots,n-1\}$ and digit $d\in D$, define
\begin{BreakableEquation*}
\text{cost}[j][d] = m - \#\{i \in [0,m-1] : \texttt{grid}[i][j] = d\}.
\end{BreakableEquation*}
Choose a sequence $(x_0,\ldots,x_{n-1})\in D^n$ with $x_j \ne x_{j+1}$ for all $j$, minimizing $\sum_{j=0}^{n-1} \text{cost}[j][x_j]$.}
\varmapStart
\var{m,n}{row and column counts}
\var{D}{digit set $\{0,\ldots,9\}$}
\var{\text{cost}[j][d]}{changes to make column $j$ all digit $d$}
\var{x_j}{chosen digit for column $j$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\min_{x_0,\ldots,x_{n-1}\in D} \sum_{j=0}^{n-1} \text{cost}[j][x_j] \\
&\text{s.t. } x_j \ne x_{j+1}\quad \forall j\in\{0,\ldots,n-2\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Columns are independent aside from the $x_j \ne x_{j+1}$ constraint. Digits beyond $0\ldots9$ are never beneficial since costs depend only on matching existing digits.}
\INVARIANTS{\begin{bullets}
\item For fixed $j$, $\min_d \text{cost}[j][d] = m - \max_d \#\text{matches in column }j$.
\item Optimal solution always assigns a single digit per column due to the vertical-equality constraint.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Dynamic programming over columns with a $10$-state choice per column. Transition disallows staying on the same digit between adjacent columns.}
\ASSUMPTIONS{Compute per-column, per-digit costs up front; then run $O(n \cdot 10^2)$ DP using plain minimization over all previous digits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\text{cost}[j][d]$ for all columns $j$ and digits $d \in \{0,\ldots,9\}$.
\item Initialize $dp_0[d] = \text{cost}[0][d]$.
\item For each $j=1,\ldots,n-1$, set $dp_j[d] = \text{cost}[j][d] + \min_{d' \ne d} dp_{j-1}[d']$.
\item Answer is $\min_d dp_{n-1}[d]$.
\end{algosteps}
\COMPLEXITY{Computing costs is $O(mn + 10n)$; DP transitions are $O(n \cdot 10 \cdot 10)$.}
\[
\begin{aligned}
T(m,n) &= O(mn) + O(n\cdot 10\cdot 10) = O(mn + 100n),\\
S(m,n) &= O(10) \text{ if we roll arrays (or } O(n\cdot 10)\text{ if we keep all).}
\end{aligned}
\]
\CORRECTNESS{Each column's choice only interacts with its immediate neighbor via the inequality constraint. The DP enumerates all valid assignments, and the transition enforces $x_{j-1} \ne x_j$. The minimal sum is accumulated.}
\EDGECASES{\begin{bullets}
\item $n=1$: answer is $m - \max_d$ frequency in the only column.
\item $m=1$: costs reduce to $0$ or $1$ per cell; DP ensures adjacent columns differ.
\item All columns identical: alternating digits will be chosen to minimize flips.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        # Precompute cost[j][d]: cost to make column j all digit d
        cost = [[0]*10 for _ in range(n)]
        for j in range(n):
            freq = [0]*10
            for i in range(m):
                v = grid[i][j]
                # Values are guaranteed in [0,9]
                freq[v] += 1
            for d in range(10):
                cost[j][d] = m - freq[d]
        if n == 0:
            return 0
        # DP over columns, naive O(10*10) transition
        prev = cost[0][:]
        for j in range(1, n):
            curr = [0]*10
            for d in range(10):
                best = float('inf')
                for pd in range(10):
                    if pd == d:
                        continue
                    val = prev[pd] + cost[j][d]
                    if val < best:
                        best = val
                curr[d] = best
            prev = curr
        return min(prev)

# Basic asserts from the prompt
assert Solution().minimumOperations([[1,0,2],[1,0,2]]) == 0
assert Solution().minimumOperations([[1,1,1],[0,0,0]]) == 3
assert Solution().minimumOperations([[1],[2],[3]]) == 2
\end{minted}
\VALIDATION{Sanity: single column with mixed digits returns $m - \max$-frequency; two columns with same values force different chosen digits, incurring minimal flips on one column.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Transition Using Best and Second-Best}
\WHICHFORMULA{For each column, let $\min_1$ be the smallest prior DP value and $\min_2$ the second smallest, with corresponding digit $\arg\min_1$. Then $\min_{d'\ne d} dp_{j-1}[d']$ equals $\min_1$ if $d \ne \arg\min_1$, else $\min_2$.}
\ASSUMPTIONS{We still use the same cost table; we only optimize the DP transition from $O(10^2)$ to $O(10)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $\text{cost}$ as before.
\item Maintain for each step the pair $(\min_1,\text{argmin}_1)$ and $\min_2$ over $d\in D$.
\item For each $d$, set $dp_j[d] = \text{cost}[j][d] + (\min_1 \text{ if } d \ne \text{argmin}_1 \text{ else } \min_2)$.
\item The answer is $\min_d dp_{n-1}[d]$.
\end{algosteps}
\COMPLEXITY{Transition reduces to $O(10)$ per column; total time $O(mn + 10n)$; space $O(10)$.}
\[
\begin{aligned}
T(m,n) &= O(mn) + O(10n), \\
S(m,n) &= O(10).
\end{aligned}
\]
\CORRECTNESS{For any fixed $d$, the best previous digit different from $d$ is either the global best previous digit if it is not $d$, or otherwise the second best previous digit. This case analysis is complete and disjoint.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        if n == 0:
            return 0
        # Precompute cost[j][d]
        cost = [[0]*10 for _ in range(n)]
        for j in range(n):
            freq = [0]*10
            for i in range(m):
                freq[grid[i][j]] += 1
            for d in range(10):
                cost[j][d] = m - freq[d]
        prev = cost[0][:]
        for j in range(1, n):
            # find min1, min2 and argmin1
            min1 = float('inf'); min2 = float('inf'); arg1 = -1
            for d in range(10):
                v = prev[d]
                if v < min1:
                    min2 = min1
                    min1 = v
                    arg1 = d
                elif v < min2:
                    min2 = v
            curr = [0]*10
            for d in range(10):
                best_prev = min1 if d != arg1 else min2
                curr[d] = cost[j][d] + best_prev
            prev = curr
        return min(prev)

# Same asserts
assert Solution().minimumOperations([[1,0,2],[1,0,2]]) == 0
assert Solution().minimumOperations([[1,1,1],[0,0,0]]) == 3
assert Solution().minimumOperations([[1],[2],[3]]) == 2
\end{minted}
\VALIDATION{Comparing with the baseline on random small cases yields identical results; edge cases $n=1$ and $m=1$ match closed-form expectations.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Column DP with Best/Second-Best and Streaming Costs}
\WHICHFORMULA{Same DP as B; precompute per-column frequencies in one pass and roll the DP arrays to keep memory constant.}
\ASSUMPTIONS{Digits domain fixed to $\{0,\ldots,9\}$; costs computed column-wise; transitions use best/second-best trick.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each column $j$, count frequencies of $0\ldots9$ in $O(m)$ and derive $\text{cost}[j][d]$.
\item Initialize $prev[d] = \text{cost}[0][d]$.
\item For each next column, compute $(\min_1,\min_2,\arg\min_1)$ over $prev$ and fill $curr[d]$ accordingly; swap.
\item Return $\min_d prev[d]$.
\end{algosteps}
\OPTIMALITY{This matches the natural lower bound of evaluating each input cell at least once to build column statistics: $O(mn)$ is information-theoretically optimal. DP overhead is $O(10n)$, which is linear in $n$.}
\COMPLEXITY{Tight bounds:}
\[
\begin{aligned}
T(m,n) &= \Theta(mn) + \Theta(10n),\\
S(m,n) &= \Theta(10).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import random

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        if n == 0:
            return 0
        # Precompute costs per column and digit
        cost = [[0]*10 for _ in range(n)]
        for j in range(n):
            freq = [0]*10
            for i in range(m):
                freq[grid[i][j]] += 1
            for d in range(10):
                cost[j][d] = m - freq[d]
        prev = cost[0][:]

        for j in range(1, n):
            # best and second-best from prev
            min1 = float('inf'); min2 = float('inf'); arg1 = -1
            for d in range(10):
                v = prev[d]
                if v < min1:
                    min2 = min1
                    min1 = v
                    arg1 = d
                elif v < min2:
                    min2 = v
            curr = [0]*10
            for d in range(10):
                best_prev = min1 if d != arg1 else min2
                curr[d] = cost[j][d] + best_prev
            prev = curr
        return min(prev)

# Exactly 3 asserts (prompt examples)
assert Solution().minimumOperations([[1,0,2],[1,0,2]]) == 0
assert Solution().minimumOperations([[1,1,1],[0,0,0]]) == 3
assert Solution().minimumOperations([[1],[2],[3]]) == 2
\end{minted}
\VALIDATION{Three prompt-based asserts pass. Additionally, random testing (not shown here) can compare against the $O(10^2)$ transition to ensure equivalence.}
\RESULT{The algorithm returns the minimum number of cell updates needed so that each column is constant and adjacent columns differ; ties are irrelevant as we only return the minimal count.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on examples; property tests comparing the improved DP vs. a slower $O(10^2)$ transition on random grids; edge cases $m=1$, $n=1$, all-equal columns, alternating columns.}
\LINE{CROSS-CHECKS}{Cross-validate Approach A vs B vs C on randomly generated small matrices to ensure equal outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate small $m,n\le 5$ with values in $[0,9]$ and compare results across implementations deterministically.}
\begin{minted}{python}
from typing import List
import random

def baseline_min_ops(grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0]) if m > 0 else 0
    if n == 0:
        return 0
    cost = [[0]*10 for _ in range(n)]
    for j in range(n):
        freq = [0]*10
        for i in range(m):
            freq[grid[i][j]] += 1
        for d in range(10):
            cost[j][d] = m - freq[d]
    prev = cost[0][:]
    for j in range(1, n):
        curr = [0]*10
        for d in range(10):
            best = float('inf')
            for pd in range(10):
                if pd == d:
                    continue
                best = min(best, prev[pd])
            curr[d] = cost[j][d] + best
        prev = curr
    return min(prev)

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        if n == 0:
            return 0
        cost = [[0]*10 for _ in range(n)]
        for j in range(n):
            freq = [0]*10
            for i in range(m):
                freq[grid[i][j]] += 1
            for d in range(10):
                cost[j][d] = m - freq[d]
        prev = cost[0][:]
        for j in range(1, n):
            min1 = float('inf'); min2 = float('inf'); arg1 = -1
            for d in range(10):
                v = prev[d]
                if v < min1:
                    min2 = min1
                    min1 = v
                    arg1 = d
                elif v < min2:
                    min2 = v
            curr = [0]*10
            for d in range(10):
                best_prev = min1 if d != arg1 else min2
                curr[d] = cost[j][d] + best_prev
            prev = curr
        return min(prev)

# Cross-check tests
def run_cross_checks():
    rng = random.Random(0)
    for m in range(1, 6):
        for n in range(1, 6):
            for _ in range(50):
                grid = [[rng.randrange(10) for _ in range(n)] for __ in range(m)]
                a = baseline_min_ops(grid)
                c = Solution().minimumOperations(grid)
                assert a == c, (m, n, grid, a, c)
    # Edge checks
    assert Solution().minimumOperations([[0]]) == 0
    assert Solution().minimumOperations([[0,0,0]]) in (1, 2)  # must alternate digits, cost depends on chosen alt
    assert Solution().minimumOperations([[1],[1],[1]]) == 0

run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        if n == 0:
            return 0
        # Precompute cost to make each column j all digit d
        cost = [[0]*10 for _ in range(n)]
        for j in range(n):
            freq = [0]*10
            for i in range(m):
                freq[grid[i][j]] += 1
            for d in range(10):
                cost[j][d] = m - freq[d]
        # DP with best/second-best optimization
        prev = cost[0][:]
        for j in range(1, n):
            min1 = float('inf'); min2 = float('inf'); arg1 = -1
            for d in range(10):
                v = prev[d]
                if v < min1:
                    min2 = min1
                    min1 = v
                    arg1 = d
                elif v < min2:
                    min2 = v
            curr = [0]*10
            for d in range(10):
                best_prev = min1 if d != arg1 else min2
                curr[d] = cost[j][d] + best_prev
            prev = curr
        return min(prev)

# Final sanity asserts
if __name__ == "__main__":
    s = Solution()
    assert s.minimumOperations([[1,0,2],[1,0,2]]) == 0
    assert s.minimumOperations([[1,1,1],[0,0,0]]) == 3
    assert s.minimumOperations([[1],[2],[3]]) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Pick one digit per column; adjacent columns must differ; minimize total flips using a 10-state DP across columns.}
\WHY{Appears in interviews to test modeling constraints into DP, precomputation of costs, and optimizing transitions via best/second-best.}
\CHECKLIST{\begin{bullets}
\item Build per-column frequency counts for digits $0\ldots9$.
\item Derive $\text{cost}[j][d] = m - \text{freq}_j(d)$.
\item Initialize DP with column $0$ costs.
\item For each column, compute best and second-best from previous DP.
\item Transition: add column cost and enforce inequality via best/second-best.
\item Take the minimum over final DP states.
\end{bullets}}
\EDGECASES{\begin{bullets}
\item $n=1$: return $m - \max_d \text{freq}(d)$ in the only column.
\item $m=1$: sequence coloring with costs $0/1$; must alternate digits.
\item All entries identical: optimal alternation picks minimal-change columns.
\item Columns with dominant digits near ties: ensure correct tie-handling in min1/min2.
\item Large $m,n$ up to $1000$: ensure $O(mn)$ implementation.
\item Empty grid is not in constraints, but guard for $n=0$ if needed.
\end{bullets}}
\PITFALLS{\begin{bullets}
\item Forgetting to exclude same digit in transition ($d'=d$).
\item Mishandling best/second-best when multiple equal minima exist.
\item Recomputing full $O(10^2)$ min redundantly when $O(10)$ suffices.
\item Using values beyond $0\ldots9$ (never beneficial).
\item Overflow is not a concern in Python, but initialize with $\infty$ safely.
\item Off-by-one in column indices during DP updates.
\end{bullets}}
\FAILMODES{Greedy per-column choices without considering neighbors may fail when two adjacent columns share the same dominant digit; the DP avoids this by considering neighbor constraints.}
\ELI{Count how many changes each column needs to become all 0s, all 1s, ..., all 9s. Then, walking left-to-right, pick a digit for each column so neighbors differ and the total changes are smallest. Track the best and second-best prior totals to decide quickly.}
\NotePages{3}

\end{document}