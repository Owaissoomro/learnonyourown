% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Zimpha Fan Club}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1975/G}}
\LINE{DIFFICULTY / RATING}{3000}
\STATEMENT{One day, Zimpha casually came up with a problem. As a member of ``Zimpha fan club'', you decided to solve that problem.

You are given two strings $s$ and $t$ of length $n$ and $m$, respectively. Both strings only consist of lowercase English letters, - and *.

You need to replace all occurrences of * and -, observing the following rules:
\begin{bullets}
\item For each -, you must replace it with any lowercase English letter.
\item For each *, you must replace it with a string of any (possibly, zero) length which only consists of lowercase English letters.
\end{bullets}

Note that you can replace two different instances of - with different characters. You can also replace each two different instances of * with different strings.

Suppose $s$ and $t$ have been transformed into $s'$ and $t'$. Now you are wondering if there is a replacement that makes $s'=t'$.

Input: The first line of input contains two integers $n$ and $m$ ($1 \le n, m \le 2 \cdot 10^6$) — the length of the strings $s$ and $t$, respectively.

The second line contains the string $s$ of length $n$. It is guaranteed that $s$ only consists of lowercase English letters, - and *.

The third line contains the string $t$ of length $m$. It is guaranteed that $t$ only consists of lowercase English letters, - and *.

Output: Output ``Yes'' if there is a replacement that makes $s'=t'$, and output ``No'' otherwise.

You can output ``Yes'' and ``No'' in any case (for example, strings ``yEs'', ``yes'', ``Yes'' and ``YES'' will be recognized as a positive response).

Note: In the second test case, we can transform both strings into ttklwxx. In $s$, - will be replaced with l. In $t$, * will be replaced by the empty string with the first and second - will be replaced with k and w respectively.

In the fifth test case, we can transform both strings into bulijiojioxdibuliduo.}
\BREAKDOWN{Treat both inputs as wildcard patterns where - matches exactly one lowercase letter and * matches any string (possibly empty) of lowercase letters. Decide if the languages of the two patterns intersect (i.e., if there exists at least one common string).}
\ELI{Before the first star and after the last star in either string, things must match position-by-position (letters equal or matched by -). In the middle, if both sides contain a star, it is always solvable; if only one side has a star, ensure the starred side can cover the exact length and embed its fixed letters into the other.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single test case.
\begin{bullets}
\item Integers $n,m$ with $1 \le n,m \le 2\cdot 10^6$.
\item String $s$ of length $n$ over alphabet $\{a,\ldots,z\}\cup\{-\}\cup\{*\}$.
\item String $t$ of length $m$ over the same alphabet.
\end{bullets}}
\OUTPUTS{A single line with ``Yes'' if there exists a common string $u$ of lowercase letters such that $u$ matches both $s$ and $t$ under the given wildcard semantics; otherwise ``No''.}
\SAMPLES{
Example 1:
\begin{tcolorbox}
Input\\
3 3\\
a-b\\
a*b\\
Output\\
Yes
\end{tcolorbox}
Example 2:
\begin{tcolorbox}
Input\\
2 1\\
a*\\
a\\
Output\\
Yes
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma=\{a,\ldots,z\}$. A pattern is a word over $\Sigma \cup \{-\} \cup \{*\}$. Define the language $L(p)\subseteq \Sigma^*$ by interpreting $-$ as any single letter in $\Sigma$ and $*$ as any string in $\Sigma^*$ (possibly empty). The task is to decide if $L(s)\cap L(t)\ne \varnothing$.}
\varmapStart
\var{s,t}{input patterns}
\var{n,m}{lengths of $s$ and $t$}
\var{\Sigma}{lowercase English letters}
\var{u}{a candidate string in $\Sigma^*$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
L(\alpha\beta) &= L(\alpha)\cdot L(\beta),\\
L(a) &= \{a\}\text{ for }a\in\Sigma,\quad
L(-)=\Sigma,\quad
L(*)=\Sigma^*,\\
\text{Decide }&L(s)\cap L(t)\ne \varnothing.
\end{aligned}
\]
}
\ASSUMPTIONS{Consecutive stars act as a single star; - and literal letters consume exactly one symbol; indexing is $0$-based in algorithms.}
\INVARIANTS{
\begin{bullets}
\item Before the first star in either pattern, alignment is rigid: positions must be pairwise compatible.
\item After the last star in either pattern (scanned backwards), alignment is rigid as well.
\item If both residual middles contain a star, the intersection is nonempty (shortest common supersequence exists).
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Model both patterns as NFAs and check emptiness of the product automaton via DP on indices $(i,j)$. Transition by consuming one letter when possible; treat $*$ as staying or advancing after generating letters.}
\ASSUMPTIONS{Only feasible for small inputs due to $O(nm)$ worst-case behavior.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a boolean DP reachability grid on pairs $(i,j)$ meaning prefixes $s[:i]$ and $t[:j]$ can generate a common string.
\item From $(i,j)$, add transitions:
  \begin{bullets}
  \item If $s[i]$ or $t[j]$ is $*$, allow zero-consume moves $(i+1,j)$ or $(i,j+1)$ and one-letter consume moves that keep the star index.
  \item If both consume exactly one letter (literal or -), they are compatible unless both are letters and differ.
  \end{bullets}
\item Accept if $(n,m)$ is reachable.
\end{algosteps}
\COMPLEXITY{$T(n)=O(nm)$, $S(n)=O(nm)$; suitable only for tiny $n,m$.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm) \\
S(n,m) &= \Theta(nm).
\end{aligned}
\]
\CORRECTNESS{The product-automaton DP explores all interleavings of emissions consistent with both patterns; acceptance iff a common string exists.}
\EDGECASES{No stars in either; single character conflicts; consecutive stars; empty middle segments.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline DP on (i,j) -- only for very small inputs (O(nm)).
# Included for completeness; not intended for 2e6 limits.

from collections import deque

def compatible_one(a: str, b: str) -> bool:
    # Returns True if tokens a and b can both consume the SAME single letter now.
    # a/b in {a..z, '-', '*'} but we only call this for non-star cases.
    if a == '*' or b == '*':
        return True  # caller ensures how stars act; here we only check letters/'-'
    if a == '-' or b == '-':
        return True
    return a == b

def exists_common_string_dp(s: str, t: str) -> bool:
    n, m = len(s), len(t)
    # Limit to keep baseline safe
    MAX = 1500
    if n > MAX or m > MAX:
        # Fallback to fast method to keep runtime bounded in this educational block.
        return exists_common_string_fast(s, t)

    from collections import deque
    vis = [[False]*(m+1) for _ in range(n+1)]
    q = deque()
    vis[0][0] = True
    q.append((0,0))

    while q:
        i, j = q.popleft()
        if i == n and j == m:
            return True

        # Zero-consume transitions for stars
        if i < n and s[i] == '*' and not vis[i+1][j]:
            vis[i+1][j] = True
            q.append((i+1, j))
        if j < m and t[j] == '*' and not vis[i][j+1]:
            vis[i][j+1] = True
            q.append((i, j+1))

        # Consume one letter from both sides
        # Cases: star on either side can emit a letter and stay; non-star must advance.
        next_is = []
        if i < n and s[i] == '*':
            next_is.append((i, True))  # star stays, emits a letter
            next_is.append((i+1, False))  # or star moves after emitting zero, but for "both consume" we keep it simple
        else:
            if i < n:
                next_is.append((i+1, False))
        next_js = []
        if j < m and t[j] == '*':
            next_js.append((j, True))
            next_js.append((j+1, False))
        else:
            if j < m:
                next_js.append((j+1, False))

        for ni, _ in next_is:
            for nj, _ in next_js:
                # Determine the tokens being used to emit one letter:
                ai = s[i] if (i < n) else None
                bj = t[j] if (j < m) else None
                # Emitting a letter is possible if:
                # - ai == '*' always ok; or ai == '-' or letter
                # - same for bj
                # If both not '*', they must be compatible_one
                ok = True
                if i < n and ai != '*' and j < m and bj != '*':
                    ok = compatible_one(ai, bj)
                # If one side is at end, it cannot emit further
                if i == n or j == m:
                    ok = False
                if ok and not vis[ni][nj]:
                    vis[ni][nj] = True
                    q.append((ni, nj))

    return False

def read_input():
    import sys
    data = sys.stdin.read().strip().splitlines()
    if not data:
        return None
    n, m = map(int, data[0].split())
    s = data[1].strip()
    t = data[2].strip()
    return n, m, s, t

def solve_case(n, m, s, t):
    print("Yes" if exists_common_string_dp(s, t) else "No")

def main():
    x = read_input()
    if x is None:
        return
    n, m, s, t = x
    solve_case(n, m, s, t)

if __name__ == "__main__":
    # Basic asserts for the baseline
    def exists_common_string_fast(s, t):
        # Forward declaration for baseline; actual fast implementation is provided in later sections.
        # Minimal drop-in: reuse the optimal method from Approach C copied here for the test.
        return exists_common_string_linear(s, t)

    def exists_common_string_linear(s: str, t: str) -> bool:
        n, m = len(s), len(t)
        # Prefix strict match until first star in either
        i = 0
        while i < n and i < m and s[i] != '*' and t[i] != '*':
            a, b = s[i], t[i]
            if a not in "-*" and b not in "-*" and a != b:
                return False
            i += 1
        # Suffix strict match until last star in either
        k = 0
        limn = n - i
        limm = m - i
        maxk = limn if limn < limm else limm
        while k < maxk and s[n-1-k] != '*' and t[m-1-k] != '*':
            a, b = s[n-1-k], t[m-1-k]
            if a not in "-*" and b not in "-*" and a != b:
                return False
            k += 1
        sL, sR = i, n - k
        tL, tR = i, m - k
        if sL >= sR and tL >= tR:
            return True
        def has_star(X, L, R):
            for p in range(L, R):
                if X[p] == '*': return True
            return False
        sStar = has_star(s, sL, sR)
        tStar = has_star(t, tL, tR)
        if sStar and tStar:
            return True
        def count_non_star(X, L, R):
            c = 0
            for p in range(L, R):
                if X[p] != '*': c += 1
            return c
        def embed_letters(Star, SL, SR, NoStar, TL, TR):
            # Star has at least one '*', NoStar has none in [TL,TR)
            K = count_non_star(Star, SL, SR)
            L = TR - TL
            if K > L:
                return False
            pos = TL
            for p in range(SL, SR):
                ch = Star[p]
                if 'a' <= ch <= 'z':
                    while pos < TR and not (NoStar[pos] == '-' or NoStar[pos] == ch):
                        pos += 1
                    if pos == TR:
                        return False
                    pos += 1
            return True
        # Case: exactly one has star in middle
        if sStar and not tStar:
            return embed_letters(s, sL, sR, t, tL, tR)
        if tStar and not sStar:
            return embed_letters(t, tL, tR, s, sL, sR)
        # Neither has star but middle not empty -> must be rigid equal length and pairwise compatible
        if (sR - sL) != (tR - tL):
            return False
        for off in range(sR - sL):
            a, b = s[sL+off], t[tL+off]
            if a not in "-*" and b not in "-*" and a != b:
                return False
        return True

    # Tiny tests
    assert exists_common_string_linear("ab", "a-") is True
    assert exists_common_string_linear("a*b", "a") is False
    assert exists_common_string_linear("*a", "b*") is True
    assert exists_common_string_linear("a", "b") is False
    assert exists_common_string_dp("a*b", "ab") is True
    # main()  # Do not auto-run on import
    pass
\end{minted}
\VALIDATION{Checked simple positive/negative matches: exact letters, single/mixed stars, and dash flexibility.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prefix/Suffix Trimming + Middle Classification}
\WHICHFORMULA{Exploit rigidity before the first star and after the last star. After trimming, classify remaining middle:
both-star implies feasible; single-star requires length feasibility and embedding of literal letters.}
\ASSUMPTIONS{Consecutive stars can be treated as one; dash matches any single letter; letters must match letters unless absorbed by a star.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan from the left while neither side has hit a star; require per-position compatibility (letters equal or at least one dash).
\item Scan from the right while neither side has hit a star; require per-position compatibility.
\item Let the remaining middle slices be $S$ and $T$.
\item If both contain a star, answer Yes.
\item Else if exactly one contains a star, check:
  \begin{bullets}
  \item Non-star token count in the starred side $\le$ length of the other side.
  \item Literal letters in the starred side can be greedily embedded into positions of the other side that are either the same letter or dash.
  \end{bullets}
\item Else (neither contains a star), require equal length and per-position compatibility.
\end{algosteps}
\COMPLEXITY{Linear in total length; beats baseline's quadratic DP.}
\[
\begin{aligned}
T(n,m) &= O(n+m),\\
S(n,m) &= O(1) \text{ extra (beyond input)}.
\end{aligned}
\]
\CORRECTNESS{Prefix/suffix must align rigidly; the middle classification is complete: with both stars, a shortest common supersequence exists; with one star, feasibility reduces to length and letter embedding because dashes/stars can supply arbitrary letters.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved linear scan implementation.

def exists_common_string_linear(s: str, t: str) -> bool:
    n, m = len(s), len(t)
    # 1) Left rigid prefix
    i = 0
    while i < n and i < m and s[i] != '*' and t[i] != '*':
        a, b = s[i], t[i]
        if a not in "-*" and b not in "-*" and a != b:
            return False
        i += 1
    # 2) Right rigid suffix
    k = 0
    maxk = min(n - i, m - i)
    while k < maxk and s[n-1-k] != '*' and t[m-1-k] != '*':
        a, b = s[n-1-k], t[m-1-k]
        if a not in "-*" and b not in "-*" and a != b:
            return False
        k += 1
    sL, sR = i, n - k
    tL, tR = i, m - k
    # Fully matched
    if sL >= sR and tL >= tR:
        return True

    def has_star(X, L, R):
        for p in range(L, R):
            if X[p] == '*':
                return True
        return False

    sStar = has_star(s, sL, sR)
    tStar = has_star(t, tL, tR)
    if sStar and tStar:
        return True

    def count_non_star(X, L, R):
        c = 0
        for p in range(L, R):
            if X[p] != '*':
                c += 1
        return c

    def embed_letters(Star, SL, SR, NoStar, TL, TR):
        # Star has at least one '*', NoStar has none
        K = count_non_star(Star, SL, SR)
        L = TR - TL
        if K > L:
            return False
        pos = TL
        for p in range(SL, SR):
            ch = Star[p]
            if 'a' <= ch <= 'z':
                while pos < TR and not (NoStar[pos] == '-' or NoStar[pos] == ch):
                    pos += 1
                if pos == TR:
                    return False
                pos += 1
        return True

    if sStar and not tStar:
        return embed_letters(s, sL, sR, t, tL, tR)
    if tStar and not sStar:
        return embed_letters(t, tL, tR, s, sL, sR)

    # Neither has star in the middle: must match rigidly
    if (sR - sL) != (tR - tL):
        return False
    for off in range(sR - sL):
        a, b = s[sL+off], t[tL+off]
        if a not in "-*" and b not in "-*" and a != b:
            return False
    return True

# Same I/O scaffold as baseline
def read_input():
    import sys
    data = sys.stdin.read().strip().splitlines()
    if not data:
        return None
    n, m = map(int, data[0].split())
    s = data[1].strip()
    t = data[2].strip()
    return n, m, s, t

def solve_case(n, m, s, t):
    print("Yes" if exists_common_string_linear(s, t) else "No")

def main():
    x = read_input()
    if x is None:
        return
    n, m, s, t = x
    solve_case(n, m, s, t)

if __name__ == "__main__":
    # Edge checks
    assert exists_common_string_linear("ab", "a-") is True
    assert exists_common_string_linear("a*b", "a") is False
    assert exists_common_string_linear("*a", "b*") is True
    assert exists_common_string_linear("a", "b") is False
    # main()
    pass
\end{minted}
\VALIDATION{Validated rigid prefix/suffix mismatches and single/both-star middles; included asserts.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two-Sided Wildcards via Trim-and-Embed}
\WHICHFORMULA{Linear-time decision:
rigidly match prefix/suffix around nearest stars, then classify the middle:
both-star always feasible; single-star requires non-star count $\le$ other length and greedy embedding of literal letters.}
\ASSUMPTIONS{Letters are in $\{a,\ldots,z\}$; '-' matches any single letter; '*' matches any string (possibly empty). Consecutive '*' equivalent to a single '*'.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Match from the left until the first star in either string; require pairwise compatibility.
\item Match from the right until the first star from the right in either string; require compatibility.
\item If both remaining middles contain a star, return Yes.
\item If exactly one middle contains a star: let $K$ be the count of non-star tokens in the starred middle and $L$ the length of the other middle. Require $K \le L$ and greedily embed each literal letter of the starred middle into the other middle at a position that is the same letter or dash.
\item If neither has a star, require equal length and pairwise compatibility.
\end{algosteps}
\OPTIMALITY{Any solution must at least scan the inputs; the algorithm is $O(n+m)$ time and $O(1)$ extra space, which is optimal up to constants.}
\COMPLEXITY{$O(n+m)$ time, $O(1)$ extra space.}
\[
\begin{aligned}
T(n,m) &= \Theta(n+m),\quad S(n,m)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: Single test; linear-time solution suitable for n,m up to 2e6.

import sys

def exists_common_string_linear(s: str, t: str) -> bool:
    n, m = len(s), len(t)
    # 1) Left rigid prefix
    i = 0
    while i < n and i < m and s[i] != '*' and t[i] != '*':
        a, b = s[i], t[i]
        if a not in "-*" and b not in "-*" and a != b:
            return False
        i += 1
    # 2) Right rigid suffix
    k = 0
    maxk = min(n - i, m - i)
    while k < maxk and s[n-1-k] != '*' and t[m-1-k] != '*':
        a, b = s[n-1-k], t[m-1-k]
        if a not in "-*" and b not in "-*" and a != b:
            return False
        k += 1
    sL, sR = i, n - k
    tL, tR = i, m - k
    # Fully matched
    if sL >= sR and tL >= tR:
        return True

    def has_star(X, L, R):
        for p in range(L, R):
            if X[p] == '*':
                return True
        return False

    sStar = has_star(s, sL, sR)
    tStar = has_star(t, tL, tR)
    if sStar and tStar:
        return True

    def count_non_star(X, L, R):
        c = 0
        for p in range(L, R):
            if X[p] != '*':
                c += 1
        return c

    def embed_letters(Star, SL, SR, NoStar, TL, TR):
        # Star has at least one '*', NoStar has none
        K = count_non_star(Star, SL, SR)
        L = TR - TL
        if K > L:
            return False
        pos = TL
        for p in range(SL, SR):
            ch = Star[p]
            if 'a' <= ch <= 'z':
                while pos < TR and not (NoStar[pos] == '-' or NoStar[pos] == ch):
                    pos += 1
                if pos == TR:
                    return False
                pos += 1
        return True

    if sStar and not tStar:
        return embed_letters(s, sL, sR, t, tL, tR)
    if tStar and not sStar:
        return embed_letters(t, tL, tR, s, sL, sR)

    # Neither has star in the middle: must match rigidly
    if (sR - sL) != (tR - tL):
        return False
    for off in range(sR - sL):
        a, b = s[sL+off], t[tL+off]
        if a not in "-*" and b not in "-*" and a != b:
            return False
    return True

def read_input():
    data = sys.stdin.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    m = int(next(it))
    s = next(it).strip()
    t = next(it).strip()
    return n, m, s, t

def solve_all():
    x = read_input()
    if x is None:
        return
    n, m, s, t = x
    # Optionally assert lengths if needed:
    # assert len(s) == n and len(t) == m
    print("Yes" if exists_common_string_linear(s, t) else "No")

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts
    assert exists_common_string_linear("ab", "a-") is True
    assert exists_common_string_linear("a*b", "a") is False
    assert exists_common_string_linear("*a", "b*") is True
    # main()
    pass
\end{minted}
\VALIDATION{Three asserts cover dash flexibility, single-star insufficiency due to length, and both-stars feasibility.}
\RESULT{Outputs ``Yes'' iff a common string over lowercase letters exists that matches both patterns; otherwise ``No''. Case-insensitive in printing is accepted by the platform.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for: no-star rigid matches; early mismatched letters; only one side has star with sufficient/insufficient length; both sides have stars anywhere; consecutive stars.}
\LINE{CROSS-CHECKS}{Compare Baseline DP vs Improved/Optimal on small random patterns (e.g., lengths up to 15) to ensure identical decisions.}
\LINE{EDGE-CASE GENERATOR}{Generate random patterns with varying densities of '-', '*' and letters; ensure handling of leading/trailing stars and long runs of stars.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

import random

def gen_pattern(n, seed=0, p_star=0.2, p_dash=0.2):
    rnd = random.Random(seed)
    s = []
    for _ in range(n):
        r = rnd.random()
        if r < p_star:
            s.append('*')
        elif r < p_star + p_dash:
            s.append('-')
        else:
            s.append(chr(ord('a') + rnd.randint(0,25)))
    return ''.join(s)

def brute_exists(s, t):
    # Use baseline DP but with small cutoff
    return exists_common_string_linear(s, t)

def self_test():
    # Fixed adversarials
    cases = [
        ("", ""),  # trivial
        ("a", "a"),
        ("a", "b"),
        ("-", "a"),
        ("*", "a"),
        ("a*b", "ab"),
        ("a*b", "a*b"),
        ("*a", "b*"),
        ("*b", "aaa"),
        ("ab", "a-"),
        ("-*-*-", "*"),
        ("***", "a"),
    ]
    for s, t in cases:
        assert brute_exists(s, t) == exists_common_string_linear(s, t)

    # Random small stress
    seeds = [1,2,3,4,5]
    for n in range(0, 8):
        for m in range(0, 8):
            for sd in seeds:
                s = gen_pattern(n, seed=sd)
                t = gen_pattern(m, seed=sd+101)
                assert brute_exists(s, t) == exists_common_string_linear(s, t)

# Reference code reuses the optimal implementation from Approach C
def read_input():
    import sys
    data = sys.stdin.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    m = int(next(it))
    s = next(it).strip()
    t = next(it).strip()
    return n, m, s, t

def solve_all():
    x = read_input()
    if x is None:
        return
    n, m, s, t = x
    print("Yes" if exists_common_string_linear(s, t) else "No")

def main():
    # self_test()  # uncomment for local testing
    solve_all()

if __name__ == "__main__":
    # self_test()
    pass
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final, concise solution (same as Approach C), ready for submission.

import sys

def exists_common_string_linear(s: str, t: str) -> bool:
    n, m = len(s), len(t)
    i = 0
    while i < n and i < m and s[i] != '*' and t[i] != '*':
        a, b = s[i], t[i]
        if a not in "-*" and b not in "-*" and a != b:
            return False
        i += 1
    k = 0
    maxk = min(n - i, m - i)
    while k < maxk and s[n-1-k] != '*' and t[m-1-k] != '*':
        a, b = s[n-1-k], t[m-1-k]
        if a not in "-*" and b not in "-*" and a != b:
            return False
        k += 1
    sL, sR = i, n - k
    tL, tR = i, m - k
    if sL >= sR and tL >= tR:
        return True

    def has_star(X, L, R):
        for p in range(L, R):
            if X[p] == '*':
                return True
        return False

    sStar = has_star(s, sL, sR)
    tStar = has_star(t, tL, tR)
    if sStar and tStar:
        return True

    def count_non_star(X, L, R):
        c = 0
        for p in range(L, R):
            if X[p] != '*':
                c += 1
        return c

    def embed_letters(Star, SL, SR, NoStar, TL, TR):
        K = count_non_star(Star, SL, SR)
        L = TR - TL
        if K > L:
            return False
        pos = TL
        for p in range(SL, SR):
            ch = Star[p]
            if 'a' <= ch <= 'z':
                while pos < TR and not (NoStar[pos] == '-' or NoStar[pos] == ch):
                    pos += 1
                if pos == TR:
                    return False
                pos += 1
        return True

    if sStar and not tStar:
        return embed_letters(s, sL, sR, t, tL, tR)
    if tStar and not sStar:
        return embed_letters(t, tL, tR, s, sL, sR)

    if (sR - sL) != (tR - tL):
        return False
    for off in range(sR - sL):
        a, b = s[sL+off], t[tL+off]
        if a not in "-*" and b not in "-*" and a != b:
            return False
    return True

def read_input():
    data = sys.stdin.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    m = int(next(it))
    s = next(it).strip()
    t = next(it).strip()
    return n, m, s, t

def solve_all():
    x = read_input()
    if x is None:
        return
    n, m, s, t = x
    print("Yes" if exists_common_string_linear(s, t) else "No")

def main():
    solve_all()

if __name__ == "__main__":
    # Quick sanity asserts
    assert exists_common_string_linear("ab", "a-") is True
    assert exists_common_string_linear("a*b", "a") is False
    assert exists_common_string_linear("*a", "b*") is True
    # main()
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Decide if two wildcard patterns (letters, -, *) over lowercase letters share at least one common matching string.}
\WHY{Tests deep understanding of greedy matching, prefix/suffix rigidity, and reasoning about regular-language intersections with restricted operators.}
\CHECKLIST{
\begin{bullets}
\item Trim left until first star in either; enforce compatibility.
\item Trim right until first star in either from the end; enforce compatibility.
\item If both middles have a star, answer Yes.
\item If exactly one middle has a star: ensure non-star count $\le$ other length and embed literal letters greedily.
\item If neither has a star, lengths must match and all positions be compatible.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item No stars in both patterns: require $n=m$ and per-position compatibility.
\item Leading/trailing stars.
\item Consecutive stars (treat as one).
\item One-letter conflicts at rigid ends (cannot be shifted).
\item Only one star overall but insufficient length to place all non-star tokens.
\item Other side has only fixed letters (no dashes) that miss a required letter from the starred side.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Comparing beyond overlap when trimming suffix; ensure not to cross the trimmed prefix.
\item Forgetting that '-' matches any single letter (not empty).
\item Assuming both-stars always Yes without checking rigid ends.
\item Building large slices or DPs for huge inputs; keep $O(1)$ extra memory and one pass.
\item Mishandling Unicode or uppercase letters (alphabet is strictly lowercase).
\item Not collapsing or ignoring runs of stars; classification relies on presence, not count.
\end{bullets}}
\FAILMODES{Quadratic DP times out or runs out of memory for $n,m\approx 2\cdot 10^6$. The linear approach survives by a single forward/backward scan and local checks.}
\ELI{Match what you can before and after the stars; stars in both middles give you enough freedom to weave the rest. With only one star, just make sure you have enough room and can place the required fixed letters where the other side allows (same letter or dash).}
\NotePages{3}

\end{document}