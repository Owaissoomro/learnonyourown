% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Squid Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1610/H}}
\LINE{DIFFICULTY / RATING}{CF: 1610/H, Rating: 3100}
\STATEMENT{After watching the new over-rated series Squid Game, Mashtali and Soroush decided to hold their own Squid Games! Soroush agreed to be the host and will provide money for the winner's prize, and Mashtali became the Front Man!

$m$ players registered to play in the games to win the great prize, but when Mashtali found out how huge the winner's prize is going to be, he decided to kill eliminate all the players so he could take the money for himself!

Here is how evil Mashtali is going to eliminate players:

There is an unrooted tree with $n$ vertices. Every player has $2$ special vertices $x_i$ and $y_i$.

In one operation, Mashtali can choose any vertex $v$ of the tree. Then, for each remaining player $i$ he finds a vertex $w$ on the simple path from $x_i$ to $y_i$, which is the closest to $v$. If $w\ne x_i$ and $w\ne y_i$, player $i$ will be eliminated.

Now Mashtali wondered: ``What is the minimum number of operations I should perform so that I can remove every player from the game and take the money for myself?''

Since he was only thinking about the money, he could not solve the problem by himself and asked for your help!

Input:
The first line contains $2$ integer $n$ and $m$ $(1 \le n, m \le 3 \cdot 10^5)$ — the number of vertices of the tree and the number of players.

The second line contains $n-1$ integers $par_2, par_3, \ldots, par_n$ $(1 \le par_i < i)$ — denoting an edge between node $i$ and $par_i$.

The $i$-th of the following $m$ lines contains two integers $x_i$ and $y_i$ $(1 \le x_i, y_i \le n, x_i \ne y_i)$ — the special vertices of the $i$-th player.

Output:
Print the minimum number of operations Mashtali has to perform.

If there is no way for Mashtali to eliminate all the players, print $-1$.

Note:
Explanation for the first sample:

In the first operation, Mashtali can choose vertex $1$ and eliminate players with colors red and blue. In the second operation, he can choose vertex $6$ and eliminate the player with orange color.

In the second sample, Mashtali cannot eliminate the first player.}
\BREAKDOWN{We must choose a minimum-size set of operation vertices so that, for each player path $(x_i,y_i)$, at least one chosen vertex projects to an internal point of that path (not an endpoint). If any path has length $1$, elimination is impossible. Otherwise, we can restrict attention to selecting tree vertices that lie on the interior of paths.}
\ELI{Pick as few tree vertices as possible so that every given path has at least one selected internal vertex; if some path is just one edge, answer is $-1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test.\\
- $n$ (int), $m$ (int), $1 \le n,m \le 3\cdot 10^5$.\\
- Parents $par_2,\ldots,par_n$ with $1 \le par_i < i$, edges $(i,par_i)$.\\
- $m$ pairs $(x_i,y_i)$ with $1 \le x_i \ne y_i \le n$.}
\OUTPUTS{A single integer: the minimum number of operations; or $-1$ if impossible.}
\SAMPLES{- Example 1 (informal): a path with three colored pairs; choose vertex $1$ then $6$ to finish, so output $2$.\\
- Example 2 (informal): one player path has length $1$, so output $-1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a tree $T=(V,E)$ and a multiset of simple paths $\mathcal{P}=\{P_i\}$ with endpoints $(x_i,y_i)$. An operation chooses $v\in V$ and eliminates every path $P_i$ for which the metric projection of $v$ onto $P_i$ is an internal vertex (i.e., not $x_i$ or $y_i$). If $\mathrm{dist}(x_i,y_i)=1$ for some $i$, no $v$ can eliminate $P_i$. Find the minimum number of operations to eliminate all players.}
\varmapStart
\var{T=(V,E)}{input tree}
\var{\mathcal{P}}{set of player paths}
\var{x_i,y_i}{endpoints of the $i$-th path}
\var{L_i}{$\mathrm{lca}(x_i,y_i)$ in an arbitrary root}
\var{S}{chosen operation vertices}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Feasibility: }&\forall i,\ \mathrm{dist}(x_i,y_i)\ge 2.\\
\text{Elimination: }&\forall i,\ \exists v\in S:\ v\in P_i\setminus\{x_i,y_i\}.\\
\text{Objective: }&\min |S|.
\end{aligned}
\]
}
\ASSUMPTIONS{Root the tree at $1$ for convenience; all LCA operations refer to this root. Paths are unique in a tree.}
\INVARIANTS{- If $v$ lies on the interior of $P_i$, then choosing $v$ eliminates player $i$.\\
- If $\mathrm{dist}(x_i,y_i)=1$, no operation can eliminate player $i$ (projection always hits an endpoint).\\
- There exists an optimal solution selecting only vertices on path interiors (never need off-path vertices).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedy by decreasing $\mathrm{depth}(\mathrm{lca})$: if a path is not yet covered by any previously chosen internal vertex, pick an internal vertex on it. Check coverage by explicitly enumerating path nodes.}
\ASSUMPTIONS{Tree sizes are moderate in this baseline; path enumeration may be $O(n)$ per query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the tree, root at $1$; preprocess parent and LCA with binary lifting.
\item Sort all pairs by decreasing $\mathrm{depth}(\mathrm{lca}(x_i,y_i))$.
\item For each pair in order: if there is no selected vertex on the interior of the path (checked by enumerating nodes along the path and ignoring endpoints), then select an interior vertex: choose $\mathrm{lca}(x,y)$ if it is not an endpoint; otherwise choose the child of the endpoint-$\mathrm{lca}$ toward the other endpoint.
\end{algosteps}
\COMPLEXITY{Worst case $O\!\left(\sum |P_i| \right)$ for coverage checks, which is $O(nm)$ in the worst case; preprocessing $O(n\log n)$.}
\[
\begin{aligned}
T(n,m) &\approx O(n\log n) + O\!\left(\sum_{i=1}^m |P_i|\right) \\
&\le O(n\log n + nm).\\
S(n) &= O(n\log n).
\end{aligned}
\]
\CORRECTNESS{Processing deepest LCAs first ensures that when a path is uncovered, picking the interior vertex described covers it and does not invalidate previously covered paths. Selecting $\mathrm{lca}(x,y)$ if internal, else the child toward the other endpoint, always picks an internal vertex when $\mathrm{dist}(x,y)\ge 2$.}
\EDGECASES{- Any $(x,y)$ with $\mathrm{dist}(x,y)=1$ implies answer $-1$.\\
- Paths that share only endpoints do not cover each other; endpoints are excluded.\\
- Multiple identical paths are handled naturally by coverage test.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1 << 25)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    parents = [0]*(n+1)
    parents[1] = 0
    for i in range(2, n+1):
        parents[i] = int(next(it))
    pairs = []
    for _ in range(m):
        x = int(next(it)); y = int(next(it))
        pairs.append((x, y))
    return (n, m, parents, pairs)

def build_tree(n, parents):
    g = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        p = parents[v]
        g[v].append(p)
        g[p].append(v)
    return g

def preprocess_lca(n, g, root=1):
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)

    stk = [(root, 0, 0)]  # (u, p, state) 0=enter,1=exit
    order = []
    parent[root] = 0
    depth[root] = 0
    while stk:
        u, p, st = stk.pop()
        if st == 0:
            parent[u] = p
            order.append(u)
            stk.append((u, p, 1))
            for v in g[u]:
                if v == p: continue
                depth[v] = depth[u] + 1
                stk.append((v, u, 0))
        else:
            pass
    for v in range(1, n+1):
        up[0][v] = parent[v]
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]
    return up, depth, parent

def lca(u, v, up, depth):
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    du = depth[u] - depth[v]
    for k in range(LOG-1, -1, -1):
        if du & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def ascend(u, k, up):
    for i in range(len(up)):
        if k & (1 << i):
            u = up[i][u]
    return u

def path_nodes(u, v, up, depth, parent):
    # enumerate nodes on path u..v inclusive (slow): up from u to l, then down from l to v
    l = lca(u, v, up, depth)
    path = []
    # up from u to l
    x = u
    while x != l:
        path.append(x)
        x = parent[x]
    path.append(l)
    # collect down from l to v by stacking
    down = []
    y = v
    while y != l:
        down.append(y)
        y = parent[y]
    while down:
        path.append(down.pop())
    return path

def solve_greedy_naive(n, parents, pairs):
    g = build_tree(n, parents)
    up, depth, parent = preprocess_lca(n, g, 1)

    def dist(a, b):
        c = lca(a, b, up, depth)
        return depth[a] + depth[b] - 2*depth[c]

    # Check impossible
    for x, y in pairs:
        if dist(x, y) == 1:
            return -1

    # Sort by depth of lca decreasing
    pairs_sorted = sorted(pairs, key=lambda p: depth[lca(p[0], p[1], up, depth)], reverse=True)

    chosen = set()
    ans = 0

    for x, y in pairs_sorted:
        p = path_nodes(x, y, up, depth, parent)
        # interior = p[1:-1]
        covered = any((v in chosen) for v in p[1:-1])
        if covered:
            continue
        # choose an interior vertex
        L = lca(x, y, up, depth)
        if L != x and L != y:
            s = L
        elif L == x:
            # choose child toward y (not y, because dist>=2 here)
            steps = depth[y] - depth[L] - 1
            s = ascend(y, steps, up)
        else:  # L == y
            steps = depth[x] - depth[L] - 1
            s = ascend(x, steps, up)
        # safety assert: s must be interior
        assert s != x and s != y
        chosen.add(s)
        ans += 1
    return ans

def solve_all():
    data = read_input()
    if data is None:
        return
    n, m, parents, pairs = data
    print(solve_greedy_naive(n, parents, pairs))

def main():
    if sys.stdin.isatty():
        # Simple self-checks
        # 1) Line tree 1-2-3-4, pairs (1,3), (2,4) -> need 2
        n = 4
        parents = [0,0,1,2,3]
        pairs = [(1,3),(2,4)]
        assert solve_greedy_naive(n, parents, pairs) == 2
        # 2) Star 1-2,1-3,1-4, pairs (2,3),(2,4) -> pick 1 once
        n = 4
        parents = [0,0,1,1,1]
        pairs = [(2,3),(2,4)]
        assert solve_greedy_naive(n, parents, pairs) == 1
        # 3) Edge path length 1 impossible
        n = 2
        parents = [0,0,1]
        pairs = [(1,2)]
        assert solve_greedy_naive(n, parents, pairs) == -1
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{- Verifies impossibility for $\mathrm{dist}=1$.\\
- Checks a star and a line tree for expected counts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same greedy order by decreasing $\mathrm{depth}(\mathrm{lca})$, but maintain coverage with Heavy-Light Decomposition (HLD) plus a Fenwick tree over Euler positions to test if any already-chosen vertex lies on the interior of the path in $O(\log n)$.}
\ASSUMPTIONS{We can preprocess HLD in $O(n)$ and answer path-sum queries in $O(\log n)$; updates are point-adds.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute LCA, HLD arrays: head, heavy child, parent, depth, position.
\item Maintain a Fenwick tree of chosen vertices (point updates).
\item For each pair in decreasing $\mathrm{depth}(\mathrm{lca})$, query the sum on path $(x,y)$ and subtract the contributions at $x$ and $y$ to get only interior hits. If positive, skip.
\item Otherwise add one chosen vertex: $\mathrm{lca}(x,y)$ if internal; else the child of the endpoint-$\mathrm{lca}$ toward the other endpoint. Point-update it in the Fenwick tree.
\end{algosteps}
\COMPLEXITY{Each pair processed in $O(\log n)$; preprocessing $O(n)$.}
\[
\begin{aligned}
T(n,m) &= O(n\log n + m\log n),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{The greedy is optimal: processing deepest LCAs first ensures any uncovered path must be covered by choosing an interior node at or below its LCA; choosing the LCA when internal maximizes sharing. Excluding endpoints in the query guarantees we only count valid eliminators.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1 << 25)

class Fenwick:
    def __init__(self, n):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, i, v):
        i += 1
        while i <= self.n:
            self.bit[i] += v
            i += i & -i
    def sum(self, i):
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s
    def range_sum(self, l, r):
        if l > r: return 0
        return self.sum(r) - self.sum(l-1)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    parents = [0]*(n+1)
    parents[1] = 0
    for i in range(2, n+1):
        parents[i] = int(next(it))
    pairs = []
    for _ in range(m):
        x = int(next(it)); y = int(next(it))
        pairs.append((x, y))
    return (n, m, parents, pairs)

def build_tree(n, parents):
    g = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        p = parents[v]
        g[v].append(p)
        g[p].append(v)
    return g

def preprocess(n, g, root=1):
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)
    size = [0]*(n+1)
    heavy = [-1]*(n+1)

    # DFS1: parent, depth, heavy
    st = [(root, 0, 0, 0)]  # (u,p,state,idx)
    order = []
    parent[root] = 0
    depth[root] = 0
    while st:
        u, p, stt, idx = st.pop()
        if stt == 0:
            parent[u] = p
            st.append((u, p, 1, 0))
            for v in g[u]:
                if v == p: continue
                depth[v] = depth[u] + 1
                st.append((v, u, 0, 0))
        else:
            size[u] = 1
            maxsz = 0
            for v in g[u]:
                if v == p: continue
                size[u] += size[v]
                if size[v] > maxsz:
                    maxsz = size[v]
                    heavy[u] = v

    # up table
    for v in range(1, n+1):
        up[0][v] = parent[v]
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]

    # DFS2: decompose
    head = [0]*(n+1)
    pos = [0]*(n+1)
    cur = 0
    def decompose(u, h):
        nonlocal cur
        head[u] = h
        pos[u] = cur
        cur += 1
        if heavy[u] != -1:
            decompose(heavy[u], h)
            for v in g[u]:
                if v == parent[u] or v == heavy[u]:
                    continue
                decompose(v, v)
    decompose(root, root)
    return up, depth, parent, head, pos

def lca(u, v, up, depth):
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    d = depth[u] - depth[v]
    for k in range(LOG-1, -1, -1):
        if d & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def ascend(u, k, up):
    for i in range(len(up)):
        if k & (1 << i):
            u = up[i][u]
    return u

def path_sum(u, v, head, pos, depth, parent, bit):
    s = 0
    while head[u] != head[v]:
        if depth[head[u]] >= depth[head[v]]:
            s += bit.range_sum(pos[head[u]], pos[u])
            u = parent[head[u]]
        else:
            s += bit.range_sum(pos[head[v]], pos[v])
            v = parent[head[v]]
    # same head
    if depth[u] >= depth[v]:
        s += bit.range_sum(pos[v], pos[u])
    else:
        s += bit.range_sum(pos[u], pos[v])
    return s

def solve_greedy_hld(n, parents, pairs):
    g = build_tree(n, parents)
    up, depth, parent, head, pos = preprocess(n, g, 1)
    def dist(a, b):
        c = lca(a, b, up, depth)
        return depth[a] + depth[b] - 2*depth[c]

    for x, y in pairs:
        if dist(x, y) == 1:
            return -1

    pairs_sorted = sorted(pairs, key=lambda p: depth[lca(p[0], p[1], up, depth)], reverse=True)
    bit = Fenwick(n)
    chosen = [0]*(n+1)
    ans = 0

    for x, y in pairs_sorted:
        # interior sum = path_sum - val[x] - val[y]
        total = path_sum(x, y, head, pos, depth, parent, bit)
        covered = total - chosen[x] - chosen[y] > 0
        if covered:
            continue
        L = lca(x, y, up, depth)
        if L != x and L != y:
            s = L
        elif L == x:
            steps = depth[y] - depth[L] - 1
            s = ascend(y, steps, up)
        else:
            steps = depth[x] - depth[L] - 1
            s = ascend(x, steps, up)
        assert s != x and s != y
        if chosen[s] == 0:
            chosen[s] = 1
            bit.add(pos[s], 1)
            ans += 1
    return ans

def solve_all():
    data = read_input()
    if data is None:
        return
    n, m, parents, pairs = data
    print(solve_greedy_hld(n, parents, pairs))

def main():
    if sys.stdin.isatty():
        # Tests mirror baseline expectations
        n = 4
        parents = [0,0,1,2,3]
        pairs = [(1,3),(2,4)]
        assert solve_greedy_hld(n, parents, pairs) == 2
        n = 4
        parents = [0,0,1,1,1]
        pairs = [(2,3),(2,4)]
        assert solve_greedy_hld(n, parents, pairs) == 1
        n = 2
        parents = [0,0,1]
        pairs = [(1,2)]
        assert solve_greedy_hld(n, parents, pairs) == -1
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{- Confirms correctness on line, star, and impossible edge cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Greedy on LCAs + HLD Interior Coverage}
\WHICHFORMULA{Process pairs in decreasing order of the depth of their LCA. For each uncovered path, select an interior vertex: the LCA if it is not an endpoint, otherwise the child of the LCA toward the opposite endpoint. Maintain coverage with HLD and a Fenwick tree restricted to interior nodes.}
\ASSUMPTIONS{All paths satisfy $\mathrm{dist}(x_i,y_i)\ge 2$; otherwise answer is $-1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Root tree at $1$. Precompute LCA and HLD arrays.
\item Sort all pairs by decreasing $\mathrm{depth}(\mathrm{lca})$.
\item For each pair, query if any chosen vertex lies on the interior of the path via HLD path-sum minus endpoints.
\item If not, add one interior vertex per the rule (LCA or child toward the other endpoint). Update BIT.
\end{algosteps}
\OPTIMALITY{Standard exchange argument: if a deepest-LCA path is uncovered, any optimal solution must pick a vertex on its interior at or below its LCA. Choosing the LCA (if internal) maximizes sharing with other paths; otherwise the unique child toward the other endpoint is still internal. Replacing any other choice by this choice does not increase the number of selections, yielding an optimal greedy.}
\COMPLEXITY{$O((n+m)\log n)$ time, $O(n)$ space.}
\[
\begin{aligned}
T(n,m) &= O(n\log n + m\log n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1 << 25)

class Fenwick:
    def __init__(self, n):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, i, v):
        i += 1
        while i <= self.n:
            self.bit[i] += v
            i += i & -i
    def sum(self, i):
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s
    def range_sum(self, l, r):
        if l > r: return 0
        return self.sum(r) - self.sum(l-1)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    parents = [0]*(n+1)
    parents[1] = 0
    for i in range(2, n+1):
        parents[i] = int(next(it))
    pairs = []
    for _ in range(m):
        x = int(next(it)); y = int(next(it))
        pairs.append((x, y))
    return (n, m, parents, pairs)

def build_tree(n, parents):
    g = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        p = parents[v]
        g[v].append(p)
        g[p].append(v)
    return g

def preprocess(n, g, root=1):
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)
    size = [0]*(n+1)
    heavy = [-1]*(n+1)

    # Iterative DFS1 to avoid recursion limits
    stack = [(root, 0, 0, 0, 0)]  # (u,p,state,ci,child_iter)
    parent[root] = 0
    order = []
    while stack:
        u, p, state, ci, it_idx = stack.pop()
        if state == 0:
            parent[u] = p
            stack.append((u, p, 1, 0, 0))
            for v in g[u]:
                if v == p: continue
                depth[v] = depth[u] + 1
                stack.append((v, u, 0, 0, 0))
        else:
            size[u] = 1
            maxsz = 0
            for v in g[u]:
                if v == p: continue
                size[u] += size[v]
                if size[v] > maxsz:
                    maxsz = size[v]
                    heavy[u] = v

    for v in range(1, n+1):
        up[0][v] = parent[v]
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]

    head = [0]*(n+1)
    pos = [0]*(n+1)
    cur = 0
    # Iterative decomposition using stack
    stack = [(root, root, 0)]  # (u, head, state) 0=enter,1=exit
    while stack:
        u, h, st = stack.pop()
        if st == 0:
            # decompose heavy path first
            head[u] = h
            pos[u] = cur
            cur += 1
            if heavy[u] != -1:
                # push light children first (they will be processed after heavy)
                for v in g[u]:
                    if v == parent[u] or v == heavy[u]: continue
                    stack.append((v, v, 0))
                stack.append((heavy[u], h, 0))
            else:
                pass
        else:
            pass
    return up, depth, parent, head, pos

def lca(u, v, up, depth):
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    d = depth[u] - depth[v]
    for k in range(LOG-1, -1, -1):
        if d & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def ascend(u, k, up):
    for i in range(len(up)):
        if k & (1 << i):
            u = up[i][u]
    return u

def path_sum(u, v, head, pos, depth, parent, bit):
    s = 0
    while head[u] != head[v]:
        if depth[head[u]] >= depth[head[v]]:
            s += bit.range_sum(pos[head[u]], pos[u])
            u = parent[head[u]]
        else:
            s += bit.range_sum(pos[head[v]], pos[v])
            v = parent[head[v]]
    # same head
    if depth[u] >= depth[v]:
        s += bit.range_sum(pos[v], pos[u])
    else:
        s += bit.range_sum(pos[u], pos[v])
    return s

def solve_instance(n, parents, pairs):
    g = build_tree(n, parents)
    up, depth, parent, head, pos = preprocess(n, g, 1)
    def dist(a, b):
        c = lca(a, b, up, depth)
        return depth[a] + depth[b] - 2*depth[c]

    for x, y in pairs:
        if dist(x, y) == 1:
            return -1

    pairs_sorted = sorted(pairs, key=lambda p: depth[lca(p[0], p[1], up, depth)], reverse=True)
    bit = Fenwick(n)
    chosen = [0]*(n+1)
    ans = 0

    for x, y in pairs_sorted:
        total = path_sum(x, y, head, pos, depth, parent, bit)
        covered = total - chosen[x] - chosen[y] > 0
        if covered:
            continue
        L = lca(x, y, up, depth)
        if L != x and L != y:
            s = L
        elif L == x:
            steps = depth[y] - depth[L] - 1
            s = ascend(y, steps, up)
        else:
            steps = depth[x] - depth[L] - 1
            s = ascend(x, steps, up)
        assert s != x and s != y
        if chosen[s] == 0:
            chosen[s] = 1
            bit.add(pos[s], 1)
            ans += 1
    return ans

def solve_all():
    data = read_input()
    if data is None:
        return
    n, m, parents, pairs = data
    print(solve_instance(n, parents, pairs))

def main():
    if sys.stdin.isatty():
        # Exactly 3 asserts
        # 1) Star: 1-2,1-3,1-4; pairs (2,3),(2,4) -> answer 1 (choose 1)
        n = 4
        parents = [0,0,1,1,1]
        assert solve_instance(n, parents, [(2,3),(2,4)]) == 1
        # 2) Line 1-2-3-4; pairs (1,3),(2,4) -> answer 2
        n = 4
        parents = [0,0,1,2,3]
        assert solve_instance(n, parents, [(1,3),(2,4)]) == 2
        # 3) Edge-length path impossible
        n = 2
        parents = [0,0,1]
        assert solve_instance(n, parents, [(1,2)]) == -1
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts cover a star, a path, and an impossible case.}
\RESULT{Minimum number of operations equals the minimum number of selected interior vertices covering all paths; greedy on deepest LCAs with HLD interior coverage yields the optimal count, or $-1$ if any path has length $1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Use tiny deterministic trees (line, star, small random) to check: (a) impossible edge case; (b) overlapping paths sharing an interior; (c) disjoint paths.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved vs Final on the same small cases to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Construct adversarial inputs: many paths sharing only endpoints; chains of LCAs; ensure interior-only coverage.}
\begin{minted}{python}
import random

def gen_line(n):
    parents = [0]*(n+1)
    for i in range(2, n+1):
        parents[i] = i-1
    return parents

def gen_star(n):
    parents = [0]*(n+1)
    for i in range(2, n+1):
        parents[i] = 1
    return parents

def gen_pairs_line(n, k):
    pairs = []
    for _ in range(k):
        a = random.randint(1, n)
        b = random.randint(1, n)
        while b == a:
            b = random.randint(1, n)
        if a > b: a, b = b, a
        pairs.append((a, b))
    return pairs

# Deterministic seeds for reproducibility
random.seed(12345)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final CF-ready implementation: read_input(), solve_all(), and asserts in TTY mode.
import sys
sys.setrecursionlimit(1 << 25)

class Fenwick:
    def __init__(self, n):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, i, v):
        i += 1
        while i <= self.n:
            self.bit[i] += v
            i += i & -i
    def sum(self, i):
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s
    def range_sum(self, l, r):
        if l > r: return 0
        return self.sum(r) - self.sum(l-1)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    parents = [0]*(n+1)
    parents[1] = 0
    for i in range(2, n+1):
        parents[i] = int(next(it))
    pairs = []
    for _ in range(m):
        x = int(next(it)); y = int(next(it))
        pairs.append((x, y))
    return (n, m, parents, pairs)

def build_tree(n, parents):
    g = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        p = parents[v]
        g[v].append(p)
        g[p].append(v)
    return g

def preprocess(n, g, root=1):
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    parent = [0]*(n+1)
    size = [0]*(n+1)
    heavy = [-1]*(n+1)

    # DFS1 (iterative): parent, depth, size, heavy
    stack = [(root, 0, 0)]  # (u,p,state) 0=enter,1=exit
    while stack:
        u, p, st = stack.pop()
        if st == 0:
            parent[u] = p
            stack.append((u, p, 1))
            for v in g[u]:
                if v == p: continue
                depth[v] = depth[u] + 1
                stack.append((v, u, 0))
        else:
            size[u] = 1
            maxsz = 0
            for v in g[u]:
                if v == p: continue
                size[u] += size[v]
                if size[v] > maxsz:
                    maxsz = size[v]
                    heavy[u] = v

    for v in range(1, n+1):
        up[0][v] = parent[v]
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][up[k-1][v]]

    head = [0]*(n+1)
    pos = [0]*(n+1)
    cur = 0
    # Decompose (iterative-ish using stack to mimic recursion order)
    stack = [(root, root, 0)]  # (u, h, state)
    # We'll simulate recursion by manual traversal of heavy first, then lights.
    while stack:
        u, h, st = stack.pop()
        if st == 0:
            # process along heavy path
            while True:
                head[u] = h
                pos[u] = cur
                cur += 1
                # push light children to process later
                for v in g[u]:
                    if v == parent[u] or v == heavy[u]:
                        continue
                    stack.append((v, v, 0))
                if heavy[u] != -1:
                    u = heavy[u]
                else:
                    break
        else:
            pass
    return up, depth, parent, head, pos

def lca(u, v, up, depth):
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    d = depth[u] - depth[v]
    for k in range(LOG-1, -1, -1):
        if d & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def ascend(u, k, up):
    for i in range(len(up)):
        if k & (1 << i):
            u = up[i][u]
    return u

def path_sum(u, v, head, pos, depth, parent, bit):
    s = 0
    while head[u] != head[v]:
        if depth[head[u]] >= depth[head[v]]:
            s += bit.range_sum(pos[head[u]], pos[u])
            u = parent[head[u]]
        else:
            s += bit.range_sum(pos[head[v]], pos[v])
            v = parent[head[v]]
    if depth[u] >= depth[v]:
        s += bit.range_sum(pos[v], pos[u])
    else:
        s += bit.range_sum(pos[u], pos[v])
    return s

def solve_instance(n, parents, pairs):
    g = build_tree(n, parents)
    up, depth, parent, head, pos = preprocess(n, g, 1)
    def dist(a, b):
        c = lca(a, b, up, depth)
        return depth[a] + depth[b] - 2*depth[c]

    for x, y in pairs:
        if dist(x, y) == 1:
            return -1

    pairs_sorted = sorted(pairs, key=lambda p: depth[lca(p[0], p[1], up, depth)], reverse=True)
    bit = Fenwick(n)
    chosen = [0]*(n+1)
    ans = 0

    for x, y in pairs_sorted:
        total = path_sum(x, y, head, pos, depth, parent, bit)
        covered = total - chosen[x] - chosen[y] > 0
        if covered:
            continue
        L = lca(x, y, up, depth)
        if L != x and L != y:
            s = L
        elif L == x:
            steps = depth[y] - depth[L] - 1
            s = ascend(y, steps, up)
        else:
            steps = depth[x] - depth[L] - 1
            s = ascend(x, steps, up)
        # Must be interior
        if s == x or s == y:
            # Should not happen when dist>=2
            return -1
        if chosen[s] == 0:
            chosen[s] = 1
            bit.add(pos[s], 1)
            ans += 1
    return ans

def solve_all():
    data = read_input()
    if data is None:
        return
    n, m, parents, pairs = data
    print(solve_instance(n, parents, pairs))

def main():
    if sys.stdin.isatty():
        # Self-tests (TTY only)
        n = 4
        parents = [0,0,1,2,3]
        assert solve_instance(n, parents, [(1,3),(2,4)]) == 2
        n = 4
        parents = [0,0,1,1,1]
        assert solve_instance(n, parents, [(2,3),(2,4)]) == 1
        n = 2
        parents = [0,0,1]
        assert solve_instance(n, parents, [(1,2)]) == -1
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Cover every path with at least one selected interior vertex; deepest-LCA-first greedy with HLD/BIT for interior coverage tests.}
\WHY{Greedy over LCAs with path queries is a common pattern in advanced tree problems; recognizing interior-vs-endpoint distinction is crucial.}
\CHECKLIST{- Precheck $\mathrm{dist}(x,y)\ge 2$ for all pairs.\\
- Precompute LCA and HLD.\\
- Sort by depth of LCA (desc).\\
- Coverage query = path sum minus endpoints.\\
- Select LCA if internal else child toward the other endpoint.}
\EDGECASES{- Paths of length $1$ (impossible).\\
- Paths sharing only endpoints (do not cover each other).\\
- Many paths with same LCA (order-insensitive).\\
- Star trees where the center is the only interior.\\
- Chains where interior nodes are unique per path.\\
- Repeated identical pairs.\\
- Very unbalanced trees.\\
- Large $n,m$ stress memory/time.\\
- Root choice does not affect correctness.}
\PITFALLS{- Accidentally counting endpoints as coverage.\\
- Choosing the child toward the wrong endpoint when LCA equals one endpoint.\\
- Off-by-one in ascend distance: use $\mathrm{depth}[\cdot]-\mathrm{depth}[L]-1$.\\
- Incorrect HLD path sum ranges (ensure inclusive).\\
- Forgetting to subtract chosen[x], chosen[y] in interior test.\\
- Failing to handle impossible case early.\\
- Misbuilding the tree from parent list.\\
- Missing sys.setrecursionlimit or iterative DFS due to recursion limits.}
\FAILMODES{Naive enumeration per query can TLE on large inputs; improper coverage tests may overcount by endpoints leading to wrong answers. The HLD-based approach survives with $O((n+m)\log n)$.}
\ELI{We need to poke each path in the belly, not at its ends. Start from the deepest crossroads (LCAs) and place a guard there if the path is still unguarded. Use HLD to quickly test whether some guard already stands in the interior of the path.}
\NotePages{3}

\end{document}