% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Vika and the Bridge}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1848/B}}
\LINE{DIFFICULTY / RATING}{1200}
\STATEMENT{In the summer, Vika likes to visit her country house. There is everything for relaxation: comfortable swings, bicycles, and a river.

There is a wooden bridge over the river, consisting of $n$ planks. It is quite old and unattractive, so Vika decided to paint it. And in the shed, they just found cans of paint of $k$ colors.

After painting each plank in one of $k$ colors, Vika was about to go swinging to take a break from work. However, she realized that the house was on the other side of the river, and the paint had not yet completely dried, so she could not walk on the bridge yet.

In order not to spoil the appearance of the bridge, Vika decided that she would still walk on it, but only stepping on planks of the same color. Otherwise, a small layer of paint on her sole will spoil the plank of another color. Vika also has a little paint left, but it will only be enough to repaint one plank of the bridge.

Now Vika is standing on the ground in front of the first plank. To walk across the bridge, she will choose some planks of the same color (after repainting), which have numbers $1 \le i_1 < i_2 < \ldots < i_m \le n$ (planks are numbered from $1$ from left to right). Then Vika will have to cross $i_1 - 1, i_2 - i_1 - 1, i_3 - i_2 - 1, \ldots, i_m - i_{m-1} - 1, n - i_m$ planks as a result of each of $m + 1$ steps.

Since Vika is afraid of falling, she does not want to take too long steps. Help her and tell her the minimum possible maximum number of planks she will have to cross in one step, if she can repaint one (or zero) plank a different color while crossing the bridge.

Input:
Each test consists of multiple test cases. The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers $n$ and $k$ ($1 \le k \le n \le 2 \cdot 10^5$) — the number of planks in the bridge and the number of different colors of paint.

The second line of each test case contains $n$ integers $c_1, c_2, c_3, \dots, c_n$ ($1 \le c_i \le k$) — the colors in which Vika painted the planks of the bridge.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

Output:
For each test case, output a single integer — the minimum possible maximum number of planks that Vika will have to step over in one step.

Note:
In the first test case, Vika can repaint the plank in the middle in color $1$ and walk across the bridge without stepping over any planks.

In the second test case, Vika can repaint the plank in the middle in color $2$ and walk across the bridge, stepping over only one plank each time.

In the third test case, Vika can repaint the penultimate plank in color $2$ and walk across the bridge, stepping only on planks with numbers $2$ and $5$. Then Vika will have to step over $1$, $2$ and $1$ plank each time she steps, so the answer is $2$.

In the fourth test case, Vika can simply walk across the bridge without repainting it, stepping over two planks each time, walking on planks of color $3$.

In the fifth test case, Vika can simply walk across the bridge without repainting it, without stepping over any planks.}
\BREAKDOWN{Fix a stepping color $c$. Consider the gaps (counts of non-$c$ planks) between consecutive $c$-colored planks and at the ends. One repaint to $c$ can optimally split exactly one gap. For each color, compute the two largest gaps to evaluate the best achievable maximum after one split, and take the minimum over colors.}
\ELI{For each color, look at stretches of other colors; repainting one plank of that color cuts the longest stretch roughly in half, so the answer is the best over colors of ``second largest stretch vs. half the largest''.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.
\begin{bullets}
\item $t$ — number of test cases ($1 \le t \le 10^4$).
\item For each test: integers $n,k$ ($1 \le k \le n \le 2\cdot 10^5$).
\item Array $c_1,\ldots,c_n$ with $1 \le c_i \le k$.
\item $\sum n \le 2\cdot 10^5$ over all tests.
\end{bullets}}
\OUTPUTS{For each test case, a single integer on its own line — the minimal possible maximum number of planks Vika must step over in any one step, after optionally repainting at most one plank to any color.}
\SAMPLES{Example 1
\par Input:
\par \texttt{1}
\par \texttt{3 2}
\par \texttt{1 2 1}
\par Output:
\par \texttt{0}
\par
\par Example 2
\par Input:
\par \texttt{1}
\par \texttt{5 3}
\par \texttt{2 3 1 3 2}
\par Output:
\par \texttt{1}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let colors be $\{1,\ldots,k\}$. For a fixed color $c$, let $p_1 < \cdots < p_m$ be indices with color $c$. Define sentinels $p_0=0$, $p_{m+1}=n+1$. Define gaps of non-$c$ planks
\begin{BreakableEquation*}
g_i \coloneqq p_i - p_{i-1} - 1 \quad (i=1,\ldots,m+1).
\end{BreakableEquation*}
Without repainting, the maximum step equals $\max_i g_i$. Repainting one plank to $c$ allows inserting one $p$ into a single gap, optimally splitting its length to balance the two new gaps.}
\varmapStart
\var{n}{number of planks}
\var{k}{number of colors}
\var{c_i}{color at plank $i$}
\var{p_j}{indices of planks with chosen stepping color}
\var{g_i}{counts of consecutive non-chosen-color planks between consecutive $p$'s or at ends}
\var{A_c}{best achievable maximum step for color $c$ after one repaint}
\varmapEnd
\GOVERN{
\[
\text{For each } c:\quad
\begin{aligned}
&\text{Let } g^{(1)}_c \ge g^{(2)}_c \ge \cdots \text{ be } \{g_i\} \text{ sorted nonincreasing}.\\
&A_c \;=\; \max\!\bigl(g^{(2)}_c,\; \bigl\lfloor \tfrac{g^{(1)}_c}{2} \bigr\rfloor \bigr),\quad
\text{Answer} \;=\; \min_{c\in\{1,\ldots,k\}} A_c.
\end{aligned}
\]
}
\ASSUMPTIONS{Planks indexed $1\ldots n$. Exactly one repaint permitted; repaint can be to any color (including one already present). All $c_i$ are integers in $[1,k]$.}
\INVARIANTS{
\begin{bullets}
\item For fixed $c$, $\sum_i g_i = n - m$ (non-$c$ planks count).
\item Repainting to $c$ reduces some single gap $g$ to two that sum to $g-1$, so the new local maximum can be minimized to $\lfloor g/2 \rfloor$.
\item The global maximum after repaint equals $\max(\text{second largest original gap}, \lfloor \text{largest gap}/2 \rfloor)$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{For each color $c$, explicitly form the position list, compute all gaps $g_i$, sort them to get the two largest, and evaluate $\max(g^{(2)}, \lfloor g^{(1)}/2 \rfloor)$. Take the minimum over all colors.}
\ASSUMPTIONS{We can afford building per-color position vectors and sorting their gap arrays. This is already fast enough for constraints when implemented with linear-time two-maximum extraction, but here we keep it simple.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each color $c$, collect indices $p_1<\cdots<p_m$ where $c_i=c$.
\item Compute gaps $g_i=p_i-p_{i-1}-1$ with $p_0=0$ and $p_{m+1}=n+1$.
\item Sort gaps descending, pad missing with $0$, compute candidate $A_c=\max(g^{(2)},\lfloor g^{(1)}/2\rfloor)$.
\item Output $\min_c A_c$.
\end{algosteps}
\COMPLEXITY{Sorting per color is the bottleneck. Summed positions across colors is $n$, but naive sorting yields
\[
\begin{aligned}
T(n) &= \sum_{c=1}^{k} O(m_c \log m_c) \;\le\; O\!\bigl(n \log n\bigr), \\
S(n) &= O(n) \text{ for storing positions}.
\end{aligned}
\]
}
\CORRECTNESS{The maximum step equals the largest gap of non-$c$ planks. Repainting to $c$ can only split one gap, and the optimal split minimizes the larger of the two parts, which is $\lfloor g/2\rfloor$. Other gaps are unchanged, so the post-repaint maximum is as stated. Minimizing over colors yields the optimal plan.}
\EDGECASES{Color absent ($m=0$), all planks already the same color, $n=1$, colors appearing once, adjacent repeats.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 1848B - Vika and the Bridge (Baseline: build positions and sort gaps)
# API: read_input(), solve_case(), solve_all(), main() with guard, and asserts.

from typing import List, Tuple
import sys

def solve_case(n: int, k: int, arr: List[int]) -> int:
    pos = [[] for _ in range(k + 1)]
    for i, col in enumerate(arr, start=1):
        pos[col].append(i)
    ans = n  # upper bound
    for c in range(1, k + 1):
        p = pos[c]
        # Build gaps with sentinels
        gaps = []
        prev = 0
        for x in p:
            gaps.append(x - prev - 1)
            prev = x
        gaps.append(n + 1 - prev - 1)  # tail gap
        # Get top two gaps
        gaps.sort(reverse=True)
        g1 = gaps[0] if gaps else 0
        g2 = gaps[1] if len(gaps) >= 2 else 0
        cand = max(g2, g1 // 2)
        if cand < ans:
            ans = cand
    return ans

def read_input(data: str) -> List[Tuple[int, int, List[int]]]:
    it = iter(data.strip().split())
    out = []
    try:
        t = int(next(it))
    except StopIteration:
        return out
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        out.append((n, k, arr))
    return out

def solve_all(cases: List[Tuple[int, int, List[int]]]) -> List[int]:
    return [solve_case(n, k, arr) for (n, k, arr) in cases]

def _run_tests_baseline():
    # Tiny sanity tests
    assert solve_case(3, 2, [1,2,1]) == 0  # repaint middle to 1 -> 0
    assert solve_case(5, 2, [1,2,1,2,2]) == 1
    assert solve_case(1, 1, [1]) == 0
    assert solve_case(5, 5, [1,2,3,4,5]) == 2  # choose any color, repaint mid -> 2
    # Case where best is a color not frequent
    assert solve_case(6, 2, [1,2,2,2,2,1]) == 1

def main():
    data = sys.stdin.read()
    if not data.strip():
        _run_tests_baseline()
        print("OK")
        return
    cases = read_input(data)
    res = solve_all(cases)
    sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks included in \texttt{\_run\_tests\_baseline()}: mixed arrays, all-same, all-distinct.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{One Pass per Color via Two Max Gaps}
\WHICHFORMULA{Avoid building and sorting gap arrays. For each color, keep track of the two largest gaps seen so far using just two variables. Walk the array once, updating gaps by measuring distances between consecutive occurrences.}
\ASSUMPTIONS{Maintain arrays \texttt{last[c]} (last seen position) and per-color \texttt{g1[c]}, \texttt{g2[c]} for the largest and second-largest gaps. Process start and end edges as implicit sentinels.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{last[c]=0}, \texttt{g1[c]=g2[c]=0} for all $c$.
\item For $i=1\ldots n$: let $c=c_i$. Compute gap $d=i-\texttt{last[c]}-1$. Update $(g1,g2)$ of $c$. Set \texttt{last[c]=i}.
\item After the loop, for each $c$, process tail gap $d=n-\texttt{last[c]}$ and update $(g1,g2)$.
\item Answer is $\min_c \max(g2[c], \lfloor g1[c]/2 \rfloor)$.
\end{algosteps}
\COMPLEXITY{Single pass and $O(k)$ finishing:
\[
\begin{aligned}
T(n) &= O(n + k),\\
S(n) &= O(k).
\end{aligned}
\]
}
\CORRECTNESS{By construction, $g1[c]$ and $g2[c]$ are indeed the two largest gaps among all gaps for color $c$, including edges. Splitting the largest gap yields new local maximum $\lfloor g1/2 \rfloor$; all others remain, so the post-repaint maximum is $\max(g2, \lfloor g1/2 \rfloor)$. Minimizing across $c$ is optimal.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF 1848B - Improved O(n + k): track two largest gaps per color in one pass
from typing import List, Tuple
import sys

def solve_case(n: int, k: int, arr: List[int]) -> int:
    last = [0] * (k + 1)
    g1 = [0] * (k + 1)
    g2 = [0] * (k + 1)
    def upd(c: int, gap: int) -> None:
        if gap > g1[c]:
            g2[c] = g1[c]
            g1[c] = gap
        elif gap > g2[c]:
            g2[c] = gap
    for i, col in enumerate(arr, start=1):
        gap = i - last[col] - 1
        upd(col, gap)
        last[col] = i
    for c in range(1, k + 1):
        gap = n - last[c]
        upd(c, gap)
    ans = n
    for c in range(1, k + 1):
        cand = max(g2[c], g1[c] // 2)
        if cand < ans:
            ans = cand
    return ans

def read_input(data: str) -> List[Tuple[int, int, List[int]]]:
    it = iter(data.strip().split())
    out = []
    try:
        t = int(next(it))
    except StopIteration:
        return out
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        out.append((n, k, arr))
    return out

def solve_all(cases: List[Tuple[int, int, List[int]]]) -> List[int]:
    return [solve_case(n, k, arr) for (n, k, arr) in cases]

def _run_tests_improved():
    # Cross-check with small handcrafted cases
    assert solve_case(3, 2, [1,2,1]) == 0
    assert solve_case(5, 2, [1,2,1,2,2]) == 1
    assert solve_case(5, 5, [1,2,3,4,5]) == 2
    assert solve_case(6, 2, [1,2,2,2,2,1]) == 1
    assert solve_case(7, 2, [1,1,1,1,1,1,1]) == 0

def main():
    data = sys.stdin.read()
    if not data.strip():
        _run_tests_improved()
        print("OK")
        return
    cases = read_input(data)
    res = solve_all(cases)
    sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Included asserts mirror baseline and add trivial all-same-color case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Single-Pass Gap Tracking}
\WHICHFORMULA{Track for each color the two largest gaps among consecutive occurrences and edges; the answer is $\min_c \max(g2[c], \lfloor g1[c]/2 \rfloor)$.}
\ASSUMPTIONS{Array indices are $1$-based conceptually; we use sentinels at $0$ and $n+1$ via \texttt{last[c]} and a final tail update.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize arrays \texttt{last}, \texttt{g1}, \texttt{g2} of size $k+1$ with $0$.
\item Scan $i=1\ldots n$: update the gap since the last occurrence of color $c_i$, then set \texttt{last[c\_i]=i}.
\item After the scan, update each color with its tail gap $n-\texttt{last[c]}$.
\end{algosteps}
\OPTIMALITY{Lower bound: for any color $c$, at least $\max(g2[c], \lfloor g1[c]/2 \rfloor)$ is unavoidable because all gaps other than the largest cannot be reduced, and the largest can be reduced by at most splitting it into two parts whose maximum is at least $\lceil(g1[c]-1)/2\rceil=\lfloor g1[c]/2 \rfloor$. The algorithm achieves this bound for the minimizing color, thus is optimal.}
\COMPLEXITY{Linear in input size:
\[
\begin{aligned}
T(n) &= O(n + k),\quad S(n) = O(k).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF 1848B - Final reference solution (single pass per test)
from typing import List, Tuple
import sys

def solve_case(n: int, k: int, arr: List[int]) -> int:
    last = [0] * (k + 1)
    g1 = [0] * (k + 1)
    g2 = [0] * (k + 1)
    def upd(c: int, gap: int) -> None:
        if gap > g1[c]:
            g2[c] = g1[c]
            g1[c] = gap
        elif gap > g2[c]:
            g2[c] = gap
    for i, col in enumerate(arr, start=1):
        gap = i - last[col] - 1
        if gap > 0:
            upd(col, gap)
        else:
            # Still need to consider zero gaps for tracking completeness
            upd(col, 0)
        last[col] = i
    for c in range(1, k + 1):
        gap = n - last[c]
        upd(c, gap)
    ans = n
    for c in range(1, k + 1):
        cand = max(g2[c], g1[c] // 2)
        if cand < ans:
            ans = cand
    return ans

def read_input(data: str) -> List[Tuple[int, int, List[int]]]:
    toks = data.strip().split()
    if not toks:
        return []
    it = iter(toks)
    t = int(next(it))
    cases: List[Tuple[int, int, List[int]]] = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append((n, k, arr))
    return cases

def solve_all(cases: List[Tuple[int, int, List[int]]]) -> List[int]:
    return [solve_case(n, k, arr) for (n, k, arr) in cases]

def _run_tests_final():
    # Exactly 3 asserts
    assert solve_case(3, 2, [1,2,1]) == 0
    assert solve_case(5, 3, [2,3,1,3,2]) == 1
    assert solve_case(5, 5, [1,2,3,4,5]) == 2

def main():
    data = sys.stdin.read()
    if not data.strip():
        _run_tests_final()
        print("OK")
        return
    cases = read_input(data)
    res = solve_all(cases)
    sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts cover symmetric/edge cases: already optimal, mixed with middle repaint, and all distinct.}
\RESULT{For each test, print the minimal maximal number of planks stepped over in a single step after repainting at most one plank to any color.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for small constructions; randomized cross-checking of the improved method vs. a slow but obviously correct solver that builds gaps and sorts them.}
\LINE{CROSS-CHECKS}{On random tiny arrays ($n \le 10$), compare outputs of the optimized method with the baseline.}
\LINE{EDGE-CASE GENERATOR}{Covers $n=1$, all equal colors, all distinct colors, alternating colors, and random colors with small $k$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def slow_solve(n: int, k: int, arr: List[int]) -> int:
    pos = [[] for _ in range(k + 1)]
    for i, col in enumerate(arr, start=1):
        pos[col].append(i)
    ans = n
    for c in range(1, k + 1):
        p = pos[c]
        gaps = []
        prev = 0
        for x in p:
            gaps.append(x - prev - 1)
            prev = x
        gaps.append(n + 1 - prev - 1)
        gaps.sort(reverse=True)
        g1 = gaps[0] if gaps else 0
        g2 = gaps[1] if len(gaps) >= 2 else 0
        ans = min(ans, max(g2, g1 // 2))
    return ans

def fast_solve(n: int, k: int, arr: List[int]) -> int:
    last = [0] * (k + 1)
    g1 = [0] * (k + 1)
    g2 = [0] * (k + 1)
    def upd(c: int, gap: int) -> None:
        nonlocal g1, g2
        if gap > g1[c]:
            g2[c] = g1[c]; g1[c] = gap
        elif gap > g2[c]:
            g2[c] = gap
    for i, col in enumerate(arr, start=1):
        upd(col, i - last[col] - 1)
        last[col] = i
    for c in range(1, k + 1):
        upd(c, n - last[c])
    ans = n
    for c in range(1, k + 1):
        ans = min(ans, max(g2[c], g1[c] // 2))
    return ans

def run_random_tests():
    rnd = random.Random(0)
    for n in range(1, 11):
        for k in range(1, n + 1):
            for _ in range(200):
                arr = [rnd.randint(1, k) for _ in range(n)]
                a = slow_solve(n, k, arr)
                b = fast_solve(n, k, arr)
                assert a == b, (n, k, arr, a, b)

if __name__ == "__main__":
    run_random_tests()
    print("Cross-check OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required CF API + asserts
from typing import List, Tuple
import sys

def solve_case(n: int, k: int, arr: List[int]) -> int:
    last = [0] * (k + 1)
    g1 = [0] * (k + 1)
    g2 = [0] * (k + 1)
    def upd(c: int, gap: int) -> None:
        if gap > g1[c]:
            g2[c] = g1[c]
            g1[c] = gap
        elif gap > g2[c]:
            g2[c] = gap
    for i, col in enumerate(arr, start=1):
        upd(col, i - last[col] - 1)
        last[col] = i
    for c in range(1, k + 1):
        upd(c, n - last[c])
    ans = n
    for c in range(1, k + 1):
        cand = max(g2[c], g1[c] // 2)
        if cand < ans:
            ans = cand
    return ans

def read_input(data: str) -> List[Tuple[int, int, List[int]]]:
    toks = data.strip().split()
    if not toks:
        return []
    it = iter(toks)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append((n, k, arr))
    return cases

def solve_all(cases: List[Tuple[int, int, List[int]]]) -> List[int]:
    return [solve_case(n, k, arr) for (n, k, arr) in cases]

def _tests():
    assert solve_case(3, 2, [1,2,1]) == 0
    assert solve_case(5, 5, [1,2,3,4,5]) == 2
    assert solve_case(6, 2, [1,2,2,2,2,1]) == 1

def main():
    data = sys.stdin.read()
    if not data.strip():
        _tests()
        print("OK")
        return
    cases = read_input(data)
    res = solve_all(cases)
    sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize the worst gap of non-chosen-color planks by repainting one plank and stepping on a single color.}
\WHY{A classic pattern: minimize maximum segment length with one split. Appears in greedy/DP disguise; recognizing the ``split the largest gap'' trick is key.}
\CHECKLIST{
\begin{bullets}
\item Fix a color $c$; compute non-$c$ gaps with edge sentinels.
\item Track two largest gaps $(g1,g2)$.
\item Candidate $=\max(g2, \lfloor g1/2 \rfloor)$.
\item Take the minimum over all colors.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item Color absent entirely: $g1=n$, $g2=0$.
\item All planks same color: answer $0$.
\item Alternating colors.
\item Long run at the beginning or end.
\item $k=1$.
\item Multiple colors with equal candidates — choose minimum anyway.
\item Arrays with big $n$ but small $k$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting edge gaps (before first and after last occurrence).
\item Off-by-one in gap computation ($p_i-p_{i-1}-1$).
\item Using $\lceil g/2 \rceil$ instead of $\lfloor g/2 \rfloor$ for the split.
\item Not updating the second maximum when the first changes.
\item Overflow is not an issue in Python, but index bases can bite.
\item Mishandling colors that never appear.
\item Building and sorting full gap lists is slower than needed.
\end{bullets}}
\FAILMODES{Any approach that tries repainting every position explicitly per color ($O(nk)$ or worse) will time out on worst cases. Ignoring edge gaps or using the wrong split formula produces off-by-one errors.}
\ELI{Pick a color and look at stretches of other colors; repaint one plank to cut the longest such stretch in half. Do this for each color and choose the best outcome. It is fast because we only need the two largest stretches per color.}
\NotePages{3}

\end{document}