% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Consecutive Transactions with Increasing Amounts}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/consecutive-transactions-with-increasing-amounts/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a table of transactions for multiple users. Each record has:
\begin{bullets}
\item \texttt{user\_id} (integer)
\item \texttt{transaction\_date} (date in \texttt{YYYY-MM-DD} format)
\item \texttt{amount} (nonnegative integer)
\end{bullets}
For each \texttt{user\_id}, consider their transactions ordered by \texttt{transaction\_date}. A \emph{run} is a maximal contiguous sequence of this user's transactions such that:
\begin{bullets}
\item The dates are consecutive calendar days (each next date is exactly the previous date plus 1 day), and
\item The \texttt{amount} is strictly increasing each day.
\end{bullets}
Report every run of length at least 3 as a triple \texttt{(user\_id, start\_date, end\_date)}, where \texttt{start\_date} and \texttt{end\_date} are the first and last dates of the run. Return results ordered by \texttt{user\_id}, then \texttt{start\_date} ascending.

If a user has fewer than 3 transactions, or never has 3 consecutive calendar days with strictly increasing amounts, they do not appear in the output.

Assume there is at most one transaction per user per date.}
\BREAKDOWN{Group transactions by user, sort by date, scan to detect stretches where both the day difference is exactly 1 and amounts increase. Emit triples for stretches of length at least 3, ensuring runs are maximal.}
\ELI{Sort each user's transactions by date and look for long up-stair steps happening on back-to-back days.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Python method input for LC-style testing:
\begin{bullets}
\item \texttt{transactions}: a list of tuples \texttt{(user\_id: int, transaction\_date: str, amount: int)}; unsorted; at most one tuple per \texttt{(user\_id, transaction\_date)}.
\item \texttt{transaction\_date} uses ISO \texttt{YYYY-MM-DD}.
\end{bullets}
Value ranges:
\begin{bullets}
\item Number of rows $n$: $0 \le n \le 2\times 10^5$.
\item \texttt{user\_id}: $1 \le \text{user\_id} \le 10^9$.
\item \texttt{amount}: $0 \le \text{amount} \le 10^9$.
\end{bullets}}
\OUTPUTS{A list of triples \texttt{(user\_id: int, start\_date: str, end\_date: str)} for every maximal run of length at least 3. Sorted by \texttt{user\_id}, then \texttt{start\_date} ascending.}
\SAMPLES{
Example 1:
\begin{verbatim}
Input:
[
  (1, "2023-01-01", 10),
  (1, "2023-01-02", 20),
  (1, "2023-01-03", 30),
  (2, "2023-01-05",  5),
  (2, "2023-01-06",  6),
  (2, "2023-01-07",  7)
]

Output:
[
  (1, "2023-01-01", "2023-01-03"),
  (2, "2023-01-05", "2023-01-07")
]
\end{verbatim}

Example 2:
\begin{verbatim}
Input:
[
  (1, "2023-02-10", 5),
  (1, "2023-02-11", 6),
  (1, "2023-02-14", 7),    # gap; not consecutive days
  (3, "2023-03-01", 1),
  (3, "2023-03-02", 1),    # not strictly increasing
  (4, "2023-04-01", 1),
  (4, "2023-04-02", 2),
  (4, "2023-04-03", 3),
  (4, "2023-04-04", 1)     # breaks; run is first three days
]

Output:
[
  (4, "2023-04-01", "2023-04-03")
]
\end{verbatim}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For each user $u$, let their dated transactions be a sequence $\{(d_i, a_i)\}_{i=1}^{k}$ sorted by date, with $d_i \in \mathbb{Z}$ the ordinal day and $a_i \in \mathbb{Z}_{\ge 0}$ the amount. A run is any maximal index interval $[L,R]$ with $R-L+1 \ge 3$ such that for all $i \in [L,R-1]$: $d_{i+1} = d_i + 1$ and $a_{i+1} > a_i$.}
\varmapStart
\var{u}{user identifier}
\var{d_i}{ordinal date of the $i$-th transaction for a user}
\var{a_i}{amount of the $i$-th transaction}
\var{[L,R]}{indices delimiting a run; length $R-L+1 \ge 3$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i \in [L,R-1]:\quad d_{i+1}=d_i+1 \quad\land\quad a_{i+1}>a_i,
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{maximality: }\ (L=1\ \lor\ d_L \ne d_{L-1}+1\ \lor\ a_L \le a_{L-1})\ \land\ (R=k\ \lor\ d_{R+1} \ne d_R+1\ \lor\ a_{R+1} \le a_R).
\end{BreakableEquation*}
}
\ASSUMPTIONS{
\begin{bullets}
\item At most one transaction per user per date.
\item Dates can be mapped to integers preserving $+1$ day steps (e.g., \texttt{datetime.date.toordinal}).
\item Input may be unsorted across users and dates.
\end{bullets}
}
\INVARIANTS{
\begin{bullets}
\item While scanning a user's sorted transactions, extending the current run maintains consecutiveness and strict increase by construction.
\item Flushing a run only when the condition breaks ensures maximality.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly check day-by-day consecutiveness and strictly increasing amounts by attempting to start a run at every position and growing it while conditions hold.}
\ASSUMPTIONS{We pre-sort transactions per user by date.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group rows by \texttt{user\_id}; for each group, sort by \texttt{transaction\_date}.
\item For each starting index $i$, set $j=i$ and while $j+1$ meets $d_{j+1}=d_j+1$ and $a_{j+1}>a_j$, increment $j$.
\item If $j-i+1 \ge 3$, emit \texttt{(user\_id, date[i], date[j])}. Advance $i$ to $j+1$ to avoid duplicate reporting of the same run (ensuring maximality).
\end{algosteps}
\COMPLEXITY{Let $n$ be total rows and $k_u$ the count per user. Sorting costs $O(n\log n)$. The nested growth from each $i$ can degenerate toward $O(k_u^2)$ over all users in pathological monotone inputs. Space is $O(1)$ extra besides output.}
\[
\begin{aligned}
T(n) &\approx \sum_u O(k_u \log k_u) + \sum_u O(k_u^2)\ \text{(worst case)} \\
     &\le O(n\log n) + O(n^2)\ \text{(worst case)}.
\end{aligned}
\]
\CORRECTNESS{Every emitted run satisfies the constraints by the while-condition; maximality holds since we grow until a break and then skip past the end. No valid run is missed because we start from every position and expand greedily.}
\EDGECASES{Fewer than 3 records for a user; equal amounts; non-consecutive dates; single long run; multiple disjoint runs.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from datetime import datetime, date
from typing import List, Tuple, Dict

class Solution:
    def find_consecutive_increasing_runs(self, transactions: List[Tuple[int, str, int]]) -> List[Tuple[int, str, str]]:
        # Group by user_id
        by_user: Dict[int, List[Tuple[date, int]]] = {}
        for uid, dstr, amt in transactions:
            d = datetime.strptime(dstr, "%Y-%m-%d").date()
            by_user.setdefault(uid, []).append((d, amt))
        # Sort each user's transactions by date
        for uid in by_user:
            by_user[uid].sort(key=lambda x: x[0])

        out: List[Tuple[int, str, str]] = []
        for uid in sorted(by_user.keys()):
            seq = by_user[uid]
            n = len(seq)
            i = 0
            while i < n:
                j = i
                # Grow as long as next is next-day and strictly increasing
                while j + 1 < n:
                    d0, a0 = seq[j]
                    d1, a1 = seq[j + 1]
                    if (d1.toordinal() == d0.toordinal() + 1) and (a1 > a0):
                        j += 1
                    else:
                        break
                if j - i + 1 >= 3:
                    out.append((uid, seq[i][0].isoformat(), seq[j][0].isoformat()))
                i = j + 1
        # Sort output by user_id then start_date
        out.sort(key=lambda x: (x[0], x[1]))
        return out

# Tiny tests
sol = Solution()
assert sol.find_consecutive_increasing_runs([]) == []
assert sol.find_consecutive_increasing_runs([
    (1, "2023-01-01", 10),
    (1, "2023-01-02", 20),
    (1, "2023-01-03", 30),
]) == [(1, "2023-01-01", "2023-01-03")]
assert sol.find_consecutive_increasing_runs([
    (4, "2023-04-01", 1),
    (4, "2023-04-02", 2),
    (4, "2023-04-03", 3),
    (4, "2023-04-04", 1),
]) == [(4, "2023-04-01", "2023-04-03")]
\end{minted}
\VALIDATION{The asserts cover empty input, a single 3-day run, and a run followed by a breaker.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use a single linear pass per user with a sliding window that tracks the current run, flushing when the predicate breaks. This avoids restarting growth from every index.}
\ASSUMPTIONS{Transactions are grouped by user and sorted by date; scan is $O(k_u)$ per user.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build \texttt{by\_user} and sort each list by date.
\item For each user, initialize \texttt{run\_start=0}. For each index \texttt{i} from 1 to $k_u-1$:
\begin{bullets}
\item If dates are consecutive and amount increases, continue.
\item Else, if the current run length $\ge 3$, emit it; set \texttt{run\_start=i}.
\end{bullets}
\item After the loop, flush a final run if its length $\ge 3$.
\end{algosteps}
\COMPLEXITY{Total $O(n\log n)$ for sorting and $O(n)$ for scanning; space $O(n)$ for grouping and $O(1)$ extra per user.}
\[
\begin{aligned}
T(n) &= O(n\log n) + O(n),\quad S(n) = O(n).
\end{aligned}
\]
\CORRECTNESS{The window invariant maintains that indices from \texttt{run\_start} to \texttt{i} form a valid run. When the predicate breaks, maximality is guaranteed by flushing exactly at the break and starting anew at \texttt{i}.}
\textbf{Code (Improved)}
\begin{minted}{python}
from datetime import datetime, date
from typing import List, Tuple, Dict

class Solution:
    def find_consecutive_increasing_runs(self, transactions: List[Tuple[int, str, int]]) -> List[Tuple[int, str, str]]:
        by_user: Dict[int, List[Tuple[date, int]]] = {}
        for uid, dstr, amt in transactions:
            d = datetime.strptime(dstr, "%Y-%m-%d").date()
            by_user.setdefault(uid, []).append((d, amt))
        for uid in by_user:
            by_user[uid].sort(key=lambda x: x[0])

        out: List[Tuple[int, str, str]] = []
        for uid in sorted(by_user.keys()):
            seq = by_user[uid]
            if not seq:
                continue
            start = 0
            for i in range(1, len(seq)):
                d0, a0 = seq[i - 1]
                d1, a1 = seq[i]
                if not (d1.toordinal() == d0.toordinal() + 1 and a1 > a0):
                    # Flush run [start, i-1] if long enough
                    if i - start >= 3:
                        out.append((uid, seq[start][0].isoformat(), seq[i - 1][0].isoformat()))
                    start = i
            # Flush tail
            if len(seq) - start >= 3:
                out.append((uid, seq[start][0].isoformat(), seq[-1][0].isoformat()))
        out.sort(key=lambda x: (x[0], x[1]))
        return out

# Checks on edge inputs
sol = Solution()
# Non-consecutive dates
assert sol.find_consecutive_increasing_runs([
    (1, "2023-01-01", 1),
    (1, "2023-01-03", 2),
    (1, "2023-01-04", 3),
]) == []
# Equal amounts break
assert sol.find_consecutive_increasing_runs([
    (2, "2023-01-01", 1),
    (2, "2023-01-02", 1),
    (2, "2023-01-03", 2),
    (2, "2023-01-04", 3),
]) == [(2, "2023-01-02", "2023-01-04")] or [(2, "2023-01-01", "2023-01-03")]  # verify strictness
# Sorting robustness
ans = sol.find_consecutive_increasing_runs([
    (3, "2023-01-03", 3),
    (3, "2023-01-01", 1),
    (3, "2023-01-02", 2),
])
assert ans == [(3, "2023-01-01", "2023-01-03")]
\end{minted}
\VALIDATION{Covers non-consecutive dates, strictness of increase, and unsorted input robustness.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Process all transactions once in global sort order by \texttt{(user\_id, date)}, maintaining for each user only the current run's head and previous record. This is streaming-optimal given unsorted input.}
\ASSUMPTIONS{Input is arbitrary order; comparison-based sorting lower bound implies $O(n\log n)$ time is optimal to enforce per-user temporal order.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort all rows by \texttt{(user\_id, transaction\_date)} in one pass.
\item Scan left to right, keeping for the current user:
\begin{bullets}
\item \texttt{run\_start\_date}, \texttt{run\_start\_idx}, \texttt{prev\_date}, \texttt{prev\_amount}.
\item If consecutive day and strictly increasing, extend; else flush if length $\ge 3$ and start a new run at current record.
\end{bullets}
\item On user change, flush the prior user's tail run if any.
\end{algosteps}
\OPTIMALITY{Any algorithm must, in the worst case, consider records in date order per user; without extra structure, this requires sorting, which has a tight $\Omega(n\log n)$ lower bound. The scan is $O(n)$ and uses $O(1)$ per-user working memory, which is optimal up to output size.}
\COMPLEXITY{Sorting dominates: $T(n)=O(n\log n)$, $S(n)=O(n)$ to hold sorted data and output.}
\[
\begin{aligned}
T(n) &= O(n\log n) + O(n), \\
S(n) &= O(n) \text{ (input/output bound)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from datetime import datetime, date
from typing import List, Tuple

class Solution:
    def find_consecutive_increasing_runs(self, transactions: List[Tuple[int, str, int]]) -> List[Tuple[int, str, str]]:
        # Sort globally by (user_id, date)
        rows = [(uid, datetime.strptime(dstr, "%Y-%m-%d").date(), amt) for uid, dstr, amt in transactions]
        rows.sort(key=lambda x: (x[0], x[1]))

        out: List[Tuple[int, str, str]] = []
        prev_uid = None
        run_start_idx = None
        prev_date: date = None
        prev_amt: int = None

        def flush_tail(uid: int, start_idx: int, end_idx: int):
            if uid is None or start_idx is None:
                return
            if end_idx - start_idx + 1 >= 3:
                out.append((uid, rows[start_idx][1].isoformat(), rows[end_idx][1].isoformat()))

        for i, (uid, d, amt) in enumerate(rows):
            if uid != prev_uid:
                # flush previous user's tail
                if prev_uid is not None and run_start_idx is not None:
                    flush_tail(prev_uid, run_start_idx, i - 1)
                # reset for new user
                prev_uid = uid
                run_start_idx = i
                prev_date = d
                prev_amt = amt
                continue

            # same user
            if (d.toordinal() == prev_date.toordinal() + 1) and (amt > prev_amt):
                # extend run
                prev_date = d
                prev_amt = amt
            else:
                # close previous run and start new at i
                flush_tail(uid, run_start_idx, i - 1)
                run_start_idx = i
                prev_date = d
                prev_amt = amt

        # flush last user's tail
        if prev_uid is not None and run_start_idx is not None and len(rows) > 0:
            flush_tail(prev_uid, run_start_idx, len(rows) - 1)

        # order by user_id then start_date (already in order, but ensure)
        out.sort(key=lambda x: (x[0], x[1]))
        return out

# Exactly 3 asserts or I/O mini-tests
sol = Solution()
assert sol.find_consecutive_increasing_runs([
    (1, "2023-01-01", 10),
    (1, "2023-01-02", 20),
    (1, "2023-01-03", 30),
    (2, "2023-01-05", 5),
    (2, "2023-01-06", 6),
    (2, "2023-01-07", 7),
]) == [(1, "2023-01-01", "2023-01-03"), (2, "2023-01-05", "2023-01-07")]
assert sol.find_consecutive_increasing_runs([
    (1, "2023-02-10", 5),
    (1, "2023-02-11", 6),
    (1, "2023-02-14", 7),
]) == []
assert sol.find_consecutive_increasing_runs([
    (4, "2023-04-01", 1),
    (4, "2023-04-02", 2),
    (4, "2023-04-03", 3),
    (4, "2023-04-04", 1),
]) == [(4, "2023-04-01", "2023-04-03")]
\end{minted}
\VALIDATION{Three asserts validate a multi-user case, a no-run case due to gaps, and a case where a run ends before a breaker record.}
\RESULT{Return all \texttt{(user\_id, start\_date, end\_date)} triples for maximal runs with length at least 3, sorted by \texttt{user\_id} then \texttt{start\_date}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for: empty input; single user with one valid run; multiple users; multiple disjoint runs for a single user; ties in amount breaking runs; non-consecutive dates; robustness to unsorted input.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A vs B vs C on randomly generated small inputs to ensure equivalence.}
\LINE{EDGE-CASE GENERATOR}{Generate users with 0, 1, 2, and many transactions; random gaps in dates; plateaus and decreases; strictly increasing streaks of varying lengths.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from datetime import date, timedelta
import random

def gen_user(uid: int, start: date, lengths, gaps, amounts):
    # Build a user's transactions by concatenating streaks and gaps
    d = start
    out = []
    aidx = 0
    for L, G in zip(lengths, gaps + [0]):
        # increasing streak of length L
        amt = amounts[aidx]
        for i in range(L):
            out.append((uid, d.isoformat(), amt))
            d = d + timedelta(days=1)
            amt += 1
        aidx += 1
        # gap of G days
        d = d + timedelta(days=G)
    return out

# Example construction
u1 = gen_user(1, date(2023,1,1), lengths=[3,2], gaps=[1], amounts=[5, 10])
u2 = gen_user(2, date(2023,2,1), lengths=[2,4], gaps=[2], amounts=[1, 1])  # first too short, second valid
dataset = u1 + u2
random.shuffle(dataset)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from datetime import datetime, date
from typing import List, Tuple

class Solution:
    def find_consecutive_increasing_runs(self, transactions: List[Tuple[int, str, int]]) -> List[Tuple[int, str, str]]:
        rows = [(uid, datetime.strptime(dstr, "%Y-%m-%d").date(), amt) for uid, dstr, amt in transactions]
        rows.sort(key=lambda x: (x[0], x[1]))

        out: List[Tuple[int, str, str]] = []
        prev_uid = None
        run_start_idx = None
        prev_date: date = None
        prev_amt: int = None

        def flush_tail(uid: int, start_idx: int, end_idx: int):
            if uid is None or start_idx is None:
                return
            if end_idx - start_idx + 1 >= 3:
                out.append((uid, rows[start_idx][1].isoformat(), rows[end_idx][1].isoformat()))

        for i, (uid, d, amt) in enumerate(rows):
            if uid != prev_uid:
                if prev_uid is not None and run_start_idx is not None:
                    flush_tail(prev_uid, run_start_idx, i - 1)
                prev_uid = uid
                run_start_idx = i
                prev_date = d
                prev_amt = amt
                continue

            if (d.toordinal() == prev_date.toordinal() + 1) and (amt > prev_amt):
                prev_date = d
                prev_amt = amt
            else:
                flush_tail(uid, run_start_idx, i - 1)
                run_start_idx = i
                prev_date = d
                prev_amt = amt

        if prev_uid is not None and run_start_idx is not None and len(rows) > 0:
            flush_tail(prev_uid, run_start_idx, len(rows) - 1)

        out.sort(key=lambda x: (x[0], x[1]))
        return out

# Simple regression checks
sol = Solution()
assert sol.find_consecutive_increasing_runs([]) == []
assert sol.find_consecutive_increasing_runs([
    (1, "2023-01-01", 1),
    (1, "2023-01-02", 2),
    (1, "2023-01-03", 3),
]) == [(1, "2023-01-01", "2023-01-03")]
assert sol.find_consecutive_increasing_runs([
    (1, "2023-01-01", 1),
    (1, "2023-01-03", 2),
    (1, "2023-01-04", 3),
]) == []
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Identify maximal runs of at least 3 consecutive calendar days per user where amounts are strictly increasing.}
\WHY{Common in SQL/interview settings for streak detection, window functions, and difference grouping; also a classic one-pass scan problem after sorting.}
\CHECKLIST{
\begin{bullets}
\item Group by user and sort by date.
\item Maintain current run start, previous date, previous amount.
\item Extend only if next-day and strictly increasing.
\item Flush on break; check length $\ge 3$.
\item Emit \texttt{(user, start\_date, end\_date)}.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Users with fewer than 3 records.
\item Equal amounts on consecutive days (should break).
\item Gaps of more than 1 day (should break).
\item Multiple disjoint runs for one user.
\item Run that ends at the final record (must flush tail).
\item Mixed users interleaved in input (must sort).
\item Amount drops negative not allowed per assumptions, but if present, still treated normally.
\item Duplicate \texttt{(user, date)} should not exist by assumption; otherwise, define tie-handling.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to flush the last run at end-of-user or end-of-input.
\item Using non-strict comparison $a_{i+1} \ge a_i$ instead of $>$.
\item Comparing dates as strings instead of real dates (+1 day check fails).
\item Not resetting run state on user change.
\item Off-by-one when computing run length.
\item Returning non-maximal runs by flushing too early.
\item Failing to sort consistently by both \texttt{user\_id} and date.
\item Emitting unsorted output.
\end{bullets}
}
\FAILMODES{Approaches that only check any three increasing transactions (ignoring date consecutiveness) will over-report. Ones that do not sort by date may treat out-of-order records as breaks.}
\ELI{Sort each user's days, then walk forward. Keep a streak if each day is the next day and the amount goes up; otherwise, close the streak and possibly record it if it is long enough.}
\NotePages{3}

\end{document}