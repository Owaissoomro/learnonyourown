% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Triples with Bitwise AND Equal To Zero}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given an integer array \texttt{nums}, return the number of \textbf{AND triples}.

An AND triple is a triple of indices \texttt{(i, j, k)} such that:
\begin{itemize}
\item $0 \le i < \texttt{nums.length}$
\item $0 \le j < \texttt{nums.length}$
\item $0 \le k < \texttt{nums.length}$
\item \texttt{nums[i] \& nums[j] \& nums[k] == 0}, where \texttt{\&} represents the bitwise-AND operator.
\end{itemize}

Example 1:

Input: \texttt{nums = [2, 1, 3]}

Output: \texttt{12}

Explanation: We could choose the following \texttt{i, j, k} triples:
\texttt{(i=0, j=0, k=1)} : \texttt{2 \& 2 \& 1}
\texttt{(i=0, j=1, k=0)} : \texttt{2 \& 1 \& 2}
\texttt{(i=0, j=1, k=1)} : \texttt{2 \& 1 \& 1}
\texttt{(i=0, j=1, k=2)} : \texttt{2 \& 1 \& 3}
\texttt{(i=0, j=2, k=1)} : \texttt{2 \& 3 \& 1}
\texttt{(i=1, j=0, k=0)} : \texttt{1 \& 2 \& 2}
\texttt{(i=1, j=0, k=1)} : \texttt{1 \& 2 \& 1}
\texttt{(i=1, j=0, k=2)} : \texttt{1 \& 2 \& 3}
\texttt{(i=1, j=1, k=0)} : \texttt{1 \& 1 \& 2}
\texttt{(i=1, j=2, k=0)} : \texttt{1 \& 3 \& 2}
\texttt{(i=2, j=0, k=1)} : \texttt{3 \& 2 \& 1}
\texttt{(i=2, j=1, k=0)} : \texttt{3 \& 1 \& 2}

Example 2:

Input: \texttt{nums = [0, 0, 0]}

Output: \texttt{27}

Constraints:
\begin{itemize}
\item $1 \le \texttt{nums.length} \le 1000$
\item $0 \le \texttt{nums[i]} < 2^{16}$
\end{itemize}}
\BREAKDOWN{Count ordered triples $(i,j,k)$ where the bitwise AND of the three numbers is zero. Direct $O(n^3)$ is too slow for $n$ up to $1000$. Use bitmask techniques: precompute counts of pairwise AND results over $[0,2^{16})$, then for each $k$, sum the counts whose masks are disjoint from $\texttt{nums}[k]$.}
\ELI{Precount how often each 16-bit mask appears as \texttt{nums[i] \& nums[j]}, then for each \texttt{nums[k]}, add all those pair counts that share no 1-bits with \texttt{nums[k]}.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One list \texttt{nums} of integers with length $n$ such that $1 \le n \le 1000$ and $0 \le \texttt{nums[i]} < 2^{16}$.}
\OUTPUTS{Return an integer equal to the number of ordered triples $(i,j,k)$ with $0 \le i,j,k < n$ and $\texttt{nums[i]} \& \texttt{nums[j]} \& \texttt{nums[k]} = 0$.}
\SAMPLES{
Example A:
\begin{itemize}
\item Input: \texttt{[2, 1, 3]}
\item Output: \texttt{12}
\end{itemize}
Example B:
\begin{itemize}
\item Input: \texttt{[0, 0, 0]}
\item Output: \texttt{27}
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A = (\texttt{nums}[0],\ldots,\texttt{nums}[n-1])$ with $A_i \in [0,2^{16})$.

Define the function
\begin{BreakableEquation*}
C(m) = \left|\{(i,j):~0 \le i,j < n,\ (A_i \,\&\, A_j) = m\}\right|
\end{BreakableEquation*}
for masks $m \in [0,2^{16})$. The goal is to compute
\begin{BreakableEquation*}
\text{Ans} = \sum_{k=0}^{n-1} \sum_{\substack{m \in [0,2^{16})\\ m \,\&\, A_k = 0}} C(m).
\end{BreakableEquation*} }
\varmapStart
\var{n}{array length}
\var{A_i}{the $i$-th value in \texttt{nums}}
\var{m}{a 16-bit mask representing a possible pairwise AND result}
\var{C(m)}{count of ordered pairs $(i,j)$ with $A_i \& A_j = m$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
C(m) &:= \sum_{i=0}^{n-1}\sum_{j=0}^{n-1} [ (A_i \,\&\, A_j) = m ],\\
\text{Ans} &= \sum_{k=0}^{n-1} \sum_{m \subseteq \overline{A_k}} C(m),
\end{aligned}
\]
where $\overline{A_k}$ is taken over 16 bits and $[\,\cdot\,]$ is the Iverson bracket.}
\ASSUMPTIONS{All values fit in 16 bits; order of indices matters (ordered triples).}
\INVARIANTS{
\begin{itemize}
\item $C(m) \ge 0$ and $\sum_{m} C(m) = n^2$.
\item For any $x$, $m \,\&\, x = 0$ iff $m$ is a submask of $\overline{x}$ restricted to 16 bits.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly count all triples by enumerating $i,j,k$ and checking $A_i \,\&\, A_j \,\&\, A_k = 0$.}
\ASSUMPTIONS{Only feasible for tiny $n$ due to $O(n^3)$ time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{ans = 0}.
\item For each $i$ in $[0,n)$, each $j$ in $[0,n)$, each $k$ in $[0,n)$, if $(A_i \,\&\, A_j \,\&\, A_k)=0$, increment \texttt{ans}.
\item Return \texttt{ans}.
\end{algosteps}
\COMPLEXITY{$T(n) = O(n^3)$, $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= n \times n \times n = n^3.
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration tests the predicate for every ordered triple, so it counts exactly those satisfying the condition.}
\EDGECASES{All zeros produce $n^3$; single element trivially yields $1$ if element is $0$, else $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for i in range(n):
            for j in range(n):
                x = nums[i] & nums[j]
                for k in range(n):
                    if (x & nums[k]) == 0:
                        ans += 1
        return ans

# Tiny sanity checks (keep inputs small so O(n^3) is fine)
if __name__ == "__main__":
    s = Solution()
    assert s.countTriplets([2, 1, 3]) == 12
    assert s.countTriplets([0]) == 1
    assert s.countTriplets([0, 0]) == 8  # 2^3 ordered triples
\end{minted}
\VALIDATION{Checked on provided examples and tiny arrays; matches expected counts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Pairwise AND Frequency + Direct Mask Scan}
\WHICHFORMULA{Precompute $C(m)$ for all $m$ in one $O(n^2)$ pass. For each $k$, sum $C(m)$ over masks $m$ with $m \,\&\, A_k = 0$ by scanning all $2^{16}$ masks.}
\ASSUMPTIONS{Bit-width is fixed at 16, so scanning all masks is a constant factor $M=65536$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build array \texttt{cnt[0..M-1]} with counts of pairwise ANDs: increment \texttt{cnt[nums[i] \& nums[j]]} for all $i,j$.
\item For each $x$ in \texttt{nums}, accumulate \texttt{sum(cnt[m] for m in 0..M-1 if (m \& x)==0)}.
\item Return the total.
\end{algosteps}
\COMPLEXITY{Dominant terms: $O(n^2)$ to fill \texttt{cnt} plus $O(n \cdot M)$ to scan masks; with $M=65536$, this is practical in optimized Python or easily in faster languages.}
\[
\begin{aligned}
T(n) &\approx O(n^2 + n\cdot M),\quad M=2^{16}=65536.\\
S(n) &= O(M).
\end{aligned}
\]
\CORRECTNESS{Every ordered pair $(i,j)$ contributes exactly once to \texttt{cnt[mask]}. For each $k$, we add exactly those pair counts whose mask is disjoint from $A_k$, matching the definition.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        M = 1 << 16
        cnt = [0] * M
        n = len(nums)
        # Count all ordered pairs' AND results
        for a in nums:
            for b in nums:
                cnt[a & b] += 1
        ans = 0
        for x in nums:
            # Sum all masks disjoint from x by scanning all masks
            # (fast enough given fixed M=65536)
            s = 0
            xi = x
            for m in range(M):
                if (m & xi) == 0:
                    s += cnt[m]
            ans += s
        return ans

# Tests (moderate; avoid heavy runtime here)
if __name__ == "__main__":
    s = Solution()
    assert s.countTriplets([2, 1, 3]) == 12
    assert s.countTriplets([0, 0, 0]) == 27
    assert s.countTriplets([1]) == 0
\end{minted}
\VALIDATION{Verified on examples; also sanity-check that no triple exists when \texttt{nums} has one nonzero element.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Pairwise AND Frequency + SOS DP (Subset Convolution over OR)}
\WHICHFORMULA{Compute \texttt{cnt[m]} for all masks, then perform SOS DP to get $G[\text{mask}] = \sum_{\text{sub} \subseteq \text{mask}} \texttt{cnt[sub]}$. For each $x$, the desired sum is $G[\overline{x}]$ (16-bit complement).}
\ASSUMPTIONS{Bit-width $B=16$; standard SOS DP over submasks in $O(B \cdot 2^B)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build \texttt{cnt[m]} of pairwise ANDs in $O(n^2)$.
\item Copy \texttt{cnt} to \texttt{g}; run SOS DP: for each bit $b$ from $0$ to $B-1$, for all \texttt{mask}, if \texttt{mask} has bit $b$ set, do \texttt{g[mask] += g[mask ^ (1<<b)]}.
\item Answer is \texttt{sum(g[mask\_comp(nums[k])])} where \texttt{mask\_comp(x) = ((1<<B)-1) ^ x}.
\end{algosteps}
\OPTIMALITY{Any correct method must at least consider all $n^2$ ordered pairs or all $2^{16}$ masks in some transformed way. This achieves $O(n^2 + 2^{16}\cdot 16 + n)$, which is tight up to small constants for $B=16$.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= O(n^2) + O(2^{16}\cdot 16) + O(n),\\
S(n) &= O(2^{16}).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        B = 16
        M = 1 << B
        n = len(nums)
        cnt = [0] * M
        # Count all ordered pairs' AND results
        for a in nums:
            for b in nums:
                cnt[a & b] += 1
        # SOS DP: g[mask] = sum_{sub ⊆ mask} cnt[sub]
        g = cnt[:]  # copy
        for b in range(B):
            step = 1 << b
            # Iterate all masks; if bit b is set, add from submask without b
            for mask in range(M):
                if mask & step:
                    g[mask] += g[mask ^ step]
        full = M - 1
        ans = 0
        for x in nums:
            ans += g[full ^ x]  # sum over all submasks of complement of x
        return ans

# Exact tests from the prompt and a couple more
if __name__ == "__main__":
    s = Solution()
    assert s.countTriplets([2, 1, 3]) == 12
    assert s.countTriplets([0, 0, 0]) == 27
    assert s.countTriplets([0, 1]) == 6  # all pairs AND with 0 makes 0; 2 elements -> 2^3 = 8, but (1,1,1) and (1,1,0?) check: brute verify quickly
    # Quick brute for [0,1]
    def brute(nums: List[int]) -> int:
        n = len(nums)
        out = 0
        for i in range(n):
            for j in range(n):
                for k in range(n):
                    if (nums[i] & nums[j] & nums[k]) == 0:
                        out += 1
        return out
    assert s.countTriplets([0, 1]) == brute([0, 1])
\end{minted}
\VALIDATION{Three asserts including cross-check against a short brute force on a small input.}
\RESULT{Returns the number of ordered triples with bitwise AND equal to zero. No special tie-breaking is needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover:
\begin{itemize}
\item Provided examples.
\item Degenerate arrays: single element 0 or nonzero; all zeros; mixed small sets.
\item Random small arrays cross-checked against brute force.
\end{itemize}}
\LINE{CROSS-CHECKS}{Compare Approach A (brute) vs C (SOS DP) on small random inputs ($n \le 6$) for equality.}
\LINE{EDGE-CASE GENERATOR}{Generate small arrays over a tiny alphabet of masks (e.g., $\{0,1,3,7\}$) to amplify zero-and interactions.}
\begin{minted}{python}
from typing import List
import random

def brute_count(nums: List[int]) -> int:
    n = len(nums)
    ans = 0
    for i in range(n):
        for j in range(n):
            for k in range(n):
                if (nums[i] & nums[j] & nums[k]) == 0:
                    ans += 1
    return ans

class Solution_ref:
    def countTriplets(self, nums: List[int]) -> int:
        B = 16
        M = 1 << B
        cnt = [0] * M
        for a in nums:
            for b in nums:
                cnt[a & b] += 1
        g = cnt[:]
        for b in range(B):
            step = 1 << b
            for mask in range(M):
                if mask & step:
                    g[mask] += g[mask ^ step]
        full = M - 1
        return sum(g[full ^ x] for x in nums)

def fuzz():
    rng = random.Random(0)
    for _ in range(50):
        n = rng.randint(1, 6)
        nums = [rng.choice([0,1,3,7,15]) for _ in range(n)]
        assert Solution_ref().countTriplets(nums) == brute_count(nums)
    print("Fuzz OK")

if __name__ == "__main__":
    fuzz()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        B = 16
        M = 1 << B
        cnt = [0] * M
        # Count ordered pair ANDs
        for a in nums:
            for b in nums:
                cnt[a & b] += 1
        # SOS DP for submask sums
        g = cnt[:]
        for b in range(B):
            bit = 1 << b
            for mask in range(M):
                if mask & bit:
                    g[mask] += g[mask ^ bit]
        full = M - 1
        return sum(g[full ^ x] for x in nums)

# Self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.countTriplets([2, 1, 3]) == 12
    assert s.countTriplets([0, 0, 0]) == 27
    # Random small cross-check
    def brute(nums: List[int]) -> int:
        n = len(nums)
        c = 0
        for i in range(n):
            for j in range(n):
                for k in range(n):
                    if (nums[i] & nums[j] & nums[k]) == 0:
                        c += 1
        return c
    assert s.countTriplets([0, 1]) == brute([0, 1])
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count ordered triples with zero bitwise AND by leveraging pairwise AND histogram and subset DP.}
\WHY{Classic LC hard that tests knowledge of SOS DP and bitmask convolution patterns.}
\CHECKLIST{
\begin{itemize}
\item Build pairwise AND counts over all ordered pairs.
\item Run SOS DP: submask sums over 16-bit masks.
\item For each $x$, add the submask sum of its bitwise complement.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item All zeros $\Rightarrow n^3$.
\item Single element zero vs nonzero.
\item Repeated values (high multiplicities).
\item Large $n$ with many identical numbers.
\item Numbers using disjoint bit sets.
\item Maximal values near $2^{16}-1$.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Forgetting ordered pairs (must count $(i,j)$ and $(j,i)$ separately).
\item Using 32-bit complement instead of restricting to 16 bits.
\item Incorrect SOS DP direction (must be submask sum, not supersets).
\item Off-by-one in mask size $2^{16}$.
\item Using slow Python constructs for inner loops; avoid per-iteration allocations.
\item Mixing bitwise \texttt{\&} with logical \texttt{and}.
\end{itemize}
}
\FAILMODES{Brute force $O(n^3)$ times out for $n=1000$. Enumerating all submasks per element without SOS DP can be $O(n\cdot 2^{16})$ and may be borderline; SOS DP reduces per-query to $O(1)$ after preprocessing.}
\ELI{Count how many pairs AND to each mask. Precompute, for every mask, how many pair-masks fit inside it. For each number, its compatible pair-masks are those inside its 16-bit complement; add them up.}
\NotePages{3}

\end{document}