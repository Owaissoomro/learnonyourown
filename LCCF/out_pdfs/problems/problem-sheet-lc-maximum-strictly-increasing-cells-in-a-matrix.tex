% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximum Strictly Increasing Cells in a Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given a 1-indexed $m \times n$ integer matrix $\text{mat}$, you may select any cell as the starting cell. From the current cell, you may move to any other cell in the same row or the same column whose value is strictly greater than the current cell's value. You may repeat moves as long as the destination value is strictly greater.

Your task is to find the maximum number of cells you can visit by choosing an optimal starting cell and making valid moves. Return an integer denoting this maximum.

Examples:
\begin{bullets}
\item Input: $\text{mat} = [[3,1],[3,4]]$; Output: $2$. One optimal path starts at row 1, column 2.
\item Input: $\text{mat} = [[1,1],[1,1]]$; Output: $1$. No strictly increasing move is possible.
\item Input: $\text{mat} = [[3,1,6],[-9,5,7]]$; Output: $4$.
\end{bullets}

Constraints (sanitized and clarified):
\begin{bullets}
\item $m = \lvert \text{mat} \rvert$, $n = \lvert \text{mat}[i] \rvert$ for all valid $i$.
\item $1 \le m,n \le 10^5$ and $1 \le m \times n \le 10^5$.
\item $-10^5 \le \text{mat}[i][j] \le 10^5$.
\end{bullets}}
\BREAKDOWN{Model moves as a directed acyclic graph by value: edges go from a cell to strictly greater cells in the same row or column. We need the longest path length in this DAG. Exploit row/column structure to avoid quadratic adjacency construction.}
\ELI{Sort cells by value and do dynamic programming that, for each cell, adds 1 to the best seen so far in its row or column from smaller values.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A 2D integer list $\text{mat}$ with shape $m \times n$ ($m,n \ge 1$), with entries in the range $[-10^5,10^5]$.}
\OUTPUTS{A single integer: the maximum number of cells that can be visited along a strictly increasing path moving only within rows or columns.}
\SAMPLES{
Example A:
\begin{bullets}
\item Input: $\text{mat}=[[3,1],[3,4]]$
\item Output: $2$
\end{bullets}
Example B:
\begin{bullets}
\item Input: $\text{mat}=[[1,2,3]]$
\item Output: $3$
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in \mathbb{Z}^{m \times n}$ be the matrix. Define a directed graph on nodes $(i,j)$ with an edge $(i,j) \to (i,k)$ iff $A_{i,k} > A_{i,j}$ and an edge $(i,j) \to (k,j)$ iff $A_{k,j} > A_{i,j}$. The goal is to compute
\begin{BreakableEquation*}
\max_{(i,j)} f(i,j)
\end{BreakableEquation*}
where $f(i,j)$ is the length of the longest path starting at $(i,j)$ in this DAG.}
\varmapStart
\var{A}{input matrix, $m \times n$}
\var{f(i,j)}{optimal path length starting at cell $(i,j)$}
\var{\text{row\_best}[i]}{best $f$ value among cells in row $i$ with smaller value than the current group's value}
\var{\text{col\_best}[j]}{best $f$ value among cells in column $j$ with smaller value than the current group's value}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
f(i,j) \;=\; 1 + \max\!\Big(\max_{\substack{k\\A_{i,k} > A_{i,j}}} f(i,k),\;\max_{\substack{k\\A_{k,j} > A_{i,j}}} f(k,j)\Big).
\end{BreakableEquation*}
To compute efficiently, sort cells by value and process equal values as a group:
\begin{BreakableEquation*}
g(i,j) \;=\; 1 + \max\big(\text{row\_best}[i],\text{col\_best}[j]\big)
\end{BreakableEquation*}
for all $(i,j)$ with the same value $v$, then set
\[
\text{row\_best}[i] \gets \max\big(\text{row\_best}[i], g(i,j)\big),\quad
\text{col\_best}[j] \gets \max\big(\text{col\_best}[j], g(i,j)\big).
\]
}
\ASSUMPTIONS{Moves are only to strictly greater values, so the value order induces a DAG. When processing a value group, no transitions are allowed within the group.}
\INVARIANTS{
\begin{bullets}
\item After finishing all groups with values $< v$, $\text{row\_best}[i]$ and $\text{col\_best}[j]$ equal the maximum $f$ among strictly smaller values in that row/column.
\item Group updates never use within-group information, preserving strictness.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute $f(i,j)$ with DFS and memoization on the DAG defined by ``greater in same row or column,'' enumerating neighbors by scanning the row and column.}
\ASSUMPTIONS{Intended for small instances due to $O(mn(m+n))$ neighbor scans in the worst case.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each cell $(i,j)$, define $f(i,j)$ as $1$ plus the maximum of $f$ over neighbors with larger values in its row and column.
\item Use DFS with memoization; neighbors are found by scanning all $n$ cells in row $i$ and all $m$ cells in column $j$.
\item Return the maximum $f(i,j)$ over all cells.
\end{algosteps}
\COMPLEXITY{Time $T(m,n)$ is dominated by repeated scans of rows and columns during DFS. In the worst case,
\[
\begin{aligned}
T(m,n) &\le O\big(mn \cdot (m+n)\big), \\
S(m,n) &= O(mn) \text{ for recursion stack and memo table.}
\end{aligned}
\]
}
\CORRECTNESS{Strictly increasing moves guarantee acyclicity by value, so DFS with memoization computes the longest path on this DAG. Scanning rows/columns enumerates exactly all valid outgoing edges.}
\EDGECASES{Single cell; single row or single column; all equal values; strictly increasing along a row/column; negative values.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
from functools import lru_cache

class Solution:
    # Baseline DFS with neighbor scans
    def maxIncreasingCells(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])

        @lru_cache(maxsize=None)
        def dfs(i: int, j: int) -> int:
            v = mat[i][j]
            best = 1
            # scan row i
            for jj in range(n):
                if mat[i][jj] > v:
                    cand = 1 + dfs(i, jj)
                    if cand > best:
                        best = cand
            # scan column j
            for ii in range(m):
                if mat[ii][j] > v:
                    cand = 1 + dfs(ii, j)
                    if cand > best:
                        best = cand
            return best

        ans = 1
        for i in range(m):
            for j in range(n):
                cur = dfs(i, j)
                if cur > ans:
                    ans = cur
        return ans

# Tiny sanity tests (baseline)
if __name__ == "__main__":
    s = Solution()
    assert s.maxIncreasingCells([[3,1],[3,4]]) == 2
    assert s.maxIncreasingCells([[1,1],[1,1]]) == 1
    assert s.maxIncreasingCells([[3,1,6],[-9,5,7]]) == 4
\end{minted}
\VALIDATION{Checked against three samples. For larger inputs this approach is too slow, motivating the improved DP.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Value Buckets + Per-Row/Col Best}
\WHICHFORMULA{Sort unique values and process value buckets. For each bucket value $v$, compute $g(i,j)=1+\max(\text{row\_best}[i],\text{col\_best}[j])$ for all cells with value $v$, then update row/column bests.}
\ASSUMPTIONS{We maintain $\text{row\_best}$ and $\text{col\_best}$ as the best DP values from strictly smaller values. Grouping by equal values preserves strictness.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a map from value $v$ to the list of coordinates with that value.
\item Iterate values $v$ in increasing order.
\item For each cell $(i,j)$ in the current value's bucket, compute $g(i,j)=1+\max(\text{row\_best}[i],\text{col\_best}[j])$ and track the global maximum.
\item After finishing the bucket, update $\text{row\_best}[i]$ and $\text{col\_best}[j]$ with the computed $g(i,j)$ for all cells in the bucket.
\end{algosteps}
\COMPLEXITY{Let $N=mn$ be the number of cells. Sorting by value and linear passes over buckets yield
\[
\begin{aligned}
T(N) &= O(N \log N),\\
S(N) &= O(m+n) \text{ for row/col best} + O(N) \text{ for grouping.}
\end{aligned}
\]
}
\CORRECTNESS{Strictly increasing moves imply no transitions within equal-value buckets. Computing $g(i,j)$ uses only bests from strictly smaller values, and delaying updates until the entire bucket is processed forbids equal-value chaining.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Dict, Tuple
from collections import defaultdict

class Solution:
    # Improved: process value buckets in increasing order
    def maxIncreasingCells(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        buckets: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
        for i in range(m):
            for j in range(n):
                buckets[mat[i][j]].append((i, j))

        row_best = [0] * m
        col_best = [0] * n
        ans = 1

        for v in sorted(buckets.keys()):
            cells = buckets[v]
            # compute g(i,j) without polluting bests for this bucket
            group_vals: List[Tuple[int, int, int]] = []
            for i, j in cells:
                g = 1 + max(row_best[i], col_best[j])
                group_vals.append((i, j, g))
                if g > ans:
                    ans = g
            # commit updates after the bucket
            for i, j, g in group_vals:
                if g > row_best[i]:
                    row_best[i] = g
                if g > col_best[j]:
                    col_best[j] = g

        return ans

# Tiny sanity tests (improved)
if __name__ == "__main__":
    s = Solution()
    assert s.maxIncreasingCells([[3,1],[3,4]]) == 2
    assert s.maxIncreasingCells([[1,1],[1,1]]) == 1
    assert s.maxIncreasingCells([[3,1,6],[-9,5,7]]) == 4
    assert s.maxIncreasingCells([[1,2,3]]) == 3
\end{minted}
\VALIDATION{Validated on samples and an extra single-row case. Equal-value rows/columns are handled because updates are bucket-delayed.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Streaming Sort + Grouped DP (Provably Optimal)}
\WHICHFORMULA{Sort all cells $(A_{i,j}, i, j)$ once; iterate in increasing value order while batching equal values. For each cell compute $1+\max(\text{row\_best}[i], \text{col\_best}[j])$, then commit updates after the batch.}
\ASSUMPTIONS{Applicable for any integer matrix. Correct because strict inequality induces a topological order by value and equal-value batches forbid within-batch transitions.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Flatten cells into triples $(\text{val}, i, j)$ and sort by $\text{val}$.
\item Sweep the list, identifying contiguous groups of equal $\text{val}$.
\item For each group, compute $g(i,j)=1+\max(\text{row\_best}[i],\text{col\_best}[j])$ for all $(i,j)$ in the group.
\item Commit: for all $(i,j)$ in the group, set $\text{row\_best}[i] \gets \max(\text{row\_best}[i], g(i,j))$ and $\text{col\_best}[j] \gets \max(\text{col\_best}[j], g(i,j))$.
\item Track and return the global maximum $g(i,j)$.
\end{algosteps}
\OPTIMALITY{This computes the exact longest path in the DAG and runs in $O(N \log N)$ time due to sorting; a comparison-based lower bound implies sorting of arbitrary values is necessary in the worst case. Memory is $O(m+n)$ beyond the input.}
\COMPLEXITY{
\[
\begin{aligned}
T(N) &= O(N \log N) \text{ from sorting plus linear sweep},\\
S(N) &= O(m+n) \text{ for row/col arrays}.
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def maxIncreasingCells(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        cells: List[Tuple[int, int, int]] = []
        for i in range(m):
            for j in range(n):
                cells.append((mat[i][j], i, j))
        cells.sort()  # increasing by value

        row_best = [0] * m
        col_best = [0] * n
        ans = 1

        idx = 0
        N = len(cells)
        while idx < N:
            v = cells[idx][0]
            j = idx
            group = []
            # collect equal-value group
            while j < N and cells[j][0] == v:
                _, i, k = cells[j]
                g = 1 + max(row_best[i], col_best[k])
                group.append((i, k, g))
                if g > ans:
                    ans = g
                j += 1
            # commit updates after the group
            for i, k, g in group:
                if g > row_best[i]:
                    row_best[i] = g
                if g > col_best[k]:
                    col_best[k] = g
            idx = j

        return ans

# Exact 3 asserts (final)
if __name__ == "__main__":
    s = Solution()
    assert s.maxIncreasingCells([[3,1],[3,4]]) == 2
    assert s.maxIncreasingCells([[1,1],[1,1]]) == 1
    assert s.maxIncreasingCells([[3,1,6],[-9,5,7]]) == 4
\end{minted}
\VALIDATION{Three asserts reproduce the given samples.}
\RESULT{Returns the maximum number of cells along any strictly increasing path moving within rows or columns; ties are irrelevant since only the maximum length is returned.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests: sample cases; random small matrices to compare baseline vs. optimal; degenerate layouts (single row/col, all equal, strictly increasing along one line, strictly decreasing).}
\LINE{CROSS-CHECKS}{On small sizes ($m,n \le 5$), compare Approach A and C outputs for equality over random seeds. On crafted equal-value clusters, verify no within-equal transitions.}
\LINE{EDGE-CASE GENERATOR}{Generate matrices with: all equal; monotone row-wise; monotone column-wise; checkerboard values; duplicates heavy vs. unique; negatives.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_equal(m: int, n: int, v: int) -> List[List[int]]:
    return [[v for _ in range(n)] for _ in range(m)]

def gen_row_increasing(m: int, n: int) -> List[List[int]]:
    return [list(range(1, n+1)) for _ in range(m)]

def gen_col_increasing(m: int, n: int) -> List[List[int]]:
    return [[i+1 for _ in range(m)] for _ in range(n)]  # transposed form

def gen_checker(m: int, n: int, a: int, b: int) -> List[List[int]]:
    return [[a if (i+j) % 2 == 0 else b for j in range(n)] for i in range(m)]

def gen_random_small(m: int, n: int, lo: int = -3, hi: int = 3, seed: int = 0) -> List[List[int]]:
    rng = random.Random(seed)
    return [[rng.randint(lo, hi) for _ in range(n)] for _ in range(m)]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def maxIncreasingCells(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        cells: List[Tuple[int, int, int]] = []
        for i in range(m):
            for j in range(n):
                cells.append((mat[i][j], i, j))
        cells.sort()

        row_best = [0] * m
        col_best = [0] * n
        ans = 1

        idx = 0
        N = len(cells)
        while idx < N:
            v = cells[idx][0]
            j = idx
            group = []
            while j < N and cells[j][0] == v:
                _, i, k = cells[j]
                g = 1 + max(row_best[i], col_best[k])
                group.append((i, k, g))
                if g > ans:
                    ans = g
                j += 1
            for i, k, g in group:
                if g > row_best[i]:
                    row_best[i] = g
                if g > col_best[k]:
                    col_best[k] = g
            idx = j

        return ans

# Reference tests
if __name__ == "__main__":
    s = Solution()
    assert s.maxIncreasingCells([[3,1],[3,4]]) == 2
    assert s.maxIncreasingCells([[1,1],[1,1]]) == 1
    assert s.maxIncreasingCells([[1,2,3]]) == 3
    assert s.maxIncreasingCells([[3,1,6],[-9,5,7]]) == 4
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Longest strictly increasing path where moves are limited to same row or column; process by values and keep per-row/column bests.}
\WHY{Common DP-on-sorted-states pattern; tests ability to avoid illegal equal-value transitions and to derive efficient state summaries.}
\CHECKLIST{
\begin{bullets}
\item Build states: cells, ordered by value.
\item Batch equal values; never mix within-batch updates.
\item DP step: $1+\max(\text{row\_best}[i], \text{col\_best}[j])$.
\item Commit row/column bests after finishing the batch.
\item Track global maximum.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All values equal $\Rightarrow$ answer $1$.
\item Single row or single column.
\item Strictly increasing along one row or one column.
\item Strictly decreasing matrix.
\item Large duplicates in one row and one column crossing.
\item Negative values mixed with positive.
\item $m=1$, $n=1$.
\item Same value appears in many rows and columns.
\item Non-square matrices $m \ne n$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Updating $\text{row\_best}$ or $\text{col\_best}$ inside the current value's loop (allows illegal equal-value chains).
\item Forgetting to take $\max$ when committing bests across multiple cells touching same row/column.
\item Integer off-by-one in path length initialization (must start at $1$).
\item Sorting but not grouping equal values.
\item Using recursion without memoization in the brute force approach.
\item Memory blow-up by building explicit adjacency lists per cell.
\item Confusing $m \times n$ limits with $m,n$ limits when estimating complexity.
\end{bullets}
}
\FAILMODES{Naive DFS that scans neighbors for each call can time out on adversarial matrices with many near-equal values. Incorrectly updating bests within a value bucket yields overestimates by allowing equal-value transitions. The grouped DP survives by deferring updates until the bucket completes.}
\ELI{Think of each number as a ``height.'' You can only climb to strictly higher heights in your row or column. Sweep heights from low to high: for each cell, your best climb length is one plus the best climb already seen in your row or column from lower heights. Cells of the same height are computed together, then recorded.}
\NotePages{3}

\end{document}