% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Cost to Move Chips to The Same Position}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-cost-to-move-chips-to-the-same-position/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{We have $n$ chips, where the position of the $i$th chip is $\text{position}[i]$. We need to move all the chips to the same position.

In one step, we can change the position of the $i$th chip from $\text{position}[i]$ to:
\begin{bullets}
\item $\text{position}[i] + 2$ or $\text{position}[i] - 2$ with cost $= 0$.
\item $\text{position}[i] + 1$ or $\text{position}[i] - 1$ with cost $= 1$.
\end{bullets}
Return the minimum cost needed to move all the chips to the same position.

Example 1:

Input: $\text{position} = [1, 2, 3]$. Output: $1$.

Explanation: First step: Move the chip at position $3$ to position $1$ with cost $= 0$. Second step: Move the chip at position $2$ to position $1$ with cost $= 1$. Total cost is $1$.

Example 2:

Input: $\text{position} = [2, 2, 2, 3, 3]$. Output: $2$.

Explanation: We can move the two chips at position $3$ to position $2$. Each move has cost $= 1$. The total cost $= 2$.

Example 3:

Input: $\text{position} = [1, 1000000000]$. Output: $1$.

Constraints:
\begin{bullets}
\item $1 \le \text{position.length} \le 100$.
\item $1 \le \text{position}[i] \le 10^9$.
\end{bullets}
}
\BREAKDOWN{Moving by $\pm 2$ is free, so parity of positions is invariant under zero-cost moves. Only crossing from even to odd (or odd to even) costs $1$ per chip. Therefore, it suffices to choose a target parity and pay for chips of the opposite parity.}
\ELI{Count how many chips are on even positions and how many on odd positions; the answer is the smaller of the two counts.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array $\text{position}$ of integers with $1 \le \text{position.length} \le 100$ and $1 \le \text{position}[i] \le 10^9$.}
\OUTPUTS{A single integer: the minimum total cost to move all chips to the same position.}
\SAMPLES{
Example A: $\text{position} = [1,2,3] \Rightarrow 1$.

Example B: $\text{position} = [2,2,2,3,3] \Rightarrow 2$.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $P = \{p_1, \ldots, p_n\}$ be the multiset of chip positions on $\mathbb{Z}$. A move of $\pm 2$ has cost $0$; a move of $\pm 1$ has cost $1$. The parity (even/odd) of a chip changes iff we pay cost $1$ for that chip. We seek a target integer $t$ minimizing total cost.}
\varmapStart
\var{n}{number of chips}
\var{p_i}{initial position of chip $i$}
\var{E}{number of chips initially at even positions}
\var{O}{number of chips initially at odd positions; $O = n - E$}
\var{t}{final target position}
\varmapEnd
\GOVERN{
\[
\text{cost}(t) = \#\{i : (p_i \bmod 2) \ne (t \bmod 2)\}
= \begin{cases}
O, & t \text{ even},\\
E, & t \text{ odd}.
\end{cases}
\]
Thus, the optimal value is
\begin{BreakableEquation*}
\min_{t \in \mathbb{Z}} \text{cost}(t) = \min(E, O).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Positions are integers; chips are indistinguishable except for positions; multiple chips may share the same position; we may move chips independently.}
\INVARIANTS{
\begin{bullets}
\item Parity invariant under free moves: $p_i \mapsto p_i \pm 2$ does not change parity.
\item A parity change costs at least $1$: any path from even to odd requires an odd number of $\pm 1$ moves.
\item Feasibility: Any $t \in \mathbb{Z}$ is reachable for any chip by combining $\pm 2$ and at most one $\pm 1$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all candidate targets among the given positions; compute cost for each as the number of chips whose parity differs from the target. Take the minimum.}
\ASSUMPTIONS{Since moving by $\pm 2$ is free, only parity matters; checking all unique input positions covers both parities present in the data.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the set $T$ of unique positions from $\text{position}$.
\item For each $t \in T$, compute $\text{cost}(t) = \sum_i [ (p_i - t) \bmod 2 \ne 0 ]$.
\item Return $\min_{t \in T} \text{cost}(t)$.
\end{algosteps}
\COMPLEXITY{With $m = |T| \le n$, we scan all chips for each target.}
\[
\begin{aligned}
T(n) &= O(n \cdot m) \le O(n^2), \\
S(n) &= O(1) \text{ extra (ignoring input storage)}.
\end{aligned}
\]
\CORRECTNESS{For any optimal target $t^\star$, only its parity affects the cost. If $t^\star$ has even parity and there exists at least one even position in the input, then some $t \in T$ shares that parity and achieves the same cost. If all positions are odd (or even), moving to that parity yields zero cost; such $t$ is also in $T$.}
\EDGECASES{All chips on the same parity (answer $0$). Single chip (answer $0$). Large coordinates do not matter since only parity is used.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        # Brute-force over unique targets; compute parity-mismatch cost
        uniq = set(position)
        best = 10**9
        for t in uniq:
            cost = 0
            for p in position:
                # Crossing parity costs 1; even distance costs 0
                if ((p - t) & 1) != 0:
                    cost += 1
            if cost < best:
                best = cost
        # If uniq is empty (should not happen per constraints), return 0
        return 0 if best == 10**9 else best

# Basic asserts from the prompt
assert Solution().minCostToMoveChips([1, 2, 3]) == 1
assert Solution().minCostToMoveChips([2, 2, 2, 3, 3]) == 2
assert Solution().minCostToMoveChips([1, 1000000000]) == 1
\end{minted}
\VALIDATION{Also check trivial boundaries: single element returns $0$; all equal positions returns $0$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Parity Counting}
\WHICHFORMULA{Only parity matters. Count chips on even indices and on odd indices; cost is $\min(E, O)$.}
\ASSUMPTIONS{Parity of positions drives zero-cost reachability via $\pm 2$ moves; switching parity costs exactly $1$ per chip.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize counters $E \leftarrow 0$, $O \leftarrow 0$.
\item For each $p$ in $\text{position}$: if $p$ is even, increment $E$, else increment $O$.
\item Return $\min(E, O)$.
\end{algosteps}
\COMPLEXITY{Single pass over the input.}
\[
\begin{aligned}
T(n) &= O(n), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Each chip at the same parity as the target can be moved to it using only $\pm 2$ moves at zero cost. Each chip at opposite parity must change parity exactly once, incurring cost $1$. Thus the minimal total cost is the count of chips on the non-chosen parity, minimized by choosing the more populous parity.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        even = 0
        for p in position:
            if (p & 1) == 0:
                even += 1
        odd = len(position) - even
        return min(even, odd)

# Same tests
assert Solution().minCostToMoveChips([1, 2, 3]) == 1
assert Solution().minCostToMoveChips([2, 2, 2, 3, 3]) == 2
assert Solution().minCostToMoveChips([1, 1000000000]) == 1
\end{minted}
\VALIDATION{Edge validation: all even $\Rightarrow 0$; all odd $\Rightarrow 0$; mixed small arrays match baseline.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Closed-Form via Parity Invariant}
\WHICHFORMULA{Compute $E$ and $O$ once and return $\min(E, O)$; this is optimal and cannot be asymptotically improved.}
\ASSUMPTIONS{Positions are integers; operations allowed are $\pm 1$ and $\pm 2$ with stated costs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $E = \#\{p \in \text{position} : p \text{ is even}\}$.
\item Let $O = n - E$.
\item Return $\min(E, O)$.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must inspect the parity of each input element at least once, implying an $\Omega(n)$ time lower bound in the comparison model; we match this with $O(n)$ time and $O(1)$ space.}
\COMPLEXITY{Linear time, constant extra space.}
\[
\begin{aligned}
T(n) &= \Theta(n), \\
S(n) &= \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        even = sum(1 for p in position if (p & 1) == 0)
        odd = len(position) - even
        return min(even, odd)

# Exactly 3 asserts (prompt examples)
assert Solution().minCostToMoveChips([1, 2, 3]) == 1
assert Solution().minCostToMoveChips([2, 2, 2, 3, 3]) == 2
assert Solution().minCostToMoveChips([1, 1000000000]) == 1
\end{minted}
\VALIDATION{The three provided examples all hold.}
\RESULT{Return the integer $\min(\#\text{even positions}, \#\text{odd positions})$. Ties can be broken arbitrarily since both parities yield the same minimal cost.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit test the method on given examples, degenerate cases (all same parity, single element), and randomized arrays by cross-checking brute-force and optimal implementations.}
\LINE{CROSS-CHECKS}{For random inputs with small size, compare the parity-count solution with a direct scan over both parities or over all unique targets; they must agree.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of size $1$; arrays where all entries share parity; arrays alternating parity; arrays with repeated positions.}
\begin{minted}{python}
import random
from typing import List

def bf_cost(position: List[int]) -> int:
    uniq = set(position)
    if not uniq:
        return 0
    best = 10**9
    for t in uniq:
        cost = sum(((p - t) & 1) != 0 for p in position)
        best = min(best, cost)
    return best

class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        even = sum(1 for p in position if (p & 1) == 0)
        return min(even, len(position) - even)

# Property tests
rng = random.Random(0)
for n in range(1, 25):
    for _ in range(200):
        arr = [rng.randint(1, 10**6) for _ in range(n)]
        assert Solution().minCostToMoveChips(arr) == bf_cost(arr)

# Deterministic edge tests
assert Solution().minCostToMoveChips([2]) == 0
assert Solution().minCostToMoveChips([3]) == 0
assert Solution().minCostToMoveChips([2, 4, 6, 8]) == 0
assert Solution().minCostToMoveChips([1, 3, 5, 7]) == 0
assert Solution().minCostToMoveChips([1, 2, 2, 2, 3, 5]) == min(4, 2)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        # Count parity; moving by ±2 is free, crossing parity costs 1 per chip.
        even = 0
        for p in position:
            if (p & 1) == 0:
                even += 1
        odd = len(position) - even
        return min(even, odd)

# Sanity tests
if __name__ == "__main__":
    s = Solution()
    assert s.minCostToMoveChips([1, 2, 3]) == 1
    assert s.minCostToMoveChips([2, 2, 2, 3, 3]) == 2
    assert s.minCostToMoveChips([1, 1000000000]) == 1
    assert s.minCostToMoveChips([2]) == 0
    assert s.minCostToMoveChips([3]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimum total cost equals the count of chips whose parity differs from the chosen target parity; pick the majority parity as target.}
\WHY{This is a classic invariant trick: recognizing that certain moves are free preserves a feature (parity) and reduces the problem to a simple count.}
\CHECKLIST{
\begin{bullets}
\item Identify free moves and their invariant (parity under $\pm 2$).
\item Map costful moves to changing the invariant (parity flips).
\item Count even vs odd occurrences.
\item Return $\min(E, O)$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Single chip: cost $0$.
\item All chips same position: cost $0$.
\item All chips same parity: cost $0$.
\item Mix with one chip of minority parity: cost $1$.
\item Large coordinates (up to $10^9$): unaffected.
\item Duplicates in positions: handled naturally.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Over-simulating moves instead of using parity.
\item Assuming target must be one of the input positions; only parity matters, but this assumption is harmless here.
\item Integer overflow not an issue in Python, but beware in fixed-width languages.
\item Miscounting parity due to negative numbers (not present here; inputs are positive).
\item Forgetting that $\pm 2$ moves can chain to reach any same-parity target at zero cost.
\item Off-by-one in counting evens and odds.
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item A naive ``move to median'' heuristic fails because distances beyond parity do not matter.
\item Greedy local moves that pay unnecessary $\pm 1$ steps inflate cost; parity counting avoids this.
\end{bullets}
}
\ELI{Because jumps of size $2$ are free, you can slide any chip along even steps without paying. You only pay when you need to switch from even to odd or vice versa. So gather chips on whichever parity already has more chips, and pay only for the others.}
\NotePages{3}

\end{document}