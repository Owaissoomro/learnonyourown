% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lexicographical Numbers}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/lexicographical-numbers/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given an integer \texttt{n}, return all the numbers in the range \texttt{[1, n]} sorted in lexicographical order.

You must write an algorithm that runs in \texttt{O(n)} time and uses \texttt{O(1)} extra space.

\textbf{Example 1:}

\texttt{Input:} n = 13

\texttt{Output:} [1,10,11,12,13,2,3,4,5,6,7,8,9]

\textbf{Example 2:}

\texttt{Input:} n = 2

\texttt{Output:} [1,2]

\textbf{Constraints:}
\begin{itemize}
\item \texttt{1 <= n <= 5 * 10\^{}4} \quad (sanitized: $1 \le n \le 5 \times 10^{4}$).
\end{itemize}
}
\BREAKDOWN{We must list integers $1$ to $n$ in dictionary order by their decimal string forms, but compute them on-the-fly in $O(n)$ time and $O(1)$ auxiliary space (besides the output). The classic approach is to simulate a preorder traversal of a 10-ary trie over digit prefixes.}
\ELI{Walk numbers like words in a dictionary: go as deep as possible by appending 0, then backtrack and increment the last digit when needed.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $n$ with $1 \le n \le 5 \times 10^{4}$.}
\OUTPUTS{Return a list of integers of length $n$ containing the numbers $1,2,\ldots,n$ sorted by lexicographic order of their decimal representations (no leading zeros).}
\SAMPLES{
Example A: $n=13 \Rightarrow [1,10,11,12,13,2,3,4,5,6,7,8,9]$.

Example B: $n=2 \Rightarrow [1,2]$.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $S=\{1,2,\ldots,n\}$. Define $\phi:S\to \{0,1,\ldots,9\}^{*}$ by $\phi(x)=\text{the base-10 string of }x$ (no leading zeros). We seek the total order on $S$ given by $x \prec y \iff \phi(x)$ is lexicographically smaller than $\phi(y)$.}
\varmapStart
\var{n}{upper bound of the range}
\var{\phi(x)}{string of $x$ in base 10}
\var{curr}{current integer during prefix walk}
\var{A}{output list of length $n$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Enumerate }A[1..n]\text{ such that }A \text{ is a permutation of }[1..n]\text{ and } \forall i<j:\ \phi(A_i) \le_{\text{lex}} \phi(A_j).
\end{BreakableEquation*}
}
\ASSUMPTIONS{No leading zeros; base-10 digits only; comparison is standard lexicographical order on strings.}
\INVARIANTS{
\begin{bullets}
\item Every emitted integer is in $[1,n]$ and distinct.
\item Prefix-walk invariant: when possible, move from $x$ to $10x$; otherwise backtrack by truncating trailing $9$s and incrementing.
\item The next produced value is the lexicographic successor of the current value under $\phi$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Convert each integer to its decimal string, sort pairs $(\phi(x),x)$ by key $\phi(x)$, then output the $x$ values.}
\ASSUMPTIONS{Sorting is allowed; extra memory proportional to $n$ is allowed for this baseline only (not acceptable per problem constraints, but useful for validation).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build array of pairs $(\phi(x),x)$ for $x=1,\ldots,n$.
\item Sort the array by the string key $\phi(x)$.
\item Output the sequence of $x$ from the sorted array.
\end{algosteps}
\COMPLEXITY{Time $O(n\log n)$ for comparison sort (average; key lengths are $O(\log_{10} n)$), space $O(n)$ extra.}
\[
\begin{aligned}
T(n) &= O(n\log n) \quad \text{(comparisons)} \\
S(n) &= O(n) \quad \text{(keys and pairs)}
\end{aligned}
\]
\CORRECTNESS{Sorting by $\phi(x)$ produces the lexicographic order by definition of $\phi$ and the comparator.}
\EDGECASES{Small $n$ (e.g., $n=1$); transitions across decimal boundaries such as between $9$ and $10$, $19$ to $2$, etc.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        # Baseline: sort by string key
        pairs: List[Tuple[str, int]] = [(str(x), x) for x in range(1, n + 1)]
        pairs.sort(key=lambda t: t[0])
        return [x for _, x in pairs]

# Asserts (baseline behavior)
sol = Solution()
assert sol.lexicalOrder(1) == [1]
assert sol.lexicalOrder(2) == [1, 2]
assert sol.lexicalOrder(13) == [1,10,11,12,13,2,3,4,5,6,7,8,9]
\end{minted}
\VALIDATION{Baseline will be used to cross-check optimized methods on small $n$. The above asserts cover edge and typical cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Recursive DFS on Digit Trie}
\WHICHFORMULA{Perform a preorder DFS over the implicit 10-ary trie of decimal prefixes. Visit nodes for integers in $[1,n]$ in lexicographic order.}
\ASSUMPTIONS{Recursive stack depth is bounded by the number of digits of $n$ ($\le 5$ for $n \le 5 \times 10^{4}$), so $O(\log_{10} n)$ extra space.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each leading digit $d=1$ to $9$, call \texttt{dfs(d)}.
\item In \texttt{dfs(x)}: if $x>n$, return. Otherwise append $x$ to output.
\item Recurse for children $10x, 10x+1, \ldots, 10x+9$ in order.
\end{algosteps}
\COMPLEXITY{Visits each valid integer once: $O(n)$ time; recursion uses $O(\log_{10} n)$ stack frames.}
\[
\begin{aligned}
T(n) &= \Theta(n) \\
S(n) &= \Theta(\log_{10} n)
\end{aligned}
\]
\CORRECTNESS{Preorder traversal of a trie enumerates words in lexicographic order; valid children maintain prefix order.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        res: List[int] = []

        def dfs(x: int) -> None:
            if x > n:
                return
            res.append(x)
            for d in range(10):
                child = x * 10 + d
                if child > n:
                    break
                dfs(child)

        for d in range(1, 10):
            dfs(d)
            if len(res) == n:
                break
        return res

# Asserts (improved behavior)
sol = Solution()
assert sol.lexicalOrder(1) == [1]
assert sol.lexicalOrder(2) == [1, 2]
assert sol.lexicalOrder(13) == [1,10,11,12,13,2,3,4,5,6,7,8,9]
\end{minted}
\VALIDATION{Checks for $n=1,2,13$ ensure order is lexicographic and recursion halts at bounds.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Iterative Lexicographic Successor Walk}
\WHICHFORMULA{Maintain current value $curr$ and repeatedly move to the lexicographic successor:
(i) if $10\cdot curr \le n$, descend to $10\cdot curr$;
(ii) else while $curr \bmod 10 = 9$ or $curr+1>n$, backtrack via $curr \gets \lfloor curr/10 \rfloor$;
(iii) then $curr \gets curr+1$.}
\ASSUMPTIONS{Decimal representation without leading zeros; $n \ge 1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $curr=1$.
\item Repeat $n$ times: append $curr$ to output.
\item If $curr \times 10 \le n$, set $curr \gets 10 \times curr$ and continue.
\item Otherwise, while $curr \bmod 10 = 9$ or $curr+1>n$, set $curr \gets \lfloor curr/10 \rfloor$.
\item Finally, set $curr \gets curr+1$.
\end{algosteps}
\OPTIMALITY{Each integer $1..n$ is produced exactly once; each digit position is incremented/decremented a constant number of times across the run, giving $O(n)$ time and $O(1)$ extra space (besides output).}
\COMPLEXITY{Time $T(n)=\Theta(n)$; space $S(n)=\Theta(1)$ auxiliary.}
\[
\begin{aligned}
T(n) &= \Theta(n) \\
S(n) &= \Theta(1)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        res: List[int] = []
        curr = 1
        for _ in range(n):
            res.append(curr)
            if curr * 10 <= n:
                curr *= 10
            else:
                while curr % 10 == 9 or curr + 1 > n:
                    curr //= 10
                curr += 1
        return res

# Asserts (final behavior)
sol = Solution()
assert sol.lexicalOrder(1) == [1]
assert sol.lexicalOrder(2) == [1, 2]
assert sol.lexicalOrder(13) == [1,10,11,12,13,2,3,4,5,6,7,8,9]
\end{minted}
\VALIDATION{Exactly 3 asserts included, covering minimal, small, and boundary-crossing cases.}
\RESULT{Return the lexicographic ordering of $[1..n]$ with no ties; ordering is total by string comparison rules.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify correctness on boundaries ($n=1,9,10,11,19,20$), random small $n$, and compare against the baseline sorted-by-string method for $n$ up to, say, 200.}
\LINE{CROSS-CHECKS}{For a range of $n$, ensure the optimal method matches the baseline output exactly.}
\LINE{EDGE-CASE GENERATOR}{Deterministically iterate $n=1$ to $200$; include digit-boundary values: $9,10,19,20,99,100,199,200$.}
\begin{minted}{python}
from typing import List, Tuple

def baseline_lex_order(n: int) -> List[int]:
    return [x for _, x in sorted((str(x), x) for x in range(1, n + 1))]

class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        res: List[int] = []
        curr = 1
        for _ in range(n):
            res.append(curr)
            if curr * 10 <= n:
                curr *= 10
            else:
                while curr % 10 == 9 or curr + 1 > n:
                    curr //= 10
                curr += 1
        return res

# Deterministic checks
def run_checks():
    sol = Solution()
    # Boundary and crafted cases
    cases: List[int] = [1, 2, 9, 10, 11, 13, 19, 20, 99, 100, 199, 200]
    for n in cases:
        assert sol.lexicalOrder(n) == baseline_lex_order(n)
    # Range sweep
    for n in range(1, 201):
        assert sol.lexicalOrder(n) == baseline_lex_order(n)

run_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        res: List[int] = []
        curr = 1
        for _ in range(n):
            res.append(curr)
            if curr * 10 <= n:
                curr *= 10
            else:
                while curr % 10 == 9 or curr + 1 > n:
                    curr //= 10
                curr += 1
        return res

# Minimal sanity asserts (can be removed for submission)
if __name__ == "__main__":
    s = Solution()
    assert s.lexicalOrder(1) == [1]
    assert s.lexicalOrder(2) == [1, 2]
    assert s.lexicalOrder(13) == [1,10,11,12,13,2,3,4,5,6,7,8,9]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Simulate dictionary order over $1..n$ by iteratively descending to $10\cdot x$ when possible, else backtracking and incrementing.}
\WHY{Lexicographic enumeration appears often in interviews to test understanding of tries, successor functions, and in-place traversals with strict space bounds.}
\CHECKLIST{
\begin{bullets}
\item Start at $curr=1$; loop exactly $n$ iterations.
\item Prefer $curr \gets 10\cdot curr$ if within $n$.
\item Else backtrack while at a rightmost path: $curr \bmod 10 = 9$ or $curr+1>n$.
\item Then do $curr \gets curr+1$.
\item Emit every $curr$ before transitions.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item Crossing $9 \to 10$.
\item Ending at a block boundary like $n=19$ (must backtrack to $2$).
\item Deep descent like $1 \to 10 \to 100$ when $n$ large enough.
\item Many trailing $9$s, e.g., $curr=1999$.
\item Exact powers of ten: $n=10,100$.
\item Near-max constraint $n=5\times 10^{4}$.
\item When $curr+1>n$ repeatedly near the end.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to emit before descending.
\item Infinite loop if backtracking does not eventually reduce $curr$.
\item Off-by-one when checking $curr*10 \le n$ vs $curr*10 < n$.
\item Not handling multiple trailing $9$s in a row.
\item Using recursion and violating strict $O(1)$ auxiliary space.
\item Converting to strings inside the optimal loop (unnecessary overhead).
\item Mishandling $curr=0$ (should never occur).
\item Exiting early and producing fewer than $n$ numbers.
\end{bullets}
}
\FAILMODES{Sorting-based methods exceed $O(1)$ extra space and $O(n)$ time; naive increment with string comparison per step does not preserve lexicographic order without backtracking. The successor-walk survives all cases by construction.}
\ELI{Think of counting words in a dictionary: go as far as you can by appending zeros, and when you cannot, go back until you can increase a digit, then continue. This produces exactly the next word every time, using only a couple of integers.}
\NotePages{3}

\end{document}