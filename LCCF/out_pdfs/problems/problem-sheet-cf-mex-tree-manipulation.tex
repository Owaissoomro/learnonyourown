% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — MEX Tree Manipulation}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1740/H}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{Given a rooted tree, define the value of vertex $u$ in the tree recursively as the MEX$^\dagger$ of the values of its children. Note that it is only the children, not all of its descendants. In particular, the value of a leaf is $0$.

Pak Chanek has a rooted tree that initially only contains a single vertex with index $1$, which is the root. Pak Chanek is going to do $q$ queries. In the $i$-th query, Pak Chanek is given an integer $x_i$. Pak Chanek needs to add a new vertex with index $i+1$ as the child of vertex $x_i$. After adding the new vertex, Pak Chanek needs to recalculate the values of all vertices and report the sum of the values of all vertices in the current tree.

$^\dagger$ The MEX (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. For example, the MEX of $[0,1,1,2,6,7]$ is $3$ and the MEX of $[6,9]$ is $0$.

Input:
The first line contains a single integer $q$ ($1 \le q \le 3 \cdot 10^5$) — the number of operations.

Each of the next $q$ lines contains a single integer $x_i$ ($1 \leq x_i \leq i$) — the description of the $i$-th query.

Output:
For each query, print a line containing an integer representing the sum of the new values of all vertices in the tree after adding the vertex.

Note:
In the first example, the tree after the $6$-th query will look like this.

- Vertex $7$ is a leaf, so its value is $0$.
- Vertex $6$ is a leaf, so its value is $0$.
- Vertex $5$ only has a child with value $0$, so its value is $1$.
- Vertex $4$ is a leaf, so its value is $0$.
- Vertex $3$ only has a child with value $0$, so its value is $1$.
- Vertex $2$ has children with values $0$ and $1$, so its value is $2$.
- Vertex $1$ has children with values $1$ and $2$, so its value is $0$.

The sum of the values of all vertices is $0+0+1+0+1+2+0=4$.}
\BREAKDOWN{Maintain for each node the multiset of child values and its current MEX. Upon inserting a new leaf under $x_i$, update the counts at $x_i$, recompute its MEX, and propagate any change to its ancestors until stabilization. Track the running sum of all node values.}
\ELI{Each node holds the smallest integer missing among its children. Adding a new leaf can ripple changes up toward the root; update along that path and keep a running total.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test.\\
- Integer $q$ with $1 \le q \le 3 \cdot 10^5$.\\
- For each $i=1,\ldots,q$, an integer $x_i$ with $1 \le x_i \le i$, meaning node $i+1$ is added as a child of node $x_i$.}
\OUTPUTS{After each insertion, output one line with the sum of the current node values (the MEX of each node's children), across all nodes present.}
\SAMPLES{Example A. Input:
\[
\begin{aligned}
q&=1\\
x_1&=1
\end{aligned}
\]
Output:
\begin{BreakableEquation*}
1
\end{BreakableEquation*}
Explanation: After adding node $2$ under $1$, values are $g(2)=0$, $g(1)=1$, sum $=1$.

Example B. Input sequence:
\begin{BreakableEquation*}
q=3,\quad (x_1,x_2,x_3)=(1,1,2).
\end{BreakableEquation*}
Outputs by step:
\begin{BreakableEquation*}
1,\ 1,\ 3.
\end{BreakableEquation*}
Explanation: After steps, sums are $1$ (nodes $1,2$), then $1$ (nodes $1,2,3$), then $3$ (nodes $1,2,3,4$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a rooted tree with root $r$. For each vertex $u$, define $g(u)$ recursively by:
- If $u$ is a leaf, then $g(u)=0$.
- Otherwise $g(u)=\operatorname{mex}\{g(v): v \text{ is a child of } u\}$.\\
After each insertion that attaches a new leaf as a child of some $x$, recompute $g(\cdot)$ and report $\sum_{u\in V} g(u)$.}
\varmapStart
\var{g(u)}{value at node $u$ (MEX of child values)}
\var{\operatorname{mex}(S)}{smallest non-negative integer not in the multiset $S$}
\var{x_i}{parent chosen at step $i$; new node has index $i+1$}
\var{\text{par}(u)}{parent of $u$; $\text{par}(r)=0$ (sentinel)}
\var{C(u)}{multiset of child values of $u$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
g(u) &= \begin{cases}
0, & \text{if $u$ is a leaf},\\
\min\{k \in \mathbb{Z}_{\ge 0} : k \not\in \{g(v): v \in \text{children}(u)\}\}, & \text{otherwise},
\end{cases}\\
\text{Answer after step }i &= \sum_{u \in V_i} g(u).
\end{aligned}
\]
}
\ASSUMPTIONS{The root is node $1$. Nodes are added one-by-one; at step $i$ we add node $i+1$ under an existing node $x_i$. No deletions.}
\INVARIANTS{After any step:
- For all $u$, $g(u)$ is a non-negative integer and $g(u) \le \deg(u)$.
- If $g(u) > 0$, then for every $t \in \{0,\ldots,g(u)-1\}$, there exists a child $v$ of $u$ with $g(v)=t$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Maintain for each node a frequency map of child values and recompute $\operatorname{mex}$ as the smallest non-missing key starting from $0$. Propagate changes along the parent chain until stabilization; maintain the running sum.}
\ASSUMPTIONS{Tree only grows by adding leaves. Parent pointers are available. Child-value frequency maps are maintained incrementally.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize root $1$ with $g(1)=0$; empty frequency maps for all nodes.
\item For each query $(x)$ adding node $v$ as child of $x$: set $g(v)=0$, add one count of $0$ to $x$'s frequency map.
\item Let $u \leftarrow x$. While the recomputed $\operatorname{mex}$ at $u$ differs from current $g(u)$, update the global sum and update the parent frequency map to reflect the child's value change, then move $u \leftarrow \text{par}(u)$. Stop when a node's value stays unchanged or at the root with no parent.
\end{algosteps}
\COMPLEXITY{In the worst case, each recomputation at $u$ scans its child-value frequency map from $0$ upward, i.e., $O(\deg(u)+g(u))$. Propagation can travel up to the root. In the worst case this can be $O(n)$ per query, hence $O(n^2)$ total. Practical performance is fast for small to moderate inputs.}
\[
\begin{aligned}
T(q) &\le \sum_{i=1}^{q} O(\text{depth of }x_i \text{ at step }i) \\
     &\text{(can be }O(q^2)\text{ in adversarial inputs).}
\end{aligned}
\]
\CORRECTNESS{At each node, the maintained frequency map exactly captures multiset of child values, so recomputing the smallest $k$ with zero frequency yields $\operatorname{mex}$. Propagation updates the only affected ancestors (the parent chain), and stops when a node's value stabilizes, so values match the definition after each step. The running sum is updated by the exact deltas.}
\EDGECASES{Single-node tree; repeatedly attaching to the root; attaching in a long chain; creating a star; multiple identical child values; deep propagation that stops early when a node's value is unchanged.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Codeforces CF-Style: read_input(), solve_all(), main + guard, and asserts.
from typing import List, Tuple, Dict

def read_input(data: str) -> Tuple[int, List[int]]:
    it = iter(data.strip().split())
    try:
        q = int(next(it))
    except StopIteration:
        return 0, []
    xs = [int(next(it)) for _ in range(q)]
    return q, xs

def solve_all(data: str) -> str:
    q, xs = read_input(data)
    if q == 0:
        return ""
    n = q + 1  # total nodes after all insertions
    parent = [0] * (n + 2)
    g = [0] * (n + 2)
    # frequency maps of child values for each node
    freq: List[Dict[int, int]] = [dict() for _ in range(n + 2)]
    parent[1] = 0
    g[1] = 0
    total_sum = 0  # g[1] is 0 initially

    out_lines: List[str] = []

    def recompute_mex(u: int) -> int:
        # smallest k >= 0 with freq[u].get(k,0) == 0
        k = 0
        fu = freq[u]
        while fu.get(k, 0) > 0:
            k += 1
        return k

    for i, x in enumerate(xs, start=1):
        v = i + 1
        parent[v] = x
        g[v] = 0
        freq[v] = {}
        # add child v with value 0 to x
        fx = freq[x]
        fx[0] = fx.get(0, 0) + 1

        # propagate changes up from x
        u = x
        while True:
            new_val = recompute_mex(u)
            if new_val == g[u]:
                break
            old_val = g[u]
            g[u] = new_val
            total_sum += (new_val - old_val)
            p = parent[u]
            if p == 0:
                break
            # update parent's frequency map for child's value change
            fp = freq[p]
            cnt_old = fp.get(old_val, 0)
            if cnt_old <= 1:
                if old_val in fp:
                    del fp[old_val]
            else:
                fp[old_val] = cnt_old - 1
            fp[new_val] = fp.get(new_val, 0) + 1
            u = p

        out_lines.append(str(total_sum))

    return "\n".join(out_lines)

def _run_tests():
    # Tiny tests for sanity
    # Test 1: single insertion under root
    data = "1\n1\n"
    out = solve_all(data)
    assert out.strip().split() == ["1"]
    # Test 2: chain then branch
    data = "3\n1\n1\n2\n"
    out = solve_all(data)
    assert out.strip().split() == ["1", "1", "3"]
    # Test 3: a small star at root
    data = "4\n1\n1\n1\n1\n"
    out = solve_all(data)
    # After k-th insert, g(root)=1 (until a child reaches 1), sums: 1,1,1,1
    assert out.strip().split() == ["1", "1", "1", "1"]

if __name__ == "__main__":
    import sys
    data = sys.stdin.read()
    if not data.strip():
        _run_tests()
    else:
        sys.stdout.write(solve_all(data))
\end{minted}
\VALIDATION{Verified on tiny hand-crafted cases, including a star at the root and a short chain with a branch.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use per-node hash maps counting child values to avoid rescanning all children on each propagation step, and terminate propagation immediately once a node's value (MEX) stabilizes. This prunes many updates in practice.}
\ASSUMPTIONS{Child values only increase over time; only ancestors of the insertion point can change. Hash maps keep only present values to keep scans short when MEX is small.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain, for each node $u$, a map from child value $t$ to count.
\item On insertion under $x$, increment count of $0$ in $x$'s map; recompute $\operatorname{mex}(x)$ by scanning $t=0,1,\ldots$ until a gap.
\item If $g(x)$ changes, update the parent map by decrementing old value and incrementing new value, then continue to the parent. Stop once a node's value does not change.
\end{algosteps}
\COMPLEXITY{Propagation halts as soon as a node's value remains stable, often yielding short updates. However, in the worst case the chain can be long, and recomputation scans from $0$ up to the MEX, so the worst-case remains $O(n)$ per operation.}
\[
\begin{aligned}
T(q) &\in O\Bigl(\sum_{i=1}^{q} \text{depth}(x_i)\Bigr)\quad\text{(worst case)}.
\end{aligned}
\]
\CORRECTNESS{Same as baseline: frequency maps precisely reflect child-value multisets; updates are local and propagate only when necessary; sum is updated via exact deltas.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple, Dict

def read_input(data: str) -> Tuple[int, List[int]]:
    it = iter(data.strip().split())
    try:
        q = int(next(it))
    except StopIteration:
        return 0, []
    xs = [int(next(it)) for _ in range(q)]
    return q, xs

def solve_all(data: str) -> str:
    q, xs = read_input(data)
    if q == 0:
        return ""
    n = q + 1
    parent = [0] * (n + 2)
    g = [0] * (n + 2)
    freq: List[Dict[int, int]] = [dict() for _ in range(n + 2)]
    total_sum = 0
    parent[1] = 0
    g[1] = 0
    out_lines: List[str] = []

    def mex_of(u: int) -> int:
        fu = freq[u]
        k = 0
        while fu.get(k, 0) > 0:
            k += 1
        return k

    for i, x in enumerate(xs, start=1):
        v = i + 1
        parent[v] = x
        g[v] = 0
        freq[v] = {}
        # add child v with value 0
        fx = freq[x]
        fx[0] = fx.get(0, 0) + 1

        # propagate upwards
        u = x
        while True:
            new_val = mex_of(u)
            if new_val == g[u]:
                break
            old_val = g[u]
            g[u] = new_val
            total_sum += new_val - old_val
            p = parent[u]
            if p == 0:
                break
            # reflect child's value change in parent
            fp = freq[p]
            co = fp.get(old_val, 0)
            if co <= 1:
                if old_val in fp:
                    del fp[old_val]
            else:
                fp[old_val] = co - 1
            fp[new_val] = fp.get(new_val, 0) + 1
            u = p

        out_lines.append(str(total_sum))

    return "\n".join(out_lines)

def _run_tests():
    data = "1\n1\n"
    assert solve_all(data).strip().split() == ["1"]
    data = "3\n1\n1\n2\n"
    assert solve_all(data).strip().split() == ["1", "1", "3"]
    data = "4\n1\n1\n1\n1\n"
    assert solve_all(data).strip().split() == ["1", "1", "1", "1"]

if __name__ == "__main__":
    import sys
    data = sys.stdin.read()
    if not data.strip():
        _run_tests()
    else:
        sys.stdout.write(solve_all(data))
\end{minted}
\VALIDATION{Checked on small handcrafted patterns: chain, star, and mixed branch.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Partition nodes into light/heavy by degree threshold $B\approx \sqrt{q}$. For light nodes, track presence of small child values in a bounded array and recompute $\operatorname{mex}$ quickly. For heavy nodes (at most $O(q/B)$), maintain a balanced structure (e.g., a Fenwick/segment tree over a boolean array of presences) to query the smallest missing value in $O(\log q)$. Propagation updates only along the ancestor chain, with each step costing $O(1)$ for light nodes or $O(\log q)$ for heavy nodes.}
\ASSUMPTIONS{Degree thresholding ensures there are few heavy nodes; child values are non-decreasing, so updates are one-way for children even though parent MEX can fluctuate.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Fix $B = \lfloor \sqrt{q} \rfloor$. Nodes with degree $< B$ are light; others are heavy.
\item For a light node, maintain an $[0..B)$ presence array and a counter of present small values. Its MEX is either the first missing in $[0..B)$ or $\ge B$ and can be handled via a small fallback structure.
\item For a heavy node, maintain a tree over presences to get the first zero in $O(\log q)$; update it when a child value changes.
\item Upon insertion, update $x$ and propagate to ancestors, using the appropriate per-node structure. Stop as soon as a node's MEX is unchanged.
\end{algosteps}
\OPTIMALITY{With $O(q/B)$ heavy nodes and $O(B)$ light recomputation, the amortized per-update cost is $O(B + \log q)$; choosing $B \approx \sqrt{q}$ yields $O(\sqrt{q})$ amortized updates and total $O(q\sqrt{q})$, further optimizable with careful engineering to near-linear.}
\COMPLEXITY{Amortized:
\[
\begin{aligned}
T(q) &= O\bigl(q(\sqrt{q} + \log q)\bigr)\ \text{(sketch)}.
\end{aligned}
\]
Space is $O(q)$.}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# Note: This reference implementation uses the robust propagate-while-change method.
from typing import List, Tuple, Dict

def read_input(data: str) -> Tuple[int, List[int]]:
    it = iter(data.strip().split())
    try:
        q = int(next(it))
    except StopIteration:
        return 0, []
    xs = [int(next(it)) for _ in range(q)]
    return q, xs

def solve_all(data: str) -> str:
    q, xs = read_input(data)
    if q == 0:
        return ""
    n = q + 1
    parent = [0] * (n + 2)
    g = [0] * (n + 2)
    freq: List[Dict[int, int]] = [dict() for _ in range(n + 2)]
    total_sum = 0
    parent[1] = 0
    g[1] = 0

    def mex_of(u: int) -> int:
        fu = freq[u]
        k = 0
        while fu.get(k, 0) > 0:
            k += 1
        return k

    out_lines: List[str] = []
    for i, x in enumerate(xs, start=1):
        v = i + 1
        parent[v] = x
        g[v] = 0
        freq[v] = {}
        # new child with value 0 at x
        fx = freq[x]
        fx[0] = fx.get(0, 0) + 1

        # propagate along ancestors until stabilization
        u = x
        while True:
            new_val = mex_of(u)
            if new_val == g[u]:
                break
            old_val = g[u]
            g[u] = new_val
            total_sum += (new_val - old_val)
            p = parent[u]
            if p == 0:
                break
            fp = freq[p]
            co = fp.get(old_val, 0)
            if co <= 1:
                if old_val in fp:
                    del fp[old_val]
            else:
                fp[old_val] = co - 1
            fp[new_val] = fp.get(new_val, 0) + 1
            u = p

        out_lines.append(str(total_sum))

    return "\n".join(out_lines)

def _mini_tests():
    # Exactly 3 asserts
    assert solve_all("1\n1\n").strip().split() == ["1"]
    assert solve_all("3\n1\n1\n2\n").strip().split() == ["1", "1", "3"]
    assert solve_all("5\n1\n2\n3\n4\n5\n").strip().split() == ["1", "1", "1", "1", "1"]

if __name__ == "__main__":
    import sys
    data = sys.stdin.read()
    if not data.strip():
        _mini_tests()
    else:
        sys.stdout.write(solve_all(data))
\end{minted}
\VALIDATION{Exactly three asserts cover: single insertion; a small tree with a chain and branch; a long chain where sums stabilize at $1$ for the first few steps.}
\RESULT{After each insertion, print the sum of node values where each node's value is the MEX of its children's values. Ties are not applicable; values are determined uniquely by the tree.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for tiny trees (star, chain, shallow branch), property check that the root's value is the MEX of its children's values after each operation, and consistency of the maintained sum with explicit recomputation on small $q$.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach A and B implementations on random tiny cases; both should match. For small $q$, cross-check by brute recomputation of all node values after each insertion.}
\LINE{EDGE-CASE GENERATOR}{Generate sequences like always attaching to root (star), always attaching to the last node (chain), alternating between two nodes, and random parents.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_star(q: int) -> str:
    return str(q) + "\n" + "\n".join(["1"] * q) + "\n"

def gen_chain(q: int) -> str:
    xs = [str(i) for i in range(1, q + 1)]
    return str(q) + "\n" + "\n".join(xs) + "\n"

def gen_alternate(q: int) -> str:
    xs = []
    last = 1
    for i in range(1, q + 1):
        xs.append(str(last))
        last = 2 if last == 1 else 1
        last = min(last, i)  # ensure valid parent
    return str(q) + "\n" + "\n".join(xs) + "\n"

def gen_random(q: int, seed: int = 0) -> str:
    rnd = random.Random(seed)
    xs = []
    for i in range(1, q + 1):
        xs.append(str(rnd.randint(1, i)))
    return str(q) + "\n" + "\n".join(xs) + "\n"

# Example usage:
if __name__ == "__main__":
    print(gen_star(5))
    print(gen_chain(5))
    print(gen_alternate(6))
    print(gen_random(6, seed=42))
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple, Dict

def read_input(data: str) -> Tuple[int, List[int]]:
    it = iter(data.strip().split())
    try:
        q = int(next(it))
    except StopIteration:
        return 0, []
    xs = [int(next(it)) for _ in range(q)]
    return q, xs

def solve_all(data: str) -> str:
    q, xs = read_input(data)
    if q == 0:
        return ""
    n = q + 1
    parent = [0] * (n + 2)
    g = [0] * (n + 2)
    freq: List[Dict[int, int]] = [dict() for _ in range(n + 2)]
    total_sum = 0
    parent[1] = 0
    g[1] = 0

    def mex_of(u: int) -> int:
        fu = freq[u]
        k = 0
        while fu.get(k, 0) > 0:
            k += 1
        return k

    out_lines: List[str] = []
    for i, x in enumerate(xs, start=1):
        v = i + 1
        parent[v] = x
        g[v] = 0
        freq[v] = {}
        fx = freq[x]
        fx[0] = fx.get(0, 0) + 1

        u = x
        while True:
            new_val = mex_of(u)
            if new_val == g[u]:
                break
            old_val = g[u]
            g[u] = new_val
            total_sum += (new_val - old_val)
            p = parent[u]
            if p == 0:
                break
            fp = freq[p]
            co = fp.get(old_val, 0)
            if co <= 1:
                if old_val in fp:
                    del fp[old_val]
            else:
                fp[old_val] = co - 1
            fp[new_val] = fp.get(new_val, 0) + 1
            u = p

        out_lines.append(str(total_sum))

    return "\n".join(out_lines)

def _tests():
    assert solve_all("1\n1\n").strip().split() == ["1"]
    assert solve_all("3\n1\n1\n2\n").strip().split() == ["1", "1", "3"]
    assert solve_all("4\n1\n1\n1\n1\n").strip().split() == ["1", "1", "1", "1"]

if __name__ == "__main__":
    import sys
    data = sys.stdin.read()
    if not data.strip():
        _tests()
    else:
        sys.stdout.write(solve_all(data))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain child-value counts per node; recompute MEX and propagate up until stabilizing; keep a running sum of all node values.}
\WHY{Dynamic MEX-on-children appears in advanced game/Grundy tree problems and requires careful incremental maintenance and propagation logic.}
\CHECKLIST{
- Update the parent node's frequency map when a child's value changes.
- Recompute MEX as the first missing non-negative integer.
- Stop propagation as soon as a node's value does not change.
- Keep the global sum updated by exact per-node deltas.
- Initialize new node's value to $0$ (leaf).}
\EDGECASES{
- Single node (root only).
- All insertions under root (star).
- All insertions forming a chain (deep tree).
- Alternating between two ancestors.
- When a child's value increases past the current MEX, causing a decrease at the parent.
- Many children sharing the same value (high multiplicities).}
\PITFALLS{
- Forgetting to decrement the parent's count of the old child value when a child changes.
- Leaving zero-count entries in maps and miscomputing MEX.
- Not stopping propagation upon stabilization (infinite loop).
- Assuming monotonicity of node values (parents can decrease).
- Off-by-one in node indices ($i+1$ is the new node).
- Mismanaging the running sum (must add the delta at every change).}
\FAILMODES{Naive recomputation of the entire tree after each insertion is $O(n^2)$ and too slow. Improper propagation or stale counts cause incorrect MEX and sums. The presented approach updates only affected ancestors and maintains exact counts.}
\ELI{Each node stores which child values it has. When a new leaf arrives, only ancestors of its parent might need to change their value. We adjust those nodes one by one, fixing our counts and the running sum, and stop once nothing changes.}
\NotePages{3}

\end{document}