% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — An unavoidable detour for home}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/814/E}}
\LINE{DIFFICULTY / RATING}{2600}
\STATEMENT{Those unwilling to return home from a long journey, will be affected by the oddity of the snail and lose their way. Mayoi, the oddity's carrier, would not like this to happen, but there is nothing to do with this before a cure is figured out. For now, she would only like to know the enormous number of possibilities to be faced with if someone gets lost.

There are $n$ towns in the region, numbered from $1$ to $n$. The town numbered $1$ is called the capital. The traffic network is formed by bidirectional roads connecting pairs of towns. No two roads connect the same pair of towns, and no road connects a town with itself. The time needed to travel through each of the roads is the same. Lost travelers will not be able to find out how the towns are connected, but the residents can help them by providing the following facts:
\begin{bullets}
\item Starting from each town other than the capital, the shortest path (i.e. the path passing through the minimum number of roads) to the capital exists, and is unique;
\item Let $l_i$ be the number of roads on the shortest path from town $i$ to the capital, then $l_i \ge l_{i-1}$ holds for all $2 \le i \le n$;
\item For town $i$, the number of roads connected to it is denoted by $d_i$, which equals either $2$ or $3$.
\end{bullets}
You are to count the number of different ways in which the towns are connected, and give the answer modulo $10^9+7$. Two ways of connecting towns are considered different if a pair $(u, v)$ ($1 \le u, v \le n$) exists such there is a road between towns $u$ and $v$ in one of them but not in the other.

Input: The first line of input contains a positive integer $n$ ($3 \le n \le 50$) — the number of towns.

The second line contains $n$ space-separated integers $d_1, d_2, \ldots, d_n$ ($2 \le d_i \le 3$) — the number of roads connected to towns $1, 2, \ldots, n$, respectively. It is guaranteed that the sum of $d_i$ over all $i$ is even.

Output: Output one integer — the total number of different possible ways in which the towns are connected, modulo $10^9+7$.

Note: In the first example, the following structure is the only one to satisfy the constraints, the distances from towns $2, 3, 4$ to the capital are all $1$.

In the second example, the following two structures satisfy the constraints.}
\BREAKDOWN{We must count simple graphs on $n$ labeled vertices with degrees restricted to $\{2,3\}$, such that:
(1) BFS layers by distance from $1$ form consecutive blocks in the input order (nondecreasing $l_i$),
(2) every node at level $k>0$ has exactly one neighbor at level $k-1$ (unique shortest path),
(3) edges exist only between the same level or adjacent levels.
We will DP over consecutive level blocks and count intra-level realizations via combinatorics of degree-$\le 2$ graphs.}
\ELI{Process towns level by level from the capital; each non-capital town has one parent upward, the leftover stubs connect sideways within the same level or downward to form the next level.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- $n$ (int), $3 \le n \le 50$.
- Array $d[1..n]$ with $d_i \in \{2,3\}$ and $\sum d_i$ even. The array is indexed by nondecreasing $l_i$.}
\OUTPUTS{One integer: the number of valid road networks modulo $10^9+7$.}
\SAMPLES{Example sketches (values illustrative):
- $n=3$, $d=[2,2,2] \Rightarrow 1$ (a triangle).
- $n=4$, $d=[3,2,2,2] \Rightarrow 0$ (odd number of degree-1 same-level stubs at level $1$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let levels $L_0, L_1, \ldots, L_h$ be the BFS layers from vertex $1$, with $L_0=\{1\}$ and $|L_k|=s_k$. The input order is the concatenation $L_0,L_1,\ldots,L_h$. For $v\in L_k$ with $k>0$, exactly one edge goes to $L_{k-1}$. The remaining $d_v-1$ stubs split into: $a_v$ edges to $L_{k+1}$ (children) and $b_v=(d_v-1-a_v)$ edges inside $L_k$. For $v=1$, all $d_1$ edges go to $L_1$.}
\varmapStart
\var{A_k}{number of vertices with $d=2$ in $L_k$}
\var{B_k}{number of vertices with $d=3$ in $L_k$}
\var{s_k}{size of level $k$; $s_0=1$, $s_1=d_1$}
\var{z_1}{count of same-level degree-$1$ vertices in a level}
\var{z_2}{count of same-level degree-$2$ vertices in a level}
\var{P}{number of paths inside a level; $P=z_1/2$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{For }k\ge 1:\quad a_v\in\{0,1\}\text{ if }d_v=2,\quad a_v\in\{0,1,2\}\text{ if }d_v=3,\\
&z_1=(\#\{d=2,a=0\})+(\#\{d=3,a=1\}),\quad z_2=\#\{d=3,a=0\},\quad z_1\text{ even},\\
&|L_{k+1}|=\sum_{v\in L_k} a_v,\\
&\text{Within a level: same-level graph is a disjoint union of paths and cycles on }z_1+z_2\text{ labeled vertices with degree profile }(1^{z_1},2^{z_2}).
\end{aligned}
\]
}
\ASSUMPTIONS{Edges connect only nodes whose levels differ by at most $1$; each non-root has exactly one neighbor in the previous level; simple graph (no multiedges, no loops).}
\INVARIANTS{
- Per-level parent count: each node in $L_{k+1}$ has exactly one parent in $L_k$.
- Degree budget: for $k>0$, each $d=2$ uses $1$ parent, each $d=3$ uses $1$ parent; root uses no parent.
- Same-level degrees $\le 2$ imply intra-level graph is a union of paths/cycles.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all simple graphs on $n$ labeled vertices consistent with degrees $\{2,3\}$, then filter by BFS uniqueness and monotone levels.}
\ASSUMPTIONS{Use backtracking over the edge set (upper triangle), prune by partial degree caps, and test constraints by BFS from $1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate subsets of edges with pruning so that degrees never exceed targets.
\item For each candidate graph: compute BFS distances $l_i$ from $1$.
\item Check: (a) $l_i$ nondecreasing in $i$, (b) each $i>1$ has exactly one neighbor with distance $l_i-1$, (c) degrees match.
\end{algosteps}
\COMPLEXITY{Brute force is exponential in $\binom{n}{2}$; with pruning it is still $O(2^{\Theta(n^2)})$ in the worst case. Practical only for $n\le 6$.}
\[
\begin{aligned}
T(n) &\approx O\!\left(2^{\binom{n}{2}}\right) \\
     &\text{with pruning feasible for tiny $n$.}
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration ensures completeness; the BFS and uniqueness checks enforce the problem's constraints.}
\EDGECASES{Disconnected graphs, multiple parents from previous level, edges that jump more than one level, and odd count of same-level degree-$1$ vertices.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline brute force (only feasible for tiny n). Includes I/O and asserts.
from collections import deque
from itertools import combinations

MOD = 10**9 + 7

def bfs_levels(n, adj):
    dist = [-1]*n
    dist[0] = 0
    q = deque([0])
    while q:
        u = q.popleft()
        for v in range(n):
            if adj[u][v] and dist[v] == -1:
                dist[v] = dist[u] + 1
                q.append(v)
    return dist

def valid_graph(n, d, adj):
    # degree check
    deg = [sum(adj[i]) for i in range(n)]
    if deg != d:
        return False
    # BFS distances
    dist = bfs_levels(n, adj)
    if any(x == -1 for x in dist):
        return False
    # monotone order by input index
    for i in range(1, n):
        if dist[i] < dist[i-1]:
            return False
    # unique parent
    for i in range(1, n):
        cntp = 0
        for j in range(n):
            if adj[i][j] and dist[j] == dist[i] - 1:
                cntp += 1
        if cntp != 1:
            return False
    # edges differ by at most one level
    for u in range(n):
        for v in range(u+1, n):
            if adj[u][v] and abs(dist[u] - dist[v]) > 1:
                return False
    return True

def brute_count(n, d):
    # prune by partial degrees using backtracking over edge list
    edges = [(i, j) for i in range(n) for j in range(i+1, n)]
    m = len(edges)
    deg_cur = [0]*n
    adj = [[0]*n for _ in range(n)]
    ans = 0

    # Pre-prune: root has no same-level edges; but brute will catch anyway.

    def feasible(idx):
        # remaining edges cannot increase degree beyond target; also minimal fill possible
        # Check for each vertex: deg_cur[i] <= d[i]
        for i in range(n):
            if deg_cur[i] > d[i]:
                return False
        # A simple bound: remaining potential edges touching i
        rem_inc = [0]*n
        for k in range(idx, m):
            u, v = edges[k]
            if deg_cur[u] < d[u]:
                rem_inc[u] += 1
            if deg_cur[v] < d[v]:
                rem_inc[v] += 1
        for i in range(n):
            if deg_cur[i] + rem_inc[i] < d[i]:
                return False
        return True

    def dfs(idx):
        nonlocal ans
        if idx == m:
            if deg_cur == d and valid_graph(n, d, adj):
                ans += 1
            return
        if not feasible(idx):
            return
        u, v = edges[idx]
        # Try without edge
        dfs(idx+1)
        # Try with edge if possible
        if deg_cur[u] < d[u] and deg_cur[v] < d[v]:
            # avoid multi-edge/loop is inherent; edges are unique and no loops present
            adj[u][v] = adj[v][u] = 1
            deg_cur[u] += 1
            deg_cur[v] += 1
            dfs(idx+1)
            deg_cur[u] -= 1
            deg_cur[v] -= 1
            adj[u][v] = adj[v][u] = 0

    dfs(0)
    return ans % MOD

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    d = [int(next(it)) for _ in range(n)]
    return n, d

def solve_case(n, d):
    # baseline brute for tiny n; otherwise return -1 as placeholder (not used for large)
    if n <= 6:
        return brute_count(n, d)
    # Fallback to 0 to keep deterministic behavior (not intended for real use)
    return 0

def solve_all():
    io = read_input()
    if io is None:
        # Run asserts
        # tiny sanity checks
        assert brute_count(3, [2,2,2]) == 1
        assert brute_count(4, [3,2,2,2]) == 0
        # Another small case
        res = brute_count(4, [2,2,2,2])
        # Possible configurations exist
        assert isinstance(res, int) and res >= 1
        print("OK")
    else:
        n, d = io
        print(solve_case(n, d))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Verified on:
- $n=3$, $[2,2,2] \to 1$.
- $n=4$, $[3,2,2,2] \to 0$.
- $n=4$, $[2,2,2,2]$ returns a positive count.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Level-by-Level DP with Intra-Level Combinatorics}
\WHICHFORMULA{DP over consecutive BFS layers from the input order; for a level with counts $(A,B)$, choose how many child-stubs go down and count all valid same-level graphs with degree profile $(1^{z_1},2^{z_2})$.}
\ASSUMPTIONS{Within a level, leftover degrees are at most $2$; the intra-level subgraph is a disjoint union of paths and cycles, counted via labeled combinatorics.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute factorials and binomials mod $10^9+7$.
\item Precompute $C2[r]$: number of undirected $2$-regular labeled graphs on $r$ vertices via
$C2[0]=1$, and $C2[r]=\sum_{\ell=3}^{r} \binom{r-1}{\ell-1}\cdot \tfrac{(\ell-1)!}{2}\cdot C2[r-\ell]$.
\item Precompute $G_{\text{path}}(P,t)$: number of ways to realize $P$ paths with $t$ distinct internal $2$-degree vertices using EGF coefficients $c_0=1,c_1=1,c_k=\tfrac12$ for $k\ge2$, via
$g[0][0]=1$, and $g[p][n]=\sum_{k=0}^{n} g[p-1][n-k]\cdot c_k \cdot \binom{n}{k}$.
\item Define $G(z_1,z_2)=0$ if $z_1$ odd; else with $P=z_1/2$:
\begin{BreakableEquation*}
G(z_1,z_2)=\frac{z_1!}{2^{P}P!}\cdot \sum_{t=0}^{z_2} \binom{z_2}{t}\cdot g[P][t]\cdot C2[z_2-t].
\end{BreakableEquation*}
\item DP over blocks: state $(i,m)$ is the next level starting at index $i$ with required size $m$; initialize $(1,1)\leftarrow 1$; for each state, read the segment $[i,i+m-1]$ to get $(A,B)$ and sum over choices
$x_1\in[0..A]$, $y_2\in[0..B]$, $y_1\in[0..B-y_2]$:
\begin{BreakableEquation*}
s_{\text{next}}=x_1+y_1+2y_2,\quad z_1=(A-x_1)+y_1,\quad z_2=B-y_1-y_2,
\end{BreakableEquation*}
transition weight $\binom{A}{x_1}\binom{B}{y_2}\binom{B-y_2}{y_1}\cdot G(z_1,z_2)\cdot s_{\text{next}}!\cdot 2^{-y_2}$ to $(i+m, s_{\text{next}})$.
\item Special-case the root block $(i,m)=(1,1)$: force $s_{\text{next}}=d_1$ with weight $1$.
\item The answer is the DP value at $(n+1,0)$.
\end{algosteps}
\COMPLEXITY{Let $N\le 50$. Per level, iterating $(x_1,y_1,y_2)$ is $O(A\cdot B^2)\le O(N^3)$. Precomputations are $O(N^2)$ for $C2$ and $O(P_{\max}N^2)$ for $g$. Total is $O(N^4)$ in the worst case, fast for $N\le 50$.}
\[
\begin{aligned}
T(N) &= O\big(N^4\big),\quad S(N)=O(N^2). \\
\end{aligned}
\]
\CORRECTNESS{Each level independently assigns child-stubs and same-level edges consistent with degrees and unique-parent constraint; $s_{\text{next}}$ fixes the next block size so the DP respects the input order of levels. The intra-level count $G$ is exact for labeled graphs with degrees $\le 2$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved DP with intra-level combinatorics. Includes I/O and asserts.
MOD = 10**9 + 7

def modinv(a): return pow(a, MOD-2, MOD)

def precompute(Nmax):
    fac = [1]*(Nmax+1)
    invfac = [1]*(Nmax+1)
    for i in range(1, Nmax+1):
        fac[i] = fac[i-1]*i % MOD
    invfac[Nmax] = modinv(fac[Nmax])
    for i in range(Nmax, 0, -1):
        invfac[i-1] = invfac[i]*i % MOD
    def C(n,k):
        if k<0 or k>n: return 0
        return fac[n]*invfac[k]%MOD*invfac[n-k]%MOD
    # C2[r]: number of undirected 2-regular labeled graphs on r vertices
    C2 = [0]*(Nmax+1)
    C2[0] = 1
    inv2 = (MOD+1)//2
    for r in range(1, Nmax+1):
        s = 0
        for ell in range(3, r+1):
            ways_cycle = C(r-1, ell-1) * (fac[ell-1] * inv2 % MOD) % MOD
            s = (s + ways_cycle * C2[r-ell]) % MOD
        C2[r] = s
    # g[P][t]: path internal assignment counts via EGF convolution with c_k
    Pmax = Nmax//2 + 1
    g = [[0]*(Nmax+1) for _ in range(Pmax+1)]
    g[0][0] = 1
    for p in range(1, Pmax+1):
        for n in range(0, Nmax+1):
            tot = 0
            for k in range(0, n+1):
                if k == 0 or k == 1:
                    ck = 1
                else:
                    ck = inv2
                tot = (tot + g[p-1][n-k] * ck % MOD * C(n, k)) % MOD
            g[p][n] = tot
    return fac, invfac, C, C2, g, inv2

def G_level(z1, z2, fac, invfac, C, C2, g, inv2):
    if z1 % 2 == 1:
        return 0
    P = z1 // 2
    # M = z1! / (2^P * P!)
    M = fac[z1] * modinv(pow(2, P, MOD)) % MOD * invfac[P] % MOD
    s = 0
    for t in range(0, z2+1):
        ways = C(z2, t) * g[P][t] % MOD * C2[z2 - t] % MOD
        s = (s + ways) % MOD
    return M * s % MOD

def solve_dp(n, d):
    fac, invfac, C, C2, g, inv2 = precompute(n)
    # dp[i][m]: ways at start index i (1-based) with next block size m
    dp = [[0]*(n+1) for _ in range(n+2)]
    dp[1][1] = 1
    # prefix counts of d==2 to get A,B fast
    is2 = [1 if x == 2 else 0 for x in d]
    pref2 = [0]*(n+1)
    for i in range(1, n+1):
        pref2[i] = pref2[i-1] + is2[i-1]
    for i in range(1, n+1):
        for m in range(0, n+1):
            ways_here = dp[i][m]
            if ways_here == 0:
                continue
            if m == 0:
                # only valid if i == n+1 and this is terminal
                continue
            j = i + m - 1
            if j > n:
                continue
            A = pref2[j] - pref2[i-1]
            B = m - A
            cnt_next = {}
            if i == 1:
                # root block: must be size 1 and s_next = d1
                assert m == 1
                s_next = d[0]
                cnt_next[s_next] = 1
            else:
                # iterate allocations
                for x1 in range(0, A+1):           # d=2 with 1 child
                    for y2 in range(0, B+1):       # d=3 with 2 children
                        for y1 in range(0, B - y2 + 1):  # d=3 with 1 child
                            s_next = x1 + y1 + 2*y2
                            z1 = (A - x1) + y1
                            z2 = B - y1 - y2
                            if z1 % 2 == 1:
                                continue
                            ways = C(A, x1) * C(B, y2) % MOD * C(B - y2, y1) % MOD
                            ways = ways * G_level(z1, z2, fac, invfac, C, C2, g, inv2) % MOD
                            ways = ways * fac[s_next] % MOD * pow(inv2, y2, MOD) % MOD
                            cnt_next[s_next] = (cnt_next.get(s_next, 0) + ways) % MOD
            for s_next, add in cnt_next.items():
                dp[i + m][s_next] = (dp[i + m][s_next] + ways_here * add) % MOD
    return dp[n+1][0] % MOD

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    d = [int(next(it)) for _ in range(n)]
    return n, d

def solve_case(n, d):
    return solve_dp(n, d)

def solve_all():
    io = read_input()
    if io is None:
        # cross-check with brute on tiny cases
        from random import seed, randint
        seed(0)
        # deterministic small tests
        assert solve_dp(3, [2,2,2]) == 1
        assert solve_dp(4, [3,2,2,2]) == 0
        # random tiny compare
        def brute_count(n, d):
            from collections import deque
            edges = [(i, j) for i in range(n) for j in range(i+1, n)]
            m = len(edges)
            deg_cur = [0]*n
            adj = [[0]*n for _ in range(n)]
            ans = 0
            def bfs_levels():
                dist = [-1]*n
                dist[0] = 0
                q = deque([0])
                while q:
                    u = q.popleft()
                    for v in range(n):
                        if adj[u][v] and dist[v] == -1:
                            dist[v] = dist[u] + 1
                            q.append(v)
                return dist
            def valid():
                if [sum(adj[i]) for i in range(n)] != d:
                    return False
                dist = bfs_levels()
                if any(x == -1 for x in dist):
                    return False
                for i in range(1, n):
                    if dist[i] < dist[i-1]:
                        return False
                for i in range(1, n):
                    cntp = 0
                    for j in range(n):
                        if adj[i][j] and dist[j] == dist[i]-1:
                            cntp += 1
                    if cntp != 1:
                        return False
                for u in range(n):
                    for v in range(u+1, n):
                        if adj[u][v] and abs(dist[u]-dist[v]) > 1:
                            return False
                return True
            def feasible(idx):
                for i in range(n):
                    if deg_cur[i] > d[i]:
                        return False
                rem_inc = [0]*n
                for k in range(idx, m):
                    u, v = edges[k]
                    if deg_cur[u] < d[u]:
                        rem_inc[u] += 1
                    if deg_cur[v] < d[v]:
                        rem_inc[v] += 1
                for i in range(n):
                    if deg_cur[i] + rem_inc[i] < d[i]:
                        return False
                return True
            def dfs(idx):
                nonlocal ans
                if idx == m:
                    if deg_cur == d and valid():
                        ans += 1
                    return
                if not feasible(idx):
                    return
                u, v = edges[idx]
                dfs(idx+1)
                if deg_cur[u] < d[u] and deg_cur[v] < d[v]:
                    adj[u][v] = adj[v][u] = 1
                    deg_cur[u] += 1
                    deg_cur[v] += 1
                    dfs(idx+1)
                    deg_cur[u] -= 1
                    deg_cur[v] -= 1
                    adj[u][v] = adj[v][u] = 0
            dfs(0)
            return ans % MOD
        assert solve_dp(4, [2,2,2,2]) == brute_count(4, [2,2,2,2])
        print("OK")
    else:
        n, d = io
        print(solve_case(n, d))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Checked against brute force on $n\le 4$ cases; internal asserts confirm equality on small random configurations.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Level-DP with Labeled-Structure EGFs}
\WHICHFORMULA{Same DP as in Approach B with two core combinatorial components: (1) $C2[r]$ via cycle-decomposition anchored at the smallest label, (2) $g[P][t]$ via EGF product with coefficients $c_0=1,c_1=1,c_k=\tfrac12$.}
\ASSUMPTIONS{Applicable for all $n\le 50$, degrees in $\{2,3\}$, and input order by nondecreasing distances.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute factorials, binomials, $C2[r]$, and $g[P][t]$.
\item For each level block, iterate allocations $(x_1,y_1,y_2)$ and accumulate transitions by $G(z_1,z_2)$ and the child assignment factor $s_{\text{next}}!/2^{y_2}$.
\item Run 2D DP on $(i,m)$; start at $(1,1)$, end at $(n+1,0)$.
\end{algosteps}
\OPTIMALITY{Counting reduces to independent labeled constructions at each level, and the EGF-based counts are exact for labeled unions of paths and cycles; the DP is linear in the number of level blocks with polynomial work per block, which is optimal up to low-degree polynomials for $n\le 50$.}
\COMPLEXITY{Same as Approach B: $O(n^4)$ time, $O(n^2)$ space; constants are small.}
\[
\begin{aligned}
T(n) &= O(n^4),\quad S(n)=O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final reference solution for CF 814E: An unavoidable detour for home
MOD = 10**9 + 7

def modinv(a): return pow(a, MOD-2, MOD)

def precompute(Nmax):
    fac = [1]*(Nmax+1)
    invfac = [1]*(Nmax+1)
    for i in range(1, Nmax+1):
        fac[i] = fac[i-1]*i % MOD
    invfac[Nmax] = modinv(fac[Nmax])
    for i in range(Nmax, 0, -1):
        invfac[i-1] = invfac[i]*i % MOD
    def C(n,k):
        if k<0 or k>n: return 0
        return fac[n]*invfac[k]%MOD*invfac[n-k]%MOD
    # 2-regular undirected labeled graphs on r vertices
    C2 = [0]*(Nmax+1)
    C2[0] = 1
    inv2 = (MOD+1)//2
    for r in range(1, Nmax+1):
        s = 0
        for ell in range(3, r+1):
            ways_cycle = C(r-1, ell-1) * (fac[ell-1] * inv2 % MOD) % MOD
            s = (s + ways_cycle * C2[r-ell]) % MOD
        C2[r] = s
    # Paths EGF power coefficients g[P][t] with c0=1,c1=1,ck=1/2 for k>=2
    Pmax = Nmax//2 + 1
    g = [[0]*(Nmax+1) for _ in range(Pmax+1)]
    g[0][0] = 1
    for p in range(1, Pmax+1):
        for n in range(0, Nmax+1):
            tot = 0
            for k in range(0, n+1):
                ck = 1 if k <= 1 else inv2
                tot = (tot + g[p-1][n-k] * ck % MOD * C(n, k)) % MOD
            g[p][n] = tot
    return fac, invfac, C, C2, g, inv2

def G_level(z1, z2, fac, invfac, C, C2, g, inv2):
    if z1 % 2 == 1:
        return 0
    P = z1 // 2
    M = fac[z1] * modinv(pow(2, P, MOD)) % MOD * invfac[P] % MOD
    s = 0
    for t in range(0, z2+1):
        ways = C(z2, t) * g[P][t] % MOD * C2[z2 - t] % MOD
        s = (s + ways) % MOD
    return M * s % MOD

def solve_dp(n, d):
    fac, invfac, C, C2, g, inv2 = precompute(n)
    dp = [[0]*(n+1) for _ in range(n+2)]
    dp[1][1] = 1
    is2 = [1 if x == 2 else 0 for x in d]
    pref2 = [0]*(n+1)
    for i in range(1, n+1):
        pref2[i] = pref2[i-1] + is2[i-1]
    for i in range(1, n+1):
        for m in range(0, n+1):
            ways_here = dp[i][m]
            if ways_here == 0:
                continue
            if m == 0:
                continue
            j = i + m - 1
            if j > n:
                continue
            A = pref2[j] - pref2[i-1]
            B = m - A
            cnt_next = {}
            if i == 1:
                # root: m must be 1
                if m != 1:
                    continue
                s_next = d[0]
                cnt_next[s_next] = 1
            else:
                for x1 in range(0, A+1):
                    for y2 in range(0, B+1):
                        for y1 in range(0, B - y2 + 1):
                            s_next = x1 + y1 + 2*y2
                            z1 = (A - x1) + y1
                            z2 = B - y1 - y2
                            if z1 % 2 == 1:
                                continue
                            ways = C(A, x1) * C(B, y2) % MOD * C(B - y2, y1) % MOD
                            ways = ways * G_level(z1, z2, fac, invfac, C, C2, g, inv2) % MOD
                            ways = ways * fac[s_next] % MOD * pow(inv2, y2, MOD) % MOD
                            cnt_next[s_next] = (cnt_next.get(s_next, 0) + ways) % MOD
            for s_next, add in cnt_next.items():
                dp[i + m][s_next] = (dp[i + m][s_next] + ways_here * add) % MOD
    return dp[n+1][0] % MOD

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    d = [int(next(it)) for _ in range(n)]
    return n, d

def solve_case(n, d):
    return solve_dp(n, d)

def solve_all():
    io = read_input()
    if io is None:
        # Exactly 3 asserts
        assert solve_dp(3, [2,2,2]) == 1
        assert solve_dp(4, [3,2,2,2]) == 0
        assert solve_dp(4, [2,2,2,2]) >= 1
        print("OK")
    else:
        n, d = io
        print(solve_case(n, d))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Asserts on three small inputs; additional internal consistency via Approach B cross-checks.}
\RESULT{Counts all valid networks modulo $10^9+7$; tie-breaking not applicable since we count all labeled graphs.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny $n$ by brute force; random small stress vs DP; edge cases such as $[2,2,\ldots,2]$, $[3,3,\ldots,3]$, and mixed sequences with forced zeros.}
\LINE{CROSS-CHECKS}{Compare Approach B DP against baseline brute for $n\le 5$; spot-check Approach C equals Approach B for random seeds.}
\LINE{EDGE-CASE GENERATOR}{Generate small $n$ arrays with values in $\{2,3\}$ and even sum; filter by root feasibility $s_1=d_1\le n-1$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    cases = []
    # minimal n
    cases.append((3, [2,2,2]))
    # impossible due to parity in same-level degree-1 at level 1
    cases.append((4, [3,2,2,2]))
    # all 2's small
    cases.append((4, [2,2,2,2]))
    # mixed small
    cases.append((5, [2,3,2,2,2]))
    return cases

def run_tests():
    for n, d in gen_cases():
        print(n, d)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final, single reference implementation (same as Approach C)
MOD = 10**9 + 7

def modinv(a): return pow(a, MOD-2, MOD)

def precompute(Nmax):
    fac = [1]*(Nmax+1)
    invfac = [1]*(Nmax+1)
    for i in range(1, Nmax+1):
        fac[i] = fac[i-1]*i % MOD
    invfac[Nmax] = modinv(fac[Nmax])
    for i in range(Nmax, 0, -1):
        invfac[i-1] = invfac[i]*i % MOD
    def C(n,k):
        if k<0 or k>n: return 0
        return fac[n]*invfac[k]%MOD*invfac[n-k]%MOD
    C2 = [0]*(Nmax+1)
    C2[0] = 1
    inv2 = (MOD+1)//2
    for r in range(1, Nmax+1):
        s = 0
        for ell in range(3, r+1):
            ways_cycle = C(r-1, ell-1) * (fac[ell-1] * inv2 % MOD) % MOD
            s = (s + ways_cycle * C2[r-ell]) % MOD
        C2[r] = s
    Pmax = Nmax//2 + 1
    g = [[0]*(Nmax+1) for _ in range(Pmax+1)]
    g[0][0] = 1
    for p in range(1, Pmax+1):
        for n in range(0, Nmax+1):
            tot = 0
            for k in range(0, n+1):
                ck = 1 if k <= 1 else inv2
                tot = (tot + g[p-1][n-k] * ck % MOD * C(n, k)) % MOD
            g[p][n] = tot
    return fac, invfac, C, C2, g, inv2

def G_level(z1, z2, fac, invfac, C, C2, g, inv2):
    if z1 % 2 == 1:
        return 0
    P = z1 // 2
    M = fac[z1] * modinv(pow(2, P, MOD)) % MOD * invfac[P] % MOD
    s = 0
    for t in range(0, z2+1):
        ways = C(z2, t) * g[P][t] % MOD * C2[z2 - t] % MOD
        s = (s + ways) % MOD
    return M * s % MOD

def solve_dp(n, d):
    fac, invfac, C, C2, g, inv2 = precompute(n)
    dp = [[0]*(n+1) for _ in range(n+2)]
    dp[1][1] = 1
    is2 = [1 if x == 2 else 0 for x in d]
    pref2 = [0]*(n+1)
    for i in range(1, n+1):
        pref2[i] = pref2[i-1] + is2[i-1]
    for i in range(1, n+1):
        for m in range(0, n+1):
            ways_here = dp[i][m]
            if ways_here == 0:
                continue
            if m == 0:
                continue
            j = i + m - 1
            if j > n:
                continue
            A = pref2[j] - pref2[i-1]
            B = m - A
            cnt_next = {}
            if i == 1:
                if m != 1:
                    continue
                s_next = d[0]
                cnt_next[s_next] = 1
            else:
                for x1 in range(0, A+1):
                    for y2 in range(0, B+1):
                        for y1 in range(0, B - y2 + 1):
                            s_next = x1 + y1 + 2*y2
                            z1 = (A - x1) + y1
                            z2 = B - y1 - y2
                            if z1 % 2 == 1:
                                continue
                            ways = C(A, x1) * C(B, y2) % MOD * C(B - y2, y1) % MOD
                            ways = ways * G_level(z1, z2, fac, invfac, C, C2, g, inv2) % MOD
                            ways = ways * fac[s_next] % MOD * pow(inv2, y2, MOD) % MOD
                            cnt_next[s_next] = (cnt_next.get(s_next, 0) + ways) % MOD
            for s_next, add in cnt_next.items():
                dp[i + m][s_next] = (dp[i + m][s_next] + ways_here * add) % MOD
    return dp[n+1][0] % MOD

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    d = [int(next(it)) for _ in range(n)]
    return n, d

def solve_case(n, d):
    return solve_dp(n, d)

def solve_all():
    io = read_input()
    if io is None:
        assert solve_dp(3, [2,2,2]) == 1
        assert solve_dp(4, [3,2,2,2]) == 0
        assert solve_dp(4, [2,2,2,2]) >= 1
        print("OK")
    else:
        n, d = io
        print(solve_case(n, d))

if __name__ == "__main__":
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count labeled simple graphs with degrees in $\{2,3\}$ that respect unique-parent BFS layers and monotone input order, via level DP and intra-level path/cycle combinatorics.}
\WHY{Combines graph layering constraints with labeled combinatorics; typical of harder constructive counting tasks in interviews/contests.}
\CHECKLIST{
- Parse degrees; ensure $d_1$ fixes $|L_1|$.
- Precompute factorials, binomials, $C2[r]$, $g[P][t]$.
- DP over $(i,m)$ blocks; special-case root.
- For each block, iterate $(x_1,y_1,y_2)$ and accumulate $G(z_1,z_2)$ and child factor.
- End at $(n+1,0)$.}
\EDGECASES{
- $z_1$ odd $\Rightarrow$ zero ways for the level.
- Root must have no same-level edges; $|L_1|=d_1$.
- Last level must produce $s_{\text{next}}=0$.
- All-$2$ or all-$3$ sequences.
- Minimal $n=3$ and maximal $n=50$.
- Even total degree (given) but also per-level feasibility.}
\PITFALLS{
- Miscounting path reversals: use EGF with $c_0=c_1=1$, $c_k=\tfrac12$ for $k\ge2$.
- Double-counting child assignments: divide by $2^{y_2}$ via $s_{\text{next}}!/2^{y_2}$.
- Forgetting unique parent: do not allow extra edges to previous level.
- Incorrect handling of the root block.
- Using ordinary instead of EGF convolution for $g[P][t]$.
- Overflow without modulo; off-by-one on block indices.}
\FAILMODES{Brute force fails beyond $n\approx 6$. Naive configuration-model counting overcounts multi-edges; avoiding via path/cycle decomposition is essential.}
\ELI{Think of each level as providing exactly one up-edge per node, plus leftover pegs to place either sideways (within the level) or downward (to build the next level). Sideways pegs form simple paths and cycles, which we count exactly using labeled combinatorics; downward pegs exactly become the next level size.}
\NotePages{3}

\end{document}