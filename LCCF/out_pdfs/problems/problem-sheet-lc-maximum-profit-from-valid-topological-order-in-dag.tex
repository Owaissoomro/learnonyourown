% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximum Profit from Valid Topological Order in DAG}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximum-profit-from-valid-topological-order-in-dag/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a \textbf{Directed Acyclic Graph (DAG)} with $n$ nodes labeled from $0$ to $n - 1$, represented by a 2D array \texttt{edges}, where \texttt{edges[i] = [u\_i, v\_i]} indicates a directed edge from node $u\_i$ to $v\_i$. Each node has an associated \textbf{score} given in an array \texttt{score}, where \texttt{score[i]} represents the score of node $i$.\\
You must process the nodes in a \textbf{valid topological order}. Each node is assigned a \textbf{1-based position} in the processing order.\\
The \textbf{profit} is calculated by summing up the product of each node's score and its position in the ordering.\\
Return the \textbf{maximum} possible profit achievable with an optimal topological order.\\
A \textbf{topological order} of a DAG is a linear ordering of its nodes such that for every directed edge $u \to v$, node $u$ comes before $v$ in the ordering.\\[4pt]
\textbf{Example 1:}\\
\textbf{Input:} \texttt{n = 2}, \texttt{edges = [[0,1]]}, \texttt{score = [2,3]}\\
\textbf{Output:} \texttt{8}\\
\textbf{Explanation:} Node $1$ depends on node $0$, so a valid order is \texttt{[0, 1]}.\\
Node $0$: position $1$, score $2$, profit $2 \times 1 = 2$.\\
Node $1$: position $2$, score $3$, profit $3 \times 2 = 6$.\\
Total $= 2 + 6 = 8$.\\[4pt]
\textbf{Example 2:}\\
\textbf{Input:} \texttt{n = 3}, \texttt{edges = [[0,1],[0,2]]}, \texttt{score = [1,6,3]}\\
\textbf{Output:} \texttt{25}\\
\textbf{Explanation:} Nodes $1$ and $2$ depend on node $0$, so one optimal valid order is \texttt{[0, 2, 1]}.\\
Node $0$: position $1$, score $1$, profit $1 \times 1 = 1$.\\
Node $2$: position $2$, score $3$, profit $3 \times 2 = 6$.\\
Node $1$: position $3$, score $6$, profit $6 \times 3 = 18$.\\
Total $= 1 + 6 + 18 = 25$.\\[4pt]
\textbf{Constraints:}
\begin{itemize}
\item $1 \le n = \texttt{score.length} \le 22$
\item $1 \le \texttt{score[i]} \le 10^5$
\item $0 \le \texttt{edges.length} \le n (n - 1) / 2$
\item \texttt{edges[i] == [u\_i, v\_i]} denotes a directed edge from $u\_i$ to $v\_i$
\item $0 \le u\_i, v\_i < n$, and $u\_i \ne v\_i$
\item The input graph is guaranteed to be a DAG
\item There are no duplicate edges
\end{itemize}}
\BREAKDOWN{We must choose a linear extension (topological order) of the partial order defined by the DAG to maximize $\sum \texttt{score}[v] \cdot \text{position}(v)$. Intuitively, higher scores should be placed later when possible, but precedence constraints restrict feasible permutations. With $n \le 22$, an exponential-time dynamic programming over subsets is viable.}
\ELI{Place low-score nodes earlier and high-score nodes later, as allowed by the DAG; use bitmask DP to find the exact optimum.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Three inputs:
\begin{itemize}
\item \texttt{n} (int): number of nodes, $1 \le n \le 22$.
\item \texttt{edges} (List of pairs): each pair \texttt{[u, v]} is a directed edge from $u$ to $v$; the graph is a DAG.
\item \texttt{score} (List[int]): node scores; length $n$; $1 \le \texttt{score[i]} \le 10^5$.
\end{itemize}}
\OUTPUTS{Single integer: the maximum profit $\sum_{i=1}^{n} \texttt{score}[v\_i] \cdot i$ over all valid topological orders $(v\_1,\ldots,v\_n)$.}
\SAMPLES{Example A: \\
Input: \texttt{n=2}, \texttt{edges=[[0,1]]}, \texttt{score=[2,3]} $\to$ Output: \texttt{8}.\\
Example B: \\
Input: \texttt{n=3}, \texttt{edges=[[0,1],[0,2]]}, \texttt{score=[1,6,3]} $\to$ Output: \texttt{25}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a DAG with $|V|=n$ and scores $s:V\to\mathbb{Z}_{>0}$. A topological order is a bijection $\pi:V\to\{1,\ldots,n\}$ such that $(u,v)\in E \implies \pi(u) < \pi(v)$. The objective is to maximize:
\[
\text{profit}(\pi) = \sum_{v\in V} s(v)\cdot \pi(v).
\]}
\varmapStart
\var{n}{number of nodes}
\var{E}{set of directed edges $(u,v)$}
\var{s(v)}{score of node $v$}
\var{\pi(v)}{1-based position of node $v$ in the order}
\var{\text{pred}(v)}{set of predecessors of $v$}
\var{\text{mask}}{bitmask of already placed nodes}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{maximize } \sum_{v\in V} s(v)\cdot \pi(v) \\
&\text{subject to } \pi:V\to \{1,\ldots,n\}\text{ is a bijection, and } \forall (u,v)\in E:\ \pi(u)<\pi(v).
\end{aligned}
\]
}
\ASSUMPTIONS{Nodes are labeled $0..n-1$. Graph is a DAG (no cycles), no parallel edges, no self-loops.}
\INVARIANTS{
\begin{itemize}
\item Feasibility: At any partial order state, the available set is exactly nodes whose predecessors are already placed.
\item Monotonicity: Adding a node increases the position counter by one; profit accumulates additively.
\item Optimal substructure: The best completion after a prefix depends only on the set of placed nodes (mask), not their internal order.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all topological orders via backtracking (Kahn-style choice among zero in-degree nodes) and compute $\sum s(v)\cdot \text{position}(v)$; keep the maximum.}
\ASSUMPTIONS{Only suitable for very small $n$ due to factorial growth in the number of linear extensions.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency lists and in-degrees.
\item Recursively choose any current zero in-degree node, place it next, update in-degrees, and continue.
\item Track running profit using current position; backtrack and maximize over all branches.
\end{algosteps}
\COMPLEXITY{In the worst case (no edges), the number of topological orders is $n!$, so time is $\Theta(n!)$, space $O(n)$ for recursion and bookkeeping.}
\[
\begin{aligned}
T(n) &= \sum_{k=0}^{n-1} \binom{n}{k} (n-k)! \quad (\text{branching among ready nodes}) \\
     &\approx \Theta(n!) \\
S(n) &= O(n + m)
\end{aligned}
\]
\CORRECTNESS{All and only valid topological orders are explored. The maximum profit seen is the optimal value by exhaustive search.}
\EDGECASES{No edges; chain; star; equal scores; single node.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Dict, Tuple

class Solution:
    def maxProfit(self, n: int, edges: List[List[int]], score: List[int]) -> int:
        # Build graph and indegrees
        g = [[] for _ in range(n)]
        indeg = [0] * n
        for u, v in edges:
            g[u].append(v)
            indeg[v] += 1

        best = 0
        placed = [False] * n

        # Initialize ready list
        ready = [i for i in range(n) if indeg[i] == 0]

        def dfs(pos: int, curr: int, ready_list: List[int]) -> None:
            nonlocal best
            if pos == n + 1:
                if curr > best:
                    best = curr
                return
            # Try each available node
            for i in range(len(ready_list)):
                u = ready_list[i]
                if placed[u]:
                    continue
                placed[u] = True
                # Update indegrees and build next ready
                changed = []
                for v in g[u]:
                    indeg[v] -= 1
                    changed.append(v)
                next_ready = ready_list[:i] + ready_list[i+1:]
                for v in changed:
                    if indeg[v] == 0:
                        next_ready.append(v)
                dfs(pos + 1, curr + score[u] * (pos), next_ready)
                # rollback
                for v in changed:
                    indeg[v] += 1
                placed[u] = False

        dfs(1, 0, ready)
        return best

if __name__ == "__main__":
    # Example 1
    n = 2
    edges = [[0, 1]]
    score = [2, 3]
    assert Solution().maxProfit(n, edges, score) == 8

    # Example 2
    n = 3
    edges = [[0, 1], [0, 2]]
    score = [1, 6, 3]
    assert Solution().maxProfit(n, edges, score) == 25

    # Additional tiny check
    n = 1
    edges = []
    score = [7]
    assert Solution().maxProfit(n, edges, score) == 7
\end{minted}
\VALIDATION{Validated on the two provided examples and a single-node case; keep inputs tiny when using brute force.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Bitmask DP with Memoization}
\WHICHFORMULA{Use DP over subsets: let \texttt{dp[mask]} be the maximum profit after placing exactly the nodes in \texttt{mask}. The next position is $k+1$ where $k=\text{popcount}(\texttt{mask})$. For any available node $v$ (all predecessors in \texttt{mask}), transition to \texttt{mask|1<<v} with gain $\texttt{score[v]}\cdot (k+1)$.}
\ASSUMPTIONS{Precompute predecessor mask for each node; use Python memoization to avoid re-computation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute \texttt{predMask[v]} as the bitmask of predecessors of node $v$.
\item Define recursive \texttt{f(mask)} returning the best profit from state \texttt{mask}.
\item For each node $v$ not in \texttt{mask} with \texttt{(predMask[v] \& \textasciitilde mask) == 0}, try placing $v$ next and maximize.
\end{algosteps}
\COMPLEXITY{This is $O(n\cdot 2^n)$ states/transitions and $O(2^n)$ memory in the worst case, which is feasible for $n \le 22$ in optimized languages; Python is acceptable with memoization for moderate $n$ and passes the provided samples.}
\[
\begin{aligned}
T(n) &\le \sum_{\text{mask}} (\text{ready\_count}(\text{mask})) \le n\cdot 2^{n-1}, \\
S(n) &= O(2^n).
\end{aligned}
\]
\CORRECTNESS{By optimal substructure: the profit of any completion depends only on \texttt{mask}. Feasible actions are exactly the available nodes, ensuring adherence to topological constraints. The DP takes the maximum over all feasible next choices, thus achieving the optimum.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from functools import lru_cache

class Solution:
    def maxProfit(self, n: int, edges: List[List[int]], score: List[int]) -> int:
        # predecessor mask for each node
        pred = [0] * n
        for u, v in edges:
            pred[v] |= 1 << u

        @lru_cache(maxsize=None)
        def f(mask: int) -> int:
            k = mask.bit_count()  # number placed
            if k == n:
                return 0
            pos = k + 1
            best = 0
            # Try each available node
            for v in range(n):
                if (mask >> v) & 1:
                    continue
                if (pred[v] & ~mask) == 0:
                    cand = score[v] * pos + f(mask | (1 << v))
                    if cand > best:
                        best = cand
            return best

        return f(0)

if __name__ == "__main__":
    # Example 1
    n = 2
    edges = [[0, 1]]
    score = [2, 3]
    assert Solution().maxProfit(n, edges, score) == 8

    # Example 2
    n = 3
    edges = [[0, 1], [0, 2]]
    score = [1, 6, 3]
    assert Solution().maxProfit(n, edges, score) == 25

    # Another small DAG
    n = 3
    edges = [[0, 2], [1, 2]]
    score = [5, 5, 1]
    # Best is [2, 0, 1] or [2, 1, 0]? Feasible must have 0,1 before 2. So order [0,1,2] gives 5*1+5*2+1*3=5+10+3=18
    # [1,0,2] gives 5*1+5*2+1*3=18 as well.
    assert Solution().maxProfit(n, edges, score) == 18
\end{minted}
\VALIDATION{Checks include the two examples and a small fork-shaped DAG where multiple optimal orders exist.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Layered Bitmask DP (Memory-Savvy), $O(n\cdot 2^n)$}
\WHICHFORMULA{Iteratively build states by layer (by number of placed nodes $k$): keep only states with exactly $k$ bits set, expand to $k+1$ using available nodes. This achieves the same DP but uses at most one layer in memory.}
\ASSUMPTIONS{Precompute predecessor masks. Enumerate ready nodes per state using bit operations; layer dictionaries merge via max.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute \texttt{predMask[v]} for each node.
\item Initialize \texttt{dp = \{0: 0\}} for $k=0$.
\item For $k=0$ to $n-1$: for each \texttt{mask} in current layer, compute ready nodes; relax transitions to \texttt{mask|(1<<v)} with gain \texttt{score[v]*(k+1)}; build \texttt{next\_dp} as max over duplicates.
\item Return the maximum in the final layer (it is a single state \texttt{mask=(1<<n)-1}).
\end{algosteps}
\OPTIMALITY{Same DP recurrence as Approach B with identical state space and transitions; no suboptimal pruning. The layer-by-layer reorganization preserves maxima and reduces peak memory.}
\COMPLEXITY{Time $O(n\cdot 2^n)$, Space $O\big(\max_k \binom{n}{k}\big)$ for the active layer.}
\[
\begin{aligned}
T(n) &\le \sum_{k=0}^{n-1} \binom{n}{k} \cdot (n-k) = n\cdot 2^{n-1}, \\
S(n) &= O\!\left(\binom{n}{\lfloor n/2\rfloor}\right).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Dict

class Solution:
    def maxProfit(self, n: int, edges: List[List[int]], score: List[int]) -> int:
        pred = [0] * n
        for u, v in edges:
            pred[v] |= 1 << u

        dp: Dict[int, int] = {0: 0}
        for k in range(n):
            pos = k + 1
            next_dp: Dict[int, int] = {}
            for mask, val in dp.items():
                # enumerate ready nodes
                for v in range(n):
                    if (mask >> v) & 1:
                        continue
                    if (pred[v] & ~mask) == 0:
                        nm = mask | (1 << v)
                        nv = val + score[v] * pos
                        if nm not in next_dp or nv > next_dp[nm]:
                            next_dp[nm] = nv
            dp = next_dp
        full = (1 << n) - 1
        return dp.get(full, 0)

if __name__ == "__main__":
    # Example 1
    n = 2
    edges = [[0, 1]]
    score = [2, 3]
    assert Solution().maxProfit(n, edges, score) == 8

    # Example 2
    n = 3
    edges = [[0, 1], [0, 2]]
    score = [1, 6, 3]
    assert Solution().maxProfit(n, edges, score) == 25

    # Random small DAG cross-check with expectations
    n = 4
    edges = [[0,1], [0,2], [1,3], [2,3]]
    score = [4, 10, 3, 7]
    # Feasible must be 0 before 1,2; 1,2 before 3.
    # Intuition: place 0 early, put higher of 1,2 later: e.g., [0,2,1,3] gives 4*1+3*2+10*3+7*4 = 4+6+30+28 = 68
    # Try [0,1,2,3]: 4+20+9+28=61; [0,2,1,3] seems higher.
    assert Solution().maxProfit(n, edges, score) == 68
\end{minted}
\VALIDATION{Exactly 3 asserts: the two given examples and a crafted diamond DAG where the best schedule places the larger middle node later.}
\RESULT{Return the maximum achievable profit value; if multiple orders attain the same maximum, any is acceptable since only the value is returned.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted DAGs: chains, antichains (no edges), stars, diamonds, and mixed. Property: for antichain, the optimal order is nondecreasing by score (lowest scores first). Cross-validate DP-based solutions for small $n$ against brute force.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C on $n \le 10$ random DAGs; ensure identical maximum values.}
\LINE{EDGE-CASE GENERATOR}{Generate DAGs by sampling a random permutation $\pi$ and adding edges $(u,v)$ only if $\pi(u)<\pi(v)$ to guarantee acyclicity; vary density from sparse to dense.}
\begin{minted}{python}
from typing import List, Tuple
import random

def gen_random_dag(n: int, p: float, seed: int = 0) -> List[List[int]]:
    rnd = random.Random(seed)
    order = list(range(n))
    rnd.shuffle(order)
    pos = {v: i for i, v in enumerate(order)}
    edges = []
    for u in range(n):
        for v in range(n):
            if u == v:
                continue
            if pos[u] < pos[v] and rnd.random() < p:
                edges.append([u, v])
    return edges

def brute_max(n: int, edges: List[List[int]], score: List[int]) -> int:
    # Baseline brute force for small n
    g = [[] for _ in range(n)]
    indeg = [0] * n
    for u, v in edges:
        g[u].append(v)
        indeg[v] += 1
    ready = [i for i in range(n) if indeg[i] == 0]
    placed = [False] * n
    best = 0
    def dfs(pos: int, val: int, ready_list: List[int]):
        nonlocal best
        if pos == n + 1:
            best = max(best, val)
            return
        for i, u in enumerate(ready_list):
            if placed[u]:
                continue
            placed[u] = True
            changed = []
            for w in g[u]:
                indeg[w] -= 1
                changed.append(w)
            nxt = ready_list[:i] + ready_list[i+1:]
            for w in changed:
                if indeg[w] == 0:
                    nxt.append(w)
            dfs(pos + 1, val + score[u] * pos, nxt)
            for w in changed:
                indeg[w] += 1
            placed[u] = False
    dfs(1, 0, ready)
    return best

def dp_layer(n: int, edges: List[List[int]], score: List[int]) -> int:
    pred = [0] * n
    for u, v in edges:
        pred[v] |= 1 << u
    dp = {0: 0}
    for k in range(n):
        pos = k + 1
        nd = {}
        for mask, val in dp.items():
            for v in range(n):
                if (mask >> v) & 1:
                    continue
                if (pred[v] & ~mask) == 0:
                    nm = mask | (1 << v)
                    nv = val + score[v] * pos
                    if nm not in nd or nv > nd[nm]:
                        nd[nm] = nv
        dp = nd
    return dp[(1 << n) - 1]

if __name__ == "__main__":
    # Cross-check on small random DAGs
    for n in range(1, 8):
        for density in [0.2, 0.5, 0.8]:
            for seed in range(5):
                edges = gen_random_dag(n, density, seed)
                score = [seed + i * 3 + 1 for i in range(n)]
                b = brute_max(n, edges, score)
                d = dp_layer(n, edges, score)
                assert b == d
    print("Cross-checks passed for n up to 7.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Dict

class Solution:
    def maxProfit(self, n: int, edges: List[List[int]], score: List[int]) -> int:
        # Precompute predecessors mask for each node
        pred = [0] * n
        for u, v in edges:
            pred[v] |= 1 << u

        # Layered DP: dp maps mask -> best profit after placing exactly those nodes
        dp: Dict[int, int] = {0: 0}
        for k in range(n):
            pos = k + 1  # next position to fill
            next_dp: Dict[int, int] = {}
            for mask, acc in dp.items():
                # Enumerate ready nodes
                for v in range(n):
                    if (mask >> v) & 1:
                        continue
                    if (pred[v] & ~mask) == 0:
                        nm = mask | (1 << v)
                        nv = acc + score[v] * pos
                        # Keep best for the same new mask
                        if nm not in next_dp or nv > next_dp[nm]:
                            next_dp[nm] = nv
            dp = next_dp

        full_mask = (1 << n) - 1
        return dp.get(full_mask, 0)

if __name__ == "__main__":
    # Provided examples
    assert Solution().maxProfit(2, [[0, 1]], [2, 3]) == 8
    assert Solution().maxProfit(3, [[0, 1], [0, 2]], [1, 6, 3]) == 25

    # Additional checks
    assert Solution().maxProfit(1, [], [7]) == 7
    # Diamond DAG
    n = 4
    edges = [[0, 1], [0, 2], [1, 3], [2, 3]]
    score = [4, 10, 3, 7]
    assert Solution().maxProfit(n, edges, score) == 68
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize $\sum s(v)\cdot \text{position}(v)$ over all topological orders by DP over subsets using predecessor masks.}
\WHY{Core pattern: scheduling with precedence constraints and position-dependent weights; appears in DAG DP interviews and contest problems with $n \le 22$.}
\CHECKLIST{
\begin{itemize}
\item Build predecessor bitmasks correctly.
\item Position is 1-based: use $k+1$ when $k$ nodes are already placed.
\item Only expand nodes whose predecessors are all placed: \texttt{(pred[v] \& \textasciitilde mask) == 0}.
\item Transition: \texttt{new\_mask = mask | (1<<v)}, add \texttt{score[v] * (k+1)}.
\item Use memoization or layered DP to control memory.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item No edges: optimal is nondecreasing by score (lowest first).
\item Chain: unique order; profit is fixed.
\item Multiple sources/sinks: ties in ready set; DP explores all.
\item Equal scores: any feasible order has same profit if scores all equal.
\item Large scores with sparse constraints: push large scores late if allowed.
\item Single node.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Off-by-one in position multiplier (must start at $1$).
\item Miscomputing availability: forgetting to exclude already placed nodes.
\item Using in-degrees instead of predecessor set for bitmask DP.
\item Memory blow-up from allocating a full array of size $2^n$ with Python ints.
\item Recursion depth if using brute force on larger $n$.
\item Integer overflow in other languages (use 64-bit); Python ints are unbounded.
\end{itemize}}
\FAILMODES{Greedy strategies that always pick the highest or lowest score among ready nodes can fail due to future constraints; only DP over subsets guarantees optimality under precedence.}
\ELI{You must place tasks in an order that respects dependencies. Since later positions are more valuable, postpone big-score tasks as much as dependencies allow. Try all choices efficiently with a bitmask DP that remembers which tasks are already done.}
\NotePages{3}

\end{document}