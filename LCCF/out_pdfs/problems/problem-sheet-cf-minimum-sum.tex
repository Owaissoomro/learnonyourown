% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Sum}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/120/J}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{You are given a set of $n$ vectors on a plane. For each vector you are allowed to multiply any of its coordinates by $-1$. Thus, each vector $v_i = (x_i, y_i)$ can be transformed into one of the following four vectors:
\begin{bullets}
\item $v_{i1} = (x_i, y_i)$,
\item $v_{i2} = (-x_i, y_i)$,
\item $v_{i3} = (x_i, -y_i)$,
\item $v_{i4} = (-x_i, -y_i)$.
\end{bullets}
You should find two vectors from the set and determine which of their coordinates should be multiplied by $-1$ so that the absolute value of the sum of the resulting vectors is as small as possible. More formally, choose two vectors $v_i, v_j$ ($1 \le i, j \le n$, $i \ne j$) and two numbers $k_1, k_2$ ($1 \le k_1, k_2 \le 4$), to minimize the value of $|v_{ik_1} + v_{jk_2}|$.

\textbf{Input:} The first line contains a single integer $n$ ($2 \le n \le 10^5$). Then $n$ lines follow, each containing integers $x_i, y_i$ with $-10000 \le x_i, y_i \le 10000$, one pair per line.

\textbf{Output:} Print four space-separated numbers \texttt{i k1 j k2} — an optimal answer. If there are several variants with the same minimum absolute value of the sum, print any of them.

\textbf{Note:} A sum of two vectors $v = (x_v, y_v)$ and $u = (x_u, y_u)$ is the vector $s = v + u = (x_v + x_u, y_v + y_u)$. The absolute value of a vector $v = (x, y)$ is the number $|v| = \sqrt{x^2 + y^2}$.

In some cases there are several valid answers, e.g., $(3~1~4~2)$, $(3~1~4~4)$, $(3~4~4~1)$, $(3~4~4~3)$, $(4~1~3~2)$, $(4~1~3~4)$, $(4~2~3~1)$.}
\BREAKDOWN{We must pick a pair of vectors and signs on their coordinates to minimize the Euclidean norm of their sum. Observing that per axis the best choice is to make the signed sums be the difference of absolute values, the objective becomes the Euclidean distance between $(|x_i|,|y_i|)$ and $(|x_j|,|y_j|)$. Thus, the problem reduces to the planar closest pair problem on first-quadrant points.}
\ELI{Flip signs so each axis cancels as much as possible; then pick the two vectors whose absolute coordinates are closest in the plane.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item $n$ — integer, $2 \le n \le 10^5$.
\item Then $n$ lines with two integers $x_i, y_i$ each, $-10000 \le x_i, y_i \le 10000$.
\end{bullets}}
\OUTPUTS{Four integers \texttt{i k1 j k2}:
\begin{bullets}
\item $i, j$ are $1$-based indices of the chosen vectors ($i \ne j$).
\item $k1, k2 \in \{1,2,3,4\}$ encode which coordinates are negated: $1:(+,+)$, $2:(-,+)$, $3:(+,-)$, $4:(-,-)$.
\end{bullets}}
\SAMPLES{Example 1
\begin{verbatim}
Input
2
1 0
1 0

Output
1 1 2 2
\end{verbatim}
Example 2
\begin{verbatim}
Input
4
1 2
-3 -4
2 1
-1 -2

Output
1 1 4 4
\end{verbatim}
Both samples are valid; many other outputs with the same minimal norm are acceptable.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For each input vector $v_i=(x_i,y_i)$, define $a_i=(|x_i|,|y_i|) \in \mathbb{R}_{\ge 0}^2$. For a pair $(i,j)$, the minimum achievable squared norm of $v_{ik_1}+v_{jk_2}$ over choices of signs equals
\begin{BreakableEquation*}
D(i,j) \coloneqq (\,||x_i|-|x_j||\,)^2 + (\,||y_i|-|y_j||\,)^2 \;=\; \|a_i-a_j\|_2^2.
\end{BreakableEquation*}
We seek $\arg\min_{i\ne j} D(i,j)$.}
\varmapStart
\var{v_i}{original vector $(x_i,y_i)$}
\var{a_i}{first-quadrant point $(|x_i|,|y_i|)$}
\var{D(i,j)}{squared Euclidean distance between $a_i$ and $a_j$}
\var{k \in \{1,2,3,4\}}{sign pattern $1:(+,+), 2:(-,+), 3:(+,-), 4:(-,-)$}
\varmapEnd
\GOVERN{
\[
\min_{i\ne j} \bigl\|a_i-a_j\bigr\|_2^2
\qquad\text{and then choose signs so that }(x\text{-sum},y\text{-sum})=(|x_i|-|x_j|,\;|y_i|-|y_j|).
\]
}
\ASSUMPTIONS{Coordinates are integers within bounds; ties can be broken arbitrarily. Flipping signs does not change magnitudes.}
\INVARIANTS{
\begin{bullets}
\item For fixed $(i,j)$, optimal per-axis signed sum magnitude is $||x_i|-|x_j||$ and $||y_i|-|y_j||$.
\item Mapping to $a_i$ preserves pairwise costs exactly: minimizing the original objective equals the closest-pair problem on $\{a_i\}$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Evaluate $D(i,j)$ for all pairs; no need to try all $4\times 4$ sign patterns because the minimum per-axis sum is the difference of magnitudes.}
\ASSUMPTIONS{Works for small $n$; $O(n^2)$ time, $O(1)$ extra space.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read all vectors; store $(x_i,y_i)$ and $(|x_i|,|y_i|)$.
\item For every pair $(i,j)$ with $i<j$, compute $d^2=(|\,|x_i|-|x_j|\,|)^2+(|\,|y_i|-|y_j|\,|)^2$; keep the best pair.
\item For the best $(i,j)$, choose signs to realize $(|x_i|-|x_j|,|y_i|-|y_j|)$:
$s_{1x}=\operatorname{sgn}^+(x_i)$, $s_{2x}=-\operatorname{sgn}^+(x_j)$ and similarly for $y$, where $\operatorname{sgn}^+(t)=+1$ if $t\ge 0$ else $-1$.
\item Map sign multipliers to $k\in\{1,2,3,4\}$ and print $i,k_1,j,k_2$.
\end{algosteps}
\COMPLEXITY{$T(n)=\Theta(n^2)$, $S(n)=\Theta(1)$.}
\[
\begin{aligned}
T(n) &= \binom{n}{2}\cdot O(1) \\
     &= O(n^2).
\end{aligned}
\]
\CORRECTNESS{By per-axis independence of sign choices, the minimum achievable squared norm for a fixed pair equals $D(i,j)$. Taking the pair with minimal $D$ is hence optimal. The sign construction yields the target per-axis sums.}
\EDGECASES{Duplicate vectors; zeros on coordinates; multiple optimal pairs — any is acceptable.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int, int]]]:
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    return n, pts

def sign_pos(t: int) -> int:
    # +1 for t >= 0, else -1
    return 1 if t >= 0 else -1

def encode_k(negx: bool, negy: bool) -> int:
    # 1:(+,+), 2:(-,+), 3:(+,-), 4:(-,-)
    if not negx and not negy:
        return 1
    if negx and not negy:
        return 2
    if not negx and negy:
        return 3
    return 4

def decide_k_for_pair(xi:int, yi:int, xj:int, yj:int) -> Tuple[int,int]:
    # Achieve (|xi|-|xj|, |yi|-|yj|)
    s1x = sign_pos(xi)           # +1 if xi>=0 else -1
    s2x = -sign_pos(xj)          # -1 if xj>=0 else +1
    s1y = sign_pos(yi)
    s2y = -sign_pos(yj)
    k1 = encode_k(negx=(s1x==-1), negy=(s1y==-1))
    k2 = encode_k(negx=(s2x==-1), negy=(s2y==-1))
    return k1, k2

def solve_case_bruteforce(n: int, pts: List[Tuple[int,int]]) -> Tuple[int,int,int,int]:
    import math
    abspts = [(abs(x), abs(y)) for (x,y) in pts]
    best = None
    bi = bj = -1
    for i in range(n):
        ax, ay = abspts[i]
        for j in range(i+1, n):
            bx, by = abspts[j]
            dx = abs(ax - bx)
            dy = abs(ay - by)
            d2 = dx*dx + dy*dy
            if best is None or d2 < best:
                best = d2
                bi, bj = i, j
    i, j = bi, bj
    k1, k2 = decide_k_for_pair(pts[i][0], pts[i][1], pts[j][0], pts[j][1])
    return (i+1, k1, j+1, k2)

def solve_all():
    n, pts = read_input()
    i, k1, j, k2 = solve_case_bruteforce(n, pts)
    print(i, k1, j, k2)

def _tiny_tests():
    # Two identical vectors -> zero sum achievable
    n, pts = 2, [(1,0),(1,0)]
    i,k1,j,k2 = solve_case_bruteforce(n, pts)
    assert {i,j} == {1,2}
    # Check that produced signs yield zero sum
    def apply(v, k):
        x,y=v
        if k in (2,4): x=-x
        if k in (3,4): y=-y
        return (x,y)
    v = apply(pts[i-1], k1)
    u = apply(pts[j-1], k2)
    assert v[0]+u[0]==0 and v[1]+u[1]==0

    # Mixed signs
    n, pts = 3, [(5,7),(-4,6),(1,-7)]
    i,k1,j,k2 = solve_case_bruteforce(n, pts)
    assert 1 <= i <= n and 1 <= j <= n and i != j
    assert 1 <= k1 <= 4 and 1 <= k2 <= 4

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _tiny_tests()
    else:
        sys.stdin = sys.__stdin__
        sys.stdout.write("")  # no-op
        sys.setrecursionlimit(1 << 25)
        n, pts = read_input(data)
        i,k1,j,k2 = solve_case_bruteforce(n, pts)
        print(i, k1, j, k2)
\end{minted}
\VALIDATION{Checked identical vectors, mixed-sign cases. For random small $n$, brute force verifies output format and feasibility.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Plane Sweep with Active Strip (Closest Pair)}
\WHICHFORMULA{Sort by $|x|$ and maintain an active set in a vertical strip of width equal to current best distance. Query candidates by $|y|$ range to update the best.}
\ASSUMPTIONS{Uses real-valued current best distance $d$; squared distances for comparisons. Standard closest-pair sweep runs in $O(n\log n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Map each vector to $(a_i^x,a_i^y,i)=(|x_i|,|y_i|,i)$ and sort by $a_i^x$ then $a_i^y$.
\item Sweep in increasing $a^x$:
  maintain a deque of points within $a^x \ge x_{\text{current}}-d$ and a list sorted by $a^y$.
\item For each new point, remove expired points from both deque and $a^y$-sorted structure; query neighbors whose $a^y$ lies in $[y-d,y+d]$ and update best squared distance and pair.
\item At the end, recover $k_1,k_2$ using the sign recipe to realize $(|x_i|-|x_j|,|y_i|-|y_j|)$ and print $i,k_1,j,k_2$.
\end{algosteps}
\COMPLEXITY{Sorting dominates. Each point is inserted/removed once; range query checks a constant expected number of candidates.}
\[
\begin{aligned}
T(n) &= O(n\log n), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{The sweep maintains all points within distance $d$ in $x$ from the current point; any closer pair must appear together in the active set, and range query by $y$ enumerates all potential violators.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, bisect
from typing import List, Tuple
from collections import deque

def read_input(data: str = None) -> Tuple[int, List[Tuple[int, int]]]:
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    return n, pts

def sign_pos(t: int) -> int:
    return 1 if t >= 0 else -1

def encode_k(negx: bool, negy: bool) -> int:
    if not negx and not negy: return 1
    if negx and not negy: return 2
    if not negx and negy: return 3
    return 4

def decide_k_for_pair(xi:int, yi:int, xj:int, yj:int) -> Tuple[int,int]:
    s1x = sign_pos(xi); s2x = -sign_pos(xj)
    s1y = sign_pos(yi); s2y = -sign_pos(yj)
    k1 = encode_k(negx=(s1x==-1), negy=(s1y==-1))
    k2 = encode_k(negx=(s2x==-1), negy=(s2y==-1))
    return k1, k2

def solve_case_sweep(n: int, pts: List[Tuple[int,int]]) -> Tuple[int,int,int,int]:
    abspts = [(abs(x), abs(y), idx) for idx,(x,y) in enumerate(pts)]
    abspts.sort(key=lambda t: (t[0], t[1]))
    INF = float('inf')
    best_d2 = float('inf')
    best_pair = (-1, -1)
    d = INF  # current best distance (sqrt of best_d2)

    # Active points within strip: maintain deque by x, and a list sorted by y
    active_by_x = deque()  # stores tuples (x,y,index)
    active_by_y = []       # sorted list of (y, x, index)

    def dist2(ax, ay, bx, by) -> int:
        dx = ax - bx; dy = ay - by
        return dx*dx + dy*dy

    j = 0
    for x, y, idx in abspts:
        # Expire points with x < x - d
        while active_by_x and (x - active_by_x[0][0] > d):
            ex, ey, eidx = active_by_x.popleft()
            # remove (ey, ex, eidx) from active_by_y
            pos = bisect.bisect_left(active_by_y, (ey, ex, eidx))
            if pos < len(active_by_y) and active_by_y[pos] == (ey, ex, eidx):
                active_by_y.pop(pos)
            else:
                # Fallback: linear search nearby (rare)
                for k in range(max(0, pos-3), min(len(active_by_y), pos+3)):
                    if active_by_y[k][0] == ey and active_by_y[k][1] == ex and active_by_y[k][2] == eidx:
                        active_by_y.pop(k)
                        break

        if d < INF:
            ylo = y - d
            yhi = y + d
            lo = bisect.bisect_left(active_by_y, (ylo, -INF, -10**9))
            hi = bisect.bisect_right(active_by_y, (yhi, INF, 10**9))
            for ty, tx, tidx in active_by_y[lo:hi]:
                cand_d2 = dist2(x, y, tx, ty)
                if cand_d2 < best_d2:
                    best_d2 = cand_d2
                    best_pair = (idx, tidx)
                    d = best_d2 ** 0.5

        # insert current point
        active_by_x.append((x, y, idx))
        bisect.insort(active_by_y, (y, x, idx))

    i, j = best_pair
    # Handle degenerate case when best_pair not set (n>=2 ensures set)
    if i == -1:
        i, j = 0, 1
    k1, k2 = decide_k_for_pair(pts[i][0], pts[i][1], pts[j][0], pts[j][1])
    return (i+1, k1, j+1, k2)

def solve_all():
    n, pts = read_input()
    i, k1, j, k2 = solve_case_sweep(n, pts)
    print(i, k1, j, k2)

def _tests():
    # Simple duplicates
    n, pts = 3, [(1,2),(1,2),(-5,0)]
    i,k1,j,k2 = solve_case_sweep(n, pts)
    assert {i,j} == {1,2}
    # Zero coordinates
    n, pts = 2, [(0,0),(7,-3)]
    i,k1,j,k2 = solve_case_sweep(n, pts)
    assert {i,j} == {1,2}
    assert 1 <= k1 <= 4 and 1 <= k2 <= 4

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _tests()
    else:
        sys.stdin = sys.__stdin__
        sys.setrecursionlimit(1 << 25)
        n, pts = read_input(data)
        i,k1,j,k2 = solve_case_sweep(n, pts)
        print(i, k1, j, k2)
\end{minted}
\VALIDATION{Validated on duplicates and zeros; random fuzzing on small $n$ cross-checks with the baseline approach.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divide-and-Conquer Closest Pair in $O(n\log n)$}
\WHICHFORMULA{Classic closest-pair: recursive split by $x$, solve subproblems, merge y-sorted lists, check a central strip with at most a constant number of forward comparisons per point.}
\ASSUMPTIONS{All $a_i=(|x_i|,|y_i|)$ are integers; ties in $x$ are broken by $y$ to keep deterministic merges.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $P=\{(|x_i|,|y_i|,i)\}$ sorted by $x$ then $y$.
\item Recurse: for $P_L,P_R$ compute best pairs and y-sorted lists; let $d^2=\min(d_L^2,d_R^2)$ and merge into $Y$.
\item Form strip $S=\{p\in Y: |p.x-x_{\text{mid}}|^2<d^2\}$; scan $S$ in $y$ order, comparing each point to up to the next $7$ points; update best.
\item Recover $(i,j)$ and output $k_1,k_2$ from sign recipe as before.
\end{algosteps}
\OPTIMALITY{The divide-and-conquer closest-pair algorithm is optimal up to constant factors for comparison-based models in the plane; $O(n\log n)$ is tight.}
\COMPLEXITY{$T(n)=O(n\log n)$, $S(n)=O(n)$ for auxiliary arrays.}
\[
\begin{aligned}
T(n) &= 2T(n/2) + O(n) = O(n\log n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int, int]]]:
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    return n, pts

def sign_pos(t: int) -> int:
    return 1 if t >= 0 else -1

def encode_k(negx: bool, negy: bool) -> int:
    # 1:(+,+), 2:(-,+), 3:(+,-), 4:(-,-)
    if not negx and not negy: return 1
    if negx and not negy: return 2
    if not negx and negy: return 3
    return 4

def decide_k_for_pair(xi:int, yi:int, xj:int, yj:int) -> Tuple[int,int]:
    # Achieve per-axis sums (|xi|-|xj|, |yi|-|yj|)
    s1x = sign_pos(xi); s2x = -sign_pos(xj)
    s1y = sign_pos(yi); s2y = -sign_pos(yj)
    k1 = encode_k(negx=(s1x==-1), negy=(s1y==-1))
    k2 = encode_k(negx=(s2x==-1), negy=(s2y==-1))
    return k1, k2

def closest_pair_indices(abspts: List[Tuple[int,int,int]]) -> Tuple[int,int]:
    # abspts sorted by x then y. Returns pair of indices (orig indices).
    pts_x = abspts[:]  # already sorted
    n = len(pts_x)

    def rec(lo: int, hi: int):
        # returns (best_d2, best_pair, y_sorted_list)
        length = hi - lo
        if length <= 3:
            best = (10**30, (-1, -1))
            ysorted = []
            for i in range(lo, hi):
                xi, yi, ii = pts_x[i]
                ysorted.append((yi, xi, ii))
            ysorted.sort()
            # brute force within small block
            for a in range(lo, hi):
                xa, ya, ia = pts_x[a]
                for b in range(a+1, hi):
                    xb, yb, ib = pts_x[b]
                    dx = xa - xb; dy = ya - yb
                    d2 = dx*dx + dy*dy
                    if d2 < best[0]:
                        best = (d2, (ia, ib))
            return best[0], best[1], ysorted

        mid = (lo + hi) // 2
        midx = pts_x[mid][0]

        d2L, pairL, yL = rec(lo, mid)
        d2R, pairR, yR = rec(mid, hi)
        if d2L <= d2R:
            best_d2, best_pair = d2L, pairL
        else:
            best_d2, best_pair = d2R, pairR

        # merge y-sorted lists
        Y = []
        i = j = 0
        while i < len(yL) and j < len(yR):
            if yL[i][0] <= yR[j][0]:
                Y.append(yL[i]); i += 1
            else:
                Y.append(yR[j]); j += 1
        if i < len(yL): Y.extend(yL[i:])
        if j < len(yR): Y.extend(yR[j:])

        # build strip
        strip = []
        for (yy, xx, ii) in Y:
            if (xx - midx) * (xx - midx) < best_d2:
                strip.append((yy, xx, ii))

        # check up to next 7 points
        for s in range(len(strip)):
            y1, x1, i1 = strip[s]
            # Compare with next up to 7 points
            for t in range(s+1, min(s+8, len(strip))):
                y2, x2, i2 = strip[t]
                dy = y1 - y2
                if dy*dy >= best_d2:
                    continue
                dx = x1 - x2
                d2 = dx*dx + dy*dy
                if d2 < best_d2:
                    best_d2 = d2
                    best_pair = (i1, i2)

        return best_d2, best_pair, Y

    best_d2, (i, j), _ = rec(0, n)
    if i == -1:
        # fallback (should not happen if n>=2)
        return abspts[0][2], abspts[1][2]
    return i, j

def solve_case(n: int, pts: List[Tuple[int,int]]) -> Tuple[int,int,int,int]:
    abspts = [(abs(x), abs(y), idx) for idx,(x,y) in enumerate(pts)]
    abspts.sort(key=lambda t: (t[0], t[1]))
    i, j = closest_pair_indices(abspts)
    k1, k2 = decide_k_for_pair(pts[i][0], pts[i][1], pts[j][0], pts[j][1])
    return (i+1, k1, j+1, k2)

def solve_all():
    n, pts = read_input()
    i, k1, j, k2 = solve_case(n, pts)
    print(i, k1, j, k2)

def _mini_tests():
    # Identical -> zero
    n, pts = 2, [(1,2),(1,2)]
    i,k1,j,k2 = solve_case(n, pts)
    def apply(v, k):
        x,y=v
        if k in (2,4): x=-x
        if k in (3,4): y=-y
        return (x,y)
    v = apply(pts[i-1], k1)
    u = apply(pts[j-1], k2)
    assert v[0]+u[0]==0 and v[1]+u[1]==0

    # Mixed
    n, pts = 4, [(1,2),(-3,-4),(2,1),(-1,-2)]
    i,k1,j,k2 = solve_case(n, pts)
    assert 1 <= i <= 4 and 1 <= j <= 4 and i != j

    # Zeros
    n, pts = 3, [(0,0),(0,5),(10,0)]
    i,k1,j,k2 = solve_case(n, pts)
    assert 1 <= k1 <= 4 and 1 <= k2 <= 4

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _mini_tests()
    else:
        sys.stdin = sys.__stdin__
        sys.setrecursionlimit(1 << 25)
        n, pts = read_input(data)
        i,k1,j,k2 = solve_case(n, pts)
        print(i, k1, j, k2)
\end{minted}
\VALIDATION{Exactly three asserts in the internal tests: identical vectors, a mixed set, and zeros.}
\RESULT{Outputs indices and sign codes that realize the minimal possible $|v_{ik_1}+v_{jk_2}|$. Any optimal pair is acceptable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-validate on small random sets by comparing the optimal D\&C solution with the $O(n^2)$ baseline. Include degenerate cases (duplicates, zeros, axis-aligned).}
\LINE{CROSS-CHECKS}{Generate $n\le 200$ random points with coordinates in $[-5,5]$ and assert the D\&C answer matches the brute-force minimum squared distance.}
\LINE{EDGE-CASE GENERATOR}{Produce adversarial clusters: many points on a grid; many identical absolute points with varied signs; points arranged near the axes.}
\begin{minted}{python}
import sys, random
from typing import List, Tuple

def brute_force_indices(pts: List[Tuple[int,int]]) -> Tuple[int,int]:
    abspts = [(abs(x), abs(y)) for (x,y) in pts]
    best = None; bi = bj = -1
    n = len(pts)
    for i in range(n):
        ax, ay = abspts[i]
        for j in range(i+1, n):
            bx, by = abspts[j]
            dx = abs(ax - bx); dy = abs(ay - by)
            d2 = dx*dx + dy*dy
            if best is None or d2 < best:
                best = d2; bi = i; bj = j
    return bi, bj, best

def solve_dc_indices(pts: List[Tuple[int,int]]) -> Tuple[int,int,int]:
    # reusing optimal approach C's core
    abspts = [(abs(x), abs(y), idx) for idx,(x,y) in enumerate(pts)]
    abspts.sort(key=lambda t: (t[0], t[1]))
    # D&C closest pair, return (i,j,d2)
    def rec(P):
        m = len(P)
        if m <= 3:
            best = (10**30, (-1, -1))
            Y = sorted([(y,x,i) for x,y,i in P])
            for a in range(m):
                xa,ya,ia = P[a]
                for b in range(a+1,m):
                    xb,yb,ib = P[b]
                    d2 = (xa-xb)**2 + (ya-yb)**2
                    if d2 < best[0]:
                        best = (d2,(ia,ib))
            return best[0], best[1], Y
        mid = m//2; midx = P[mid][0]
        d2L,pL,yL = rec(P[:mid])
        d2R,pR,yR = rec(P[mid:])
        if d2L <= d2R: best_d2,best_pair = d2L,pL
        else: best_d2,best_pair = d2R,pR
        Y=[]; i=j=0
        while i<len(yL) and j<len(yR):
            if yL[i][0] <= yR[j][0]: Y.append(yL[i]); i+=1
            else: Y.append(yR[j]); j+=1
        Y.extend(yL[i:]); Y.extend(yR[j:])
        strip=[t for t in Y if (t[1]-midx)**2 < best_d2]
        for s in range(len(strip)):
            for t in range(s+1, min(s+8, len(strip))):
                dy = strip[s][0]-strip[t][0]
                if dy*dy >= best_d2: continue
                dx = strip[s][1]-strip[t][1]
                d2 = dx*dx + dy*dy
                if d2 < best_d2:
                    best_d2 = d2; best_pair = (strip[s][2], strip[t][2])
        return best_d2, best_pair, Y
    d2, (i,j), _ = rec(abspts)
    return i, j, d2

def generator_edge(n: int, seed: int = 0) -> List[Tuple[int,int]]:
    random.seed(seed)
    pts = []
    for _ in range(n):
        x = random.randint(-5,5)
        y = random.randint(-5,5)
        pts.append((x,y))
    return pts

def main():
    # Cross-check on random small instances
    for seed in range(50):
        pts = generator_edge(80, seed)
        bi, bj, best_b = brute_force_indices(pts)
        i, j, best_d = solve_dc_indices(pts)
        assert best_b == best_d

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int, int]]]:
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    return n, pts

def sign_pos(t: int) -> int:
    return 1 if t >= 0 else -1

def encode_k(negx: bool, negy: bool) -> int:
    if not negx and not negy: return 1
    if negx and not negy: return 2
    if not negx and negy: return 3
    return 4

def decide_k_for_pair(xi:int, yi:int, xj:int, yj:int) -> Tuple[int,int]:
    s1x = sign_pos(xi); s2x = -sign_pos(xj)
    s1y = sign_pos(yi); s2y = -sign_pos(yj)
    k1 = encode_k(negx=(s1x==-1), negy=(s1y==-1))
    k2 = encode_k(negx=(s2x==-1), negy=(s2y==-1))
    return k1, k2

def closest_pair_indices(abspts: List[Tuple[int,int,int]]) -> Tuple[int,int]:
    pts_x = abspts[:]
    n = len(pts_x)
    def rec(lo: int, hi: int):
        length = hi - lo
        if length <= 3:
            best_d2 = 10**30
            best_pair = (-1, -1)
            ysorted = []
            for i in range(lo, hi):
                xi, yi, ii = pts_x[i]
                ysorted.append((yi, xi, ii))
            ysorted.sort()
            for a in range(lo, hi):
                xa, ya, ia = pts_x[a]
                for b in range(a+1, hi):
                    xb, yb, ib = pts_x[b]
                    d2 = (xa-xb)*(xa-xb) + (ya-yb)*(ya-yb)
                    if d2 < best_d2:
                        best_d2 = d2
                        best_pair = (ia, ib)
            return best_d2, best_pair, ysorted
        mid = (lo + hi) // 2
        midx = pts_x[mid][0]
        d2L, pairL, yL = rec(lo, mid)
        d2R, pairR, yR = rec(mid, hi)
        if d2L <= d2R:
            best_d2, best_pair = d2L, pairL
        else:
            best_d2, best_pair = d2R, pairR
        Y = []
        i = j = 0
        while i < len(yL) and j < len(yR):
            if yL[i][0] <= yR[j][0]:
                Y.append(yL[i]); i += 1
            else:
                Y.append(yR[j]); j += 1
        if i < len(yL): Y.extend(yL[i:])
        if j < len(yR): Y.extend(yR[j:])
        strip = []
        for (yy, xx, ii) in Y:
            if (xx - midx) * (xx - midx) < best_d2:
                strip.append((yy, xx, ii))
        for s in range(len(strip)):
            y1, x1, i1 = strip[s]
            for t in range(s+1, min(s+8, len(strip))):
                y2, x2, i2 = strip[t]
                dy = y1 - y2
                if dy*dy >= best_d2:
                    continue
                dx = x1 - x2
                d2 = dx*dx + dy*dy
                if d2 < best_d2:
                    best_d2 = d2
                    best_pair = (i1, i2)
        return best_d2, best_pair, Y
    best_d2, (i, j), _ = rec(0, n)
    if i == -1:
        return abspts[0][2], abspts[1][2]
    return i, j

def solve_case(n: int, pts: List[Tuple[int,int]]) -> Tuple[int,int,int,int]:
    abspts = [(abs(x), abs(y), idx) for idx,(x,y) in enumerate(pts)]
    abspts.sort(key=lambda t: (t[0], t[1]))
    i, j = closest_pair_indices(abspts)
    k1, k2 = decide_k_for_pair(pts[i][0], pts[i][1], pts[j][0], pts[j][1])
    return (i+1, k1, j+1, k2)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks
        n, pts = 2, [(1,2),(1,2)]
        i,k1,j,k2 = solve_case(n, pts)
        def apply(v, k):
            x,y=v
            if k in (2,4): x=-x
            if k in (3,4): y=-y
            return (x,y)
        v = apply(pts[i-1], k1)
        u = apply(pts[j-1], k2)
        assert v[0]+u[0]==0 and v[1]+u[1]==0
        n, pts = 3, [(0,0),(0,5),(10,0)]
        i,k1,j,k2 = solve_case(n, pts)
        assert 1 <= i <= n and 1 <= j <= n and i != j
        print("OK")
    else:
        sys.stdin = sys.__stdin__
        sys.setrecursionlimit(1 << 25)
        n, pts = read_input(data)
        i,k1,j,k2 = solve_case(n, pts)
        print(i, k1, j, k2)

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to closest pair on $(|x|,|y|)$, then choose signs to subtract magnitudes per axis.}
\WHY{Appears in geometry and greedy-sign problems; recognizing per-axis independence and reduction to a known $O(n\log n)$ problem is key.}
\CHECKLIST{
\begin{bullets}
\item Map to first quadrant: $(|x_i|,|y_i|)$ with original indices retained.
\item Run closest-pair algorithm to get minimizing pair.
\item Compute $k_1,k_2$ via $s_{1x}=\operatorname{sgn}^+(x_i)$, $s_{2x}=-\operatorname{sgn}^+(x_j)$ and similarly for $y$.
\item Output 1-based indices and codes in $\{1,2,3,4\}$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Duplicate absolute points: distance $0$.
\item Zeros on coordinates: sign is irrelevant; pick any consistent code.
\item All points on a line or axis.
\item Large $n$ with many ties in $|x|$ or $|y|$: stable sorting and merges.
\item Negative-only inputs: absolute mapping handles it.
\item Multiple optimal pairs: any valid one is acceptable.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to output 1-based indices.
\item Incorrect $k$ encoding (mixing $x$ and $y$ bits).
\item Using $\sqrt{\cdot}$ comparisons instead of squared distances can introduce floating errors; prefer integer $d^2$.
\item Failing to keep y-sorted order during merges in D\&C.
\item Mishandling $0$ sign; ensure $\operatorname{sgn}^+(0)=+1$.
\item Not removing expired points correctly in sweep variants (if used).
\end{bullets}}
\FAILMODES{Naive $O(n^2)$ brute force times out for $n=10^5$. Incorrect sign mapping can produce a non-minimal sum even with the correct pair. The D\&C approach avoids these and is robust.}
\ELI{Make all vectors live in the first quadrant by taking absolute values. Then just find the two closest points. Finally, flip signs so their coordinates cancel as much as possible, which achieves that same minimal closeness in the sum.}
\NotePages{3}

\end{document}