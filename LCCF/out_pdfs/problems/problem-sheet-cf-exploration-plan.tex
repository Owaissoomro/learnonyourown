% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{BreakableEquation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Exploration plan}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/852/D}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{The competitors of Bubble Cup X gathered after the competition and discussed what is the best way to get to know the host country and its cities.

After exploring the map of Serbia for a while, the competitors came up with the following facts: the country has $V$ cities which are indexed with numbers from $1$ to $V$, and there are $E$ bi-directional roads that connect the cites. Each road has a weight (the time needed to cross that road). There are $N$ teams at the Bubble Cup and the competitors came up with the following plan: each of the $N$ teams will start their journey in one of the $V$ cities, and some of the teams share the starting position.

They want to find the shortest time $T$, such that every team can move in these $T$ minutes, and the number of different cities they end up in is at least $K$ (because they will only get to know the cities they end up in). A team does not have to be on the move all the time, if they like it in a particular city, they can stay there and wait for the time to pass.

Please help the competitors to determine the shortest time $T$ so it is possible for them to end up in at least $K$ different cities or print $-1$ if that is impossible no matter how they move.

Note that there can exist multiple roads between some cities.

Input:
The first line contains four integers: $V$, $E$, $N$ and $K$ ($1 \le V \le 600$, $1 \le E \le 20000$, $1 \le N \le \min(V, 200)$, $1 \le K \le N$), number of cities, number of roads, number of teams and the smallest number of different cities they need to end up in, respectively.

The second line contains $N$ integers, the cities where the teams start their journey.

Next $E$ lines contain information about the roads in following format: $A_i$ $B_i$ $T_i$ ($1 \le A_i, B_i \le V$, $1 \le T_i \le 10000$), which means that there is a road connecting cities $A_i$ and $B_i$, and you need $T_i$ minutes to cross that road.

Output:
Output a single integer that represents the minimal time the teams can move for, such that they end up in at least $K$ different cities or output $-1$ if there is no solution.

If the solution exists, result will be no greater than $1731311$.

Note:
Three teams start from city $5$, and two teams start from city $2$. If they agree to move for $3$ minutes, one possible situation would be the following: Two teams in city $2$, one team in city $5$, one team in city $3$, and one team in city $1$. And we see that there are four different cities the teams end their journey at.}
\BREAKDOWN{Model reachability in time $T$ from each team to cities using shortest paths. For a fixed $T$, determine if at least $K$ distinct cities can be occupied by assigning teams to distinct cities they can reach. Binary search the minimal feasible $T$.}
\ELI{Precompute how far each start can go, then pick $K$ different cities reachable by different teams; shrink $T$ by binary search until it just works.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test. First line: integers $V$, $E$, $N$, $K$. Second line: $N$ integers $s_1,\ldots,s_N$ with $1 \le s_i \le V$. Then $E$ lines: $A_i$ $B_i$ $T_i$ describing an undirected edge of weight $T_i$.}
\OUTPUTS{Single integer: minimal $T$ such that at least $K$ distinct cities can be occupied by the $N$ teams after moving for at most $T$ minutes; $-1$ if impossible.}
\SAMPLES{Example 1: Let $V=3$, $E=2$, $N=2$, $K=2$, starts $[1,3]$, edges $(1,2,5)$, $(2,3,5)$. Answer $0$.

Example 2: Let $V=3$, $E=1$, $N=2$, $K=2$, starts $[1,1]$, edge $(1,2,7)$. Minimal time is $7$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E,w)$ be an undirected weighted graph, $|V|=V$, $|E|=E$. Let starting multiset $S=\{s_1,\ldots,s_N\}$. For time $T \ge 0$, define for team $i$ the reachable set $R_i(T)=\{v \in V : \operatorname{dist}(s_i,v) \le T\}$. Form a bipartite graph $B_T=(L \cup R, E_T)$ with $L=\{1,\ldots,N\}$ and $R=V$, and edge $(i,v) \in E_T$ iff $v \in R_i(T)$. Feasibility for at least $K$ distinct cities is equivalent to the existence of a matching of size at least $K$ in $B_T$.}
\varmapStart
\var{V}{number of cities, also the vertex set}
\var{E}{set of undirected edges}
\var{w(e)}{positive integer weight of edge $e$}
\var{N}{number of teams}
\var{K}{required number of distinct cities}
\var{T}{time budget to test for feasibility}
\var{\operatorname{dist}(u,v)}{shortest path distance in $G$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Feasible}(T) \iff \nu(B_T) \ge K, \\
&\text{where } \nu(B_T) \text{ is the maximum matching size in } B_T, \\
&\text{and } (i,v) \in E_T \iff \operatorname{dist}(s_i,v) \le T.
\end{aligned}
\]
}
\ASSUMPTIONS{Graph is connected or not; multiple edges allowed; weights are positive integers; indices are $1$-based in input.}
\INVARIANTS{Shortest path distances satisfy triangle inequality and are finite only within connected components. For fixed $T$, $B_T$ is monotone in $T$: if $T_1 \le T_2$ then $E_{T_1} \subseteq E_{T_2}$, implying $\nu(B_{T_1}) \le \nu(B_{T_2})$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Naively test a candidate $T$ by building $B_T$ and running a simple DFS-based augmenting path algorithm (Kuhn) to count how many distinct cities can be matched. Search $T$ by linear scan from $0$ upward.}
\ASSUMPTIONS{Weights are integers and an absolute cap on the answer exists ($\le 1731311$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute all-pairs distances from each distinct starting city using Dijkstra.
\item For $T=0,1,2,\ldots,1731311$, build $B_T$ and run Kuhn matching; stop once matching size $\ge K$.
\item Return that $T$ or $-1$ if none works.
\end{algosteps}
\COMPLEXITY{Let $S$ be the number of distinct start cities. Dijkstra $S$ times costs $O(S (E \log V))$. Each $T$ test costs $O(NV + M_T N)$ where $M_T \le NV$. Linear scan over $T$ is too slow in the worst case.}
\[
\begin{aligned}
T(n) &= O\big(S(E\log V)\big) + O\big(1731312 \cdot NV\big) \\
     &\text{(impractical due to the linear scan).}
\end{aligned}
\]
\CORRECTNESS{Kuhn finds a maximum matching by repeatedly augmenting along alternating paths; if at some $T$ we find $\ge K$ matches, the teams can occupy $\ge K$ distinct cities.}
\EDGECASES{Disconnected graph; multiple edges; $K=1$; $T=0$; many teams in one city; unreachable cities.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline components: Dijkstra, bipartite graph by threshold T, Kuhn matching, linear scan T.
# Not intended for final use due to linear scan; kept for comparison and unit reasoning.

from heapq import heappush, heappop

INF = 10**18

def dijkstra(V, adj, src):
    dist = [INF] * (V + 1)
    dist[src] = 0
    pq = [(0, src)]
    while pq:
        d, u = heappop(pq)
        if d != dist[u]:
            continue
        for v, w in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                heappush(pq, (nd, v))
    return dist

def kuhn_max_matching(N, V, edges):
    # edges: list of lists; edges[i] contains right nodes (0..V-1) adjacent to left i (0..N-1)
    matchR = [-1] * V
    def dfs(u, seen):
        for v in edges[u]:
            if seen[v]:
                continue
            seen[v] = True
            if matchR[v] == -1 or dfs(matchR[v], seen):
                matchR[v] = u
                return True
        return False
    msize = 0
    for u in range(N):
        if dfs(u, [False] * V):
            msize += 1
    return msize

def build_edges_by_T(N, V, starts, dist_from_start, T):
    # dist_from_start: dict start_city -> dist array
    edges = [[] for _ in range(N)]
    for i in range(N):
        s = starts[i]
        dist = dist_from_start[s]
        # right side nodes are 0..V-1 representing cities 1..V
        edges[i] = [v-1 for v in range(1, V+1) if dist[v] <= T]
    return edges

def baseline_min_time(V, E, N, K, starts, edge_list):
    adj = [[] for _ in range(V + 1)]
    for a, b, w in edge_list:
        adj[a].append((b, w))
        adj[b].append((a, w))
    uniq_starts = sorted(set(starts))
    dist_from_start = {s: dijkstra(V, adj, s) for s in uniq_starts}
    # quick impossibility check at max cap
    cap = 1731311
    edges_cap = build_edges_by_T(N, V, starts, dist_from_start, cap)
    if kuhn_max_matching(N, V, edges_cap) < K:
        return -1
    # linear scan (inefficient)
    for T in range(0, cap + 1):
        edges_T = build_edges_by_T(N, V, starts, dist_from_start, T)
        if kuhn_max_matching(N, V, edges_T) >= K:
            return T
    return -1

# Tiny asserts
def _test_baseline():
    V, E, N, K = 3, 2, 2, 2
    starts = [1, 3]
    edges = [(1, 2, 5), (2, 3, 5)]
    assert baseline_min_time(V, E, N, K, starts, edges) == 0
    V, E, N, K = 3, 1, 2, 2
    starts = [1, 1]
    edges = [(1, 2, 7)]
    assert baseline_min_time(V, E, N, K, starts, edges) == 7

# Do not run by default (too slow); just ensure it imports and basic tests pass quickly.
_test_baseline()
\end{minted}
\VALIDATION{The asserts verify $T=0$ when teams already sit in distinct cities, and a single move to a neighbor suffices when both start the same.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search on $T$ + Hopcroft--Karp}
\WHICHFORMULA{Monotonicity: Feasible$(T)$ is non-decreasing in $T$. Hence binary search on $T$. Replace Kuhn with Hopcroft--Karp to compute maximum matching in $O(M \sqrt{U})$.}
\ASSUMPTIONS{Precompute distances from each distinct starting city via Dijkstra once.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency for the road network.
\item For each distinct start city, run Dijkstra to get $\operatorname{dist}(s,\cdot)$.
\item Binary search $T \in [0, 1731311]$. For each mid:
  \begin{bullets}
  \item Build bipartite edges $(i,v)$ where $\operatorname{dist}(s_i,v) \le T$.
  \item Run Hopcroft--Karp and check if matching size $\ge K$.
  \end{bullets}
\item If no $T$ works, return $-1$; else return the minimal feasible $T$.
\end{algosteps}
\COMPLEXITY{Dijkstra: $O(S(E \log V))$ for $S \le N \le 200$. Each check builds up to $NV$ edges and runs in $O(NV \sqrt{V})$. About $\lceil \log_2(1731312) \rceil \approx 21$ checks.}
\[
\begin{aligned}
T(n) &= O\big(S(E\log V)\big) + O\big(\log \text{cap} \cdot NV \sqrt{V}\big), \\
S(n) &= O(SV + NV).
\end{aligned}
\]
\CORRECTNESS{By construction, an edge exists iff a team can reach a city within $T$. Maximum matching gives the largest number of distinct cities that can be assigned to different teams. Binary search yields the minimal $T$ due to monotonicity.}
\textbf{Code (Improved)}
\begin{minted}{python}
from heapq import heappush, heappop
from collections import deque

INF = 10**18
CAP_MAX = 1731311

def dijkstra(V, adj, src):
    dist = [INF] * (V + 1)
    dist[src] = 0
    pq = [(0, src)]
    while pq:
        d, u = heappop(pq)
        if d != dist[u]:
            continue
        for v, w in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                heappush(pq, (nd, v))
    return dist

def build_edges_by_T(N, V, starts, dist_from_start, T):
    edges = [[] for _ in range(N)]
    for i in range(N):
        d = dist_from_start[starts[i]]
        # right nodes 0..V-1 correspond to cities 1..V
        edges[i] = [v-1 for v in range(1, V+1) if d[v] <= T]
    return edges

def hopcroft_karp(N, V, adjL):
    # adjL: list of lists, left nodes 0..N-1, right nodes 0..V-1
    NIL = -1
    pairU = [-1] * N
    pairV = [-1] * V
    dist = [0] * N

    def bfs():
        q = deque()
        for u in range(N):
            if pairU[u] == -1:
                dist[u] = 0
                q.append(u)
            else:
                dist[u] = -1
        found_free = False
        while q:
            u = q.popleft()
            for v in adjL[u]:
                pu = pairV[v]
                if pu != -1 and dist[pu] == -1:
                    dist[pu] = dist[u] + 1
                    q.append(pu)
                if pu == -1:
                    found_free = True
        return found_free

    def dfs(u):
        for v in adjL[u]:
            pu = pairV[v]
            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):
                pairU[u] = v
                pairV[v] = u
                return True
        dist[u] = -1
        return False

    matching = 0
    while bfs():
        for u in range(N):
            if pairU[u] == -1 and dfs(u):
                matching += 1
    return matching

def feasible(N, V, K, starts, dist_from_start, T):
    edges = build_edges_by_T(N, V, starts, dist_from_start, T)
    m = hopcroft_karp(N, V, edges)
    return m >= K

def min_time(V, E, N, K, starts, edge_list):
    adj = [[] for _ in range(V + 1)]
    for a, b, w in edge_list:
        adj[a].append((b, w))
        adj[b].append((a, w))
    uniq_starts = sorted(set(starts))
    dist_from_start = {s: dijkstra(V, adj, s) for s in uniq_starts}
    # Check impossibility at cap
    if not feasible(N, V, K, starts, dist_from_start, CAP_MAX):
        return -1
    lo, hi = 0, CAP_MAX
    while lo < hi:
        mid = (lo + hi) // 2
        if feasible(N, V, K, starts, dist_from_start, mid):
            hi = mid
        else:
            lo = mid + 1
    return lo

def _tests_improved():
    V, E, N, K = 3, 2, 2, 2
    starts = [1, 3]
    edges = [(1, 2, 5), (2, 3, 5)]
    assert min_time(V, E, N, K, starts, edges) == 0
    V, E, N, K = 3, 1, 2, 2
    starts = [1, 1]
    edges = [(1, 2, 7)]
    assert min_time(V, E, N, K, starts, edges) == 7
    V, E, N, K = 1, 0, 2, 2
    starts = [1, 1]
    edges = []
    assert min_time(V, E, N, K, starts, edges) == -1

_tests_improved()
\end{minted}
\VALIDATION{Covers $T=0$, minimal positive $T$, and impossible cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Precompute Dijkstra + Binary Search + Hopcroft--Karp}
\WHICHFORMULA{This combines optimal primitives: one Dijkstra per distinct start, binary search on a monotone predicate, and Hopcroft--Karp for maximum matching.}
\ASSUMPTIONS{Edge weights positive; $V \le 600$, $N \le 200$, making $S \le 200$ Dijkstras feasible in Python.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency list with multiple edges preserved.
\item Precompute distances from each distinct starting city using Dijkstra with a heap.
\item Define predicate Feasible$(T)$ by constructing bipartite edges for teams to cities with distance $\le T$ and computing maximum matching via Hopcroft--Karp; return true if matching size $\ge K$.
\item Binary search minimal $T \in [0, 1731311]$ satisfying Feasible$(T)$; if none, print $-1$.
\end{algosteps}
\OPTIMALITY{Matching-based formulation is necessary due to the ``distinct cities'' constraint. The binary search is asymptotically optimal among comparison-based searches on integer $T$ with unknown transition point.}
\COMPLEXITY{Let $S$ be the number of distinct start cities.
\[
\begin{aligned}
\text{Precompute} &:\ O(S(E\log V)),\\
\text{Each check} &:\ O(NV + NV\sqrt{V}),\\
\text{Checks} &:\ O(\log 1731312) \approx 21.
\end{aligned}
\]
Overall practical within limits.}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts

from heapq import heappush, heappop
from collections import deque
import sys

INF = 10**18
CAP_MAX = 1731311

def dijkstra(V, adj, src):
    dist = [INF] * (V + 1)
    dist[src] = 0
    pq = [(0, src)]
    while pq:
        d, u = heappop(pq)
        if d != dist[u]:
            continue
        for v, w in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                heappush(pq, (nd, v))
    return dist

def build_edges_by_T(N, V, starts, dist_from_start, T):
    edges = [[] for _ in range(N)]
    # right nodes are 0..V-1 for cities 1..V
    for i in range(N):
        d = dist_from_start[starts[i]]
        # Small heuristic: iterate only cities reachable; scanning 1..V is fine for V<=600
        edges[i] = [v-1 for v in range(1, V+1) if d[v] <= T]
    return edges

def hopcroft_karp(N, V, adjL):
    pairU = [-1] * N
    pairV = [-1] * V
    dist = [0] * N

    def bfs():
        q = deque()
        for u in range(N):
            if pairU[u] == -1:
                dist[u] = 0
                q.append(u)
            else:
                dist[u] = -1
        found_free = False
        while q:
            u = q.popleft()
            for v in adjL[u]:
                pu = pairV[v]
                if pu != -1 and dist[pu] == -1:
                    dist[pu] = dist[u] + 1
                    q.append(pu)
                if pu == -1:
                    found_free = True
        return found_free

    def dfs(u):
        for v in adjL[u]:
            pu = pairV[v]
            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):
                pairU[u] = v
                pairV[v] = u
                return True
        dist[u] = -1
        return False

    matching = 0
    while bfs():
        for u in range(N):
            if pairU[u] == -1 and dfs(u):
                matching += 1
    return matching

def feasible(N, V, K, starts, dist_from_start, T):
    edges = build_edges_by_T(N, V, starts, dist_from_start, T)
    return hopcroft_karp(N, V, edges) >= K

def solve_case(V, E, N, K, starts, edge_list):
    adj = [[] for _ in range(V + 1)]
    for a, b, w in edge_list:
        adj[a].append((b, w))
        adj[b].append((a, w))
    uniq_starts = sorted(set(starts))
    dist_from_start = {s: dijkstra(V, adj, s) for s in uniq_starts}
    if not feasible(N, V, K, starts, dist_from_start, CAP_MAX):
        return -1
    lo, hi = 0, CAP_MAX
    while lo < hi:
        mid = (lo + hi) // 2
        if feasible(N, V, K, starts, dist_from_start, mid):
            hi = mid
        else:
            lo = mid + 1
    return lo

def read_input(data: str):
    it = iter(data.strip().split())
    V = int(next(it)); E = int(next(it)); N = int(next(it)); K = int(next(it))
    starts = [int(next(it)) for _ in range(N)]
    edges = []
    for _ in range(E):
        a = int(next(it)); b = int(next(it)); w = int(next(it))
        edges.append((a, b, w))
    return V, E, N, K, starts, edges

def solve_all():
    data = sys.stdin.read()
    if not data.strip():
        return
    V, E, N, K, starts, edges = read_input(data)
    ans = solve_case(V, E, N, K, starts, edges)
    print(ans)

def _self_tests():
    # 1) Already distinct, T = 0
    V, E, N, K = 3, 2, 2, 2
    starts = [1, 3]
    edges = [(1, 2, 5), (2, 3, 5)]
    assert solve_case(V, E, N, K, starts, edges) == 0
    # 2) Same start, need to move once
    V, E, N, K = 3, 1, 2, 2
    starts = [1, 1]
    edges = [(1, 2, 7)]
    assert solve_case(V, E, N, K, starts, edges) == 7
    # 3) Impossible to get 2 distinct cities
    V, E, N, K = 1, 0, 2, 2
    starts = [1, 1]
    edges = []
    assert solve_case(V, E, N, K, starts, edges) == -1

if __name__ == "__main__":
    _self_tests()
    solve_all()
\end{minted}
\VALIDATION{Exactly three asserts covering distinct, minimal positive, and impossible scenarios.}
\RESULT{Minimal time $T$ achieving at least $K$ distinct cities, or $-1$ if infeasible. If feasible, $T \le 1731311$ as guaranteed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on synthetic graphs: lines, stars, disconnected components; random small graphs; verify monotonicity of feasibility and equality of different implementations on small sizes.}
\LINE{CROSS-CHECKS}{Compare Kuhn vs Hopcroft--Karp on tiny cases; ensure both give same matching sizes for various $T$.}
\LINE{EDGE-CASE GENERATOR}{Generate graphs with zero or one edge, multiple parallel edges, heavy weights, and multiple teams per start to stress matching and Dijkstra.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

def gen_line_graph(n, w):
    edges = []
    for i in range(1, n):
        edges.append((i, i+1, w))
    return edges

def gen_star_graph(n, center, w):
    edges = []
    for v in range(1, n+1):
        if v == center: continue
        edges.append((center, v, w))
    return edges

def tiny_crosscheck():
    # Line graph
    V, E = 5, 4
    edges = gen_line_graph(5, 2)
    starts = [1, 1, 3]
    N, K = len(starts), 3
    # Expect T=0 infeasible (only 2 distinct cities max at T=0), T=2 feasible
    assert solve_case(V, E, N, K, starts, edges) == 2

if __name__ == "__main__":
    tiny_crosscheck()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts

from heapq import heappush, heappop
from collections import deque
import sys

INF = 10**18
CAP_MAX = 1731311

def dijkstra(V, adj, src):
    dist = [INF] * (V + 1)
    dist[src] = 0
    pq = [(0, src)]
    while pq:
        d, u = heappop(pq)
        if d != dist[u]:
            continue
        for v, w in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                heappush(pq, (nd, v))
    return dist

def build_edges_by_T(N, V, starts, dist_from_start, T):
    edges = [[] for _ in range(N)]
    for i in range(N):
        d = dist_from_start[starts[i]]
        edges[i] = [v-1 for v in range(1, V+1) if d[v] <= T]
    return edges

def hopcroft_karp(N, V, adjL):
    pairU = [-1] * N
    pairV = [-1] * V
    dist = [0] * N

    def bfs():
        q = deque()
        for u in range(N):
            if pairU[u] == -1:
                dist[u] = 0
                q.append(u)
            else:
                dist[u] = -1
        found_free = False
        while q:
            u = q.popleft()
            for v in adjL[u]:
                pu = pairV[v]
                if pu != -1 and dist[pu] == -1:
                    dist[pu] = dist[u] + 1
                    q.append(pu)
                if pu == -1:
                    found_free = True
        return found_free

    def dfs(u):
        for v in adjL[u]:
            pu = pairV[v]
            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):
                pairU[u] = v
                pairV[v] = u
                return True
        dist[u] = -1
        return False

    matching = 0
    while bfs():
        for u in range(N):
            if pairU[u] == -1 and dfs(u):
                matching += 1
    return matching

def feasible(N, V, K, starts, dist_from_start, T):
    edges = build_edges_by_T(N, V, starts, dist_from_start, T)
    return hopcroft_karp(N, V, edges) >= K

def solve_case(V, E, N, K, starts, edge_list):
    adj = [[] for _ in range(V + 1)]
    for a, b, w in edge_list:
        adj[a].append((b, w))
        adj[b].append((a, w))
    uniq_starts = sorted(set(starts))
    dist_from_start = {s: dijkstra(V, adj, s) for s in uniq_starts}
    if not feasible(N, V, K, starts, dist_from_start, CAP_MAX):
        return -1
    lo, hi = 0, CAP_MAX
    while lo < hi:
        mid = (lo + hi) // 2
        if feasible(N, V, K, starts, dist_from_start, mid):
            hi = mid
        else:
            lo = mid + 1
    return lo

def read_input(data: str):
    it = iter(data.strip().split())
    V = int(next(it)); E = int(next(it)); N = int(next(it)); K = int(next(it))
    starts = [int(next(it)) for _ in range(N)]
    edges = []
    for _ in range(E):
        a = int(next(it)); b = int(next(it)); w = int(next(it))
        edges.append((a, b, w))
    return V, E, N, K, starts, edges

def solve_all():
    data = sys.stdin.read()
    if not data.strip():
        return
    V, E, N, K, starts, edges = read_input(data)
    ans = solve_case(V, E, N, K, starts, edges)
    print(ans)

def _ref_tests():
    V, E, N, K = 3, 2, 2, 2
    starts = [1, 3]
    edges = [(1, 2, 5), (2, 3, 5)]
    assert solve_case(V, E, N, K, starts, edges) == 0
    V, E, N, K = 3, 1, 2, 2
    starts = [1, 1]
    edges = [(1, 2, 7)]
    assert solve_case(V, E, N, K, starts, edges) == 7
    V, E, N, K = 1, 0, 2, 2
    starts = [1, 1]
    edges = []
    assert solve_case(V, E, N, K, starts, edges) == -1

if __name__ == "__main__":
    _ref_tests()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to bipartite matching between teams and cities reachable within time $T$; binary search the minimal feasible $T$.}
\WHY{Combines shortest paths with matching and binary search, a common pattern in graph scheduling and assignment problems.}
\CHECKLIST{Determine monotonic predicate; precompute Dijkstra from distinct starts; implement matching; binary search; handle impossibility at cap.}
\EDGECASES{All teams start at one city; $T=0$; disconnected components; multiple parallel edges; $K=N$; $K=1$; graph with $V=1$; edges with large weights; teams starting at cities unreachable from others.}
\PITFALLS{Off-by-one in city indexing between $1$-based input and $0$-based matching; forgetting that multiple teams can share a start; building edges per $T$ inefficiently without precomputed distances; not checking infeasibility before binary search; recursion depth if using DFS recursively in Python on large inputs (use iterative or limited recursion).}
\FAILMODES{Greedy assignment fails due to not considering global constraints; scanning $T$ linearly times out; using BFS on weighted graph yields wrong distances. The proposed method avoids these.}
\ELI{Each team can reach a set of cities by time $T$. We want to pick $K$ different cities, each assigned to a distinct team that can reach it. Check if this is possible for a given $T$, and then search for the smallest $T$ for which it is possible.}
\NotePages{3}

\end{document}