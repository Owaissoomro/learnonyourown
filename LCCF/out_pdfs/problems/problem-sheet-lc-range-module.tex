% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Range Module}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/range-module/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{A Range Module tracks ranges of numbers. Design a data structure to track ranges represented as \textbf{half-open intervals} and to query them.

A \textbf{half-open interval} $[left, right)$ denotes all real numbers $x$ where $left \le x < right$.

Implement the \texttt{RangeModule} class:
\begin{bullets}
\item \texttt{RangeModule()} initializes the data structure.
\item \texttt{void addRange(int left, int right)} adds the half-open interval $[left, right)$, tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in $[left, right)$ that are not already tracked.
\item \texttt{boolean queryRange(int left, int right)} returns \texttt{true} if every real number in $[left, right)$ is currently being tracked, and \texttt{false} otherwise.
\item \texttt{void removeRange(int left, int right)} stops tracking every real number currently being tracked in the half-open interval $[left, right)$.
\end{bullets}

\textbf{Example 1:}
\begin{tcolorbox}
Input\\
\quad \texttt{["RangeModule","addRange","removeRange","queryRange","queryRange","queryRange"]}\\
\quad \texttt{[[],[10,20],[14,16],[10,14],[13,15],[16,17]]}\\
Output\\
\quad \texttt{[null,null,null,true,false,true]}\\[3pt]
Explanation\\
\quad \texttt{RangeModule rangeModule = new RangeModule();}\\
\quad \texttt{rangeModule.addRange(10, 20);} \\
\quad \texttt{rangeModule.removeRange(14, 16);} \\
\quad \texttt{rangeModule.queryRange(10, 14);} returns \texttt{true} (every number in $[10,14)$ is tracked).\\
\quad \texttt{rangeModule.queryRange(13, 15);} returns \texttt{false} (numbers like $14, 14.03, 14.17$ in $[13,15)$ are not tracked).\\
\quad \texttt{rangeModule.queryRange(16, 17);} returns \texttt{true} (the number $16$ in $[16,17)$ is still tracked despite the removal).
\end{tcolorbox}

\textbf{Constraints:}
\begin{bullets}
\item $1 \le left < right \le 10^9$.
\item At most $10^4$ calls are made to \texttt{addRange}, \texttt{queryRange}, and \texttt{removeRange}.
\end{bullets}}
\BREAKDOWN{Maintain the union of tracked half-open intervals in a canonical, disjoint, sorted form. Implement add by merging overlaps, remove by subtracting and possibly splitting intervals, and query by checking whether $[left,right)$ lies inside one stored interval.}
\ELI{Keep a sorted list of non-overlapping ranges; add merges ranges, remove cuts them, and query checks containment by binary search.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{This is a design class with methods:
\begin{bullets}
\item \texttt{addRange(left: int, right: int)} with $1 \le left < right \le 10^9$.
\item \texttt{queryRange(left: int, right: int)} with $1 \le left < right \le 10^9$.
\item \texttt{removeRange(left: int, right: int)} with $1 \le left < right \le 10^9$.
\end{bullets}
All ranges are half-open $[left,right)$.}
\OUTPUTS{\texttt{queryRange} returns a boolean. \texttt{addRange} and \texttt{removeRange} return nothing.}
\SAMPLES{\textbf{Sample A}
\begin{tcolorbox}
\texttt{addRange(5, 8)}\\
\texttt{queryRange(5, 7)} $\to$ \texttt{true}\\
\texttt{removeRange(6, 7)}\\
\texttt{queryRange(6, 7)} $\to$ \texttt{false}
\end{tcolorbox}
\textbf{Sample B}
\begin{tcolorbox}
\texttt{addRange(1, 3)}; \texttt{addRange(3, 5)}\\
\texttt{queryRange(2, 4)} $\to$ \texttt{true}\\
\texttt{removeRange(2, 3)}\\
\texttt{queryRange(2, 3)} $\to$ \texttt{false}\\
\texttt{queryRange(1, 2)} $\to$ \texttt{true}
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $U \subseteq \mathbb{R}$ denote the set of tracked points. Initially $U = \varnothing$. Each operation updates or queries $U$ using half-open intervals $[l,r)$.}
\varmapStart
\var{U}{current tracked set, union of disjoint half-open intervals}
\var{[l,r)}{incoming operation interval with $l<r$}
\var{\mathcal{I}}{sorted list of disjoint intervals whose union equals $U$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Add:}\quad & U \leftarrow U \cup [l,r) \\
\text{Remove:}\quad & U \leftarrow U \setminus [l,r) \\
\text{Query:}\quad & \text{return } \big([l,r) \subseteq U\big)
\end{aligned}
\]
}
\ASSUMPTIONS{Maintain $\mathcal{I}$ as disjoint, sorted by left endpoint, merging adjacent intervals (e.g., $[a,b)$ and $[b,c)$ become $[a,c)$) for a canonical form.}
\INVARIANTS{
\begin{bullets}
\item Disjointness: Consecutive intervals satisfy $r_i \le l_{i+1}$.
\item Sortedness: Left endpoints are non-decreasing.
\item Canonicality: No two intervals can be merged further; if $r_i = l_{i+1}$, they are stored as one $[l_i,r_{i+1})$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Represent $U$ as a list of intervals. On every add, append and re-normalize by sorting and merging globally. On remove, rebuild by subtracting from each interval. Query scans linearly for a containing interval.}
\ASSUMPTIONS{Simple, straightforward correctness; not optimized for per-operation time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Store intervals in a list. For \texttt{addRange}, append $[l,r)$ and then sort and merge overlapping/adjacent intervals in one pass.
\item For \texttt{removeRange}, for each stored $[a,b)$, subtract $[l,r)$ producing up to two pieces.
\item For \texttt{queryRange}, linearly scan for an interval $[a,b)$ with $a \le l$ and $r \le b$.
\end{algosteps}
\COMPLEXITY{Let $n$ be the number of stored intervals.
\[
\begin{aligned}
T_{\text{add}}(n) &= O(n \log n) \text{ (sort) } + O(n) \text{ (merge)} = O(n \log n),\\
T_{\text{remove}}(n) &= O(n),\quad T_{\text{query}}(n) = O(n),\quad S(n) = O(n).
\end{aligned}
\]
}
\CORRECTNESS{Global re-merge after each add ensures the invariant that intervals are disjoint, sorted, and maximally merged, making remove and query straightforward and correct under half-open semantics.}
\EDGECASES{Ignore no-op intervals with $l \ge r$; correctly handle adjacency ($b=a'$) by merging; removals that fully erase or split intervals.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class RangeModule:
    def __init__(self):
        self.iv: List[List[int]] = []

    def _merge_all(self) -> None:
        if not self.iv:
            return
        self.iv.sort()  # sort by left, then right
        merged: List[List[int]] = []
        for l, r in self.iv:
            if not merged or merged[-1][1] < l:
                merged.append([l, r])
            else:
                # overlap or adjacency; merge into last
                if r > merged[-1][1]:
                    merged[-1][1] = r
        self.iv = merged

    def addRange(self, left: int, right: int) -> None:
        if left >= right:
            return
        self.iv.append([left, right])
        self._merge_all()

    def queryRange(self, left: int, right: int) -> bool:
        if left >= right:
            return True
        for l, r in self.iv:
            if l <= left and right <= r:
                return True
            if l > left:
                break
        return False

    def removeRange(self, left: int, right: int) -> None:
        if left >= right or not self.iv:
            return
        new_iv: List[List[int]] = []
        for l, r in self.iv:
            if r <= left or right <= l:
                new_iv.append([l, r])
            else:
                if l < left:
                    new_iv.append([l, left])
                if right < r:
                    new_iv.append([right, r])
        self.iv = new_iv

# LeetCode wrapper (not used by the platform here) plus asserts for validation
class Solution:
    def dummy(self) -> int:
        return 0

# Baseline sanity checks
rm = RangeModule()
rm.addRange(10, 20)
rm.removeRange(14, 16)
assert rm.queryRange(10, 14) is True
assert rm.queryRange(13, 15) is False
assert rm.queryRange(16, 17) is True
\end{minted}
\VALIDATION{Checks include: removing a middle slice splits an interval; adjacency merges: adding $[1,3)$ then $[3,5)$ yields coverage of $[1,5)$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Maintain disjoint, sorted intervals without global sort on every add. Build new lists in a single linear pass per update; accelerate queries with binary search via \texttt{bisect}.}
\ASSUMPTIONS{Intervals remain disjoint and sorted; adjacency is merged. Python \texttt{bisect} provides $O(\log n)$ query positioning.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item \texttt{addRange}: scan once, merging overlaps with $[l,r)$ into one expanded interval, copying others unchanged.
\item \texttt{removeRange}: scan once, subtracting $[l,r)$ from each interval and emitting up to two pieces.
\item \texttt{queryRange}: binary search the predecessor interval of $left$ and test containment.
\end{algosteps}
\COMPLEXITY{Per operation with $n$ stored intervals:
\[
\begin{aligned}
T_{\text{add}}(n) &= O(n),\quad T_{\text{remove}}(n) = O(n),\quad T_{\text{query}}(n) = O(\log n),\quad S(n)=O(n).
\end{aligned}
\]
}
\CORRECTNESS{Single-pass reconstruction preserves order and disjointness. Binary search finds the only interval that could contain $[l,r)$ due to disjointness and sortedness.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from bisect import bisect_right

class RangeModule:
    def __init__(self):
        self.iv: List[List[int]] = []  # disjoint, sorted, merged

    def addRange(self, left: int, right: int) -> None:
        if left >= right:
            return
        nl, nr = left, right
        res: List[List[int]] = []
        placed = False
        for l, r in self.iv:
            if r < nl:
                res.append([l, r])
            elif nr < l:
                if not placed:
                    res.append([nl, nr])
                    placed = True
                res.append([l, r])
            else:
                nl = min(nl, l)
                nr = max(nr, r)
        if not placed:
            res.append([nl, nr])
        self.iv = res

    def removeRange(self, left: int, right: int) -> None:
        if left >= right:
            return
        res: List[List[int]] = []
        for l, r in self.iv:
            if r <= left or right <= l:
                res.append([l, r])
            else:
                if l < left:
                    res.append([l, left])
                if right < r:
                    res.append([right, r])
        self.iv = res

    def queryRange(self, left: int, right: int) -> bool:
        if left >= right:
            return True
        # find the interval with left endpoint <= left using bisect_right
        i = bisect_right(self.iv, [left, float('inf')]) - 1
        return i >= 0 and self.iv[i][0] <= left and right <= self.iv[i][1]

class Solution:
    def dummy(self) -> int:
        return 0

# Improved sanity checks
rm = RangeModule()
rm.addRange(5, 8)
assert rm.queryRange(5, 7) is True
rm.removeRange(6, 7)
assert rm.queryRange(6, 7) is False
# Adjacency merge
rm.addRange(7, 10)
assert rm.queryRange(5, 10) is True
\end{minted}
\VALIDATION{Edge checks: zero-width updates are no-ops; queries with $[l,r)$ exactly matching a stored interval return \texttt{true}; removal at boundaries preserves half-open semantics.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use binary search to find the affected slice of intervals for updates, then splice in $O(k)$ time where $k$ is the number of overlapping intervals. Query in $O(\log n)$. This achieves optimal $O(\log n + k)$ per update for ordered lists.}
\ASSUMPTIONS{Intervals are stored in a Python list sorted by left endpoint; comparisons are lexicographic.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For \texttt{addRange}:
\begin{bullets}
\item Find insertion index $i$ by \texttt{bisect\_left}. If the predecessor overlaps, step to it.
\item While overlaps/adjacency exist, merge into $[L,R)$ and delete covered intervals.
\item Insert the merged interval at index $i$.
\end{bullets}
\item For \texttt{removeRange}:
\begin{bullets}
\item Find starting index similarly. While overlapping:
\item Split or trim intervals according to four cases; delete fully covered ones; stop when no overlap.
\end{bullets}
\item For \texttt{queryRange}, binary search the predecessor of $left$ and test containment.
\end{algosteps}
\OPTIMALITY{Any comparison-based structure maintaining a sorted list must touch all overlapping intervals $k$ to update their boundaries; thus $O(\log n + k)$ is tight.}
\COMPLEXITY{
\[
\begin{aligned}
T_{\text{add/remove}}(n) &= O(\log n + k),\quad T_{\text{query}}(n) = O(\log n),\quad S(n)=O(n).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from bisect import bisect_left, bisect_right

class RangeModule:
    def __init__(self):
        self.iv: List[List[int]] = []  # sorted, disjoint, merged

    def addRange(self, left: int, right: int) -> None:
        if left >= right:
            return
        iv = self.iv
        i = bisect_left(iv, [left, left])
        if i > 0 and iv[i - 1][1] >= left:
            i -= 1
        L, R = left, right
        # Merge overlapping/adjacent intervals starting at i
        j = i
        while j < len(iv) and iv[j][0] <= R:
            L = min(L, iv[j][0])
            R = max(R, iv[j][1])
            j += 1
        # splice: replace iv[i:j] with [L,R]
        iv[i:j] = [[L, R]]

    def removeRange(self, left: int, right: int) -> None:
        if left >= right:
            return
        iv = self.iv
        i = bisect_left(iv, [left, left])
        if i > 0 and iv[i - 1][1] > left:
            i -= 1
        res_prefix = iv[:i]
        res_mid: List[List[int]] = []
        j = i
        while j < len(iv) and iv[j][0] < right:
            l, r = iv[j]
            if l < left and right < r:
                # split into two
                res_mid.append([l, left])
                res_mid.append([right, r])
            elif l < left and r <= right:
                # trim right side
                res_mid.append([l, left])
            elif left <= l and right < r:
                # trim left side; keep tail and stop overlaps
                res_mid.append([right, r])
            else:
                # fully covered (left <= l and r <= right): drop
                pass
            j += 1
        iv[:] = res_prefix + res_mid + iv[j:]

    def queryRange(self, left: int, right: int) -> bool:
        if left >= right:
            return True
        i = bisect_right(self.iv, [left, float('inf')]) - 1
        return i >= 0 and self.iv[i][0] <= left and right <= self.iv[i][1]

class Solution:
    # Placeholder to satisfy LC block structure in this sheet; not used by platform.
    def dummy(self) -> int:
        return 0

# Final validation tests (exactly 3)
rm = RangeModule()
rm.addRange(10, 20)
rm.removeRange(14, 16)
assert rm.queryRange(10, 14) is True
assert rm.queryRange(13, 15) is False
assert rm.queryRange(16, 17) is True
\end{minted}
\VALIDATION{Three asserts mirror the official example.}
\RESULT{A fully functional \texttt{RangeModule} with $O(\log n)$ query and $O(\log n + k)$ updates, canonicalizing intervals via merging and precise half-open subtraction when removing.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for: empty structure; adjacency merges; full cover removal; interior removal that splits; idempotent add; repeated remove; random sequences cross-checked by a slow reference.}
\LINE{CROSS-CHECKS}{Compare Approach A vs C on small random sequences by replaying the same operations and asserting identical query results for sampled ranges.}
\LINE{EDGE-CASE GENERATOR}{Generate boundaries near $1$ and $10^9$, tiny ranges (length $1$), and adjacency stress ($[x,y)$ then $[y,z)$).}
\begin{minted}{python}
import random
from bisect import bisect_right
from typing import List, Tuple

# Deterministic generators for boundaries, degenerates, adversarials
def gen_ops(seed: int = 0, n: int = 200) -> List[Tuple[str, int, int]]:
    rng = random.Random(seed)
    ops = []
    for _ in range(n):
        typ = rng.choice(['add','rem','qry'])
        a = rng.randint(1, 10**6)
        b = a + rng.randint(1, 50)
        if typ == 'add':
            ops.append(('add', a, b))
        elif typ == 'rem':
            ops.append(('rem', a, b))
        else:
            ops.append(('qry', a, b))
    # sprinkle boundary/adjacency cases
    ops += [('add', 1, 2), ('add', 2, 3), ('qry', 1, 3), ('rem', 2, 3), ('qry', 2, 3)]
    return ops

class RangeModuleSlow:
    # Canonical but simpler baseline
    def __init__(self):
        self.iv: List[List[int]] = []
    def _merge_all(self):
        if not self.iv:
            return
        self.iv.sort()
        merged = []
        for l, r in self.iv:
            if not merged or merged[-1][1] < l:
                merged.append([l, r])
            else:
                if r > merged[-1][1]: merged[-1][1] = r
        self.iv = merged
    def addRange(self, left: int, right: int) -> None:
        if left >= right: return
        self.iv.append([left, right])
        self._merge_all()
    def removeRange(self, left: int, right: int) -> None:
        if left >= right: return
        new = []
        for l, r in self.iv:
            if r <= left or right <= l:
                new.append([l, r])
            else:
                if l < left: new.append([l, left])
                if right < r: new.append([right, r])
        self.iv = new
    def queryRange(self, left: int, right: int) -> bool:
        for l, r in self.iv:
            if l <= left and right <= r: return True
            if l > left: break
        return False

from bisect import bisect_left

class RangeModuleFast:
    def __init__(self):
        self.iv: List[List[int]] = []
    def addRange(self, left: int, right: int) -> None:
        if left >= right: return
        i = bisect_left(self.iv, [left, left])
        if i > 0 and self.iv[i-1][1] >= left: i -= 1
        L, R = left, right
        j = i
        while j < len(self.iv) and self.iv[j][0] <= R:
            L = min(L, self.iv[j][0])
            R = max(R, self.iv[j][1])
            j += 1
        self.iv[i:j] = [[L, R]]
    def removeRange(self, left: int, right: int) -> None:
        if left >= right: return
        i = bisect_left(self.iv, [left, left])
        if i > 0 and self.iv[i-1][1] > left: i -= 1
        res = self.iv[:i]
        j = i
        mid = []
        while j < len(self.iv) and self.iv[j][0] < right:
            l, r = self.iv[j]
            if l < left and right < r:
                mid.append([l, left])
                mid.append([right, r])
            elif l < left and r <= right:
                mid.append([l, left])
            elif left <= l and right < r:
                mid.append([right, r])
            else:
                pass
            j += 1
        self.iv[:] = res + mid + self.iv[j:]
    def queryRange(self, left: int, right: int) -> bool:
        i = bisect_right(self.iv, [left, float('inf')]) - 1
        return i >= 0 and self.iv[i][0] <= left and right <= self.iv[i][1]

def cross_check():
    ops = gen_ops(7, 300)
    slow = RangeModuleSlow()
    fast = RangeModuleFast()
    for typ, a, b in ops:
        if typ == 'add':
            slow.addRange(a, b); fast.addRange(a, b)
        elif typ == 'rem':
            slow.removeRange(a, b); fast.removeRange(a, b)
        else:
            assert slow.queryRange(a, b) == fast.queryRange(a, b)
    # basic example
    rm = RangeModuleFast()
    rm.addRange(10, 20)
    rm.removeRange(14, 16)
    assert rm.queryRange(10, 14) is True
    assert rm.queryRange(13, 15) is False
    assert rm.queryRange(16, 17) is True

cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from bisect import bisect_left, bisect_right

class RangeModule:
    def __init__(self):
        self.iv: List[List[int]] = []  # disjoint, sorted, merged

    def addRange(self, left: int, right: int) -> None:
        if left >= right:
            return
        i = bisect_left(self.iv, [left, left])
        if i > 0 and self.iv[i - 1][1] >= left:
            i -= 1
        L, R = left, right
        j = i
        while j < len(self.iv) and self.iv[j][0] <= R:
            L = min(L, self.iv[j][0])
            R = max(R, self.iv[j][1])
            j += 1
        self.iv[i:j] = [[L, R]]

    def removeRange(self, left: int, right: int) -> None:
        if left >= right:
            return
        i = bisect_left(self.iv, [left, left])
        if i > 0 and self.iv[i - 1][1] > left:
            i -= 1
        prefix = self.iv[:i]
        mid: List[List[int]] = []
        j = i
        while j < len(self.iv) and self.iv[j][0] < right:
            l, r = self.iv[j]
            if l < left and right < r:
                mid.append([l, left])
                mid.append([right, r])
            elif l < left and r <= right:
                mid.append([l, left])
            elif left <= l and right < r:
                mid.append([right, r])
            else:
                pass
            j += 1
        self.iv[:] = prefix + mid + self.iv[j:]

    def queryRange(self, left: int, right: int) -> bool:
        if left >= right:
            return True
        i = bisect_right(self.iv, [left, float('inf')]) - 1
        return i >= 0 and self.iv[i][0] <= left and right <= self.iv[i][1]

# Minimal Solution wrapper to satisfy sheet contract + asserts
class Solution:
    def dummy(self) -> int:
        return 0

# Reference asserts
rm = RangeModule()
rm.addRange(1, 3)
rm.addRange(3, 5)
assert rm.queryRange(1, 5) is True
rm.removeRange(2, 4)
assert rm.queryRange(1, 2) is True
assert rm.queryRange(2, 4) is False
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain a canonical union of half-open intervals with $O(\log n)$ queries and $O(\log n + k)$ updates.}
\WHY{Common in design interviews to test interval algebra, careful boundary handling, and data structure invariants.}
\CHECKLIST{
\begin{bullets}
\item Enforce half-open semantics consistently.
\item Merge adjacency on add.
\item Use binary search to find predecessor interval for query/update.
\item On remove, handle the four overlap cases (none, trim-left, trim-right, split).
\item Keep intervals sorted and disjoint after every op.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item No-op ranges with $l \ge r$.
\item Removing outside current coverage (should do nothing).
\item Removing exactly an endpoint (e.g., $[a,b)$ remove $[b,c)$ leaves unchanged).
\item Adjacent adds $[a,b)$ then $[b,c)$ must merge to $[a,c)$.
\item Full cover removal of an interval.
\item Split removal where $l<a<r<b$.
\item Query on a boundary $[b,c)$ where $b$ equals a stored right endpoint.
\item Large values near $10^9$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one at half-open boundaries when trimming.
\item Forgetting to merge adjacency ($r==l'$) leading to redundant intervals.
\item Using linear scan for query when $O(\log n)$ is easy via \texttt{bisect}.
\item Not updating indices correctly when splicing lists during iteration.
\item Sorting on every add unnecessarily.
\item Allowing overlapping intervals to persist, breaking query correctness.
\end{bullets}}
\FAILMODES{Naive unsorted storage with on-the-fly merge in query will time out for many operations; the optimized method touches only overlapping intervals and uses binary search to localize work.}
\ELI{We keep a clean, ordered list of non-overlapping ranges. Adding sticks nearby ranges together; removing cuts them apart. To check if a range is tracked, we jump with binary search to the only candidate interval and see if it fully contains the query.}
\NotePages{3}

\end{document}