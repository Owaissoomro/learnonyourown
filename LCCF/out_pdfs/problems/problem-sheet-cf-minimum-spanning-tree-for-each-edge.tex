% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum spanning tree for each edge}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/609/E}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{Connected undirected weighted graph without self-loops and multiple edges is given. Graph contains $n$ vertices and $m$ edges.

For each edge $(u,v)$ find the minimal possible weight of the spanning tree that contains the edge $(u,v)$.

The weight of the spanning tree is the sum of weights of all edges included in spanning tree.

Input:

First line contains two integers $n$ and $m$ ($1 \le n \le 2\cdot 10^5$, $n - 1 \le m \le 2\cdot 10^5$) — the number of vertices and edges in graph.

Each of the next $m$ lines contains three integers $u_i$, $v_i$, $w_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$, $1 \le w_i \le 10^9$) — the endpoints of the $i$-th edge and its weight.

Output:

Print $m$ lines. $i$-th line should contain the minimal possible weight of the spanning tree that contains $i$-th edge.

The edges are numbered from $1$ to $m$ in order of their appearing in input.}
\BREAKDOWN{Compute one minimum spanning tree (MST) and answer, for every edge, the minimal total weight of an MST that is constrained to include that edge. This reduces to replacing on the unique MST path between its endpoints the maximum-weight edge.}
\ELI{MST plus an extra edge forms a cycle; to force-include the edge, drop the heaviest edge on that cycle.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test. Integers $n$, $m$; then $m$ triples $(u_i, v_i, w_i)$ with $1 \le u_i, v_i \le n$, $u_i \ne v_i$, $1 \le w_i \le 10^9$. The graph is connected, simple.}
\OUTPUTS{Print $m$ lines: for each input edge in order, print the minimal total weight among spanning trees that contain that edge.}
\SAMPLES{Example:

Input
3 3
1 2 1
2 3 2
1 3 3

Output
3
3
4

Explanation: An MST has weight $3$. For edge $(1,3,3)$, the maximum on the MST path $(1\text{--}2\text{--}3)$ is $2$, so $3 + 3 - 2 = 4$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E,w)$ be a connected simple undirected weighted graph. Let $T$ be a fixed MST with total weight $W_T$. For any edge $e=(u,v)$ with weight $w_e$, the fundamental cycle $C_e$ formed by adding $e$ to $T$ contains the unique path $P_T(u,v)$ in $T$.}
\varmapStart
\var{G}{input graph}
\var{T}{a chosen MST of $G$}
\var{W_T}{total weight of $T$}
\var{e=(u,v)}{queried edge with weight $w_e$}
\var{P_T(u,v)}{unique simple path between $u$ and $v$ in $T$}
\var{\max_T(u,v)}{maximum edge weight on $P_T(u,v)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Ans}(e) \;=\; W_T \;+\; w_e \;-\; \max_T(u,v).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Graph is connected and simple; edge weights are positive integers but may repeat. Any MST suffices since $\max_T(u,v)$ over an MST is well-defined for the formula.}
\INVARIANTS{
- Adding $e$ to $T$ creates exactly one cycle $C_e$.

- The optimal way to include $e$ is to remove a heaviest edge on $C_e$; removing any lighter edge cannot improve the total.

- For $e\in T$, the heaviest edge on $P_T(u,v)$ equals $w_e$, so $\text{Ans}(e)=W_T$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the governing formula $\text{Ans}(e)=W_T+w_e-\max_T(u,v)$. Build one MST, then for each edge compute $\max_T(u,v)$ by a linear tree walk.}
\ASSUMPTIONS{We can traverse the MST in $O(n)$ per query, which is acceptable only for tiny graphs but serves as a correctness baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Run Kruskal to build an MST $T$ and compute $W_T$; also store $T$ as an adjacency list.
\item For each query edge $(u,v,w)$, run a BFS/DFS on $T$ from $u$ to reach $v$, tracking the maximum edge weight seen along the discovered path.
\item Output $W_T + w - \text{pathMax}(u,v)$.
\end{algosteps}
\COMPLEXITY{For $n$ nodes, $m$ edges:
\[
\begin{aligned}
T(n,m) &= O(m \log m) \;+\; m\cdot O(n) \\
       &= O(m \log m + mn), \\
S(n,m) &= O(n + m).
\end{aligned}
\]
}
\CORRECTNESS{Each query uses the exact path in the MST, and the maximum edge on that path is precisely the heaviest edge on the unique cycle formed by adding $(u,v)$, hence the formula holds.}
\EDGECASES{Edge lies in MST; multiple edges with same weight on the path; star or line graphs; $n=1$ or $m=n-1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return 0, 0, []
    n = it[0]; m = it[1]
    edges = []
    p = 2
    for i in range(m):
        u = it[p]; v = it[p+1]; w = it[p+2]; p += 3
        edges.append((u-1, v-1, w, i))  # 0-index internally
    return n, m, edges

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def build_mst(n, edges):
    dsu = DSU(n)
    g = [[] for _ in range(n)]
    total = 0
    for w,u,v,idx in sorted((w,u,v,idx) for (u,v,w,idx) in edges):
        if dsu.union(u, v):
            g[u].append((v, w))
            g[v].append((u, w))
            total += w
    return total, g

def path_max_bfs(g, u, v):
    n = len(g)
    q = deque([u])
    seen = [-1]*n
    seen[u] = -2
    max_on_path = [0]*n
    while q:
        x = q.popleft()
        if x == v:
            return max_on_path[x]
        for y, w in g[x]:
            if seen[y] == -1:
                seen[y] = x
                max_on_path[y] = max(max_on_path[x], w)
                q.append(y)
    return 0

def solve_all(n, m, edges):
    total, g = build_mst(n, edges)
    ans = [0]*m
    for (u,v,w,idx) in edges:
        mx = path_max_bfs(g, u, v)
        ans[idx] = total + w - mx
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests
        n, m, edges = 3, 3, [(0,1,1,0),(1,2,2,1),(0,2,3,2)]
        out = solve_all(n,m,edges)
        assert out == [3,3,4]
        n, m = 4, 5
        edges = [(0,1,1,0),(1,2,1,1),(2,3,1,2),(3,0,1,3),(0,2,2,4)]
        out = solve_all(n,m,edges)
        assert out == [3,3,3,3,4]
        n, m, edges = 2, 1, [(0,1,5,0)]
        assert solve_all(n,m,edges) == [5]
        return
    n, m, edges = read_input(data)
    ans = solve_all(n, m, edges)
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked with three deterministic asserts in main(): a triangle, a 4-cycle with a diagonal, and a single-edge graph.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Keep the same formula, but answer $\max_T(u,v)$ in $O(\log n)$ using binary lifting (LCA) with per-jump maximum edge weights.}
\ASSUMPTIONS{The MST is a tree; preprocess depth, $2^k$-ancestors, and maximum edge weight to each ancestor.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build MST $T$ and compute total weight $W_T$ using Kruskal.
\item Root $T$ arbitrarily; compute depth, parent up-jumps, and max-edge-to-parent for each power of two using a DFS/BFS and DP up to $\lceil \log_2 n\rceil$.
\item For each edge $(u,v,w)$, lift the deeper node up to the same depth while tracking the max; then lift both up together while merging maxes; finally combine one-step parents. Output $W_T + w - \text{max\_path}(u,v)$.
\end{algosteps}
\COMPLEXITY{Preprocessing $O(n \log n)$ time and $O(n \log n)$ space. Each query in $O(\log n)$, so total $O(m \log n)$ after Kruskal $O(m \log m)$.}
\[
\begin{aligned}
T(n,m) &= O(m\log m) + O(n\log n) + O(m\log n),\\
S(n,m) &= O(n\log n) + O(n+m).
\end{aligned}
\]
\CORRECTNESS{Binary lifting preserves the maximum along the lifted segments; combining segments yields the maximum on the entire path. The cycle-exchange argument ensures optimality of replacing the heaviest edge on the cycle.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return 0, 0, []
    n = it[0]; m = it[1]
    edges = []
    p = 2
    for i in range(m):
        u = it[p]; v = it[p+1]; w = it[p+2]; p += 3
        edges.append((u-1, v-1, w, i))
    return n, m, edges

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def build_mst(n, edges):
    dsu = DSU(n)
    g = [[] for _ in range(n)]
    total = 0
    for w,u,v,idx in sorted((w,u,v,idx) for (u,v,w,idx) in edges):
        if dsu.union(u, v):
            g[u].append((v, w))
            g[v].append((u, w))
            total += w
    return total, g

def preprocess_lca(g):
    n = len(g)
    LOG = max(1, (n).bit_length())
    up = [[-1]*n for _ in range(LOG)]
    mx = [[0]*n for _ in range(LOG)]
    depth = [0]*n
    # BFS to set depth and up[0], mx[0]
    root = 0
    q = deque([root])
    up[0][root] = root
    mx[0][root] = 0
    seen = [False]*n
    seen[root] = True
    while q:
        x = q.popleft()
        for y, w in g[x]:
            if not seen[y]:
                seen[y] = True
                depth[y] = depth[x] + 1
                up[0][y] = x
                mx[0][y] = w
                q.append(y)
    for k in range(1, LOG):
        for v in range(n):
            p = up[k-1][v]
            up[k][v] = up[k-1][p]
            mx[k][v] = max(mx[k-1][v], mx[k-1][p])
    return up, mx, depth

def max_on_path(u, v, up, mx, depth):
    if u == v: return 0
    LOG = len(up)
    res = 0
    if depth[u] < depth[v]:
        u, v = v, u
    # Lift u
    diff = depth[u] - depth[v]
    for k in range(LOG-1, -1, -1):
        if diff & (1 << k):
            res = max(res, mx[k][u])
            u = up[k][u]
    if u == v: return res
    # Lift both
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            res = max(res, mx[k][u], mx[k][v])
            u = up[k][u]
            v = up[k][v]
    # One more step to LCA
    res = max(res, mx[0][u], mx[0][v])
    return res

def solve_all(n, m, edges):
    total, g = build_mst(n, edges)
    up, mx, depth = preprocess_lca(g)
    ans = [0]*m
    for (u,v,w,idx) in edges:
        mxp = max_on_path(u, v, up, mx, depth)
        ans[idx] = total + w - mxp
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests
        n, m, edges = 3, 3, [(0,1,1,0),(1,2,2,1),(0,2,3,2)]
        out = solve_all(n,m,edges)
        assert out == [3,3,4]
        n, m = 4, 5
        edges = [(0,1,1,0),(1,2,1,1),(2,3,1,2),(3,0,1,3),(0,2,2,4)]
        out = solve_all(n,m,edges)
        assert out == [3,3,3,3,4]
        n, m, edges = 2, 1, [(0,1,5,0)]
        assert solve_all(n,m,edges) == [5]
        return
    n, m, edges = read_input(data)
    ans = solve_all(n, m, edges)
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three deterministic asserts identical to the Baseline section to cross-check correctness.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Kruskal to get an MST and its total $W_T$; binary lifting LCA with max-edge lifting to answer each edge in $O(\log n)$ using $\text{Ans}(e)=W_T+w_e-\max_T(u,v)$.}
\ASSUMPTIONS{Graph connected and simple; weights arbitrary positive integers; any MST suffices.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort edges by weight and run Kruskal to form $T$ and $W_T$.
\item Root $T$; preprocess $up[k][v]$ and $mx[k][v]$ (max edge to the $2^k$-ancestor) along with depth.
\item For each edge $(u,v,w)$, compute $M=\max_T(u,v)$ via lifting and output $W_T + w - M$.
\end{algosteps}
\OPTIMALITY{By the cycle property of MSTs, among all spanning trees that contain $e$, the optimal is obtained by removing a maximum-weight edge on the unique cycle formed when adding $e$ to an MST. No better replacement exists; any lighter removal would raise the total or disconnect the graph.}
\COMPLEXITY{End-to-end:
\[
\begin{aligned}
T(n,m) &= O(m\log m) + O(n\log n) + O(m\log n),\\
S(n,m) &= O(n\log n) + O(n+m).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return 0, 0, []
    n = it[0]; m = it[1]
    edges = []
    p = 2
    for i in range(m):
        u = it[p]; v = it[p+1]; w = it[p+2]; p += 3
        edges.append((u-1, v-1, w, i))
    return n, m, edges

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def build_mst(n, edges):
    dsu = DSU(n)
    g = [[] for _ in range(n)]
    total = 0
    # Sort by weight
    for w,u,v,idx in sorted((w,u,v,idx) for (u,v,w,idx) in edges):
        if dsu.union(u, v):
            g[u].append((v, w))
            g[v].append((u, w))
            total += w
    return total, g

def preprocess_lca(g):
    n = len(g)
    LOG = max(1, (n).bit_length())
    up = [[-1]*n for _ in range(LOG)]
    mx = [[0]*n for _ in range(LOG)]
    depth = [0]*n
    root = 0
    q = deque([root])
    up[0][root] = root
    mx[0][root] = 0
    seen = [False]*n
    seen[root] = True
    while q:
        x = q.popleft()
        for y, w in g[x]:
            if not seen[y]:
                seen[y] = True
                depth[y] = depth[x] + 1
                up[0][y] = x
                mx[0][y] = w
                q.append(y)
    for k in range(1, LOG):
        for v in range(n):
            p = up[k-1][v]
            up[k][v] = up[k-1][p]
            mx[k][v] = max(mx[k-1][v], mx[k-1][p])
    return up, mx, depth

def max_on_path(u, v, up, mx, depth):
    if u == v: return 0
    LOG = len(up)
    res = 0
    if depth[u] < depth[v]:
        u, v = v, u
    # Lift u up to depth v
    diff = depth[u] - depth[v]
    for k in range(LOG-1, -1, -1):
        if diff & (1 << k):
            res = max(res, mx[k][u])
            u = up[k][u]
    if u == v:
        return res
    # Lift both while parents differ
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            res = max(res, mx[k][u], mx[k][v])
            u = up[k][u]
            v = up[k][v]
    # Account for one step to LCA
    res = max(res, mx[0][u], mx[0][v])
    return res

def solve_all(n, m, edges):
    total, g = build_mst(n, edges)
    up, mx, depth = preprocess_lca(g)
    ans = [0]*m
    for (u,v,w,idx) in edges:
        ans[idx] = total + w - max_on_path(u, v, up, mx, depth)
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests (deterministic)
        n, m, edges = 3, 3, [(0,1,1,0),(1,2,2,1),(0,2,3,2)]
        assert solve_all(n,m,edges) == [3,3,4]
        n, m = 4, 5
        edges = [(0,1,1,0),(1,2,1,1),(2,3,1,2),(3,0,1,3),(0,2,2,4)]
        assert solve_all(n,m,edges) == [3,3,3,3,4]
        n, m, edges = 2, 1, [(0,1,5,0)]
        assert solve_all(n,m,edges) == [5]
        return
    n, m, edges = read_input(data)
    ans = solve_all(n, m, edges)
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts: triangle, 4-cycle with diagonal, and single-edge graph.}
\RESULT{For each input edge $e=(u,v)$, output $W_T + w_e - \max_T(u,v)$ using the preprocessed MST path maximums. Ties are naturally handled by the maximum operator; if $e$ is already in the MST, the output equals $W_T$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on canonical small graphs: triangles with unique MST, cycles with equal weights, path graphs. Property: for any edge in the MST, answer equals $W_T$.}
\LINE{CROSS-CHECKS}{Compare Baseline (BFS per query) vs Improved/Final (LCA) on tiny graphs to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate small connected graphs up to $n=6$ with varying weights and verify the formula vs brute-force recomputation by forcing edges.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def small_connected_graphs():
    # Returns a few small graphs for spot-checks
    cases = []
    # Triangle
    n, m = 3, 3
    edges = [(0,1,1,0),(1,2,2,1),(0,2,3,2)]
    cases.append((n,m,edges,[3,3,4]))
    # 4-cycle + diagonal
    n, m = 4, 5
    edges = [(0,1,1,0),(1,2,1,1),(2,3,1,2),(3,0,1,3),(0,2,2,4)]
    cases.append((n,m,edges,[3,3,3,3,4]))
    # Line of 2
    n, m = 2, 1
    edges = [(0,1,5,0)]
    cases.append((n,m,edges,[5]))
    return cases
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return 0, 0, []
    n = it[0]; m = it[1]
    edges = []
    p = 2
    for i in range(m):
        u = it[p]; v = it[p+1]; w = it[p+2]; p += 3
        edges.append((u-1, v-1, w, i))
    return n, m, edges

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def build_mst(n, edges):
    dsu = DSU(n)
    g = [[] for _ in range(n)]
    total = 0
    for w,u,v,idx in sorted((w,u,v,idx) for (u,v,w,idx) in edges):
        if dsu.union(u, v):
            g[u].append((v, w))
            g[v].append((u, w))
            total += w
    return total, g

def preprocess_lca(g):
    n = len(g)
    LOG = max(1, (n).bit_length())
    up = [[-1]*n for _ in range(LOG)]
    mx = [[0]*n for _ in range(LOG)]
    depth = [0]*n
    root = 0
    q = deque([root])
    up[0][root] = root
    mx[0][root] = 0
    seen = [False]*n
    seen[root] = True
    while q:
        x = q.popleft()
        for y, w in g[x]:
            if not seen[y]:
                seen[y] = True
                depth[y] = depth[x] + 1
                up[0][y] = x
                mx[0][y] = w
                q.append(y)
    for k in range(1, LOG):
        for v in range(n):
            p = up[k-1][v]
            up[k][v] = up[k-1][p]
            mx[k][v] = max(mx[k-1][v], mx[k-1][p])
    return up, mx, depth

def max_on_path(u, v, up, mx, depth):
    if u == v: return 0
    LOG = len(up)
    res = 0
    if depth[u] < depth[v]:
        u, v = v, u
    diff = depth[u] - depth[v]
    for k in range(LOG-1, -1, -1):
        if diff & (1 << k):
            res = max(res, mx[k][u])
            u = up[k][u]
    if u == v:
        return res
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            res = max(res, mx[k][u], mx[k][v])
            u = up[k][u]
            v = up[k][v]
    res = max(res, mx[0][u], mx[0][v])
    return res

def solve_all(n, m, edges):
    total, g = build_mst(n, edges)
    up, mx, depth = preprocess_lca(g)
    ans = [0]*m
    for (u,v,w,idx) in edges:
        ans[idx] = total + w - max_on_path(u, v, up, mx, depth)
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests
        n, m, edges = 3, 3, [(0,1,1,0),(1,2,2,1),(0,2,3,2)]
        assert solve_all(n,m,edges) == [3,3,4]
        n, m = 4, 5
        edges = [(0,1,1,0),(1,2,1,1),(2,3,1,2),(3,0,1,3),(0,2,2,4)]
        assert solve_all(n,m,edges) == [3,3,3,3,4]
        n, m, edges = 2, 1, [(0,1,5,0)]
        assert solve_all(n,m,edges) == [5]
        return
    n, m, edges = read_input(data)
    ans = solve_all(n, m, edges)
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute an MST once, then for each edge output $W_T + w_e - \max_T(u,v)$ using LCA with max-edge lifting.}
\WHY{This is a classic use of MST cycle property and LCA preprocessing; common in graph-heavy interviews and contests for batch path-aggregate queries.}
\CHECKLIST{
- Build MST with Kruskal and DSU.

- Root the MST; preprocess $up$ and $mx$ tables.

- For each edge, get path maximum in $O(\log n)$.

- Output $W_T + w_e - \max_T(u,v)$.}
\EDGECASES{
- Edge already in MST $\Rightarrow$ answer equals $W_T$.

- Multiple equal maximums on path.

- All weights equal.

- Long chains (ensure non-recursive or high recursion limit).

- Large $n$ and $m$ near $2\cdot 10^5$.

- 1-based input indices; convert carefully to 0-based internally.}
\PITFALLS{
- Forgetting to set ancestor of root to itself in lifting tables.

- Not initializing max-edge tables for root to $0$.

- Mixing 0-based and 1-based indices in answers.

- Using recursive DFS that overflows the call stack.

- Incorrect LOG size (must be $\ge \lceil \log_2 n\rceil$).

- Assuming the queried edge must be in MST; formula works for all edges.}
\FAILMODES{Baseline $O(mn)$ traversal per query will time out on large inputs. The LCA-based solution scales as $O((m+n)\log n)$ and survives the constraints.}
\ELI{Build one cheapest tree, then for each edge, imagine adding it: we get a loop. To keep a tree and include that edge, drop the heaviest edge on the loop. Precompute how heavy the heaviest edge is between any two nodes in the tree, so each answer is quick.}
\NotePages{3}

\end{document}