% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Let Me Teach You a Lesson (Easy Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1995/E1}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{This is the easy version of a problem. The only difference between an easy and a hard version is the constraints on $t$ and $n$. You can make hacks only if both versions of the problem are solved.

Arthur is giving a lesson to his famous $2 n$ knights. Like any other students, they are sitting at the desks in pairs, but out of habit in a circle. The knight $2 i - 1$ is sitting at the desk with the knight $2 i$.

Each knight has intelligence, which can be measured by an integer. Let us denote the intelligence of the $i$-th knight as $a_i$. Arthur wants the maximal difference in total intelligence over all pairs of desks to be as small as possible. More formally, he wants to minimize $\max\limits_{1 \le i \le n} (a_{2 i - 1} + a_{2 i}) - \min\limits_{1 \le i \le n} (a_{2 i - 1} + a_{2 i})$.

However, the Code of Chivalry only allows swapping the opposite knights in the circle, i.e., Arthur can simultaneously perform $a_i := a_{i + n}$, $a_{i + n} := a_i$ for any $1 \le i \le n$. Arthur can make any number of such swaps. What is the best result he can achieve?

Input:
Each test consists of several test cases. The first line contains a single integer $t$ ($1 \le t \le 1000$) — the number of test cases. It is followed by descriptions of the test cases.

The first line of each test case contains a single integer $n$ ($1 \le n \le 2000$) — the number of desks.

The second line consists of $2n$ integers $a_1, a_2, \ldots, a_{2 n}$ ($1 \le a_i \le 10^9$) — the intelligence values of the knights.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.

Output:
For each test case, output a single line containing one integer — the minimal difference Arthur can achieve.

Note:
In the first test case, Arthur can swap the second and the fourth knights. Then the total intelligence at both desks will be $10$.

In the third test case, Arthur can make $0$ operations, which will result in the total intelligence of $11$ at each of the desks.

In the fourth test case, Arthur can swap knights with indices $2$ and $5$ and achieve the difference of $2$. It can be proven that he cannot improve his result any further.}
\BREAKDOWN{We can choose, for each index $i \in [1..n]$, whether to swap $a_i$ with $a_{i+n}$. After choices, desk $j$ has sum $b_{2j-1}+b_{2j}$. Model this as $n$ binary variables on a cycle, each desk constraining a pair of consecutive variables. Minimize the range of $n$ sums by finding the shortest interval $[L,R]$ that can contain all desk sums for some assignment.}
\ELI{Treat each swap as a binary switch; each desk sum depends on two neighboring switches around a cycle. Slide a window $[L,R]$ over all possible sums and test if the cycle constraints admit some switch assignment.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case:
\begin{bullets}
\item Integer $n$ ($1 \le n \le 2000$).
\item Array $a$ of length $2n$ with $1 \le a_i \le 10^9$.
\end{bullets}
Total $\sum n \le 2000$.}
\OUTPUTS{For each test case, a single integer: the minimal achievable value of $\max_j S_j - \min_j S_j$ where $S_j = b_{2j-1}+b_{2j}$ after any number of allowed opposite-index swaps.}
\SAMPLES{Example-style micro-cases:
\begin{bullets}
\item $n=1$, $a=[3,7]$. Answer: $0$ (both desks the same single desk, sum always $10$).
\item $n=2$, $a=[1,9,4,6]$. One optimal plan yields sums $10$ and $10$, answer $0$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Define binary variables $x_i \in \{0,1\}$ for $i=1,\ldots,n$ indicating whether we swap indices $i$ and $i+n$ ($x_i=1$ means swap). Let $b_k$ be the resulting elements after swaps:
\[
b_k=
\begin{cases}
a_k & \text{if } k \le n \text{ and } x_k=0,\\
a_{k+n} & \text{if } k \le n \text{ and } x_k=1,\\
a_k & \text{if } k>n \text{ and } x_{k-n}=0,\\
a_{k-n} & \text{if } k>n \text{ and } x_{k-n}=1.
\end{cases}
\]
Desk sums are $S_j=b_{2j-1}+b_{2j}$ for $j=1,\ldots,n$. Minimize $\max_j S_j-\min_j S_j$.}
\varmapStart
\var{x_i}{swap decision for pair $(i, i+n)$}
\var{b_k}{value at position $k$ after swaps}
\var{S_j}{sum at desk $j$}
\var{L,R}{candidate interval bounds for all $S_j$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Feasibility}(L,R) \iff \exists (x_1,\ldots,x_n)\in\{0,1\}^n\ \forall j:~ L \le S_j(x) \le R.
\end{BreakableEquation*}
The minimal answer is $\min\{R-L:\ \text{Feasibility}(L,R)\}$, with $L,R$ chosen among attainable desk-sum values.}
\ASSUMPTIONS{Indices are $1$-based in the statement; implementation uses $0$-based. The constraints couple only adjacent variables on a cycle: desk $j$ touches variables indexed $\bigl((2j-2)\bmod n\bigr)+1$ and $\bigl((2j-1)\bmod n\bigr)+1$.}
\INVARIANTS{
\begin{bullets}
\item The multiset of $b_k$ equals that of $a_k$ (swaps permute entries).
\item $\sum_{j=1}^{n} S_j = \sum_{k=1}^{2n} a_k$ (fixed average desk sum).
\item Each desk constraint depends only on two neighboring variables around the cycle.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all $2^n$ swap assignments $x$ and compute the range of desk sums; take the minimum.}
\ASSUMPTIONS{Viable only for very small $n$ (e.g., $n \le 18$) due to exponential time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each bitmask $x \in \{0,1\}^n$, form $b$ by swapping.
\item Compute all $S_j=b_{2j-1}+b_{2j}$ and their range.
\item Keep the minimal range.
\end{algosteps}
\COMPLEXITY{Exponential time and linear space.}
\[
\begin{aligned}
T(n) &= \Theta(2^n \cdot n),\quad S(n)=\Theta(n).
\end{aligned}
\]
\CORRECTNESS{Direct enumeration checks all feasible configurations, so the minimum achieved equals the optimal value.}
\EDGECASES{$n=1$ (both positions share the same variable), repeated equal values, already balanced sums.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(2 * n)]
        cases.append((n, a))
    return t, cases

def brute_solve_case(n: int, a: List[int]) -> int:
    # Exponential baseline; OK for tiny n
    if n == 0:
        return 0
    best = 10**30
    for mask in range(1 << n):
        b = a[:]  # copy
        # apply swaps based on mask
        for i in range(n):
            if (mask >> i) & 1:
                b[i], b[i + n] = b[i + n], b[i]
        # compute desk sums
        lo = 10**30
        hi = -10**30
        for j in range(n):
            s = b[2 * j] + b[2 * j + 1]
            if s < lo:
                lo = s
            if s > hi:
                hi = s
        if hi - lo < best:
            best = hi - lo
    return best

def solve_all(cases: List[Tuple[int, List[int]]]) -> str:
    out = []
    for n, a in cases:
        out.append(str(brute_solve_case(n, a)))
    return "\n".join(out)

def main():
    t, cases = read_input()
    if t == 0:
        # Self-checks on tiny sizes
        assert brute_solve_case(1, [3, 7]) == 0
        assert brute_solve_case(2, [1, 9, 4, 6]) == 0
        # Random small checks by hand-crafted inputs
        assert brute_solve_case(2, [1, 2, 3, 4]) == 0  # can make sums 4 and 4
        print("OK")
    else:
        print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Included asserts for $n=1$ and simple $n=2$ cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Fix a Range and Check Feasibility via Cycle-DP}
\WHICHFORMULA{For a candidate interval $[L,R]$, each desk $j$ allows a subset of the four assignments $(x_p,x_q) \in \{0,1\}^2$. Desks constrain consecutive variables around a cycle. Existence of an assignment is equivalent to a path around a 2-state automaton whose transitions are the allowed pairs.}
\ASSUMPTIONS{Per-desk constraints depend only on adjacent variables $(i,i+1 \bmod n)$. For even $n$, two desks constrain the same adjacent pair; intersect their allowances.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute, for each desk, its four possible sums as a function of $(x_i,x_{i+1})$.
\item For a fixed $[L,R]$, build for each $i$ a $2\times 2$ boolean matrix $M_i$ where $M_i[u][v]$ is true iff all desks that touch $(i,i{+}1)$ accept $(u,v)$.
\item Compose $T=M_1 \circ M_2 \circ \cdots \circ M_n$ with boolean matrix multiplication; feasible iff $T[0][0]$ or $T[1][1]$ is true.
\end{algosteps}
\COMPLEXITY{Per feasibility check $O(n)$ (constant-sized matrices).}
\[
\begin{aligned}
T_{\text{check}}(n) &= \Theta(n),\quad S(n)=\Theta(1).
\end{aligned}
\]
\CORRECTNESS{Every desk is an edge constraint on the cycle. Boolean matrix composition captures all paths consistent with local constraints. A feasible assignment corresponds to starting state $s$ returning to $s$ after one full cycle, i.e., diagonal of $T$ is nonempty.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(2 * n)]
        cases.append((n, a))
    return t, cases

def feasibility_cycle_dp(n: int, a: List[int], L: int, R: int,
                         per_edge_tabs: List[List[List[List[int]]]]) -> bool:
    # Build combined 2x2 matrices M_i by intersecting all edge-tabs for pair (i,i+1).
    M = [[[True, True], [True, True]] for _ in range(n)]
    for i in range(n):
        tabs = per_edge_tabs[i]
        if not tabs:
            continue
        for u in (0, 1):
            for v in (0, 1):
                ok = True
                for tab in tabs:
                    s = tab[u][v]
                    if not (L <= s <= R):
                        ok = False
                        break
                M[i][u][v] = ok
    # Compose M[0] ... M[n-1]
    T = [[True, False], [False, True]]  # identity
    def mult(A, B):
        return [
            [ (A[0][0] and B[0][0]) or (A[0][1] and B[1][0]),
              (A[0][0] and B[0][1]) or (A[0][1] and B[1][1]) ],
            [ (A[1][0] and B[0][0]) or (A[1][1] and B[1][0]),
              (A[1][0] and B[0][1]) or (A[1][1] and B[1][1]) ],
        ]
    for i in range(n):
        T = mult(T, M[i])
    return T[0][0] or T[1][1]

def precompute_tabs(n: int, a: List[int]) -> Tuple[List[List[List[List[int]]]], List[int]]:
    # per_edge_tabs[i] holds 1 or 2 tabs (each tab is 2x2 sums) for the pair (i, i+1 mod n).
    per_edge_tabs = [[] for _ in range(n)]
    candidates = set()
    def val(r: int, bit: int) -> int:
        if r < n:
            return a[r] if bit == 0 else a[r + n]
        else:
            return a[r] if bit == 0 else a[r - n]
    def idx(r: int) -> int:
        return r % n
    for j in range(n):
        r1 = 2 * j
        r2 = r1 + 1
        i = idx(r1)
        # assert idx(r2) == (i + 1) % n
        tab = [[0, 0], [0, 0]]
        for u in (0, 1):
            for v in (0, 1):
                s = val(r1, u) + val(r2, v)
                tab[u][v] = s
                candidates.add(s)
        per_edge_tabs[i].append(tab)
    return per_edge_tabs, sorted(candidates)

def solve_case(n: int, a: List[int]) -> int:
    per_edge_tabs, cand = precompute_tabs(n, a)
    m = len(cand)
    ans = 10**30
    l = 0
    for r in range(m):
        while l <= r and feasibility_cycle_dp(n, a, cand[l], cand[r], per_edge_tabs):
            ans = min(ans, cand[r] - cand[l])
            l += 1
    return ans

def solve_all(cases: List[Tuple[int, List[int]]]) -> str:
    return "\n".join(str(solve_case(n, a)) for n, a in cases)

def main():
    t, cases = read_input()
    if t == 0:
        # Tiny deterministic checks
        assert solve_case(1, [3, 7]) == 0
        assert solve_case(2, [1, 9, 4, 6]) == 0
        assert solve_case(3, [5, 6, 7, 4, 3, 2]) >= 0
        print("OK")
    else:
        print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts cover $n=1$, simple $n=2$, and a sanity check for $n=3$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sliding Window over Candidate Sums + Cycle DP}
\WHICHFORMULA{All achievable desk sums come from four choices per desk; thus the optimal interval endpoints are among these values. Sort unique candidates and use a two-pointer window. For each $[L,R]$, test feasibility via the $2$-state cycle DP (boolean $2\times2$ matrix product).}
\ASSUMPTIONS{Monotonicity: if $[L,R]$ is feasible, any superset interval is feasible. Candidates set size is $O(n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute per-edge $2\times 2$ sums and collect all sums into a sorted unique array $C$.
\item Initialize $l=0$. For $r=0$ to $|C|-1$:
\begin{bullets}
\item While feasible on $[C[l], C[r]]$, update answer and increment $l$.
\end{bullets}
\item Output the minimal width found.
\end{algosteps}
\OPTIMALITY{Any optimal interval can be shifted to align with candidate endpoints without losing feasibility, since constraints only change when crossing a candidate sum. Thus scanning candidate windows attains the global optimum.}
\COMPLEXITY{Per test case:
\[
\begin{aligned}
\text{Precompute} &:\ \Theta(n),\\
\text{Window scans} &:\ O(|C|) \text{ windows} \times \Theta(n) \text{ per feasibility} = \Theta(n|C|)=\Theta(n^2),\\
\text{Space} &:\ \Theta(n).
\end{aligned}
\]
With $\sum n \le 2000$, this comfortably fits time limits.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\quad S(n)=\Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(2 * n)]
        cases.append((n, a))
    return t, cases

def precompute_tabs(n: int, a: List[int]) -> Tuple[List[List[List[List[int]]]], List[int]]:
    per_edge_tabs = [[] for _ in range(n)]  # for pair (i, i+1 mod n)
    candidates = set()
    def val(r: int, bit: int) -> int:
        if r < n:
            return a[r] if bit == 0 else a[r + n]
        else:
            return a[r] if bit == 0 else a[r - n]
    def idx(r: int) -> int:
        return r % n
    for j in range(n):
        r1 = 2 * j
        r2 = r1 + 1
        i = idx(r1)  # neighbor is (i+1) % n
        tab = [[0, 0], [0, 0]]
        for u in (0, 1):
            for v in (0, 1):
                s = val(r1, u) + val(r2, v)
                tab[u][v] = s
                candidates.add(s)
        per_edge_tabs[i].append(tab)
    return per_edge_tabs, sorted(candidates)

def feasibility_cycle_dp(n: int, L: int, R: int,
                         per_edge_tabs: List[List[List[List[int]]]]) -> bool:
    # Build 2x2 boolean matrices M_i by intersecting all tabs attached to edge i.
    M = [[[True, True], [True, True]] for _ in range(n)]
    for i in range(n):
        tabs = per_edge_tabs[i]
        if not tabs:
            continue
        for u in (0, 1):
            for v in (0, 1):
                ok = True
                for tab in tabs:
                    s = tab[u][v]
                    if s < L or s > R:
                        ok = False
                        break
                M[i][u][v] = ok
    # Compose around the cycle
    T = [[True, False], [False, True]]  # identity
    def mult(A, B):
        return [
            [ (A[0][0] and B[0][0]) or (A[0][1] and B[1][0]),
              (A[0][0] and B[0][1]) or (A[0][1] and B[1][1]) ],
            [ (A[1][0] and B[0][0]) or (A[1][1] and B[1][0]),
              (A[1][0] and B[0][1]) or (A[1][1] and B[1][1]) ],
        ]
    for i in range(n):
        T = mult(T, M[i])
    return T[0][0] or T[1][1]

def solve_case(n: int, a: List[int]) -> int:
    per_edge_tabs, cand = precompute_tabs(n, a)
    ans = 10**30
    l = 0
    for r in range(len(cand)):
        while l <= r and feasibility_cycle_dp(n, cand[l], cand[r], per_edge_tabs):
            ans = min(ans, cand[r] - cand[l])
            l += 1
    return ans

def solve_all(cases: List[Tuple[int, List[int]]]) -> str:
    return "\n".join(str(solve_case(n, a)) for n, a in cases)

def main():
    t, cases = read_input()
    if t == 0:
        # Exactness vs brute for small random-like fixed cases
        def brute(n: int, a: List[int]) -> int:
            best = 10**30
            for mask in range(1 << n):
                b = a[:]
                for i in range(n):
                    if (mask >> i) & 1:
                        b[i], b[i + n] = b[i + n], b[i]
                lo, hi = 10**30, -10**30
                for j in range(n):
                    s = b[2 * j] + b[2 * j + 1]
                    lo = min(lo, s)
                    hi = max(hi, s)
                best = min(best, hi - lo)
            return best
        # Deterministic checks
        assert solve_case(1, [3, 7]) == 0
        assert solve_case(2, [1, 9, 4, 6]) == 0
        # Cross-check small n against brute
        assert solve_case(2, [1, 2, 3, 4]) == brute(2, [1, 2, 3, 4])
        assert solve_case(3, [1, 2, 3, 4, 5, 6]) == brute(3, [1, 2, 3, 4, 5, 6])
        print("OK")
    else:
        print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts (plus extra) provide direct checks and cross-validate against brute force on tiny instances.}
\RESULT{For each test, the minimal achievable range $\max_j S_j - \min_j S_j$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks for $n=1,2$; cross-check against brute force for small $n \le 3,4$. Ensure even/odd $n$ and wrap-around are covered.}
\LINE{CROSS-CHECKS}{Compare the optimal method against the brute enumerator on random tiny arrays.}
\LINE{EDGE-CASE GENERATOR}{Construct cases with identical values, strictly increasing, and alternating large/small to stress interval endpoints.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_equal(n: int, v: int) -> list:
    return [v] * (2 * n)

def gen_increasing(n: int, start: int = 1) -> list:
    return list(range(start, start + 2 * n))

def gen_alternating(n: int, low: int = 1, high: int = 10**9) -> list:
    a = []
    cur = low
    for i in range(2 * n):
        a.append(cur)
        cur = high if cur == low else low
    return a

# Quick property: answer is 0 for any all-equal input.
def prop_all_equal_zero():
    for n in range(1, 6):
        a = gen_all_equal(n, 7)
        assert solve_case(n, a) == 0

# Quick property: for n=1, answer is always 0.
def prop_n1_zero():
    for v1 in [1, 5, 123456789]:
        for v2 in [2, 7, 1000000000]:
            assert solve_case(1, [v1, v2]) == 0
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(2 * n)]
        cases.append((n, a))
    return t, cases

def precompute_tabs(n: int, a: List[int]) -> Tuple[List[List[List[List[int]]]], List[int]]:
    per_edge_tabs = [[] for _ in range(n)]
    candidates = set()
    def val(r: int, bit: int) -> int:
        if r < n:
            return a[r] if bit == 0 else a[r + n]
        else:
            return a[r] if bit == 0 else a[r - n]
    def idx(r: int) -> int:
        return r % n
    for j in range(n):
        r1 = 2 * j
        r2 = r1 + 1
        i = idx(r1)
        tab = [[0, 0], [0, 0]]
        for u in (0, 1):
            for v in (0, 1):
                s = val(r1, u) + val(r2, v)
                tab[u][v] = s
                candidates.add(s)
        per_edge_tabs[i].append(tab)
    return per_edge_tabs, sorted(candidates)

def feasibility_cycle_dp(n: int, L: int, R: int,
                         per_edge_tabs: List[List[List[List[int]]]]) -> bool:
    M = [[[True, True], [True, True]] for _ in range(n)]
    for i in range(n):
        tabs = per_edge_tabs[i]
        if not tabs:
            continue
        for u in (0, 1):
            for v in (0, 1):
                ok = True
                for tab in tabs:
                    s = tab[u][v]
                    if s < L or s > R:
                        ok = False
                        break
                M[i][u][v] = ok
    T = [[True, False], [False, True]]
    def mult(A, B):
        return [
            [ (A[0][0] and B[0][0]) or (A[0][1] and B[1][0]),
              (A[0][0] and B[0][1]) or (A[0][1] and B[1][1]) ],
            [ (A[1][0] and B[0][0]) or (A[1][1] and B[1][0]),
              (A[1][0] and B[0][1]) or (A[1][1] and B[1][1]) ],
        ]
    for i in range(n):
        T = mult(T, M[i])
    return T[0][0] or T[1][1]

def solve_case(n: int, a: List[int]) -> int:
    per_edge_tabs, cand = precompute_tabs(n, a)
    ans = 10**30
    l = 0
    for r in range(len(cand)):
        while l <= r and feasibility_cycle_dp(n, cand[l], cand[r], per_edge_tabs):
            ans = min(ans, cand[r] - cand[l])
            l += 1
    return ans

def solve_all(cases: List[Tuple[int, List[int]]]) -> str:
    return "\n".join(str(solve_case(n, a)) for n, a in cases)

def main():
    t, cases = read_input()
    if t == 0:
        # Minimal deterministic asserts
        assert solve_case(1, [3, 7]) == 0
        assert solve_case(2, [1, 9, 4, 6]) == 0
        assert solve_case(2, [1, 2, 3, 4]) == 0
        print("OK")
    else:
        print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize the range of desk sums by toggling opposite swaps; feasibility for a range $[L,R]$ reduces to a 2-state cycle DP and the optimum follows from a sliding window over candidate sums.}
\WHY{Binary-variable cycles with local pairwise constraints are common in interviews and contests; recognizing the cycle-automaton structure avoids heavy 2-SAT.}
\CHECKLIST{
\begin{bullets}
\item Build four-sum table per desk using correct index mapping.
\item Group constraints by adjacent variable pair $(i,i{+}1 \bmod n)$, intersect duplicates for even $n$.
\item Collect and sort candidate sums.
\item Two-pointer over $[L,R]$; per window, compose $2\times2$ matrices and check diagonal.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ (same variable appears twice in one desk).
\item Even $n$ with duplicated edge constraints (must intersect).
\item All values equal (answer $0$).
\item Strictly increasing/decreasing arrays.
\item Large values near $10^9$ (watch for integer overflow in other languages).
\item Mixed large/small that push $L$ or $R$ to extremes.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in mapping desk $j$ to positions $(2j{-}1,2j)$.
\item Wrong modulo mapping $\text{idx}(r)=(r\bmod n)$ for $0$-based indices.
\item Forgetting that for $r \ge n$ and $x_i=1$, value comes from $a[r-n]$.
\item Not intersecting two constraints for even $n$ on the same pair $(i,i{+}1)$.
\item Treating variables at positions $2j{-}1$ and $2j$ as independent when they wrap to the same index for $n=1$.
\item Assuming endpoints of optimal interval are arbitrary reals; must use candidate sums only.
\end{bullets}}
\FAILMODES{Brute force times out beyond tiny $n$. Naive 2-SAT per window is too slow; the cycle-DP is the robust alternative.}
\ELI{Think of $n$ switches in a ring. Each desk looks at two neighboring switches and says which settings are acceptable for its sum to fall in $[L,R]$. Multiply all these tiny rules together to see if the ring can be satisfied. Slide $[L,R]$ over all possible sums to find the tightest fit.}
\NotePages{3}

\end{document}