% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Largest Combination With Bitwise AND Greater Than Zero}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/largest-combination-with-bitwise-and-greater-than-zero/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{The bitwise AND of an array \texttt{nums} is the bitwise AND of all integers in \texttt{nums}. For example, for \texttt{nums = [1, 5, 3]}, the bitwise AND is equal to \texttt{1 \& 5 \& 3 = 1}. Also, for \texttt{nums = [7]}, the bitwise AND is \texttt{7}.

You are given an array of positive integers \texttt{candidates}. Compute the bitwise AND for all possible combinations of elements in the \texttt{candidates} array. Return the size of the largest combination of \texttt{candidates} with a bitwise AND greater than \texttt{0}.

Example 1:

Input: \texttt{candidates = [16,17,71,62,12,24,14]}

Output: \texttt{4}

Explanation: The combination \texttt{[16,17,62,24]} has a bitwise AND of \texttt{16 \& 17 \& 62 \& 24 = 16 > 0}. The size of the combination is \texttt{4}. It can be shown that no combination with a size greater than \texttt{4} has a bitwise AND greater than \texttt{0}. Note that more than one combination may have the largest size. For example, the combination \texttt{[62,12,24,14]} has a bitwise AND of \texttt{62 \& 12 \& 24 \& 14 = 8 > 0}.

Example 2:

Input: \texttt{candidates = [8,8]}

Output: \texttt{2}

Explanation: The largest combination \texttt{[8,8]} has a bitwise AND of \texttt{8 \& 8 = 8 > 0}. The size of the combination is \texttt{2}, so we return \texttt{2}.

Constraints: \texttt{1 <= candidates.length <= 10\^5} and \texttt{(1 <= candidates[i] <= 10\^7)}.}
\BREAKDOWN{We must find the maximum subset size whose bitwise AND is positive. Observing that a positive AND requires at least one bit position that is set in all chosen numbers, we can reduce the problem to counting, per bit position, how many numbers have that bit set, and taking the maximum count.}
\ELI{Pick a single bit position and include all numbers that have that bit set; the biggest such pile gives the answer.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{candidates} of length $n$ where $1 \le n \le 10^5$, with integers satisfying $1 \le \texttt{candidates}[i] \le 10^7$.}
\OUTPUTS{Return an integer equal to the largest size of a combination (subset) whose bitwise AND is strictly greater than $0$.}
\SAMPLES{Example A: \texttt{[16,17,71,62,12,24,14]} $\to$ \texttt{4}. Example B: \texttt{[8,8]} $\to$ \texttt{2}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $c_1,\ldots,c_n \in \mathbb{N}$ be the given values. A subset $S \subseteq \{1,\ldots,n\}$ is feasible if $\bigwedge_{i \in S} c_i > 0$, where $\wedge$ is bitwise AND. The objective is to maximize $|S|$. Equivalently, there exists some bit index $b \ge 0$ such that $b$ is set in every $c_i$ for $i \in S$.}
\varmapStart
\var{n}{number of elements}
\var{c_i}{the $i$-th candidate value}
\var{b}{bit position index (zero-based)}
\var{S}{subset of indices selected}
\var{L}{number of considered bit positions (e.g., $\lceil \log_2(\max c_i + 1)\rceil$)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Ans} \;=\; \max_{b \in \{0,\ldots,L-1\}} \sum_{i=1}^{n} \mathbf{1}\!\left( (c_i \mathbin{\&} (1 \ll b)) \ne 0 \right),
\end{BreakableEquation*}
where $\mathbf{1}(\cdot)$ is the indicator function and $\ll$ is left shift. This is valid because a positive AND requires at least one shared set bit across all chosen elements, and choosing all elements sharing a fixed bit $b$ yields the largest feasible subset for that bit.}
\ASSUMPTIONS{Index bits from $0$. All $c_i \ge 1$. Let $L=\max(1,\lceil \log_2(\max_i c_i + 1)\rceil)$; practically, for $c_i \le 10^7$, $L \le 24$.}
\INVARIANTS{If $b$ is fixed, the set $S_b=\{i : (c_i \gg b)\,\&\,1 = 1\}$ yields $\bigwedge_{i\in S_b} c_i \ge 1 \ll b > 0$. No subset larger than $|S_b|$ can have bit $b$ set in all its elements. Therefore the maximum over $b$ is optimal.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all nonempty subsets and compute their bitwise AND; track the maximum subset size that yields a positive AND.}
\ASSUMPTIONS{Intended only for very small $n$ due to exponential complexity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each mask from $1$ to $(1 \ll n)-1$, compute the subset size $k=\text{popcount}(\text{mask})$.
\item If $k$ is not larger than the current best, skip. Otherwise compute the AND over elements selected by the mask, early-stopping if it becomes $0$.
\item If the final AND $>0$, update the best with $k$.
\end{algosteps}
\COMPLEXITY{Let $n$ be the length. In the worst case, all $2^n-1$ subsets are checked and each computation scans up to $n$ elements. Time $T(n)=\Theta(n2^n)$, space $S(n)=O(1)$ beyond the input.}
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n} \binom{n}{k}\cdot O(k) \;=\; O\!\left(\sum_{k=1}^{n} \binom{n}{k}\,k\right) \;=\; O(n2^n). \\
\end{aligned}
\]
\CORRECTNESS{By exhaustive enumeration, if any subset yields positive AND, it will be considered; the best size is tracked, so the maximum is found.}
\EDGECASES{Single element; all elements equal; disjoint bits so that any pair ANDs to $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
        n = len(candidates)
        best = 0
        # Enumerate all nonempty subsets; prune by size and early-stop AND when it hits 0.
        for mask in range(1, 1 << n):
            k = mask.bit_count()
            if k <= best:
                continue
            andv = None
            m = mask
            idx = 0
            while m:
                if m & 1:
                    if andv is None:
                        andv = candidates[idx]
                    else:
                        andv &= candidates[idx]
                    if andv == 0:
                        break
                idx += 1
                m >>= 1
            if andv is not None and andv > 0:
                best = k
        return best

# Tiny sanity tests (small n due to exponential nature)
assert Solution().largestCombination([8]) == 1
assert Solution().largestCombination([8, 8]) == 2
assert Solution().largestCombination([1, 2, 4]) == 1  # no shared bit across any pair
assert Solution().largestCombination([16,17,71,62,12,24,14]) == 4
\end{minted}
\VALIDATION{Verified on the two provided examples and crafted cases: all disjoint bits yields \texttt{1}; duplicates of the same power-of-two yield the count.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Bit Count per Position}
\WHICHFORMULA{Positive AND requires a common set bit. For each bit position $b$, count how many numbers have bit $b$ set; the maximum count over $b$ is the answer.}
\ASSUMPTIONS{Let $L$ be the number of bits needed to represent the maximum element; iterate $b=0,\ldots,L-1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $L = \max(1, \lfloor \log_2(\max(c_i)) \rfloor + 1)$.
\item Initialize an array \texttt{cnt} of length $L$ with zeros.
\item For each number $x$ and each $b \in [0,L)$, if $x$ has bit $b$ set, increment \texttt{cnt[b]}.
\item Return $\max_b \texttt{cnt[b]}$.
\end{algosteps}
\COMPLEXITY{Each number is inspected across $L \le 24$ bits for the given constraints, so time $O(nL)$ and space $O(L)$.}
\[
\begin{aligned}
T(n) &= O(n \cdot L),\quad S(n)=O(L).
\end{aligned}
\]
\CORRECTNESS{For any feasible subset $S$, there exists $b$ set in all elements of $S$, so $|S| \le \texttt{cnt}[b]$. Choosing all numbers with that bit $b$ set realizes $\texttt{cnt}[b]$, hence the maximum over $b$ is optimal.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
        if not candidates:
            return 0
        maxv = max(candidates)
        L = max(1, maxv.bit_length())
        cnt = [0] * L
        for x in candidates:
            for b in range(L):
                if (x >> b) & 1:
                    cnt[b] += 1
        return max(cnt)

# Checks
assert Solution().largestCombination([16,17,71,62,12,24,14]) == 4
assert Solution().largestCombination([8, 8]) == 2
assert Solution().largestCombination([1, 2, 4]) == 1
assert Solution().largestCombination([3, 3, 1]) == 3  # bit 0 set in all
\end{minted}
\VALIDATION{Covers empty-guard, powers of two, mixed bits, and the provided examples.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Iterate Set Bits Only}
\WHICHFORMULA{Same counting principle, but iterate only the set bits of each value using $x \mathbin{\&} (-x)$ to extract the least significant set bit, reducing constant factors.}
\ASSUMPTIONS{Works for nonzero positive integers; here all inputs are positive.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $L = \max(1, \text{bit\_length}(\max(c_i)))$ and allocate a \texttt{cnt} array of size $L$.
\item For each $x$ in \texttt{candidates}, while $x \ne 0$: let $lsb = x \mathbin{\&} (-x)$, index $b = \text{bit\_length}(lsb)-1$, increment \texttt{cnt[b]}, and set $x \leftarrow x - lsb$.
\item Return $\max(\texttt{cnt})$.
\end{algosteps}
\OPTIMALITY{This is optimal up to constant factors for this counting approach: each set bit across all numbers is processed exactly once.}
\COMPLEXITY{Let $B$ be the total number of set bits across inputs; the loop visits each set bit once, so time $O(B)$ with $B \le n \cdot L$ and space $O(L)$.}
\[
\begin{aligned}
T(n) &= O\Big(\sum_{i=1}^n \text{popcount}(c_i)\Big)\; \le\; O(n \cdot L), \quad S(n)=O(L).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
        if not candidates:
            return 0
        maxv = max(candidates)
        L = max(1, maxv.bit_length())
        cnt = [0] * L
        for val in candidates:
            x = val
            while x:
                lsb = x & -x
                b = lsb.bit_length() - 1
                cnt[b] += 1
                x -= lsb
        return max(cnt)

# Exactly 3 asserts
assert Solution().largestCombination([16,17,71,62,12,24,14]) == 4
assert Solution().largestCombination([8, 8]) == 2
assert Solution().largestCombination([1, 2, 4, 6]) == 2  # e.g., bit 1 shared by 2 and 6
\end{minted}
\VALIDATION{Three asserts cover the two official examples and a mixed-bit case with a shared bit among a pair.}
\RESULT{Return the maximum count of numbers sharing any single bit position set to $1$; ties are naturally resolved by taking the maximum.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests over small crafted arrays to verify: duplicates, all disjoint powers of two, single element, mixed values with known shared bits, and randomized small arrays where brute force and optimal must agree.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (brute force) and Approach C (optimal) on random arrays of size up to 15 with values up to $2^{10}$.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of size $1$; arrays of identical values; arrays of distinct powers of two; arrays where all numbers share a specific bit; random arrays with bounded bit-width.}
\begin{minted}{python}
from typing import List
import random

def brute_force_largest_combination(candidates: List[int]) -> int:
    n = len(candidates)
    best = 0
    for mask in range(1, 1 << n):
        k = mask.bit_count()
        if k <= best:
            continue
        andv = None
        for i in range(n):
            if (mask >> i) & 1:
                andv = candidates[i] if andv is None else (andv & candidates[i])
                if andv == 0:
                    break
        if andv and andv > 0:
            best = k
    return best

class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
        if not candidates:
            return 0
        L = max(1, max(candidates).bit_length())
        cnt = [0] * L
        for v in candidates:
            x = v
            while x:
                lsb = x & -x
                b = lsb.bit_length() - 1
                cnt[b] += 1
                x -= lsb
        return max(cnt)

# Deterministic generators for boundaries, degenerates, adversarials
def gen_all():
    yield [8]
    yield [8, 8]
    yield [1, 2, 4]
    yield [3, 3, 1]
    yield [16, 17, 71, 62, 12, 24, 14]
    # Disjoint powers of two repeated
    yield [1, 2, 4, 8, 16, 32]
    # Shared bit among many
    yield [6, 14, 10, 2, 18, 22]  # bit 1 set in all
    # Random small arrays (deterministic seed)
    rnd = random.Random(0)
    for _ in range(10):
        n = rnd.randint(1, 10)
        arr = [rnd.randint(1, (1 << 10) - 1) for _ in range(n)]
        yield arr

# Cross-check brute force vs optimal on small cases
for arr in gen_all():
    bf = brute_force_largest_combination(arr)
    opt = Solution().largestCombination(arr)
    assert bf == opt, (arr, bf, opt)

# Reference answers for specific cases
assert Solution().largestCombination([16,17,71,62,12,24,14]) == 4
assert Solution().largestCombination([8, 8]) == 2
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
        if not candidates:
            return 0
        L = max(1, max(candidates).bit_length())
        cnt = [0] * L
        for v in candidates:
            x = v
            while x:
                lsb = x & -x
                b = lsb.bit_length() - 1
                cnt[b] += 1
                x -= lsb
        return max(cnt)

# Sanity asserts (LC-local)
if __name__ == "__main__":
    s = Solution()
    assert s.largestCombination([8]) == 1
    assert s.largestCombination([8, 8]) == 2
    assert s.largestCombination([1, 2, 4]) == 1
    assert s.largestCombination([16,17,71,62,12,24,14]) == 4
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Answer equals the maximum number of input values sharing any single set bit.}
\WHY{Appears in interviews to test bit manipulation insight and reducing subset constraints to per-bit counting.}
\CHECKLIST{Understand that positive AND implies a common set bit; compute bit-length from max value; count per bit; return maximum count.}
\EDGECASES{Single element; all identical elements; all powers of two distinct; mixed values with only one shared bit across a few; very large values near $10^7$; array length $1$ and $10^5$.}
\PITFALLS{Forgetting to escape \& in explanations; starting brute-force AND at \texttt{-1} and reasoning about two's complement; iterating a fixed 32 bits instead of actual needed bit-length; off-by-one in bit indices; ignoring empty input guard for local tests; using slow Python operations inside the deepest loops unnecessarily.}
\FAILMODES{Brute force fails on $n \approx 30+$ due to exponential blow-up. Counting per bit remains linear in $n$ and bit-width, passing constraints.}
\ELI{Think of stacking numbers into bins by which bit they set. The tallest bin is the biggest group that shares a common bit, so its AND is still positive.}
\NotePages{3}

\end{document}