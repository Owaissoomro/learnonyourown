% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tree Modification}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1375/G}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{You are given a tree with $n$ vertices. You are allowed to modify the structure of the tree through the following multi-step operation:
\begin{enumerate}
\item Choose three vertices $a$, $b$, and $c$ such that $b$ is adjacent to both $a$ and $c$.
\item For every vertex $d$ other than $b$ that is adjacent to $a$, remove the edge connecting $d$ and $a$ and add the edge connecting $d$ and $c$.
\item Delete the edge connecting $a$ and $b$ and add the edge connecting $a$ and $c$.
\end{enumerate}
It can be proven that after each operation, the resulting graph is still a tree.

Find the minimum number of operations that must be performed to transform the tree into a star. A star is a tree with one vertex of degree $n - 1$, called its center, and $n - 1$ vertices of degree $1$.

Input: The first line contains an integer $n$ ($3 \le n \le 2 \cdot 10^5$) — the number of vertices in the tree.

The $i$-th of the following $n - 1$ lines contains two integers $u_i$ and $v_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$) denoting that there exists an edge connecting vertices $u_i$ and $v_i$. It is guaranteed that the given edges form a tree.

Output: Print a single integer — the minimum number of operations needed to transform the tree into a star.

It can be proven that under the given constraints, it is always possible to transform the tree into a star using at most $10^{18}$ operations.}
\BREAKDOWN{Understand how the operation changes degrees and distances relative to a chosen center. Show that for a chosen center $c$, each operation must select a vertex at even distance from $c$, and exactly one operation per such vertex is necessary and sufficient. Therefore minimize over centers the count of even-distance vertices.}
\ELI{Pick the star center to be in the larger color class of the tree's bipartition; then you only need to ``fix'' all vertices of the same color as the center except the center itself.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single test case. Integer $n$ with $3 \le n \le 2 \cdot 10^5$. Then $n-1$ undirected edges $(u_i,v_i)$ forming a tree, $1 \le u_i,v_i \le n$.}
\OUTPUTS{One integer — the minimum number of allowed operations to turn the tree into a star.}
\SAMPLES{Examples (schematic, not from platform):
\begin{itemize}
\item Path $1-2-3-4$: answer $=1$ (center at $3$).
\item Star centered at $4$: answer $=0$.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a tree on $|V|=n$. For a chosen center $c \in V$, root the tree at $c$. Define $\operatorname{dist}(u,c)$ as the graph distance. An operation selects a path $a$--$b$--$c$ with $\operatorname{dist}(b,c)=1$ and $\operatorname{dist}(a,c)=2$, and makes $a$ adjacent to $c$ while moving all children of $a$ to be adjacent to $c$.}
\varmapStart
\var{n}{number of vertices}
\var{G}{input tree}
\var{c}{chosen center candidate}
\var{\operatorname{dist}(u,c)}{distance from $u$ to $c$}
\var{A_c}{set of vertices at even distance from $c$}
\var{B_c}{set of vertices at odd distance from $c$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Minimum operations} \;=\; \min_{c \in V}\bigl(|A_c| - 1\bigr)
\end{BreakableEquation*}
}
\ASSUMPTIONS{Tree is connected and acyclic. Distances are well-defined. The operation preserves the tree property.}
\INVARIANTS{
\begin{itemize}
\item Parity invariant: For any fixed $c$, every operation selects $a$ with $\operatorname{dist}(a,c)$ even (specifically $2$ at the time of selection).
\item Each vertex at even distance from the chosen center (except $c$) must be selected exactly once to make all vertices adjacent to $c$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{For each possible center $c$, compute the number of vertices at even distance from $c$ and take the minimum value minus $1$.}
\ASSUMPTIONS{We can run a BFS from every vertex (overall $O(n^2)$) since this is only a conceptual baseline; not suitable for $n \approx 2\cdot 10^5$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $c \in \{1,\ldots,n\}$:
\item Run BFS from $c$ to compute $\operatorname{dist}(u,c)$ for all $u$.
\item Count how many $u$ have even distance; update answer with $\min(\text{count} - 1)$.
\end{algosteps}
\COMPLEXITY{Naively, $O(n)$ BFS per center, total $O(n^2)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= \sum_{c=1}^{n} O(n) \\
     &= O(n^2) \\
\end{aligned}
\]
\CORRECTNESS{By definition, for a fixed $c$ the set of even-distance vertices are exactly those requiring one operation each (excluding $c$) to become adjacent to $c$. Taking the minimum over $c$ yields the optimal star center.}
\EDGECASES{Already a star $\Rightarrow$ $\min(|A_c|)-1=0$. Paths of various lengths.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    edges = [[] for _ in range(n)]
    for _ in range(n - 1):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges[u].append(v)
        edges[v].append(u)
    return n, edges

def even_count_from_center(n, adj, c):
    dist = [-1] * n
    dist[c] = 0
    q = deque([c])
    even = 0
    while q:
        u = q.popleft()
        if dist[u] % 2 == 0:
            even += 1
        for v in adj[u]:
            if dist[v] == -1:
                dist[v] = dist[u] + 1
                q.append(v)
    return even  # includes c itself

def solve_case_bruteforce(n, adj):
    ans = n  # large
    for c in range(n):
        even = even_count_from_center(n, adj, c)
        ans = min(ans, even - 1)  # exclude the center itself
    return ans

def solve_all_bruteforce(data: str) -> str:
    n, adj = read_input(data)
    return str(solve_case_bruteforce(n, adj))

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    print(solve_all_bruteforce(data))

if __name__ == "__main__":
    # Tiny tests
    def build_edges(n, edge_list):
        adj = [[] for _ in range(n)]
        for u, v in edge_list:
            u -= 1; v -= 1
            adj[u].append(v); adj[v].append(u)
        return adj

    # Path 1-2-3-4 => answer 1
    n = 4
    adj = build_edges(n, [(1,2),(2,3),(3,4)])
    assert solve_case_bruteforce(n, adj) == 1

    # Star centered at 4 (1-4,2-4,3-4) => answer 0
    n = 4
    adj = build_edges(n, [(1,4),(2,4),(3,4)])
    assert solve_case_bruteforce(n, adj) == 0

    # "Y" shape: 0-1,1-2,1-3,2-4,3-5, (and add 1-6 to make 3 arms) => expecting 2
    # Reindex to 1-based for builder:
    n = 7
    adj = build_edges(n, [(1,2),(2,3),(2,4),(3,5),(4,6),(2,7)])
    assert solve_case_bruteforce(n, adj) == 2

    # If running with stdin input:
    # main()
\end{minted}
\VALIDATION{Checked on paths, stars, and small branched trees; all consistent with parity reasoning.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Rerooting View / Parity Classes}
\WHICHFORMULA{In any tree, fixing an arbitrary root $r$ induces a bipartition of $V$ by parity of $\operatorname{dist}(\cdot,r)$. For any chosen center $c$, the vertices at even distance from $c$ are exactly those in the same bipartition class as $c$. Thus $\min_c \bigl(|A_c|-1\bigr) = \min\bigl(|\mathcal{C}_0|,|\mathcal{C}_1|\bigr) - 1$, where $\mathcal{C}_0,\mathcal{C}_1$ are the two color classes.}
\ASSUMPTIONS{Tree is bipartite; parity class sizes are independent of the particular root up to swapping.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Root the tree at an arbitrary node (say $1$) and $2$-color it by BFS.
\item Let $c_0$ be the number of nodes of color $0$, $c_1$ the number with color $1$.
\item Answer is $\min(c_0,c_1) - 1$.
\end{algosteps}
\COMPLEXITY{Single BFS: $O(n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n), \\
\end{aligned}
\]
\CORRECTNESS{Parity-of-distance identity in trees: for any fixed reference coloring, $\operatorname{dist}(u,v)$ is even iff $u$ and $v$ have the same color. Hence $|A_c|$ equals the size of $c$'s color class; minimizing over $c$ selects the smaller class.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    edges = [[] for _ in range(n)]
    for _ in range(n - 1):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges[u].append(v)
        edges[v].append(u)
    return n, edges

def color_classes(n, adj):
    color = [-1] * n
    ccount = [0, 0]
    q = deque([0])
    color[0] = 0
    ccount[0] += 1
    while q:
        u = q.popleft()
        for v in adj[u]:
            if color[v] == -1:
                color[v] = color[u] ^ 1
                ccount[color[v]] += 1
                q.append(v)
    return ccount[0], ccount[1]

def solve_case(n, adj):
    c0, c1 = color_classes(n, adj)
    return min(c0, c1) - 1

def solve_all(data: str) -> str:
    n, adj = read_input(data)
    return str(solve_case(n, adj))

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    print(solve_all(data))

if __name__ == "__main__":
    # Sanity tests
    def build_edges(n, edge_list):
        adj = [[] for _ in range(n)]
        for u, v in edge_list:
            u -= 1; v -= 1
            adj[u].append(v); adj[v].append(u)
        return adj

    # Path n=6 => min class size 3 => 3-1 = 2
    n = 6
    adj = build_edges(n, [(1,2),(2,3),(3,4),(4,5),(5,6)])
    assert solve_case(n, adj) == 2

    # Star centered at 4 => min class size 1 => 1-1 = 0
    n = 4
    adj = build_edges(n, [(1,4),(2,4),(3,4)])
    assert solve_case(n, adj) == 0

    # "Y" shape (7 nodes) => classes (3,4) => 3-1 = 2
    n = 7
    adj = build_edges(n, [(1,2),(2,3),(2,4),(3,5),(4,6),(2,7)])
    assert solve_case(n, adj) == 2

    # If running with stdin:
    # main()
\end{minted}
\VALIDATION{Matches brute-force on many random small trees; invariant to the initial root used.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Parity/Bipartition Formula}
\WHICHFORMULA{Compute a bipartition by BFS/DFS once. Let $c_0$ and $c_1$ be the class sizes. The minimum operations equal $\min(c_0,c_1) - 1$.}
\ASSUMPTIONS{Tree is connected, $n \ge 3$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency lists.
\item BFS from vertex $1$ to $2$-color the tree and count class sizes $c_0,c_1$.
\item Output $\min(c_0,c_1) - 1$.
\end{algosteps}
\OPTIMALITY{Tight: For a chosen center $c$, every vertex at even distance from $c$ (excluding $c$) must be selected once, and selecting a vertex at odd distance is impossible as the middle of the $a$--$b$--$c$ path must be a neighbor of $c$. Minimizing the number of such vertices over $c$ yields the smaller color class minus one.}
\COMPLEXITY{$O(n)$ time, $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n) \\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import deque
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    adj = [[] for _ in range(n)]
    for _ in range(n - 1):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        adj[u].append(v)
        adj[v].append(u)
    return n, adj

def solve_case(n, adj):
    # 2-color the tree (bipartition); answer = min(|class0|, |class1|) - 1
    color = [-1] * n
    ccount = [0, 0]
    q = deque([0])
    color[0] = 0
    ccount[0] = 1
    while q:
        u = q.popleft()
        for v in adj[u]:
            if color[v] == -1:
                color[v] = color[u] ^ 1
                ccount[color[v]] += 1
                q.append(v)
    return min(ccount[0], ccount[1]) - 1

def solve_all(data: str) -> str:
    n, adj = read_input(data)
    return str(solve_case(n, adj))

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    print(solve_all(data))

if __name__ == "__main__":
    # Exactly 3 asserts
    def build_edges(n, es):
        g = [[] for _ in range(n)]
        for u, v in es:
            u -= 1; v -= 1
            g[u].append(v); g[v].append(u)
        return g

    # 1) Path of 5: min class = 2 => 2-1 = 1
    n = 5
    adj = build_edges(n, [(1,2),(2,3),(3,4),(4,5)])
    assert solve_case(n, adj) == 1

    # 2) Star (center 4): min class = 1 => 0
    n = 4
    adj = build_edges(n, [(1,4),(2,4),(3,4)])
    assert solve_case(n, adj) == 0

    # 3) "Y" shape 7 nodes: classes (3,4) => 2
    n = 7
    adj = build_edges(n, [(1,2),(2,3),(2,4),(3,5),(4,6),(2,7)])
    assert solve_case(n, adj) == 2

    # main()
\end{minted}
\VALIDATION{Three asserts on canonical shapes: paths, star, and a branched tree.}
\RESULT{Print $\min(\text{size of bipartition classes}) - 1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Compare brute-force (Approach A) and optimal (Approach C) on random trees up to, say, $n \le 200$ offline. Include structured shapes: stars, paths, brooms, balanced trees.}
\LINE{CROSS-CHECKS}{For small $n$, ensure $\min_c(|A_c|-1)$ equals $\min(c_0,c_1)-1$.}
\LINE{EDGE-CASE GENERATOR}{Generate trees by: random Prufer codes; stars; paths; double-stars; caterpillars.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random
from collections import deque

def prufer_to_tree(code):
    n = len(code) + 2
    degree = [1] * (n + 1)
    for x in code:
        degree[x] += 1
    leaves = [i for i in range(1, n + 1) if degree[i] == 1]
    leaves.sort()
    edges = []
    for x in code:
        u = leaves[0]
        edges.append((u, x))
        degree[u] -= 1
        degree[x] -= 1
        if degree[x] == 1:
            # insert x into leaves maintaining order
            import bisect
            bisect.insort(leaves, x)
        leaves.pop(0)
    edges.append((leaves[0], leaves[1]))
    return n, edges

def bipart_answer(n, edges):
    g = [[] for _ in range(n)]
    for u, v in edges:
        u -= 1; v -= 1
        g[u].append(v); g[v].append(u)
    color = [-1] * n
    q = deque([0]); color[0] = 0
    cnt = [1, 0]
    while q:
        u = q.popleft()
        for v in g[u]:
            if color[v] == -1:
                color[v] = color[u] ^ 1
                cnt[color[v]] += 1
                q.append(v)
    return min(cnt) - 1

def brute(n, edges):
    g = [[] for _ in range(n)]
    for u, v in edges:
        u -= 1; v -= 1
        g[u].append(v); g[v].append(u)
    def even_from(c):
        dist = [-1]*n; dist[c] = 0
        q = deque([c]); ev = 0
        while q:
            u = q.popleft()
            if dist[u] % 2 == 0:
                ev += 1
            for v in g[u]:
                if dist[v] == -1:
                    dist[v] = dist[u] + 1
                    q.append(v)
        return ev - 1
    return min(even_from(c) for c in range(n))

# Cross-check a few fixed seeds
random.seed(0)
for m in [3, 5, 10]:
    if m >= 3:
        for _ in range(5):
            code = [random.randint(1, m) for _ in range(m - 2)]
            n, es = prufer_to_tree(code)
            assert bipart_answer(n, es) == brute(n, es)
# All good
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# CF 1375G — Tree Modification
# Final: O(n) using bipartition size.
from collections import deque
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    adj = [[] for _ in range(n)]
    for _ in range(n - 1):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        adj[u].append(v)
        adj[v].append(u)
    return n, adj

def solve_case(n, adj):
    color = [-1] * n
    q = deque([0])
    color[0] = 0
    cnt = [1, 0]
    while q:
        u = q.popleft()
        for v in adj[u]:
            if color[v] == -1:
                color[v] = color[u] ^ 1
                cnt[color[v]] += 1
                q.append(v)
    return min(cnt[0], cnt[1]) - 1

def solve_all(data: str) -> str:
    n, adj = read_input(data)
    return str(solve_case(n, adj))

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    print(solve_all(data))

if __name__ == "__main__":
    # Basic asserts
    def build(n, es):
        g = [[] for _ in range(n)]
        for u, v in es:
            u -= 1; v -= 1
            g[u].append(v); g[v].append(u)
        return g
    # Path 1-2-3-4-5 -> 1
    n = 5
    adj = build(n, [(1,2),(2,3),(3,4),(4,5)])
    assert solve_case(n, adj) == 1
    # Star center 4 -> 0
    n = 4
    adj = build(n, [(1,4),(2,4),(3,4)])
    assert solve_case(n, adj) == 0
    # Y-shape 7 -> 2
    n = 7
    adj = build(n, [(1,2),(2,3),(2,4),(3,5),(4,6),(2,7)])
    assert solve_case(n, adj) == 2
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimum operations equals the size of the smaller bipartition color class minus $1$.}
\WHY{This operation always picks a node at even distance from the chosen center; each such node must be processed once to become directly adjacent to the center.}
\CHECKLIST{
\begin{itemize}
\item Build adjacency.
\item BFS from any node to $2$-color the tree.
\item Count class sizes $c_0,c_1$.
\item Output $\min(c_0,c_1) - 1$.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item Already a star $\Rightarrow 0$.
\item Pure path: result toggles with parity; equals $\lfloor n/2 \rfloor - 1$ when $n$ even, else $\lfloor n/2 \rfloor - 1$ (via $\min$ class size minus $1$).
\item Minimal $n=3$: always $0$.
\item Highly unbalanced trees: still linear-time BFS works.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Using $|\text{leaves}|$ heuristics — incorrect.
\item Forgetting to subtract $1$ for the center's own inclusion in its class.
\item Off-by-one on $1$-based vs $0$-based indices.
\item Recursion DFS stack overflow on large $n$ — prefer BFS or iterative DFS.
\item Multiple test cases — this problem has a single test case.
\end{itemize}}
\FAILMODES{Any approach simulating operations explicitly will time out at scale; parity-based counting avoids simulation and is $O(n)$.}
\ELI{Color the tree in two colors so adjacent nodes are different. Pick the center from the larger color so that you have fewer same-colored nodes to fix. Each same-colored node (except the center) needs exactly one move; all others need none.}
\NotePages{3}

\end{document}