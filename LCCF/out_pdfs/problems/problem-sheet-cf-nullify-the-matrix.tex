% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Nullify The Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1451/F}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{Jeel and Ashish play a game on an $n \times m$ matrix. The rows are numbered $1$ to $n$ from top to bottom and the columns are numbered $1$ to $m$ from left to right. They play turn by turn. Ashish goes first.

Initially, each cell of the matrix contains a non-negative integer. Each turn, a player must perform all of the following actions in order.

- Choose a starting cell $(r_1, c_1)$ with non-zero value.
- Choose a finishing cell $(r_2, c_2)$ such that $r_1 \le r_2$ and $c_1 \le c_2$.
- Decrease the value of the starting cell by some positive non-zero integer.
- Pick any of the shortest paths between the two cells and either increase, decrease or leave the values of cells on this path unchanged. Note that:
  a shortest path is one that passes through the least number of cells;
  all cells on this path excluding the starting cell, but the finishing cell may be modified;
  the resulting value of each cell must be a non-negative integer;
  the cells are modified independently and not necessarily by the same value.

If the starting and ending cells are the same, then as per the rules, the value of the cell is decreased. No other operations are performed.

The game ends when all the values become zero. The player who is unable to make a move loses. It can be shown that the game will end in a finite number of moves if both players play optimally.

Given the initial matrix, if both players play optimally, can you predict who will win?

Input:
The first line contains a single integer $t$ ($1 \le t \le 10$) — the number of test cases. The description of each test case is as follows.

The first line of each test case contains two integers $n$ and $m$ ($1 \le n, m \le 100$) — the dimensions of the matrix.

The next $n$ lines contain $m$ space separated integers $a_{i,j}$ ($0 \le a_{i,j} \le 10^6$) — the values of each cell of the matrix.

Output:
For each test case, if Ashish wins the game, print ``Ashish'', otherwise print ``Jeel'' (without the quotes).

Note:
In the first test case, the only cell of the matrix is $0$. There are no moves Ashish can make. Jeel is the winner.

In the second test case, Ashish can choose $(r_1, c_1) = (r_2, c_2) = (1,3)$ and reduce the cell to $0$, leaving $[0, 0, 0]$. Jeel cannot perform any moves. Ashish wins.}
\BREAKDOWN{Reduce the impartial game to a Nim-style XOR over independent components determined by the parity of the number of monotone shortest paths. Show that only cells $(i,j)$ with an odd number of shortest paths from $(1,1)$ to $(i,j)$ contribute to the XOR.}
\ELI{Mark cells on the Sierpi\'nski-like pattern; XOR the values on those marked cells; non-zero XOR means first player wins.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases $t$. For each test case: integers $n,m$ and an $n \times m$ grid of non-negative integers $a_{i,j}$, with $1 \le n,m \le 100$ and $0 \le a_{i,j} \le 10^6$.}
\OUTPUTS{For each test case, a single line with either ``Ashish'' if the first player wins under optimal play, or ``Jeel'' otherwise.}
\SAMPLES{Example 1: $n=m=1$, $a_{1,1}=0 \Rightarrow$ output Jeel. Example 2: $n=1,m=3$, $a=[0,0,5] \Rightarrow$ output Ashish.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Consider the directed acyclic grid graph on vertices $(i,j)$ with edges to $(i+1,j)$ and $(i,j+1)$ (when inside bounds). A move selects a vertex $(r_1,c_1)$ with $a_{r_1,c_1}>0$, a target $(r_2,c_2)$ with $r_1 \le r_2$, $c_1 \le c_2$, and a monotone shortest path between them; it decreases $a_{r_1,c_1}$ by a positive amount and arbitrarily adjusts the values on the path excluding the start, keeping all entries non-negative. The Grundy reduction yields that only cells with an odd number of shortest paths from $(1,1)$ contribute to the Nim XOR.}
\varmapStart
\var{n,m}{matrix dimensions}
\var{a_{i,j}}{non-negative value at cell $(i,j)$}
\var{p_{i,j}}{indicator: $1$ iff $\binom{(i-1)+(j-1)}{i-1}$ is odd}
\var{X}{Nim XOR: $X=\bigoplus\limits_{i=1}^{n}\bigoplus\limits_{j=1}^{m} \left(p_{i,j}\cdot a_{i,j}\right)$}
\varmapEnd
\GOVERN{
\[
p_{i,j} \equiv \binom{(i-1)+(j-1)}{i-1} \bmod 2
\qquad\Longleftrightarrow\qquad
((i-1)~\&~(j-1))=0
\]
}
\ASSUMPTIONS{Standard optimal play; moves are legal only if all affected cells remain non-negative. Using Lucas' theorem modulo $2$, $\binom{x+y}{x}$ is odd iff $x$ and $y$ share no $1$-bits in binary.}
\INVARIANTS{The XOR $X$ defined above flips exactly as a Nim heap under legal moves; positions with $X=0$ are losing and with $X\ne 0$ are winning.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute $p_{i,j}$ via DP counting, modulo $2$, the number of monotone shortest paths from $(1,1)$ to $(i,j)$. Then XOR all $a_{i,j}$ where $p_{i,j}=1$.}
\ASSUMPTIONS{DP on a $100 \times 100$ grid is trivial; we only need parity, so addition modulo $2$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $p_{1,1}=1$; for first row and first column, $p_{i,1}=p_{i-1,1}$ and $p_{1,j}=p_{1,j-1}$.
\item For $i\ge 2$, $j\ge 2$, set $p_{i,j}=(p_{i-1,j}+p_{i,j-1}) \bmod 2$.
\item Compute $X=\bigoplus\{a_{i,j}\mid p_{i,j}=1\}$ and output ``Ashish'' if $X\ne 0$, else ``Jeel''.
\end{algosteps}
\COMPLEXITY{$T(n)=\Theta(nm)$, $S(n)=\Theta(nm)$ for storing $p$.}
\[
\begin{aligned}
T(n,m) &= \text{fill }p\text{ in }nm\text{ steps} + \text{one XOR pass }(nm) \\
       &= \Theta(nm).
\end{aligned}
\]
\CORRECTNESS{DP parity matches path-count parity. Sprague–Grundy reduction implies XOR over contributors determines outcome.}
\EDGECASES{$n=1$ or $m=1$ reduces to a line; $a_{i,j}=0$ everywhere prints ``Jeel''.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
        cases.append((n, m, a))
    return cases

def solve_case(n, m, a):
    # DP parity of shortest-path counts from (1,1) to (i,j)
    p = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if i == 0 and j == 0:
                p[i][j] = 1
            elif i == 0:
                p[i][j] = p[i][j-1]
            elif j == 0:
                p[i][j] = p[i-1][j]
            else:
                p[i][j] = (p[i-1][j] ^ p[i][j-1])
    x = 0
    for i in range(n):
        for j in range(m):
            if p[i][j]:
                x ^= a[i][j]
    return "Ashish" if x != 0 else "Jeel"

def solve_all(data: str):
    cases = read_input(data)
    out_lines = []
    for n, m, a in cases:
        out_lines.append(solve_case(n, m, a))
    return "\n".join(out_lines)

def main():
    print(solve_all(sys.stdin.read()))

if __name__ == "__main__":
    # Tiny self-checks
    assert solve_all("1\n1 1\n0\n") == "Jeel"
    assert solve_all("1\n1 3\n0 0 5\n") == "Ashish"
    # A 2x2 with only cell (2,2)=7: parity DP marks (1,1),(1,2),(2,1); (2,2) not marked -> Jeel
    assert solve_all("1\n2 2\n0 0\n0 7\n") == "Jeel"
    main()
\end{minted}
\VALIDATION{Checked $1\times 1$, $1\times 3$, and a $2\times 2$ case consistent with parity DP.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Bitwise Lucas Theorem}
\WHICHFORMULA{By Lucas' theorem modulo $2$, $\binom{x+y}{x}$ is odd iff $x$ \& $y$ have no common $1$-bits. Hence $p_{i,j}=1$ iff $((i-1)~\&~(j-1))=0$. We can compute $X$ in one pass without DP.}
\ASSUMPTIONS{Zero-based indices for the bitwise test: use $(i-1)$ and $(j-1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $x=0$.
\item For each cell $(i,j)$, if $((i-1)\ \&\ (j-1))==0$, set $x \mathrel{:=} x \oplus a_{i,j}$.
\item Output ``Ashish'' if $x\ne 0$, else ``Jeel''.
\end{algosteps}
\COMPLEXITY{Single pass over the matrix: $T(n)=\Theta(nm)$, $S(n)=O(1)$.}
\[
\begin{aligned}
T(n,m) &= nm \cdot O(1) = \Theta(nm).
\end{aligned}
\]
\CORRECTNESS{Directly characterizes the odd-path cells using the bitwise-\& condition, identical to the DP parity.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
        cases.append((n, m, a))
    return cases

def solve_case(n, m, a):
    x = 0
    for i in range(n):
        ii = i  # zero-based i => (i) corresponds to (i+1) in 1-based; use ii & jj
        for j in range(m):
            jj = j
            if (ii & jj) == 0:
                x ^= a[i][j]
    return "Ashish" if x != 0 else "Jeel"

def solve_all(data: str):
    cases = read_input(data)
    return "\n".join(solve_case(n, m, a) for n, m, a in cases)

def main():
    print(solve_all(sys.stdin.read()))

if __name__ == "__main__":
    # Cross-check with baseline logic on small grids
    assert solve_all("1\n1 1\n0\n") == "Jeel"
    assert solve_all("1\n1 1\n9\n") == "Ashish"
    assert solve_all("1\n1 3\n0 0 5\n") == "Ashish"
    # Crafted: 2x3 with values only at (2,2)=4 and (1,3)=7 -> mask includes (1,3) only -> XOR=7
    data = "1\n2 3\n0 0 7\n0 4 0\n"
    assert solve_all(data) == "Ashish"
    main()
\end{minted}
\VALIDATION{Unit checks include boundary single-cell cases and mixed grids.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Parity Mask via Sierpi\'nski Pattern}
\WHICHFORMULA{Use the mask condition $((i-1)\ \&\ (j-1))=0$ to select contributors and XOR their values.}
\ASSUMPTIONS{Indices treated zero-based for bitwise operations.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize accumulator $x=0$.
\item For each cell $(i,j)$ (zero-based), if $(i~\&~j)==0$, do $x\mathrel{:=}x\oplus a[i][j]$.
\item Print ``Ashish'' if $x\ne 0$, else ``Jeel''.
\end{algosteps}
\OPTIMALITY{Single scan with $O(1)$ extra memory is optimal for reading all inputs once. Decision via XOR is information-theoretically minimal.}
\COMPLEXITY{$\Theta(nm)$ time, $O(1)$ extra space.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
        cases.append((n, m, a))
    return cases

def solve_case(n, m, a):
    x = 0
    for i in range(n):
        for j in range(m):
            if (i & j) == 0:
                x ^= a[i][j]
    return "Ashish" if x != 0 else "Jeel"

def solve_all(data: str):
    cases = read_input(data)
    return "\n".join(solve_case(n, m, a) for n, m, a in cases)

def main():
    print(solve_all(sys.stdin.read()))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_all("1\n1 1\n0\n") == "Jeel"
    assert solve_all("1\n1 3\n0 0 5\n") == "Ashish"
    assert solve_all("1\n2 2\n0 0\n0 7\n") == "Jeel"
    main()
\end{minted}
\VALIDATION{The three asserts cover empty grid, simple winning grid, and a case where only a non-contributing cell is non-zero.}
\RESULT{Output ``Ashish'' iff the XOR over all $a_{i,j}$ with $(i-1)\ \&\ (j-1)=0$ is non-zero; otherwise output ``Jeel''.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify parity-mask equivalence of DP vs. bitwise; test random small grids and compare both implementations. Include degenerate sizes $1\times m$ and $n\times 1$.}
\LINE{CROSS-CHECKS}{On small $n,m\le 6$, compute $p$ via DP modulo $2$ and ensure the bitwise-\& mask yields the same set; both produce identical winners.}
\LINE{EDGE-CASE GENERATOR}{Generate matrices with all zeros, single non-zero at various coordinates, and random values up to $10^6$.}
\begin{minted}{python}
import random

def gen_case(n, m, kind="random"):
    if kind == "zeros":
        return [[0]*m for _ in range(n)]
    if kind == "single":
        a = [[0]*m for _ in range(n)]
        i = random.randrange(n); j = random.randrange(m)
        a[i][j] = random.randint(1, 10)
        return a
    # random
    return [[random.randint(0, 7) for _ in range(m)] for __ in range(n)]

def dp_mask(n, m):
    p = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if i == 0 and j == 0:
                p[i][j] = 1
            elif i == 0:
                p[i][j] = p[i][j-1]
            elif j == 0:
                p[i][j] = p[i-1][j]
            else:
                p[i][j] = p[i-1][j] ^ p[i][j-1]
    return p

def bit_mask(n, m):
    return [[1 if (i & j) == 0 else 0 for j in range(m)] for i in range(n)]

def agree_masks(n, m):
    return dp_mask(n, m) == bit_mask(n, m)

def winner_via_dp(a):
    n, m = len(a), len(a[0])
    p = dp_mask(n, m)
    x = 0
    for i in range(n):
        for j in range(m):
            if p[i][j]: x ^= a[i][j]
    return "Ashish" if x != 0 else "Jeel"

def winner_via_bit(a):
    n, m = len(a), len(a[0])
    x = 0
    for i in range(n):
        for j in range(m):
            if (i & j) == 0: x ^= a[i][j]
    return "Ashish" if x != 0 else "Jeel"

def self_test():
    for n in range(1, 7):
        for m in range(1, 7):
            assert agree_masks(n, m)
            for kind in ["zeros", "single", "random"]:
                for _ in range(10):
                    a = gen_case(n, m, kind)
                    assert winner_via_dp(a) == winner_via_bit(a)
    return True

if __name__ == "__main__":
    assert self_test()
    print("All tests passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        a = [[int(next(it)) for _ in range(m)] for __ in range(n)]
        cases.append((n, m, a))
    return cases

def solve_case(n, m, a):
    x = 0
    for i in range(n):
        for j in range(m):
            if (i & j) == 0:
                x ^= a[i][j]
    return "Ashish" if x != 0 else "Jeel"

def solve_all(data: str):
    return "\n".join(solve_case(n, m, a) for (n, m, a) in read_input(data))

def main():
    print(solve_all(sys.stdin.read()))

if __name__ == "__main__":
    # Basic asserts
    assert solve_all("1\n1 1\n0\n") == "Jeel"
    assert solve_all("1\n1 3\n0 0 5\n") == "Ashish"
    assert solve_all("1\n2 2\n0 0\n0 7\n") == "Jeel"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Winner is determined by the XOR of all $a_{i,j}$ with $((i-1)\ \&\ (j-1))=0$.}
\WHY{This compresses a seemingly complex path-editing game to a simple Nim condition using parity of path counts (Lucas modulo $2$).}
\CHECKLIST{%
\begin{bullets}
\item Build or recognize the parity mask: $(i-1)\ \&\ (j-1)$ equals $0$.
\item XOR only the marked cells' values.
\item Non-zero XOR $\Rightarrow$ first player wins; zero XOR $\Rightarrow$ second player wins.
\end{bullets}}
\EDGECASES{%
\begin{bullets}
\item All zeros $\Rightarrow$ ``Jeel''.
\item Single row or column: mask is all ones, reduce to XOR of the whole array.
\item Large values up to $10^6$: XOR fits in Python int.
\item Sparse matrices: only positions with $(i-1)\ \&\ (j-1)=0$ matter.
\item $n=m=1$ handled correctly.
\item Mixed zeros and positives; mask selection is independent of values.
\end{bullets}}
\PITFALLS{%
\begin{bullets}
\item Off-by-one: use zero-based indices for the bitwise-\& test.
\item Confusing AND with OR/XOR; must be bitwise AND.
\item Attempting to count paths fully; parity is sufficient.
\item Misinterpreting that DP sum is modulo $2$, not integer counts.
\item Forgetting to reset XOR per test case.
\item Reading input incorrectly across multiple test cases.
\end{bullets}}
\FAILMODES{%
\begin{bullets}
\item Using full path counts can overflow or be slow; parity DP or bitwise test avoids this.
\item Grouping by $(i+j)$ parity alone is incorrect; the correct mask is Sierpi\'nski-like $(i\ \&\ j)=0$ in zero-based.
\end{bullets}}
\ELI{Mark cells where the binary forms of their zero-based row and column indices do not overlap in $1$-bits. XOR the numbers on those cells. If the XOR is non-zero, the first player has a winning move; otherwise, the second player can mirror to win.}
\NotePages{3}

\end{document}