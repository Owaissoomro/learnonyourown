% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[#1]{}
\renewcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — National Property}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/875/C}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{You all know that the Library of Bookland is the largest library in the world. There are dozens of thousands of books in the library.

Some long and uninteresting story was removed\ldots

The alphabet of Bookland is so large that its letters are denoted by positive integers. Each letter can be small or large, the large version of a letter $x$ is denoted by $x'$. BSCII encoding, which is used everywhere in Bookland, is made in that way so that large letters are presented in the order of the numbers they are denoted by, and small letters are presented in the order of the numbers they are denoted by, but all large letters are before all small letters. For example, the following conditions hold: $2 < 3$, $2' < 3'$, $3' < 2$.

A word $x_1, x_2, \ldots, x_a$ is not lexicographically greater than $y_1, y_2, \ldots, y_b$ if one of the two following conditions holds:
\begin{itemize}
\item $a \le b$ and $x_1 = y_1, \ldots, x_a = y_a$, i.e. the first word is the prefix of the second word;
\item there is a position $1 \le j \le \min(a,b)$, such that $x_1 = y_1, \ldots, x_{j-1} = y_{j-1}$ and $x_j < y_j$, i.e. at the first position where the words differ the first word has a smaller letter than the second word has.
\end{itemize}

For example, the word ``$3'~7~5$'' is before the word ``$2~4'~6$'' in lexicographical order. It is said that sequence of words is in lexicographical order if each word is not lexicographically greater than the next word in the sequence.

Denis has a sequence of words consisting of small letters only. He wants to change some letters to large (let's call this process a capitalization) in such a way that the sequence of words is in lexicographical order. However, he soon realized that for some reason he can't change a single letter in a single word. He only can choose a letter and change all of its occurrences in all words to large letters. He can perform this operation any number of times with arbitrary letters of Bookland's alphabet.

Help Denis to choose which letters he needs to capitalize (make large) in order to make the sequence of words lexicographically ordered, or determine that it is impossible.

Note that some words can be equal.

Input:

The first line contains two integers $n$ and $m$ ($2 \le n \le 100{,}000$, $1 \le m \le 100{,}000$)~--- the number of words and the number of letters in Bookland's alphabet, respectively. The letters of Bookland's alphabet are denoted by integers from $1$ to $m$.

Each of the next $n$ lines contains a description of one word in format $l_i, s_{i,1}, s_{i,2}, \ldots, s_{i,l_i}$ ($1 \le l_i \le 100{,}000$, $1 \le s_{i,j} \le m$), where $l_i$ is the length of the word, and $s_{i,j}$ is the sequence of letters in the word. The words are given in the order Denis has them in the sequence.

It is guaranteed that the total length of all words is not greater than $100{,}000$.

Output:

In the first line print ``Yes'' (without quotes), if it is possible to capitalize some set of letters in such a way that the sequence of words becomes lexicographically ordered. Otherwise, print ``No'' (without quotes).

If the required is possible, in the second line print $k$~--- the number of letters Denis has to capitalize (make large), and in the third line print $k$ distinct integers~--- these letters. Note that you don't need to minimize the value $k$.

You can print the letters in any order. If there are multiple answers, print any of them.

Note:

In the first example after Denis makes letters $2$ and $3$ large, the sequence looks like the following:
\begin{itemize}
\item $2'$
\item $1$
\item $1~3'~2'$
\item $1~1$
\end{itemize}
The condition $2' < 1$ holds, so the first word is not lexicographically larger than the second word. The second word is the prefix of the third word, so they are in lexicographical order. As the first letters of the third and the fourth words are the same, and $3' < 1$, then the third word is not lexicographically larger than the fourth word.

In the second example the words are in lexicographical order from the beginning, so Denis can do nothing.

In the third example there is no set of letters such that if Denis capitalizes them, the sequence becomes lexicographically ordered.}
\BREAKDOWN{Extract pairwise constraints from each adjacent pair of words at the first differing position. Handle the strict prefix impossibility. Reduce to choosing a subset $S \subseteq \{1,\ldots,m\}$ (letters to capitalize) satisfying implications $y \in S \Rightarrow x \in S$ and unit requirements $x \in S$, $y \notin S$.}
\ELI{Only constraints are ``if you capitalize $y$ you must also capitalize $x$'', plus some letters are forced capitalized or forced small; propagate these implications and check for contradictions.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m$ with $2 \le n \le 100{,}000$, $1 \le m \le 100{,}000$. Then $n$ lines: each starts with $l_i$ followed by $l_i$ integers $s_{i,1}, \ldots, s_{i,l_i}$ in $[1,m]$. Total $\sum l_i \le 100{,}000$.}
\OUTPUTS{Print ``Yes'' or ``No''. If ``Yes'', also print line with $k$~--- the number of capitalized letters, and a line with $k$ distinct integers (any order). If $k=0$, print an empty third line.}
\SAMPLES{Example mini-cases:
\begin{itemize}
\item Input:
\[
\begin{aligned}
&2~3\\
&2~1~2\\
&1~1
\end{aligned}
\]
Output:
\begin{BreakableEquation*}
\text{No}
\end{BreakableEquation*}
\item Input:
\[
\begin{aligned}
&2~3\\
&1~1\\
&2~1~2
\end{aligned}
\]
Output (one valid):
\begin{BreakableEquation*}
\text{Yes}\newline 0\newline
\end{BreakableEquation*}
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the alphabet be $\{1,\ldots,m\}$. Choose a subset $S \subseteq \{1,\ldots,m\}$ to capitalize. The total order on letters is: all capitalized letters (in increasing index), then all small letters (in increasing index). Each adjacent pair of words $(A,B)$ imposes a constraint at the first differing position.}
\varmapStart
\var{S}{subset of letters made large (capitalized)}
\var{A,B}{adjacent words in the given sequence}
\var{x,y}{first differing letters of $A$ and $B$ at some position}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{If $A$ is a strict extension of $B$ and equal on $|B|$ positions, then infeasible.}\\
&\text{If } x<y:\quad (y \in S) \Rightarrow (x \in S).\\
&\text{If } x>y:\quad (x \in S) \text{ and } (y \notin S).
\end{aligned}
\]
}
\ASSUMPTIONS{Words are sequences of integers; lexicographic order induced by the described total order. All occurrences of a letter share the same capitalization choice.}
\INVARIANTS{
\begin{itemize}
\item Implication transitivity: if $y \in S \Rightarrow x \in S$ and $x \in S \Rightarrow z \in S$, then $y \in S \Rightarrow z \in S$.
\item Forced-small letters can never be reached from any forced-large letter in the implication graph.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Naively, one could try all $2^m$ subsets $S$ and check lex order; clearly infeasible. However, the structure is Horn: constraints are implications and unit literals. We can directly construct these constraints from pairs.}
\ASSUMPTIONS{We compute constraints per adjacent pair only at the first differing index; strict prefix violation aborts.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each adjacent pair $(A,B)$, find first position $j$ where they differ or detect strict prefix.
\item If strict prefix with $|A|>|B|$, print ``No''.
\item Else if $x=A_j$, $y=B_j$: add implication $y \to x$ if $x<y$; add unit constraints $x \in S$, $y \notin S$ if $x>y$.
\item Start with $S$ as all forced-large letters; propagate implications along edges; if any forced-small is reached, print ``No''.
\item Print ``Yes'' and the resulting $S$.
\end{algosteps}
\COMPLEXITY{Linear in total input size.}
\[
\begin{aligned}
T(n) &= O\!\left(\sum l_i + m + E\right) \le O(100{,}000) \\
S(n) &= O(m + E)
\end{aligned}
\]
\CORRECTNESS{Every adjacent pair's requirement is necessary. The Horn implication closure yields the least $S$ satisfying all implications and unit requirements; any superset would also work, but the closure already satisfies all pairs. A strict prefix conflict is unresolvable since equal letters stay equal under global capitalization.}
\EDGECASES{Equal words; identical prefixes; multiple implications chains; simultaneous force-large and force-small on same letter; empty $S$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    n = int(next(it))
    m = int(next(it))
    words = []
    for _ in range(n):
        li = int(next(it))
        w = [int(next(it)) for _ in range(li)]
        words.append(w)
    return n, m, words

def build_constraints(n, m, words):
    # adjacency list for implications: y -> x meaning if y is large then x must be large
    adj = [[] for _ in range(m + 1)]
    must_large = [False] * (m + 1)
    must_small = [False] * (m + 1)
    for i in range(n - 1):
        a = words[i]
        b = words[i + 1]
        t = min(len(a), len(b))
        j = 0
        while j < t and a[j] == b[j]:
            j += 1
        if j == t:
            if len(a) > len(b):
                return None, None, None  # impossible
            continue
        x = a[j]
        y = b[j]
        if x < y:
            # implication: if y is large then x must be large
            adj[y].append(x)
        else:
            # x > y: force x large and y small
            must_large[x] = True
            must_small[y] = True
    return adj, must_large, must_small

def solve_all_text(text):
    data = text.strip().split()
    it = iter(data)
    n = int(next(it))
    m = int(next(it))
    words = []
    for _ in range(n):
        li = int(next(it))
        w = [int(next(it)) for _ in range(li)]
        words.append(w)
    ok, k, arr = solve_case(n, m, words)
    if not ok:
        return "No\n"
    out = []
    out.append("Yes")
    out.append(str(k))
    if k == 0:
        out.append("")
    else:
        out.append(" ".join(map(str, arr)))
    return "\n".join(out) + "\n"

def solve_case(n, m, words):
    adj, must_large, must_small = build_constraints(n, m, words)
    if adj is None:
        return False, 0, []
    # check immediate contradictions
    for v in range(1, m + 1):
        if must_large[v] and must_small[v]:
            return False, 0, []
    # propagate implications from all initially forced-large letters
    large = [False] * (m + 1)
    dq = deque()
    for v in range(1, m + 1):
        if must_large[v]:
            large[v] = True
            dq.append(v)
    while dq:
        u = dq.popleft()
        for v in adj[u]:
            if not large[v]:
                if must_small[v]:
                    return False, 0, []
                large[v] = True
                dq.append(v)
    res = [i for i in range(1, m + 1) if large[i]]
    return True, len(res), res

def main():
    n, m, words = read_input()
    ok, k, arr = solve_case(n, m, words)
    if not ok:
        sys.stdout.write("No\n")
        return
    sys.stdout.write("Yes\n")
    sys.stdout.write(str(k) + "\n")
    if k == 0:
        sys.stdout.write("\n")
    else:
        sys.stdout.write(" ".join(map(str, arr)) + "\n")

if __name__ == "__main__":
    # Basic asserts
    # 1) Strict prefix violation -> No
    inp = "2 3\n2 1 2\n1 1\n"
    out = solve_all_text(inp)
    assert out.strip().splitlines()[0] == "No"
    # 2) Already ordered -> Yes, k can be 0
    inp = "2 3\n1 1\n2 1 2\n"
    out = solve_all_text(inp)
    lines = out.strip().splitlines()
    assert lines[0] == "Yes"
    # 3) Need capitalization: [2] then [1] forces 2 large and 1 small
    inp = "2 3\n1 2\n1 1\n"
    out = solve_all_text(inp)
    lines = out.strip().splitlines()
    assert lines[0] == "Yes"
    main()
\end{minted}
\VALIDATION{Checked three small cases: strict prefix impossible, already sorted with $k=0$, and a case requiring capitalization.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Model as a Horn-SAT instance: implications $y \to x$ and unit assignments. Solve via BFS/DFS from forced-true variables to compute transitive closure, while checking conflicts with forced-false variables.}
\ASSUMPTIONS{Implication graph over $m$ nodes; unit facts from $x>y$ pairs; early abort on prefix conflict or contradiction during propagation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build directed graph of implications and unit sets as in Approach A.
\item Initialize queue with all forced-large letters; mark them large.
\item While queue nonempty, pop $u$ and push any unmarked neighbors $v$; if any $v$ is forced-small, report ``No''.
\item Output the marked set.
\end{algosteps}
\COMPLEXITY{Linear in edges and vertices; dominates input size.}
\[
\begin{aligned}
T(n) &= O(m + E) \\
\end{aligned}
\]
\CORRECTNESS{Horn-SAT via forward chaining is sound and complete: closure under $y \to x$ precisely enforces all implications; unit contradictions are detected.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    n = int(next(it))
    m = int(next(it))
    words = []
    for _ in range(n):
        li = int(next(it))
        w = [int(next(it)) for _ in range(li)]
        words.append(w)
    return n, m, words

def build_constraints(n, m, words):
    adj = [[] for _ in range(m + 1)]
    must_large = [False] * (m + 1)
    must_small = [False] * (m + 1)
    for i in range(n - 1):
        a = words[i]
        b = words[i + 1]
        j = 0
        t = min(len(a), len(b))
        while j < t and a[j] == b[j]:
            j += 1
        if j == t:
            if len(a) > len(b):
                return None, None, None
            continue
        x = a[j]; y = b[j]
        if x < y:
            adj[y].append(x)
        else:
            must_large[x] = True
            must_small[y] = True
    return adj, must_large, must_small

def solve_case(n, m, words):
    adj, must_large, must_small = build_constraints(n, m, words)
    if adj is None:
        return False, 0, []
    for v in range(1, m + 1):
        if must_large[v] and must_small[v]:
            return False, 0, []
    large = [False] * (m + 1)
    dq = deque()
    for v in range(1, m + 1):
        if must_large[v]:
            large[v] = True
            dq.append(v)
    while dq:
        u = dq.popleft()
        for v in adj[u]:
            if not large[v]:
                if must_small[v]:
                    return False, 0, []
                large[v] = True
                dq.append(v)
    res = [i for i in range(1, m + 1) if large[i]]
    return True, len(res), res

def solve_all():
    n, m, words = read_input()
    ok, k, arr = solve_case(n, m, words)
    if not ok:
        print("No")
        return
    print("Yes")
    print(k)
    if k == 0:
        print()
    else:
        print(" ".join(map(str, arr)))

def solve_all_text(text):
    data = text.split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    words = []
    for _ in range(n):
        li = int(next(it))
        words.append([int(next(it)) for _ in range(li)])
    ok, k, arr = solve_case(n, m, words)
    if not ok:
        return "No\n"
    ans = ["Yes", str(k), "" if k == 0 else " ".join(map(str, arr))]
    return "\n".join(ans) + "\n"

if __name__ == "__main__":
    # Edge inputs checks
    # Equal words sequence should be OK with k=0
    inp = "3 2\n1 1\n1 1\n1 1\n"
    out = solve_all_text(inp)
    assert out.splitlines()[0] == "Yes"
    # Simple force: 2 then 1 => Yes, and 2 must be in the set
    inp = "2 3\n1 2\n1 1\n"
    out = solve_all_text(inp)
    lines = out.strip().splitlines()
    assert lines[0] == "Yes"
    # Prefix violation
    inp = "2 5\n3 1 2 3\n2 1 2\n"
    out = solve_all_text(inp)
    assert out.strip() == "No"
    solve_all()
\end{minted}
\VALIDATION{Confirmed behavior on equal words, a forced-capitalization pair, and a strict prefix violation.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Treat constraints as a Horn formula over $m$ booleans. Compute the least model by forward-chaining from unit positives through directed implications; check against unit negatives.}
\ASSUMPTIONS{Applicable for any $n,m$ within bounds; adjacency edges and unit literals are derived solely from first-difference logic of lexicographic ordering under the two-tier alphabet order.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan adjacent pairs; on $x>y$ force $x$ large and $y$ small; on $x<y$ add $y \to x$.
\item Abort if any strict-prefix conflict occurs.
\item Initialize $S$ with all forced-large letters; BFS/DFS over the implication graph to add all implied letters; if a forced-small is reached, infeasible.
\item Output $S$.
\end{algosteps}
\OPTIMALITY{This computes the least satisfying capitalization set. Any feasible solution must contain all forced-large letters and their implication-closure; adding more letters preserves feasibility but is unnecessary.}
\COMPLEXITY{$O(\sum l_i + m + E)$ time, $O(m + E)$ space.}
\[
\begin{aligned}
T(n) &= O(100{,}000) \\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    words = []
    for _ in range(n):
        li = int(next(it))
        words.append([int(next(it)) for _ in range(li)])
    return n, m, words

def build_constraints(n, m, words):
    adj = [[] for _ in range(m + 1)]
    must_large = [False] * (m + 1)
    must_small = [False] * (m + 1)
    for i in range(n - 1):
        a = words[i]; b = words[i + 1]
        t = min(len(a), len(b))
        j = 0
        while j < t and a[j] == b[j]:
            j += 1
        if j == t:
            if len(a) > len(b):
                return None, None, None
            continue
        x, y = a[j], b[j]
        if x < y:
            adj[y].append(x)
        else:
            must_large[x] = True
            must_small[y] = True
    return adj, must_large, must_small

def solve_case(n, m, words):
    adj, must_large, must_small = build_constraints(n, m, words)
    if adj is None:
        return False, 0, []
    for v in range(1, m + 1):
        if must_large[v] and must_small[v]:
            return False, 0, []
    large = [False] * (m + 1)
    dq = deque()
    for v in range(1, m + 1):
        if must_large[v]:
            large[v] = True
            dq.append(v)
    while dq:
        u = dq.popleft()
        for v in adj[u]:
            if not large[v]:
                if must_small[v]:
                    return False, 0, []
                large[v] = True
                dq.append(v)
    res = [i for i in range(1, m + 1) if large[i]]
    return True, len(res), res

def solve_all():
    n, m, words = read_input()
    ok, k, arr = solve_case(n, m, words)
    if not ok:
        print("No")
        return
    print("Yes")
    print(k)
    if k == 0:
        print()
    else:
        print(" ".join(map(str, arr)))

def solve_all_text(s):
    data = s.split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    words = []
    for _ in range(n):
        li = int(next(it))
        words.append([int(next(it)) for _ in range(li)])
    ok, k, arr = solve_case(n, m, words)
    if not ok:
        return "No\n"
    return "Yes\n{}\n{}\n".format(k, "" if k == 0 else " ".join(map(str, arr)))

if __name__ == "__main__":
    # Exactly 3 asserts / mini-tests
    # 1) No due to strict prefix
    t1 = "2 3\n2 1 2\n1 1\n"
    assert solve_all_text(t1).strip() == "No"
    # 2) Yes with zero set
    t2 = "2 5\n1 4\n2 4 5\n"
    out2 = solve_all_text(t2).splitlines()
    assert out2[0] == "Yes" and out2[1] == "0"
    # 3) Chain implication: x<y from pair induces edge y->x; force z>y forces z large, y small conflict if reachable
    t3 = "3 4\n1 1\n1 3\n1 2\n"
    # Here 1<3 gives 3->1; 3>2 forces 3 large, 2 small; closure adds 1 large; valid
    o3 = solve_all_text(t3).splitlines()
    assert o3[0] == "Yes" and "3" in (o3[2] if len(o3) > 2 else "")
    solve_all()
\end{minted}
\VALIDATION{Three asserts: strict prefix infeasible; trivial ordered case with $k=0$; a chain with both implication and unit constraints.}
\RESULT{Outputs any capitalization set $S$ meeting all constraints. Ties and multiple valid sets are permitted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: strict prefix conflicts; already sorted sequences; forced capitalization; implication chains; random small cases cross-checked by a verifier.}
\LINE{CROSS-CHECKS}{Compare closure-based solution against a slow brute check for tiny $m$ by enumerating subsets to ensure consistency on small random instances.}
\LINE{EDGE-CASE GENERATOR}{Generate random adjacent pairs that induce each of: $x<y$ implications, $x>y$ unit constraints, and strict prefix.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random
from collections import deque

def slow_bruteforce_ok(n, m, words):
    # For very small m (<=12), enumerate subsets to check feasibility.
    if m > 12:
        return None
    def cmp_word(a, b, S):
        # returns True if a <= b under S
        la, lb = len(a), len(b)
        t = min(la, lb)
        for i in range(t):
            x, y = a[i], b[i]
            if x == y:
                continue
            # compute rank: (tier, index), tier 0 for large, 1 for small
            rx = (0 if x in S else 1, x)
            ry = (0 if y in S else 1, y)
            return rx < ry
        return la <= lb
    for mask in range(1 << m):
        S = {i+1 for i in range(m) if (mask >> i) & 1}
        ok = True
        for i in range(n - 1):
            if not cmp_word(words[i], words[i+1], S):
                ok = False
                break
        if ok:
            return True
    return False

def run_random_small_trials(trials=50, seed=0):
    random.seed(seed)
    for _ in range(trials):
        m = random.randint(1, 6)
        n = random.randint(2, 5)
        words = []
        for _ in range(n):
            L = random.randint(0, 3) + 1
            w = [random.randint(1, m) for __ in range(L)]
            words.append(w)
        brute = slow_bruteforce_ok(n, m, words)
        # use final solver
        from sys import setrecursionlimit
        setrecursionlimit(1_000_000)
        adj = [[] for _ in range(m + 1)]
        must_large = [False] * (m + 1)
        must_small = [False] * (m + 1)
        impossible = False
        for i in range(n - 1):
            a, b = words[i], words[i+1]
            t = min(len(a), len(b))
            j = 0
            while j < t and a[j] == b[j]:
                j += 1
            if j == t:
                if len(a) > len(b):
                    impossible = True
                    break
                continue
            x, y = a[j], b[j]
            if x < y:
                adj[y].append(x)
            else:
                must_large[x] = True
                must_small[y] = True
        if impossible:
            ok = False
        else:
            ok = True
            # check contradictions and propagate
            for v in range(1, m + 1):
                if must_large[v] and must_small[v]:
                    ok = False
                    break
            if ok:
                large = [False] * (m + 1)
                dq = deque([v for v in range(1, m + 1) if must_large[v]])
                for v in dq:
                    large[v] = True
                while dq and ok:
                    u = dq.popleft()
                    for v in adj[u]:
                        if not large[v]:
                            if must_small[v]:
                                ok = False
                                break
                            large[v] = True
                            dq.append(v)
        if brute is not None:
            assert ok == brute, f"Mismatch: {words}, expected {brute}, got {ok}"
    return True

if __name__ == "__main__":
    assert run_random_small_trials(30, seed=123)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    words = []
    for _ in range(n):
        li = int(next(it))
        words.append([int(next(it)) for _ in range(li)])
    return n, m, words

def build_constraints(n, m, words):
    adj = [[] for _ in range(m + 1)]
    must_large = [False] * (m + 1)
    must_small = [False] * (m + 1)
    for i in range(n - 1):
        a = words[i]; b = words[i + 1]
        t = min(len(a), len(b))
        j = 0
        while j < t and a[j] == b[j]:
            j += 1
        if j == t:
            if len(a) > len(b):
                return None, None, None
            continue
        x, y = a[j], b[j]
        if x < y:
            adj[y].append(x)
        else:
            must_large[x] = True
            must_small[y] = True
    return adj, must_large, must_small

def solve_case(n, m, words):
    adj, must_large, must_small = build_constraints(n, m, words)
    if adj is None:
        return False, 0, []
    for v in range(1, m + 1):
        if must_large[v] and must_small[v]:
            return False, 0, []
    large = [False] * (m + 1)
    dq = deque()
    for v in range(1, m + 1):
        if must_large[v]:
            large[v] = True
            dq.append(v)
    while dq:
        u = dq.popleft()
        for v in adj[u]:
            if not large[v]:
                if must_small[v]:
                    return False, 0, []
                large[v] = True
                dq.append(v)
    res = [i for i in range(1, m + 1) if large[i]]
    return True, len(res), res

def main():
    n, m, words = read_input()
    ok, k, arr = solve_case(n, m, words)
    if not ok:
        print("No")
        return
    print("Yes")
    print(k)
    if k == 0:
        print()
    else:
        print(" ".join(map(str, arr)))

def solve_all_text(s):
    data = s.split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    words = []
    for _ in range(n):
        li = int(next(it))
        words.append([int(next(it)) for _ in range(li)])
    ok, k, arr = solve_case(n, m, words)
    if not ok:
        return "No\n"
    return "Yes\n{}\n{}\n".format(k, "" if k == 0 else " ".join(map(str, arr)))

if __name__ == "__main__":
    # Simple sanity asserts
    # 1) Strict prefix -> No
    t1 = "2 3\n2 1 2\n1 1\n"
    assert solve_all_text(t1).strip() == "No"
    # 2) Already ordered -> Yes, k can be 0
    t2 = "2 3\n1 1\n2 1 2\n"
    assert solve_all_text(t2).splitlines()[0] == "Yes"
    # 3) Force capitalization
    t3 = "2 3\n1 3\n1 2\n"
    assert solve_all_text(t3).splitlines()[0] == "Yes"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce lex-order feasibility to Horn implications plus unit constraints and compute their closure.}
\WHY{Common CF pattern: lexicographic constraints with a two-tier alphabet structure yield implication graphs and forced assignments.}
\CHECKLIST{
\begin{itemize}
\item Scan adjacent pairs; find first difference or prefix.
\item If strict prefix with first longer, answer is ``No''.
\item For $x<y$: add implication $y \to x$.
\item For $x>y$: force $x$ large and $y$ small.
\item Propagate from forced-large; check against forced-small.
\item Output the closure set.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item All words identical.
\item First differing position at the last index.
\item Multiple implications forming chains.
\item A letter both forced-large and forced-small.
\item Disconnected graph components.
\item $k=0$ printing format (ensure blank third line).
\item $m=1$ trivial cases.
\item Very long words with total length at limit.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Forgetting the strict-prefix impossibility.
\item Reversing the implication direction for $x<y$.
\item Not checking contradictions before/after propagation.
\item Missing transitive closure (only doing one pass).
\item Not stabilizing the queue when multiple sources exist.
\item Wrong output format when $k=0$ (must still print a third line).
\item Using 1-based vs 0-based indices inconsistently.
\item Mutating shared structures across tests.
\end{itemize}
}
\FAILMODES{Brute-force subset enumeration fails at $m=20+$; incorrect implication direction yields false ``Yes''; skipping transitive closure misses required capitalizations; ignoring forced-small conflicts yields invalid outputs. The presented method avoids all.}
\ELI{Compare neighbors and write down simple rules: if a bigger number must come before a smaller one, make the bigger letter large and keep the smaller one small. If a smaller letter being large would break order, only allow it when all smaller needed ones are also large. Push these requirements through the ``if large then also large'' arrows and ensure no contradictions.}
\NotePages{3}

\end{document}