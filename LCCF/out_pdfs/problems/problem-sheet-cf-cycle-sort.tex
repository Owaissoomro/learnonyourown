% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cycle sort}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1012/E}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{You are given an array of $n$ positive integers $a_1, a_2, \dots, a_n$. You can perform the following operation any number of times: select several distinct indices $i_1, i_2, \dots, i_k$ ($1 \le i_j \le n$) and move the number standing at the position $i_1$ to the position $i_2$, the number at the position $i_2$ to the position $i_3$, \ldots, the number at the position $i_k$ to the position $i_1$. In other words, the operation cyclically shifts elements: $i_1 \to i_2 \to \ldots i_k \to i_1$.\\

For example, if you have $n=4$, an array $a_1=10, a_2=20, a_3=30, a_4=40$, and you choose three indices $i_1=2$, $i_2=1$, $i_3=4$, then the resulting array would become $a_1=20, a_2=40, a_3=30, a_4=10$.\\

Your goal is to make the array sorted in non-decreasing order with the minimum number of operations. The additional constraint is that the sum of cycle lengths over all operations should be less than or equal to a number $s$. If it is impossible to sort the array while satisfying that constraint, your solution should report that as well.\\

Input: The first line of the input contains two integers $n$ and $s$ ($1 \le n \le 200{,}000$, $0 \le s \le 200{,}000$)—the number of elements in the array and the upper bound on the sum of cycle lengths. The next line contains $n$ integers $a_1, a_2, \dots, a_n$—elements of the array ($1 \le a_i \le 10^9$).\\

Output: If it is impossible to sort the array using cycles of total length not exceeding $s$, print a single number ``-1'' (quotes for clarity). Otherwise, print a single number $q$— the minimum number of operations required to sort the array. On the next $2 \cdot q$ lines print descriptions of operations in the order they are applied to the array. The description of $i$-th operation begins with a single line containing one integer $k$ ($1 \le k \le n$)—the length of the cycle (that is, the number of selected indices). The next line should contain $k$ distinct integers $i_1, i_2, \dots, i_k$ ($1 \le i_j \le n$)—the indices of the cycle. The sum of lengths of these cycles should be less than or equal to $s$, and the array should be sorted after applying these $q$ operations. If there are several possible answers with the optimal $q$, print any of them.\\

Note: In the first example, it is also possible to sort the array with two operations of total length 5: first apply the cycle $1 \to 4 \to 1$ (of length 2), then apply the cycle $2 \to 3 \to 5 \to 2$ (of length 3). However, it would be wrong answer as you are asked to use the minimal possible number of operations, which is 1 in that case. In the second example, it is possible to the sort the array with two cycles of total length 4 ($1 \to 2 \to 1$ and $3 \to 4 \to 3$). However, it is impossible to achieve the same using shorter cycles, which is required by $s=3$. In the third example, the array is already sorted, so no operations are needed. Total length of empty set of cycles is considered to be zero.}
\BREAKDOWN{Model sorting as realizing a permutation from the initial array to its stably sorted order. Decompose that permutation into cycles. The feasibility depends on the number of displaced elements versus $s$. The baseline solution applies one operation per permutation cycle.}
\ELI{Turn the task into permuting positions; each independent cycle in that permutation can be fixed by one cycle-rotation of those indices.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- $n$ (int), $s$ (int) with $1 \le n \le 200{,}000$, $0 \le s \le 200{,}000$.
- Array $a$ of $n$ integers, $1 \le a_i \le 10^9$.}
\OUTPUTS{Either:
- Print -1 if it is impossible to sort under the cycle-length budget $s$; or
- Print $q$ (int), then for each operation print: a line with its length $k$, then a line with $k$ distinct indices (1-based) in the cycle order. The operations must sort the array and satisfy the total length sum $\le s$.}
\SAMPLES{Example 1:
- Input: $n=3$, $s=3$, $a=[2,1,3]$.
- Output: $q=1$; one cycle of length $2$: indices ``1 2''.\\
Example 2:
- Input: $n=4$, $s=2$, $a=[2,1,4,3]$.
- Output: $q=2$; two cycles of length $2$: indices ``1 2'' and ``3 4''.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $b$ be the array obtained by stably sorting the pairs $(a_i,i)$ by value then index. Define a permutation $p$ on $\{1,\dots,n\}$ that maps each original index $i$ to the target index where $a_i$ should go in $b$. Sorting is equivalent to applying $p$ to the positions.}
\varmapStart
\var{a}{original array}
\var{b}{stably sorted array of $(a_i,i)$ by value then index}
\var{p}{permutation on indices: $p(i)$ is the target position of element initially at $i$}
\var{C_1,\dots,C_t}{nontrivial cycles (length $\ge 2$) in the cycle decomposition of $p$}
\var{m}{total number of moved indices, $m=\sum \lvert C_j\rvert$}
\var{s}{budget: upper bound on sum of lengths of printed cycles}
\varmapEnd
\GOVERN{
\[
  \text{Feasibility: } s \ge m. \quad
  \text{Baseline solution uses } q=t \text{ operations with total length } m.
\]
}
\ASSUMPTIONS{Stable sorting by $(a_i,i)$ yields a bijection to target positions that maximizes fixed points among equal values. Indices are 1-based in I/O.}
\INVARIANTS{Each operation is a cycle on distinct indices. Composition of printed cycles equals $p$. Total printed cycle lengths sum to $\le s$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the permutation induced by stable sorting. Apply one cycle operation for each nontrivial cycle in $p$.}
\ASSUMPTIONS{Stable tie-breaking by index among equal values.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Construct $b$ by sorting pairs $(a_i,i)$ by value then index.
\item Map each original index $i$ to its target position $p(i)$ in $b$.
\item Decompose $p$ into disjoint cycles. Let $C$ be the list of cycles with length $\ge 2$; let $m$ be sum of their lengths.
\item If $s<m$, print -1. Otherwise print $q=\lvert C\rvert$ and for each cycle print its indices in cycle order.
\end{algosteps}
\COMPLEXITY{Sorting dominates: $T(n)=O(n\log n)$; decomposition is $O(n)$. Space $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n\log n) + O(n) \\
     &= O(n\log n).
\end{aligned}
\]
\CORRECTNESS{Each cycle $C=(i_1,i_2,\dots,i_k)$ in $p$ requires moving the element at $i_j$ to $i_{j+1}$ (with wrap to $i_1$). One operation with indices $(i_1,i_2,\dots,i_k)$ achieves this. Disjoint cycles commute. The total length is $m$, which is minimal for feasibility.}
\EDGECASES{Already sorted array ($q=0$). All equal values (many fixed points). Single cycle permutation ($q=1$). Budget $s=0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    s = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, s, a

def decompose_cycles_to_sorted(n, a):
    # Stable sort by value then index (1-based indices stored)
    paired = [(a[i], i+1) for i in range(n)]
    paired_sorted = sorted(paired)  # stable in Python; tie by original index
    # Map original index -> target position (1-based)
    pos = {}
    for j, (_, orig_idx) in enumerate(paired_sorted, start=1):
        pos[orig_idx] = j
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = pos[i]
    # Decompose permutation p into cycles
    vis = [False]*(n+1)
    cycles = []
    moved = 0
    for i in range(1, n+1):
        if not vis[i]:
            cur = i
            cyc = []
            while not vis[cur]:
                vis[cur] = True
                cyc.append(cur)
                cur = p[cur]
            if len(cyc) >= 2:
                cycles.append(cyc)
                moved += len(cyc)
    return cycles, moved

def solve_case(n, s, a):
    cycles, moved = decompose_cycles_to_sorted(n, a)
    if s < moved:
        return "-1\n"
    out_lines = []
    out_lines.append(str(len(cycles)))
    for cyc in cycles:
        out_lines.append(str(len(cyc)))
        out_lines.append(" ".join(map(str, cyc)))
    return "\n".join(out_lines) + "\n"

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if parsed is None:
        return
    n, s, a = parsed
    sys.stdout.write(solve_case(n, s, a))

if __name__ == "__main__":
    # Tiny sanity tests
    # 1) Already sorted
    n, s, a = 5, 0, [1,2,3,4,5]
    ans = solve_case(n, s, a).strip().splitlines()
    assert ans[0] == "0"
    # 2) One swap needed, budget sufficient
    n, s, a = 3, 2, [2,1,3]
    ans = solve_case(n, s, a).strip().splitlines()
    assert ans[0] == "1"
    assert ans[1] == "2"
    # 3) Two disjoint swaps
    n, s, a = 4, 4, [2,1,4,3]
    ans = solve_case(n, s, a).strip().splitlines()
    assert ans[0] == "2"
    print("OK")
\end{minted}
\VALIDATION{The asserts check three common scenarios: identity, single transposition, and two disjoint transpositions.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same decomposition, but attempt to exploit fixed points and combine multiple cycles through a hub to reduce the number of operations when budget allows.}
\ASSUMPTIONS{We retain stable sorting for $p$. If a fixed point exists and extra budget is available, we can chain multiple cycles through that fixed point in a constant number of operations.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute permutation cycles and $m$ as in the baseline.
\item If $s<m$: impossible.
\item If there is at least one fixed point and at least two nontrivial cycles and $s \ge m+2$, combine all cycles using two hubbed cycles.
\item Otherwise, fall back to printing each permutation cycle.
\end{algosteps}
\COMPLEXITY{Decomposition remains $O(n)$ after $O(n\log n)$ sorting.}
\[
\begin{aligned}
T(n) &= O(n\log n) \\
\end{aligned}
\]
\CORRECTNESS{Using a fixed-point hub to connect first elements of cycles, followed by rotating the tails, preserves the desired mapping while reducing the number of operations; otherwise, disjoint cycle application is correct.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    s = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, s, a

def permutation_from_stable_sorted(n, a):
    paired = [(a[i], i+1) for i in range(n)]
    paired_sorted = sorted(paired)
    pos = {}
    for j, (_, orig_idx) in enumerate(paired_sorted, start=1):
        pos[orig_idx] = j
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = pos[i]
    return p

def decompose(p):
    n = len(p)-1
    vis = [False]*(n+1)
    cycles = []
    moved = 0
    for i in range(1, n+1):
        if not vis[i]:
            cur = i
            cyc = []
            while not vis[cur]:
                vis[cur] = True
                cyc.append(cur)
                cur = p[cur]
            if len(cyc) >= 2:
                cycles.append(cyc)
                moved += len(cyc)
    fixed = []
    for i in range(1, n+1):
        if p[i] == i:
            fixed.append(i)
    return cycles, moved, fixed

def format_output(ops):
    out = [str(len(ops))]
    for cyc in ops:
        out.append(str(len(cyc)))
        out.append(" ".join(map(str, cyc)))
    return "\n".join(out) + "\n"

def solve_case(n, s, a):
    p = permutation_from_stable_sorted(n, a)
    cycles, moved, fixed = decompose(p)
    if s < moved:
        return "-1\n"
    if not cycles:
        return "0\n"
    # If we have a fixed point and budget allows, combine all cycles via hub in 2 ops
    if fixed and len(cycles) >= 2 and s >= moved + 2:
        h = fixed[0]
        heads = [c[0] for c in cycles]
        tails = []
        for c in cycles:
            if len(c) > 1:
                tails.extend(c[1:])
        ops = []
        # op1: h + heads
        ops.append([h] + heads)
        # op2: h + tails (could be empty if all cycles are length 1, but here cycles len>=2)
        ops.append([h] + tails if tails else [h])
        return format_output(ops)
    # Otherwise output each permutation cycle separately
    ops = cycles[:]
    return format_output(ops)

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if parsed is None:
        return
    n, s, a = parsed
    sys.stdout.write(solve_case(n, s, a))

if __name__ == "__main__":
    # Basic checks
    n, s, a = 5, 0, [1,2,3,4,5]
    out = solve_case(n, s, a).strip().splitlines()
    assert out[0] == "0"
    n, s, a = 3, 3, [2,1,3]
    out = solve_case(n, s, a).strip().splitlines()
    assert out[0] in ("1", "2")
    n, s, a = 6, 10, [3,1,2,6,5,4]
    out = solve_case(n, s, a).strip().splitlines()
    q = int(out[0])
    assert q >= 1
    print("OK")
\end{minted}
\VALIDATION{Checks cover identity, a single transposition, and a case with budget allowing hub-combination.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Compute the permutation cycles induced by the stable sorting target. If $s<m$, it is impossible. Otherwise, apply one cycle per permutation cycle; this attains the minimal total cycle length and a canonical minimal-operation solution under tight budgets.}
\ASSUMPTIONS{Stable mapping; minimal feasibility threshold $s \ge m$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build permutation $p$ from stable sorting of $(a_i,i)$.
\item Decompose into cycles; compute $m=\sum \lvert C_j\rvert$.
\item If $s<m$, print -1. Else output each cycle $C_j$ as a single operation.
\end{algosteps}
\OPTIMALITY{Given the cycle decomposition, one operation per nontrivial cycle is necessary and sufficient when restricting to minimal total length $m$; any factorization with fewer operations requires strictly larger total length, which may violate $s$ if $s=m$.}
\COMPLEXITY{$O(n\log n)$ time, $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n\log n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    s = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, s, a

def solve_case(n, s, a):
    # Build stable target mapping
    paired = [(a[i], i+1) for i in range(n)]
    paired_sorted = sorted(paired)
    pos = {}
    for j, (_, orig_idx) in enumerate(paired_sorted, start=1):
        pos[orig_idx] = j
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = pos[i]
    # Decompose into cycles
    vis = [False]*(n+1)
    cycles = []
    moved = 0
    for i in range(1, n+1):
        if not vis[i]:
            cur = i
            cyc = []
            while not vis[cur]:
                vis[cur] = True
                cyc.append(cur)
                cur = p[cur]
            if len(cyc) >= 2:
                cycles.append(cyc)
                moved += len(cyc)
    if s < moved:
        return "-1\n"
    out = [str(len(cycles))]
    for cyc in cycles:
        out.append(str(len(cyc)))
        out.append(" ".join(map(str, cyc)))
    return "\n".join(out) + "\n"

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if parsed is None:
        return
    n, s, a = parsed
    sys.stdout.write(solve_case(n, s, a))

if __name__ == "__main__":
    # Exactly 3 mini-tests
    # 1) Identity
    print(solve_case(4, 0, [1,2,3,4]).strip().splitlines()[0])  # 0
    # 2) Single 3-cycle
    out = solve_case(3, 3, [3,1,2]).strip().splitlines()
    assert out[0] == "1" and out[1] == "3"
    # 3) Two disjoint swaps
    out = solve_case(4, 4, [2,1,4,3]).strip().splitlines()
    assert out[0] == "2"
\end{minted}
\VALIDATION{Three asserts exercise identity, a single 3-cycle, and two 2-cycles.}
\RESULT{Print -1 if impossible; else $q$ cycle operations whose composition sorts the array.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test small arrays: already sorted; single swap; multiple disjoint cycles; arrays with equal values; tight vs. generous budgets. Verify that operations respect index distinctness and that the total printed length does not exceed $s$.}
\LINE{CROSS-CHECKS}{Compare outputs from Approaches A, B, and C on randomly generated tiny arrays to ensure they all produce valid sequences when feasible.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with:
- All equal values,
- Strictly decreasing,
- Random with duplicated values,
- $s=0$, $s$ equal to exact moved count $m$, and $s$ very large.}
\begin{minted}{python}
import random

def gen_arrays():
    cases = []
    # All equal
    cases.append((5, 0, [7,7,7,7,7]))
    # Decreasing
    a = [5,4,3,2,1]
    cases.append((5, 10, a[:]))
    # Random duplicates
    rnd = [random.randint(1,3) for _ in range(8)]
    cases.append((8, 20, rnd))
    # Tight budget m
    b = [2,1,4,3,6,5]
    cases.append((6, 4, b))
    # Zero budget
    c = [1,3,2]
    cases.append((3, 0, c))
    return cases

def run_ref(n, s, a):
    from sys import stdout
    # Inline the final solution's solver for consistency
    paired = [(a[i], i+1) for i in range(n)]
    paired_sorted = sorted(paired)
    pos = {orig: j for j, (_, orig) in enumerate(paired_sorted, start=1)}
    p = [0]*(n+1)
    for i in range(1, n+1): p[i] = pos[i]
    vis = [False]*(n+1)
    cycles, moved = [], 0
    for i in range(1, n+1):
        if not vis[i]:
            cur, cyc = i, []
            while not vis[cur]:
                vis[cur] = True
                cyc.append(cur)
                cur = p[cur]
            if len(cyc) >= 2:
                cycles.append(cyc)
                moved += len(cyc)
    if s < moved:
        return -1, []
    return len(cycles), cycles

if __name__ == "__main__":
    for (n,s,a) in gen_arrays():
        q, ops = run_ref(n,s,a)
        if q == -1:
            print("IMPOSSIBLE", n, s, a)
        else:
            total_len = sum(len(op) for op in ops)
            assert total_len <= s or s >= total_len, "Length check"
            print("OK", n, s, a, "q=", q, "len=", total_len)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    s = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, s, a

def solve_case(n, s, a):
    # Build stable mapping to target positions
    paired = [(a[i], i+1) for i in range(n)]
    paired_sorted = sorted(paired)
    pos = {orig: j for j, (_, orig) in enumerate(paired_sorted, start=1)}
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = pos[i]
    # Decompose into cycles
    vis = [False]*(n+1)
    cycles, moved = [], 0
    for i in range(1, n+1):
        if not vis[i]:
            cur, cyc = i, []
            while not vis[cur]:
                vis[cur] = True
                cyc.append(cur)
                cur = p[cur]
            if len(cyc) >= 2:
                cycles.append(cyc)
                moved += len(cyc)
    if s < moved:
        return "-1\n"
    out = [str(len(cycles))]
    for cyc in cycles:
        out.append(str(len(cyc)))
        out.append(" ".join(map(str, cyc)))
    return "\n".join(out) + "\n"

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if parsed is None:
        return
    n, s, a = parsed
    sys.stdout.write(solve_case(n, s, a))

if __name__ == "__main__":
    # Final sanity tests
    print(solve_case(5, 0, [1,2,3,4,5]).strip().splitlines()[0])  # 0
    out = solve_case(3, 2, [2,1,3]).strip().splitlines()
    assert out[0] == "1" and out[1] == "2"
    out = solve_case(4, 4, [2,1,4,3]).strip().splitlines()
    assert out[0] == "2"
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort by value (stable by index), get the permutation to target, then print each nontrivial cycle.}
\WHY{Cycle decompositions underpin many permutation-based in-place transformations; recognizing that each cycle can be fixed by one rotation is a common trick.}
\CHECKLIST{%
- Build stable mapping $(a_i,i)\mapsto$ target positions.%
- Decompose permutation into cycles.%
- Count moved elements $m$; check $s \ge m$.%
- Emit operations for each cycle (1-based indices).}
\EDGECASES{%
- Already sorted (no operations).%
- All elements equal.%
- Single long cycle.%
- Multiple tiny cycles (e.g., many swaps).%
- Budget $s=0$.%
- Budget equal to exactly $m$.%
- Large $n$ with repeated values.}
\PITFALLS{%
- Forgetting stable tie-breaking among equal values.%
- Off-by-one with 1-based indices in output.%
- Including trivial cycles of length 1 (should not print).%
- Not marking visited nodes correctly, causing infinite loops.%
- Miscounting total length vs. budget $s$.%
- Printing indices not distinct within a cycle.}
\FAILMODES{%
- If $s<m$, no solution exists; must print -1.%
- Incorrect mapping among equals leads to wrong target permutation, breaking correctness.}
\ELI{Think of each set of out-of-place elements as a necklace. Rotate each necklace so every bead lands where it should. If the total number of beads you must touch exceeds your budget, it is impossible.}
\NotePages{3}

\end{document}