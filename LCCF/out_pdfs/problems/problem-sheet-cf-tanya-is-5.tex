% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tanya is 5!}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/737/E}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{Tanya is now five so all her friends gathered together to celebrate her birthday. There are $n$ children on the celebration, including Tanya.

The celebration is close to its end, and the last planned attraction is gaming machines. There are $m$ machines in the hall, they are numbered $1$ through $m$. Each of the children has a list of machines he wants to play on. Moreover, for each of the machines he knows the exact time he wants to play on it. For every machine, no more than one child can play on this machine at the same time.

It is evening already, so every adult wants to go home. To speed up the process, you can additionally rent second copies of each of the machines. To rent the second copy of the $j$-th machine, you have to pay $p_j$ burles. After you rent a machine, you can use it for as long as you want.

How long it will take to make every child play according to his plan, if you have a budget of $b$ burles for renting additional machines? There is only one copy of each machine, so it's impossible to rent a third machine of the same type.

The children can interrupt the game in any moment and continue it later. If the $i$-th child wants to play on the $j$-th machine, it is allowed after you rent the copy of the $j$-th machine that this child would play some part of the time on the $j$-th machine and some part of the time on its copy (each of these parts could be empty). The interruptions and changes take no time and can be performed in any integer moment of time. Of course, a child can't play on more than one machine at the same time.

Remember, that it is not needed to save money (no one saves money at the expense of children happiness!), it is needed to minimize the latest moment of time some child ends his game.

Input:
The first line contains three integers $n$, $m$ and $b$ ($1 \le n \le 40$, $1 \le m \le 10$, $0 \le b \le 10^6$)~--- the number of children, the number of gaming machines and the budget for renting additional machines.

The second line contains $m$ integers $p_1, p_2, \ldots, p_m$ ($1 \le p_j \le 10^6$), where $p_j$ is the rent price for the second copy of the $j$-th machine.

$n$ lines follow, $i$-th of them describes the wishes of the $i$-th child. The line starts with an integer $k_i$ ($0 \le k_i \le m$)~--- the number of machines, the $i$-th child wants to play on. Then there are $k_i$ pairs in the line, the $y$-th of them is $x_{iy}, t_{iy}$. It means that, the $i$-th child wants to play $t_{iy}$ ($1 \le t_{iy} \le 2500$) minutes on the $x_{iy}$-th ($1 \le x_{iy} \le m$) machine. In each of these $n$ lines the values $x_{iy}$ are distinct.

Output:
In the first line print the minimum time in which all the children can finish their games.

In the second line print a string of length $m$ consisting of zeros and ones. The $j$-th character is '1', if the copy of $j$-th machine should be rented, and '0' otherwise.

In the third line print integer $g$ ($0 \le g \le 10^6$)~--- the total number of time segments of continuous playing for all of the children. Then in $g$ lines print the segments as four integers $i, j, s, d$, meaning that the $i$-th child was playing on the $j$-th machine or its copy from the time moment $s$ ($s \ge 0$) for $d$ minutes ($d \ge 1$). You can print these lines in arbitrary order.

If there are multiple answers, print any of them.}
\BREAKDOWN{We must minimize a makespan $T$ under budget $b$ by choosing which machines to rent (at most one extra copy per machine), and then construct any feasible preemptive schedule that respects: per-machine capacity (1 or 2), per-child capacity (no overlap), and exact per-machine usage times for each child.}
\ELI{Binary search on $T$; feasibility reduces to a max-flow with optional doubling of machine capacity if rented. Then decompose the resulting flows into an explicit schedule by greedily filling time slots on machine copies while respecting each child's single-activity constraint.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{From stdin:
- Integers $n, m, b$.
- Array $p[1..m]$ of rent prices.
- For each child $i$, an integer $k_i$ followed by $k_i$ pairs $(x, t)$ meaning $t$ minutes on machine $x$.}
\OUTPUTS{To stdout:
- Line 1: minimal time $T$.
- Line 2: binary string of length $m$ with '1' if the $j$-th machine is rented.
- Line 3: integer $g$ number of segments.
- Next $g$ lines: quadruples $i~j~s~d$ describing schedule segments.}
\SAMPLES{Example A (tiny):
- Input:
  n=1, m=1, b=0; p=[10]; child 1: k=1: (1,3)
- Output:
  T=3
  0
  1
  1 1 0 3

Example B (tiny):
- Input:
  n=2, m=1, b=5; p=[5]; child 1: (1,3); child 2: (1,3)
- Output:
  T=3
  1
  2
  1 1 0 3
  2 1 0 3}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T$ be a candidate makespan. For each machine $j$, choose $r_j \in \{0,1\}$ indicating whether a second copy is rented, with $\sum_j r_j p_j \le b$. Let $x_{ij}^{(1)}, x_{ij}^{(2)} \ge 0$ be the time child $i$ spends on machine $j$'s original and copy (copy exists only if $r_j=1$).}
\varmapStart
\var{n,m}{number of children and machines}
\var{b}{budget}
\var{p_j}{price to rent second copy of machine $j$}
\var{t_{ij}}{required time of child $i$ on machine $j$ (0 if absent)}
\var{T}{makespan to minimize}
\var{r_j}{rent decision $\in\{0,1\}$}
\var{x_{ij}^{(k)}}{allocated time to child $i$ on machine $j$'s copy $k \in \{1,2\}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Feasibility at time }T\text{:} \\
&\sum_{j} \bigl(x_{ij}^{(1)} + x_{ij}^{(2)}\bigr) \le T && \forall i \\
&\sum_{i} x_{ij}^{(1)} \le T,\quad \sum_{i} x_{ij}^{(2)} \le r_j \cdot T && \forall j \\
&x_{ij}^{(1)} + x_{ij}^{(2)} = t_{ij} && \forall i,j \\
&\sum_j r_j p_j \le b,\quad r_j \in \{0,1\} \\
&x_{ij}^{(k)} \in \mathbb{Z}_{\ge 0},\ T \in \mathbb{Z}_{\ge 0}
\end{aligned}
\]
}
\ASSUMPTIONS{Preemption is allowed at integer times; changes incur no time. All $t_{ij}$ are integers, so there is an integral feasible decomposition.}
\INVARIANTS{Total child-time $\sum_j t_{ij}$ lower bounds $T$ for each $i$. For each $j$, total load $\sum_i t_{ij}$ lower bounds $T$ if not rented and lower bounds $\lceil \sum_i t_{ij}/2\rceil$ if rented.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Feasibility at time $T$ reduces to a max-flow on a bipartite network with capacities $T$ on children and machines. Enumerate all rent subsets; for each, test max-flow equality to total demand. Scan $T$ upward from a safe lower bound.}
\ASSUMPTIONS{Small $m \le 10$ allows enumerating $2^m$ rent subsets.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $t_{ij}$ matrix and total demand $D=\sum_{i,j} t_{ij}$. Set $T_{\min}=\max_i \sum_j t_{ij}$; $T_{\max}=D$.
\item For $T=T_{\min},T_{\min}{+}1,\ldots,T_{\max}$:
  \begin{bullets}
  \item For each rent mask (subset of machines), if cost $\le b$, build flow network and test if max-flow equals $D$.
  \item If any subset succeeds, stop and reconstruct one feasible flow.
  \end{bullets}
\item From the successful flow, greedily build an explicit schedule by filling free intervals on each machine copy while ensuring each child runs at most one segment at a time.
\end{algosteps}
\COMPLEXITY{Brute force over $T$ is too slow in worst case ($T_{\max}$ up to $10^6$), but suitable as a baseline reference.
\[
\begin{aligned}
\text{Per }T:~ &2^m \text{ flows},\quad V=\mathcal{O}(n{+}nm{+}m),\ E=\mathcal{O}(nm). \\
\end{aligned}
\]
}
\CORRECTNESS{Max-flow enforces child and machine capacities and exact per-pair requirements. Preemption and integrality guarantee a discrete schedule exists; the greedy construction respects capacities and never runs past $T$.}
\EDGECASES{Zero-demand children; zero budget; renting none vs all; single machine with many children; all $t_{ij}=0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

# ---------- Dinic Max Flow ----------
class Dinic:
    class Edge:
        __slots__ = ("v", "cap", "rev", "orig")
        def __init__(self, v, cap, rev):
            self.v = v
            self.cap = cap
            self.rev = rev
            self.orig = cap
    def __init__(self, n):
        self.n = n
        self.g = [[] for _ in range(n)]
    def add_edge(self, u, v, c):
        a = Dinic.Edge(v, c, None)
        b = Dinic.Edge(u, 0, a)
        a.rev = b; b.rev = a
        self.g[u].append(a)
        self.g[v].append(b)
        return a  # return forward edge for flow inspection
    def bfs(self, s, t, level):
        for i in range(self.n):
            level[i] = -1
        q = deque([s])
        level[s] = 0
        while q:
            u = q.popleft()
            for e in self.g[u]:
                if e.cap > 0 and level[e.v] < 0:
                    level[e.v] = level[u] + 1
                    if e.v == t:
                        return True
                    q.append(e.v)
        return level[t] >= 0
    def dfs(self, u, t, f, level, it):
        if u == t:
            return f
        i = it[u]
        while i < len(self.g[u]):
            e = self.g[u][i]
            if e.cap > 0 and level[e.v] == level[u] + 1:
                ret = self.dfs(e.v, t, min(f, e.cap), level, it)
                if ret:
                    e.cap -= ret
                    e.rev.cap += ret
                    return ret
            i += 1
            it[u] = i
        return 0
    def maxflow(self, s, t):
        flow = 0
        level = [-1]*self.n
        INF = 10**30
        while self.bfs(s, t, level):
            it = [0]*self.n
            while True:
                pushed = self.dfs(s, t, INF, level, it)
                if not pushed:
                    break
                flow += pushed
        return flow

# ---------- Problem-specific helpers ----------
def build_network(n, m, b, prices, times, T, rent_mask, want_detail=False):
    # copies per machine: 1 or 2 depending on rent_mask bit
    copy_nodes = []  # list of (machine_index, copy_id) -> node index
    copy_index_lists = [[] for _ in range(m)]
    # Node indexing:
    # 0: source
    # 1..n: child nodes
    # after children: wish nodes per (i,j) where times[i][j] > 0
    # then copy nodes
    # last: sink
    wish_nodes = {}
    wish_list = []  # (i,j,node_index)
    node_id = 1 + n
    # create wish nodes
    for i in range(n):
        for j in range(m):
            t = times[i][j]
            if t > 0:
                wish_nodes[(i, j)] = node_id
                wish_list.append((i, j, node_id))
                node_id += 1
    # reserve indices for copies
    for j in range(m):
        copies = 1 + ((rent_mask >> j) & 1)
        for k in range(copies):
            copy_index_lists[j].append(node_id)
            copy_nodes.append((j, k, node_id))
            node_id += 1
    sink = node_id
    N = sink + 1
    din = Dinic(N)
    s = 0; t = sink

    # source -> child with cap T
    for i in range(n):
        din.add_edge(s, 1+i, T)

    # child -> wish with cap t_ij
    wish_in_edges = {}
    for (i, j, wnode) in wish_list:
        e = din.add_edge(1+i, wnode, times[i][j])
        wish_in_edges[(i, j)] = e

    # wish -> copy edges with cap t_ij
    wish_to_copy_edges = defaultdict(list)
    for (i, j, wnode) in wish_list:
        need = times[i][j]
        for cn in copy_index_lists[j]:
            e = din.add_edge(wnode, cn, need)
            wish_to_copy_edges[(i, j)].append(e)

    # copy -> sink edges cap T
    for (j, k, cn) in copy_nodes:
        din.add_edge(cn, t, T)

    total_need = sum(times[i][j] for i in range(n) for j in range(m))
    flow = din.maxflow(s, t)
    if not want_detail:
        return flow == total_need, None, None
    # extract per (i, copy-node) flow
    # Used flow on wish->copy equals orig - cap
    flows_by_child_copy = defaultdict(int)
    for (i, j, wnode) in wish_list:
        for e in wish_to_copy_edges[(i, j)]:
            used = e.orig - e.cap
            if used > 0:
                flows_by_child_copy[(i, e.v)] += used
    # also record mapping copy-node -> machine index
    copynode_to_machine = {}
    for (j, k, cn) in copy_nodes:
        copynode_to_machine[cn] = j
    return (flow == total_need), flows_by_child_copy, copynode_to_machine

def feasible_subset_and_flow(n, m, b, prices, times, T, sorted_masks, want_detail=False):
    for cost, mask in sorted_masks:
        if cost > b:
            break
        ok, flows, cn2mj = build_network(n, m, b, prices, times, T, mask, want_detail=want_detail)
        if ok:
            if want_detail:
                return True, mask, flows, cn2mj
            else:
                return True, mask, None, None
    if want_detail:
        return False, None, None, None
    return False, None, None, None

def schedule_from_flow(n, m, T, mask, flows_by_child_copy, copynode_to_machine):
    # Build free interval lists for each copy-node
    copy_nodes = sorted(set(copynode_to_machine.keys()))
    free = {cn: [[0, T]] for cn in copy_nodes}
    # For fast search, maintain cursor per copy-node
    curs = {cn: 0 for cn in copy_nodes}
    # Build per-child demands map: copy-node -> remaining
    per_child = [dict() for _ in range(n)]
    for (i, cn), v in flows_by_child_copy.items():
        per_child[i][cn] = per_child[i].get(cn, 0) + v

    segments = []
    # For deterministic choices, order copies by (machine, copy-node id)
    ordered_copies = sorted(copy_nodes, key=lambda cn: (copynode_to_machine[cn], cn))
    for i in range(n):
        rem = per_child[i]
        if not rem:
            continue
        cur_t = 0
        # While some remaining time
        while True:
            # Check if all done
            total_rem = sum(rem.values())
            if total_rem == 0:
                break
            best_cn = None
            best_start = None
            best_end = None
            # Find earliest usable interval among copies with remaining > 0
            for cn in ordered_copies:
                need = rem.get(cn, 0)
                if need <= 0:
                    continue
                lst = free[cn]
                k = curs[cn]
                # advance k until interval end > cur_t
                while k < len(lst) and lst[k][1] <= cur_t:
                    k += 1
                curs[cn] = k
                if k >= len(lst):
                    continue
                a, b = lst[k]
                start = max(cur_t, a)
                if start < b:
                    if best_start is None or start < best_start or (start == best_start and (copynode_to_machine[cn], cn) < (copynode_to_machine.get(best_cn, 10**9), best_cn)):
                        best_cn = cn
                        best_start = start
                        best_end = b
            if best_cn is None:
                # No interval starting at/after cur_t: advance cur_t to the earliest next free start over all needed copies
                next_start = None
                for cn in ordered_copies:
                    if rem.get(cn, 0) <= 0:
                        continue
                    lst = free[cn]
                    k = curs[cn]
                    if k < len(lst):
                        a, b = lst[k]
                        cand = max(cur_t, a)
                        if cand < b:
                            if next_start is None or cand < next_start:
                                next_start = cand
                if next_start is None:
                    # Should not happen if flows are feasible
                    raise RuntimeError("No available slot to schedule remaining demand")
                cur_t = next_start
                continue
            # Allocate
            cn = best_cn
            a = best_start
            b = best_end
            need = rem[cn]
            take = min(need, b - a)
            # record segment
            mj = copynode_to_machine[cn]
            segments.append((i+1, mj+1, a, take))
            # update free list
            lst = free[cn]
            k = curs[cn]
            old_a, old_b = lst[k]
            # old_a <= a < old_b
            new_intervals = []
            if old_a < a:
                new_intervals.append([old_a, a])
            if a + take < old_b:
                new_intervals.append([a + take, old_b])
            # replace interval at position k
            lst.pop(k)
            if new_intervals:
                for seg in reversed(new_intervals):
                    lst.insert(k, seg)
            # Do not advance k unnecessarily; keep cursor at current index
            rem[cn] = need - take
            cur_t = a + take
    return segments

def solve_case(data):
    n, m, b, prices, times = data
    # Precompute masks sorted by total cost
    masks = []
    for mask in range(1 << m):
        cost = 0
        for j in range(m):
            if (mask >> j) & 1:
                cost += prices[j]
        masks.append((cost, mask))
    masks.sort()

    total_need = sum(times[i][j] for i in range(n) for j in range(m))
    child_sums = [sum(times[i][j] for j in range(m)) for i in range(n)]
    T_lo = max(child_sums) if child_sums else 0
    T_hi = total_need

    # Linear scan baseline (inefficient but correct)
    best_mask = None
    best_T = None
    for T in range(T_lo, T_hi+1):
        ok, mask, _, _ = feasible_subset_and_flow(n, m, b, prices, times, T, masks, want_detail=False)
        if ok:
            best_T = T
            best_mask = mask
            break

    # Reconstruct flow at best_T
    ok, mask, flows, cn2mj = feasible_subset_and_flow(n, m, b, prices, times, best_T, masks, want_detail=True)
    assert ok
    segments = schedule_from_flow(n, m, best_T, mask, flows, cn2mj)

    rent_str = ''.join('1' if (mask >> j) & 1 else '0' for j in range(m))
    out_lines = []
    out_lines.append(str(best_T))
    out_lines.append(rent_str)
    out_lines.append(str(len(segments)))
    for (i, j, s, d) in segments:
        out_lines.append(f"{i} {j} {s} {d}")
    return "\n".join(out_lines)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it)); b = int(next(it))
    prices = [int(next(it)) for _ in range(m)]
    times = [[0]*m for _ in range(n)]
    for i in range(n):
        k = int(next(it))
        for _ in range(k):
            x = int(next(it)) - 1
            t = int(next(it))
            times[i][x] = t
    return (n, m, b, prices, times)

def main():
    data = read_input()
    if data is None:
        return
    print(solve_case(data))

if __name__ == "__main__":
    # Tiny self-checks
    # 1) Single child, single machine, no rent needed
    n, m, b = 1, 1, 0
    prices = [10]
    times = [[3]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[0] == "3" and out[1] == "0"
    # 2) Two children, one machine, can rent to halve makespan
    n, m, b = 2, 1, 5
    prices = [5]
    times = [[3],[3]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[0] == "3" and out[1] == "1"
    # 3) Two machines, zero budget
    n, m, b = 2, 2, 0
    prices = [7, 8]
    times = [[2,2],[2,0]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[0] == "4" and out[1] == "00"
    # If actual input present, run main
    if not sys.stdin.isatty():
        sys.stdin.seek(0)
        main()
\end{minted}
\VALIDATION{We asserted simple scenarios covering: no renting, renting helps, and multiple machines under zero budget.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Replace linear scan of $T$ by binary search on $[T_{\min}, T_{\max}]$, since feasibility is monotone in $T$. For each $T$, iterate rent subsets sorted by price and stop at the first feasible within budget.}
\ASSUMPTIONS{Feasibility is monotone: if a given $T$ is feasible under some rent subset, any larger $T$ is also feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute subset costs and sort ascending.
\item Binary search $T$ in $[T_{\min}, T_{\max}]$; feasibility test uses one max-flow per subset until success or budget exceeded.
\item Recompute flow at optimal $T$ to recover detailed flows, then schedule greedily into segments.
\end{algosteps}
\COMPLEXITY{Binary search reduces the number of $T$ values from $\mathcal{O}(T_{\max})$ to $\mathcal{O}(\log T_{\max})$.
\[
\begin{aligned}
T(n) &= \mathcal{O}\bigl(2^m \cdot \log T_{\max} \cdot \text{Flow}(V,E)\bigr) \\
\end{aligned}
\]
}
\CORRECTNESS{Same as baseline; monotonicity justifies binary search. The greedy schedule is feasible because it never violates machine-copy capacities and respects each child's single-activity constraint.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

class Dinic:
    class Edge:
        __slots__ = ("v", "cap", "rev", "orig")
        def __init__(self, v, cap, rev):
            self.v = v; self.cap = cap; self.rev = rev; self.orig = cap
    def __init__(self, n):
        self.n = n; self.g = [[] for _ in range(n)]
    def add_edge(self, u, v, c):
        a = Dinic.Edge(v, c, None); b = Dinic.Edge(u, 0, a); a.rev = b; b.rev = a
        self.g[u].append(a); self.g[v].append(b); return a
    def bfs(self, s, t, level):
        for i in range(self.n): level[i] = -1
        dq = deque([s]); level[s] = 0
        while dq:
            u = dq.popleft()
            for e in self.g[u]:
                if e.cap > 0 and level[e.v] < 0:
                    level[e.v] = level[u] + 1
                    if e.v == t: return True
                    dq.append(e.v)
        return level[t] >= 0
    def dfs(self, u, t, f, level, it):
        if u == t: return f
        i = it[u]
        while i < len(self.g[u]):
            e = self.g[u][i]
            if e.cap > 0 and level[e.v] == level[u] + 1:
                ret = self.dfs(e.v, t, min(f, e.cap), level, it)
                if ret:
                    e.cap -= ret; e.rev.cap += ret; return ret
            i += 1; it[u] = i
        return 0
    def maxflow(self, s, t):
        flow = 0; level = [-1]*self.n; INF = 10**30
        while self.bfs(s, t, level):
            it = [0]*self.n
            while True:
                pushed = self.dfs(s, t, INF, level, it)
                if not pushed: break
                flow += pushed
        return flow

def build_network(n, m, prices, times, T, rent_mask, want_detail=False):
    copy_nodes = []; copy_index_lists = [[] for _ in range(m)]
    wish_nodes = {}; wish_list = []; node_id = 1 + n
    for i in range(n):
        for j in range(m):
            t = times[i][j]
            if t > 0:
                wish_nodes[(i, j)] = node_id; wish_list.append((i, j, node_id)); node_id += 1
    for j in range(m):
        copies = 1 + ((rent_mask >> j) & 1)
        for k in range(copies):
            copy_index_lists[j].append(node_id); copy_nodes.append((j, k, node_id)); node_id += 1
    sink = node_id; N = sink + 1; s = 0; t = sink
    din = Dinic(N)
    for i in range(n): din.add_edge(s, 1+i, T)
    wish_in = {}
    for (i, j, w) in wish_list:
        wish_in[(i, j)] = din.add_edge(1+i, w, times[i][j])
    w2c = defaultdict(list)
    for (i, j, w) in wish_list:
        need = times[i][j]
        for cn in copy_index_lists[j]:
            w2c[(i, j)].append(din.add_edge(w, cn, need))
    for (j, k, cn) in copy_nodes:
        din.add_edge(cn, t, T)
    total_need = sum(times[i][j] for i in range(n) for j in range(m))
    flow = din.maxflow(s, t)
    if not want_detail:
        return flow == total_need, None, None
    flows_by_child_copy = defaultdict(int)
    for (i, j, w) in wish_list:
        for e in w2c[(i, j)]:
            used = e.orig - e.cap
            if used > 0:
                flows_by_child_copy[(i, e.v)] += used
    cn2mj = {}
    for (j, k, cn) in copy_nodes:
        cn2mj[cn] = j
    return (flow == total_need), flows_by_child_copy, cn2mj

def feasible_subset(n, m, b, prices, times, T, sorted_masks, want_detail=False):
    for cost, mask in sorted_masks:
        if cost > b: break
        ok, flows, cn2mj = build_network(n, m, prices, times, T, mask, want_detail=want_detail)
        if ok:
            if want_detail: return True, mask, flows, cn2mj
            return True, mask, None, None
    if want_detail: return False, None, None, None
    return False, None, None, None

def schedule(n, m, T, mask, flows_by_child_copy, cn2mj):
    copy_nodes = sorted(cn2mj.keys())
    free = {cn: [[0, T]] for cn in copy_nodes}
    curs = {cn: 0 for cn in copy_nodes}
    per_child = [dict() for _ in range(n)]
    for (i, cn), v in flows_by_child_copy.items():
        per_child[i][cn] = per_child[i].get(cn, 0) + v
    ordered = sorted(copy_nodes, key=lambda cn: (cn2mj[cn], cn))
    segs = []
    for i in range(n):
        rem = per_child[i]
        if not rem: continue
        cur_t = 0
        while sum(rem.values()) > 0:
            best = None
            best_start = None
            best_end = None
            for cn in ordered:
                if rem.get(cn, 0) <= 0: continue
                lst = free[cn]; k = curs[cn]
                while k < len(lst) and lst[k][1] <= cur_t:
                    k += 1
                curs[cn] = k
                if k >= len(lst): continue
                a, b = lst[k]; start = max(cur_t, a)
                if start < b:
                    if best_start is None or start < best_start or (start == best_start and (cn2mj[cn], cn) < (cn2mj[best], best)):
                        best = cn; best_start = start; best_end = b
            if best is None:
                # advance to next available time
                nxt = None
                for cn in ordered:
                    if rem.get(cn, 0) <= 0: continue
                    lst = free[cn]; k = curs[cn]
                    if k < len(lst):
                        a, b = lst[k]
                        cand = max(cur_t, a)
                        if cand < b and (nxt is None or cand < nxt):
                            nxt = cand
                if nxt is None:
                    raise RuntimeError("Scheduling failed unexpectedly")
                cur_t = nxt
                continue
            cn = best; a = best_start; b = best_end
            take = min(rem[cn], b - a)
            mj = cn2mj[cn]
            segs.append((i+1, mj+1, a, take))
            lst = free[cn]; k = curs[cn]; oa, ob = lst[k]
            new_ints = []
            if oa < a: new_ints.append([oa, a])
            if a + take < ob: new_ints.append([a+take, ob])
            lst.pop(k)
            if new_ints:
                for z in reversed(new_ints): lst.insert(k, z)
            rem[cn] -= take
            cur_t = a + take
    return segs

def solve_case(data):
    n, m, b, prices, times = data
    masks = []
    for mask in range(1 << m):
        cost = sum(prices[j] for j in range(m) if (mask >> j) & 1)
        masks.append((cost, mask))
    masks.sort()
    total_need = sum(times[i][j] for i in range(n) for j in range(m))
    child_sums = [sum(times[i][j] for j in range(m)) for i in range(n)]
    T_lo = max(child_sums) if child_sums else 0
    T_hi = total_need
    # Binary search
    lo, hi = T_lo, T_hi
    best_mask = 0
    while lo < hi:
        mid = (lo + hi) // 2
        ok, mask, _, _ = feasible_subset(n, m, b, prices, times, mid, masks, want_detail=False)
        if ok:
            hi = mid; best_mask = mask
        else:
            lo = mid + 1
    T = lo
    ok, mask, flows, cn2mj = feasible_subset(n, m, b, prices, times, T, masks, want_detail=True)
    assert ok
    segs = schedule(n, m, T, mask, flows, cn2mj)
    rent_str = ''.join('1' if (mask >> j) & 1 else '0' for j in range(m))
    out = []
    out.append(str(T)); out.append(rent_str); out.append(str(len(segs)))
    for (i, j, s, d) in segs:
        out.append(f"{i} {j} {s} {d}")
    return "\n".join(out)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data: return None
    it = iter(data)
    n = int(next(it)); m = int(next(it)); b = int(next(it))
    prices = [int(next(it)) for _ in range(m)]
    times = [[0]*m for _ in range(n)]
    for i in range(n):
        k = int(next(it))
        for _ in range(k):
            x = int(next(it)) - 1; t = int(next(it))
            times[i][x] = t
    return (n, m, b, prices, times)

def main():
    data = read_input()
    if data is None: return
    print(solve_case(data))

if __name__ == "__main__":
    # Basic asserts
    n, m, b = 1, 1, 0
    prices = [10]; times = [[3]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[0] == "3" and out[1] == "0"
    n, m, b = 2, 1, 5
    prices = [5]; times = [[3],[3]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[0] == "3" and out[1] == "1"
    n, m, b = 2, 2, 0
    prices = [7, 8]; times = [[2,2],[2,0]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[0] == "4" and out[1] == "00"
    if not sys.stdin.isatty():
        sys.stdin.seek(0); main()
\end{minted}
\VALIDATION{Same tiny asserts as baseline; binary search now finds optimal $T$ efficiently.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Binary search on $T$, per-$T$ feasibility via max-flow on a network that models: source $\to$ child ($T$), child $\to$ wish$(i,j)$ ($t_{ij}$), wish$(i,j)$ $\to$ each copy of machine $j$ ($t_{ij}$), copy $\to$ sink ($T$). Enumerate rent subsets (at most $2^{10}$) sorted by price and stop at the first within budget that achieves full flow. Then transform the integral flow into a concrete schedule.}
\ASSUMPTIONS{All data integral; preemptions allowed at integers; capacities are multiples of minutes.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $T_{\min}=\max_i \sum_j t_{ij}$ and $T_{\max}=\sum_{i,j} t_{ij}$.
\item Precompute rent subsets and their costs; sort ascending.
\item Binary search $T$:
  \begin{bullets}
  \item For each rent subset with cost $\le b$, build the flow network for time $T$ and check if max-flow equals total demand.
  \item If any succeeds, $T$ is feasible; otherwise infeasible.
  \end{bullets}
\item Rebuild the network at optimal $T$ with the chosen subset and extract flows $f_{i,c}$ from child $i$ to each machine copy $c$.
\item Schedule: maintain free intervals $[0,T)$ for each copy. For each child, greedily take earliest free intervals among copies it still needs, always starting at or after its current time pointer. Emit segments; this respects machine and child capacities and finishes by $T$.}
\end{algosteps}
\OPTIMALITY{Feasibility monotonicity in $T$ guarantees binary search finds the minimal $T$. The flow construction captures all constraints; integral capacities yield integral flows, and every integral flow in a bipartite capacitated network admits a preemptive schedule.}
\COMPLEXITY{With $m \le 10$, subsets are at most $1024$. Networks have $\mathcal{O}(n+nm+m)$ nodes and $\mathcal{O}(nm)$ edges.
\[
\begin{aligned}
T(n) &= \mathcal{O}\!\left(2^m \cdot \log T_{\max} \cdot \text{Flow}(V,E)\right),\quad S(n)=\mathcal{O}(V+E).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

class Dinic:
    class Edge:
        __slots__ = ("v", "cap", "rev", "orig")
        def __init__(self, v, cap, rev):
            self.v = v; self.cap = cap; self.rev = rev; self.orig = cap
    def __init__(self, n):
        self.n = n; self.g = [[] for _ in range(n)]
    def add_edge(self, u, v, c):
        a = Dinic.Edge(v, c, None); b = Dinic.Edge(u, 0, a); a.rev = b; b.rev = a
        self.g[u].append(a); self.g[v].append(b); return a
    def bfs(self, s, t, level):
        for i in range(self.n): level[i] = -1
        dq = deque([s]); level[s] = 0
        while dq:
            u = dq.popleft()
            for e in self.g[u]:
                if e.cap > 0 and level[e.v] < 0:
                    level[e.v] = level[u] + 1
                    if e.v == t: return True
                    dq.append(e.v)
        return level[t] >= 0
    def dfs(self, u, t, f, level, it):
        if u == t: return f
        i = it[u]
        while i < len(self.g[u]):
            e = self.g[u][i]
            if e.cap > 0 and level[e.v] == level[u] + 1:
                ret = self.dfs(e.v, t, min(f, e.cap), level, it)
                if ret:
                    e.cap -= ret; e.rev.cap += ret; return ret
            i += 1; it[u] = i
        return 0
    def maxflow(self, s, t):
        flow = 0; level = [-1]*self.n; INF = 10**30
        while self.bfs(s, t, level):
            it = [0]*self.n
            while True:
                pushed = self.dfs(s, t, INF, level, it)
                if not pushed: break
                flow += pushed
        return flow

def build_network(n, m, prices, times, T, rent_mask, want_detail=False):
    copy_nodes = []; copy_index_lists = [[] for _ in range(m)]
    wish_nodes = {}; wish_list = []; node_id = 1 + n
    for i in range(n):
        for j in range(m):
            t = times[i][j]
            if t > 0:
                wish_nodes[(i, j)] = node_id; wish_list.append((i, j, node_id)); node_id += 1
    for j in range(m):
        copies = 1 + ((rent_mask >> j) & 1)
        for k in range(copies):
            copy_index_lists[j].append(node_id); copy_nodes.append((j, k, node_id)); node_id += 1
    sink = node_id; N = sink + 1; s = 0; t = sink
    din = Dinic(N)
    for i in range(n): din.add_edge(s, 1+i, T)
    w2c = defaultdict(list)
    for (i, j, w) in wish_list:
        din.add_edge(1+i, w, times[i][j])
    for (i, j, w) in wish_list:
        need = times[i][j]
        for cn in copy_index_lists[j]:
            w2c[(i, j)].append(din.add_edge(w, cn, need))
    for (j, k, cn) in copy_nodes:
        din.add_edge(cn, t, T)
    total_need = sum(times[i][j] for i in range(n) for j in range(m))
    flow = din.maxflow(s, t)
    if not want_detail:
        return flow == total_need, None, None
    flows_by_child_copy = defaultdict(int)
    for (i, j, w) in wish_list:
        for e in w2c[(i, j)]:
            used = e.orig - e.cap
            if used > 0:
                flows_by_child_copy[(i, e.v)] += used
    cn2mj = {}
    for (j, k, cn) in copy_nodes:
        cn2mj[cn] = j
    return (flow == total_need), flows_by_child_copy, cn2mj

def feasible_subset(n, m, b, prices, times, T, sorted_masks, want_detail=False):
    for cost, mask in sorted_masks:
        if cost > b: break
        ok, flows, cn2mj = build_network(n, m, prices, times, T, mask, want_detail=want_detail)
        if ok:
            if want_detail: return True, mask, flows, cn2mj
            return True, mask, None, None
    if want_detail: return False, None, None, None
    return False, None, None, None

def schedule_from_flow(n, m, T, flows_by_child_copy, cn2mj):
    copy_nodes = sorted(cn2mj.keys())
    free = {cn: [[0, T]] for cn in copy_nodes}
    curs = {cn: 0 for cn in copy_nodes}
    per_child = [dict() for _ in range(n)]
    for (i, cn), v in flows_by_child_copy.items():
        per_child[i][cn] = per_child[i].get(cn, 0) + v
    ordered = sorted(copy_nodes, key=lambda cn: (cn2mj[cn], cn))
    segs = []
    for i in range(n):
        rem = per_child[i]
        if not rem: continue
        cur_t = 0
        while sum(rem.values()) > 0:
            best = None; best_start = None; best_end = None
            for cn in ordered:
                if rem.get(cn, 0) <= 0: continue
                lst = free[cn]; k = curs[cn]
                while k < len(lst) and lst[k][1] <= cur_t:
                    k += 1
                curs[cn] = k
                if k >= len(lst): continue
                a, b = lst[k]; start = max(cur_t, a)
                if start < b:
                    if best_start is None or start < best_start or (start == best_start and (cn2mj[cn], cn) < (cn2mj[best], best)):
                        best = cn; best_start = start; best_end = b
            if best is None:
                nxt = None
                for cn in ordered:
                    if rem.get(cn, 0) <= 0: continue
                    lst = free[cn]; k = curs[cn]
                    if k < len(lst):
                        a, b = lst[k]; cand = max(cur_t, a)
                        if cand < b and (nxt is None or cand < nxt): nxt = cand
                if nxt is None: raise RuntimeError("Scheduling impossible despite feasible flow")
                cur_t = nxt; continue
            cn = best; a = best_start; b = best_end
            take = min(rem[cn], b - a)
            mj = cn2mj[cn]
            segs.append((i+1, mj+1, a, take))
            lst = free[cn]; k = curs[cn]; oa, ob = lst[k]
            new_ints = []
            if oa < a: new_ints.append([oa, a])
            if a + take < ob: new_ints.append([a+take, ob])
            lst.pop(k)
            if new_ints:
                for seg in reversed(new_ints): lst.insert(k, seg)
            rem[cn] -= take
            cur_t = a + take
    return segs

def solve_case(data):
    n, m, b, prices, times = data
    masks = []
    for mask in range(1 << m):
        cost = sum(prices[j] for j in range(m) if (mask >> j) & 1)
        masks.append((cost, mask))
    masks.sort()
    total_need = sum(times[i][j] for i in range(n) for j in range(m))
    child_sums = [sum(times[i][j] for j in range(m)) for i in range(n)]
    T_lo = max(child_sums) if child_sums else 0
    T_hi = total_need
    lo, hi = T_lo, T_hi
    while lo < hi:
        mid = (lo + hi) // 2
        ok, mask, _, _ = feasible_subset(n, m, b, prices, times, mid, masks, want_detail=False)
        if ok: hi = mid
        else: lo = mid + 1
    T = lo
    ok, mask, flows, cn2mj = feasible_subset(n, m, b, prices, times, T, masks, want_detail=True)
    assert ok
    segs = schedule_from_flow(n, m, T, flows, cn2mj)
    rent_str = ''.join('1' if (mask >> j) & 1 else '0' for j in range(m))
    out = []
    out.append(str(T)); out.append(rent_str); out.append(str(len(segs)))
    for (i, j, s, d) in segs:
        out.append(f"{i} {j} {s} {d}")
    return "\n".join(out)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data: return None
    it = iter(data)
    n = int(next(it)); m = int(next(it)); b = int(next(it))
    prices = [int(next(it)) for _ in range(m)]
    times = [[0]*m for _ in range(n)]
    for i in range(n):
        k = int(next(it))
        for _ in range(k):
            x = int(next(it)) - 1; t = int(next(it))
            times[i][x] = t
    return (n, m, b, prices, times)

def solve_all():
    data = read_input()
    if data is None: return ""
    return solve_case(data)

def main():
    ans = solve_all()
    if ans != "":
        print(ans)

if __name__ == "__main__":
    # Exactly 3 asserts
    n, m, b = 1, 1, 0
    prices = [10]; times = [[3]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[0] == "3"
    n, m, b = 2, 1, 5
    prices = [5]; times = [[3],[3]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[1] == "1"
    n, m, b = 2, 2, 0
    prices = [7, 8]; times = [[2,2],[2,0]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[1] == "00"
    # run if input is present
    if not sys.stdin.isatty():
        sys.stdin.seek(0); main()
\end{minted}
\VALIDATION{Three asserts cover renting decision, minimal time, and multi-machine no-rent case.}
\RESULT{Outputs the minimal makespan, a binary rent decision string, and a valid preemptive schedule as segments. Any valid schedule is accepted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny instances; property checks: total scheduled time per $(i,j)$ equals $t_{ij}$; per-machine total time $\le$ $T$ or $2T$ if rented; child schedule non-overlapping and ends by $T$.}
\LINE{CROSS-CHECKS}{Compare $T$ from brute-force scan (Approach A) and binary-search solution (Approach B/C) on small random seeds.}
\LINE{EDGE-CASE GENERATOR}{Generates degenerate cases: zero-demand children, single machine, all on one machine, budget 0 or very large.}
\begin{minted}{python}
import random

def gen_case(n=3, m=3, max_t=5, budget_mode="zero"):
    times = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if random.random() < 0.5:
                times[i][j] = random.randint(0, max_t)
    prices = [random.randint(1, 5) for _ in range(m)]
    if budget_mode == "zero":
        b = 0
    elif budget_mode == "all":
        b = sum(prices)
    else:
        b = random.randint(0, sum(prices))
    return n, m, b, prices, times

# Reference solve (from Approach C)
# ... (reuse solve_case from above in actual testing harness)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

class Dinic:
    class Edge:
        __slots__ = ("v", "cap", "rev", "orig")
        def __init__(self, v, cap, rev):
            self.v = v; self.cap = cap; self.rev = rev; self.orig = cap
    def __init__(self, n):
        self.n = n; self.g = [[] for _ in range(n)]
    def add_edge(self, u, v, c):
        a = Dinic.Edge(v, c, None); b = Dinic.Edge(u, 0, a); a.rev = b; b.rev = a
        self.g[u].append(a); self.g[v].append(b); return a
    def bfs(self, s, t, level):
        for i in range(self.n): level[i] = -1
        dq = deque([s]); level[s] = 0
        while dq:
            u = dq.popleft()
            for e in self.g[u]:
                if e.cap > 0 and level[e.v] < 0:
                    level[e.v] = level[u] + 1
                    if e.v == t: return True
                    dq.append(e.v)
        return level[t] >= 0
    def dfs(self, u, t, f, level, it):
        if u == t: return f
        i = it[u]
        while i < len(self.g[u]):
            e = self.g[u][i]
            if e.cap > 0 and level[e.v] == level[u] + 1:
                ret = self.dfs(e.v, t, min(f, e.cap), level, it)
                if ret:
                    e.cap -= ret; e.rev.cap += ret; return ret
            i += 1; it[u] = i
        return 0
    def maxflow(self, s, t):
        flow = 0; level = [-1]*self.n; INF = 10**30
        while self.bfs(s, t, level):
            it = [0]*self.n
            while True:
                pushed = self.dfs(s, t, INF, level, it)
                if not pushed: break
                flow += pushed
        return flow

def build_network(n, m, prices, times, T, rent_mask, want_detail=False):
    copy_nodes = []; copy_index_lists = [[] for _ in range(m)]
    wish_nodes = {}; wish_list = []; node_id = 1 + n
    for i in range(n):
        for j in range(m):
            t = times[i][j]
            if t > 0:
                wish_nodes[(i, j)] = node_id; wish_list.append((i, j, node_id)); node_id += 1
    for j in range(m):
        copies = 1 + ((rent_mask >> j) & 1)
        for k in range(copies):
            copy_index_lists[j].append(node_id); copy_nodes.append((j, k, node_id)); node_id += 1
    sink = node_id; N = sink + 1; s = 0; t = sink
    din = Dinic(N)
    for i in range(n): din.add_edge(s, 1+i, T)
    w2c = defaultdict(list)
    for (i, j, w) in wish_list:
        din.add_edge(1+i, w, times[i][j])
    for (i, j, w) in wish_list:
        need = times[i][j]
        for cn in copy_index_lists[j]:
            w2c[(i, j)].append(din.add_edge(w, cn, need))
    for (j, k, cn) in copy_nodes:
        din.add_edge(cn, t, T)
    total_need = sum(times[i][j] for i in range(n) for j in range(m))
    flow = din.maxflow(s, t)
    if not want_detail:
        return flow == total_need, None, None
    flows_by_child_copy = defaultdict(int)
    for (i, j, w) in wish_list:
        for e in w2c[(i, j)]:
            used = e.orig - e.cap
            if used > 0:
                flows_by_child_copy[(i, e.v)] += used
    cn2mj = {}
    for (j, k, cn) in copy_nodes:
        cn2mj[cn] = j
    return (flow == total_need), flows_by_child_copy, cn2mj

def feasible_subset(n, m, b, prices, times, T, sorted_masks, want_detail=False):
    for cost, mask in sorted_masks:
        if cost > b: break
        ok, flows, cn2mj = build_network(n, m, prices, times, T, mask, want_detail=want_detail)
        if ok:
            if want_detail: return True, mask, flows, cn2mj
            return True, mask, None, None
    if want_detail: return False, None, None, None
    return False, None, None, None

def schedule_from_flow(n, m, T, flows_by_child_copy, cn2mj):
    copy_nodes = sorted(cn2mj.keys())
    free = {cn: [[0, T]] for cn in copy_nodes}
    curs = {cn: 0 for cn in copy_nodes}
    per_child = [dict() for _ in range(n)]
    for (i, cn), v in flows_by_child_copy.items():
        per_child[i][cn] = per_child[i].get(cn, 0) + v
    ordered = sorted(copy_nodes, key=lambda cn: (cn2mj[cn], cn))
    segs = []
    for i in range(n):
        rem = per_child[i]
        if not rem: continue
        cur_t = 0
        while sum(rem.values()) > 0:
            best = None; best_start = None; best_end = None
            for cn in ordered:
                if rem.get(cn, 0) <= 0: continue
                lst = free[cn]; k = curs[cn]
                while k < len(lst) and lst[k][1] <= cur_t:
                    k += 1
                curs[cn] = k
                if k >= len(lst): continue
                a, b = lst[k]; start = max(cur_t, a)
                if start < b:
                    if best_start is None or start < best_start or (start == best_start and (cn2mj[cn], cn) < (cn2mj[best], best)):
                        best = cn; best_start = start; best_end = b
            if best is None:
                nxt = None
                for cn in ordered:
                    if rem.get(cn, 0) <= 0: continue
                    lst = free[cn]; k = curs[cn]
                    if k < len(lst):
                        a, b = lst[k]; cand = max(cur_t, a)
                        if cand < b and (nxt is None or cand < nxt): nxt = cand
                if nxt is None: raise RuntimeError("Scheduling impossible")
                cur_t = nxt; continue
            cn = best; a = best_start; b = best_end
            take = min(rem[cn], b - a)
            mj = cn2mj[cn]
            segs.append((i+1, mj+1, a, take))
            lst = free[cn]; k = curs[cn]; oa, ob = lst[k]
            new_ints = []
            if oa < a: new_ints.append([oa, a])
            if a + take < ob: new_ints.append([a+take, ob])
            lst.pop(k)
            if new_ints:
                for seg in reversed(new_ints): lst.insert(k, seg)
            rem[cn] -= take
            cur_t = a + take
    return segs

def solve_case(data):
    n, m, b, prices, times = data
    masks = []
    for mask in range(1 << m):
        cost = sum(prices[j] for j in range(m) if (mask >> j) & 1)
        masks.append((cost, mask))
    masks.sort()
    total_need = sum(times[i][j] for i in range(n) for j in range(m))
    child_sums = [sum(times[i][j] for j in range(m)) for i in range(n)]
    T_lo = max(child_sums) if child_sums else 0
    T_hi = total_need
    lo, hi = T_lo, T_hi
    while lo < hi:
        mid = (lo + hi) // 2
        ok, mask, _, _ = feasible_subset(n, m, b, prices, times, mid, masks, want_detail=False)
        if ok: hi = mid
        else: lo = mid + 1
    T = lo
    ok, mask, flows, cn2mj = feasible_subset(n, m, b, prices, times, T, masks, want_detail=True)
    assert ok
    segs = schedule_from_flow(n, m, T, flows, cn2mj)
    rent_str = ''.join('1' if (mask >> j) & 1 else '0' for j in range(m))
    out = []
    out.append(str(T)); out.append(rent_str); out.append(str(len(segs)))
    for (i, j, s, d) in segs:
        out.append(f"{i} {j} {s} {d}")
    return "\n".join(out)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data: return None
    it = iter(data)
    n = int(next(it)); m = int(next(it)); b = int(next(it))
    prices = [int(next(it)) for _ in range(m)]
    times = [[0]*m for _ in range(n)]
    for i in range(n):
        k = int(next(it))
        for _ in range(k):
            x = int(next(it)) - 1; t = int(next(it))
            times[i][x] = t
    return (n, m, b, prices, times)

def main():
    data = read_input()
    if data is None: return
    print(solve_case(data))

if __name__ == "__main__":
    # Smoke asserts
    n, m, b = 1, 1, 0
    prices = [10]; times = [[3]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[0] == "3" and out[1] == "0"
    n, m, b = 2, 1, 5
    prices = [5]; times = [[3],[3]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[0] == "3" and out[1] == "1"
    n, m, b = 2, 2, 0
    prices = [7, 8]; times = [[2,2],[2,0]]
    out = solve_case((n, m, b, prices, times)).splitlines()
    assert out[1] == "00"
    if not sys.stdin.isatty():
        sys.stdin.seek(0); main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize makespan $T$ by renting up to one extra copy per machine under budget and scheduling preemptively; feasibility at a fixed $T$ is a max-flow.}
\WHY{Combines flow modeling with constructive scheduling; appears in advanced interview questions for flow with side decisions and schedule construction.}
\CHECKLIST{%
\begin{bullets}
\item Compute $T_{\min}$ and $T_{\max}$ bounds.
\item Precompute and sort rent subsets by cost.
\item Binary search $T$; per $T$, test subsets with max-flow.
\item Rebuild at optimal $T$; extract flows.
\item Greedy fill of machine-copy free intervals per child to output segments.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item Children with $k_i=0$.
\item All demand on a single machine.
\item Budget $b=0$ vs. very large budget.
\item Machines with zero total demand.
\item Exact saturation where $\sum_i t_{ij}=2T$ for rented machines.
\item Large $T$ where number of segments may be large (up to $10^6$).
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting the coupling across two copies for the same machine; fix with wish nodes.
\item Not keeping child capacity at $T$ (source$\to$child).
\item Failing to retrieve integral flows (ensure integer capacities).
\item Schedule overlaps for a child; fix by monotone child time pointer.
\item Mishandling free intervals when splitting; ensure correct list updates.
\item Outputting copy indices instead of machine indices in segments.
\end{bullets}
}
\FAILMODES{Greedy per-time-slot matching would time out for large $T$. The flow-based feasibility with greedy interval packing avoids per-minute operations while still constructing a valid schedule.}
\ELI{Think of each machine (and its copy if rented) as a lane of length $T$, and each child has a personal single lane of the same length. Flow decides how much of each child's time goes to which machine lane. Then we slice and fit those amounts into the machine lanes chronologically, making sure a child uses only one lane at a time.}
\NotePages{3}

\end{document}