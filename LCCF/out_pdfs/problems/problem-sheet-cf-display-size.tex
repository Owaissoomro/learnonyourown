% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Display Size}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/747/A}}
\LINE{DIFFICULTY / RATING}{CF 747/A, Rating 800}
\STATEMENT{A big company decided to launch a new series of rectangular displays, and decided that the display must have exactly $n$ pixels.

Your task is to determine the size of the rectangular display — the number of lines (rows) of pixels $a$ and the number of columns of pixels $b$, so that:
(1) there are exactly $n$ pixels on the display, i.e., $a \times b = n$;
(2) the number of rows does not exceed the number of columns, i.e., $a \le b$;
(3) the difference $b - a$ is as small as possible.

Input:
The first line contains the positive integer $n$ ($1 \le n \le 10^6$) — the number of pixels the display should have.

Output:
Print two integers — the number of rows and columns on the display.

Note:
In the first example the minimum possible difference equals $2$, so the display should be $2$ rows of $4$ pixels.
In the second example the minimum possible difference equals $0$, so the display should be $8$ rows of $8$ pixels.
In the third example the minimum possible difference equals $4$, so the display should be $1$ row of $5$ pixels.}
\BREAKDOWN{We need to choose factor pair $(a,b)$ of $n$ with $a \le b$ minimizing $b-a$. This is equivalent to finding the divisor $a$ of $n$ that is as close as possible to $\sqrt{n}$ from below, then setting $b = n/a$.}
\ELI{Pick the divisor of $n$ that is closest to $\sqrt{n}$; make it the number of rows, and columns are $n$ divided by that.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{$n$ — integer, $1 \le n \le 10^6$.}
\OUTPUTS{Two integers $a$ and $b$ such that $a \times b = n$, $a \le b$, and $b-a$ is minimized. Output as ``$a~b$'' on one line.}
\SAMPLES{Example 1: Input: $8$; Output: $2~4$. Example 2: Input: $16$; Output: $4~4$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n \in \mathbb{Z}_{>0}$, find $(a,b) \in \mathbb{Z}_{>0}^2$ such that $a b = n$, $a \le b$, and $b-a$ is minimized.}
\varmapStart
\var{n}{total pixel count}
\var{a}{rows (a positive divisor of $n$)}
\var{b}{columns (the complementary divisor, $b = n/a$)}
\var{d}{a trial divisor of $n$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
& a b = n,\quad a,b \in \mathbb{Z}_{>0}, \\
& a \le b, \\
& (a,b) \in \arg\min_{(x,y)}\{\, y-x \mid xy=n,\ x \le y,\ x,y \in \mathbb{Z}_{>0} \,\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Any optimal pair satisfies $a \le \sqrt{n} \le b$. If multiple optimal pairs exist (ties), choosing the one with largest $a$ yields the smallest difference $b-a$.}
\INVARIANTS{If $d \mid n$ and $d \le \sqrt{n}$, then its complement $n/d \ge \sqrt{n}$, hence considering only $d \le \sqrt{n}$ suffices. The minimum of $b-a$ over factor pairs occurs at the factor pair closest to $\sqrt{n}$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all candidates $a \in \{1,\ldots,n\}$ with $a \mid n$, compute $b=n/a$, normalize $(a,b)$ so $a \le b$, and keep the pair minimizing $b-a$.}
\ASSUMPTIONS{None beyond problem constraints; exhaustive search over all factors.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize best pair $(a^\star,b^\star) \leftarrow (1,n)$ and best difference $\Delta \leftarrow n-1$.
\item For each $a=1$ to $n$: if $n \bmod a = 0$, set $b=n/a$, reorder so $a \le b$, and if $b-a < \Delta$, update the best pair.
\item Output the best pair.
\end{algosteps}
\COMPLEXITY{$T(n)=\Theta(n)$ iterations with $O(1)$ work each; $S(n)=O(1)$ auxiliary space.}
\[
\begin{aligned}
T(n) &= \sum_{a=1}^{n} 1 \\
     &= n \in \Theta(n).
\end{aligned}
\]
\CORRECTNESS{All factor pairs are considered; the algorithm keeps the pair achieving the smallest difference $b-a$, thus satisfies minimality and the constraint $a \le b$.}
\EDGECASES{$n=1$ gives $(1,1)$. Prime $n$ yields $(1,n)$. Perfect squares yield $(\sqrt{n},\sqrt{n})$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 747A - Display Size (Baseline O(n))
# read_input(), solve_case(), solve_all(), main()+guard, with asserts.
from typing import Tuple
import sys

def read_input(data: str) -> int:
    tokens = data.strip().split()
    assert len(tokens) >= 1
    return int(tokens[0])

def solve_case(n: int) -> Tuple[int, int]:
    best_a, best_b = 1, n
    best_diff = best_b - best_a
    for a in range(1, n + 1):
        if n % a == 0:
            b = n // a
            x, y = (a, b) if a <= b else (b, a)
            diff = y - x
            if diff < best_diff:
                best_diff = diff
                best_a, best_b = x, y
                if best_diff == 0:
                    break
    return best_a, best_b

def solve_all(n: int) -> str:
    a, b = solve_case(n)
    return f"{a} {b}"

def main() -> None:
    data = sys.stdin.read()
    if data.strip():
        n = read_input(data)
        sys.stdout.write(solve_all(n))
    else:
        # Self-tests when no input is provided
        assert solve_case(1) == (1, 1)
        assert solve_case(2) == (1, 2)
        assert solve_case(4) == (2, 2)
        assert solve_case(5) == (1, 5)
        assert solve_case(8) == (2, 4)
        assert solve_case(16) == (4, 4)
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked against $n \in \{1,2,4,5,8,16\}$; baseline matches expected pairs and respects $a \le b$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Factor Search up to $\lfloor \sqrt{n} \rfloor$}
\WHICHFORMULA{Only divisors $d \le \sqrt{n}$ need be tried. For each such divisor, its complement is $n/d$. Keep the pair minimizing $n/d - d$.}
\ASSUMPTIONS{Trial divisors restricted to $1 \le d \le \lfloor \sqrt{n} \rfloor$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $r = \lfloor \sqrt{n} \rfloor$. Initialize best pair as before.
\item For each $d$ from $1$ to $r$: if $d \mid n$, set candidate $(d, n/d)$ and update minimum by $n/d - d$.
\item Output the best pair.
\end{algosteps}
\COMPLEXITY{At most $\lfloor \sqrt{n} \rfloor$ iterations, each $O(1)$, so $T(n)=O(\sqrt{n})$ and $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= \sum_{d=1}^{\lfloor \sqrt{n} \rfloor} 1 \\
     &= \lfloor \sqrt{n} \rfloor \in \Theta(\sqrt{n}).
\end{aligned}
\]
\CORRECTNESS{For any factor pair $(a,b)$ with $a>b$ we can swap to satisfy $a \le b$. Among all pairs with $a \le b$, the optimal $a$ is the largest divisor not exceeding $\sqrt{n}$; the loop examines all such $a$ and thus finds the optimum.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF 747A - Display Size (Improved O(sqrt(n)))
from typing import Tuple
from math import isqrt
import sys

def read_input(data: str) -> int:
    tokens = data.strip().split()
    assert len(tokens) >= 1
    return int(tokens[0])

def solve_case(n: int) -> Tuple[int, int]:
    best_a, best_b = 1, n
    best_diff = best_b - best_a
    r = isqrt(n)
    for d in range(1, r + 1):
        if n % d == 0:
            a = d
            b = n // d
            diff = b - a  # here a <= b by construction
            if diff < best_diff:
                best_diff = diff
                best_a, best_b = a, b
                if best_diff == 0:
                    break
    return best_a, best_b

def solve_all(n: int) -> str:
    a, b = solve_case(n)
    return f"{a} {b}"

def main() -> None:
    data = sys.stdin.read()
    if data.strip():
        n = read_input(data)
        sys.stdout.write(solve_all(n))
    else:
        # Self-tests
        assert solve_case(1) == (1, 1)
        assert solve_case(8) == (2, 4)
        assert solve_case(16) == (4, 4)
        # A large prime near the bound (999983 is prime): expect (1, n)
        assert solve_case(999983) == (1, 999983)
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge inputs: $n=1$ gives $(1,1)$. Perfect square $n=10^6$ gives $(1000,1000)$. Prime $n$ near the maximum (e.g., $999{,}983$) gives $(1,n)$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Scan Downward from $\lfloor \sqrt{n} \rfloor$ to First Divisor}
\WHICHFORMULA{Let $a^\star$ be the largest divisor of $n$ with $a^\star \le \sqrt{n}$. Then $(a^\star, n/a^\star)$ minimizes $b-a$. Scanning $a$ from $\lfloor \sqrt{n} \rfloor$ downward finds $a^\star$ as soon as possible.}
\ASSUMPTIONS{The closest factor pair around $\sqrt{n}$ is optimal; no need to evaluate all smaller divisors once the largest $\le \sqrt{n}$ is found.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set $a \leftarrow \lfloor \sqrt{n} \rfloor$.
\item While $a \ge 1$ and $a \nmid n$, decrement $a$.
\item Output $(a, n/a)$.
\end{algosteps}
\OPTIMALITY{Among all $d \le \sqrt{n}$ with $d \mid n$, the largest such $d$ yields the smallest $n/d - d$. The scan returns this $d$ first. Any faster algorithm cannot asymptotically beat the need to inspect divisibility up to $\sqrt{n}$ in the worst case.}
\COMPLEXITY{$T(n)=O(\sqrt{n})$ in the worst case; $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= O(\sqrt{n}) \quad \text{(at most one divisibility check per integer down to $1$)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF 747A - Display Size (Final; O(sqrt(n)) scan downward)
from typing import Tuple
from math import isqrt
import sys

def read_input(data: str) -> int:
    tokens = data.strip().split()
    assert len(tokens) >= 1
    return int(tokens[0])

def solve_case(n: int) -> Tuple[int, int]:
    a = isqrt(n)
    while a > 0 and n % a != 0:
        a -= 1
    b = n // a
    return a, b  # a <= b by construction

def solve_all(n: int) -> str:
    a, b = solve_case(n)
    return f"{a} {b}"

def main() -> None:
    data = sys.stdin.read()
    if data.strip():
        n = read_input(data)
        sys.stdout.write(solve_all(n))
    else:
        # Exactly 3 asserts
        assert solve_case(1) == (1, 1)
        assert solve_case(8) == (2, 4)
        assert solve_case(16) == (4, 4)
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts: $n=1 \mapsto (1,1)$; $n=8 \mapsto (2,4)$; $n=16 \mapsto (4,4)$.}
\RESULT{Print the optimal pair $a~b$ with $a \le b$ minimizing $b-a$. For ties (not possible here beyond symmetric swaps), the construction yields the largest $a$ since it scans downward from $\lfloor \sqrt{n} \rfloor$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on canonical cases: $n=1$; small primes (2, 3, 5); small composites (6, 8, 12, 18); perfect squares (4, 9, 16, $10^6$); large prime near bound (e.g., $999{,}983$).}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (brute force) and Approach C (final) on small $n \le 200$ for equality.}
\LINE{EDGE-CASE GENERATOR}{Generate boundary and adversarial cases: $n=1$, $n=10^6$, primes around powers and just below the limit, and numbers with many divisors (e.g., $997920$).}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from math import isqrt

def gen_small(n_max=200):
    for n in range(1, n_max + 1):
        yield n

def gen_boundaries():
    yield 1
    yield 10**6

def gen_many_divisors():
    # Highly composite-ish around 10^6
    for n in [360360, 720720, 831600, 997920]:
        yield n

def brute(n: int):
    best = (1, n)
    best_diff = n - 1
    for a in range(1, n + 1):
        if n % a == 0:
            b = n // a
            x, y = (a, b) if a <= b else (b, a)
            d = y - x
            if d < best_diff:
                best_diff, best = d, (x, y)
    return best

def optimal(n: int):
    a = isqrt(n)
    while a > 0 and n % a != 0:
        a -= 1
    return a, n // a

def self_check():
    for n in gen_small():
        assert brute(n) == optimal(n)
    for n in gen_boundaries():
        assert optimal(n)[0] * optimal(n)[1] == n
    for n in gen_many_divisors():
        assert brute(n) == optimal(n)
    print("All cross-checks passed.")

if __name__ == "__main__":
    self_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# CF 747A - Display Size (Reference Solution)
from typing import Tuple
from math import isqrt
import sys

def read_input(data: str) -> int:
    tokens = data.strip().split()
    assert len(tokens) >= 1
    return int(tokens[0])

def solve_case(n: int) -> Tuple[int, int]:
    a = isqrt(n)
    while a > 0 and n % a != 0:
        a -= 1
    b = n // a
    return a, b

def solve_all(n: int) -> str:
    a, b = solve_case(n)
    return f"{a} {b}"

def main() -> None:
    data = sys.stdin.read()
    if data.strip():
        n = read_input(data)
        sys.stdout.write(solve_all(n))
    else:
        # Quick sanity checks
        assert solve_case(1) == (1, 1)
        assert solve_case(5) == (1, 5)
        assert solve_case(36) == (6, 6)
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the factor pair of $n$ closest to a square: $(a,b)$ with $a \le b$, $ab=n$, minimizing $b-a$.}
\WHY{Classic factor search problem that tests using $\sqrt{n}$ bounds and reasoning about divisors, common in interviews and programming contests.}
\CHECKLIST{Compute $r=\lfloor \sqrt{n} \rfloor$; scan down to find first divisor $a$; set $b=n/a$; print $a~b$.}
\EDGECASES{Smallest $n=1$; prime $n$ (answer $1~n$); perfect squares ($a=b=\sqrt{n}$); $n$ just above a square; $n$ with many small factors; maximum $n=10^6$.}
\PITFALLS{Forgetting to ensure $a \le b$; scanning upward from $1$ causing unnecessary work; off-by-one in $\lfloor \sqrt{n} \rfloor$; integer division vs. float; not handling $n=1$; printing order reversed.}
\FAILMODES{Brute force $O(n)$ times out for larger limits; methods relying on floating-point square roots risk precision errors — use integer $\mathrm{isqrt}$. The downward scan avoids both issues.}
\ELI{Look near the square root of $n$ for a divisor. The closest such divisor gives the most square-like rectangle, which minimizes the difference between columns and rows.}
\NotePages{3}

\end{document}