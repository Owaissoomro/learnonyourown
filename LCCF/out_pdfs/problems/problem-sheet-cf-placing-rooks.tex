% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Placing Rooks}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1342/E}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Calculate the number of ways to place $n$ rooks on $n \times n$ chessboard so that both following conditions are met:

\begin{bullets}
\item each empty cell is under attack;
\item exactly $k$ pairs of rooks attack each other.
\end{bullets}

An empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column. Two rooks attack each other if they share the same row or column, and there are no other rooks between them. For example, there are only two pairs of rooks that attack each other in the following picture:

One of the ways to place the rooks for $n = 3$ and $k = 2$.

Two ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way.

The answer might be large, so print it modulo $998{,}244{,}353$.

Input: The only line of the input contains two integers $n$ and $k$ ($1 \le n \le 200000$; $0 \le k \le \tfrac{n(n - 1)}{2}$).

Output: Print one integer — the number of ways to place the rooks, taken modulo $998{,}244{,}353$.}
\BREAKDOWN{Translate the attacking-pairs condition into counts of non-empty rows and columns, enforce the coverage constraint, and count placements via surjections with inclusion--exclusion. Finally, handle overlap of the two symmetric cases and compute modulo $998{,}244{,}353$.}
\ELI{Every valid placement either uses all rows or all columns; counting becomes ``assign each of $n$ rooks to $m$ chosen lines so that every chosen line is used at least once''.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers: $n$ (board size, number of rooks), $k$ (number of attacking pairs). Valid ranges: $1 \le n \le 200{,}000$, $0 \le k \le \tfrac{n(n-1)}{2}$.}
\OUTPUTS{One integer: the number of valid placements modulo $998{,}244{,}353$.}
\SAMPLES{
\begin{bullets}
\item Input: ``1 0'' $\to$ Output: ``1''.
\item Input: ``2 1'' $\to$ Output: ``4''.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $r_i$ be the number of rooks in row $i$ and $c_j$ the number in column $j$. Define $R=\#\{i : r_i > 0\}$ and $C=\#\{j : c_j > 0\}$. The number of attacking pairs equals
\begin{BreakableEquation*}
k = \sum_{i: r_i>0} (r_i - 1) + \sum_{j: c_j>0} (c_j - 1) = (n - R) + (n - C) = 2n - R - C.
\end{BreakableEquation*}
The coverage constraint ``every empty cell is attacked'' is equivalent to $R=n$ or $C=n$.}
\varmapStart
\var{n}{board size and number of rooks}
\var{k}{number of attacking pairs}
\var{R}{number of non-empty rows}
\var{C}{number of non-empty columns}
\var{m}{target non-empty count on the other axis, $m=n-k$}
\var{S(n,m)}{Stirling numbers of the second kind}
\var{\text{surj}(n,m)}{number of surjections from $[n]$ to $[m]$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&k = 2n - R - C,\quad \text{and}\quad (R=n)\ \text{or}\ (C=n).\\
&\text{If }R=n,\ C=m=n-k:~\text{place }n\text{ rooks in }n\times m\text{ with each row/column non-empty}.\\
&\text{If }C=n,\ R=m=n-k:~\text{place }n\text{ rooks in }m\times n\text{ with each row/column non-empty}.\\
&\text{surj}(n,m) = m!\,S(n,m) = \sum_{i=0}^{m}(-1)^i \binom{m}{i}(m-i)^n.
\end{aligned}
\]
}
\ASSUMPTIONS{At most one rook per cell; rows/columns are labeled; placements differing at any cell are distinct.}
\INVARIANTS{
\begin{bullets}
\item Total rooks is $n$: $\sum_i r_i = \sum_j c_j = n$.
\item For $R=n$, each row has exactly one rook when exactly $n$ rooks are placed and all rows are non-empty.
\item Symmetry by transpose: the two cases $R=n$ and $C=n$ are symmetric.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all $\binom{n^2}{n}$ placements, compute $R$, $C$, and attacking pairs $k$ from adjacency in each row/column, and filter by the coverage constraint $(R=n)\lor(C=n)$.}
\ASSUMPTIONS{Feasible only for tiny $n$; used for validation and as a fallback sanity check.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate all subsets of $n$ cells from the $n^2$ grid.
\item For each subset, compute row/column counts; check coverage ($R=n$ or $C=n$).
\item Count attacking pairs as $\sum_{\text{rows}}(\#\text{rooks in row}-1)+\sum_{\text{cols}}(\#\text{rooks in col}-1)$ and compare to target $k$.
\end{algosteps}
\COMPLEXITY{Brute force is exponential: $T(n)=\Theta\!\big(\binom{n^2}{n}\cdot n\big)$ operations; $S(n)=\Theta(n^2)$.}
\[
\begin{aligned}
T(n) &= \binom{n^2}{n}\cdot \Theta(n) \\
     &= \exp\!\big(\Theta(n\log n)\big)\ \text{(infeasible beyond very small $n$).}
\end{aligned}
\]
\CORRECTNESS{Direct enumeration checks the exact constraints and counts.}
\EDGECASES{Handles $n=1$; $k=0$ vs. $k\ge n$; full rows or full columns.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
import sys
from itertools import combinations

MOD = 998244353

def brute_force_count(n: int, k: int) -> int:
    N = n * n
    cells = [(i // n, i % n) for i in range(N)]
    ans = 0
    for choose in combinations(range(N), n):
        rows = [[] for _ in range(n)]
        cols = [[] for _ in range(n)]
        for idx in choose:
            r, c = cells[idx]
            rows[r].append(c)
            cols[c].append(r)
        R = sum(1 for r in rows if r)
        C = sum(1 for c in cols if c)
        if not (R == n or C == n):
            continue
        pairs = 0
        for r in rows:
            if r:
                pairs += len(r) - 1
        for c in cols:
            if c:
                pairs += len(c) - 1
        if pairs == k:
            ans += 1
    return ans % MOD

def precompute_fact(n: int):
    fact = [1] * (n + 1)
    invfact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[n] = pow(fact[n], MOD - 2, MOD)
    for i in range(n, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def nCk(n: int, k: int, fact, invfact) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

def surjections(n: int, m: int, fact, invfact) -> int:
    # surj(n,m) = sum_{i=0}^m (-1)^i C(m,i) (m-i)^n
    if m < 0 or m > n:
        # Here, if m > n then surjections are zero; m == 0 also zero for n>0.
        if m == 0 and n == 0:
            return 1
        return 0
    s = 0
    for i in range(0, m + 1):
        term = nCk(m, i, fact, invfact) * pow(m - i, n, MOD) % MOD
        if i % 2 == 1:
            s = (s - term) % MOD
        else:
            s = (s + term) % MOD
    return s

def formula_answer(n: int, k: int) -> int:
    if k < 0:
        return 0
    m = n - k
    if m <= 0 or m > n:
        return 0
    fact, invfact = precompute_fact(n)
    surj = surjections(n, m, fact, invfact)
    ways_one_side = nCk(n, m, fact, invfact) * surj % MOD
    ans = (2 * ways_one_side) % MOD
    if k == 0:
        # subtract overlap where both R=n and C=n
        ans = (ans - surjections(n, n, fact, invfact)) % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, k = map(int, data[:2])
    return n, k

def solve_case(n: int, k: int) -> int:
    # For safety, use the formula (fast) for all inputs; brute force only for small validation.
    return formula_answer(n, k)

def main():
    # Tiny self-tests (quick) before processing input
    # Cross-check baseline brute force vs formula for n <= 5
    for n in range(1, 6):
        fact, invfact = precompute_fact(n)
        for k in range(0, n + 2):  # include a couple beyond to check zeros
            bf = brute_force_count(n, k) if n <= 5 else 0
            fm = formula_answer(n, k)
            if n <= 5:
                assert bf == fm, f"mismatch n={n} k={k} brute={bf} formula={fm}"
    # Known spot checks
    assert formula_answer(1, 0) == 1
    assert formula_answer(2, 0) == 2
    assert formula_answer(2, 1) == 4
    assert formula_answer(3, 2) == 6
    # Process input
    nk = read_input()
    if nk is None:
        return
    n, k = nk
    print(solve_case(n, k))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Validated by brute force up to $n=5$ across all feasible $k$, plus specific spot checks.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Collapse counting to surjections via inclusion--exclusion and choose which $m=n-k$ lines are non-empty. Use fast modular binomials and powers.}
\ASSUMPTIONS{Use that with $R=n$ every row has exactly one rook; then the number of ways is $\binom{n}{m}\cdot \text{surj}(n,m)$. Symmetric case for $C=n$. Subtract the overlap when $k=0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $m=n-k \le 0$ or $m>n$, return $0$.
\item Precompute factorials and inverse factorials up to $n$ modulo $998{,}244{,}353$.
\item Compute $\text{surj}(n,m) = \sum_{i=0}^{m}(-1)^i \binom{m}{i} (m-i)^n$.
\item Compute $2\cdot \binom{n}{m}\cdot \text{surj}(n,m)$ and subtract $\text{surj}(n,n)$ if $k=0$.
\end{algosteps}
\COMPLEXITY{The inclusion--exclusion sum costs $O(m)$ and precomputation is $O(n)$. This beats brute force exponentially.}
\[
\begin{aligned}
T(n) &= O(n) + O(m) \le O(n),\quad S(n)=O(n). \\
\end{aligned}
\]
\CORRECTNESS{Derived from $k=2n-R-C$ and the coverage condition $(R=n)\lor(C=n)$. Counting reduces to surjective maps from $n$ labeled rows/columns onto $m$ chosen labeled lines. Intersection for $k=0$ is handled by inclusion--exclusion on cases.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
import sys

MOD = 998244353

def precompute_fact(n: int):
    fact = [1] * (n + 1)
    invfact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[n] = pow(fact[n], MOD - 2, MOD)
    for i in range(n, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def nCk(n: int, k: int, fact, invfact) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

def surjections(n: int, m: int, fact, invfact) -> int:
    if m <= 0 or m > n:
        return 0
    s = 0
    for i in range(0, m + 1):
        term = nCk(m, i, fact, invfact) * pow(m - i, n, MOD) % MOD
        if i & 1:
            s = (s - term) % MOD
        else:
            s = (s + term) % MOD
    return s

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, k = map(int, data[:2])
    return n, k

def solve_case(n: int, k: int) -> int:
    m = n - k
    if m <= 0 or m > n:
        return 0
    fact, invfact = precompute_fact(n)
    surj = surjections(n, m, fact, invfact)
    ways_one_side = nCk(n, m, fact, invfact) * surj % MOD
    ans = (2 * ways_one_side) % MOD
    if k == 0:
        ans = (ans - surjections(n, n, fact, invfact)) % MOD
    return ans

def main():
    # Quick asserts
    assert solve_case(1, 0) == 1
    assert solve_case(2, 0) == 2
    assert solve_case(2, 1) == 4
    assert solve_case(3, 2) == 6
    nk = read_input()
    if nk is None:
        return
    n, k = nk
    print(solve_case(n, k))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Spot checks on $(n,k)=(1,0),(2,0),(2,1),(3,2)$; random small comparisons can be done against brute force.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Closed form via inclusion--exclusion on surjections and a single $O(n)$ precomputation of factorials. Final answer:
\[
\text{ans} =
\begin{cases}
0, & n-k \le 0 \text{ or } n-k>n,\\
2 \binom{n}{n-k}\,\text{surj}(n,n-k) - [k=0]\cdot \text{surj}(n,n) \pmod{998{,}244{,}353}, & \text{otherwise.}
\end{cases}
\]
}
\ASSUMPTIONS{Prime modulus; $n$ up to $2\cdot 10^5$; inclusion--exclusion sum over $m=n-k$ terms is fast.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n,k$; set $m=n-k$. If $m \le 0$ or $m>n$, print $0$.
\item Precompute factorials and inverse factorials up to $n$ modulo $998{,}244{,}353$.
\item Compute $\text{surj}(n,m)=\sum_{i=0}^{m}(-1)^i \binom{m}{i}(m-i)^n \bmod M$.
\item Compute $2\binom{n}{m}\text{surj}(n,m)$; if $k=0$, subtract $\text{surj}(n,n)$; print the result modulo $M$.
\end{algosteps}
\OPTIMALITY{The inclusion--exclusion sum must touch all $m$ terms, and $m$ can be $\Theta(n)$; thus $O(n)$ time and space are tight up to polylog factors.}
\COMPLEXITY{$T(n)=O(n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n) \text{ for factorials } + O(m) \le O(n),\\
S(n) &= O(n) \text{ for factorial tables}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys

MOD = 998244353

def precompute_fact(n: int):
    fact = [1] * (n + 1)
    invfact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[n] = pow(fact[n], MOD - 2, MOD)
    for i in range(n, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def nCk(n: int, k: int, fact, invfact) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

def surjections(n: int, m: int, fact, invfact) -> int:
    if m <= 0 or m > n:
        return 0
    s = 0
    for i in range(0, m + 1):
        term = nCk(m, i, fact, invfact) * pow(m - i, n, MOD) % MOD
        if i & 1:
            s = (s - term) % MOD
        else:
            s = (s + term) % MOD
    return s

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, k = map(int, data[:2])
    return n, k

def solve_case(n: int, k: int) -> int:
    m = n - k
    if m <= 0 or m > n:
        return 0
    fact, invfact = precompute_fact(n)
    surj_nm = surjections(n, m, fact, invfact)
    ans = (2 * nCk(n, m, fact, invfact) * surj_nm) % MOD
    if k == 0:
        ans = (ans - surjections(n, n, fact, invfact)) % MOD
    return ans

def main():
    # Minimal asserts
    assert solve_case(1, 0) == 1
    assert solve_case(2, 0) == 2
    assert solve_case(2, 1) == 4
    assert solve_case(3, 2) == 6
    nk = read_input()
    if nk is None:
        return
    n, k = nk
    print(solve_case(n, k))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts included; matches brute force for $n \le 5$ (see earlier section) and known spot checks.}
\RESULT{Print the count modulo $998{,}244{,}353$. For $k \ge n$ the answer is $0$; for $k=0$ it is $n!$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Compare the formula against brute force for all $(n,k)$ with $n \le 5$; add spot checks for edge $k=0$ and $k \ge n$.}
\LINE{CROSS-CHECKS}{Baseline vs. Improved vs. Final produce identical outputs on all mini-cases.}
\LINE{EDGE-CASE GENERATOR}{Generate $(n,k)$ with $n \in [1,5]$, $k \in [0,n+1]$ to ensure zeros beyond range and correct positives within range.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def edge_cases():
    cases = []
    for n in range(1, 6):
        for k in range(0, n + 2):
            cases.append((n, k))
    cases += [(10, 0), (10, 1), (10, 9), (10, 10), (200000, 0), (200000, 1)]
    return cases

def run_cross_checks():
    from itertools import combinations
    MOD = 998244353

    def brute(n, k):
        N = n * n
        cells = [(i // n, i % n) for i in range(N)]
        ans = 0
        for choose in combinations(range(N), n):
            rows = [[] for _ in range(n)]
            cols = [[] for _ in range(n)]
            for idx in choose:
                r, c = cells[idx]
                rows[r].append(c)
                cols[c].append(r)
            R = sum(1 for r in rows if r)
            C = sum(1 for c in cols if c)
            if not (R == n or C == n):
                continue
            pairs = 0
            for r in rows:
                if r:
                    pairs += len(r) - 1
            for c in cols:
                if c:
                    pairs += len(c) - 1
            if pairs == k:
                ans += 1
        return ans % MOD

    # Import final solver
    import sys
    sys.setrecursionlimit(1 << 25)

    def precompute_fact(n: int):
        fact = [1] * (n + 1)
        invfact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] * i % MOD
        invfact[n] = pow(fact[n], MOD - 2, MOD)
        for i in range(n, 0, -1):
            invfact[i - 1] = invfact[i] * i % MOD
        return fact, invfact

    def nCk(n: int, k: int, fact, invfact) -> int:
        if k < 0 or k > n:
            return 0
        return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

    def surjections(n: int, m: int, fact, invfact) -> int:
        if m <= 0 or m > n:
            return 0
        s = 0
        for i in range(0, m + 1):
            term = nCk(m, i, fact, invfact) * pow(m - i, n, MOD) % MOD
            if i & 1:
                s = (s - term) % MOD
            else:
                s = (s + term) % MOD
        return s

    def solve_case(n: int, k: int) -> int:
        m = n - k
        if m <= 0 or m > n:
            return 0
        fact, invfact = precompute_fact(n)
        ans = (2 * nCk(n, m, fact, invfact) * surjections(n, m, fact, invfact)) % MOD
        if k == 0:
            ans = (ans - surjections(n, n, fact, invfact)) % MOD
        return ans

    for n, k in edge_cases():
        if n <= 5:
            assert brute(n, k) == solve_case(n, k), (n, k, brute(n, k), solve_case(n, k))
    # spot checks
    assert solve_case(1, 0) == 1
    assert solve_case(2, 1) == 4

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys

MOD = 998244353

def precompute_fact(n: int):
    fact = [1] * (n + 1)
    invfact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[n] = pow(fact[n], MOD - 2, MOD)
    for i in range(n, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def nCk(n: int, k: int, fact, invfact) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

def surjections(n: int, m: int, fact, invfact) -> int:
    if m <= 0 or m > n:
        return 0
    s = 0
    for i in range(0, m + 1):
        term = nCk(m, i, fact, invfact) * pow(m - i, n, MOD) % MOD
        if i & 1:
            s = (s - term) % MOD
        else:
            s = (s + term) % MOD
    return s

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, k = map(int, data[:2])
    return n, k

def solve_case(n: int, k: int) -> int:
    m = n - k
    if m <= 0 or m > n:
        return 0
    fact, invfact = precompute_fact(n)
    ans = (2 * nCk(n, m, fact, invfact) * surjections(n, m, fact, invfact)) % MOD
    if k == 0:
        ans = (ans - surjections(n, n, fact, invfact)) % MOD
    return ans

def main():
    # Minimal sanity asserts
    assert solve_case(1, 0) == 1
    assert solve_case(2, 0) == 2
    assert solve_case(2, 1) == 4
    nk = read_input()
    if nk is None:
        return
    n, k = nk
    print(solve_case(n, k))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to counting surjections after recognizing $k=2n-R-C$ and the coverage equivalence $(R=n)\lor(C=n)$.}
\WHY{Transforms a seemingly geometric counting problem into a clean combinatorial sum, a common interview pattern.}
\CHECKLIST{
\begin{bullets}
\item Compute $m=n-k$; if $m \le 0$ or $m>n$, answer $0$.
\item Precompute factorials and inverse factorials.
\item Compute $\text{surj}(n,m)$ by inclusion--exclusion.
\item Multiply by $\binom{n}{m}$ and double for symmetry.
\item Subtract overlap when $k=0$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $k=0 \Rightarrow$ answer $n!$ (permutations).
\item $k \ge n \Rightarrow$ answer $0$.
\item $n=1$: only $(k=0)$ is valid.
\item $m=1$: exactly $2\binom{n}{1}$ ways.
\item Very large $n$: ensure precomputation bounds and modulo arithmetic.
\item Empty intersection handling only when $m=n$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to subtract the overlap when $k=0$.
\item Using $\binom{n}{m} m^n$ instead of surjections (missing inclusion--exclusion).
\item Off-by-one in inclusion--exclusion signs.
\item Computing binomials without precomputed inverses modulo a prime.
\item Treating $m=0$ incorrectly (no surjections for $n>0$).
\item Overflow if modulo not applied consistently.
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item Brute force fails beyond tiny $n$.
\item DP over distributions without surjection count yields wrong multiplicities.
\item Ignoring coverage leads to counting invalid placements with both an empty row and column.
\end{bullets}
}
\ELI{Either every row is used or every column is used. Once you choose which $m$ lines are used on the other side, you just assign each of the $n$ rooks to those lines so that none is left empty. Counting these assignments is exactly the number of surjections, computed by inclusion--exclusion.}
\NotePages{3}

\end{document}