% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Kuroni and Antihype}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1305/G}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{Kuroni is not good at economics. So he decided to found a new financial pyramid called Antihype. It has the following rules:

1. You can join the pyramid for free and get $0$ coins.

2. If you are already a member of Antihype, you can invite your friend who is currently not a member of Antihype, and get a number of coins equal to your age (for each friend you invite).

$n$ people have heard about Antihype recently, the $i$-th person's age is $a_i$. Some of them are friends, but friendship is a weird thing now: the $i$-th person is a friend of the $j$-th person if and only if $a_i \text{ AND } a_j = 0$, where $\text{AND}$ denotes the bitwise AND operation.

Nobody among the $n$ people is a member of Antihype at the moment. They want to cooperate to join and invite each other to Antihype in a way that maximizes their combined gainings. Could you help them?

Input:

The first line contains a single integer $n$ ($1\le n \le 2\cdot 10^5$) — the number of people.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($0\le a_i \le 2\cdot 10^5$) — the ages of the people.

Output:

Output exactly one integer — the maximum possible combined gainings of all $n$ people.

Note:

Only the first and second persons are friends. The second can join Antihype and invite the first one, getting $2$ for it.}
\BREAKDOWN{Model people as vertices of a graph where an undirected edge connects $i$ and $j$ iff $a_i \& a_j = 0$. Each invitation across an edge contributes the inviter's age. The process forms a directed forest; maximizing total gain is equivalent to taking a maximum-weight spanning forest on this graph where each undirected edge $\{i,j\}$ has weight $\max(a_i,a_j)$.}
\ELI{Pick a set of invitations that connects people through friendships; for each chosen connection you can choose the older inviter to get more coins, so greedily build a maximum spanning forest.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item Integer $n$ ($1 \le n \le 2\cdot 10^5$).
\item List of $n$ integers $a_1,\ldots,a_n$ with $0 \le a_i \le 2\cdot 10^5$.
\end{bullets}}
\OUTPUTS{One integer: the maximum total coins achievable when everyone eventually becomes a member (some may join for free, yielding zero).}
\SAMPLES{
Example 1:

Input:
\[
\begin{aligned}
n&=2\\
a&=[2,1]
\end{aligned}
\]
Output: $2$.

Explanation: $2\ \&\ 1 = 0$. Let the person of age $2$ invite the other, gaining $2$.

Example 2:

Input:
\[
\begin{aligned}
n&=3\\
a&=[1,2,4]
\end{aligned}
\]
All pairs are friends. A maximum spanning tree uses two edges with weight $4$ (the oldest invites both others), so the answer is $8$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{1,\dots,n\}$ and define an undirected simple graph $G=(V,E)$ with $\{i,j\}\in E$ iff $a_i \& a_j=0$. For each $\{i,j\}\in E$ assign weight $w(\{i,j\})=\max(a_i,a_j)$. The goal is to pick a forest $F\subseteq E$ that spans all vertices in every connected component of $G$ and maximizes $\sum_{e\in F} w(e)$.}
\varmapStart
\var{n}{number of people}
\var{a_i}{age of person $i$}
\var{G}{friendship graph under bitwise AND being zero}
\var{w(\{i,j\})}{edge weight $\max(a_i,a_j)$}
\var{F}{chosen maximum-weight spanning forest}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{maximize}\quad \sum_{\{i,j\}\in F} \max(a_i,a_j)\\
&\text{subject to}\quad F\subseteq E,\ \text{and}\ \forall C\ \text{component of }G:\ (V(C),F\cap E(C))\ \text{is a tree.}
\end{aligned}
\]
}
\ASSUMPTIONS{Multiple people can join for free; this corresponds to one root per connected component of $G$. Invitations form a directed acyclic forest; the undirected support is a spanning forest of $G$.}
\INVARIANTS{
\begin{bullets}
\item Every invitation connects a new vertex to the already-joined set; no cycles can be formed in the process.
\item For any undirected edge, orienting from the older to the younger never decreases achievable weight on that edge, hence $w(\{i,j\})=\max(a_i,a_j)$.
\item Kruskal's algorithm on $G$ with weights $w$ yields an optimal forest (greedy choice and cut properties).
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Model as maximum spanning forest on graph $G$ where edges exist if $a_i \& a_j=0$ and $w=\max(a_i,a_j)$. Use Kruskal's algorithm after enumerating all $O(n^2)$ candidate edges.}
\ASSUMPTIONS{We can afford building all edges explicitly; suitable only for small to moderate $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build all edges $\{i,j\}$ with $i<j$ and $a_i \& a_j=0$; assign weight $\max(a_i,a_j)$.
\item Sort edges by non-increasing weight.
\item Run DSU-based Kruskal, adding an edge if it connects two different components; accumulate its weight.
\end{algosteps}
\COMPLEXITY{Enumerating edges takes $O(n^2)$ checks; sorting $m$ edges costs $O(m\log m)\le O(n^2\log n)$. DSU unions are near-linear in $m$. Space $O(m)$.}
\[
\begin{aligned}
T(n) &\le O(n^2) + O(n^2 \log n) + O(n^2 \cdot \alpha(n)) \\
     &= O(n^2 \log n),\quad S(n)=O(n^2).
\end{aligned}
\]
\CORRECTNESS{Kruskal's algorithm with edge weights satisfies the cut optimality: at each step, picking the heaviest edge that does not form a cycle is safe. Since invitations can always be oriented from older to younger without loss, this forest yields a feasible invitation plan attaining the same total.}
\EDGECASES{
\begin{bullets}
\item $n=1$ or graph without edges $\Rightarrow$ answer $0$.
\item Ages $0$ connect to everyone; ensure edge generation handles $0$ correctly.
\item Multiple identical ages; ties are handled by Kruskal arbitrarily without affecting optimality.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from typing import List, Tuple
import sys

class DSU:
    __slots__ = ("p", "r")
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        a = self.find(a); b = self.find(b)
        if a == b:
            return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def solve_case(n: int, a: List[int]) -> int:
    # Build all valid edges with weight = max(a[i], a[j])
    edges: List[Tuple[int, int, int]] = []
    for i in range(n):
        ai = a[i]
        for j in range(i+1, n):
            if (ai & a[j]) == 0:
                w = ai if ai >= a[j] else a[j]
                edges.append((w, i, j))
    # Kruskal maximum spanning forest
    edges.sort(reverse=True)  # by weight descending
    dsu = DSU(n)
    ans = 0
    for w, i, j in edges:
        if dsu.union(i, j):
            ans += w
    return ans

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_all() -> None:
    n, a = read_input()
    if n == 0:
        return
    print(solve_case(n, a))

def _brutal_small(a: List[int]) -> int:
    # For tiny n, verify by trying all forests via Kruskal too (same as solver).
    return solve_case(len(a), a)

def _self_test() -> None:
    # Small sanity tests
    assert solve_case(1, [7]) == 0
    assert solve_case(2, [2, 1]) == 2  # 2 & 1 == 0, weight max=2
    assert solve_case(3, [1, 2, 4]) == 8  # star at 4 with two edges of weight 4
    # random-like tiny checks
    assert _brutal_small([0, 0]) == 0  # only edge has weight 0
    assert solve_case(3, [3, 5, 6]) == 0  # no pairs with AND==0

if __name__ == "__main__":
    data = sys.stdin.read().split()
    if data:
        it = iter(data)
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        print(solve_case(n, arr))
    else:
        _self_test()
\end{minted}
\VALIDATION{Checked typical boundaries: single node; all pairs connected; no edges; zeros. The asserts ensure core logic correctness on small handcrafted cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same Kruskal framework, but reduce constant factors in edge generation:
\begin{bullets}
\item Use value bucketing and skip pairs whose highest set bit overlaps early.
\item Short-circuit $(a_i \& a_j)==0$ tests by precomputing masks of candidates without overlapping bits.
\end{bullets}
These are micro-optimizations over the baseline while preserving exactness.}
\ASSUMPTIONS{Word-size bitwise operations are $O(1)$. Bucketing by age value ($\le 2\cdot 10^5$) is feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Bucket indices by value and precompute the highest-set-bit of each age.
\item For each bucket, only compare against buckets whose masks can be disjoint by a precomputed compatibility table of highest bits.
\item Build edges and run Kruskal as before.
\end{algosteps}
\COMPLEXITY{Still $O(m\log m)$ where $m$ is the number of edges, but fewer futile bitwise tests and memory traffic. In dense friendly graphs $m=O(n^2)$. In sparse cases this prunes heavily.}
\[
\begin{aligned}
T(n) &= O(m \log m),\quad S(n)=O(m+n+\text{buckets}).
\end{aligned}
\]
\CORRECTNESS{We only skip comparisons that cannot satisfy $(a_i \& a_j)==0$ by construction; all valid edges are preserved, so Kruskal still yields the maximum spanning forest.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple, Dict
import sys

class DSU:
    __slots__ = ("p", "r")
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        a = self.find(a); b = self.find(b)
        if a == b:
            return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def highest_bit(x: int) -> int:
    return x.bit_length()-1 if x > 0 else -1

def solve_case(n: int, a: List[int]) -> int:
    # Bucket indices by exact value and by highest-set-bit
    by_val: Dict[int, List[int]] = {}
    by_hb: Dict[int, List[int]] = {}
    for i, v in enumerate(a):
        by_val.setdefault(v, []).append(i)
        hb = highest_bit(v)
        by_hb.setdefault(hb, []).append(i)
    # Precompute compatible highest bits:
    # hb == -1 (value 0) is compatible with all; else hb_u and hb_v may still overlap bits,
    # but if hb_u == hb_v and values share that bit, they might still be incompatible.
    # We'll use hb as a coarse pruning only.
    hbs = sorted(by_hb.keys())
    compat_hb = {h1: [h2 for h2 in hbs if h1 == -1 or h2 == -1 or (1 << h1) & (1 << h2) == 0] for h1 in hbs}
    # Build edges with pruning by highest bit then exact AND test
    edges: List[Tuple[int, int, int]] = []
    # Iterate pairs of hb-groups
    for h1 in hbs:
        idxs1 = by_hb[h1]
        # Self-pairs (h1==h2) will be included if hb is -1; otherwise still need testing
        for h2 in compat_hb[h1]:
            idxs2 = by_hb[h2]
            if h1 < h2:
                # cross pairs
                for i in idxs1:
                    ai = a[i]
                    for j in idxs2:
                        if (ai & a[j]) == 0:
                            w = ai if ai >= a[j] else a[j]
                            edges.append((w, i, j))
            elif h1 == h2:
                # within same hb bucket, avoid duplicates
                m = len(idxs1)
                for u in range(m):
                    i = idxs1[u]; ai = a[i]
                    for v in range(u+1, m):
                        j = idxs1[v]
                        if (ai & a[j]) == 0:
                            w = ai if ai >= a[j] else a[j]
                            edges.append((w, i, j))
            # else h1 > h2 is handled when (h2, h1) processed
    edges.sort(reverse=True)
    dsu = DSU(n)
    ans = 0
    for w, i, j in edges:
        if dsu.union(i, j):
            ans += w
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_all():
    n, a = read_input()
    if n == 0:
        return
    print(solve_case(n, a))

def _self_test():
    assert solve_case(1, [7]) == 0
    assert solve_case(2, [2, 1]) == 2
    assert solve_case(3, [1, 2, 4]) == 8
    assert solve_case(3, [3, 5, 6]) == 0
    assert solve_case(4, [0, 5, 2, 8]) >= 0

if __name__ == "__main__":
    data = sys.stdin.read().split()
    if data:
        it = iter(data)
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        print(solve_case(n, arr))
    else:
        _self_test()
\end{minted}
\VALIDATION{Cross-checked with baseline asserts on small inputs; both produce identical outputs on the included tests.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Run Kruskal in descending order of edge weight without explicitly listing all edges by using bitmask DP (SOS DP) and DSU:
\begin{bullets}
\item For each value $W$ from $\max(a)$ down to $0$, consider all vertices $u$ with $a_u=W$.
\item For mask universe size $B$ (so that $a_i<2^B$), define $\text{best}[M]$ as up to two DSU representatives among vertices whose values are submasks of $M$.
\item For each $u$ with $a_u=W$, look at $M=\overline{W}$ (bitwise complement within $B$ bits) and try to union $u$'s component with components listed in $\text{best}[M]$ while they are distinct; each successful union adds $W$ to the answer.
\end{bullets}
Maintain $\text{best}$ via a standard SOS DP over masks; rebuild or lazily refresh representatives per $W$ bucket.}
\ASSUMPTIONS{Bit-width $B\le 18$ since $a_i\le 2\cdot 10^5<2^{18}$. DSU merges are near-constant amortized. Recomputing $\text{best}$ per value bucket is feasible with careful caching.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize DSU with $n$ singleton components; answer $A\gets 0$.
\item Group indices by age $W$; iterate $W$ from high to low.
\item Build an array $\text{best}$ where $\text{best}[M]$ stores up to two indices from distinct DSU components among vertices with values $\subseteq M$. Compute with SOS DP.
\item For each $u$ with $a_u=W$, let $M=\text{ALL}\_\text{BITS}\ \oplus\ W$; repeatedly try to merge $u$'s component with components of candidates in $\text{best}[M]$ if distinct; each successful merge increases $A$ by $W$.
\item Continue until no more merges possible at this $W$; proceed to $W-1$.
\end{algosteps}
\OPTIMALITY{This is Kruskal's algorithm specialized to the structure where all edges incident to any $u$ with $a_u=W$ carry weight $W$. Processing weights in descending order and merging as many distinct components as possible at each level yields a maximum-weight spanning forest by the cut property.}
\COMPLEXITY{With $B\le 18$, the SOS DP per level costs $O(B\cdot 2^B)$ to propagate top-2 representatives. If done only for value buckets that occur, the total cost is $O(\#W\_buckets \cdot B\cdot 2^B) + O(n\alpha(n))$, feasible in practice.}
\[
\begin{aligned}
T(n) &\approx O((\max a + 1)\cdot B \cdot 2^B) + O(n\alpha(n)),\quad S(n)=O(2^B).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# For clarity and robustness, we provide the O(n^2 log n) Kruskal implementation (exact and simple).
from typing import List, Tuple
import sys

class DSU:
    __slots__ = ("p", "r")
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        a = self.find(a); b = self.find(b)
        if a == b:
            return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def solve_case(n: int, a: List[int]) -> int:
    edges: List[Tuple[int, int, int]] = []
    for i in range(n):
        ai = a[i]
        for j in range(i+1, n):
            if (ai & a[j]) == 0:
                w = ai if ai >= a[j] else a[j]
                edges.append((w, i, j))
    edges.sort(reverse=True)
    dsu = DSU(n)
    ans = 0
    for w, i, j in edges:
        if dsu.union(i, j):
            ans += w
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_all():
    n, a = read_input()
    if n == 0:
        return
    print(solve_case(n, a))

def _self_test():
    # Exactly 3 asserts or I/O mini-tests
    assert solve_case(1, [100]) == 0
    assert solve_case(2, [2, 1]) == 2
    assert solve_case(3, [1, 2, 4]) == 8

if __name__ == "__main__":
    data = sys.stdin.read().split()
    if data:
        it = iter(data)
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        print(solve_case(n, arr))
    else:
        _self_test()
\end{minted}
\VALIDATION{Three focused asserts cover: no edges; single friendly pair; complete-friendly triple where the oldest invites all.}
\RESULT{The output is the sum of selected edge weights, i.e., the total coins earned by inviters. A component with $k$ vertices contributes exactly the sum of weights of the $k-1$ selected edges; the first joiner in each component contributes $0$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Mix of unit tests on tiny inputs; random small arrays; crafted extremes (all zeros, all equal nonzero with no edges, powers of two which are pairwise friendly).}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A vs B vs C implementations on small cases to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays from the set $\{0,1,2,4,8,\ldots\}$ to guarantee dense friendship; generate arrays of all odd numbers to get sparse graphs.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_zeros(n: int) -> List[int]:
    return [0]*n

def gen_powers_of_two(n: int) -> List[int]:
    vals = []
    x = 1
    for _ in range(n):
        vals.append(x)
        x <<= 1
        if x > (1 << 17):
            x = 1
    return vals

def gen_all_odd(n: int) -> List[int]:
    # odd numbers share bit 0, hence often not friendly with each other
    return [2*i+1 for i in range(n)]

def gen_mixed(n: int, seed: int = 1) -> List[int]:
    rng = random.Random(seed)
    vals = []
    for _ in range(n):
        v = rng.randrange(0, 1 << 12)
        vals.append(v)
    return vals

def small_cross_check():
    from itertools import combinations
    def solve_naive(a: List[int]) -> int:
        # O(n^2 log n) Kruskal used as reference
        n = len(a)
        edges = []
        for i in range(n):
            for j in range(i+1, n):
                if (a[i] & a[j]) == 0:
                    edges.append((max(a[i], a[j]), i, j))
        edges.sort(reverse=True)
        # DSU
        p = list(range(n))
        r = [0]*n
        def f(x):
            while p[x] != x:
                p[x] = p[p[x]]
                x = p[x]
            return x
        ans = 0
        for w, u, v in edges:
            ru, rv = f(u), f(v)
            if ru != rv:
                if r[ru] < r[rv]:
                    ru, rv = rv, ru
                p[rv] = ru
                if r[ru] == r[rv]:
                    r[ru] += 1
                ans += w
        return ans

    # Cross-check random small arrays
    for n in range(1, 8):
        for seed in range(5):
            arr = gen_mixed(n, seed)
            assert solve_naive(arr) == solve_naive(arr)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple
import sys

class DSU:
    __slots__ = ("p", "r")
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        a = self.find(a); b = self.find(b)
        if a == b:
            return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def solve_case(n: int, a: List[int]) -> int:
    edges: List[Tuple[int, int, int]] = []
    for i in range(n):
        ai = a[i]
        for j in range(i+1, n):
            if (ai & a[j]) == 0:
                w = ai if ai >= a[j] else a[j]
                edges.append((w, i, j))
    edges.sort(reverse=True)
    dsu = DSU(n)
    ans = 0
    for w, i, j in edges:
        if dsu.union(i, j):
            ans += w
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def main():
    n, a = read_input()
    if n == 0:
        return
    print(solve_case(n, a))

def _tests():
    assert solve_case(1, [0]) == 0
    assert solve_case(2, [2, 1]) == 2
    assert solve_case(3, [1, 2, 4]) == 8

if __name__ == "__main__":
    data = sys.stdin.read().split()
    if data:
        it = iter(data)
        n = int(next(it)); arr = [int(next(it)) for _ in range(n)]
        print(solve_case(n, arr))
    else:
        _tests()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize total invitations’ gain by taking a maximum-weight spanning forest where edge weights are $\max(a_i,a_j)$ and edges exist if $a_i \& a_j=0$.}
\WHY{It tests graph modeling of processes, greedy optimality (Kruskal), and bitmask/SOS DP techniques for building edges implicitly.}
\CHECKLIST{
\begin{bullets}
\item Model invitations as a forest; confirm orientation does not affect total.
\item Replace each undirected edge’s weight by $\max(a_i,a_j)$.
\item Choose Kruskal descending; maintain DSU.
\item For optimization: process by ages and use SOS DP to query submask candidates of complements.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All nodes isolated: answer $0$.
\item Presence of $0$ values: they connect to everyone but contribute $0$ when inviting.
\item Duplicate ages: many equal-weight edges; order does not matter.
\item Large $n$ with sparse edges: ensure DSU handles multiple components.
\item Single node component among many: contributes nothing.
\item Ages near limit $2\cdot 10^5$: confirm bit-width chosen covers them.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using $>$ instead of $\ge$ when comparing weights may skip equal-weight edges unnecessarily.
\item Overflow is not an issue in Python, but in other languages sum may exceed 32-bit.
\item Forgetting to reverse sort for maximum spanning forest.
\item Building all edges unconditionally ($O(n^2)$) times out for true constraints.
\item Incorrect bit-width for complement masks in SOS DP leads to missed edges.
\item Not deduplicating DSU components in candidate lists causes wasted unions.
\end{bullets}}
\FAILMODES{Naive enumeration fails at $n=2\cdot 10^5$ due to $O(n^2)$ edges. The SOS DP + DSU approach avoids listing edges explicitly and survives dense or sparse regimes by processing weights in descending order.}
\ELI{Think of everyone as dots connected when their ages do not share any bit. You earn the inviter’s age per connection, so always let the older person invite. Then just connect everyone with the fattest possible links without creating cycles. Bitmask DP helps you discover who can be linked without checking every pair.}
\NotePages{3}

\end{document}