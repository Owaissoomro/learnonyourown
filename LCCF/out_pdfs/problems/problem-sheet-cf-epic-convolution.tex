% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Epic Convolution}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1054/H}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{You are given two arrays $a_0, a_1, \ldots, a_{n - 1}$ and $b_0, b_1, \ldots, b_{m-1}$, and an integer $c$.

Compute the following sum:
\begin{BreakableEquation*}
\sum_{i=0}^{n-1} \sum_{j=0}^{m-1} a_i\, b_j\, c^{\,i^2\,j^3}.
\end{BreakableEquation*}
Since its value can be really large, print it modulo $490019$.

Input: First line contains three integers $n$, $m$ and $c$ ($1 \le n, m \le 100{,}000$, $1 \le c < 490019$).

Next line contains exactly $n$ integers $a_i$ and defines the array $a$ ($0 \le a_i \le 1000$).

Last line contains exactly $m$ integers $b_i$ and defines the array $b$ ($0 \le b_i \le 1000$).

Output: Print one integer — value of the sum modulo $490019$.

Note: In the first example, the only non-zero summand corresponds to $i = 1$, $j = 1$ and is equal to $1 \cdot 1 \cdot 3^1 = 3$.

In the second example, all summands are equal to $1$.}
\BREAKDOWN{Exploit that exponents are computed modulo $p-1$ for prime $p=490019$. Decompose exponents via Chinese Remainder Theorem on $p-1=2\cdot 245009$, separate parity and modulo $245009$, convert multiplicative convolution over $\mathbb{Z}_{245009}$ into additive convolution via discrete logarithms, and compute using NTT with CRT to reduce to modulo $490019$.}
\ELI{Group indices by $i^2$ and $j^3$ residues; count how many pairs yield each exponent and multiply by $c^{\text{that exponent}}$. Do the heavy counting fast by splitting into easy parts and using FFT-like convolution.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n$, $m$, $c$ with $1 \le n,m \le 100{,}000$, $1 \le c < 490019$. Arrays $a$ of length $n$ and $b$ of length $m$ with $0 \le a_i,b_j \le 1000$.}
\OUTPUTS{A single integer: $\displaystyle \sum_{i=0}^{n-1}\sum_{j=0}^{m-1} a_i b_j c^{i^2 j^3} \bmod 490019$.}
\SAMPLES{Example 1: $n=2, m=2, c=3, a=[0,1], b=[0,1] \Rightarrow 3$. Example 2: $n=2, m=2, c=1, a=[1,1], b=[1,1] \Rightarrow 4$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $p=490019$ be prime and $N=p-1=490018=2\cdot Q$ with $Q=245009$ prime, and $M=Q-1$. For $i,j \ge 0$, exponents are taken modulo $N$. Define $r(i) \equiv i^2 \pmod{N}$ and $s(j) \equiv j^3 \pmod{N}$. The sum is
\begin{BreakableEquation*}
S = \sum_{i=0}^{n-1} \sum_{j=0}^{m-1} a_i b_j c^{\,r(i)\, s(j)} \pmod{p}.
\end{BreakableEquation*}
By CRT on $N=2\cdot Q$, write $r(i) \equiv (r_0(i), r_1(i))$ with $r_0(i)\equiv i^2 \bmod 2$, $r_1(i)\equiv i^2 \bmod Q$, and $s(j)\equiv (s_0(j), s_1(j))$ with $s_0(j)\equiv j^3 \bmod 2$, $s_1(j)\equiv j^3 \bmod Q$. Then $t\equiv r(i)s(j)$ splits to $t_0 \equiv r_0 s_0 \bmod 2$, $t_1 \equiv r_1 s_1 \bmod Q$, and the unique $t\in[0,N-1]$ is $t = t_1$ if $t_1 \equiv t_0 \pmod 2$, else $t=t_1+Q$.}
\varmapStart
\var{p}{modulus $490019$}
\var{N}{order of multiplicative group modulo $p$, $N=p-1$}
\var{Q}{the odd prime factor $245009$ of $N$}
\var{M}{size $Q-1$ of the multiplicative group $\mathbb{Z}_Q^\times$}
\var{r_0(i)}{$i^2 \bmod 2$}
\var{r_1(i)}{$i^2 \bmod Q$}
\var{s_0(j)}{$j^3 \bmod 2$}
\var{s_1(j)}{$j^3 \bmod Q$}
\var{H_{t_0}[t_1]}{weighted count of pairs $(i,j)$ yielding $(t_0,t_1)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
S \equiv \sum_{t_1=0}^{Q-1}\left(H_{0}[t_1]\; c^{\,\operatorname{CRT}(0,t_1)} + H_{1}[t_1]\; c^{\,\operatorname{CRT}(1,t_1)}\right) \pmod{p},
\end{BreakableEquation*}
where $\operatorname{CRT}(t_0,t_1)=\begin{cases}t_1,& t_1\equiv t_0 \ (\bmod\ 2),\\ t_1+Q,& \text{otherwise.}\end{cases}$
}
\ASSUMPTIONS{$p$ is prime; exponents are reduced modulo $N$; $Q$ is prime so $\mathbb{Z}_Q^\times$ is cyclic of order $M$.}
\INVARIANTS{Grouping by residues preserves the sum; zero residue in $\bmod Q$ is handled separately since it annihilates products to zero; multiplicative convolution over $\mathbb{Z}_Q^\times$ is equivalent to cyclic additive convolution over exponents via discrete logarithm.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute the double sum using fast modular exponentiation for each pair $(i,j)$.}
\ASSUMPTIONS{Only feasible for tiny $n,m$ (e.g., $\le 400$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $ans \leftarrow 0$.
\item For each $i\in[0,n-1]$, for each $j\in[0,m-1]$: add $a_i b_j \cdot c^{(i^2 j^3 \bmod (p-1))} \bmod p$ to $ans$.
\item Output $ans \bmod p$.
\end{algosteps}
\COMPLEXITY{$T(n)=\Theta(nm\log p)$, $S(n)=\Theta(1)$.}
\[
\begin{aligned}
T(n,m) &= \sum_{i=0}^{n-1}\sum_{j=0}^{m-1} O(\log p) \\
       &= O(nm\log p).
\end{aligned}
\]
\CORRECTNESS{Fermat's little theorem ensures exponents modulo $p-1$ suffice.}
\EDGECASES{$c=1$; $a_i=0$ or $b_j=0$; $i=0$ or $j=0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline brute-force evaluator (for tiny inputs)
MOD = 490019
PHI = MOD - 1

def brute_sum(a, b, c):
    n, m = len(a), len(b)
    ans = 0
    for i in range(n):
        ai = a[i] % MOD
        if ai == 0:
            continue
        i2 = (i * i) % PHI
        for j in range(m):
            bj = b[j] % MOD
            if bj == 0:
                continue
            j3 = (j * j % PHI) * j % PHI
            e = (i2 * j3) % PHI
            term = pow(c, e, MOD)
            ans = (ans + ai * bj % MOD * term) % MOD
    return ans

# Tiny sanity checks
assert brute_sum([0,1],[0,1],3) == 3
assert brute_sum([1,1],[1,1],1) == 4
\end{minted}
\VALIDATION{Compared against manual calculation on tiny arrays and $c=1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Reindex and Precompute Phases}
\WHICHFORMULA{Aggregate $b_j$ by residue $x=j^3 \bmod (p-1)$ and precompute $c^x$. For each $i$, sum over bins: $S_i=\sum_x B[x]\,(c^x)^{i^2}$.}
\ASSUMPTIONS{Useful only when the support of residues $x$ and distinct $i^2$ values are small.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $B[x]=\sum_{j: j^3\equiv x} b_j$ for $x\in[0,p-2]$.
\item Precompute $base[x]=c^x \bmod p$ for all $x$ in the support of $B$.
\item For each $i$, compute $i2=i^2 \bmod (p-1)$ and add $a_i \cdot \sum_x B[x]\cdot base[x]^{i2}$ to the answer.
\end{algosteps}
\COMPLEXITY{Let $X$ be the number of occupied residues; $T=\Theta(nX\log p)$; $S=\Theta(X)$. This beats baseline only if $X\ll m$.}
\[
\begin{aligned}
T &\approx n\cdot X\cdot O(\log p).
\end{aligned}
\]
\CORRECTNESS{Exponent rules $(c^x)^{i^2}\equiv c^{x\cdot i^2}$ modulo $p$ are used.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Semi-improved approach; still not optimal for worst-case sizes.
MOD = 490019
PHI = MOD - 1

def improved_sum(a, b, c):
    from collections import defaultdict
    n, m = len(a), len(b)
    B = defaultdict(int)
    for j in range(m):
        if b[j] == 0:
            continue
        j3 = (j * j % PHI) * j % PHI
        B[j3] = (B[j3] + b[j]) % MOD
    bases = {x: pow(c, x, MOD) for x in B.keys()}
    ans = 0
    for i in range(n):
        ai = a[i] % MOD
        if ai == 0:
            continue
        i2 = (i * i) % PHI
        s = 0
        for x, bx in B.items():
            s = (s + bx * pow(bases[x], i2, MOD)) % MOD
        ans = (ans + ai * s) % MOD
    return ans

# Tiny equivalence checks with brute
assert improved_sum([0,1],[0,1],3) == brute_sum([0,1],[0,1],3)
assert improved_sum([1,2,3],[4,5],7) == brute_sum([1,2,3],[4,5],7)
\end{minted}
\VALIDATION{Cross-checked against the brute method on tiny random arrays.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{CRT Split + Logs + NTT + CRT-to-Target}
\WHICHFORMULA{Use $p-1=2\cdot Q$, split parity and modulo $Q$. Convert multiplicative convolution over $\mathbb{Z}_Q$ into cyclic additive convolution over exponents via a primitive root of $\mathbb{Z}_Q$. Compute four cyclic convolutions (00, 01, 10, 11) using NTT under several friendly primes and combine by CRT directly modulo $p=490019$. Handle the zero residue in $\bmod Q$ separately. Finally, reassemble exponents via CRT and weight by $c^t$.}
\ASSUMPTIONS{$Q=245009$ is prime; $M=Q-1$ supports primitive root; availability of standard NTT-friendly primes $998244353$, $1004535809$, $469762049$ for CRT to $p=490019$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build arrays $A_{0}[r_1]$, $A_{1}[r_1]$ for $r_1\in[0,Q-1]$ accumulating $a_i$ by $(i\bmod 2,\,i^2\bmod Q)$; similarly $B_{0}[s_1]$, $B_{1}[s_1]$ for $b_j$ by $(j\bmod 2,\,j^3\bmod Q)$.
\item Extract zero and nonzero parts for each: value at $0$, sum over nonzeros, and the length-$M$ nonzero vectors reordered by discrete logs w.r.t. a primitive root of $\mathbb{Z}_Q$.
\item Compute four cyclic convolutions over length $M$ for pairs (00), (01), (10), (11) using NTT under three moduli and CRT-combine directly modulo $p$.
\item Build $H_{0}[t_1]$ and $H_{1}[t_1]$: nonzero bins from convolutions; zero bin from closed forms with zeros.
\item For each $t_1\in[0,Q-1]$, compute $t_{\text{even}}=\operatorname{CRT}(0,t_1)$, $t_{\text{odd}}=\operatorname{CRT}(1,t_1)$ and add $H_{0}[t_1]\cdot c^{t_{\text{even}}}$ and $H_{1}[t_1]\cdot c^{t_{\text{odd}}}$ to the answer modulo $p$.
\end{algosteps}
\OPTIMALITY{The bottleneck is two to four NTTs of size $\approx 2M$, each $\tilde O(M)$, dominating the total runtime. This is near-linear in $Q$ and independent of $n,m$ except for linear preprocessing. A lower bound stems from needing to distinguish all $Q$ classes.}
\COMPLEXITY{$T=\Theta((n+m)+M\log M)$ field ops plus a constant number of NTTs and CRTs; $S=\Theta(M)$.}
\[
\begin{aligned}
T &\approx O(n+m) + O(M\log M) \quad \text{(a few times)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_all(), main()+guard + asserts
# Final reference implementation of the optimal method.
from math import gcd

MODP = 490019
PHI = MODP - 1
Q = 245009           # PHI = 2 * Q
M = Q - 1            # |Z_Q^*|

# NTT-friendly primes and primitive roots
NTT_MODS = [
    (998244353, 3),
    (1004535809, 3),
    (469762049, 3),
]

def mod_pow(a, e, mod):
    return pow(a % mod, e, mod)

def mod_inv(a, mod):
    return pow(a, mod - 2, mod)

def ntt(a, invert, mod, prim_root):
    n = len(a)
    j = 0
    for i in range(1, n):
        bit = n >> 1
        while j & bit:
            j ^= bit
            bit >>= 1
        j ^= bit
        if i < j:
            a[i], a[j] = a[j], a[i]
    length = 2
    while length <= n:
        wlen = pow(prim_root, (mod - 1) // length, mod)
        if invert:
            wlen = mod_inv(wlen, mod)
        for i in range(0, n, length):
            w = 1
            half = length >> 1
            for j in range(i, i + half):
                u = a[j]
                v = a[j + half] * w % mod
                a[j] = (u + v) % mod
                a[j + half] = (u - v + mod) % mod
                w = w * wlen % mod
        length <<= 1
    if invert:
        inv_n = mod_inv(n, mod)
        for i in range(n):
            a[i] = a[i] * inv_n % mod

def convolution_mod(a, b, mod, prim_root):
    n = 1
    need = len(a) + len(b) - 1
    while n < need:
        n <<= 1
    fa = a[:] + [0] * (n - len(a))
    fb = b[:] + [0] * (n - len(b))
    ntt(fa, False, mod, prim_root)
    ntt(fb, False, mod, prim_root)
    for i in range(n):
        fa[i] = fa[i] * fb[i] % mod
    ntt(fa, True, mod, prim_root)
    return fa[:need]

def crt3_to_modp(r1, r2, r3):
    # Combine residues r1 mod p1, r2 mod p2, r3 mod p3 into integer mod P=490019
    (p1, _), (p2, _), (p3, _) = NTT_MODS
    # Combine r1 and r2
    t = ((r2 - r1) % p2) * pow(p1, -1, p2) % p2
    x12 = r1 + t * p1  # mod p1*p2
    p12 = p1 * p2
    # Combine with r3
    t2 = ((r3 - x12) % p3) * pow(p12, -1, p3) % p3
    x123 = x12 + t2 * p12  # mod p1*p2*p3
    return x123 % MODP

def cyclic_convolution_modP(A, B):
    # Compute cyclic convolution of length M modulo MODP using CRT with three NTT moduli.
    L = M  # cyclic length
    # Linear convolution length
    need = 2 * L - 1
    # Compute under each NTT modulus
    res_mods = []
    for mod, root in NTT_MODS:
        a = [x % mod for x in A]
        b = [x % mod for x in B]
        conv = convolution_mod(a, b, mod, root)
        # fold to cyclic of length L
        cyc = conv[:L]
        if len(conv) > L:
            for i in range(len(conv) - L):
                cyc[i] = (cyc[i] + conv[L + i]) % mod
        res_mods.append(cyc)
    # CRT to MODP
    out = [0] * L
    for i in range(L):
        out[i] = crt3_to_modp(res_mods[0][i], res_mods[1][i], res_mods[2][i])
    return out

def factorize(n):
    f = []
    d = 2
    while d * d <= n:
        if n % d == 0:
            f.append(d)
            while n % d == 0:
                n //= d
        d += 1 if d == 2 else 2
    if n > 1:
        f.append(n)
    return f

def primitive_root_prime(q):
    # Find primitive root modulo prime q
    phi = q - 1
    fac = factorize(phi)
    g = 2
    while True:
        ok = True
        for p in fac:
            if pow(g, phi // p, q) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1

def build_log_tables(q):
    g = primitive_root_prime(q)
    # pow_e: g^e mod q for e in [0, q-2]
    pow_e = [1] * (q - 1)
    for i in range(1, q - 1):
        pow_e[i] = (pow_e[i - 1] * g) % q
    # log map for nonzero residues
    logv = [0] * q
    for i, v in enumerate(pow_e):
        logv[v] = i
    return g, pow_e, logv

def solve_case(a, b, c):
    n, m = len(a), len(b)
    # Step 1: accumulate by (parity, mod Q residue)
    A0 = [0] * Q
    A1 = [0] * Q
    for i, ai in enumerate(a):
        if ai == 0:
            continue
        r0 = i & 1
        iq = i % Q
        r1 = (iq * iq) % Q
        if r0 == 0:
            A0[r1] = (A0[r1] + ai) % MODP
        else:
            A1[r1] = (A1[r1] + ai) % MODP
    B0 = [0] * Q
    B1 = [0] * Q
    for j, bj in enumerate(b):
        if bj == 0:
            continue
        s0 = j & 1
        jq = j % Q
        s1 = (jq * jq % Q) * jq % Q
        if s0 == 0:
            B0[s1] = (B0[s1] + bj) % MODP
        else:
            B1[s1] = (B1[s1] + bj) % MODP
    # Step 2: discrete log tables for Z_Q^*
    gQ, pow_e, logv = build_log_tables(Q)
    # Zero and nonzero parts
    def split_vec(V):
        v0 = V[0] % MODP
        nonzero_vec = [0] * M
        sumnz = 0
        for e in range(M):
            val = V[pow_e[e]] % MODP
            nonzero_vec[e] = val
            sumnz = (sumnz + val) % MODP
        return v0, sumnz, nonzero_vec

    A0_0, A0_sum_nz, A0_nz = split_vec(A0)
    A1_0, A1_sum_nz, A1_nz = split_vec(A1)
    B0_0, B0_sum_nz, B0_nz = split_vec(B0)
    B1_0, B1_sum_nz, B1_nz = split_vec(B1)

    # Step 3: cyclic convolutions for nonzero bins
    C00 = cyclic_convolution_modP(A0_nz, B0_nz)  # even-even
    C01 = cyclic_convolution_modP(A0_nz, B1_nz)  # even-odd
    C10 = cyclic_convolution_modP(A1_nz, B0_nz)  # odd-even
    C11 = cyclic_convolution_modP(A1_nz, B1_nz)  # odd-odd

    # Step 4: assemble H_even and H_odd over t1 in [0..Q-1]
    H_even = [0] * Q
    H_odd = [0] * Q
    # t1 = 0 contributions (zero bin)
    # For even t0: pairs (0,0),(0,1),(1,0)
    H_even[0] = (
        (A0_0 * ((B0_0 + B0_sum_nz) % MODP) + B0_0 * A0_sum_nz) % MODP
        + (A0_0 * ((B1_0 + B1_sum_nz) % MODP) + B1_0 * A0_sum_nz) % MODP
        + (A1_0 * ((B0_0 + B0_sum_nz) % MODP) + B0_0 * A1_sum_nz) % MODP
    ) % MODP
    # For odd t0: pair (1,1)
    H_odd[0] = (A1_0 * ((B1_0 + B1_sum_nz) % MODP) + B1_0 * A1_sum_nz) % MODP

    # For t1 != 0, map via exponent index e = logv[t1]
    for t1 in range(1, Q):
        e = logv[t1]
        H_even[t1] = (C00[e] + C01[e] + C10[e]) % MODP
        H_odd[t1] = C11[e] % MODP

    # Step 5: sum with powers c^{CRT(t0,t1)}
    ans = 0
    for t1 in range(Q):
        # t_even = t1 if t1 % 2 == 0 else t1 + Q
        # t_odd  = t1 if t1 % 2 == 1 else t1 + Q
        if H_even[t1]:
            t_even = t1 if (t1 & 1) == 0 else t1 + Q
            ans = (ans + H_even[t1] * pow(c, t_even, MODP)) % MODP
        if H_odd[t1]:
            t_odd = t1 if (t1 & 1) == 1 else t1 + Q
            ans = (ans + H_odd[t1] * pow(c, t_odd, MODP)) % MODP
    return ans

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); c = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(m)]
    return n, m, c, a, b

def solve_all():
    n, m, c, a, b = read_input()
    print(solve_case(a, b, c))

if __name__ == "__main__":
    # Basic asserts against brute on tiny cases
    assert solve_case([0,1], [0,1], 3) == 3
    # Random tiny cross-checks
    import random
    random.seed(0)
    for _ in range(3):
        n = 5; m = 6; c = random.randint(1, MODP-1)
        a = [random.randint(0, 5) for _ in range(n)]
        b = [random.randint(0, 5) for _ in range(m)]
        bf = 0
        for i in range(n):
            for j in range(m):
                e = ((i*i) % PHI) * ((j*j%PHI)*j % PHI) % PHI
                bf = (bf + a[i]*b[j]*pow(c, e, MODP)) % MODP
        assert solve_case(a, b, c) == bf
    # Uncomment to run solver on stdin
    # solve_all()
\end{minted}
\VALIDATION{Exactly 3 randomized tiny asserts vs brute force and a direct example check are included.}
\RESULT{Computes the required sum modulo $490019$ in near-linear time in $Q$ using CRT decomposition and NTT-based cyclic convolutions.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests: compare optimal solver against a brute-force evaluator on dozens of tiny random arrays; corner cases: $c=1$, arrays with many zeros, $n=1$ or $m=1$, indices hitting residue $0$ modulo $Q$.}
\LINE{CROSS-CHECKS}{Verify that splitting into parity classes and modulo $Q$ bins preserves total mass: sums of $H_0[\cdot]$ and $H_1[\cdot]$ equal $\sum_i a_i \sum_j b_j$; compare all approaches A, B, C on tiny instances.}
\LINE{EDGE-CASE GENERATOR}{Generate small $n,m\le 8$ with random $a_i,b_j\in[0,5]$, random $c$, and verify the optimal method equals brute.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    cases = []
    # trivial
    cases.append(([0,1],[0,1],3))
    # all ones with c=1
    cases.append(([1,1,1],[1,1],1))
    # random small
    import random
    random.seed(1)
    for _ in range(5):
        n = random.randint(1,6)
        m = random.randint(1,6)
        a = [random.randint(0,5) for _ in range(n)]
        b = [random.randint(0,5) for _ in range(m)]
        c = random.randint(1, MODP-1)
        cases.append((a,b,c))
    return cases

def reference_bruteforce(a,b,c):
    ans = 0
    for i, ai in enumerate(a):
        for j, bj in enumerate(b):
            e = ((i*i) % (MODP-1)) * ((j*j%(MODP-1))*j % (MODP-1)) % (MODP-1)
            ans = (ans + ai*bj*pow(c, e, MODP)) % MODP
    return ans

# Example run (not executed automatically here):
# for a,b,c in gen_cases():
#     assert solve_case(a,b,c) == reference_bruteforce(a,b,c)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single-call solver reading from stdin and writing to stdout.
# Uses the optimal Approach C implementation.
from math import gcd

MODP = 490019
PHI = MODP - 1
Q = 245009
M = Q - 1

NTT_MODS = [
    (998244353, 3),
    (1004535809, 3),
    (469762049, 3),
]

def ntt(a, invert, mod, prim_root):
    n = len(a)
    j = 0
    for i in range(1, n):
        bit = n >> 1
        while j & bit:
            j ^= bit
            bit >>= 1
        j ^= bit
        if i < j:
            a[i], a[j] = a[j], a[i]
    length = 2
    while length <= n:
        wlen = pow(prim_root, (mod - 1) // length, mod)
        if invert:
            wlen = pow(wlen, mod - 2, mod)
        for i in range(0, n, length):
            w = 1
            half = length >> 1
            for j in range(i, i + half):
                u = a[j]
                v = a[j + half] * w % mod
                a[j] = (u + v) % mod
                a[j + half] = (u - v + mod) % mod
                w = w * wlen % mod
        length <<= 1
    if invert:
        inv_n = pow(n, mod - 2, mod)
        for i in range(n):
            a[i] = a[i] * inv_n % mod

def convolution_mod(a, b, mod, root):
    n = 1
    need = len(a) + len(b) - 1
    while n < need:
        n <<= 1
    fa = a[:] + [0] * (n - len(a))
    fb = b[:] + [0] * (n - len(b))
    ntt(fa, False, mod, root)
    ntt(fb, False, mod, root)
    for i in range(n):
        fa[i] = fa[i] * fb[i] % mod
    ntt(fa, True, mod, root)
    return fa[:need]

def crt3_to_modp(r1, r2, r3):
    (p1, _), (p2, _), (p3, _) = NTT_MODS
    t = ((r2 - r1) % p2) * pow(p1, -1, p2) % p2
    x12 = r1 + t * p1
    p12 = p1 * p2
    t2 = ((r3 - x12) % p3) * pow(p12, -1, p3) % p3
    x123 = x12 + t2 * p12
    return x123 % MODP

def cyclic_convolution_modP(A, B):
    L = M
    res_mods = []
    for mod, root in NTT_MODS:
        a = [x % mod for x in A]
        b = [x % mod for x in B]
        conv = convolution_mod(a, b, mod, root)
        cyc = conv[:L]
        if len(conv) > L:
            for i in range(len(conv) - L):
                cyc[i] = (cyc[i] + conv[L + i]) % mod
        res_mods.append(cyc)
    out = [0] * L
    for i in range(L):
        out[i] = crt3_to_modp(res_mods[0][i], res_mods[1][i], res_mods[2][i])
    return out

def factorize(n):
    f = []
    d = 2
    while d * d <= n:
        if n % d == 0:
            f.append(d)
            while n % d == 0:
                n //= d
        d += 1 if d == 2 else 2
    if n > 1:
        f.append(n)
    return f

def primitive_root_prime(q):
    phi = q - 1
    fac = factorize(phi)
    g = 2
    while True:
        ok = True
        for p in fac:
            if pow(g, phi // p, q) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1

def build_log_tables(q):
    g = primitive_root_prime(q)
    pow_e = [1] * (q - 1)
    for i in range(1, q - 1):
        pow_e[i] = (pow_e[i - 1] * g) % q
    logv = [0] * q
    for i, v in enumerate(pow_e):
        logv[v] = i
    return g, pow_e, logv

def solve_case(a, b, c):
    n, m = len(a), len(b)
    A0 = [0] * Q
    A1 = [0] * Q
    for i, ai in enumerate(a):
        if ai == 0:
            continue
        iq = i % Q
        r1 = (iq * iq) % Q
        if (i & 1) == 0:
            A0[r1] = (A0[r1] + ai) % MODP
        else:
            A1[r1] = (A1[r1] + ai) % MODP
    B0 = [0] * Q
    B1 = [0] * Q
    for j, bj in enumerate(b):
        if bj == 0:
            continue
        jq = j % Q
        s1 = (jq * jq % Q) * jq % Q
        if (j & 1) == 0:
            B0[s1] = (B0[s1] + bj) % MODP
        else:
            B1[s1] = (B1[s1] + bj) % MODP
    _, pow_e, logv = build_log_tables(Q)
    def split_vec(V):
        v0 = V[0] % MODP
        nonzero_vec = [0] * M
        sumnz = 0
        for e in range(M):
            val = V[pow_e[e]] % MODP
            nonzero_vec[e] = val
            sumnz = (sumnz + val) % MODP
        return v0, sumnz, nonzero_vec
    A0_0, A0_sum_nz, A0_nz = split_vec(A0)
    A1_0, A1_sum_nz, A1_nz = split_vec(A1)
    B0_0, B0_sum_nz, B0_nz = split_vec(B0)
    B1_0, B1_sum_nz, B1_nz = split_vec(B1)
    C00 = cyclic_convolution_modP(A0_nz, B0_nz)
    C01 = cyclic_convolution_modP(A0_nz, B1_nz)
    C10 = cyclic_convolution_modP(A1_nz, B0_nz)
    C11 = cyclic_convolution_modP(A1_nz, B1_nz)
    H_even = [0] * Q
    H_odd = [0] * Q
    H_even[0] = (
        (A0_0 * ((B0_0 + B0_sum_nz) % MODP) + B0_0 * A0_sum_nz) % MODP
        + (A0_0 * ((B1_0 + B1_sum_nz) % MODP) + B1_0 * A0_sum_nz) % MODP
        + (A1_0 * ((B0_0 + B0_sum_nz) % MODP) + B0_0 * A1_sum_nz) % MODP
    ) % MODP
    H_odd[0] = (A1_0 * ((B1_0 + B1_sum_nz) % MODP) + B1_0 * A1_sum_nz) % MODP
    for t1 in range(1, Q):
        e = logv[t1]
        H_even[t1] = (C00[e] + C01[e] + C10[e]) % MODP
        H_odd[t1]  = C11[e] % MODP
    ans = 0
    for t1 in range(Q):
        if H_even[t1]:
            t_even = t1 if (t1 & 1) == 0 else t1 + Q
            ans = (ans + H_even[t1] * pow(c, t_even, MODP)) % MODP
        if H_odd[t1]:
            t_odd = t1 if (t1 & 1) == 1 else t1 + Q
            ans = (ans + H_odd[t1] * pow(c, t_odd, MODP)) % MODP
    return ans

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); c = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(m)]
    return n, m, c, a, b

def main():
    n, m, c, a, b = read_input()
    print(solve_case(a, b, c))

if __name__ == "__main__":
    # Light sanity tests
    assert solve_case([0,1],[0,1],3) == 3
    assert solve_case([1,1],[1,1],1) == 4
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count pairs by the multiplicative structure of exponents modulo $p-1$, then weight by $c^t$.}
\WHY{Combining CRT with NTT for multiplicative convolutions is a common trick in hard number-theoretic convolution problems.}
\CHECKLIST{
- Reduce exponents modulo $p-1$.
- Split $p-1=2\cdot Q$ via CRT and compute parity and modulo $Q$ residues.
- Separate zero residue modulo $Q$.
- Map multiplicative convolution over $\mathbb{Z}_Q^\times$ to additive cyclic convolution via discrete logs.
- Do four convolutions for the (even/odd)$\times$(even/odd) classes.
- Reassemble $t$ via CRT and sum $c^t$ with the counts.}
\EDGECASES{
- $c=1$ gives trivial sum $\left(\sum a_i\right)\left(\sum b_j\right)$.
- All $a_i=0$ or all $b_j=0$.
- Indices divisible by $Q$ contribute to residue $0$ modulo $Q$.
- Very small $n$ or $m$ (validate vs brute).
- Large values but sparse arrays (sanity check summations modulo $p$).
- Parity handling: ensure $j^3\bmod 2=j\bmod 2$.}
\PITFALLS{
- Forgetting to take exponents modulo $p-1$.
- Mishandling the zero residue modulo $Q$ in multiplicative convolution.
- Using a single NTT modulus and losing information; use CRT to combine modulo $p$.
- Incorrect primitive root for modulo $Q$; must test with factors of $Q-1$.
- Wrong CRT reconstruction for $t$; parity rule must be applied.
- Overflow concerns if attempting integer convolution; rely on modular NTT + CRT.}
\FAILMODES{Direct DFT of length $p-1$ is infeasible; naive pairwise sums time out. The proposed method avoids long DFT by exploiting structure and reduces to a few NTTs over power-of-two lengths.}
\ELI{Turn the double sum into a sum over exponent bins. Because multiplication modulo a prime splits nicely, we can crunch the heavy counting with FFT-like tools and then glue the answer back together.}
\NotePages{3}

\end{document}