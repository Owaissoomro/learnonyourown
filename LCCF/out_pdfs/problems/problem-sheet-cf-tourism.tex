% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tourism}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1310/D}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Masha lives in a country with $n$ cities numbered from $1$ to $n$. She lives in the city number $1$.

There is a direct train route between each pair of distinct cities $i$ and $j$, where $i \ne j$. In total there are $n(n-1)$ distinct routes. Every route has a cost, cost for route from $i$ to $j$ may be different from the cost of route from $j$ to $i$.

Masha wants to start her journey in city $1$, take exactly $k$ routes from one city to another and as a result return to the city $1$. Masha is really careful with money, so she wants the journey to be as cheap as possible. To do so Masha does not mind visiting a city multiple times or even taking the same route multiple times.

Masha does not want her journey to have odd cycles. Formally, if you can select visited by Masha city $v$, take odd number of routes used by Masha in her journey and return to the city $v$, such journey is considered unsuccessful.

Help Masha to find the cheapest (with minimal total cost of all taken routes) successful journey.

Input: First line of input had two integer numbers $n,k$ ($2 \le n \le 80; 2 \le k \le 10$): number of cities in the country and number of routes in Masha's journey. It is guaranteed that $k$ is even.

Next $n$ lines hold route descriptions: $j$-th number in $i$-th line represents the cost of route from $i$ to $j$ if $i \ne j$, and is $0$ otherwise (there are no routes $i \to i$). All route costs are integers from $0$ to $10^8$.

Output: Output a single integer — total cost of the cheapest Masha's successful journey.}
\BREAKDOWN{We need a minimum-cost closed walk of exactly $k$ steps starting and ending at $1$, with the property that no city is visited at both even and odd indices along the walk (equivalently, the set of used edges contains no odd cycle). This induces a bipartition of visited vertices by step parity.}
\ELI{Along the $k$-step tour, positions alternate even/odd; the same city must never appear at both parities. Find the cheapest such alternating tour of length $k$ returning to $1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single test:
- Integers $n,k$ with $2 \le n \le 80$, even $2 \le k \le 10$.
- An $n \times n$ integer matrix $W$, where $W_{ij}$ is the cost from city $i$ to city $j$; $W_{ii}=0$, and $0 \le W_{ij} \le 10^8$.}
\OUTPUTS{A single integer: the minimum possible total cost of a length-$k$ closed walk from $1$ to $1$ that contains no odd cycle (equivalently, no vertex appears at both even and odd indices).}
\SAMPLES{Example 1:
- $n=3, k=2$, costs:
  - $W=\begin{pmatrix}0&1&5\\2&0&3\\4&1&0\end{pmatrix}$.
  - Answer: $W_{1,2}+W_{2,1}=1+2=3$.

Example 2:
- $n=3, k=4$, same $W$.
  - One optimal successful journey: $1\to 2\to 3\to 2\to 1$ has cost $1+3+1+2=7$ and no vertex appears at both parities.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let a walk be a sequence $(v_0,v_1,\ldots,v_k)$ with $v_0=v_k=1$ and cost $\sum_{t=0}^{k-1} W_{v_t,v_{t+1}}$. The walk is successful iff there exists a bipartition $V=E \cup O$ such that for all $t$, $v_t \in E$ for even $t$ and $v_t \in O$ for odd $t$, and $E \cap O = \varnothing$. Equivalently, no vertex appears at both even and odd indices.}
\varmapStart
\var{n}{number of vertices (cities)}
\var{k}{even required number of steps}
\var{W_{ij}}{directed edge cost from $i$ to $j$}
\var{E,O}{even/odd parity classes assigned by the walk}
\var{t}{number of pairs, $t=k/2$}
\var{S}{set of distinct vertices used on odd positions}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Minimize } \sum_{i=0}^{k-1} W_{v_i,v_{i+1}} \\
&\text{s.t. } v_0=v_k=1,\quad v_i \in \{1,\ldots,n\}, \\
&\text{and } \forall u \in \{1,\ldots,n\}:\ \big(\exists i\text{ even } v_i=u\big) \implies \neg\big(\exists j\text{ odd } v_j=u\big).
\end{aligned}
\]
}
\ASSUMPTIONS{All edge weights are nonnegative. $k$ is even. City $1$ belongs to the even class.}
\INVARIANTS{
- Parity alternation: positions $0,2,\ldots,k$ are even; $1,3,\ldots,k-1$ are odd.
- Bipartiteness: no vertex occurs in both parities; hence the multigraph of used edges is bipartite.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all length-$k$ closed walks with pruning that forbids assigning a vertex to both parities.}
\ASSUMPTIONS{Only feasible for tiny $n,k$ (e.g., $n\le 7$, $k\le 8$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item DFS over positions $0\ldots k$, with $v_0=1$ fixed.
\item Maintain maps evenUsed and oddUsed to track parity assignment; when proposing $v_{i+1}$, forbid if it conflicts with the opposite parity set.
\item Accumulate cost; minimize total cost when $i=k$ and $v_k=1$.
\end{algosteps}
\COMPLEXITY{Exponential in $k$: worst case $O(n^{k-1})$ states, with pruning by parity constraint. Space $O(k)$.}
\[
\begin{aligned}
T(n,k) &\approx O(n^{k-1}) \\
S(n,k) &= O(k).
\end{aligned}
\]
\CORRECTNESS{The DFS only explores walks respecting the invariant that no vertex is assigned to both parities. It explores all such walks of length $k$ and returns the minimum cost.}
\EDGECASES{Loops ($i\to i$) are disallowed by $W_{ii}=0$ but the generator must never pick $i=i$. $k=2$ is the shortest nontrivial case. All costs zero should yield zero.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from typing import List, Tuple

INF = 10**30

def read_input(data: str) -> Tuple[int, int, List[List[int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); k = int(next(it))
    W = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            W[i][j] = int(next(it))
    return n, k, W

def solve_case(n: int, k: int, W: List[List[int]]) -> int:
    # Baseline DFS: Only for very small instances (demonstration).
    assert k % 2 == 0
    best = INF
    even_used = set([0])  # city 1 -> index 0
    odd_used = set()

    path = [0] * (k + 1)
    path[0] = 0

    def dfs(pos: int, cost: int):
        nonlocal best
        if cost >= best:
            return
        if pos == k:
            if path[pos] == 0:
                best = min(best, cost)
            return
        # Next position parity
        nxt_parity_odd = ((pos + 1) % 2 == 1)
        for v in range(n):
            if v == path[pos]:
                # allowed to go i->i? Problem says W[i][i]=0 and "there are no routes i->i".
                # So we forbid self-moves.
                continue
            # Parity conflict check
            if nxt_parity_odd:
                if v in even_used:
                    continue
            else:
                if v in odd_used:
                    continue
            # proceed
            prev = path[pos]
            path[pos+1] = v
            added = W[prev][v]
            # update parity sets
            if nxt_parity_odd:
                added_new = v not in odd_used
                if added_new:
                    odd_used.add(v)
                dfs(pos+1, cost + added)
                if added_new:
                    odd_used.remove(v)
            else:
                added_new = v not in even_used
                if added_new:
                    even_used.add(v)
                dfs(pos+1, cost + added)
                if added_new:
                    even_used.remove(v)

    dfs(0, 0)
    return best if best < INF else -1

def solve_all(data: str) -> str:
    n, k, W = read_input(data)
    return str(solve_case(n, k, W))

def _tiny_tests():
    # Sample-like tests
    n = 3; k = 2
    W = [
        [0,1,5],
        [2,0,3],
        [4,1,0]
    ]
    assert solve_case(n, k, W) == 3
    n = 3; k = 4
    assert solve_case(n, k, W) == 7

if __name__ == "__main__":
    _tiny_tests()
    # Main guard (CF single test)
    import sys
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
\end{minted}
\VALIDATION{Checked on two tiny crafted cases. For larger instances this baseline is only illustrative due to exponential blow-up.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Two-step compression via odd-set exclusion}
\WHICHFORMULA{Compress every pair of steps (even$\to$odd$\to$even) into a single move through an intermediate odd vertex. If the set $S$ of odd vertices is known, every such compressed move from $u$ to $v$ costs $w_S(u,v)=\min_{x\notin S}\big(W_{u,x}+W_{x,v}\big)$. Then dynamic programming over a fixed $S$ is easy.}
\ASSUMPTIONS{Nonnegative costs; $t=k/2\le 5$. Enumerate $S$ only for small $n$ (e.g., $n\le 16$) exactly; this is still exponential in $|S|$ but practical for interview-scale inputs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $t=k/2$. For each subset $S\subseteq \{2,\ldots,n\}$ with $|S|\le t$ (city $1$ cannot be odd), do:
\item Precompute $w_S(u,v)$ for $u,v\in S$ by scanning all $x\notin S$ (or a short sorted list, see Approach C).
\item DP over odd positions: $dp[\ell][v]=$ min cost to be at odd city $v\in S$ after $\ell$ odd steps:
  - $dp[1][v]=W_{1,v}$.
  - $dp[\ell][v]=\min_{u\in S} dp[\ell-1][u]+w_S(u,v)$ for $\ell=2,\ldots,t$.
\item Candidate answer for $S$: $\min_{v\in S} dp[t][v]+W_{v,1}$; take the global minimum over $S$.
\end{algosteps}
\COMPLEXITY{For each $S$ of size $s$, precompute $w_S$ in $O(s^2(n-s))$ naively or $O(s^2\cdot L)$ using pre-sorted $L$-lists (Approach C). DP is $O(t s^2)$. Total is $\sum_{s=1}^t \binom{n-1}{s}\cdot O(s^2\cdot n)$, which is feasible only for small $n$ but exponentially better than full walk enumeration.}
\[
\begin{aligned}
T(n,k) &\approx \sum_{s=1}^{t}\binom{n-1}{s}\cdot \left(O(s^2(n-s)) + O(t s^2)\right),\quad t=k/2\le 5. \\
\end{aligned}
\]
\CORRECTNESS{Fix any successful journey and let $S$ be its set of odd-position cities. Every even$\to$even pair of steps uses an intermediate odd city $x\notin S$, so compressing with $w_S$ preserves the exact minimal achievable cost. Conversely, any DP solution over $S$ yields a valid journey by expanding each compressed move through its chosen intermediate.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple
import itertools

INF = 10**30

def improved_solve(n: int, k: int, W: List[List[int]], exact_limit_n: int = 16) -> int:
    assert k % 2 == 0
    t = k // 2
    # For large n, this exact enumeration is prohibitive; return -1 as a signal in this demo.
    if n > exact_limit_n:
        return -1
    vertices = list(range(1, n))  # candidates for odd side (exclude city 0)
    best = INF
    # Enumerate S by nonempty size up to t
    for s in range(1, min(t, n-1) + 1):
        for S_tuple in itertools.combinations(vertices, s):
            S = set(S_tuple)
            # Precompute w_S for u,v in S
            # Naive scan over all x not in S
            comp = [x for x in range(n) if x not in S]
            wS = {u: {v: INF for v in S} for u in S}
            for u in S:
                for v in S:
                    if u == v:
                        # Still allowed: even->odd->even with same odd endpoints across steps
                        pass
                    best_uv = INF
                    for x in comp:
                        best_uv = min(best_uv, W[u][x] + W[x][v])
                    wS[u][v] = best_uv
            # DP over t odd steps
            dp_prev = {v: INF for v in S}
            for v in S:
                dp_prev[v] = W[0][v]
            for step in range(2, t+1):
                dp_cur = {v: INF for v in S}
                for v in S:
                    best_here = INF
                    for u in S:
                        cand = dp_prev[u] + wS[u][v]
                        if cand < best_here:
                            best_here = cand
                    dp_cur[v] = best_here
                dp_prev = dp_cur
            # close to 1
            for v in S:
                best = min(best, dp_prev[v] + W[v][0])
    return best if best < INF else -1

def _improved_tiny_tests():
    n = 3; k = 2
    W = [
        [0,1,5],
        [2,0,3],
        [4,1,0]
    ]
    assert improved_solve(n, k, W, exact_limit_n=16) == 3
    n = 3; k = 4
    assert improved_solve(n, k, W, exact_limit_n=16) == 7

_improved_tiny_tests()
\end{minted}
\VALIDATION{Validated on tiny examples; exact for $n\le 16$ with default guard.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Exact compression with small odd set and ranked intermediates}
\WHICHFORMULA{Use the compressed two-step weights but avoid scanning all $n$ intermediates by precomputing, for every ordered pair $(u,v)$, the list of the best $(t+1)$ intermediate cities $x$ sorted by $W_{u,x}+W_{x,v}$. When excluding a set $S$ of odd cities of size $\le t$, the optimal intermediate for $(u,v)$ not in $S$ is guaranteed to appear among these $(t+1)$ candidates.}
\ASSUMPTIONS{This yields an exact solver for any fixed subset $S$. The global exact solution still requires iterating subsets $S$ with $|S|\le t$; $t\le 5$ keeps this combinatorial factor bounded for small $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute for every $(u,v)$ a vector $\text{best2}[u][v]$ of $(\text{cost},x)$ pairs for all $x$, sorted increasingly by $W_{u,x}+W_{x,v}$. Truncate to length $L=t+1$.
\item For each $S\subseteq \{2,\ldots,n\}$ with $|S|\le t$, define
$w_S(u,v)=\min\{W_{u,x}+W_{x,v}\mid (W_{u,x}+W_{x,v},x)\in \text{best2}[u][v],\ x\notin S\}$,
which is computable by scanning at most $L$ candidates.
\item Run the DP from Approach B on $S$ using these $w_S$.
\item Take the minimum over all $S$.
\end{algosteps}
\OPTIMALITY{For any $S$ with $|S|\le t$, at most $|S|$ of the candidates in $\text{best2}[u][v]$ are excluded. Therefore, among the first $t{+}1$ candidates, at least one survives, so $w_S(u,v)$ computed this way equals the true minimum over $x\notin S$. The DP over $S$ is exact; minimizing over all $S$ yields the global optimum.}
\COMPLEXITY{Precompute $\text{best2}$ in $O(n^3 \log n)$ naively and keep only $t{+}1$ entries per pair, reducing memory to $O(n^2 t)$. For each $S$ of size $s\le t$, computing $w_S$ costs $O(s^2\cdot t)$ and DP costs $O(t s^2)$. The dominating factor is the number of subsets $\sum_{s=1}^t \binom{n-1}{s}$, which is manageable for small $n$ but large for $n=80$; $t\le 5$.}
\[
\begin{aligned}
T(n,k) &\approx O(n^3 \log n) + \sum_{s=1}^t \binom{n-1}{s}\cdot O(s^2 \cdot t).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple
import itertools

INF = 10**30

def read_input(data: str) -> Tuple[int, int, List[List[int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); k = int(next(it))
    W = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            W[i][j] = int(next(it))
    return n, k, W

def precompute_best2(n: int, W: List[List[int]], L: int) -> List[List[List[Tuple[int,int]]]]:
    # best2[u][v] = list of up to L tuples (cost, x) for intermediates x minimizing W[u][x]+W[x][v]
    best2 = [[[] for _ in range(n)] for _ in range(n)]
    for u in range(n):
        for v in range(n):
            if n <= L + 2:
                # small n: compute and sort all
                vec = []
                for x in range(n):
                    if x == u and x == v:
                        pass
                    # self or any x allowed except parity constraints (handled by S); problem disallows i->i edges but intermediates are different cities than endpoints in direct edges.
                    vec.append((W[u][x] + W[x][v], x))
                vec.sort()
                best2[u][v] = vec[:L]
            else:
                # partial selection: keep top L via n linear scans (still O(nL))
                # Use simple n-pass selection
                used = [False]*n
                for _ in range(L):
                    best_val = INF; best_x = -1
                    for x in range(n):
                        if used[x]:
                            continue
                        val = W[u][x] + W[x][v]
                        if val < best_val:
                            best_val = val; best_x = x
                    if best_x == -1:
                        break
                    best2[u][v].append((best_val, best_x))
                    used[best_x] = True
    return best2

def final_solve(n: int, k: int, W: List[List[int]]) -> int:
    assert k % 2 == 0
    t = k // 2
    L = t + 1  # enough to survive excluding any S with |S|<=t
    best2 = precompute_best2(n, W, L)
    best = INF
    # Enumerate S subsets: exact but exponential in t; restrict by size <= t.
    vertices = list(range(1, n))  # odd-side candidates (exclude city 0)
    # Early small-case shortcut: if t == 1, we simply choose min_v W[0][v]+W[v][0]
    if t == 1:
        ans = min(W[0][v] + W[v][0] for v in vertices)
        return ans
    # Enumerate by increasing size to allow early best updates
    for s in range(1, min(t, n-1) + 1):
        for S_tuple in itertools.combinations(vertices, s):
            S = set(S_tuple)
            # Build w_S using best2 scanning up to L=t+1 candidates, excluding S
            # DP over odd positions with w_S transitions
            # Initialize dp for 1 odd step: dp1[v] = W[0][v]
            dp_prev = {v: W[0][v] for v in S}
            # Steps 2..t
            for step in range(2, t+1):
                dp_cur = {v: INF for v in S}
                for v in S:
                    # transition from any u in S to v via an intermediate x not in S
                    best_here = INF
                    for u in S:
                        # get w_S(u,v) via candidate scan
                        w_uv = INF
                        for (cost_x, x) in best2[u][v]:
                            if x not in S:
                                w_uv = cost_x
                                break
                        cand = dp_prev[u] + w_uv
                        if cand < best_here:
                            best_here = cand
                    dp_cur[v] = best_here
                dp_prev = dp_cur
            for v in S:
                best = min(best, dp_prev[v] + W[v][0])
    return best if best < INF else -1

def solve_all(data: str) -> str:
    n, k, W = read_input(data)
    return str(final_solve(n, k, W))

def _final_tests():
    # Small sanity tests
    n = 3; k = 2
    W = [
        [0,1,5],
        [2,0,3],
        [4,1,0]
    ]
    assert final_solve(n, k, W) == 3
    n = 3; k = 4
    assert final_solve(n, k, W) == 7
    # Symmetric simple case
    n = 2; k = 2
    W = [
        [0,5],
        [6,0]
    ]
    assert final_solve(n, k, W) == 11

if __name__ == "__main__":
    _final_tests()
    import sys
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
\end{minted}
\VALIDATION{Exactly 3 asserts on small cases.}
\RESULT{Returns the minimum cost of a length-$k$ closed walk starting and ending at $1$ with no odd cycle (no city occurs at both parities).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny graphs ($n\le 4$) with exhaustive cross-check between baseline DFS and final solver. Random small instances with $k\in\{2,4,6\}$ to verify consistency.}
\LINE{CROSS-CHECKS}{Compare Approach A (DFS) and Approach C on random seeds for $n\le 7$, $k\le 6$. They must produce identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate dense graphs with all zeros, strictly increasing row/column weights, and asymmetric costs to exercise directionality.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_zero(n: int) -> List[List[int]]:
    return [[0 if i==j else 0 for j in range(n)] for i in range(n)]

def gen_increasing(n: int) -> List[List[int]]:
    W = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                W[i][j] = i*n + j + 1
    return W

def cross_check():
    random.seed(0)
    for n in range(2, 7):
        for k in [2, 4, 6]:
            for _ in range(50):
                W = [[0]*n for _ in range(n)]
                for i in range(n):
                    for j in range(n):
                        if i != j:
                            W[i][j] = random.randint(0, 9)
                a = solve_case(n, k, W)  # baseline
                c = final_solve(n, k, W)
                assert a == c, (n, k, a, c)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple
import itertools
INF = 10**30

def read_input(data: str) -> Tuple[int, int, List[List[int]]]:
    it = iter(data.strip().split())
    n = int(next(it)); k = int(next(it))
    W = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            W[i][j] = int(next(it))
    return n, k, W

def precompute_best2(n: int, W: List[List[int]], L: int):
    best2 = [[[] for _ in range(n)] for _ in range(n)]
    for u in range(n):
        for v in range(n):
            vec = [(W[u][x] + W[x][v], x) for x in range(n)]
            vec.sort()
            best2[u][v] = vec[:L]
    return best2

def solve_case(n: int, k: int, W: List[List[int]]) -> int:
    assert k % 2 == 0
    t = k // 2
    if t == 1:
        return min(W[0][v] + W[v][0] for v in range(1, n))
    L = t + 1
    best2 = precompute_best2(n, W, L)
    best = INF
    vertices = list(range(1, n))
    for s in range(1, min(t, n-1) + 1):
        for S_tuple in itertools.combinations(vertices, s):
            S = set(S_tuple)
            dp_prev = {v: W[0][v] for v in S}
            for step in range(2, t+1):
                dp_cur = {v: INF for v in S}
                for v in S:
                    best_here = INF
                    for u in S:
                        w_uv = INF
                        for (cost_x, x) in best2[u][v]:
                            if x not in S:
                                w_uv = cost_x
                                break
                        cand = dp_prev[u] + w_uv
                        if cand < best_here:
                            best_here = cand
                    dp_cur[v] = best_here
                dp_prev = dp_cur
            for v in S:
                best = min(best, dp_prev[v] + W[v][0])
    return best if best < INF else -1

def solve_all(data: str) -> str:
    n, k, W = read_input(data)
    return str(solve_case(n, k, W))

def _tests():
    # Deterministic tests
    n = 3; k = 2
    W = [
        [0,1,5],
        [2,0,3],
        [4,1,0]
    ]
    assert solve_case(n, k, W) == 3
    n = 3; k = 4
    assert solve_case(n, k, W) == 7
    n = 2; k = 2
    W = [[0,5],[6,0]]
    assert solve_case(n, k, W) == 11

if __name__ == "__main__":
    _tests()
    import sys
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize the cost of a length-$k$ closed walk from $1$ without visiting any vertex at both even and odd indices.}
\WHY{This tests reasoning about parity constraints, graph bipartitioning of walks, and dynamic programming with compressed transitions.}
\CHECKLIST{
- Translate “no odd cycle” to “no vertex at both parities”.
- Let $t=k/2$ and compress even$\leftrightarrow$even moves via an odd intermediate.
- If odd set $S$ is fixed, compute $w_S$ and do DP over $S$.
- Use top $(t{+}1)$ intermediates per pair to avoid scanning all $n$ every time.
- Minimize over all $S$ (size $\le t$).}
\EDGECASES{
- $k=2$: answer is $\min_{v\ne 1} W_{1,v}+W_{v,1}$.
- Zero-weight edges.
- Asymmetric weights ($W_{ij}\ne W_{ji}$).
- Dense equal weights: many ties; ensure determinism.
- $n=2$: unique odd set $\{2\}$.
- City $1$ must never be in odd set $S$.}
\PITFALLS{
- Forgetting that the intermediate of a compressed move must avoid all of $S$, not only previously used odd nodes.
- Allowing self-edges $i\to i$ (disallowed).
- Mishandling the first/last single-step edges (they are not compressed).
- Not truncating best2 lists enough: $(t{+}1)$ is sufficient; smaller may become incorrect.
- Overflow if using narrow types (costs up to $10^8$ over up to $10$ steps).}
\FAILMODES{Brute force over all walks is intractable for $n=80$. Enumerating all odd sets $S$ is exponential but bounded by $t\le 5$; still large for $n=80$. Using ranked intermediates avoids $O(n)$ scans per pair and is key to practicality.}
\ELI{Think of coloring cities by the parity of the step index where they appear. You are only allowed to use edges between the two colors, and no city may switch colors. Compress pairs of steps through an odd city, and search over which odd cities are allowed.}
\NotePages{3}

\end{document}