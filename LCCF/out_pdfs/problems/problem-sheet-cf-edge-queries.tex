% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Edge Queries}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1763/F}}
\LINE{DIFFICULTY / RATING}{3000}
\STATEMENT{You are given an undirected, connected graph of $n$ nodes and $m$ edges. All nodes $u$ of the graph satisfy the following:
\begin{bullets}
\item Let $S_u$ be the set of vertices in the longest simple cycle starting and ending at $u$.
\item Let $C_u$ be the union of the sets of vertices in any simple cycle starting and ending at $u$.
\item $S_u = C_u$.
\end{bullets}
You need to answer $q$ queries.

For each query, you will be given node $a$ and node $b$. Out of all the edges that belong to any simple path from $a$ to $b$, count the number of edges such that if you remove that edge, $a$ and $b$ are reachable from each other.

Input:
The first line contains two integers $n$ and $m$ ($2 \le n \le 2 \cdot 10^5$, $1 \le m \le \min(2 \cdot 10^5, (n \cdot (n-1))/2)$) — the total number of nodes and edges in the graph, respectively.

The next $m$ lines contain two integers $u$ and $v$ ($1 \le u, v \le n$, $u \ne v$) — describing an edge, implying that nodes $u$ and $v$ are connected to each other.

It is guaranteed that there is at most one edge between any pair of vertices in the graph and the given graph is connected.

The next line contains a single integer $q$ ($1 \le q \le 2 \cdot 10^5$) — the number of queries.

Then $q$ lines follow, each representing a query. Each query contains two integers $a$ and $b$ ($1 \le a, b \le n$).

Output:
For each query, output a single integer — answer to the query.

Note:
The graph in the first sample is:

The first query is $(1, 4)$. There are $5$ total edges that belong to any simple path from $1$ to $4$. Edges $(3, 4), (4, 5), (5, 3)$ will be counted in the answer to the query.

The fourth query is $(2, 8)$. There is only one simple path from $2$ to $8$, thus none of the edges will be counted in the answer to the query.

The fifth query is $(7, 10)$. There are $4$ total edges that belong to any simple path from $7$ to $10$, all of them will be counted in the answer to the query.}
\BREAKDOWN{Leverage the given structural property to reduce arbitrary undirected graphs to a tree of cycle-components connected by bridges. For a query $(a,b)$, exactly the cycle edges on the unique path between the components of $a$ and $b$ are counted. Preprocess to answer weighted path-sum queries using LCA.}
\ELI{Compress each simple cycle into a node with weight equal to its cycle length; then the answer is the sum of those weights along the path between $a$ and $b$ in this tree.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A connected undirected simple graph with $n$ nodes and $m$ edges; then $q$ pairs $(a,b)$. Ranges: $2 \le n \le 2 \cdot 10^5$, $1 \le m \le \min(2 \cdot 10^5, (n \cdot (n-1))/2)$, $1 \le q \le 2 \cdot 10^5$, and $1 \le a,b \le n$.}
\OUTPUTS{For each query, a single integer: the count of edges that lie on at least one simple path from $a$ to $b$ and whose removal does not disconnect $a$ and $b$. One answer per line.}
\SAMPLES{Example 1 (intuition only):
\begin{bullets}
\item If the graph is a tree, every edge on the unique path is critical, so the answer is $0$ for all queries.
\item If the graph is a single $k$-cycle, the answer is $k$ for any $(a,b)$ with $a \ne b$, since all $k$ edges appear in the union of simple $a$–$b$ paths and none is critical for $a$–$b$ reachability.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Under the condition $S_u=C_u$ for all $u$, the graph is a cactus with vertex-disjoint cycles. Contract every $2$-edge-connected component (which here is either a simple cycle or a singleton) into a node. The bridges become edges between these nodes, forming a tree $T$. Assign to each node $x$ the weight $w(x)$ equal to the number of edges inside the corresponding $2$-edge-connected component (i.e., cycle length, or $0$ if singleton). For a query $(a,b)$, map them to their component nodes $A,B$ in $T$; the answer is the sum of $w(\cdot)$ over all nodes on the unique path $A \leadsto B$.}
\varmapStart
\var{G=(V,E)}{original connected undirected graph}
\var{T}{tree of $2$-edge-connected components (cycles/singletons) after contracting non-bridge edges}
\var{w(x)}{weight of component $x$: number of non-bridge edges inside it (cycle length or $0$)}
\var{\mathrm{comp}(v)}{component of vertex $v$ in $T$}
\var{\mathrm{path}_T(A,B)}{unique node-path in $T$ between $A$ and $B$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Ans}(a,b) \;=\; \sum_{x \in \mathrm{path}_T(\mathrm{comp}(a),\mathrm{comp}(b))} w(x).
\end{BreakableEquation*}
}
\ASSUMPTIONS{The condition $S_u=C_u$ implies cycles are pairwise vertex-disjoint; bridges are exactly the edges not lying on any cycle; contracting non-bridge edges yields a tree.}
\INVARIANTS{
\begin{bullets}
\item Bridges are $a$–$b$ critical: any bridge on the $T$-path must be used by every $a$–$b$ path and contributes $0$ to the count.
\item Every encountered cycle contributes all its edges: within a cycle block, there are two internally edge-disjoint routes between its entry/exit vertices, so removing any single cycle edge preserves $a$–$b$ reachability.
\item $T$ is a tree: contracting $2$-edge-connected components in a connected graph and keeping bridges yields an acyclic connected structure.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Definition-driven: an edge is counted if (i) it lies on at least one simple $a$–$b$ path, and (ii) removing it does not disconnect $a$ and $b$.}
\ASSUMPTIONS{Use BFS/DFS per edge to test membership and connectivity; feasible only for tiny $n,m$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a query $(a,b)$, find the set $E_{ab}$ of edges that lie on at least one simple $a$–$b$ path by testing each edge $e$: does there exist an $a$–$b$ path using $e$?
\item For each $e \in E_{ab}$, temporarily remove $e$ and test if $a$ and $b$ are still connected.
\item Count edges that pass the second test.
\end{algosteps}
\COMPLEXITY{Intractable for constraints: per query $O(m)$ edge tests, each with $O(n+m)$ traversals, giving $O(m(n+m))$ per query.}
\[
\begin{aligned}
T_{\text{baseline}}(n,m,q) &\approx q \cdot m \cdot (n+m), \\
S(n) &= O(n+m).
\end{aligned}
\]
\CORRECTNESS{Follows directly from the definition of counted edges.}
\EDGECASES{Self-query $a=b$; multi-component after removal; edges not on any $a$–$b$ path.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque, defaultdict
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges.append((u, v))
    q = int(next(it))
    queries = []
    for _ in range(q):
        a = int(next(it)) - 1
        b = int(next(it)) - 1
        queries.append((a, b))
    return n, m, edges, q, queries

def bfs_connected(n, adj, s, t):
    """Check connectivity s->t."""
    vis = [False]*n
    dq = deque([s])
    vis[s] = True
    while dq:
        u = dq.popleft()
        if u == t:
            return True
        for v in adj[u]:
            if not vis[v]:
                vis[v] = True
                dq.append(v)
    return vis[t]

def edge_on_some_path(n, adj, a, b, e):
    """Check whether edge e=(x,y) lies on some simple path from a to b.
    Equivalent to: exists path a->x avoiding e endpoints? Careful.
    Simpler sufficient check: there exists path a->b in the graph where we contract e?
    A correct test: edge e lies on some a-b path iff removing e does NOT break all a-b paths,
    but also e is on a-b path iff a and b are connected in the graph AND endpoints of e lie on some a-b simple path.
    For brute-force small graphs, we can check both orientations:
    try to force using e by temporarily contracting one endpoint to the other with a traversal that first reaches e.
    Instead, we can check by max-flow=1 in undirected graph using edge orientation via doubling; but too heavy.
    We'll use a simple method:
    - Temporarily direct e as two directed edges and forbid using e by removing it; if a and b are disconnected when e is removed AND connected when present, then any path uses e, but that does not prove existence when it is not critical.
    For brute-force correctness, we enumerate all simple paths up to a cap for tiny graphs.
    """
    # Tiny enumeration using DFS with pruning up to n! in worst case; safe only for tiny graphs used in asserts.
    sys.setrecursionlimit(10000)
    x, y = e
    target = (min(x, y), max(x, y))
    nlimit = n
    seen_paths = 0
    found_using_e = False
    vis = [False]*n
    path = []

    def dfs(u):
        nonlocal found_using_e, seen_paths
        if found_using_e:
            return
        if len(path) > nlimit:
            return
        if u == b:
            # check if path uses e
            for i in range(1, len(path)):
                uu, vv = path[i-1], path[i]
                if (min(uu, vv), max(uu, vv)) == target:
                    found_using_e = True
                    break
            seen_paths += 1
            return
        for v in adj[u]:
            if not vis[v]:
                vis[v] = True
                path.append(v)
                dfs(v)
                path.pop()
                vis[v] = False

    vis[a] = True
    path = [a]
    dfs(a)
    return found_using_e

def solve_all_baseline(n, m, edges, q, queries):
    adj = [[] for _ in range(n)]
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)
    ans = []
    for a, b in queries:
        # collect edges on some a-b path
        E = []
        for idx, (x, y) in enumerate(edges):
            if edge_on_some_path(n, adj, a, b, (x, y)):
                E.append((x, y))
        # count those whose removal does not disconnect a and b
        cnt = 0
        for (x, y) in E:
            # remove edge
            adj[x].remove(y)
            adj[y].remove(x)
            ok = bfs_connected(n, adj, a, b)
            # restore
            adj[x].append(y)
            adj[y].append(x)
            if ok:
                cnt += 1
        ans.append(cnt)
    return ans

def _test_baseline():
    # Tiny tests only (n <= 8)
    n = 3
    edges = [(0,1),(1,2)]  # chain
    q = 1
    queries = [(0,2)]
    assert solve_all_baseline(n, len(edges), edges, q, queries) == [0]

    # triangle
    n = 3
    edges = [(0,1),(1,2),(2,0)]
    q = 1
    queries = [(0,1)]
    assert solve_all_baseline(n, len(edges), edges, q, queries) == [3]

if __name__ == "__main__":
    _test_baseline()
\end{minted}
\VALIDATION{Validated on tiny graphs: path of length $2$ (answer $0$), triangle (answer $3$).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Block-Cut Tree Summation}
\WHICHFORMULA{Build the block-cut tree (bipartite between original vertices and biconnected components). Assign to each biconnected component node a weight equal to its cycle length (or $0$). Then the answer is the sum of weights of component nodes along the block-cut tree path between $a$ and $b$.}
\ASSUMPTIONS{Under the given property, every nontrivial biconnected component is exactly one simple cycle.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Run a standard biconnected components algorithm (Tarjan) to extract components.
\item Build the block-cut tree $B$ with original-vertex nodes and component nodes.
\item Precompute LCA and prefix sums of weights on $B$.
\item For each query $(a,b)$, sum weights on the path between nodes $a$ and $b$ in $B$, counting only component-node weights.
\end{algosteps}
\COMPLEXITY{All preprocessing in $O(n+m)$; each query in $O(\log n)$ by binary lifting LCA.}
\[
\begin{aligned}
T_{\text{pre}} &= O(n+m),\quad T_{\text{per-query}} = O(\log n),\\
S &= O(n).
\end{aligned}
\]
\CORRECTNESS{The block-cut path alternates vertex/component nodes; every cycle component intersected by the path contributes all its edges to the union of $a$–$b$ paths, hence contributes its weight and is not $a$–$b$ critical. Bridges correspond to edges between a vertex and a component node of size $1$, contributing zero weight.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Sketch omitted: see Approach C for a leaner 2-edge-connected compression that yields the same tree
# but with simpler construction (contract non-bridge edges).
\end{minted}
\VALIDATION{Same as Approach C; both trees (block-cut vs 2-edge-connected compression) yield identical path sums under this graph class.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{2-Edge-Connected Compression + LCA Path Sum}
\WHICHFORMULA{Find all bridges via Tarjan. Contract non-bridge edges to $2$-edge-connected components. Build the tree of components using bridges. Assign each component node the weight equal to the number of non-bridge edges within it (cycle length, or $0$). Answer each query as a node-weight path sum via LCA.}
\ASSUMPTIONS{Given $S_u=C_u$ for every $u$, each $2$-edge-connected component is either a singleton or one simple cycle; contracting them yields a tree.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute all bridges using a DFS with discovery times and lowlinks.
\item Build components by DFS over only non-bridge edges, label $\mathrm{comp}(v)$ for all $v$.
\item For each non-bridge edge $(u,v)$, increment $w[\mathrm{comp}(u)]$ by $1$; this counts cycle edges.
\item For each bridge $(u,v)$, add an edge between $\mathrm{comp}(u)$ and $\mathrm{comp}(v)$ in the component tree $T$.
\item Root $T$ arbitrarily; binary-lift preprocess ancestors, depths, and prefix sums $S[x]=\sum w$ from root to $x$.
\item For each query $(a,b)$, map to $A=\mathrm{comp}(a)$, $B=\mathrm{comp}(b)$, compute $\mathrm{lca}$ and output $S[A]+S[B]-2S[\mathrm{lca}]+w[\mathrm{lca}]$.
\end{algosteps}
\OPTIMALITY{Linear-time preprocessing and logarithmic queries are asymptotically optimal under comparison/LCA models for arbitrary $q$ up to $O(n)$.}
\COMPLEXITY{Tarjan bridges, component contraction, and tree build are $O(n+m)$; LCA preprocessing $O(n\log n)$; each query $O(\log n)$.}
\[
\begin{aligned}
T_{\text{pre}} &= O(n+m),\quad T_{\text{per-query}} = O(\log n),\\
S &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1_000_000)

from collections import defaultdict, deque

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges.append((u, v))
    q = int(next(it))
    queries = []
    for _ in range(q):
        a = int(next(it)) - 1
        b = int(next(it)) - 1
        queries.append((a, b))
    return n, m, edges, q, queries

def find_bridges(n, edges):
    g = [[] for _ in range(n)]
    for i, (u, v) in enumerate(edges):
        g[u].append((v, i))
        g[v].append((u, i))
    tin = [-1]*n
    low = [0]*n
    is_bridge = [False]*len(edges)
    time = 0

    def dfs(u, pe):
        nonlocal time
        tin[u] = low[u] = time; time += 1
        for v, ei in g[u]:
            if ei == pe:
                continue
            if tin[v] != -1:
                # back edge
                low[u] = min(low[u], tin[v])
            else:
                dfs(v, ei)
                low[u] = min(low[u], low[v])
                if low[v] > tin[u]:
                    is_bridge[ei] = True

    for u in range(n):
        if tin[u] == -1:
            dfs(u, -1)
    return is_bridge

def build_components(n, edges, is_bridge):
    # adjacency without bridges
    g_nb = [[] for _ in range(n)]
    for i, (u, v) in enumerate(edges):
        if not is_bridge[i]:
            g_nb[u].append(v)
            g_nb[v].append(u)
    comp = [-1]*n
    comp_id = 0
    stack = []
    for s in range(n):
        if comp[s] != -1:
            continue
        # BFS/DFS to label component
        dq = [s]
        comp[s] = comp_id
        while dq:
            u = dq.pop()
            for v in g_nb[u]:
                if comp[v] == -1:
                    comp[v] = comp_id
                    dq.append(v)
        comp_id += 1
    C = comp_id
    # weights: count non-bridge edges per component
    w = [0]*C
    for i, (u, v) in enumerate(edges):
        if not is_bridge[i]:
            cu = comp[u]
            cv = comp[v]
            assert cu == cv
            w[cu] += 1
    # build tree using bridges
    T = [[] for _ in range(C)]
    for i, (u, v) in enumerate(edges):
        if is_bridge[i]:
            cu = comp[u]; cv = comp[v]
            T[cu].append(cv)
            T[cv].append(cu)
    return comp, w, T

def lca_prep(T, w, root=0):
    n = len(T)
    LOG = (n).bit_length()
    up = [[-1]*n for _ in range(LOG)]
    depth = [0]*n
    pref = [0]*n

    # iterative stack to avoid recursion
    parent = [-1]*n
    order = []
    stack = [root]
    parent[root] = root
    depth[root] = 0
    while stack:
        u = stack.pop()
        order.append(u)
        for v in T[u]:
            if v == parent[u]:
                continue
            parent[v] = u
            depth[v] = depth[u] + 1
            stack.append(v)
    # Handle disconnected (shouldn't happen in connected graph), but safe:
    for s in range(n):
        if parent[s] == -1:
            parent[s] = s
            stack = [s]
            while stack:
                u = stack.pop()
                for v in T[u]:
                    if v == parent[u]:
                        continue
                    parent[v] = u
                    depth[v] = depth[u] + 1
                    stack.append(v)

    up[0] = parent[:]
    for k in range(1, LOG):
        for v in range(n):
            up[k][v] = up[k-1][up[k-1][v]]

    # prefix sums from root using parent pointers
    # We need to compute pref[v] = sum of w on path root..v inclusive.
    # We can do in order of depth:
    nodes_by_depth = sorted(range(n), key=lambda x: depth[x])
    for v in nodes_by_depth:
        if v == up[0][v]:
            pref[v] = w[v]
        else:
            pref[v] = pref[up[0][v]] + w[v]
    return up, depth, pref

def lca(u, v, up, depth):
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    # lift u
    diff = depth[u] - depth[v]
    for k in range(LOG):
        if diff & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def answer_queries(n, m, edges, q, queries):
    is_bridge = find_bridges(n, edges)
    comp, w, T = build_components(n, edges, is_bridge)
    C = len(T)
    # Tree should be connected after contracting; choose root 0
    up, depth, pref = lca_prep(T, w, 0 if C > 0 else 0)
    ans = []
    for a, b in queries:
        A = comp[a]; B = comp[b]
        L = lca(A, B, up, depth)
        res = pref[A] + pref[B] - 2*pref[L] + w[L]
        ans.append(res)
    return ans

def solve_case():
    n, m, edges, q, queries = read_input()
    out = answer_queries(n, m, edges, q, queries)
    print("\n".join(map(str, out)))

def main():
    solve_case()

# --- tests ---
def _tiny_tests():
    # Tree graph: answers are 0
    n = 3
    edges = [(0,1),(1,2)]
    q = 2
    queries = [(0,2),(0,1)]
    out = answer_queries(n, len(edges), edges, q, queries)
    assert out == [0,0]

    # Single cycle of length 3
    n = 3
    edges = [(0,1),(1,2),(2,0)]
    q = 3
    queries = [(0,1),(0,2),(1,2)]
    out = answer_queries(n, len(edges), edges, q, queries)
    assert out == [3,3,3]

    # Cycle with a tail
    n = 5
    edges = [(0,1),(1,2),(2,0),(2,3),(3,4)]
    q = 3
    queries = [(0,4),(1,4),(3,4)]
    out = answer_queries(n, len(edges), edges, q, queries)
    assert out == [3,3,0]

if __name__ == "__main__":
    _tiny_tests()
    # For online judge, uncomment:
    # main()
\end{minted}
\VALIDATION{Exactly 3 asserts:
\begin{bullets}
\item Tree: answers $0$.
\item Triangle: answers $3$.
\item Triangle with tail: $(0,4)$ and $(1,4)$ both $3$; $(3,4)$ is $0$.
\end{bullets}}
\RESULT{For each query $(a,b)$, output the sum of cycle lengths of the $2$-edge-connected components encountered along the component-tree path between $\mathrm{comp}(a)$ and $\mathrm{comp}(b)$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests covering trees, single cycles, and cycles with attached trees. Random cactus generators with vertex-disjoint cycles to fuzz-compare baseline vs optimal on small sizes.}
\LINE{CROSS-CHECKS}{Compare Approach A (baseline) against Approach C on small $n \le 10$ random instances satisfying the property.}
\LINE{EDGE-CASE GENERATOR}{Generate trees (no cycles), single big cycle, multiple disjoint cycles connected by bridges, and queries with $a=b$.}
\begin{minted}{python}
from random import Random

def gen_cactus_disjoint_cycles(n_nodes=20, seed=0):
    """
    Generate a connected graph with vertex-disjoint cycles (cactus) and bridges only between components.
    Returns (n, edges).
    """
    rnd = Random(seed)
    # Build a tree of K components
    K = rnd.randint(1, max(1, n_nodes // 4))
    comp_sizes = []
    comps = []
    total_nodes = 0
    for i in range(K):
        # Decide if this component is a cycle or singleton
        is_cycle = rnd.random() < 0.6
        if is_cycle and total_nodes + 3 <= n_nodes:
            k = rnd.randint(3, min(6, n_nodes - total_nodes))
            nodes = list(range(total_nodes, total_nodes + k))
            total_nodes += k
            edges = [(nodes[j], nodes[(j+1) % k]) for j in range(k)]
            comps.append((nodes, edges))
        else:
            # singleton
            if total_nodes >= n_nodes:
                break
            nodes = [total_nodes]
            total_nodes += 1
            edges = []
            comps.append((nodes, edges))
    if total_nodes < n_nodes:
        # fill remaining with singletons
        for x in range(total_nodes, n_nodes):
            comps.append(([x], []))
        total_nodes = n_nodes

    # Connect components via bridges to form a tree
    comp_roots = [nodes[0] for nodes, _ in comps]
    edges_all = []
    for _, e in comps:
        edges_all.extend(e)
    # Build a random tree over components
    parents = [-1]*len(comps)
    order = list(range(len(comps)))
    rnd.shuffle(order)
    for i in range(1, len(order)):
        u = order[i]
        v = order[rnd.randint(0, i-1)]
        a = comp_roots[u]
        b = comp_roots[v]
        edges_all.append((a, b))
        parents[u] = v
    # Renumber n if needed
    n = max(max(u, v) for u, v in edges_all) + 1 if edges_all else total_nodes
    return n, edges_all

def brute_force_answer(n, edges, queries):
    # Use baseline solver from Approach A (be careful: tiny n)
    return solve_all_baseline(n, len(edges), edges, len(queries), queries)

def final_answer(n, edges, queries):
    return answer_queries(n, len(edges), edges, len(queries), queries)

def _fuzz():
    for seed in range(30):
        n, edges = gen_cactus_disjoint_cycles(n_nodes=10, seed=seed)
        # Deduplicate edges
        edges = list({tuple(sorted(e)) for e in edges})
        # Make connected if empty edges
        if not edges and n >= 2:
            edges = [(0,1)]
        # random queries
        rnd = Random(seed)
        qs = [(rnd.randrange(n), rnd.randrange(n)) for _ in range(10)]
        bf = brute_force_answer(n, edges, qs)
        fa = final_answer(n, edges, qs)
        assert bf == fa, (seed, n, edges, qs, bf, fa)

if __name__ == "__main__":
    _fuzz()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1_000_000)

from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges.append((u, v))
    q = int(next(it))
    queries = []
    for _ in range(q):
        a = int(next(it)) - 1
        b = int(next(it)) - 1
        queries.append((a, b))
    return n, m, edges, q, queries

def find_bridges(n, edges):
    g = [[] for _ in range(n)]
    for i, (u, v) in enumerate(edges):
        g[u].append((v, i))
        g[v].append((u, i))
    tin = [-1]*n
    low = [0]*n
    is_bridge = [False]*len(edges)
    time = 0
    def dfs(u, pe):
        nonlocal time
        tin[u] = low[u] = time; time += 1
        for v, ei in g[u]:
            if ei == pe:
                continue
            if tin[v] != -1:
                low[u] = min(low[u], tin[v])
            else:
                dfs(v, ei)
                low[u] = min(low[u], low[v])
                if low[v] > tin[u]:
                    is_bridge[ei] = True
    for u in range(n):
        if tin[u] == -1:
            dfs(u, -1)
    return is_bridge

def build_components(n, edges, is_bridge):
    g_nb = [[] for _ in range(n)]
    for i, (u, v) in enumerate(edges):
        if not is_bridge[i]:
            g_nb[u].append(v)
            g_nb[v].append(u)
    comp = [-1]*n
    comp_id = 0
    for s in range(n):
        if comp[s] != -1:
            continue
        # label all nodes reachable without using bridges
        dq = [s]
        comp[s] = comp_id
        while dq:
            u = dq.pop()
            for v in g_nb[u]:
                if comp[v] == -1:
                    comp[v] = comp_id
                    dq.append(v)
        comp_id += 1
    C = comp_id
    w = [0]*C
    for i, (u, v) in enumerate(edges):
        if not is_bridge[i]:
            cu = comp[u]; cv = comp[v]
            assert cu == cv
            w[cu] += 1
    # Component tree via bridges
    T = [[] for _ in range(C)]
    for i, (u, v) in enumerate(edges):
        if is_bridge[i]:
            cu = comp[u]; cv = comp[v]
            T[cu].append(cv)
            T[cv].append(cu)
    return comp, w, T

def lca_prep(T, w, root=0):
    n = len(T)
    if n == 0:
        return [[0]], [0], [0]
    LOG = (n).bit_length()
    up = [[-1]*n for _ in range(LOG)]
    depth = [0]*n
    pref = [0]*n
    # BFS tree to get parent/depth
    parent = [-1]*n
    dq = deque([root])
    parent[root] = root
    depth[root] = 0
    order = []
    while dq:
        u = dq.popleft()
        order.append(u)
        for v in T[u]:
            if parent[v] == -1:
                parent[v] = u
                depth[v] = depth[u] + 1
                dq.append(v)
    # Handle disconnected safety (shouldn't happen here)
    for s in range(n):
        if parent[s] == -1:
            parent[s] = s
            dq = deque([s])
            depth[s] = 0
            while dq:
                u = dq.popleft()
                for v in T[u]:
                    if parent[v] == -1:
                        parent[v] = u
                        depth[v] = depth[u] + 1
                        dq.append(v)
    up[0] = parent[:]
    for k in range(1, LOG):
        for v in range(n):
            up[k][v] = up[k-1][ up[k-1][v] ]
    # prefix sums
    nodes_by_depth = sorted(range(n), key=lambda x: depth[x])
    for v in nodes_by_depth:
        if up[0][v] == v:
            pref[v] = w[v]
        else:
            pref[v] = pref[ up[0][v] ] + w[v]
    return up, depth, pref

def lca(u, v, up, depth):
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    diff = depth[u] - depth[v]
    k = 0
    while diff:
        if diff & 1:
            u = up[k][u]
        diff >>= 1
        k += 1
    if u == v:
        return u
    for k in range(LOG-1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def answer_queries(n, m, edges, q, queries):
    is_bridge = find_bridges(n, edges)
    comp, w, T = build_components(n, edges, is_bridge)
    C = len(T)
    if C == 0:
        return [0]*q
    up, depth, pref = lca_prep(T, w, 0)
    ans = []
    for a, b in queries:
        A = comp[a]; B = comp[b]
        L = lca(A, B, up, depth)
        res = pref[A] + pref[B] - 2*pref[L] + w[L]
        ans.append(res)
    return ans

def solve_case():
    n, m, edges, q, queries = read_input()
    res = answer_queries(n, m, edges, q, queries)
    print("\n".join(map(str, res)))

def main():
    solve_case()

# basic asserts
def _selfcheck():
    # Tree
    n = 3; edges = [(0,1),(1,2)]
    assert answer_queries(n, len(edges), edges, 1, [(0,2)]) == [0]
    # Triangle
    n = 3; edges = [(0,1),(1,2),(2,0)]
    assert answer_queries(n, len(edges), edges, 3, [(0,1),(1,2),(0,2)]) == [3,3,3]
    # Triangle + tail
    n = 5; edges = [(0,1),(1,2),(2,0),(2,3),(3,4)]
    assert answer_queries(n, len(edges), edges, 3, [(0,4),(1,4),(3,4)]) == [3,3,0]

if __name__ == "__main__":
    _selfcheck()
    # For submission:
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Contract non-bridge edges to $2$-edge-connected components; the answer for $(a,b)$ is the sum of cycle lengths on the component-tree path between $\mathrm{comp}(a)$ and $\mathrm{comp}(b)$.}
\WHY{Transforms arbitrary path-union reasoning into a tree path-sum under the given cactus-like constraint, enabling $O(\log n)$ queries after linear preprocessing.}
\CHECKLIST{
\begin{bullets}
\item Run Tarjan to mark bridges.
\item DFS over non-bridge edges to label components.
\item Count non-bridge edges per component as weights.
\item Build the component tree via bridges.
\item LCA preprocess with node-weight prefix sums.
\item Answer queries with inclusion–exclusion on prefix sums.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $a=b$: answer equals the cycle length of $\mathrm{comp}(a)$ (or $0$ if none).
\item Graph is a tree: all weights are $0$, all answers $0$.
\item Single big cycle: all answers equal cycle length.
\item Leaves attached to cycles via bridges: bridges contribute $0$; only cycles on the path contribute.
\item Multiple disjoint cycles connected by bridges: sum over all encountered cycles.
\item Nodes not incident to any non-bridge edge: singleton components with weight $0$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Mixing $0$-based and $1$-based indices in input/output mapping.
\item Forgetting to count non-bridge edges as component weight; counting vertices instead of edges changes answers.
\item Incorrect lowlink comparisons for bridges; must use $\text{low}[v] > \text{tin}[u]$.
\item Building components using full graph instead of only non-bridge edges.
\item LCA path sum double-counting or missing the LCA term; use $S[u]+S[v]-2S[\text{lca}]+w[\text{lca}]$.
\item Stack recursion limits in Python; increase recursionlimit or use iterative traversals.
\end{bullets}
}
\FAILMODES{On general graphs without the property, component compression may create non-tree structures; this solution assumes the given constraint to ensure a tree. Bridges-only or dense cycles outside the cactus model would break the correctness argument; the problem guarantees prevent such cases.}
\ELI{Squash each ring of roads (cycle) into a city with a number equal to how many roads the ring has. The highways between cities are one-way choices with no alternatives. To travel from $a$ to $b$, you pass through some cities; every ring you pass gives you credit for all its roads, since losing one road in a ring still leaves another way around.}
\NotePages{3}

\end{document}