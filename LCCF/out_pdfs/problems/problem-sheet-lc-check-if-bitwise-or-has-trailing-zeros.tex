% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Check if Bitwise OR Has Trailing Zeros}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/check-if-bitwise-or-has-trailing-zeros/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given an array of \textbf{positive} integers \texttt{nums}. You have to check if it is possible to select \textbf{two or more} elements in the array such that the bitwise \texttt{OR} of the selected elements has \textbf{at least} one trailing zero in its binary representation. For example, the binary representation of \texttt{5}, which is \texttt{"101"}, does not have any trailing zeros, whereas the binary representation of \texttt{4}, which is \texttt{"100"}, has two trailing zeros. Return \texttt{true} \emph{if it is possible to select two or more elements whose bitwise} \texttt{OR} \emph{has trailing zeros, return} \texttt{false} \emph{otherwise}.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{nums = [1,2,3,4,5]} \\
\quad \textbf{Output:} \texttt{true} \\
\quad \textbf{Explanation:} If we select the elements \texttt{2} and \texttt{4}, their bitwise OR is \texttt{6}, which has the binary representation \texttt{"110"} with one trailing zero.

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{nums = [2,4,8,16]} \\
\quad \textbf{Output:} \texttt{true} \\
\quad \textbf{Explanation:} If we select the elements \texttt{2} and \texttt{4}, their bitwise OR is \texttt{6}, which has the binary representation \texttt{"110"} with one trailing zero. Other possible ways to select elements to have trailing zeroes in the binary representation of their bitwise OR are: \texttt{(2, 8)}, \texttt{(2, 16)}, \texttt{(4, 8)}, \texttt{(4, 16)}, \texttt{(8, 16)}, \texttt{(2, 4, 8)}, \texttt{(2, 4, 16)}, \texttt{(2, 8, 16)}, \texttt{(4, 8, 16)}, and \texttt{(2, 4, 8, 16)}.

\textbf{Example 3:}

\quad \textbf{Input:} \texttt{nums = [1,3,5,7,9]} \\
\quad \textbf{Output:} \texttt{false} \\
\quad \textbf{Explanation:} There is no possible way to select two or more elements to have trailing zeros in the binary representation of their bitwise OR.

\textbf{Constraints:}
\begin{itemize}
\item \texttt{2 <= nums.length <= 100}
\item \texttt{1 <= nums[i] <= 100}
\end{itemize}
}
\BREAKDOWN{We need to determine whether there exists a subset of size at least two whose bitwise OR is even (has at least one trailing zero). Observing that the least significant bit of an OR is 0 iff all contributing numbers have least significant bit 0, the problem reduces to checking whether there are at least two even numbers in the array.}
\ELI{An OR ends with 0 only if every chosen number ends with 0 in binary, so the answer is true exactly when the array has at least two even numbers.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Array \texttt{nums} of integers with \texttt{2 \le nums.length \le 100} and \texttt{1 \le nums[i] \le 100}.}
\OUTPUTS{Return a boolean: \texttt{true} if there exist at least two indices \texttt{i != j} such that \texttt{(nums[i] | nums[j])} is even; equivalently, if there are at least two even numbers in \texttt{nums}. Return \texttt{false} otherwise.}
\SAMPLES{\textbf{Sample A:} \texttt{nums = [1,2,3,4,5]} $\rightarrow$ \texttt{true}. \\
\textbf{Sample B:} \texttt{nums = [1,3,5,7,9]} $\rightarrow$ \texttt{false}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=\{a_1,\ldots,a_n\}$ be the multiset of inputs. We ask whether there exists a subset $S \subseteq \{1,\ldots,n\}$ with $|S|\ge 2$ such that $\bigl(\bigvee_{i\in S} a_i\bigr)$ has at least one trailing zero, i.e., is even.}
\varmapStart
\var{A}{multiset of given positive integers}
\var{S}{index subset of selected elements}
\var{\vee}{bitwise OR over integers}
\var{v\_2(x)}{the exponent of $2$ in $x$ (number of trailing zeros in binary), with $v\_2(0)=\infty$ by convention but not needed here}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\exists S \subseteq \{1,\ldots,n\}:\ |S|\ge 2\ \wedge\ \left(\bigvee_{i\in S} a_i\right)\equiv 0 \pmod{2}.
\end{BreakableEquation*}
Equivalently,
\begin{BreakableEquation*}
\exists S:\ |S|\ge 2\ \wedge\ \forall i\in S:\ a_i \equiv 0 \pmod{2}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{All $a_i$ are positive integers. Standard bitwise semantics apply. Subset selection must include at least two elements.}
\INVARIANTS{If any selected element is odd, the OR is odd; conversely, an OR is even iff all included elements are even. Therefore, feasibility is equivalent to the existence of at least two even elements in the input.}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Check all unordered pairs and compute their OR; if any pair has an even OR, return true. This directly matches the definition while avoiding exponential subset enumeration.}
\ASSUMPTIONS{Pairwise suffices because an OR is even iff every participating number is even; the existence of a valid subset implies the existence of a valid pair among its elements.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate over all pairs $(i,j)$ with $0\le i<j<n$.
\item Compute $x = \texttt{nums}[i]\ \texttt{|}\ \texttt{nums}[j]$ and check $x \bmod 2 = 0$.
\item If any such pair exists, return true; otherwise, return false.
\end{algosteps}
\COMPLEXITY{There are $\tfrac{n(n-1)}{2}$ pairs and each check is $O(1)$.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(\binom{n}{2}\right) = \Theta(n^2),\\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{If a valid subset exists, choose any two of its elements; their OR is still even, so a valid pair exists. Conversely, a valid pair immediately certifies feasibility.}
\EDGECASES{Arrays with fewer than two even numbers cannot satisfy the condition; arrays with at least two even numbers always do.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def hasTrailingZeros(self, nums: List[int]) -> bool:
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if ((nums[i] | nums[j]) & 1) == 0:
                    return True
        return False

# Baseline checks
s = Solution()
assert s.hasTrailingZeros([1, 2, 3, 4, 5]) is True
assert s.hasTrailingZeros([2, 4, 8, 16]) is True
assert s.hasTrailingZeros([1, 3, 5, 7, 9]) is False
\end{minted}
\VALIDATION{Manually verify with samples and small crafted cases: all-odd array; exactly one even; exactly two evens.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Parity Counting}
\WHICHFORMULA{An OR is even iff all operands are even. Hence, counting even numbers suffices: answer is true iff the count of even elements is at least two.}
\ASSUMPTIONS{Standard parity properties; no other bit positions matter for having at least one trailing zero.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan the array and count elements with $\texttt{num} \bmod 2 = 0$.
\item Return true iff the count is at least $2$.
\end{algosteps}
\COMPLEXITY{Single pass, constant space.}
\[
\begin{aligned}
T(n) &= \Theta(n), \\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Necessary: if fewer than two evens exist, any subset of size $\ge 2$ contains an odd, making the OR odd. Sufficient: if at least two evens exist, selecting any two yields an even OR.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def hasTrailingZeros(self, nums: List[int]) -> bool:
        evens = sum((x & 1) == 0 for x in nums)
        return evens >= 2

# Improved checks
s = Solution()
assert s.hasTrailingZeros([1, 2, 3, 4, 5]) is True
assert s.hasTrailingZeros([2, 4, 8, 16]) is True
assert s.hasTrailingZeros([1, 3, 5, 7, 9]) is False
\end{minted}
\VALIDATION{Edge verification: [2,2] is true; [2,3] is false; large arrays with many evens are true.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-Pass Early-Exit Count}
\WHICHFORMULA{Keep a small counter of even numbers and early-exit once it reaches two. This is optimal under the decision-tree model for parity-based certification.}
\ASSUMPTIONS{Same as Approach B; we only need to detect the second even.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $c=0$.
\item For each $x$ in \texttt{nums}, if $x$ is even, increment $c$; if $c=2$, return true.
\item After the loop, return false.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must inspect at least two even elements in the worst case to return true, and must inspect all elements when there are fewer than two evens to return false. This method attains these bounds up to constant factors.}
\COMPLEXITY{Worst-case $\Theta(n)$ time and $\Theta(1)$ space; best-case $O(1)$ time if the first two elements are even.}
\[
\begin{aligned}
T(n) &= \Theta(n)\ \text{worst-case}, \\
S(n) &= \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def hasTrailingZeros(self, nums: List[int]) -> bool:
        c = 0
        for x in nums:
            if (x & 1) == 0:
                c += 1
                if c == 2:
                    return True
        return False

# Final asserts (exactly 3)
s = Solution()
assert s.hasTrailingZeros([1, 2, 3, 4, 5]) is True
assert s.hasTrailingZeros([2, 4, 8, 16]) is True
assert s.hasTrailingZeros([1, 3, 5, 7, 9]) is False
\end{minted}
\VALIDATION{The three asserts cover mixed parity, all-even, and all-odd arrays.}
\RESULT{Return \texttt{true} iff at least two even numbers exist in \texttt{nums}; otherwise return \texttt{false}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on representative cases: all odd; one even; two evens; many evens; mixed; boundary sizes. Property test: cross-check pairwise-OR baseline vs final method on a deterministic corpus.}
\LINE{CROSS-CHECKS}{For each test array, compare the $O(n^2)$ pairwise-OR outcome with the $O(n)$ even-count outcome; they must match.}
\LINE{EDGE-CASE GENERATOR}{Generate deterministic arrays hitting boundaries: smallest length $2$, largest values $100$, patterns like alternating parity, all same parity, exactly one even.}
\begin{minted}{python}
from typing import List

def baseline_pair_or(nums: List[int]) -> bool:
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if ((nums[i] | nums[j]) & 1) == 0:
                return True
    return False

def final_even_count(nums: List[int]) -> bool:
    ev = 0
    for x in nums:
        if (x & 1) == 0:
            ev += 1
            if ev == 2:
                return True
    return False

def deterministic_cases():
    cases = []
    # Smallest arrays
    cases.append([1, 1])          # all odd -> False
    cases.append([2, 2])          # two evens -> True
    cases.append([2, 3])          # one even -> False
    # Mixed
    cases.append([1, 2, 3, 4, 5]) # True
    cases.append([1, 3, 5, 7, 9]) # False
    cases.append([2, 4, 8, 16])   # True
    # Alternating parity
    cases.append([1, 2, 1, 2, 1, 2])
    # Larger with boundary values
    cases.append([100, 99, 98, 97, 96, 95, 94])
    cases.append([1, 100])
    cases.append([3, 5, 7, 9, 11, 13, 15, 17])
    return cases

for arr in deterministic_cases():
    assert baseline_pair_or(arr) == final_even_count(arr)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def hasTrailingZeros(self, nums: List[int]) -> bool:
        evens = 0
        for x in nums:
            if (x & 1) == 0:
                evens += 1
                if evens == 2:
                    return True
        return False

# Reference asserts
s = Solution()
assert s.hasTrailingZeros([1, 2, 3, 4, 5]) is True
assert s.hasTrailingZeros([2, 4, 8, 16]) is True
assert s.hasTrailingZeros([1, 3, 5, 7, 9]) is False
assert s.hasTrailingZeros([2, 3]) is False
assert s.hasTrailingZeros([2, 2]) is True
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Answer is true iff there are at least two even numbers in the array.}
\WHY{This problem tests recognition that the least significant bit of a bitwise OR is 0 only when all operands have that bit 0, i.e., all are even.}
\CHECKLIST{%
\begin{bullets}
\item Scan and count evens.
\item Early exit on the second even.
\item Return false otherwise.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item Exactly two elements, both odd: false.
\item Exactly two elements, both even: true.
\item Exactly one even in the entire array: false.
\item Many evens: true.
\item Presence of large values like 100 does not matter beyond parity.
\item Mixed parity with evens far apart: still true if there are at least two.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Misinterpreting ``trailing zeros'' as requiring more than one zero; at least one zero means even.
\item Thinking that adding an odd to an even set can keep OR even; it flips LSB to 1.
\item Overcomplicating with full subset enumeration for $n$ up to 100.
\item Forgetting the subset must have size at least two; a single even is insufficient.
\item Using multiplication or addition instead of bitwise OR.
\item Ignoring early exit, causing unnecessary work.
\end{bullets}
}
\FAILMODES{%
\begin{bullets}
\item Brute-force over all subsets will time out conceptually for large $n$; counting parity avoids this.
\item Pairwise-only implementations that check OR parity but mishandle bounds or indices may miss cases; the parity-count is simpler and safer.
\end{bullets}
}
\ELI{The OR of numbers ends with 0 only if every number you picked ends with 0 in binary. So you just need to see whether there are at least two even numbers in the list. If yes, pick any two of them and you are done.}
\NotePages{3}

\end{document}