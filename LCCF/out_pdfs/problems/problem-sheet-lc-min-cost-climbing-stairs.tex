% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Min Cost Climbing Stairs}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/min-cost-climbing-stairs/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given an integer array \texttt{cost} where \texttt{cost[i]} is the cost of \texttt{ith} step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index \texttt{0}, or the step with index \texttt{1}. Return the minimum cost to reach the top of the floor.

Example 1:

Input: \texttt{cost = [10,\_15\_ ,20]}
Output: \texttt{15}
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.

Example 2:

Input: \texttt{cost = [\_1\_ ,100,\_1\_ ,1,\_1\_ ,100,\_1\_ ,\_1\_ ,100,\_1\_]}
Output: \texttt{6}
Explanation: You will start at index 0.
- Pay 1 and climb two steps to reach index 2.
- Pay 1 and climb two steps to reach index 4.
- Pay 1 and climb two steps to reach index 6.
- Pay 1 and climb one step to reach index 7.
- Pay 1 and climb two steps to reach index 9.
- Pay 1 and climb one step to reach the top.
The total cost is 6.

Constraints:
- \texttt{2 \le cost.length \le 1000}
- \texttt{0 \le cost[i] \le 999}}
\BREAKDOWN{Model the problem as a shortest-path on a linear graph or as a dynamic program where from each step you may come from the previous or the one before. Choose starting point 0 or 1 to minimize total cost and compute the minimal payment to reach the virtual top.}
\ELI{To reach the top cheaply, always add the current step cost to the cheaper of the two ways you could have arrived there.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{cost} of integers with length $n$ such that $2 \le n \le 1000$ and $0 \le \texttt{cost[i]} \le 999$.}
\OUTPUTS{A single integer: the minimum total cost to reach just beyond the last step (the top), starting at index 0 or 1.}
\SAMPLES{Example A: \texttt{cost=[10,15,20]} $\to$ \texttt{15}. Example B: \texttt{cost=[1,100,1,1,1,100,1,1,100,1]} $\to$ \texttt{6}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let steps be indexed $0,\ldots,n-1$ with a virtual top at index $n$. From $i$ you may move to $i+1$ or $i+2$ while paying $\texttt{cost}[i]$ when you stand on $i$. We seek the minimum total cost to reach $n$ starting from $0$ or $1$.}
\varmapStart
\var{n}{number of steps; $n = \lvert \texttt{cost} \rvert$}
\var{c_i}{the given nonnegative cost of step $i$}
\var{dp[i]}{minimum cost to reach step $i$ (to land on $i$), for $i\in\{0,\ldots,n-1\}$}
\var{\text{ans}}{minimum cost to reach the top $n$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
dp[0] &= c_0,\\
dp[1] &= c_1,\\
dp[i] &= c_i + \min\{dp[i-1],\,dp[i-2]\}\quad \text{for } i\ge 2,\\
\text{ans} &= \min\{dp[n-1],\,dp[n-2]\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are zero-based; $n\ge 2$. Costs are nonnegative so optimal substructure holds. The top is a virtual node $n$ that is reachable from $n-1$ or $n-2$ without additional cost.}
\INVARIANTS{For each $i$, $dp[i]$ equals the minimal cost of any sequence of moves that lands exactly on $i$. Because transitions only depend on the previous two steps, the recurrence is valid and yields optimality by induction.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all paths by recursion: from index $i$ the cost to finish is $c_i$ plus the minimum of the recursive costs from $i+1$ and $i+2$. Answer is $\min\{\text{solve}(0),\text{solve}(1)\}$.}
\ASSUMPTIONS{Use plain recursion without memoization; exponential time but simple and correct for small $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define \texttt{solve(i)} that returns minimum cost to reach top starting at step $i$.
\item Base case: if $i \ge n$, cost is $0$ (already at or past top).
\item Recursive case: pay \texttt{cost[i]} plus $\min(\texttt{solve}(i+1),\texttt{solve}(i+2))$. Return $\min(\texttt{solve}(0),\texttt{solve}(1))$.
\end{algosteps}
\COMPLEXITY{Exponential time $T(n)=\Theta(\varphi^n)$ in the worst case, space $S(n)=\Theta(n)$ from recursion depth.}
\[
\begin{aligned}
T(n) &= T(n-1)+T(n-2)+O(1) \\
     &= \Theta(\varphi^n).
\end{aligned}
\]
\CORRECTNESS{The recursion explores all valid paths from starting indices 0 and 1 and takes the minimum accumulated cost, so by exhaustive enumeration it is correct.}
\EDGECASES{$n=2$; all zeros; strictly increasing or decreasing costs; ties handled naturally by \texttt{min}.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        def solve(i: int) -> int:
            if i >= n:
                return 0
            return cost[i] + min(solve(i + 1), solve(i + 2))
        return min(solve(0), solve(1))

# Baseline sanity checks (small to avoid exponential blow-up)
if __name__ == "__main__":
    s = Solution()
    assert s.minCostClimbingStairs([10, 15, 20]) == 15
    assert s.minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1]) == 6
    assert s.minCostClimbingStairs([0,0]) == 0
\end{minted}
\VALIDATION{Verified on the two official examples and a trivial zero-cost case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Bottom-Up Dynamic Programming Array}
\WHICHFORMULA{Use the DP recurrence to fill an array \texttt{dp} iteratively; answer is $\min(dp[n-1], dp[n-2])$.}
\ASSUMPTIONS{Iterative computation from base cases upward; costs are nonnegative but this method also works for arbitrary integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{dp[0]=cost[0]}, \texttt{dp[1]=cost[1]}.
\item For $i=2$ to $n-1$, set \texttt{dp[i] = cost[i] + min(dp[i-1], dp[i-2])}.
\item Return \texttt{min(dp[n-1], dp[n-2])}.
\end{algosteps}
\COMPLEXITY{Runs in linear time $O(n)$ and linear extra space $O(n)$ for the \texttt{dp} array, improving drastically over the exponential baseline.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n) = O(n).
\end{aligned}
\]
\CORRECTNESS{By induction on $i$, \texttt{dp[i]} stores the minimal cost to land on step $i$ using only valid transitions. The final step to the top does not add cost, so the minimum of the last two entries is optimal.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        dp = [0] * n
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2, n):
            dp[i] = cost[i] + min(dp[i - 1], dp[i - 2])
        return min(dp[n - 1], dp[n - 2])

# Improved approach checks
if __name__ == "__main__":
    s = Solution()
    assert s.minCostClimbingStairs([10, 15, 20]) == 15
    assert s.minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1]) == 6
    assert s.minCostClimbingStairs([0,2,2,1]) == 2
\end{minted}
\VALIDATION{Checked two official examples and a small crafted case where best path alternates.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Space-Optimized Bottom-Up (Two Variables)}
\WHICHFORMULA{Only the previous two DP states are needed; keep rolling variables \texttt{a} and \texttt{b} for $dp[i-2]$ and $dp[i-1]$.}
\ASSUMPTIONS{Same DP recurrence; overwrite space as we progress.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{a = cost[0]}, \texttt{b = cost[1]}.
\item For $i=2$ to $n-1$, compute \texttt{c = cost[i] + min(a, b)}, then shift: \texttt{a=b}, \texttt{b=c}.
\item Return \texttt{min(a, b)}.
\end{algosteps}
\OPTIMALITY{This achieves optimal $O(n)$ time and $O(1)$ extra space; a linear-time lower bound follows from needing to read all inputs.}
\COMPLEXITY{Time $O(n)$, extra space $O(1)$.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n) = O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        a = cost[0]
        b = cost[1]
        for i in range(2, n):
            a, b = b, cost[i] + min(a, b)
        return min(a, b)

# Exactly 3 asserts (mini-tests)
if __name__ == "__main__":
    s = Solution()
    assert s.minCostClimbingStairs([10, 15, 20]) == 15
    assert s.minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1]) == 6
    assert s.minCostClimbingStairs([0,0,0,0]) == 0
\end{minted}
\VALIDATION{Three asserts: both official examples and an all-zero case.}
\RESULT{Return the minimal total cost as an integer; when there are ties, any equivalent path yields the same numeric result.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on edge sizes ($n=2$), all zeros, alternating low/high costs, random arrays; property: optimal result from C equals B (and equals memoized A on small $n$).}
\LINE{CROSS-CHECKS}{Compare outputs of baseline on small inputs vs improved and optimal on the same inputs.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with zeros, ones, and large values to probe transitions; include strictly increasing and decreasing sequences.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_cases() -> List[List[int]]:
    cases = []
    cases.append([0, 0])
    cases.append([10, 15, 20])
    cases.append([1,100,1,1,1,100,1,1,100,1])
    cases.append([0,2,2,1])
    cases.append([5,5,5,5,5,5])
    cases.append([0,0,0,0,0])
    cases.append([999,0,999,0,999,0,999,0])
    # increasing and decreasing
    cases.append(list(range(2, 12)))
    cases.append(list(range(20, 10, -1)))
    # random but deterministic
    rnd = random.Random(0)
    for n in range(2, 21):
        arr = [rnd.randrange(0, 20) for _ in range(n)]
        cases.append(arr)
    return cases

def solve_A(cost: List[int]) -> int:
    # memoized variant to keep it fast for testing
    from functools import lru_cache
    n = len(cost)
    @lru_cache(maxsize=None)
    def f(i: int) -> int:
        if i >= n:
            return 0
        return cost[i] + min(f(i+1), f(i+2))
    return min(f(0), f(1))

def solve_B(cost: List[int]) -> int:
    n = len(cost)
    dp = [0]*n
    dp[0] = cost[0]
    dp[1] = cost[1]
    for i in range(2, n):
        dp[i] = cost[i] + min(dp[i-1], dp[i-2])
    return min(dp[n-1], dp[n-2])

def solve_C(cost: List[int]) -> int:
    a = cost[0]
    b = cost[1]
    for i in range(2, len(cost)):
        a, b = b, cost[i] + min(a, b)
    return min(a, b)

if __name__ == "__main__":
    for arr in gen_cases():
        x = solve_B(arr)
        y = solve_C(arr)
        assert x == y, (arr, x, y)
        z = solve_A(arr[:10]) if len(arr) > 10 else solve_A(arr)  # limit size for A
        assert x == z, (arr[:10], x, z)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        a = cost[0]
        b = cost[1]
        for i in range(2, len(cost)):
            a, b = b, cost[i] + min(a, b)
        return min(a, b)

if __name__ == "__main__":
    s = Solution()
    assert s.minCostClimbingStairs([10, 15, 20]) == 15
    assert s.minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1]) == 6
    assert s.minCostClimbingStairs([0,0]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute minimal cumulative cost with a two-term DP recurrence; answer is the min of the last two DP states.}
\WHY{Classic DP warm-up; tests grasp of state definition, transitions, and space optimization.}
\CHECKLIST{%
- Define state precisely (cost to land on step $i$).
- Set base cases for $i=0,1$.
- Use recurrence $dp[i]=c_i+\min(dp[i-1],dp[i-2])$.
- Return $\min(dp[n-1],dp[n-2])$, not $dp[n-1]$.
- Consider $n=2$ and zero costs.
}
\EDGECASES{%
- $n=2$ minimal length.
- All zeros.
- Single nonzero among zeros.
- Large equal costs.
- Alternating low/high costs.
- Leading zeros.
- Very large $n$ within limits.
- Costs with plateaus and cliffs.
}
\PITFALLS{%
- Returning $dp[n-1]$ instead of $\min(dp[n-1],dp[n-2])$.
- Off-by-one when initializing base cases.
- Forgetting that you do not pay at the top.
- Using recursion without memoization on large $n$ causing timeouts.
- Overflow is not an issue in Python, but in other languages use sufficient width.
- Misinterpreting \textquotedblleft start at 0 or 1\textquotedblright{} as an extra zero step cost.
}
\FAILMODES{Greedy choices based only on immediate costs can fail; e.g., locally cheap step may lead to expensive next. The DP method survives because it evaluates both predecessors.}
\ELI{Keep the cheaper bill to reach each step and always add the current step price to that. In the end, the cheaper of reaching the last or second last step gets you to the top.}
\NotePages{3}

\end{document}