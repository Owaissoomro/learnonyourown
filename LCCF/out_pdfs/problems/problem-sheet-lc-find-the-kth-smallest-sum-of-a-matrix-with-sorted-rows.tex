% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find the Kth Smallest Sum of a Matrix With Sorted Rows}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an $m \times n$ matrix \texttt{mat} that has its rows sorted in non-decreasing order and an integer $k$. You are allowed to choose exactly one element from each row to form an array. Return the $k$th smallest array sum among all possible arrays.

Example 1:

Input: \texttt{mat = [[1,3,11],[2,4,6]], k = 5}

Output: \texttt{7}

Explanation: Choosing one element from each row, the first $k$ smallest sums are:
\texttt{[1,2]}, \texttt{[1,4]}, \texttt{[3,2]}, \texttt{[3,4]}, \texttt{[1,6]}. The 5th sum is 7.

Example 2:

Input: \texttt{mat = [[1,3,11],[2,4,6]], k = 9}

Output: \texttt{17}

Example 3:

Input: \texttt{mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7}

Output: \texttt{9}

Explanation: Choosing one element from each row, the first $k$ smallest sums are:
\texttt{[1,1,2]}, \texttt{[1,1,3]}, \texttt{[1,4,2]}, \texttt{[1,4,3]}, \texttt{[1,1,6]}, \texttt{[1,5,2]}, \texttt{[1,5,3]}. The 7th sum is 9.

Constraints:
\begin{bullets}
\item $m = \texttt{len(mat)}$.
\item $n = \texttt{len(mat[i])}$ for every valid $i$.
\item $1 \le m, n \le 40$.
\item $1 \le \texttt{mat[i][j]} \le 5000$.
\item $1 \le k \le \min(200, m n)$.
\item Each \texttt{mat[i]} is a non-decreasing array.
\end{bullets}}
\BREAKDOWN{Reduce to combining rows while keeping only the globally $k$ smallest partial sums. Treat merging two sorted lists of values via their pairwise sums and truncate to the best $k$, then iterate across all rows.}
\ELI{Keep only the best $k$ sums so far and merge with the next row using a small heap to avoid enumerating all combinations.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function \texttt{kthSmallest(mat: List[List[int]], k: int) -> int}. Here \texttt{mat} is an $m \times n$ list of lists with each row sorted non-decreasingly; $1 \le m,n \le 40$. $k$ satisfies $1 \le k \le \min(200, m n)$.}
\OUTPUTS{Return the integer value of the $k$th smallest possible sum formed by choosing exactly one element from each row.}
\SAMPLES{
\begin{bullets}
\item \texttt{mat = [[1,3,11],[2,4,6]], k = 5} $\to$ \texttt{7}
\item \texttt{mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7} $\to$ \texttt{9}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let rows be $R_1,\ldots,R_m$, each a non-decreasing sequence $R_i = (a_{i,1} \le a_{i,2} \le \cdots \le a_{i,n_i})$. A selection is an index vector $J=(j_1,\ldots,j_m)$ with $1 \le j_i \le n_i$. It induces sum $S(J)=\sum_{i=1}^m a_{i,j_i}$. We seek the $k$th order statistic of the multiset $\{S(J)\mid J \in \prod_i [n_i]\}$.}
\varmapStart
\var{m}{number of rows}
\var{n_i}{length of row $i$ (not necessarily uniform, but here bounded by 40)}
\var{a_{i,j}}{value in row $i$ at column $j$}
\var{k}{rank to retrieve among all sums}
\var{S(J)}{sum for choice vector $J$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Find } \operatorname{select}_k\Bigl(\bigl\{\,S(J)=\sum_{i=1}^m a_{i,j_i}\;:\;1\le j_i\le n_i\,\bigr\}\Bigr).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Each row is sorted non-decreasingly. $k \le \prod_i n_i$ so the $k$th sum exists.}
\INVARIANTS{
\begin{bullets}
\item When iteratively merging rows, the intermediate list of partial sums is kept sorted and truncated to at most $k$ smallest elements.
\item Merging preserves correctness: the $k$ smallest sums from $A \oplus B$ can be obtained without enumerating all pairs if we expand pairs in increasing order using a min-heap.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Naively convolve partial sums with the next row by enumerating all pairwise sums, sort, then take the smallest $k$.}
\ASSUMPTIONS{Rows are sorted; we can truncate the very first row to its first $k$ elements because larger entries cannot contribute to the global $k$ smallest sums.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize list $P$ as the first row sorted, truncated to length $k$.
\item For each subsequent row $R$:
\begin{bullets}
\item Form all pairwise sums $p + r$ for $p \in P$, $r \in R$.
\item Sort the list and truncate to its first $k$ elements; assign to $P$.
\end{bullets}
\item Return $P[k-1]$.
\end{algosteps}
\COMPLEXITY{If $|P| \le k$ and $|R|=n$, each merge builds $O(k n)$ sums, sorts them in $O(k n \log(k n))$, repeated $m-1$ times. Space $O(k n)$ transient, $O(k)$ retained.}
\[
\begin{aligned}
T(m,n,k) &\approx (m-1)\cdot O\big(k n \log(k n)\big),\\
S(m,n,k) &\approx O(k n).
\end{aligned}
\]
\CORRECTNESS{Sorting all pairwise sums guarantees that truncating to $k$ retains exactly the $k$ smallest sums involving processed rows, so downstream steps cannot exclude any globally top-$k$ sum.}
\EDGECASES{Single row; single column; $k=1$; $k$ equals total combinations; duplicate values across rows.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        # Baseline: full pairwise expansion per merge, then sort and truncate.
        if not mat:
            return 0
        # Ensure each row is non-empty
        assert all(len(row) > 0 for row in mat)
        # Start with first row (sorted) and cap to k
        curr = sorted(mat[0])[:k]
        for r in mat[1:]:
            r_sorted = sorted(r)
            # Full expansion
            tmp = []
            for a in curr:
                for b in r_sorted:
                    tmp.append(a + b)
            tmp.sort()
            curr = tmp[:k]
        # k is guaranteed <= total combinations
        return curr[k - 1]

# Asserts (samples)
if __name__ == "__main__":
    s = Solution()
    assert s.kthSmallest([[1,3,11],[2,4,6]], 5) == 7
    assert s.kthSmallest([[1,3,11],[2,4,6]], 9) == 17
    assert s.kthSmallest([[1,10,10],[1,4,5],[2,3,6]], 7) == 9
\end{minted}
\VALIDATION{For $m=1$, the method returns the $k$th element of the first row. For repeated equal elements, duplicates are kept and ranked appropriately.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Merge via K Smallest Pair Sums (Heap)}
\WHICHFORMULA{Use a min-heap to generate the $k$ smallest pairwise sums of two sorted arrays in $O(k \log \min(k,n))$ time, instead of materializing all $k n$ pairs.}
\ASSUMPTIONS{Both input arrays to the merge are non-decreasing; we can cap both to length $k$ because only the first $k$ elements of each can participate in the global top-$k$ pair sums.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define \texttt{merge\_two(A, B, k)} that returns the $k$ smallest values of $\{a+b\mid a\in A, b\in B\}$:
\begin{bullets}
\item Push $(A[i]+B[0], i, 0)$ for $i$ over valid indices into a min-heap.
\item Repeatedly pop the smallest $(s,i,j)$, append $s$ to result, and push $(A[i]+B[j+1], i, j+1)$ if $j+1<|B|$.
\item Stop after $k$ pops or heap exhaustion.
\end{bullets}
\item Initialize $P$ as the first row (sorted), truncated to $k$.
\item For each next row $R$, set $P \leftarrow \texttt{merge\_two}(P, R, k)$.
\item Return $P[k-1]$.
\end{algosteps}
\COMPLEXITY{Each merge costs $O(\min(k,|A|)\log \min(k,|A|) + k\log \min(k,|B|)) = O(k\log k)$; across $m-1$ merges this is $O(mk\log k)$ time and $O(k)$ space.}
\[
\begin{aligned}
T(m,n,k) &\approx (m-1)\cdot O(k\log k), \\
S(m,n,k) &\approx O(k).
\end{aligned}
\]
\CORRECTNESS{The heap always exposes the smallest unseen pair by increasing $B$-index per fixed $i$, and seeding across all $i$ ensures no smaller pair is skipped. This is the standard $k$-smallest pairs invariant.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        if not mat:
            return 0
        assert all(len(row) > 0 for row in mat)

        def merge_two(A: List[int], B: List[int], k: int) -> List[int]:
            # Both A and B must be non-decreasing
            A = A[:k]
            B = B[:k]
            if not A or not B:
                return []
            h = []
            for i in range(min(len(A), k)):
                heapq.heappush(h, (A[i] + B[0], i, 0))
            res = []
            while h and len(res) < k:
                s, i, j = heapq.heappop(h)
                res.append(s)
                if j + 1 < len(B):
                    heapq.heappush(h, (A[i] + B[j + 1], i, j + 1))
            return res

        curr = sorted(mat[0])[:k]
        for r in mat[1:]:
            curr = merge_two(curr, sorted(r), k)
        return curr[k - 1]

# Asserts (samples)
if __name__ == "__main__":
    s = Solution()
    assert s.kthSmallest([[1,3,11],[2,4,6]], 5) == 7
    assert s.kthSmallest([[1,3,11],[2,4,6]], 9) == 17
    assert s.kthSmallest([[1,10,10],[1,4,5],[2,3,6]], 7) == 9
\end{minted}
\VALIDATION{Edge checks: $k=1$ returns the sum of all first elements; identical rows; highly skewed values still work due to index-wise heap expansion.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Row-by-Row K-Smallest Pair Sums (Tight for $k \le 200$)}
\WHICHFORMULA{Iterative heap-based $k$-smallest-pairs merging across rows; with $k \le 200$, $m,n \le 40$, this achieves $O(mk\log k)$, which is optimal up to logarithmic factors because any algorithm must output $\Theta(k)$ partial sums per merge in the worst case.}
\ASSUMPTIONS{Rows are sorted; $k \le \prod_i n_i$; we may safely truncate each row and intermediate list to length $k$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort each row and trim to $k$.
\item Set $P$ to the first row.
\item For each subsequent row $R$, replace $P$ by the $k$ smallest sums of $P \oplus R$ via a min-heap as in Approach B.
\item Return $P[k-1]$.
\end{algosteps}
\OPTIMALITY{A lower bound of $\Omega(k)$ per row merge holds since we must at least enumerate $k$ sums to identify the $k$th answer; the heap method matches this up to a $\log k$ factor, and with tiny $k$ the constants are small.}
\COMPLEXITY{For $m$ rows the time is $O(mk\log k)$ and space $O(k)$.}
\[
\begin{aligned}
T(m,n,k) &= O(mk\log k), \\
S(m,n,k) &= O(k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        # Final: compact, robust heap-based row-by-row merge.
        assert mat and all(row for row in mat)
        rows = [sorted(row)[:k] for row in mat]
        curr = rows[0]
        for r in rows[1:]:
            curr = self._merge_k_smallest(curr, r, k)
        return curr[k - 1]

    @staticmethod
    def _merge_k_smallest(A: List[int], B: List[int], k: int) -> List[int]:
        # Both A, B are sorted and truncated to k.
        if not A or not B:
            return []
        h = []
        limit = min(len(A), k)
        for i in range(limit):
            heapq.heappush(h, (A[i] + B[0], i, 0))
        res = []
        while h and len(res) < k:
            s, i, j = heapq.heappop(h)
            res.append(s)
            if j + 1 < len(B):
                heapq.heappush(h, (A[i] + B[j + 1], i, j + 1))
        return res

# Exactly 3 asserts
if __name__ == "__main__":
    s = Solution()
    assert s.kthSmallest([[1,3,11],[2,4,6]], 5) == 7
    assert s.kthSmallest([[1,3,11],[2,4,6]], 9) == 17
    assert s.kthSmallest([[1,10,10],[1,4,5],[2,3,6]], 7) == 9
\end{minted}
\VALIDATION{The three official samples pass. Additionally, for $m=1$ it returns the $k$th element; for identical rows it equals the $k$th sum of two identical sorted arrays.}
\RESULT{Returns the integer value of the $k$th smallest possible sum obtained by picking one element from each row; ties are resolved by multiplicity and natural non-decreasing order of sums.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-check the heap-based solution against a brute-force enumerator on small sizes; include edge cases ($k=1$, single row, single column, duplicates).}
\LINE{CROSS-CHECKS}{Compare Approach A vs Approach C on random tiny matrices to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate deterministic small matrices and compare results; ensure rows are sorted and lengths vary.}
\begin{minted}{python}
from typing import List
import itertools
import random

def brute_kth_sum(mat: List[List[int]], k: int) -> int:
    # Exhaustive enumeration: only for tiny sizes.
    pools = [list(row) for row in mat]
    sums = []
    for combo in itertools.product(*pools):
        sums.append(sum(combo))
    sums.sort()
    return sums[k - 1]

def solution_heap(mat: List[List[int]], k: int) -> int:
    import heapq
    rows = [sorted(row)[:k] for row in mat]
    curr = rows[0]
    for r in rows[1:]:
        h = []
        limit = min(len(curr), k)
        for i in range(limit):
            heapq.heappush(h, (curr[i] + r[0], i, 0))
        nxt = []
        while h and len(nxt) < k:
            s, i, j = heapq.heappop(h)
            nxt.append(s)
            if j + 1 < len(r):
                heapq.heappush(h, (curr[i] + r[j + 1], i, j + 1))
        curr = nxt
    return curr[k - 1]

if __name__ == "__main__":
    # Deterministic tests
    random.seed(0)
    # Tiny random matrices for brute-force cross-check
    for _ in range(30):
        m = random.randint(1, 4)
        n = random.randint(1, 4)
        mat = []
        for _r in range(m):
            row = sorted(random.randint(1, 9) for _c in range(n))
            mat.append(row)
        total = 1
        for row in mat:
            total *= len(row)
        k = random.randint(1, min(10, total))
        assert solution_heap(mat, k) == brute_kth_sum(mat, k)

    # Fixed edge cases
    assert solution_heap([[5]], 1) == 5
    assert solution_heap([[1,2,3]], 2) == 2
    assert solution_heap([[1,1],[1,1]], 3) == 2
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        # Robust, concise heap-based row-by-row merge; ready for LC submission.
        assert mat and all(row for row in mat)
        rows = [sorted(row)[:k] for row in mat]
        curr = rows[0]
        for r in rows[1:]:
            curr = self._merge_k_smallest(curr, r, k)
        return curr[k - 1]

    @staticmethod
    def _merge_k_smallest(A: List[int], B: List[int], k: int) -> List[int]:
        if not A or not B:
            return []
        # Ensure both are capped to k for safety (though caller already does)
        A = A[:k]
        B = B[:k]
        h = []
        limit = min(len(A), k)
        for i in range(limit):
            heapq.heappush(h, (A[i] + B[0], i, 0))
        res = []
        while h and len(res) < k:
            s, i, j = heapq.heappop(h)
            res.append(s)
            if j + 1 < len(B):
                heapq.heappush(h, (A[i] + B[j + 1], i, j + 1))
        return res

# Inline sanity asserts
if __name__ == "__main__":
    s = Solution()
    assert s.kthSmallest([[1,3,11],[2,4,6]], 5) == 7
    assert s.kthSmallest([[1,3,11],[2,4,6]], 9) == 17
    assert s.kthSmallest([[1,10,10],[1,4,5],[2,3,6]], 7) == 9
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Merge rows iteratively while maintaining the $k$ smallest partial sums using a min-heap for $k$-smallest pair sums.}
\WHY{This pattern recurs in problems about combining sorted lists or layers (arrays, rows, paths) while extracting only the smallest few results.}
\CHECKLIST{
\begin{bullets}
\item Sort each row; trim to $k$.
\item Initialize with first row.
\item Heap-merge current partial sums with next row to get $k$ smallest new sums.
\item Repeat for all rows; answer is at index $k-1$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $m=1$ (answer is $k$th element of the row).
\item $n=1$ (sum of first elements; only one combination).
\item $k=1$ (sum of minimal elements of each row).
\item Duplicate values across rows.
\item Rows with different lengths.
\item Large values but small $k$.
\item Tight $k$ equal to total combinations.
\item Non-strictly increasing rows.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to cap rows and partial lists to length $k$ increases time.
\item Not ensuring rows are sorted before merging.
\item Off-by-one when returning $P[k-1]$.
\item Pushing duplicate heap states without bounds (though duplicates are fine, ensure cap by $k$ pops).
\item Using full Cartesian expansion accidentally causing $O(k n)$ memory blowup.
\item Assuming $k$ never equals total combinations and indexing past end.
\item Mutating input rows inadvertently.
\item Using unstable numeric types (stick to Python ints).
\end{bullets}
}
\FAILMODES{Full expansion per merge can time out when $n$ is up to $40$; the heap approach remains efficient because it explores only $k \le 200$ pairs per merge.}
\ELI{We build sums layer by layer, but instead of listing every possible sum, we only keep the top $k$ smallest at each step by always expanding the currently smallest candidate via a min-heap. This keeps the work tiny and focused on what matters.}
\NotePages{3}

\end{document}