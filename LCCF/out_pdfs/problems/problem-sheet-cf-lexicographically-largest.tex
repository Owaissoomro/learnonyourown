% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lexicographically Largest}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1930/C}}
\LINE{DIFFICULTY / RATING}{1700}
\STATEMENT{Stack has an array $a$ of length $n$. He also has an empty set $S$. Note that $S$ is not a multiset.

He will do the following three-step operation exactly $n$ times:
\begin{enumerate}[leftmargin=2em]
\item Select an index $i$ such that $1 \le i \le \lvert a\rvert$.
\item Insert$^\dagger$ $a_i + i$ into $S$.
\item Delete $a_i$ from $a$. Note that the indices of all elements to the right of $a_i$ will decrease by $1$.
\end{enumerate}
Note that after $n$ operations, $a$ will be empty.

Stack will now construct a new array $b$ which is $S$ sorted in decreasing order. Formally, $b$ is an array of size $\lvert S\rvert$ where $b_i$ is the $i$-th largest element of $S$ for all $1 \le i \le \lvert S\rvert$.

Find the lexicographically largest$^\ddagger$ $b$ that Stack can make.

$^\dagger$ A set can only contain unique elements. Inserting an element that is already present in a set will not change the elements of the set.

$^\ddagger$ An array $p$ is lexicographically larger than a sequence $q$ if and only if one of the following holds:
\begin{itemize}
\item $q$ is a prefix of $p$, but $p \ne q$; or
\item in the first position where $p$ and $q$ differ, the array $p$ has a larger element than the corresponding element in $q$.
\end{itemize}

Note that $[3,1,4,1,5]$ is lexicographically larger than $[3,1,3]$, $[\,]$, and $[3,1,4,1]$ but not $[3,1,4,1,5,9]$, $[3,1,4,1,5]$, and $[4]$.

Input: Each test contains multiple test cases. The first line contains a single integer $t$ ($1 \le t \le 10^4$)~— the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer $n$ ($1 \le n \le 3 \cdot 10^5$)~— the length of array $a$.

The second line of each test case contains $n$ integers $a_1,a_2,\ldots,a_{n}$ ($1 \le a_i \le 10^9$)~— the elements of array $a$.

The sum of $n$ over all test cases does not exceed $3 \cdot 10^5$.

Output: For each test case, output the lexicographically largest $b$.

Note: In the first test case, select $i=1$ in the first operation, insert $a_1 + 1 = 3$ in $S$, and delete $a_1$ from $a$. After the first operation, $a$ becomes $a=[1]$. In the second operation, we select $i=1$ again and insert $a_1 + 1 = 2$ in $S$. Thus $S=\{2, 3\}$, and $b = [3, 2]$.

Note that if you select $i=2$ in the first operation, and $i=1$ in the second operation, $S=\{3\}$ as $3$ will be inserted twice, resulting in $b=[3]$.

As $[3,2]$ is lexicographically larger than $[3]$, we should select $i=1$ in the first operation.

In the second test case, in each operation, select the last element.}
\BREAKDOWN{Each element $a_i$ can contribute a value $a_i + t$ where $t$ is the current index when it is deleted, and $t$ can range from $1$ up to its original position $i$. We must choose a deletion order to produce a set of distinct values maximizing the decreasingly sorted sequence $b$. Model each element as an interval $[L_i,R_i]=[a_i+1,a_i+i]$, pick distinct integers from these intervals to maximize the lexicographically sorted decreasing list.}
\ELI{Treat each $a_i$ as offering an interval of possible sums; greedily take the largest possible distinct sums from these intervals, stepping down when collisions happen, never going below $a_i+1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.
\begin{bullets}
\item $t$: integer, $1 \le t \le 10^4$.
\item For each test: $n$ with $1 \le n \le 3\cdot 10^5$; then $a_1,\ldots,a_n$ with $1 \le a_i \le 10^9$.
\item $\sum n \le 3\cdot 10^5$ across all test cases.
\end{bullets}}
\OUTPUTS{For each test case, print the array $b$ (elements of $S$ in decreasing order) as space-separated integers on one line. If $S$ is empty, print an empty line.}
\SAMPLES{Example 1:
\begin{bullets}
\item Input:\\
2\\
2\\
2\ 1\\
3\\
5\ 1\ 1
\item Output:\\
3\ 2\\
6\ 3\ 2
\end{bullets}
Explanation: For the first case, $b=[3,2]$ as in the note. For the second, intervals are $[6,6],[2,3],[2,4]$; we can pick $6,3,2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For each position $i$ ($1$-based), the value inserted upon deleting that element equals $a_i + t$ where $t$ is its current index at deletion time. Because deletions to the left decrease the index and deletions to the right do not, $t \in [1,i]$. Thus element $i$ offers the closed integer interval $[L_i,R_i]=[a_i+1,\ a_i+i]$. We choose a subset of elements and assign each a distinct integer $x_i \in [L_i,R_i]$. The resulting multiset of assigned values forms $S$, and $b$ is $S$ sorted in decreasing order. Our objective is to maximize $b$ under lexicographic order.}
\varmapStart
\var{a_i}{original array values}
\var{S}{set of inserted sums (distinct)}
\var{b}{$S$ sorted decreasingly}
\var{L_i}{minimum achievable sum for element $i$, $a_i+1$}
\var{R_i}{maximum achievable sum for element $i$, $a_i+i$}
\var{x_i}{chosen sum from $[L_i,R_i]$ for element $i$ (if selected)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Choose distinct integers } x_i \in \mathbb{Z} \text{ such that}\quad x_i \in [L_i,R_i]\ \text{if $i$ is used}.\\
&\text{Let } S=\{x_i:\ i \text{ used}\},\quad b=\text{sorted}(S,\ \text{decreasing}).\\
&\text{Maximize $b$ in lexicographic order.}
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based. The set $S$ removes duplicates automatically. Any assignment of distinct $x_i \in [L_i,R_i]$ is realizable by some deletion sequence (sketched in correctness).}
\INVARIANTS{
\begin{bullets}
\item For each $i$, no achievable sum exceeds $R_i=a_i+i$.
\item For each $i$, no achievable sum is below $L_i=a_i+1$.
\item If two elements choose equal sums, the set $S$ size shrinks; thus distinctness is essential.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all deletion orders, simulate, record the resulting $S$ and its decreasing sort $b$. Keep the lexicographically largest $b$.}
\ASSUMPTIONS{Only feasible for tiny $n$ due to $n!$ permutations. Used to validate improved methods.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Recursively choose a position $i$ in the current array, insert $a_i+i$ into a running set $S$, delete $a_i$, and continue.
\item At depth $n$, compute $b=\text{sorted}(S,\text{ decreasing})$ and update the best under lex order.
\item Compare arrays lexicographically by the first differing position; if all equal and lengths differ, the longer is larger.
\end{algosteps}
\COMPLEXITY{The number of deletion orders is $n!$, each simulation step costs $O(n)$ to copy arrays in a naive implementation. This is intractable beyond very small $n$.}
\[
\begin{aligned}
T(n) &\in \Theta(n!\cdot n),\quad S(n)\in O(n).
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration covers all valid sequences, thus the maximum under lexicographic order is found.}
\EDGECASES{All $a_i$ equal; strictly increasing or decreasing $a_i$; duplicates causing many collisions.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Set

def read_input() -> Tuple[int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append(a)
    return t, tests

def lex_greater(a: List[int], b: List[int]) -> bool:
    """Return True if a is lexicographically greater than b."""
    m = min(len(a), len(b))
    for i in range(m):
        if a[i] != b[i]:
            return a[i] > b[i]
    return len(a) > len(b)

def brute_best_b(a: List[int]) -> List[int]:
    n = len(a)
    best: List[int] = []

    def dfs(arr: List[int], sset: Set[int]) -> None:
        nonlocal best
        if not arr:
            b = sorted(sset, reverse=True)
            if lex_greater(b, best):
                best = b
            return
        # try deleting each position
        for i in range(len(arr)):
            val = arr[i] + (i + 1)
            new_arr = arr[:i] + arr[i+1:]
            # set insertion semantics (idempotent)
            if val in sset:
                dfs(new_arr, sset)
            else:
                sset.add(val)
                dfs(new_arr, sset)
                sset.remove(val)

    dfs(list(a), set())
    return best

def solve_case_brutal(a: List[int]) -> List[int]:
    # Only for very small n
    if len(a) > 9:
        raise ValueError("Brutal solver only supports n <= 9")
    return brute_best_b(a)

def solve_all():
    t, tests = read_input()
    out_lines = []
    for a in tests:
        b = solve_case_brutal(a)
        out_lines.append(" ".join(map(str, b)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Tiny sanity tests for the brute solver
    assert brute_best_b([2, 1]) == [3, 2]
    assert brute_best_b([1]) == [2]
    # Length-3 hand check
    res = brute_best_b([1, 1, 1])
    # Possible sets include {2,3,4} yielding [4,3,2]
    assert res == [4, 3, 2]
    # When run as a script, will attempt to read input for brute mode
    # (intended for tiny cases only).
    # solve_all()
\end{minted}
\VALIDATION{Checked on tiny arrays by hand and with embedded asserts. The brute solver establishes a ground truth for random small cases in later sections.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy on Maxima with Local Adjustments}
\WHICHFORMULA{Each element $i$ has a maximal achievable sum $R_i=a_i+i$. Sort these $R_i$ in decreasing order and greedily place them into $S$. If a collision occurs (duplicate value), decrement the candidate until it becomes unused, but never below its minimum $L_i=a_i+1$.}
\ASSUMPTIONS{Processing candidates in decreasing order while respecting lower bounds yields a set of distinct sums as large and as top-heavy as possible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $i$, compute $(L_i,R_i)=(a_i+1,a_i+i)$.
\item Sort the pairs by $R_i$ in decreasing order.
\item Maintain a hash set of used values. For each pair in order:
  \begin{bullets}
  \item Let $v=R_i$.
  \item While $v$ is used and $v > L_i$, decrement $v$.
  \item If $v$ is unused and $v \ge L_i$, insert $v$ into the used set.
  \end{bullets}
\item Output the used values in decreasing order.
\end{algosteps}
\COMPLEXITY{Sorting dominates: $O(n\log n)$. Each value is decremented at most as many times as it is inserted overall; with hashing, the total is $O(n\log n)$ expected or $O(n\log n + D)$ worst-case with ordered maps.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Because we iterate $R_i$ in decreasing order and push each as high as possible subject to distinctness and $L_i$ bounds, any alternative that makes an earlier value smaller cannot lexicographically beat this sequence. The decrement ensures distinctness; the lower bound ensures feasibility.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append(a)
    return t, tests

def greedy_adjust_set(a: List[int]) -> List[int]:
    pairs = []
    for i, val in enumerate(a, start=1):
        L = val + 1
        R = val + i
        pairs.append((R, L))
    # sort by R decreasing
    pairs.sort(reverse=True)
    used = set()
    for R, L in pairs:
        v = R
        # step down until distinct or hit lower bound
        while v in used and v > L:
            v -= 1
        if v not in used and v >= L:
            used.add(v)
    return sorted(used, reverse=True)

def solve_case(a: List[int]) -> List[int]:
    return greedy_adjust_set(a)

def solve_all():
    t, tests = read_input()
    out_lines = []
    for a in tests:
        b = solve_case(a)
        out_lines.append(" ".join(map(str, b)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Deterministic checks
    assert greedy_adjust_set([2, 1]) == [3, 2]
    assert greedy_adjust_set([1, 1]) == [3, 2]
    assert greedy_adjust_set([5, 1, 1]) == [6, 3, 2]
    # solve_all()
\end{minted}
\VALIDATION{Verified on a few crafted cases and matches the brute force on those. We will add randomized cross-checks in the final testing section.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Interval Greedy with Global Monotone Cap}
\WHICHFORMULA{View each element as an interval $[L_i,R_i]=[a_i+1,a_i+i]$. Sort intervals by $R_i$ decreasing. Maintain a moving cap $\text{cur}$, initialized to $+\infty$. For each interval in order, pick $v=\min(R_i,\ \text{cur}-1)$. If $v \ge L_i$, accept $v$ and set $\text{cur}=v$. This directly constructs $b$ in decreasing order and is lexicographically optimal.}
\ASSUMPTIONS{Any set of distinct integers chosen with $v_k$ strictly decreasing and $v_k \in [L_{i_k},R_{i_k}]$ is realizable by an appropriate deletion sequence.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $L_i=a_i+1$, $R_i=a_i+i$ for all $i$.
\item Sort the pairs $(L_i,R_i)$ by $R_i$ in decreasing order.
\item Set $\text{cur}=+\infty$, result list $b=[]$.
\item For each $(L,R)$ in order:
\begin{bullets}
\item $v=\min(R,\ \text{cur}-1)$.
\item If $v \ge L$, append $v$ to $b$ and set $\text{cur}=v$.
\end{bullets}
\item Output $b$ as is (already decreasing).
\end{algosteps}
\OPTIMALITY{We greedily maximize the first element by taking the largest available $R$. Then we cap the next by enforcing strict decrease to ensure distinctness and lexicographic dominance; picking any value larger than $\min(R,\ \text{cur}-1)$ would violate feasibility or distinctness; picking smaller would worsen lex order. By induction, this is lexicographically maximal.}
\COMPLEXITY{Sorting dominates: $O(n\log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple
import random

def read_input() -> Tuple[int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests: List[List[int]] = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append(a)
    return t, tests

def solve_case(a: List[int]) -> List[int]:
    # Interval greedy with global cap
    pairs = []
    for i, val in enumerate(a, start=1):
        L = val + 1
        R = val + i
        pairs.append((R, L))
    pairs.sort(reverse=True)  # sort by R descending
    cur = 10**30
    b: List[int] = []
    for R, L in pairs:
        v = R if R < cur else cur - 1
        if v >= L:
            b.append(v)
            cur = v
    return b  # already decreasing

def solve_all():
    t, tests = read_input()
    out_lines: List[str] = []
    for a in tests:
        b = solve_case(a)
        out_lines.append(" ".join(map(str, b)))
    sys.stdout.write("\n".join(out_lines))

# ---------- Tests (deterministic) ----------
def lex_greater(a: List[int], b: List[int]) -> bool:
    m = min(len(a), len(b))
    for i in range(m):
        if a[i] != b[i]:
            return a[i] > b[i]
    return len(a) > len(b)

def brute_best_b(a: List[int]) -> List[int]:
    # brute force for small n
    n = len(a)
    best: List[int] = []
    def dfs(arr: List[int], sset: set):
        nonlocal best
        if not arr:
            b = sorted(sset, reverse=True)
            if lex_greater(b, best):
                best = b
            return
        for i in range(len(arr)):
            val = arr[i] + (i + 1)
            nxt = arr[:i] + arr[i+1:]
            if val in sset:
                dfs(nxt, sset)
            else:
                sset.add(val)
                dfs(nxt, sset)
                sset.remove(val)
    dfs(list(a), set())
    return best

if __name__ == "__main__":
    # Exact matches on known cases
    assert solve_case([2, 1]) == [3, 2]
    assert solve_case([1]) == [2]
    assert solve_case([1, 1]) == [3, 2]
    # Random cross-check vs brute for small sizes
    rng = random.Random(0)
    for _ in range(100):
        n = rng.randint(1, 6)
        a = [rng.randint(1, 4) for _ in range(n)]
        assert solve_case(a) == brute_best_b(a)
    # Uncomment to run on stdin:
    # solve_all()
\end{minted}
\VALIDATION{Exactly 3 checks:
\begin{bullets}
\item Handcrafted: $[2,1]\to[3,2]$.
\item Handcrafted: $[1,1]\to[3,2]$.
\item Randomized: 100 small cases cross-checked against brute force.
\end{bullets}}
\RESULT{Print the distinct sums chosen by the greedy interval assignment, in decreasing order on one line per test case.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Combine hand-crafted cases (edge patterns), adversarial duplicates, and randomized small instances cross-checked against brute force to ensure correctness under lexicographic comparison.}
\LINE{CROSS-CHECKS}{For small $n$, compare Approach C results against Approach A brute force; they must match exactly. Also compare Approach B and C to ensure they produce identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with:
\begin{bullets}
\item All equal values.
\item Strictly increasing/decreasing $a_i$.
\item Random small $a_i$ with many duplicates.
\item Large $a_i$ to test bounds (no overflow in Python).
\end{bullets}}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_equal(n: int, v: int) -> List[int]:
    return [v] * n

def gen_increasing(n: int, start: int = 1, step: int = 1) -> List[int]:
    return [start + i * step for i in range(n)]

def gen_decreasing(n: int, start: int = 100, step: int = 1) -> List[int]:
    return [start - i * step for i in range(n)]

def gen_random(n: int, lo: int, hi: int, seed: int = 42) -> List[int]:
    rng = random.Random(seed)
    return [rng.randint(lo, hi) for _ in range(n)]

def cross_check():
    # Compare improved/final vs brute on small cases
    for n in range(1, 8):
        # some deterministic arrays
        cases = [
            gen_all_equal(n, 1),
            gen_increasing(n, 1, 1),
            gen_decreasing(n, 10, 1),
            gen_random(n, 1, 4, seed=123 + n),
        ]
        for a in cases:
            b_brute = brute_best_b(a)
            b_final = solve_case(a)
            assert b_brute == b_final, (a, b_brute, b_final)

# Reference brute and final from previous block (redeclared if needed)
def brute_best_b(a: List[int]) -> List[int]:
    n = len(a)
    best: List[int] = []
    def lex_greater(x: List[int], y: List[int]) -> bool:
        m = min(len(x), len(y))
        for i in range(m):
            if x[i] != y[i]:
                return x[i] > y[i]
        return len(x) > len(y)
    def dfs(arr: List[int], sset: set):
        nonlocal best
        if not arr:
            b = sorted(sset, reverse=True)
            if lex_greater(b, best):
                best = b
            return
        for i in range(len(arr)):
            val = arr[i] + (i + 1)
            nxt = arr[:i] + arr[i+1:]
            if val in sset:
                dfs(nxt, sset)
            else:
                sset.add(val)
                dfs(nxt, sset)
                sset.remove(val)
    dfs(list(a), set())
    return best

def solve_case(a: List[int]) -> List[int]:
    pairs = []
    for i, val in enumerate(a, start=1):
        L = val + 1
        R = val + i
        pairs.append((R, L))
    pairs.sort(reverse=True)
    cur = 10**30
    b: List[int] = []
    for R, L in pairs:
        v = R if R < cur else cur - 1
        if v >= L:
            b.append(v)
            cur = v
    return b

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final CF-ready implementation with required API and simple asserts
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests: List[List[int]] = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append(a)
    return t, tests

def solve_case(a: List[int]) -> List[int]:
    pairs = []
    for i, val in enumerate(a, start=1):
        L = val + 1
        R = val + i
        pairs.append((R, L))
    pairs.sort(reverse=True)
    cur = 10**30
    b: List[int] = []
    for R, L in pairs:
        v = R if R < cur else cur - 1
        if v >= L:
            b.append(v)
            cur = v
    return b

def solve_all():
    t, tests = read_input()
    out_lines: List[str] = []
    for a in tests:
        b = solve_case(a)
        out_lines.append(" ".join(map(str, b)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Minimal sanity asserts
    assert solve_case([2, 1]) == [3, 2]
    assert solve_case([1]) == [2]
    assert solve_case([5, 1, 1]) == [6, 3, 2]
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Transform each element into an interval $[a_i+1,a_i+i]$ and greedily pick the largest possible distinct integers in decreasing order.}
\WHY{Greedy interval assignment with distinctness is a recurring pattern in interview and contest problems where operations allow bounded adjustments and uniqueness constraints (sets).}
\CHECKLIST{
\begin{bullets}
\item Compute $L_i=a_i+1$, $R_i=a_i+i$ correctly (1-based).
\item Sort by $R_i$ in decreasing order.
\item Maintain a strict cap $\text{cur}$ and assign $v=\min(R_i,\ \text{cur}-1)$.
\item Skip intervals where $v<L_i$.
\item Output the collected values in decreasing order.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item All $a_i$ equal.
\item Many $R_i$ equal, requiring cascaded decrements.
\item Very large $a_i$ ($10^9$), ensure no overflow in fixed-width types (use 64-bit).
\item Cases where only a few values are distinct due to tight intervals.
\item Already strictly increasing $R_i$—algorithm should keep them all.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one: using $a_i$ or $a_i+i-1$ as bounds instead of $a_i+1$ and $a_i+i$.
\item Forgetting that indices are $1$-based when forming $R_i$.
\item Sorting in the wrong order (increasing instead of decreasing).
\item Not enforcing strict decrease globally, causing duplicates in $S$.
\item Reducing below $L_i$, which yields infeasible assignments.
\item Printing unsorted output; $b$ must be decreasing.
\end{bullets}
}
\FAILMODES{Naively taking the set of maxima $\{a_i+i\}$ fails lexicographically when duplicates collapse the set size. Likewise, greedily taking rightmost deletions only may yield fewer distinct values than possible. The interval greedy avoids both by stepping down to fill gaps.}
\ELI{Each item $a_i$ lets you choose a number in a window. To make the sorted list as big as possible at the top, always take the biggest unused number allowed, moving down if it clashes, but never below the item’s minimum. Doing this from the biggest windows first guarantees the best lexicographic result.}
\NotePages{3}

\end{document}