% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — A Heap of Heaps}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/537/F}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{Andrew skipped lessons on the subject ``Algorithms and Data Structures'' for the entire term. When he came to the final test, the teacher decided to give him a difficult task as a punishment.

The teacher gave Andrew an array of $n$ numbers $a_1, \ldots, a_n$. After that he asked Andrew for each $k$ from $1$ to $n-1$ to build a $k$-ary heap on the array and count the number of elements for which the property of the minimum-rooted heap is violated, i.e. the value of an element is less than the value of its parent.

Andrew looked up on the Wikipedia that a $k$-ary heap is a rooted tree with vertices in elements of the array. If the elements of the array are indexed from $1$ to $n$, then the children of element $v$ are elements with indices $k(v-1)+2, \ldots, kv+1$ (if some of these elements lie outside the borders of the array, the corresponding children are absent). In any $k$-ary heap every element except for the first one has exactly one parent; for the element $1$ the parent is absent (this element is the root of the heap). Denote $p(v)$ as the number of the parent of the element with the number $v$. Let us say that for a non-root element $v$ the property of the heap is violated if $a_v < a_{p(v)}$.

Help Andrew cope with the task!

Input:
The first line contains a single integer $n$ ($2 \le n \le 2\cdot 10^5$).

The second line contains $n$ space-separated integers $a_1, \ldots, a_n$ ($-10^9 \le a_i \le 10^9$).

Output:
in a single line print $n-1$ integers, separate the consecutive numbers with a single space — the number of elements for which the property of the $k$-ary heap is violated, for $k = 1, 2, \ldots, n-1$.

Note:
Pictures with the heaps for the first sample are given below; elements for which the property of the heap is violated are marked with red.

In the second sample all elements are equal, so the property holds for all pairs.}
\BREAKDOWN{For each $k$, define the parent map $p_k(v) = \lfloor (v-2)/k \rfloor + 1$ for $v \ge 2$. Count how many $v \in \{2,\ldots,n\}$ satisfy $a_v < a_{p_k(v)}$. The challenge is to compute these counts for all $k=1,\ldots,n-1$ efficiently.}
\ELI{As $k$ changes, each node's parent only changes at few breakpoints; add that node's contribution over ranges of $k$ at once.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item $n$ — integer, $2 \le n \le 2\cdot 10^5$.
\item Array $a$ of length $n$ with integers $-10^9 \le a_i \le 10^9$.
\end{bullets}
}
\OUTPUTS{One line with $n-1$ integers: for each $k=1,\ldots,n-1$, the count of indices $v \in \{2,\ldots,n\}$ with $a_v < a_{p_k(v)}$.}
\SAMPLES{
Example 1:
\begin{itemize}
\item Input:
\[
\begin{aligned}
n&=5\\
a&=[5,4,3,2,1]
\end{aligned}
\]
\item Output: $4~4~4~4$
\end{itemize}
Example 2:
\begin{itemize}
\item Input:
\[
\begin{aligned}
n&=4\\
a&=[1,1,1,1]
\end{aligned}
\]
\item Output: $0~0~0$
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $a \in \mathbb{Z}^n$, for each $k \in \{1,\ldots,n-1\}$ define
\begin{BreakableEquation*}
p_k(v) = \left\lfloor \frac{v-2}{k}\right\rfloor + 1,\quad v=2,\ldots,n.
\end{BreakableEquation*}
We want
\begin{BreakableEquation*}
\text{Ans}[k] = \left|\left\{v \in \{2,\ldots,n\} : a_v < a_{p_k(v)}\right\}\right|.
\end{BreakableEquation*}}
\varmapStart
\var{n}{array length}
\var{a_i}{value at index $i$}
\var{k}{heap arity parameter}
\var{p_k(v)}{parent of $v$ in $k$-ary heap}
\var{\text{Ans}[k]}{number of violations for arity $k$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Ans}[k] \;=\; \sum_{v=2}^{n} \mathbf{1}\!\left[a_v < a_{\,\lfloor (v-2)/k \rfloor + 1}\right].
\end{BreakableEquation*}
}
\ASSUMPTIONS{1-indexed array; root is $1$ with no parent. For each fixed $v$, $p_k(v)$ is nonincreasing in $k$ and piecewise-constant with $O(\sqrt{v})$ distinct values over $k=1,\ldots,n-1$.}
\INVARIANTS{
\begin{bullets}
\item For any $v>1$ and $k \ge v-1$, $p_k(v)=1$.
\item For fixed $v$, as $k$ increases, $p_k(v)$ changes only when $k$ crosses a divisor-like breakpoint of $v-2$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute $p_k(v)=\lfloor (v-2)/k \rfloor + 1$ directly for each pair $(k,v)$ and count violations.}
\ASSUMPTIONS{None beyond the problem definition.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $k=1$ to $n-1$:
\item For each $v=2$ to $n$, compute $p=\lfloor (v-2)/k \rfloor + 1$ and increment a counter if $a_v<a_p$.
\item Output the counters for all $k$.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(n^2)$, Space $S(n)=\Theta(1)$ aside from output.}
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n-1}\sum_{v=2}^{n} 1 \\
     &= (n-1)(n-1) = \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{By definition, we evaluate the predicate for each required pair $(k,v)$.}
\EDGECASES{All equal values; strictly increasing; strictly decreasing; minimal $n=2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return (n, a)

def solve_case_baseline(n, a):
    # Direct O(n^2) computation
    ans = [0] * (n + 1)  # 1..n-1 used
    for k in range(1, n):
        cnt = 0
        for v in range(2, n + 1):
            p = (v - 2) // k + 1
            if a[v - 1] < a[p - 1]:
                cnt += 1
        ans[k] = cnt
    return ans[1:]

def solve_all():
    inp = read_input()
    if inp is None:
        return None
    n, a = inp
    res = solve_case_baseline(n, a)
    print(" ".join(map(str, res)))
    return res

def _self_test():
    # Deterministic tiny checks
    assert solve_case_baseline(2, [1, 1]) == [0]
    assert solve_case_baseline(5, [5, 4, 3, 2, 1]) == [4, 4, 4, 4]
    assert solve_case_baseline(5, [1, 2, 3, 4, 5]) == [0, 0, 0, 0]

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Compares against hand-computed cases: decreasing array gives all maximum counts; equal and increasing arrays give all zeros.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Quotient Grouping With Range Adds}
\WHICHFORMULA{For fixed $v$, $p_k(v)=\lfloor (v-2)/k \rfloor + 1$ is constant over ranges of $k$. Iterate only the $O(\sqrt{v})$ breakpoints and update an answer difference array over $k$-intervals where the predicate is fixed.}
\ASSUMPTIONS{Use a difference array over $k$ to accumulate contributions from many $v$ efficiently.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize difference array $D[1\ldots n] \leftarrow 0$.
\item For each $v=2$ to $n$, set $x=v-2$ and iterate $k$ by quotient grouping:
\[
t=\left\lfloor \frac{x}{k} \right\rfloor,\quad
r=\begin{cases}
n-1,& t=0,\\
\min(n-1,\left\lfloor \frac{x}{t}\right\rfloor),& t>0,
\end{cases}
\]
parent $p=t+1$ is fixed for all $k\in [k,r]$.
\item If $a_v<a_p$, then do $D[k] \mathrel{+}=1$, $D[r+1]\mathrel{-}=1$. Set $k\leftarrow r+1$ and continue.
\item Prefix-sum $D$ to get answers for all $k$.
\end{algosteps}
\COMPLEXITY{Each $v$ contributes $O(\sqrt{v})$ intervals, so total time $O(n\sqrt{n})$, space $O(n)$.}
\[
\begin{aligned}
T(n) &= \sum_{v=2}^{n} O(\sqrt{v}) \;=\; O(n\sqrt{n}). \\
\end{aligned}
\]
\CORRECTNESS{Within each grouped interval, both parent index $p$ and the predicate $[a_v<a_p]$ are constant; adding over intervals equals adding over all $k$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

def read_input():
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return (n, a)

def solve_case_grouped(n: int, a: List[int]) -> List[int]:
    m = n - 1
    diff = [0] * (m + 2)  # 1..m used; guard at m+1
    for v in range(2, n + 1):
        x = v - 2
        k = 1
        while k <= m:
            t = 0 if x == 0 else x // k
            if t == 0:
                r = m
            else:
                r = x // t
                if r > m:
                    r = m
            p = t + 1
            if a[v - 1] < a[p - 1]:
                diff[k] += 1
                diff[r + 1] -= 1
            k = r + 1
    ans = [0] * (n + 1)
    run = 0
    for k in range(1, m + 1):
        run += diff[k]
        ans[k] = run
    return ans[1:]

def solve_all():
    inp = read_input()
    if inp is None:
        return None
    n, a = inp
    res = solve_case_grouped(n, a)
    print(" ".join(map(str, res)))
    return res

def _self_test():
    # Cross-check with baseline on small ranges
    def baseline(n, a):
        out = [0] * (n + 1)
        for k in range(1, n):
            c = 0
            for v in range(2, n + 1):
                p = (v - 2) // k + 1
                if a[v - 1] < a[p - 1]:
                    c += 1
            out[k] = c
        return out[1:]
    assert solve_case_grouped(2, [7, 7]) == [0]
    assert solve_case_grouped(5, [5, 4, 3, 2, 1]) == [4, 4, 4, 4]
    assert solve_case_grouped(5, [1, 2, 3, 4, 5]) == [0, 0, 0, 0]
    # Randomized small tests
    import random
    rng = random.Random(0)
    for n in range(2, 40):
        for _ in range(30):
            a = [rng.randrange(-5, 6) for _ in range(n)]
            assert solve_case_grouped(n, a) == baseline(n, a)

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Verified against the baseline on randomized cases up to $n=39$ and on structured arrays (increasing, decreasing, equal).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Split Small $k$ Directly, Large $k$ by Ranges}
\WHICHFORMULA{Hybrid: compute small $k \le B$ directly; for large $k>B$ use quotient-grouped range additions. With $B=\lfloor \sqrt{n}\rfloor$, this achieves $O(n\sqrt{n})$ time with a small constant.}
\ASSUMPTIONS{Pick $B=\lfloor \sqrt{n}\rfloor$. For $k\le B$, a direct scan is cheap; for $k>B$, each $v$ contributes $O(\sqrt{v})$ intervals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set $B=\lfloor \sqrt{n}\rfloor$; initialize answer array.
\item For each $k=1$ to $\min(B,n-1)$, scan $v=2$ to $n$ and count violations directly.
\item For each $v=2$ to $n$, quotient-group ranges only for $k\in [B+1,n-1]$; range-add contributions where $a_v<a_{p}$.
\item Prefix-sum the difference array on $[B+1,n-1]$ and write into answers.
\end{algosteps}
\OPTIMALITY{The well-known quotient grouping yields $O(\sqrt{x})$ segments per $x$; splitting at $B=\Theta(\sqrt{n})$ balances the two parts, giving tight $O(n\sqrt{n})$ with low constant, which is optimal for Pythonic solutions and standard for this task.}
\COMPLEXITY{Time $O(nB + \sum_v \sqrt{v})=O(n\sqrt{n})$, Space $O(n)$.}
\[
\begin{aligned}
T(n) &= O(nB) + \sum_{v=2}^{n} O(\sqrt{v}) \\
     &= O(n\sqrt{n}) + O(n\sqrt{n}) = O(n\sqrt{n}).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

def read_input() -> Optional[Tuple[int, List[int]]]:
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return (n, a)

def solve_case_hybrid(n: int, a: List[int]) -> List[int]:
    m = n - 1
    if m <= 0:
        return []
    B = int(n ** 0.5)
    if B < 1:
        B = 1
    if B > m:
        B = m
    ans = [0] * (n + 1)  # 1..m used
    # Small k: direct
    for k in range(1, B + 1):
        c = 0
        for v in range(2, n + 1):
            p = (v - 2) // k + 1
            if a[v - 1] < a[p - 1]:
                c += 1
        ans[k] = c
    # Large k: range adds via quotient grouping
    if B < m:
        diff = [0] * (m + 2)
        for v in range(2, n + 1):
            x = v - 2
            k = B + 1
            while k <= m:
                t = 0 if x == 0 else x // k
                if t == 0:
                    r = m
                else:
                    r = x // t
                    if r > m:
                        r = m
                p = t + 1
                if a[v - 1] < a[p - 1]:
                    diff[k] += 1
                    diff[r + 1] -= 1
                k = r + 1
        run = 0
        for k in range(B + 1, m + 1):
            run += diff[k]
            ans[k] = run
    return ans[1:]

def solve_all():
    inp = read_input()
    if inp is None:
        return None
    n, a = inp
    res = solve_case_hybrid(n, a)
    print(" ".join(map(str, res)))
    return res

def _self_test():
    # Baseline for cross-check (small N)
    def baseline(n, a):
        out = [0] * (n + 1)
        for k in range(1, n):
            c = 0
            for v in range(2, n + 1):
                p = (v - 2) // k + 1
                if a[v - 1] < a[p - 1]:
                    c += 1
            out[k] = c
        return out[1:]
    # Deterministic checks
    assert solve_case_hybrid(2, [10, 10]) == [0]
    assert solve_case_hybrid(5, [5, 4, 3, 2, 1]) == [4, 4, 4, 4]
    assert solve_case_hybrid(5, [1, 2, 3, 4, 5]) == [0, 0, 0, 0]
    # Random tests
    import random
    rng = random.Random(123)
    for n in range(2, 60):
        for _ in range(10):
            a = [rng.randrange(-9, 10) for _ in range(n)]
            assert solve_case_hybrid(n, a) == baseline(n, a)

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts included above for quick checks, plus randomized cross-checks against the baseline for small $n$.}
\RESULT{Outputs a single line with $n-1$ integers: the violation counts for $k=1,2,\ldots,n-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on edge arrays (all equal, increasing, decreasing), random arrays with cross-check against baseline for small $n$, and boundary $n=2$.}
\LINE{CROSS-CHECKS}{Compare outputs from Baseline, Grouped, and Hybrid on the same inputs for correctness.}
\LINE{EDGE-CASE GENERATOR}{Generates arrays of zeros, strictly monotone, and alternating signs to stress parent mappings and comparisons.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_equal(n, val=0):
    return [val] * n

def gen_increasing(n, start=0, step=1):
    return [start + i * step for i in range(n)]

def gen_decreasing(n, start=0, step=1):
    return [start - i * step for i in range(n)]

def gen_alternating(n, a=1, b=-1):
    return [a if i % 2 == 0 else b for i in range(n)]

def reference_hybrid(a):
    return solve_case_hybrid(len(a), a)

def quick_demo():
    cases = [
        gen_equal(6, 7),
        gen_increasing(6, 1, 1),
        gen_decreasing(6, 10, 1),
        gen_alternating(7, 3, -2),
    ]
    for arr in cases:
        print(arr, "->", reference_hybrid(arr))

if __name__ == "__main__":
    # This block is illustrative; the actual final solution is above.
    quick_demo()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

def read_input() -> Optional[Tuple[int, List[int]]]:
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return (n, a)

def solve_case_hybrid(n: int, a: List[int]) -> List[int]:
    m = n - 1
    if m <= 0:
        return []
    B = int(n ** 0.5)
    if B < 1:
        B = 1
    if B > m:
        B = m
    ans = [0] * (n + 1)  # 1..m used
    # Small k directly
    for k in range(1, B + 1):
        c = 0
        for v in range(2, n + 1):
            p = (v - 2) // k + 1
            if a[v - 1] < a[p - 1]:
                c += 1
        ans[k] = c
    # Large k via quotient grouping + difference array
    if B < m:
        diff = [0] * (m + 2)
        for v in range(2, n + 1):
            x = v - 2
            k = B + 1
            while k <= m:
                t = 0 if x == 0 else x // k
                if t == 0:
                    r = m
                else:
                    r = x // t
                    if r > m:
                        r = m
                p = t + 1
                if a[v - 1] < a[p - 1]:
                    diff[k] += 1
                    diff[r + 1] -= 1
                k = r + 1
        run = 0
        for k in range(B + 1, m + 1):
            run += diff[k]
            ans[k] = run
    return ans[1:]

def solve_all():
    inp = read_input()
    if inp is None:
        return None
    n, a = inp
    res = solve_case_hybrid(n, a)
    print(" ".join(map(str, res)))
    return res

def _self_test():
    # Quick sanity asserts
    assert solve_case_hybrid(2, [0, 0]) == [0]
    assert solve_case_hybrid(5, [5, 4, 3, 2, 1]) == [4, 4, 4, 4]
    assert solve_case_hybrid(5, [1, 2, 3, 4, 5]) == [0, 0, 0, 0]

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count, for each $k$, how many nodes violate $a_v \ge a_{p_k(v)}$ (i.e., have $a_v<a_{p_k(v)}$) in the $k$-ary heap parent mapping.}
\WHY{This is a classic application of divisor/quotient grouping and difference arrays to achieve near $O(n\sqrt{n})$ performance across many parameters.}
\CHECKLIST{
\begin{bullets}
\item Remember $p_k(v)=\lfloor (v-2)/k \rfloor + 1$ for $v\ge 2$.
\item Group $k$ by constant quotient of $(v-2)/k$.
\item Use difference array over $k$ to add whole intervals at once.
\item Split small $k$ direct, large $k$ grouped.
\item Finalize with a prefix sum over $k$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=2$ (only $k=1$).
\item All $a_i$ equal (all zero counts).
\item Strictly increasing $a$ (no violations).
\item Strictly decreasing $a$ (max violations).
\item $v=2$ where $v-2=0$ implies $p_k(2)=1$ for all $k$.
\item Very large $k$ where $k\ge v-1$ yields $p_k(v)=1$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one in parent formula; indices are $1$-based while arrays are $0$-based in code.
\item Forgetting to cap $r=\min(m,\lfloor x/t\rfloor)$ for the last interval.
\item Missing the $t=0$ case which should extend to $k=m$.
\item Writing to the wrong ends in the difference array ($D[r+1]$ must decrement).
\item Using $B$ larger than $m=n-1$ in the hybrid split.
\item Integer division precedence mistakes; always use parentheses for clarity.
\end{bullets}
}
\FAILMODES{A naive $O(n^2)$ solution times out on large $n$. Grouping without handling $t=0$ or not capping $r$ produces index errors or wrong counts.}
\ELI{Each node $v$ has only a few distinct parents as $k$ varies. We add $v$'s contribution over whole ranges of $k$ at once, then sum up to get all answers in one pass.}
\NotePages{3}

\end{document}