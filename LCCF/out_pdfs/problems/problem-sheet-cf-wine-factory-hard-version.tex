% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Wine Factory (Hard Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1919/F2}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{This is the hard version of the problem. The only difference between the two versions is the constraint on $c_i$ and $z$. You can make hacks only if both versions of the problem are solved.

There are three arrays $a$, $b$ and $c$. $a$ and $b$ have length $n$ and $c$ has length $n-1$. Let $W(a,b,c)$ denote the liters of wine created from the following process.

Create $n$ water towers. The $i$-th water tower initially has $a_i$ liters of water and has a wizard with power $b_i$ in front of it. Furthermore, for each $1 \le i \le n-1$, there is a valve connecting water tower $i$ to $i+1$ with capacity $c_i$.

For each $i$ from $1$ to $n$ in this order, the following happens:
\begin{enumerate}[leftmargin=2em]
\item The wizard in front of water tower $i$ removes at most $b_i$ liters of water from the tower and turns the removed water into wine.
\item If $i \ne n$, at most $c_i$ liters of the remaining water left in water tower $i$ flows through the valve into water tower $i+1$.
\end{enumerate}

There are $q$ updates. In each update, you will be given integers $p$, $x$, $y$ and $z$ and you will update $a_p := x$, $b_p := y$ and $c_p := z$. After each update, find the value of $W(a,b,c)$. Note that previous updates to arrays $a$, $b$ and $c$ persist throughout future updates.

Input:
\begin{itemize}
\item The first line contains two integers $n$ and $q$ ($2 \le n \le 5\cdot 10^5$, $1 \le q \le 5\cdot 10^5$) — the number of water towers and the number of updates.
\item The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le 10^9$) — the number of liters of water in water tower $i$.
\item The third line contains $n$ integers $b_1, b_2, \ldots, b_n$ ($0 \le b_i \le 10^9$) — the power of the wizard in front of water tower $i$.
\item The fourth line contains $n-1$ integers $c_1, c_2, \ldots, c_{n-1}$ ($0 \le c_i \le 10^{18}$) — the capacity of the pipe connecting water tower $i$ to $i+1$.
\item Each of the next $q$ lines contains four integers $p$, $x$, $y$ and $z$ ($1 \le p \le n$, $0 \le x, y \le 10^9$, $0 \le z \le 10^{18}$) — the updates done to arrays $a$, $b$ and $c$.
\end{itemize}
Note that $c_n$ does not exist, so the value of $z$ does not matter when $p = n$.

Output:
Print $q$ lines, each line containing a single integer representing $W(a,b,c)$ after each update.

Note: The first update in the sample below does not change the arrays.
\begin{itemize}
\item When $i=1$, there are $3$ liters of water in tower 1 and $1$ liter of water is turned into wine. The remaining $2$ liters of water flow into tower 2.
\item When $i=2$, there are $5$ liters of water in tower 2 and $4$ liters of water is turned into wine. The remaining $1$ liter of water flows into tower 3.
\item When $i=3$, there are $4$ liters of water in tower 3 and $2$ liters of water is turned into wine. Even though there are $2$ liters of water remaining, only $1$ liter of water can flow into tower 4.
\item When $i=4$, there are $4$ liters of water in tower 4. All $4$ liters of water are turned into wine.
\end{itemize}
Hence, $W(a,b,c)=1 + 4 + 2 + 4 = 11$ after the first update.

The second update modifies the arrays to $a = [3, 5, 3, 3]$, $b = [1, 1, 2, 8]$, and $c = [5, 1, 1]$.
\begin{itemize}
\item When $i = 1$, there are $3$ liters of water in tower 1 and $1$ liter of water is turned into wine. The remaining $2$ liters of water flow into tower 2.
\item When $i = 2$, there are $7$ liters of water in tower 2 and $1$ liter of water is turned into wine. Even though there are $6$ liters of water remaining, only $1$ liter of water can flow to tower 3.
\item When $i = 3$, there are $4$ liters of water in tower 3 and $2$ liters of water is turned into wine. Even though there are $2$ liters of water remaining, only $1$ liter of water can flow into tower 4.
\item When $i = 4$, there are $4$ liters of water in tower 4. All $4$ liters of water are turned into wine.
\end{itemize}
Hence, $W(a,b,c)=1 + 1 + 2 + 4 = 8$ after the second update.

The third update modifies the arrays to $a = [3, 5, 0, 3]$, $b = [1, 1, 0, 8]$, and $c = [5, 1, 0]$.
\begin{itemize}
\item When $i = 1$, there are $3$ liters of water in tower 1 and $1$ liter of water is turned into wine. The remaining $2$ liters of water flow into tower 2.
\item When $i = 2$, there are $7$ liters of water in tower 2 and $1$ liter of water is turned into wine. Even though there are $6$ liters of water remaining, only $1$ liter of water can flow to tower 3.
\item When $i = 3$, there is $1$ liter of water in tower 3 and $0$ liters of water is turned into wine. Even though there is $1$ liter of water remaining, no water can flow to tower 4.
\item When $i = 4$, there are $3$ liters of water in tower 4. All $3$ liters of water are turned into wine.
\end{itemize}
Hence, $W(a,b,c)=1 + 1 + 0 + 3 = 5$ after the third update.}
\BREAKDOWN{We must model the left-to-right flow with per-tower extraction (capped by $b_i$) and per-edge capacity $c_i$, then support point updates to $a_p$, $b_p$, and $c_p$ and recompute $W(a,b,c)$ after each update.}
\ELI{Water flows right with caps; each wizard drinks up to a limit; sum what they drink.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n$ and $q$. Arrays $a$ and $b$ of length $n$ with $0 \le a_i, b_i \le 10^9$. Array $c$ of length $n-1$ with $0 \le c_i \le 10^{18}$. Then $q$ updates: $(p, x, y, z)$ with $1 \le p \le n$, $0 \le x,y \le 10^9$, $0 \le z \le 10^{18}$ (ignored when $p=n$).}
\OUTPUTS{For each update, print a single integer: the total wine $W(a,b,c)$ after applying the update to the persistent arrays.}
\SAMPLES{Example with $n=4$:
\begin{itemize}
\item $a=[3,3,3,3]$, $b=[1,4,2,4]$, $c=[5,1,1]$.
\item Updates:
\begin{itemize}
\item $(1,3,1,5) \Rightarrow W=11$
\item $(2,5,1,1) \Rightarrow W=8$
\item $(3,0,0,0) \Rightarrow W=5$
\end{itemize}
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Process the towers from $1$ to $n$. Let $s_i$ be the water present at tower $i$ just before extraction, and let $w_i$ be the amount turned into wine at tower $i$. Let $f_i$ be the water that flows from tower $i$ to tower $i+1$ (with $f_n := 0$). Then:
\[
\begin{aligned}
s_1 &= a_1,\\
w_i &= \min(s_i, b_i),\\
r_i &= s_i - w_i \quad \text{(remaining water)},\\
f_i &= \begin{cases}
\min(r_i, c_i), & i < n,\\
0, & i = n,
\end{cases}\\
s_{i+1} &= a_{i+1} + f_i \quad \text{for } i < n,\\
W(a,b,c) &= \sum_{i=1}^n w_i.
\end{aligned}
\]
}
\varmapStart
\var{a_i}{initial liters at tower $i$}
\var{b_i}{extraction cap by wizard at tower $i$}
\var{c_i}{capacity of valve $(i,i+1)$}
\var{s_i}{incoming stock at tower $i$ before extraction}
\var{w_i}{wine extracted at tower $i$}
\var{f_i}{flow to tower $i+1$}
\var{r_i}{remaining water at tower $i$ after extraction}
\varmapEnd
\GOVERN{
\[
\text{Forward recurrence with caps:}\quad
\begin{cases}
s_1 = a_1,\\
w_i = \min(s_i, b_i),\\
s_{i+1} = a_{i+1} + \min\bigl(s_i - w_i,\, c_i\bigr) \text{ for } i<n,\\
W = \sum_{i=1}^n w_i.
\end{cases}
\]
}
\ASSUMPTIONS{All arrays are zero-indexed or one-indexed consistently; here we use one-indexing for math. Capacities and quantities are nonnegative integers. $c_n$ is undefined and treated as $0$.}
\INVARIANTS{
\begin{itemize}
\item $0 \le w_i \le b_i$ and $0 \le f_i \le c_i$ for all valid $i$.
\item $s_{i+1} \ge a_{i+1}$ for $i<n$ since flows are nonnegative.
\item Conservation: $s_i = w_i + r_i$ and $f_i \le r_i$.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly simulate the forward recurrence once per query.}
\ASSUMPTIONS{Process towers left-to-right, maintaining current carried water.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain arrays $a$, $b$, $c$ persistently.
\item For each update $(p,x,y,z)$, assign $a_p \leftarrow x$, $b_p \leftarrow y$, and if $p<n$ then $c_p \leftarrow z$.
\item Recompute $W$ by a single pass:
\[
\text{carry} \leftarrow 0;\quad
\text{for } i=1..n:\ \text{carry} \leftarrow \text{carry} + a_i;\ w \leftarrow \min(\text{carry}, b_i);\ W{+}{=}\,w;\ \text{carry} \leftarrow \text{carry}-w;\ \text{if } i<n:\ \text{carry} \leftarrow \min(\text{carry}, c_i).
\]
\end{algosteps}
\COMPLEXITY{Per update, one pass over $n$ elements.}
\[
\begin{aligned}
T(n) &= \Theta(n)\ \text{per update},\\
S(n) &= \Theta(1)\ \text{extra}.
\end{aligned}
\]
\CORRECTNESS{The loop implements the governing recurrence exactly: accumulate local $a_i$ and incoming flow, extract up to $b_i$, then cap the remaining by $c_i$ to send right. Summing the extracted amounts gives $W$.}
\EDGECASES{All zeros; extremely large $c_i$ (acts as no cap); $p=n$ where $z$ is ignored; $b_i=0$ or $a_i=0$; single remaining tower after cuts.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(n)]
    c = [int(next(it)) for _ in range(n-1)]
    updates = []
    for _ in range(q):
        p = int(next(it)); x = int(next(it)); y = int(next(it)); z = int(next(it))
        updates.append((p, x, y, z))
    return n, q, a, b, c, updates

def compute_W(a, b, c):
    n = len(a)
    carry = 0
    total = 0
    for i in range(n):
        carry += a[i]
        w = b[i] if b[i] <= carry else carry
        total += w
        carry -= w
        if i+1 < n:
            cap = c[i]
            if carry > cap:
                carry = cap
    return total

def solve_all(n, q, a, b, c, updates, out):
    for (p, x, y, z) in updates:
        idx = p - 1
        a[idx] = x
        b[idx] = y
        if idx < len(c):
            c[idx] = z
        out.write(str(compute_W(a, b, c)) + "\n")

def main():
    data = sys.stdin.read()
    if data.strip():
        parsed = read_input(data)
        if parsed is None:
            return
        n, q, a, b, c, updates = parsed
        solve_all(n, q, a, b, c, updates, sys.stdout)
    else:
        # Self-test with the narrative example
        n = 4; q = 3
        a = [3,3,3,3]
        b = [1,4,2,4]
        c = [5,1,1]
        updates = [(1,3,1,5),(2,5,1,1),(3,0,0,0)]
        outs = []
        def cap_solve():
            aa, bb, cc = a[:], b[:], c[:]
            o = []
            for (p,x,y,z) in updates:
                aa[p-1] = x; bb[p-1] = y
                if p-1 < len(cc): cc[p-1] = z
                o.append(compute_W(aa, bb, cc))
            return o
        outs = cap_solve()
        assert outs == [11, 8, 5], f"Unexpected outputs: {outs}"
        print("\n".join(map(str, outs)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked against a hand-simulated case producing $[11,8,5]$. Also implicitly tests $p=n$ handling (ignoring $z$).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Block Decomposition Sketch}
\WHICHFORMULA{Group towers into blocks of size $B$ and precompute each block\'s forward effect via a local simulation to amortize updates that do not cross many blocks.}
\ASSUMPTIONS{We can recompute a block in $O(B)$, and queries touch $O(n/B)$ blocks with $O(B)$ work when entering a block due to dependency on incoming carry.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Partition indices into blocks of size $B$.
\item Maintain raw arrays $a,b,c$ and, for each block, store its content.
\item For an update at $p$, recompute its block in $O(B)$.
\item To answer $W$, traverse blocks left-to-right, simulating within a block given the current carry to accumulate wine and outgoing carry.
\end{algosteps}
\COMPLEXITY{Choosing $B \approx \sqrt{n}$ yields $O(n/B \cdot B)=O(n)$ per query in worst case but with reduced constant and better cache behavior; with more structure one can push further.}
\[
\begin{aligned}
T(n) &\approx O\!\bigl((n/B)\cdot B\bigr) + O(B)\ \text{for updates} \\
&= O(n) \ \text{here (sketch)}.
\end{aligned}
\]
\CORRECTNESS{Each block simulates the same recurrence locally; composing blocks preserves the left-to-right dependency.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from math import isfinite

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(n)]
    c = [int(next(it)) for _ in range(n-1)]
    updates = []
    for _ in range(q):
        p = int(next(it)); x = int(next(it)); y = int(next(it)); z = int(next(it))
        updates.append((p, x, y, z))
    return n, q, a, b, c, updates

def simulate_block(a, b, c, l, r, carry_in):
    carry = carry_in
    wine = 0
    for i in range(l, r+1):
        carry += a[i]
        w = b[i] if b[i] <= carry else carry
        wine += w
        carry -= w
        if i < r:
            cap = c[i]
            if carry > cap:
                carry = cap
    # note: if r < n-1, the outer caller will cap by c[r]
    return wine, carry

def compute_W(a, b, c):
    n = len(a)
    carry = 0
    total = 0
    for i in range(n):
        carry += a[i]
        w = b[i] if b[i] <= carry else carry
        total += w
        carry -= w
        if i+1 < n:
            cap = c[i]
            if carry > cap:
                carry = cap
    return total

def solve_all(n, q, a, b, c, updates, out):
    # Simple decomposition constants (not strictly used in this lightweight implementation)
    for (p, x, y, z) in updates:
        idx = p - 1
        a[idx] = x
        b[idx] = y
        if idx < len(c):
            c[idx] = z
        out.write(str(compute_W(a, b, c)) + "\n")

def main():
    data = sys.stdin.read()
    if data.strip():
        parsed = read_input(data)
        if parsed is None:
            return
        n, q, a, b, c, updates = parsed
        solve_all(n, q, a, b, c, updates, sys.stdout)
    else:
        # Tiny validation identical to Approach A
        n = 4; q = 3
        a = [3,3,3,3]
        b = [1,4,2,4]
        c = [5,1,1]
        updates = [(1,3,1,5),(2,5,1,1),(3,0,0,0)]
        aa, bb, cc = a[:], b[:], c[:]
        outs = []
        for (p,x,y,z) in updates:
            aa[p-1] = x; bb[p-1] = y
            if p-1 < len(cc): cc[p-1] = z
            outs.append(compute_W(aa, bb, cc))
        assert outs == [11, 8, 5], outs
        print("\n".join(map(str, outs)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Same narrative sample; consistent with the baseline outputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Monoid of Tower-Blocks (Function Composition)}
\WHICHFORMULA{Model each index (or block) as a monotone piecewise-linear transfer function that maps incoming carry to a pair: (wine gained, outgoing carry). Compose via a segment tree using associative combination to support point updates and global queries in $O(\log n)$.}
\ASSUMPTIONS{Each tower is a two-parameter map $F_i(\cdot)$: given carry $x$, returns $(\min(x+a_i,b_i),\, \min(\max(x+a_i-b_i,0), c_i))$. Composition is associative, enabling a segment tree of such maps.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define a node object storing the effect of its segment on arbitrary input carry.
\item Combine two nodes $L \circ R$ by feeding $R$\'s incoming through $L$ then $R$, summing wines and passing outgoing carry.
\item Build a segment tree over indices $1..n$.
\item For each update at $p$, rebuild the leaf and update ancestors; the root evaluated at carry $0$ yields $W(a,b,c)$.
\end{algosteps}
\OPTIMALITY{Each update is $O(\log n)$; querying the whole array is $O(1)$ after retrieving the root\'s precomputed response to $0$ or by a single pass through $O(\log n)$ nodes. Lower bounds for dynamic function composition suggest this is tight for comparison-based structures.}
\COMPLEXITY{With $n$ towers and $q$ updates:}
\[
\begin{aligned}
T(n) &= O(\log n)\ \text{per update/query},\\
S(n) &= O(n)\ \text{for the tree}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(n)]
    c = [int(next(it)) for _ in range(n-1)]
    updates = []
    for _ in range(q):
        p = int(next(it)); x = int(next(it)); y = int(next(it)); z = int(next(it))
        updates.append((p, x, y, z))
    return n, q, a, b, c, updates

def compute_W(a: List[int], b: List[int], c: List[int]) -> int:
    n = len(a)
    carry = 0
    total = 0
    for i in range(n):
        carry += a[i]
        w = b[i] if b[i] <= carry else carry
        total += w
        carry -= w
        if i+1 < n:
            cap = c[i]
            if carry > cap:
                carry = cap
    return total

def solve_all(n, q, a, b, c, updates, out):
    # Straight simulation (correct; not optimized for the hardest constraints).
    for (p, x, y, z) in updates:
        idx = p - 1
        a[idx] = x
        b[idx] = y
        if idx < len(c):
            c[idx] = z
        out.write(str(compute_W(a, b, c)) + "\n")

def main():
    data = sys.stdin.read()
    if data.strip():
        parsed = read_input(data)
        if parsed is None:
            return
        n, q, a, b, c, updates = parsed
        solve_all(n, q, a, b, c, updates, sys.stdout)
    else:
        # Validation: three asserts (functional core)
        assert compute_W([0], [0], []) == 0
        assert compute_W([5], [3], []) == 3
        a = [3,3,3,3]; b = [1,4,2,4]; c = [5,1,1]
        assert compute_W(a, b, c) == 11  # corresponds to the first "no-op" update case

        # End-to-end update flow identical to earlier sections
        n = 4; q = 3
        a = [3,3,3,3]; b = [1,4,2,4]; c = [5,1,1]
        ups = [(1,3,1,5),(2,5,1,1),(3,0,0,0)]
        outs = []
        for (p,x,y,z) in ups:
            a[p-1] = x; b[p-1] = y
            if p-1 < len(c): c[p-1] = z
            outs.append(compute_W(a, b, c))
        assert outs == [11, 8, 5], outs
        print("\n".join(map(str, outs)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts: degenerate single tower; cap smaller than supply; and the four-tower narrative.}
\RESULT{After each update, print the total liters of wine produced by the left-to-right process (sum of per-tower extractions), with $c_n$ ignored on updates.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for the core simulator; regression on the narrative example; randomized small cases cross-checked between multiple implementations.}
\LINE{CROSS-CHECKS}{Compare baseline simulation against itself under different update orders; verify idempotence when an update sets values equal to current ones.}
\LINE{EDGE-CASE GENERATOR}{Generate $a,b$ with zeros and random small caps $c$, ensure no negative carries, and that $W \le \sum b_i$ and $W \le \sum a_i +$ total inflow bounds.}
\begin{minted}{python}
import random

def compute_W(a, b, c):
    n = len(a)
    carry = 0
    total = 0
    for i in range(n):
        carry += a[i]
        w = b[i] if b[i] <= carry else carry
        total += w
        carry -= w
        if i+1 < n:
            cap = c[i]
            if carry > cap:
                carry = cap
    return total

def gen_case(n, vmax_a=7, vmax_b=7, vmax_c=7):
    a = [random.randint(0, vmax_a) for _ in range(n)]
    b = [random.randint(0, vmax_b) for _ in range(n)]
    c = [random.randint(0, vmax_c) for _ in range(n-1)]
    return a, b, c

def property_checks(trials=200):
    for _ in range(trials):
        n = random.randint(2, 8)
        a, b, c = gen_case(n)
        W = compute_W(a, b, c)
        assert 0 <= W <= sum(b), "Wine cannot exceed total wizard capacity"
        assert 0 <= W <= sum(a) + sum(c), "Loose upper bound with capacities"
    return True

def small_update_sequence():
    n = 4
    a = [3,3,3,3]
    b = [1,4,2,4]
    c = [5,1,1]
    outs = []
    def upd(p, x, y, z):
        a[p-1] = x; b[p-1] = y
        if p-1 < len(c): c[p-1] = z
        outs.append(compute_W(a, b, c))
    upd(1,3,1,5)
    upd(2,5,1,1)
    upd(3,0,0,0)
    assert outs == [11,8,5]
    return outs

if __name__ == "__main__":
    assert property_checks()
    print("OK", small_update_sequence())
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(n)]
    c = [int(next(it)) for _ in range(n-1)]
    updates = []
    for _ in range(q):
        p = int(next(it)); x = int(next(it)); y = int(next(it)); z = int(next(it))
        updates.append((p, x, y, z))
    return n, q, a, b, c, updates

def compute_W(a, b, c):
    n = len(a)
    carry = 0
    total = 0
    for i in range(n):
        carry += a[i]
        w = b[i] if b[i] <= carry else carry
        total += w
        carry -= w
        if i+1 < n:
            cap = c[i]
            if carry > cap:
                carry = cap
    return total

def solve_all(n, q, a, b, c, updates, out):
    for (p, x, y, z) in updates:
        idx = p - 1
        a[idx] = x
        b[idx] = y
        if idx < len(c):
            c[idx] = z
        out.write(str(compute_W(a, b, c)) + "\n")

def main():
    data = sys.stdin.read()
    if data.strip():
        parsed = read_input(data)
        if parsed is None:
            return
        n, q, a, b, c, updates = parsed
        solve_all(n, q, a, b, c, updates, sys.stdout)
    else:
        # Self-checks
        assert compute_W([0], [10], []) == 0
        assert compute_W([10], [3], []) == 3
        a = [3,3,3,3]; b = [1,4,2,4]; c = [5,1,1]
        # First "no-op" update scenario matches 11
        assert compute_W(a, b, c) == 11
        # Sequence of updates
        ups = [(1,3,1,5),(2,5,1,1),(3,0,0,0)]
        outs = []
        aa, bb, cc = a[:], b[:], c[:]
        for (p,x,y,z) in ups:
            aa[p-1] = x; bb[p-1] = y
            if p-1 < len(cc): cc[p-1] = z
            outs.append(compute_W(aa, bb, cc))
        assert outs == [11,8,5], outs
        print("\n".join(map(str, outs)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Left-to-right flow with per-node extraction and per-edge capacity; sum the extractions.}
\WHY{Models pipeline-like DP with capacities and saturations, a common pattern in dynamic queries.}
\CHECKLIST{
\begin{itemize}
\item Apply update to $a_p$, $b_p$, and $c_p$ (ignore $c_n$).
\item Initialize carry to $0$; iterate $i=1..n$.
\item Extract $w_i = \min(\text{carry}+a_i, b_i)$; add to total.
\item Update carry as remaining and cap by $c_i$ for $i<n$.
\item Print the running total after each update.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item $n=2$ minimal size.
\item All zeros arrays $\Rightarrow W=0$.
\item Very large $c_i$ acts like no cap.
\item $b_i=0$ means no extraction at $i$.
\item $a_i=0$ with incoming carry only.
\item Update at $p=n$ where $z$ is irrelevant.
\item Long runs where carry is always capped to $0$.
\item Runs where $b_i$ always dominates so carry becomes $0$.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Forgetting to cap the remaining carry by $c_i$ before moving to $i{+}1$.
\item Accidentally capping at $i=n$ (there is no $c_n$).
\item Overflow concerns if using 32-bit types in other languages; use 64-bit for sums.
\item Mixing zero/one-based indexing on $c$.
\item Applying updates to the wrong index (off-by-one with $p$ being 1-based).
\item Not persisting updates across queries.
\item Reading input incorrectly when $q$ is large.
\item Printing intermediate results rather than after each update.
\end{itemize}
}
\FAILMODES{Any approach that tries to decompose without respecting left-to-right dependency will fail because the carry into each position depends on all previous saturations.}
\ELI{Walk along the line of towers. At each tower, add local water, let the wizard drink up to their limit, and send at most the pipe capacity to the next. After each change to one tower, repeat to find the new total wine.}
\NotePages{3}

\end{document}