% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Sasha and a Very Easy Test}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1109/E}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{Egor likes math, and not so long ago he got the highest degree of recognition in the math community — Egor became a red mathematician. In this regard, Sasha decided to congratulate Egor and give him a math test as a present. This test contains an array $a$ of integers of length $n$ and exactly $q$ queries. Queries were of three types:

1. ``1 $l$ $r$ $x$'' — multiply each number on the range from $l$ to $r$ by $x$.
2. ``2 $p$ $x$'' — divide the number at the position $p$ by $x$ (divisibility guaranteed).
3. ``3 $l$ $r$'' — find the sum of all elements on the range from $l$ to $r$.

The sum can be big, so Sasha asked Egor to calculate the sum modulo some integer $mod$.

But since Egor is a red mathematician, he does not have enough time to solve such easy tasks, at the same time he does not want to anger Sasha, that is why he asked you to help and to find answers for all queries of the $3$-rd type.

Input:
The first line contains two integers $n$ and $mod$ ($1 \le n \le 10^5$, $2 \le mod \le 10^9 + 9$) — the size of the array and the number $mod$.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^5$) — the array itself.

The third line contains one integer $q$ ($1 \le q \le 10^5$) — the number of queries.

Next $q$ lines satisfy one of the following formats:
\begin{itemize}
\item 1 $l$ $r$ $x$ ($1 \le l \le r \le n$, $1 \le x \le 10^5$), means that you must multiply each number on the range from $l$ to $r$ by $x$.
\item 2 $p$ $x$ ($1 \le p \le n$, $1 \le x \le 10^5$), means that you must divide number at the position $p$ by $x$ (divisibility guaranteed).
\item 3 $l$ $r$ ($1 \le l \le r \le n$), means that you must find the sum of elements on the range from $l$ to $r$.
\end{itemize}
It is guaranteed that there is at least one query of the $3$-rd type.

Output:
For each query of the $3$-rd type print the answer on a new line modulo $mod$.

Note:
The first example:

Initial array is $[4, 1, 2, 3, 5]$.

\begin{itemize}
\item In the first query, you must calculate the sum of the whole array, it is equal to $(4 + 1 + 2 + 3 + 5) \bmod 100 = 15 \bmod 100 = 15$.
\item In the second query, you must multiply each number on the range from $2$ to $3$ by $6$. The resulting array will be $[4, 6, 12, 3, 5]$.
\item In the third query, you must calculate the sum on the range from $1$ to $2$, it is equal to $(4 + 6) \bmod 100 = 10 \bmod 100 = 10$.
\item In the fourth query, you must multiply each number on the range from $1$ to $5$ by $1$. Multiplication by $1$ does not affect the array.
\item In the fifth query, you must calculate the sum on the range from $2$ to $4$, it is equal to $(6 + 12 + 3) \bmod 100 = 21 \bmod 100 = 21$.
\end{itemize}

The second example:

Initial array is $[4, 1, 2, 3, 5]$.

\begin{itemize}
\item In the first query, you must calculate the sum of the whole array, it is equal to $(4 + 1 + 2 + 3 + 5) \bmod 2 = 15 \bmod 2 = 1$.
\item In the second query, you must multiply each number on the range from $2$ to $3$ by $6$. The resulting array will be $[4, 6, 12, 3, 5]$.
\item In the third query, you must calculate the sum on the range from $1$ to $2$, it is equal to $(4 + 6) \bmod 2 = 10 \bmod 2 = 0$.
\item In the fourth query, you must multiply each number on the range from $1$ to $5$ by $1$. Multiplication by $1$ does not affect the array.
\item In the fifth query, you must calculate the sum on the range from $2$ to $4$, it is equal to $(6 + 12 + 3) \bmod 2 = 21 \bmod 2 = 1$.
\item In the sixth query, you must divide number at the position $3$ by $4$. $\tfrac{12}{4} = 3$, so the array will be $[4, 6, 3, 3, 5]$.
\item In the seventh query, you must calculate the sum on the range form $3$ to $4$, it is equal to $(3 + 3) \bmod 2 = 6 \bmod 2 = 0$.
\end{itemize}}
\BREAKDOWN{Maintain range multiplications, point divisions and range sum modulo arbitrary $mod$. Split each integer into a part coprime with $mod$ and prime-power part using only primes dividing $mod$; handle range updates lazily for sums while keeping point-resolvable state for divisions.}
\ELI{Separate the number into ``safe'' part (coprime with $mod$) and ``problematic'' prime powers of primes dividing $mod$; multiply ranges lazily and recompute a point exactly when it is divided.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{From stdin:
\begin{bullets}
\item $n$, $mod$.
\item Array $a_1,\ldots,a_n$.
\item $q$.
\item Then $q$ queries of types: $1~l~r~x$, $2~p~x$, $3~l~r$.
\end{bullets}}
\OUTPUTS{For each type-$3$ query, output the sum $\sum_{i=l}^r a_i \bmod mod$ on its own line.}
\SAMPLES{Example 1:
\begin{BreakableEquation*}
\begin{aligned}
n&=5,\quad mod=100,\\
a&=[4,1,2,3,5],\\
\text{queries: }&(3~1~5),(1~2~3~6),(3~1~2),(1~1~5~1),(3~2~4)\\
\text{answers: }&15,~10,~21
\end{aligned}
\end{BreakableEquation*}
Example 2:
\begin{BreakableEquation*}
\begin{aligned}
n&=5,\quad mod=2,\\
a&=[4,1,2,3,5],\\
\text{queries: }&(3~1~5),(1~2~3~6),(3~1~2),(1~1~5~1),(3~2~4),(2~3~4),(3~3~4)\\
\text{answers: }&1,~0,~1,~0
\end{aligned}
\end{BreakableEquation*}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $M=mod$ and let $P=\{p_1,\ldots,p_k\}$ be the set of distinct prime divisors of $M$. For each array entry $a_i$, write
\begin{BreakableEquation*}
a_i = r_i \cdot \prod_{j=1}^k p_j^{e_{i,j}},
\end{BreakableEquation*}
where $\gcd(r_i,M)=1$ and all $e_{i,j}\ge 0$. A range multiplication by $x$ updates $r_i$ by its $M$-coprime part $x'$ and adds exponents corresponding to primes in $P$ present in $x$. A point division by $x$ does the inverse at a single index. Query asks $\sum_{i=l}^r a_i \bmod M$.}
\varmapStart
\var{M}{the modulus}
\var{P}{distinct primes dividing $M$}
\var{r_i}{part of $a_i$ coprime with $M$}
\var{e_{i,j}}{exponent of $p_j$ in $a_i$}
\var{x'}{part of $x$ coprime with $M$}
\var{X_M}{$M$-prime part of $x$: product of $p\in P$ to their exponents in $x$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
a_i &\equiv r_i \cdot \prod_{j=1}^k p_j^{e_{i,j}} \pmod M,\\
\text{Multiply } [l,r] \text{ by } x:\quad
r_i&\leftarrow r_i\cdot x' \ (\bmod M),\quad
e_{i,j}\leftarrow e_{i,j}+v_{p_j}(x),\\
\text{Divide } i=p \text{ by } x:\quad
r_p&\leftarrow r_p\cdot (x')^{-1} \ (\bmod M),\quad
e_{p,j}\leftarrow e_{p,j}-v_{p_j}(x).
\end{aligned}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item Distinct prime count $k$ of $M$ is small ($k\le 9$ for $M\le 10^9+9$).
\item $x'\perp M$ so $(x')^{-1}\bmod M$ exists (extended Euclid).
\item Divisions are exact in $\mathbb{Z}$; exponent decrements never go negative.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item $\gcd(r_i,M)=1$ always holds by construction.
\item $a_i\bmod M$ equals current $r_i$ times prime powers from $P$ with exponents $e_{i,\cdot}$.
\item Range multiply by $x$ multiplies segment sum by $x \bmod M$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Apply each update directly to the array in $\mathcal{O}(r-l+1)$ and answer queries by summing.}
\ASSUMPTIONS{Use Python big integers and reduce modulo at the end.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Store the array as Python ints.
\item For type 1: loop $i\in[l,r]$, set $a_i\gets a_i\cdot x$.
\item For type 2: set $a_p\gets a_p/x$ (exact).
\item For type 3: compute $\sum_{i=l}^r a_i \bmod M$ naively.
\end{algosteps}
\COMPLEXITY{This is too slow for $n,q\le 10^5$.}
\[
\begin{aligned}
T(n) &= \Theta\Big(\sum \text{segment lengths of updates and queries}\Big) = \Theta(nq)\ \text{worst-case},\\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Trivially correct as it mirrors the definition.}
\EDGECASES{Large segments; repeated multiplies overflow without modulo; but Python bignums handle it, still too slow.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); mod = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    qs = []
    for _ in range(q):
        t = int(next(it))
        if t == 1:
            l = int(next(it)); r = int(next(it)); x = int(next(it))
            qs.append((t, l, r, x))
        elif t == 2:
            p = int(next(it)); x = int(next(it))
            qs.append((t, p, x))
        else:
            l = int(next(it)); r = int(next(it))
            qs.append((t, l, r))
    return n, mod, a, q, qs

def solve_all(n, mod, a, q, qs):
    out = []
    for qu in qs:
        if qu[0] == 1:
            _, l, r, x = qu
            for i in range(l-1, r):
                a[i] *= x
        elif qu[0] == 2:
            _, p, x = qu
            a[p-1] //= x
        else:
            _, l, r = qu
            s = 0
            for i in range(l-1, r):
                s += a[i]
            out.append(str(s % mod))
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    n, mod, a, q, qs = read_input(data)
    print(solve_all(n, mod, a, q, qs))

if __name__ == "__main__":
    # Basic test asserts (tiny)
    tdata = """5 100
4 1 2 3 5
5
3 1 5
1 2 3 6
3 1 2
1 1 5 1
3 2 4
"""
    n, mod, a, q, qs = read_input(tdata)
    ans = solve_all(n, mod, a, q, qs)
    assert ans.strip().split() == ["15", "10", "21"]
    # Do not run main on tests
    # main()
    pass
\end{minted}
\VALIDATION{Two tiny checks included in asserts; correctness obvious for small data but performance unacceptable.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Segment Tree for Sums, Direct Point Division}
\WHICHFORMULA{Use a lazy segment tree for range multiply and range sum. Handle point division by recomputing the exact value at that position by tracking factorization against $M$.}
\ASSUMPTIONS{Maintain for each $i$ the coprime part $r_i$ modulo $M$ and exponents for primes dividing $M$ with range-add support; for coprime multipliers, maintain a multiplicative BIT for range-multiply and point-query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Factor $M$ to get $P=\{p_j\}$.
\item Precompute SPF up to $10^5$ to factor $a_i$ and $x$ fast.
\item Build:
  \begin{bullets}
  \item Segment tree over values $a_i\bmod M$ with lazy range-multiply.
  \item For each $p_j\in P$, a Fenwick tree supporting range-add and point-query of $e_{i,j}$.
  \item One multiplicative Fenwick for range-multiply by coprime parts and point product query for $r_i$ multiplier.
  \end{bullets}
\item For type 1 $(l,r,x)$: split $x$ into coprime part $x'$ and exponents on $P$; multiply segment sum by $x\bmod M$; apply range-add of exponents; apply multiplicative BIT update by $x'$.
\item For type 2 $(p,x)$: split $x$; decrement exponents at point; update base $r_p$ by multiplying with $(x')^{-1}$; recompute $a_p$ as $r_p\cdot \prod p_j^{e_{p,j}} \bmod M$ and set leaf by point-assign.
\item For type 3: query segment sum.
\end{algosteps}
\COMPLEXITY{Beats baseline by logarithmic factors using trees.}
\[
\begin{aligned}
T(n) &= \mathcal{O}\big((\log n) \text{ per update/query} + k\log n \text{ for exponent updates} + k\log E \text{ per division}\big),\\
\end{aligned}
\]
where $k=|\{p\mid M\}| \le 9$ and $E$ is a typical exponent size.
\CORRECTNESS{The decomposition $a_i=r_i\prod p^{e_{i}}$ is unique; range multiplications distribute over sums modulo $M$; divisions are applied exactly at the point by updating $r_i$ and $e_{i}$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
import sys
from math import gcd

def egcd(a, b):
    if b == 0:
        return (a, 1, 0)
    g, x1, y1 = egcd(b, a % b)
    return (g, y1, x1 - (a // b) * y1)

def inv_mod(a, m):
    g, x, y = egcd(a, m)
    assert g == 1
    return x % m

def factorize_mod(m):
    x = m
    res = []
    d = 2
    while d * d <= x:
        if x % d == 0:
            res.append(d)
            while x % d == 0:
                x //= d
        d += 1 if d == 2 else 2
        if d % 2 == 0: d += 1
    if x > 1:
        res.append(x)
    return res

def sieve_spf(limit):
    spf = list(range(limit + 1))
    for i in range(2, int(limit ** 0.5) + 1):
        if spf[i] == i:
            step = i
            start = i * i
            for j in range(start, limit + 1, step):
                if spf[j] == j:
                    spf[j] = i
    return spf

def factorize_by_spf(x, spf):
    res = {}
    while x > 1:
        p = spf[x]
        cnt = 0
        while x % p == 0:
            x //= p
            cnt += 1
        res[p] = res.get(p, 0) + cnt
    return res

class FenwickAdd:
    def __init__(self, n):
        self.n = n
        self.fw = [0] * (n + 2)
    def add(self, i, delta):
        n = self.n + 1
        while i <= n:
            self.fw[i] += delta
            i += i & -i
    def prefix_sum(self, i):
        res = 0
        while i > 0:
            res += self.fw[i]
            i -= i & -i
        return res
    def range_add(self, l, r, delta):
        self.add(l, delta)
        self.add(r + 1, -delta)
    def point_query(self, i):
        return self.prefix_sum(i)

class FenwickMul:
    def __init__(self, n, mod):
        self.n = n
        self.mod = mod
        self.fw = [1] * (n + 2)
    def mul(self, i, val):
        n = self.n + 1
        M = self.mod
        while i <= n:
            self.fw[i] = (self.fw[i] * val) % M
            i += i & -i
    def prefix_prod(self, i):
        res = 1
        M = self.mod
        while i > 0:
            res = (res * self.fw[i]) % M
            i -= i & -i
        return res
    def range_mul(self, l, r, val):
        self.mul(l, val)
        inv = inv_mod(val, self.mod)
        self.mul(r + 1, inv)

class SegTreeMulSum:
    def __init__(self, arr, mod):
        n = len(arr)
        self.n = n
        self.M = mod
        self.sum = [0] * (4 * n)
        self.lazy = [1] * (4 * n)
        self._build(1, 0, n - 1, arr)
    def _build(self, v, tl, tr, arr):
        if tl == tr:
            self.sum[v] = arr[tl] % self.M
            return
        tm = (tl + tr) // 2
        self._build(v*2, tl, tm, arr)
        self._build(v*2+1, tm+1, tr, arr)
        self.sum[v] = (self.sum[v*2] + self.sum[v*2+1]) % self.M
    def _apply(self, v, mul_factor, len_seg):
        self.sum[v] = (self.sum[v] * mul_factor) % self.M
        self.lazy[v] = (self.lazy[v] * mul_factor) % self.M
    def _push(self, v):
        if self.lazy[v] != 1:
            f = self.lazy[v]
            self._apply(v*2, f, 0)
            self._apply(v*2+1, f, 0)
            self.lazy[v] = 1
    def range_mul(self, l, r, val):
        self._range_mul(1, 0, self.n - 1, l, r, val)
    def _range_mul(self, v, tl, tr, l, r, val):
        if l > r: return
        if l == tl and r == tr:
            self._apply(v, val, tr - tl + 1)
            return
        self._push(v)
        tm = (tl + tr) // 2
        self._range_mul(v*2, tl, tm, l, min(r, tm), val)
        self._range_mul(v*2+1, tm+1, tr, max(l, tm+1), r, val)
        self.sum[v] = (self.sum[v*2] + self.sum[v*2+1]) % self.M
    def point_set(self, pos, new_val):
        self._point_set(1, 0, self.n - 1, pos, new_val % self.M)
    def _point_set(self, v, tl, tr, pos, new_val):
        if tl == tr:
            self.sum[v] = new_val % self.M
            self.lazy[v] = 1
            return
        self._push(v)
        tm = (tl + tr) // 2
        if pos <= tm:
            self._point_set(v*2, tl, tm, pos, new_val)
        else:
            self._point_set(v*2+1, tm+1, tr, pos, new_val)
        self.sum[v] = (self.sum[v*2] + self.sum[v*2+1]) % self.M
    def range_sum(self, l, r):
        return self._range_sum(1, 0, self.n - 1, l, r)
    def _range_sum(self, v, tl, tr, l, r):
        if l > r: return 0
        if l == tl and r == tr:
            return self.sum[v] % self.M
        self._push(v)
        tm = (tl + tr) // 2
        return (self._range_sum(v*2, tl, tm, l, min(r, tm)) +
                self._range_sum(v*2+1, tm+1, tr, max(l, tm+1), r)) % self.M

def split_against_mod(x, spf, primesM_set, mod):
    fac = factorize_by_spf(x, spf) if x > 1 else {}
    exp_on_M = {}
    cop = 1 % mod
    for p, e in fac.items():
        if p in primesM_set:
            exp_on_M[p] = exp_on_M.get(p, 0) + e
        else:
            cop = (cop * pow(p, e, mod)) % mod
    return cop, exp_on_M

def build_initial(n, mod, a, spf, primesM):
    primesM_set = set(primesM)
    # exponent BITs for each prime in primesM
    expBITS = {p: FenwickAdd(n) for p in primesM}
    # base r_i modulo mod (co-prime part) after removing M-primes
    rbase = [1] * (n + 1)  # 1-based for convenience
    vals_mod = [0] * n
    for i in range(1, n+1):
        ai = a[i-1]
        cop, expM = split_against_mod(ai, spf, primesM_set, mod)
        rbase[i] = cop % mod
        # set initial exponents at point i
        for p in primesM:
            e = expM.get(p, 0)
            if e != 0:
                expBITS[p].range_add(i, i, e)
        # compute value modulo mod
        val = cop
        for p in primesM:
            e = expM.get(p, 0)
            if e:
                val = (val * pow(p, e, mod)) % mod
        vals_mod[i-1] = val % mod
    return rbase, expBITS, vals_mod

def solve_case(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); mod = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    qs = []
    for _ in range(q):
        t = int(next(it))
        if t == 1:
            l = int(next(it)); r = int(next(it)); x = int(next(it))
            qs.append((t, l, r, x))
        elif t == 2:
            p = int(next(it)); x = int(next(it))
            qs.append((t, p, x))
        else:
            l = int(next(it)); r = int(next(it))
            qs.append((t, l, r))
    # preprocessing
    primesM = factorize_mod(mod)
    spf = sieve_spf(100000)
    rbase, expBITS, vals_mod = build_initial(n, mod, a, spf, primesM)
    seg = SegTreeMulSum(vals_mod, mod)
    # multiplicative BIT for coprime range updates
    mulBIT = FenwickMul(n, mod)
    # initially identity (no updates), nothing to set
    out_lines = []
    primesM_set = set(primesM)
    for qu in qs:
        if qu[0] == 1:
            _, l, r, x = qu
            # split x
            cop, expM = split_against_mod(x, spf, primesM_set, mod)
            # update segment sum lazily
            seg.range_mul(l-1, r-1, x % mod)
            # update exponent BITs
            for p, e in expM.items():
                if e != 0:
                    expBITS[p].range_add(l, r, e)
            # update coprime multiplicative BIT
            if cop != 1:
                mulBIT.range_mul(l, r, cop)
        elif qu[0] == 2:
            _, p, x = qu
            cop, expM = split_against_mod(x, spf, primesM_set, mod)
            # decrement exponents at point p
            for prime, e in expM.items():
                if e != 0:
                    expBITS[prime].range_add(p, p, -e)
            # update rbase at point p by dividing cop (multiply by inverse)
            if cop != 1:
                invc = inv_mod(cop, mod)
                rbase[p] = (rbase[p] * invc) % mod
            # recompute current a_p modulo mod
            cur_r = (rbase[p] * mulBIT.prefix_prod(p)) % mod
            val = cur_r
            for prime in primesM:
                e = expBITS[prime].point_query(p)
                if e:
                    val = (val * pow(prime, e, mod)) % mod
            seg.point_set(p-1, val)
        else:
            _, l, r = qu
            out_lines.append(str(seg.range_sum(l-1, r-1)))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    print(solve_case(data))

if __name__ == "__main__":
    # Asserts for small handcrafted scenarios
    t1 = """5 100
4 1 2 3 5
5
3 1 5
1 2 3 6
3 1 2
1 1 5 1
3 2 4
"""
    assert solve_case(t1).strip().split() == ["15", "10", "21"]
    t2 = """5 2
4 1 2 3 5
7
3 1 5
1 2 3 6
3 1 2
1 1 5 1
3 2 4
2 3 4
3 3 4
"""
    assert solve_case(t2).strip().split() == ["1","0","1","0"]
    # main()
    pass
\end{minted}
\VALIDATION{The included asserts mirror the narrative examples: both the modulus $100$ and modulus $2$ cases validate the logic.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Lazy Sum Tree + Coprime/Product Decomposition}
\WHICHFORMULA{Maintain:
\begin{bullets}
\item A lazy segment tree for range multiply and range sum modulo $M$.
\item For the $M$-coprime part: multiplicative Fenwick for range-multiply and point product.
\item For the $M$-prime exponents: one additive Fenwick per $p\mid M$ for range-add and point-query.
\end{bullets}
Point divisions recompute exactly one leaf using $r_i$ and exponents.}
\ASSUMPTIONS{The number of distinct primes dividing $M$ is small; factorization of $x\le 10^5$ is fast with SPF.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Factor $M$ into distinct primes $P$.
\item Initialize $r_i$ and $e_{i,p}$ from $a_i$ via SPF; build segment tree over $a_i\bmod M$.
\item For update $1~l~r~x$:
  \begin{bullets}
  \item Multiply segment range by $x \bmod M$.
  \item For each $p\in P$, add $v_p(x)$ to $[l,r]$ in $p$'s BIT.
  \item Multiply coprime BIT on $[l,r]$ by $x'$.
  \end{bullets}
\item For update $2~p~x$:
  \begin{bullets}
  \item For each $p\in P$, add $-v_p(x)$ to $[p,p]$.
  \item Update $r_p\gets r_p\cdot (x')^{-1}\bmod M$.
  \item Set leaf at $p$ to $r_p\cdot \prod_{q\in P} q^{e_{p,q}} \bmod M$.
  \end{bullets}
\item For query $3~l~r$: return tree sum on $[l,r]$.
\end{algosteps}
\OPTIMALITY{Range multiplies and range sums are optimal up to logarithmic factors. Point divisions cost $\mathcal{O}(k\log n + k\log E)$ which is unavoidable without storing full per-point prime power products. The bound is tight since $k$ is constant small.}
\COMPLEXITY{Time and space bounds are near optimal for this model.}
\[
\begin{aligned}
T(n) &= \mathcal{O}\big(\log n\big) \text{ per type-1 and type-3} \quad+\quad \mathcal{O}\big(k\log n + k\log E + \log n\big) \text{ per type-2},\\
S(n) &= \mathcal{O}(n + kn).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys
from math import gcd

def egcd(a, b):
    if b == 0:
        return (a, 1, 0)
    g, x1, y1 = egcd(b, a % b)
    return (g, y1, x1 - (a // b) * y1)

def inv_mod(a, m):
    g, x, y = egcd(a, m)
    assert g == 1
    return x % m

def factorize_mod(m):
    x = m
    res = []
    d = 2
    while d * d <= x:
        if x % d == 0:
            res.append(d)
            while x % d == 0:
                x //= d
        d += 1 if d == 2 else 2
        if d % 2 == 0: d += 1
    if x > 1:
        res.append(x)
    return res

def sieve_spf(limit):
    spf = list(range(limit + 1))
    for i in range(2, int(limit ** 0.5) + 1):
        if spf[i] == i:
            step = i
            start = i * i
            for j in range(start, limit + 1, step):
                if spf[j] == j:
                    spf[j] = i
    return spf

def factorize_by_spf(x, spf):
    res = {}
    while x > 1:
        p = spf[x]
        cnt = 0
        while x % p == 0:
            x //= p
            cnt += 1
        res[p] = res.get(p, 0) + cnt
    return res

class FenwickAdd:
    def __init__(self, n):
        self.n = n
        self.fw = [0] * (n + 2)
    def add(self, i, delta):
        n = self.n + 1
        while i <= n:
            self.fw[i] += delta
            i += i & -i
    def prefix_sum(self, i):
        res = 0
        while i > 0:
            res += self.fw[i]
            i -= i & -i
        return res
    def range_add(self, l, r, delta):
        self.add(l, delta)
        self.add(r + 1, -delta)
    def point_query(self, i):
        return self.prefix_sum(i)

class FenwickMul:
    def __init__(self, n, mod):
        self.n = n
        self.mod = mod
        self.fw = [1] * (n + 2)
    def mul(self, i, val):
        n = self.n + 1
        M = self.mod
        while i <= n:
            self.fw[i] = (self.fw[i] * val) % M
            i += i & -i
    def prefix_prod(self, i):
        res = 1
        M = self.mod
        while i > 0:
            res = (res * self.fw[i]) % M
            i -= i & -i
        return res
    def range_mul(self, l, r, val):
        self.mul(l, val)
        inv = inv_mod(val, self.mod)
        self.mul(r + 1, inv)

class SegTreeMulSum:
    def __init__(self, arr, mod):
        n = len(arr)
        self.n = n
        self.M = mod
        self.sum = [0] * (4 * n)
        self.lazy = [1] * (4 * n)
        self._build(1, 0, n - 1, arr)
    def _build(self, v, tl, tr, arr):
        if tl == tr:
            self.sum[v] = arr[tl] % self.M
            return
        tm = (tl + tr) // 2
        self._build(v*2, tl, tm, arr)
        self._build(v*2+1, tm+1, tr, arr)
        self.sum[v] = (self.sum[v*2] + self.sum[v*2+1]) % self.M
    def _apply(self, v, mul_factor, length):
        self.sum[v] = (self.sum[v] * mul_factor) % self.M
        self.lazy[v] = (self.lazy[v] * mul_factor) % self.M
    def _push(self, v):
        if self.lazy[v] != 1:
            f = self.lazy[v]
            self._apply(v*2, f, 0)
            self._apply(v*2+1, f, 0)
            self.lazy[v] = 1
    def range_mul(self, l, r, val):
        self._range_mul(1, 0, self.n - 1, l, r, val)
    def _range_mul(self, v, tl, tr, l, r, val):
        if l > r: return
        if l == tl and r == tr:
            self._apply(v, val, tr - tl + 1)
            return
        self._push(v)
        tm = (tl + tr) // 2
        self._range_mul(v*2, tl, tm, l, min(r, tm), val)
        self._range_mul(v*2+1, tm+1, tr, max(l, tm+1), r, val)
        self.sum[v] = (self.sum[v*2] + self.sum[v*2+1]) % self.M
    def point_set(self, pos, new_val):
        self._point_set(1, 0, self.n - 1, pos, new_val % self.M)
    def _point_set(self, v, tl, tr, pos, new_val):
        if tl == tr:
            self.sum[v] = new_val % self.M
            self.lazy[v] = 1
            return
        self._push(v)
        tm = (tl + tr) // 2
        if pos <= tm:
            self._point_set(v*2, tl, tm, pos, new_val)
        else:
            self._point_set(v*2+1, tm+1, tr, pos, new_val)
        self.sum[v] = (self.sum[v*2] + self.sum[v*2+1]) % self.M
    def range_sum(self, l, r):
        return self._range_sum(1, 0, self.n - 1, l, r)
    def _range_sum(self, v, tl, tr, l, r):
        if l > r: return 0
        if l == tl and r == tr:
            return self.sum[v] % self.M
        self._push(v)
        tm = (tl + tr) // 2
        return (self._range_sum(v*2, tl, tm, l, min(r, tm)) +
                self._range_sum(v*2+1, tm+1, tr, max(l, tm+1), r)) % self.M

def factorize_by_spf_cached(x, spf):
    return factorize_by_spf(x, spf) if x > 1 else {}

def split_against_mod(x, spf, primesM_set, mod):
    fac = factorize_by_spf_cached(x, spf)
    exp_on_M = {}
    cop = 1 % mod
    for p, e in fac.items():
        if p in primesM_set:
            exp_on_M[p] = exp_on_M.get(p, 0) + e
        else:
            cop = (cop * pow(p, e, mod)) % mod
    return cop, exp_on_M

def build_initial(n, mod, a, spf, primesM):
    primesM_set = set(primesM)
    expBITS = {p: FenwickAdd(n) for p in primesM}
    rbase = [1] * (n + 1)  # 1-based
    vals_mod = [0] * n
    for i in range(1, n+1):
        ai = a[i-1]
        cop, expM = split_against_mod(ai, spf, primesM_set, mod)
        rbase[i] = cop % mod
        val = cop
        for p in primesM:
            e = expM.get(p, 0)
            if e:
                expBITS[p].range_add(i, i, e)
                val = (val * pow(p, e, mod)) % mod
        vals_mod[i-1] = val % mod
    return rbase, expBITS, vals_mod

def solve_all():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); mod = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    queries = []
    for _ in range(q):
        t = int(next(it))
        if t == 1:
            l = int(next(it)); r = int(next(it)); x = int(next(it))
            queries.append((t, l, r, x))
        elif t == 2:
            p = int(next(it)); x = int(next(it))
            queries.append((t, p, x))
        else:
            l = int(next(it)); r = int(next(it))
            queries.append((t, l, r))
    primesM = factorize_mod(mod)
    spf = sieve_spf(100000)
    rbase, expBITS, vals_mod = build_initial(n, mod, a, spf, primesM)
    seg = SegTreeMulSum(vals_mod, mod)
    mulBIT = FenwickMul(n, mod)
    primesM_set = set(primesM)
    out = []
    for qu in queries:
        if qu[0] == 1:
            _, l, r, x = qu
            cop, expM = split_against_mod(x, spf, primesM_set, mod)
            seg.range_mul(l-1, r-1, x % mod)
            for p, e in expM.items():
                if e:
                    expBITS[p].range_add(l, r, e)
            if cop != 1:
                mulBIT.range_mul(l, r, cop)
        elif qu[0] == 2:
            _, p, x = qu
            cop, expM = split_against_mod(x, spf, primesM_set, mod)
            for prime, e in expM.items():
                if e:
                    expBITS[prime].range_add(p, p, -e)
            if cop != 1:
                invc = inv_mod(cop, mod)
                rbase[p] = (rbase[p] * invc) % mod
            cur_r = (rbase[p] * mulBIT.prefix_prod(p)) % mod
            val = cur_r
            for prime in primesM:
                e = expBITS[prime].point_query(p)
                if e:
                    val = (val * pow(prime, e, mod)) % mod
            seg.point_set(p-1, val)
        else:
            _, l, r = qu
            out.append(str(seg.range_sum(l-1, r-1)))
    sys.stdout.write("\n".join(out))

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts on self-contained mini-tests
    t1 = """5 100
4 1 2 3 5
5
3 1 5
1 2 3 6
3 1 2
1 1 5 1
3 2 4
"""
    def run_io(s: str) -> str:
        return solve_case_for_test(s)

    def solve_case_for_test(data: str) -> str:
        # helper mirroring solve_all but from string
        it = iter(data.strip().split())
        n = int(next(it)); mod = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        q = int(next(it))
        qs = []
        for _ in range(q):
            t = int(next(it))
            if t == 1:
                l = int(next(it)); r = int(next(it)); x = int(next(it))
                qs.append((t, l, r, x))
            elif t == 2:
                p = int(next(it)); x = int(next(it))
                qs.append((t, p, x))
            else:
                l = int(next(it)); r = int(next(it))
                qs.append((t, l, r))
        primesM = factorize_mod(mod)
        spf = sieve_spf(100000)
        rbase, expBITS, vals_mod = build_initial(n, mod, a, spf, primesM)
        seg = SegTreeMulSum(vals_mod, mod)
        mulBIT = FenwickMul(n, mod)
        primesM_set = set(primesM)
        out = []
        for qu in qs:
            if qu[0] == 1:
                _, l, r, x = qu
                cop, expM = split_against_mod(x, spf, primesM_set, mod)
                seg.range_mul(l-1, r-1, x % mod)
                for p, e in expM.items():
                    if e:
                        expBITS[p].range_add(l, r, e)
                if cop != 1:
                    mulBIT.range_mul(l, r, cop)
            elif qu[0] == 2:
                _, p, x = qu
                cop, expM = split_against_mod(x, spf, primesM_set, mod)
                for prime, e in expM.items():
                    if e:
                        expBITS[prime].range_add(p, p, -e)
                if cop != 1:
                    invc = inv_mod(cop, mod)
                    rbase[p] = (rbase[p] * invc) % mod
                cur_r = (rbase[p] * mulBIT.prefix_prod(p)) % mod
                val = cur_r
                for prime in primesM:
                    e = expBITS[prime].point_query(p)
                    if e:
                        val = (val * pow(prime, e, mod)) % mod
                seg.point_set(p-1, val)
            else:
                _, l, r = qu
                out.append(str(seg.range_sum(l-1, r-1)))
        return "\n".join(out)
    assert run_io(t1).strip().split() == ["15","10","21"]
    t2 = """5 2
4 1 2 3 5
7
3 1 5
1 2 3 6
3 1 2
1 1 5 1
3 2 4
2 3 4
3 3 4
"""
    assert run_io(t2).strip().split() == ["1","0","1","0"]
    t3 = """3 12
6 10 15
5
3 1 3
1 1 3 6
3 1 3
2 2 5
3 1 3
"""
    # manual: initial sum 31 mod 12 = 7; multiply by 6: array [36,60,90] sum 186 mod 12 = 6
    # divide position 2 by 5: 60/5=12 => [36,12,90], sum=138 mod 12 = 6
    assert run_io(t3).strip().split() == ["7","6","6"]
    # main()
    pass
\end{minted}
\VALIDATION{Exactly 3 asserts check: a base modulus-100 example, a modulus-2 example with division, and a composite modulus example stressing non-invertible prime factors.}
\RESULT{All queries of type $3$ are answered online with updates in $\mathcal{O}(\log n)$ plus a small factor for primes dividing $mod$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: prime and composite moduli; range multiply by $1$; point division by a number sharing primes with $mod$; and correctness of lazy propagation.}
\LINE{CROSS-CHECKS}{Compare sums from Approach B vs Approach C on small arrays with random operations; check invariants: after only type-1 operations, sums equal naive sum times product of multipliers modulo $M$.}
\LINE{EDGE-CASE GENERATOR}{Generate random $mod$ with controlled prime factors, arrays with small values, and sequences with interleaved multiply/divide operations to validate exponent tracking.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_case(n=10, q=20, mod=1000, seed=1):
    random.seed(seed)
    a = [random.randint(1, 20) for _ in range(n)]
    ops = []
    for _ in range(q):
        t = random.choice([1,2,3,3])  # bias toward queries
        if t == 1:
            l = random.randint(1, n)
            r = random.randint(l, n)
            x = random.randint(1, 20)
            ops.append((1,l,r,x))
        elif t == 2:
            p = random.randint(1, n)
            x = random.randint(1, 10)
            # ensure divisibility
            # pick a factor of current a[p-1]
            v = a[p-1]
            facs = []
            for d in range(1, v+1):
                if v % d == 0 and d <= 20:
                    facs.append(d)
            x = random.choice(facs) if facs else 1
            a[p-1] //= x  # mutate mirror
            ops.append((2,p,x))
        else:
            l = random.randint(1, n)
            r = random.randint(l, n)
            ops.append((3,l,r))
    return n, mod, a, ops

# Reference code (Ready to Submit)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys
from math import gcd

def egcd(a, b):
    if b == 0:
        return (a, 1, 0)
    g, x1, y1 = egcd(b, a % b)
    return (g, y1, x1 - (a // b) * y1)

def inv_mod(a, m):
    g, x, y = egcd(a, m)
    assert g == 1
    return x % m

def factorize_mod(m):
    x = m
    res = []
    d = 2
    while d * d <= x:
        if x % d == 0:
            res.append(d)
            while x % d == 0:
                x //= d
        d += 1 if d == 2 else 2
        if d % 2 == 0:
            d += 1
    if x > 1:
        res.append(x)
    return res

def sieve_spf(limit):
    spf = list(range(limit + 1))
    for i in range(2, int(limit ** 0.5) + 1):
        if spf[i] == i:
            step = i
            start = i * i
            for j in range(start, limit + 1, step):
                if spf[j] == j:
                    spf[j] = i
    return spf

def factorize_by_spf(x, spf):
    res = {}
    while x > 1:
        p = spf[x]
        cnt = 0
        while x % p == 0:
            x //= p
            cnt += 1
        res[p] = res.get(p, 0) + cnt
    return res

class FenwickAdd:
    def __init__(self, n):
        self.n = n
        self.fw = [0] * (n + 2)
    def add(self, i, delta):
        n = self.n + 1
        while i <= n:
            self.fw[i] += delta
            i += i & -i
    def prefix_sum(self, i):
        res = 0
        while i > 0:
            res += self.fw[i]
            i -= i & -i
        return res
    def range_add(self, l, r, delta):
        self.add(l, delta)
        self.add(r + 1, -delta)
    def point_query(self, i):
        return self.prefix_sum(i)

class FenwickMul:
    def __init__(self, n, mod):
        self.n = n
        self.mod = mod
        self.fw = [1] * (n + 2)
    def mul(self, i, val):
        n = self.n + 1
        M = self.mod
        while i <= n:
            self.fw[i] = (self.fw[i] * val) % M
            i += i & -i
    def prefix_prod(self, i):
        res = 1
        M = self.mod
        while i > 0:
            res = (res * self.fw[i]) % M
            i -= i & -i
        return res
    def range_mul(self, l, r, val):
        self.mul(l, val)
        inv = inv_mod(val, self.mod)
        self.mul(r + 1, inv)

class SegTreeMulSum:
    def __init__(self, arr, mod):
        n = len(arr)
        self.n = n
        self.M = mod
        self.sum = [0] * (4 * n)
        self.lazy = [1] * (4 * n)
        self._build(1, 0, n - 1, arr)
    def _build(self, v, tl, tr, arr):
        if tl == tr:
            self.sum[v] = arr[tl] % self.M
            return
        tm = (tl + tr) // 2
        self._build(v*2, tl, tm, arr)
        self._build(v*2+1, tm+1, tr, arr)
        self.sum[v] = (self.sum[v*2] + self.sum[v*2+1]) % self.M
    def _apply(self, v, mul_factor, length):
        self.sum[v] = (self.sum[v] * mul_factor) % self.M
        self.lazy[v] = (self.lazy[v] * mul_factor) % self.M
    def _push(self, v):
        if self.lazy[v] != 1:
            f = self.lazy[v]
            self._apply(v*2, f, 0)
            self._apply(v*2+1, f, 0)
            self.lazy[v] = 1
    def range_mul(self, l, r, val):
        self._range_mul(1, 0, self.n - 1, l, r, val)
    def _range_mul(self, v, tl, tr, l, r, val):
        if l > r: return
        if l == tl and r == tr:
            self._apply(v, val, tr - tl + 1)
            return
        self._push(v)
        tm = (tl + tr) // 2
        self._range_mul(v*2, tl, tm, l, min(r, tm), val)
        self._range_mul(v*2+1, tm+1, tr, max(l, tm+1), r, val)
        self.sum[v] = (self.sum[v*2] + self.sum[v*2+1]) % self.M
    def point_set(self, pos, new_val):
        self._point_set(1, 0, self.n - 1, pos, new_val % self.M)
    def _point_set(self, v, tl, tr, pos, new_val):
        if tl == tr:
            self.sum[v] = new_val % self.M
            self.lazy[v] = 1
            return
        self._push(v)
        tm = (tl + tr) // 2
        if pos <= tm:
            self._point_set(v*2, tl, tm, pos, new_val)
        else:
            self._point_set(v*2+1, tm+1, tr, pos, new_val)
        self.sum[v] = (self.sum[v*2] + self.sum[v*2+1]) % self.M
    def range_sum(self, l, r):
        return self._range_sum(1, 0, self.n - 1, l, r)
    def _range_sum(self, v, tl, tr, l, r):
        if l > r: return 0
        if l == tl and r == tr:
            return self.sum[v] % self.M
        self._push(v)
        tm = (tl + tr) // 2
        return (self._range_sum(v*2, tl, tm, l, min(r, tm)) +
                self._range_sum(v*2+1, tm+1, tr, max(l, tm+1), r)) % self.M

def factorize_by_spf_cached(x, spf):
    return factorize_by_spf(x, spf) if x > 1 else {}

def split_against_mod(x, spf, primesM_set, mod):
    fac = factorize_by_spf_cached(x, spf)
    exp_on_M = {}
    cop = 1 % mod
    for p, e in fac.items():
        if p in primesM_set:
            exp_on_M[p] = exp_on_M.get(p, 0) + e
        else:
            cop = (cop * pow(p, e, mod)) % mod
    return cop, exp_on_M

def build_initial(n, mod, a, spf, primesM):
    primesM_set = set(primesM)
    expBITS = {p: FenwickAdd(n) for p in primesM}
    rbase = [1] * (n + 1)
    vals_mod = [0] * n
    for i in range(1, n+1):
        ai = a[i-1]
        cop, expM = split_against_mod(ai, spf, primesM_set, mod)
        rbase[i] = cop % mod
        val = cop
        for p in primesM:
            e = expM.get(p, 0)
            if e:
                expBITS[p].range_add(i, i, e)
                val = (val * pow(p, e, mod)) % mod
        vals_mod[i-1] = val % mod
    return rbase, expBITS, vals_mod

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); mod = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    queries = []
    for _ in range(q):
        t = int(next(it))
        if t == 1:
            l = int(next(it)); r = int(next(it)); x = int(next(it))
            queries.append((t, l, r, x))
        elif t == 2:
            p = int(next(it)); x = int(next(it))
            queries.append((t, p, x))
        else:
            l = int(next(it)); r = int(next(it))
            queries.append((t, l, r))
    return n, mod, a, q, queries

def solve_all(n, mod, a, q, queries):
    primesM = factorize_mod(mod)
    spf = sieve_spf(100000)
    rbase, expBITS, vals_mod = build_initial(n, mod, a, spf, primesM)
    seg = SegTreeMulSum(vals_mod, mod)
    mulBIT = FenwickMul(n, mod)
    primesM_set = set(primesM)
    out = []
    for qu in queries:
        if qu[0] == 1:
            _, l, r, x = qu
            cop, expM = split_against_mod(x, spf, primesM_set, mod)
            seg.range_mul(l-1, r-1, x % mod)
            for p, e in expM.items():
                if e:
                    expBITS[p].range_add(l, r, e)
            if cop != 1:
                mulBIT.range_mul(l, r, cop)
        elif qu[0] == 2:
            _, p, x = qu
            cop, expM = split_against_mod(x, spf, primesM_set, mod)
            for prime, e in expM.items():
                if e:
                    expBITS[prime].range_add(p, p, -e)
            if cop != 1:
                rbase[p] = (rbase[p] * inv_mod(cop, mod)) % mod
            cur_r = (rbase[p] * mulBIT.prefix_prod(p)) % mod
            val = cur_r
            for prime in primesM:
                e = expBITS[prime].point_query(p)
                if e:
                    val = (val * pow(prime, e, mod)) % mod
            seg.point_set(p-1, val)
        else:
            _, l, r = qu
            out.append(str(seg.range_sum(l-1, r-1)))
    return "\n".join(out)

def main():
    n, mod, a, q, queries = read_input()
    print(solve_all(n, mod, a, q, queries))

if __name__ == "__main__":
    # simple asserts
    t1 = """5 100
4 1 2 3 5
5
3 1 5
1 2 3 6
3 1 2
1 1 5 1
3 2 4
"""
    def run_io(data: str) -> str:
        it = iter(data.strip().split())
        n = int(next(it)); mod = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        q = int(next(it))
        qs = []
        for _ in range(q):
            t = int(next(it))
            if t == 1:
                l = int(next(it)); r = int(next(it)); x = int(next(it))
                qs.append((t, l, r, x))
            elif t == 2:
                p = int(next(it)); x = int(next(it))
                qs.append((t, p, x))
            else:
                l = int(next(it)); r = int(next(it))
                qs.append((t, l, r))
        return solve_all(n, mod, a, q, qs)
    assert run_io(t1).strip().split() == ["15","10","21"]
    t2 = """5 2
4 1 2 3 5
7
3 1 5
1 2 3 6
3 1 2
1 1 5 1
3 2 4
2 3 4
3 3 4
"""
    assert run_io(t2).strip().split() == ["1","0","1","0"]
    t3 = """3 12
6 10 15
5
3 1 3
1 1 3 6
3 1 3
2 2 5
3 1 3
"""
    assert run_io(t3).strip().split() == ["7","6","6"]
    # main()
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Decompose numbers by primes dividing $mod$ to decouple non-invertible updates; use lazy range multiply for sums and exact point recomputation for divisions.}
\WHY{Composite moduli break standard inverse-based approaches; careful prime-part handling restores structure. Common in interviews to test modular arithmetic with non-prime moduli.}
\CHECKLIST{
\begin{bullets}
\item Factor $mod$ into distinct primes.
\item Precompute SPF up to $10^5$.
\item Initialize $r_i$ and exponents $e_{i,p}$.
\item Segment tree for sum with lazy range multiply.
\item BIT range-add per $p\mid M$; BIT range-mul for coprime part.
\item For division: decrement exponents, update $r_i$, recompute leaf.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $mod$ prime vs highly composite.
\item $x=1$ no-op.
\item $l=r$ single-element range operations.
\item Division by $x$ where $x$ shares all its primes with $mod$ (no coprime part).
\item Division by $x$ where $x$ is coprime to $mod$ (pure inverse update).
\item Large exponent accumulation; use 64-bit exponents and fast pow.
\item $a_i=1$ and many updates.
\item $mod$ having large prime factor $>10^5$ (no effect on factorization of $x\le 10^5$).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting that inverses do not exist for factors sharing primes with $mod$.
\item Not pushing lazy before point-assign updates in the segment tree.
\item Mixing $0$-based and $1$-based indices between arrays and BITs.
\item Recomputing powers naively per update; restrict to point divisions.
\item Not ensuring $r_i$ remains coprime to $mod$ after updates.
\item Incorrectly handling $r+1$ boundary in range BIT updates.
\item Overflow is not an issue in Python but modulo must be applied consistently.
\item Trial division for $mod$ must extract distinct primes only.
\end{bullets}}
\FAILMODES{Approaches treating division as multiplication by modular inverse of $x$ fail when $\gcd(x,mod)\ne 1$; here we split $x$ and only invert $x'$ while updating prime exponents separately.}
\ELI{We split numbers by the primes that cause trouble modulo $mod$. Multiplying ranges is easy for sums, and when we divide a single number, we update its components and rebuild only that leaf. This keeps everything fast and correct under any $mod$.}
\NotePages{3}

\end{document}