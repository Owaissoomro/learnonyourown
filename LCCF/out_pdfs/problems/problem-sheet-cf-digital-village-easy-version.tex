% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Digital Village (Easy Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2021/E1}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{This is the easy version of the problem. In the three versions, the constraints on $n$ and $m$ are different. You can make hacks only if all the versions of the problem are solved.

Pak Chanek is setting up internet connections for the village of Khuntien. The village can be represented as a connected simple graph with $n$ houses and $m$ internet cables connecting house $u_i$ and house $v_i$, each with a latency of $w_i$.

There are $p$ houses that require internet. Pak Chanek can install servers in at most $k$ of the houses. The houses that need internet will then be connected to one of the servers. However, since each cable has its latency, the latency experienced by house $s_i$ requiring internet will be the maximum latency of the cables between that house and the server it is connected to.

For each $k = 1,2,\ldots,n$, help Pak Chanek determine the minimum total latency that can be achieved for all the houses requiring internet.

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 100$). The description of the test cases follows.

The first line of each test case contains three integers $n$, $m$, $p$ ($2 \le n \le 400$; $n-1 \le m \le 400$; $1 \le p \le n$) — the number of houses, the number of cables and the number of houses that need internet.

The second line of each test case contains $p$ integers $s_1, s_2, \ldots, s_p$ ($1 \le s_i \le n$) — the houses that need internet. It is guaranteed that all elements of $s$ are distinct.

The $i$-th of the next $m$ lines of each test case contains three integers $u_i$, $v_i$, and $w_i$ ($1 \le u_i < v_i \le n$; $1 \le w_i \le 10^9$) — the internet cable connecting house $u_i$ and house $v_i$ with latency of $w_i$. It is guaranteed that the given edges form a connected simple graph.

It is guaranteed that the sum of $n^3$ and the sum of $m^3$ do not exceed $10^8$.

Output:
For each test case, output $n$ integers: the minimum total latency that can be achieved for all the houses requiring internet for each $k = 1,2,\ldots,n$.

Note:
In the first test case for $k=3$, a possible optimal solution is to install servers at vertices $2$, $6$ and $8$ and obtain the following latency:
\begin{bullets}
\item $\text{latency}(2) = 0$
\item $\text{latency}(5) = \max(3, 5) = 5$
\item $\text{latency}(6) = 0$
\item $\text{latency}(8) = 0$
\item $\text{latency}(9) = \max(2, 4) = 4$
\end{bullets}
So the total latency is $9$.}
\BREAKDOWN{Reduce the general-graph problem to a tree via a minimum spanning tree (MST) and the minimax-path property, then solve a facility-location DP on the Kruskal reconstruction tree to compute, for each $k$, the minimal sum of bottleneck distances from required houses to their nearest server.}
\ELI{Turn the graph into a tree of merges by edge weights; at each merge you may pay that weight per remaining user if you have at least one server in the merged part. A knapsack-like DP over this tree gives the best total latency for every $k$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n,m,p$; a list of $p$ distinct houses $s_1,\ldots,s_p$; then $m$ edges $(u_i,v_i,w_i)$ with $1 \le u_i < v_i \le n$ and $w_i \ge 1$. The graph is connected.}
\OUTPUTS{For each test case, print $n$ space-separated integers. The $k$-th number is the minimum possible total latency if you may place servers in at most $k$ houses.}
\SAMPLES{Example 1 (tiny):
\begin{bullets}
\item $n=2,m=1,p=1$, $s=\{1\}$, edge $(1,2,5)$. Answers: $k=1,2 \Rightarrow 0, 0$.
\item $n=3,m=2,p=2$, $s=\{1,3\}$, edges $(1,2,3)$, $(2,3,5)$. Answers: $k=1,2,3 \Rightarrow 5, 0, 0$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E,w)$ be a connected simple graph. Let $S \subseteq V$ be the $p$ demand nodes. For a path $P$, define its bottleneck as $\max_{e \in P} w(e)$. The latency between $u,v$ is $d(u,v)=\min_{P:u\leadsto v} \max_{e\in P} w(e)$. Choose a set $C \subseteq V$ of servers with $|C| \le k$ to minimize $\sum_{s\in S} \min_{c\in C} d(s,c)$.}
\varmapStart
\var{n,m}{number of vertices/edges}
\var{p}{number of demand vertices}
\var{S}{set of demand vertices}
\var{T}{MST of $G$}
\var{\mathcal{K}}{Kruskal reconstruction tree of $T$}
\var{w(v)}{merge weight at internal node $v$ of $\mathcal{K}$}
\var{t(v)}{number of demands in the subtree of $v$}
\var{f_v(x)}{min total latency serving all demands in subtree of $v$ using exactly $x$ servers in that subtree}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Minimax path identity:} && d(u,v) = \max_{e \in P_{T}(u,v)} w(e), \text{ where } P_{T}(u,v)\text{ is the path in any MST}. \\
&\text{Ultrametric via Kruskal tree:} && d(u,v) = w(\mathrm{LCA}_{\mathcal{K}}(u,v)). \\
&\text{DP at internal node } v \text{ with children } a,b \text{ and weight } W=w(v): \\
&\quad t(v)=t(a)+t(b),\quad f_v(0)=
\begin{cases}
0,& t(v)=0\\
+\infty,& t(v)>0
\end{cases}, \\
&\quad \forall x\in\{1,\ldots,t(v)\}:~ f_v(x)=\min_{\substack{x_1+x_2=x\\0\le x_1\le t(a),~0\le x_2\le t(b)}} \big( \min\{f_a(x_1),~t(a)\cdot W\} + \min\{f_b(x_2),~t(b)\cdot W\} \big). \\
&\text{Leaf } u:~ t(u)=\mathbf{1}[u\in S],~ f_u(0)=0 \text{ if } t(u)=0 \text{ else } +\infty,\; f_u(1)=0 \text{ if } t(u)=1.
\end{aligned}
\]
}
\ASSUMPTIONS{Edge weights are nonnegative integers. The MST exists and is unique up to ties (any MST suffices). Kruskal reconstruction tree has $2n-1$ nodes. Placing more than $p$ servers cannot further reduce cost, so answers for $k \ge p$ equal that for $k=p$.}
\INVARIANTS{
\begin{bullets}
\item If a subtree receives at least one server, all its demands are optimally served within that subtree at cost no more than its merge weight times remaining demands.
\item DP arrays are computed only up to $t(v)$ servers since extra servers in that subtree are useless for its own demands.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute all-pairs minimax distances by building any MST and querying maximum edge on the MST path. Then, for each $k$, try all server sets of size $\le k$ (exponential) and evaluate $\sum_{s\in S}\min_{c\in C} d(s,c)$.}
\ASSUMPTIONS{Only feasible for very small $n$; serves as a correctness oracle for tiny tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build an MST of $G$ via Kruskal.
\item Precompute pairwise bottleneck distances along the MST using $n$ DFSs that track maximum edge on the path.
\item Enumerate all subsets $C \subseteq V$ with $|C|\le k$; compute the total cost and keep the best.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ in the enumeration step; only for micro validation.}
\[
\begin{aligned}
T(n) &= O(m \log m + n(n-1) + \sum_{k=1}^n \binom{n}{k} \cdot p) \\
     &= \text{intractable for large } n.
\end{aligned}
\]
\CORRECTNESS{By definition of minimax distances on MST and exhaustive enumeration, the minimum is found.}
\EDGECASES{No demands ($p=0$), single edge, equal weights, multiple optimal server placements.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); p = int(next(it))
        S = [int(next(it)) - 1 for _ in range(p)]
        edges = []
        for _e in range(m):
            u = int(next(it)) - 1; v = int(next(it)) - 1; w = int(next(it))
            edges.append((w, u, v))
        tests.append((n, m, p, S, edges))
    return tests

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> bool:
        a = self.find(a); b = self.find(b)
        if a == b: return False
        if self.r[a] < self.r[b]:
            a, b = b, a
        self.p[b] = a
        if self.r[a] == self.r[b]:
            self.r[a] += 1
        return True

def mst_build(n: int, edges: List[Tuple[int,int,int]]) -> List[List[Tuple[int,int]]]:
    g = [[] for _ in range(n)]
    dsu = DSU(n)
    edges_sorted = sorted(edges)
    cnt = 0
    for w,u,v in edges_sorted:
        if dsu.union(u,v):
            g[u].append((v,w))
            g[v].append((u,w))
            cnt += 1
            if cnt == n-1: break
    return g

def all_pairs_bottleneck_on_tree(g: List[List[Tuple[int,int]]]) -> List[List[int]]:
    n = len(g)
    # For each source, DFS to compute max edge on path
    dist = [[0]*n for _ in range(n)]
    sys.setrecursionlimit(10000)
    def dfs(s: int, u: int, p: int, curmax: int):
        dist[s][u] = curmax
        for v,w in g[u]:
            if v == p: continue
            dfs(s, v, u, max(curmax, w))
    for s in range(n):
        dfs(s, s, -1, 0)
    return dist

def brute_best_cost(dmat: List[List[int]], n: int, Sset: List[int], k: int) -> int:
    # enumerate subsets up to k, n<=12 for tests
    from itertools import combinations
    if k == 0:
        return 10**18 if len(Sset) > 0 else 0
    best = 10**18
    # small pruning: if k >= n, servers everywhere
    if k >= n:
        return 0
    for r in range(1, min(k, n)+1):
        for C in combinations(range(n), r):
            total = 0
            for s in Sset:
                best_to = min(dmat[s][c] for c in C)
                total += best_to
                if total >= best: break
            if total < best:
                best = total
    return best

def solve_case_baseline(n: int, m: int, p: int, S: List[int], edges: List[Tuple[int,int,int]]) -> List[int]:
    tree = mst_build(n, edges)
    dmat = all_pairs_bottleneck_on_tree(tree)
    ans = []
    for k in range(1, n+1):
        ans.append(brute_best_cost(dmat, n, S, k))
    return ans

def solve_all_baseline(data: str) -> str:
    tests = read_input(data)
    out_lines = []
    for (n,m,p,S,edges) in tests:
        res = solve_case_baseline(n,m,p,S,edges)
        out_lines.append(" ".join(str(x) for x in res))
    return "\n".join(out_lines)

if __name__ == "__main__":
    # Tiny self-checks (small n only)
    data = """2
2 1 1
1
1 2 5
3 2 2
1 3
1 2 3
2 3 5
"""
    out = solve_all_baseline(data)
    # For case1: placing server at 1 gives 0; case2: k=1 -> 5, k>=2 -> 0
    lines = out.strip().splitlines()
    assert lines[0].strip() == "0 0"
    assert lines[1].strip() == "5 0 0"
    print("OK-baseline")
\end{minted}
\VALIDATION{The asserts validate the two sample-like scenarios mentioned.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{MST + Kruskal Reconstruction Tree DP}
\WHICHFORMULA{Use MST to induce the minimax metric. Build the Kruskal reconstruction tree of the MST: each union creates an internal node labeled by the edge weight. The distance between two original vertices equals the weight of their LCA in this tree. A subtree with at least one server can serve any remaining demand in that subtree at the subtree's merge weight.}
\ASSUMPTIONS{Kruskal tree is binary; weights on ancestors are nondecreasing along any path.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Run Kruskal on the original graph. For each chosen MST edge $(u,v,w)$: create a new node $x$, set $w(x)=w$, and make the current component roots of $u$ and $v$ children of $x$; union them with $x$ as representative.
\item Let $t(v)$ be the number of demands in $v$'s subtree.
\item DP bottom-up. For leaf $u$: $f_u(0)=0$ if $t(u)=0$ else $+\infty$; if $t(u)=1$, $f_u(1)=0$.
\item For internal $v$ with children $a,b$ and weight $W$: for $x\in[1..t(v)]$,
\begin{BreakableEquation*}
f_v(x)=\min_{x_1+x_2=x}\big(\min\{f_a(x_1),~t(a)\cdot W\}+\min\{f_b(x_2),~t(b)\cdot W\}\big),
\end{BreakableEquation*}
and $f_v(0)=0$ if $t(v)=0$ else $+\infty$.
\item The answer for at most $k$ servers is $\min_{1\le x \le \min(k,p)} f_{\text{root}}(x)$, extended flat for $k>p$.
\end{algosteps}
\COMPLEXITY{Let $p=|S|$. Arrays are sized by $t(v)+1\le p+1$. Each internal merge costs $O(t(a)\cdot t(b))$, and $\sum t(a)t(b) = O(p^2)$ over the tree.}
\[
\begin{aligned}
T(n) &= O(m\log m + p^2) \\
S(n) &= O(n + p^2) \text{ (DP storage over all nodes)}.
\end{aligned}
\]
\CORRECTNESS{In an ultrametric induced by the Kruskal tree, cross-child assignment across a node $v$ costs exactly $w(v)$ per demand and never benefits from postponing to ancestors (weights are nondecreasing). Thus, if at least one server exists in a subtree, all its demands are optimally finalized within that subtree, justifying the transition.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import sys

def read_input(s: str):
    it = iter(s.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); p = int(next(it))
        S = [int(next(it)) - 1 for _ in range(p)]
        E = []
        for _e in range(m):
            u = int(next(it)) - 1; v = int(next(it)) - 1; w = int(next(it))
            E.append((w,u,v))
        cases.append((n,m,p,S,E))
    return cases

class DSURebuild:
    def __init__(self, cap: int):
        self.par = list(range(cap))
    def find(self, x: int) -> int:
        while self.par[x] != x:
            self.par[x] = self.par[self.par[x]]
            x = self.par[x]
        return x
    def make_parent(self, a: int, b: int, newroot: int):
        a = self.find(a); b = self.find(b)
        self.par[a] = newroot
        self.par[b] = newroot
        self.par[newroot] = newroot

def build_kruskal_tree(n: int, edges: List[Tuple[int,int,int]]):
    # Returns (root, children, weight, is_term, total_nodes)
    edges_sorted = sorted(edges)
    children = [[] for _ in range(2*n+5)]
    weight = [0]*(2*n+5)
    is_term = [False]*(2*n+5)
    dsu = DSURebuild(2*n+5)
    cur = n  # last used id
    cnt = 0
    for w,u,v in edges_sorted:
        ru = dsu.find(u); rv = dsu.find(v)
        if ru == rv: continue
        cur += 1
        weight[cur] = w
        children[cur].append(ru)
        children[cur].append(rv)
        dsu.make_parent(ru, rv, cur)
        cnt += 1
        if cnt == n-1: break
    root = cur
    return root, children, weight, is_term, cur

def dp_kruskal(root: int, children: List[List[int]], weight: List[int], is_term: List[bool], pset: List[bool]) -> List[int]:
    sys.setrecursionlimit(10000)
    N = len(children)
    tcount = [0]*N
    dp = {}  # node -> list of size tcount+1
    def dfs(u: int):
        if not children[u]:
            tcount[u] = 1 if pset[u] else 0
            if tcount[u] == 0:
                dp[u] = [0]
            else:
                dp[u] = [10**30, 0]
            return
        a,b = children[u]
        dfs(a); dfs(b)
        ta, tb = tcount[a], tcount[b]
        tcount[u] = ta + tb
        W = weight[u]
        res = [10**30]*(tcount[u]+1)
        if tcount[u] == 0:
            res[0] = 0
        # x >= 1
        for x in range(1, tcount[u]+1):
            lo = max(0, x - tb)
            hi = min(x, ta)
            best = 10**30
            cap_a = ta * W
            cap_b = tb * W
            da = dp[a]; db = dp[b]
            for x1 in range(lo, hi+1):
                x2 = x - x1
                va = da[x1] if x1 <= ta else 10**30
                vb = db[x2] if x2 <= tb else 10**30
                cand = min(va, cap_a) + min(vb, cap_b)
                if cand < best:
                    best = cand
            res[x] = best
        dp[u] = res
        return
    dfs(root)
    return dp[root]

def solve_case_improved(n: int, m: int, p: int, S: List[int], edges: List[Tuple[int,int,int]]) -> List[int]:
    root, children, weight, is_term, last = build_kruskal_tree(n, edges)
    # mark terminals on original leaves [0..n-1]
    pset = [False]*(len(children))
    for s in S:
        pset[s] = True
    dproot = dp_kruskal(root, children, weight, is_term, pset)
    pcount = sum(1 for s in S)
    # answers for k=1..n: prefix minima of dproot[1..p]
    pref = [10**30]*(pcount+1)
    curmin = 10**30
    for x in range(1, pcount+1):
        if dproot[x] < curmin:
            curmin = dproot[x]
        pref[x] = curmin
    ans = []
    for k in range(1, n+1):
        kk = min(k, pcount)
        if kk == 0:
            ans.append(0)
        else:
            ans.append(pref[kk])
    return ans

def solve_all_improved(data: str) -> str:
    outs = []
    for (n,m,p,S,E) in read_input(data):
        outs.append(" ".join(map(str, solve_case_improved(n,m,p,S,E))))
    return "\n".join(outs)

if __name__ == "__main__":
    # Validations on small crafted cases
    data = """2
2 1 1
1
1 2 5
3 2 2
1 3
1 2 3
2 3 5
"""
    out = solve_all_improved(data).splitlines()
    assert out[0].strip() == "0 0"
    assert out[1].strip() == "5 0 0"
    # Edge: all vertices demanded, star with equal weights
    data2 = """1
3 3 3
1 2 3
1 2 7
1 3 7
2 3 9
"""
    # k=1 -> place at 1: costs 7+0+7=14; better is 7+7+0=14 anyway; k>=2 -> you can place at 1 and 2 -> 0+0+7=7; k>=3 -> 0
    out2 = solve_all_improved(data2).strip()
    assert out2 == "14 7 0"
    print("OK-improved")
\end{minted}
\VALIDATION{Three asserts: two previous tiny cases and a star-like graph with equal heavy spokes.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Ultrametric DP on Kruskal Tree (Final)}
\WHICHFORMULA{Kruskal reconstruction tree DP with transition $f_v(x)=\min_{x_1+x_2=x}\big(\min\{f_a(x_1), t(a)\cdot w(v)\}+\min\{f_b(x_2), t(b)\cdot w(v)\}\big)$.}
\ASSUMPTIONS{Edge weights are integers; MST is built by Kruskal; reconstruction tree is binary.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build Kruskal reconstruction tree while running MST Kruskal on the input graph.
\item Compute $t(v)$ and $f_v(\cdot)$ bottom-up (postorder).
\item For each test, produce prefix minima $\min_{1\le x\le \min(k,p)} f_{\text{root}}(x)$ for $k=1,\ldots,n$.
\end{algosteps}
\OPTIMALITY{In any ultrametric, ancestor weights are nondecreasing; thus serving any leftover demand at the lowest possible ancestor that contains at least one server is never worse than pushing it higher. This establishes the optimal substructure used by the DP, yielding globally optimal solutions for every $k$.}
\COMPLEXITY{$O(m\log m + p^2)$ time per test, $O(n + p^2)$ space; optimal under the given approach.}
\[
\begin{aligned}
T(n) &= O(m\log m) + O\!\left(\sum_{\text{internal }v} t(\text{left}(v)) \cdot t(\text{right}(v))\right) = O(m\log m + p^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
import sys

# ========== I/O ==========
def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); p = int(next(it))
        S = [int(next(it)) - 1 for _ in range(p)]
        E = []
        for _ in range(m):
            u = int(next(it)) - 1; v = int(next(it)) - 1; w = int(next(it))
            E.append((w,u,v))
        tests.append((n,m,p,S,E))
    return tests

# ========== Kruskal Reconstruction Tree Builder ==========
class DSURebuild:
    def __init__(self, cap: int):
        self.par = list(range(cap))
    def find(self, x: int) -> int:
        while self.par[x] != x:
            self.par[x] = self.par[self.par[x]]
            x = self.par[x]
        return x
    def make_parent(self, a: int, b: int, newroot: int):
        a = self.find(a); b = self.find(b)
        self.par[a] = newroot
        self.par[b] = newroot
        self.par[newroot] = newroot

def build_kruskal_tree(n: int, edges: List[Tuple[int,int,int]]):
    edges_sorted = sorted(edges)
    children = [[] for _ in range(2*n+5)]
    weight = [0]*(2*n+5)
    dsu = DSURebuild(2*n+5)
    cur = n
    merges = 0
    for w,u,v in edges_sorted:
        ru = dsu.find(u); rv = dsu.find(v)
        if ru == rv: continue
        cur += 1
        weight[cur] = w
        children[cur].append(ru)
        children[cur].append(rv)
        dsu.make_parent(ru, rv, cur)
        merges += 1
        if merges == n-1:
            break
    root = cur
    return root, children, weight

# ========== DP on Kruskal Tree ==========
def dp_on_kruskal(root: int, children: List[List[int]], weight: List[int], terminals: List[bool]) -> List[int]:
    sys.setrecursionlimit(10000)
    N = len(children)
    tcnt = [0]*N
    dp = [None]*N  # each dp[u] is a list of size tcnt[u]+1
    INF = 10**30

    def dfs(u: int):
        if not children[u]:  # leaf
            tcnt[u] = 1 if terminals[u] else 0
            if tcnt[u] == 0:
                dp[u] = [0]
            else:
                dp[u] = [INF, 0]
            return
        a,b = children[u]
        dfs(a); dfs(b)
        ta, tb = tcnt[a], tcnt[b]
        tcnt[u] = ta + tb
        W = weight[u]
        res = [INF]*(tcnt[u]+1)
        if tcnt[u] == 0:
            res[0] = 0
            dp[u] = res
            return
        da, db = dp[a], dp[b]
        cap_a = ta * W
        cap_b = tb * W
        # For x>=1
        for x in range(1, tcnt[u]+1):
            lo = max(0, x - tb)
            hi = min(x, ta)
            best = INF
            for x1 in range(lo, hi+1):
                x2 = x - x1
                va = da[x1] if x1 <= ta else INF
                vb = db[x2] if x2 <= tb else INF
                cand = (va if va < cap_a else cap_a) + (vb if vb < cap_b else cap_b)
                if cand < best:
                    best = cand
            res[x] = best
        # x=0 only allowed if no demands
        res[0] = 0 if tcnt[u] == 0 else INF
        dp[u] = res

    dfs(root)
    return dp[root]

# ========== Solve one test ==========
def solve_case(n: int, m: int, p: int, S: List[int], edges: List[Tuple[int,int,int]]) -> List[int]:
    root, children, weight = build_kruskal_tree(n, edges)
    # terminals on original leaves 0..n-1
    terminals = [False]*(2*n+5)
    for s in S:
        terminals[s] = True
    dproot = dp_on_kruskal(root, children, weight, terminals)
    pcount = p
    # prefix minima over x=1..p
    ans_pref = [10**30]*(pcount+1)
    best = 10**30
    for x in range(1, pcount+1):
        if dproot[x] < best:
            best = dproot[x]
        ans_pref[x] = best
    res = []
    for k in range(1, n+1):
        kk = min(k, pcount)
        res.append(0 if kk == 0 else ans_pref[kk])
    return res

# ========== Solve all ==========
def solve_all(data: str) -> str:
    tests = read_input(data)
    out_lines = []
    for (n,m,p,S,E) in tests:
        out_lines.append(" ".join(map(str, solve_case(n,m,p,S,E))))
    return "\n".join(out_lines)

# ========== Main + Asserts ==========
if __name__ == "__main__":
    # Basic tests
    data = """2
2 1 1
1
1 2 5
3 2 2
1 3
1 2 3
2 3 5
"""
    out = solve_all(data).splitlines()
    assert out[0].strip() == "0 0"
    assert out[1].strip() == "5 0 0"

    # Another: triangle with different weights; MST edges picked accordingly
    data2 = """1
4 3 2
1 4
1 2 2
2 3 3
3 4 4
"""
    # Chain 1-2-3-4 with weights 2,3,4; demands at 1 and 4.
    # k=1: best place at 1 or 4: cost = 4; k=2: cost=0; k>=3: 0
    out2 = solve_all(data2).strip()
    assert out2 == "4 0 0 0"

    # Star-like equal spokes
    data3 = """1
3 3 3
1 2 3
1 2 7
1 3 7
2 3 9
"""
    out3 = solve_all(data3).strip()
    assert out3 == "14 7 0"
    print("OK-final")
\end{minted}
\VALIDATION{Exactly 3 asserts cover: tiny chain, larger chain, and a star-like graph with equal spokes and an extra edge.}
\RESULT{For each test, output $n$ integers where the $k$-th equals the minimum total latency using at most $k$ servers. For $k \ge p$, the value equals that at $k=p$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny graphs: lines, stars, equal weights; property checks that answers are nonincreasing in $k$ and reach $0$ by $k\ge p$.}
\LINE{CROSS-CHECKS}{Compare baseline enumeration on very small $n$ to improved/final DP; verify identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate connected graphs with $n\in[2,8]$, random weights, random demand sets, and cross-validate both solvers.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_connected_graph(n: int):
    # Create a random tree then add extra edges
    edges = []
    par = list(range(n))
    for v in range(1, n):
        u = random.randrange(0, v)
        w = random.randint(1, 9)
        edges.append((w, u, v))
    # add a few extra edges
    extra = min(n, 3)
    used = {(min(u,v), max(u,v)) for _,u,v in edges}
    while extra > 0:
        u = random.randrange(n); v = random.randrange(n)
        if u == v: continue
        a,b = (u,v) if u < v else (v,u)
        if (a,b) in used: continue
        used.add((a,b))
        edges.append((random.randint(1, 9), a, b))
        extra -= 1
    return edges

def random_demand(n: int, p: int):
    return random.sample(range(n), p)

def self_check_trials(trials: int = 50):
    from itertools import product
    ok = 0
    for n in range(2, 8):
        for _ in range(trials):
            edges = gen_connected_graph(n)
            for p in range(1, n+1):
                S = random_demand(n, p)
                # Build inputs
                t = 1
                m = len(edges)
                parts = [str(t), str(n), str(m), str(p)]
                parts.extend(str(x+1) for x in S)
                for (w,u,v) in edges:
                    parts.extend([str(u+1), str(v+1), str(w)])
                data = " ".join(parts)
                # Run both solvers
                from sys import setrecursionlimit
                setrecursionlimit(10000)
                out_imp = solve_all_improved(data)
                out_fin = solve_all(data)
                assert out_imp.strip() == out_fin.strip()
                # Monotonic and ends at 0 by k>=p
                arr = list(map(int, out_fin.strip().split()))
                for i in range(1, len(arr)):
                    assert arr[i] <= arr[i-1]
                assert arr[min(n, p)-1] == 0
                ok += 1
    return ok

if __name__ == "__main__":
    random.seed(0)
    # Uncomment for local fuzzing:
    # print(self_check_trials(3))
    pass
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final solver: read from stdin, write to stdout
import sys
from typing import List, Tuple

def read_input_stream() -> List[Tuple[int,int,int,List[int],List[Tuple[int,int,int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); p = int(next(it))
        S = [int(next(it)) - 1 for _ in range(p)]
        E = []
        for _ in range(m):
            u = int(next(it)) - 1; v = int(next(it)) - 1; w = int(next(it))
            E.append((w,u,v))
        tests.append((n,m,p,S,E))
    return tests

class DSURebuild:
    def __init__(self, cap: int):
        self.par = list(range(cap))
    def find(self, x: int) -> int:
        while self.par[x] != x:
            self.par[x] = self.par[self.par[x]]
            x = self.par[x]
        return x
    def make_parent(self, a: int, b: int, newroot: int):
        a = self.find(a); b = self.find(b)
        self.par[a] = newroot
        self.par[b] = newroot
        self.par[newroot] = newroot

def build_kruskal_tree(n: int, edges: List[Tuple[int,int,int]]):
    edges_sorted = sorted(edges)
    children = [[] for _ in range(2*n+5)]
    weight = [0]*(2*n+5)
    dsu = DSURebuild(2*n+5)
    cur = n
    merges = 0
    for w,u,v in edges_sorted:
        ru = dsu.find(u); rv = dsu.find(v)
        if ru == rv: continue
        cur += 1
        weight[cur] = w
        children[cur].append(ru)
        children[cur].append(rv)
        dsu.make_parent(ru, rv, cur)
        merges += 1
        if merges == n-1:
            break
    root = cur
    return root, children, weight

def dp_on_kruskal(root: int, children: List[List[int]], weight: List[int], terminals: List[bool]) -> List[int]:
    sys.setrecursionlimit(10000)
    N = len(children)
    tcnt = [0]*N
    dp = [None]*N
    INF = 10**30
    def dfs(u: int):
        if not children[u]:
            tcnt[u] = 1 if terminals[u] else 0
            if tcnt[u] == 0:
                dp[u] = [0]
            else:
                dp[u] = [INF, 0]
            return
        a,b = children[u]
        dfs(a); dfs(b)
        ta, tb = tcnt[a], tcnt[b]
        tcnt[u] = ta + tb
        W = weight[u]
        res = [INF]*(tcnt[u]+1)
        if tcnt[u] == 0:
            res[0] = 0
            dp[u] = res
            return
        da, db = dp[a], dp[b]
        cap_a = ta * W
        cap_b = tb * W
        for x in range(1, tcnt[u]+1):
            lo = max(0, x - tb)
            hi = min(x, ta)
            best = INF
            for x1 in range(lo, hi+1):
                x2 = x - x1
                va = da[x1] if x1 <= ta else INF
                vb = db[x2] if x2 <= tb else INF
                cand = (va if va < cap_a else cap_a) + (vb if vb < cap_b else cap_b)
                if cand < best:
                    best = cand
            res[x] = best
        res[0] = 0 if tcnt[u] == 0 else INF
        dp[u] = res
    dfs(root)
    return dp[root]

def solve_case(n: int, m: int, p: int, S: List[int], E: List[Tuple[int,int,int]]) -> List[int]:
    root, children, weight = build_kruskal_tree(n, E)
    terminals = [False]*(2*n+5)
    for s in S:
        terminals[s] = True
    dproot = dp_on_kruskal(root, children, weight, terminals)
    pcount = p
    ans_pref = [10**30]*(pcount+1)
    best = 10**30
    for x in range(1, pcount+1):
        if dproot[x] < best:
            best = dproot[x]
        ans_pref[x] = best
    ans = []
    for k in range(1, n+1):
        kk = min(k, pcount)
        ans.append(0 if kk == 0 else ans_pref[kk])
    return ans

def main():
    tests = read_input_stream()
    out_lines = []
    for (n,m,p,S,E) in tests:
        out_lines.append(" ".join(map(str, solve_case(n,m,p,S,E))))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Minimal sanity run when executed standalone without input
    if sys.stdin.isatty():
        demo = """2
2 1 1
1
1 2 5
3 2 2
1 3
1 2 3
2 3 5
"""
        print(main.__name__ + " demo:")
        sys.stdin = sys.__stdin__
        print(solve_case(2,1,1,[0],[(5,0,1)]))
    else:
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to an ultrametric on the MST and run a knapsack-like DP on the Kruskal reconstruction tree to get the best sum of bottleneck distances for every $k$.}
\WHY{This pattern of “serve inside subtree or pay merge weight” appears often in clustering/centroid problems on trees and MSTs.}
\CHECKLIST{
\begin{bullets}
\item Build MST by Kruskal.
\item Build reconstruction tree while Kruskal merges.
\item Count demands in subtrees.
\item DP bottom-up with the min-cap transition.
\item Prefix-min answers for $k=1..n$; flat after $k\ge p$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $p=0$ (answers all zero).
\item All demands in one component of the first merges.
\item Equal edge weights (any MST works).
\item Graph already a tree ($m=n-1$).
\item Very heavy edge isolating a single demand.
\item $k=1$ and $k\ge p$ extremes.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting that $k$ is “at most” (use prefix minima, not exact-$k$ values).
\item Allowing leftovers to bubble up when a subtree already has a server (never optimal).
\item Oversizing DP loops to $n$ instead of to $t(v)$ (causes $O(n^3)$ slowdowns).
\item Misbuilding the reconstruction tree (must attach component roots, not raw vertices).
\item Using $+\infty$ base wrongly at leaves with one demand.
\item Not handling $k>p$ as constant tail.
\end{bullets}}
\FAILMODES{Brute-force or generic $k$-median DP on distances is exponential/NP-hard in general, but the ultrametric structure makes this DP polynomial. The approach survives adversarial graphs because it depends only on the MST and the nondecreasing merge weights.}
\ELI{Turn the graph into a “merge by weight” tree. If you have at least one server in a piece, any remaining homes in that piece can connect across that piece at exactly its merge weight. Combine children with a knapsack-like step and take prefix minima over $k$.}
\NotePages{3}

\end{document}