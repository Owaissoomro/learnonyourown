% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — The Child and Binary Tree}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/438/E}}
\LINE{DIFFICULTY / RATING}{CF: 438/E, Rating: 3100}
\STATEMENT{Our child likes computer science very much, especially he likes binary trees.

Consider the sequence of $n$ distinct positive integers: $c_1, c_2, \ldots, c_n$. The child calls a vertex-weighted rooted binary tree good if and only if for every vertex $v$, the weight of $v$ is in the set $\{c_1, c_2, \ldots, c_n\}$. Also our child thinks that the weight of a vertex-weighted tree is the sum of all vertices' weights.

Given an integer $m$, can you for all $s$ ($1 \le s \le m$) calculate the number of good vertex-weighted rooted binary trees with weight $s$? Please, check the samples for better understanding what trees are considered different.

We only want to know the answer modulo $998{,}244{,}353$ ($7 \times 17 \times 223 + 1$, a prime number).

Input:
The first line contains two integers $n, m$ ($1 \le n \le 10^5$; $1 \le m \le 10^5$). The second line contains $n$ space-separated pairwise distinct integers $c_1, c_2, \ldots, c_n$. ($1 \le c_i \le 10^5$).

Output:
Print $m$ lines, each line containing a single integer. The $i$-th line must contain the number of good vertex-weighted rooted binary trees whose weight exactly equal to $i$. Print the answers modulo $998{,}244{,}353$ ($7 \times 17 \times 223 + 1$, a prime number).

Note:
In the first example, there are $9$ good vertex-weighted rooted binary trees whose weight exactly equal to $3$:}
\BREAKDOWN{We must count rooted ordered binary trees where each node's weight is chosen from $\{c_i\}$ and total sum is $s$. Build an ordinary generating function and derive a functional equation, then compute coefficients up to $m$ using fast series operations modulo $998{,}244{,}353$.}
\ELI{Turn node choices into a polynomial $G(x)$; then the tree series solves a Catalan-like equation. Compute series square root and inverse to get answers.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n, m$; then $n$ distinct integers $c_1,\ldots,c_n$. Valid ranges: $1 \le n,m \le 10^5$, $1 \le c_i \le 10^5$.}
\OUTPUTS{For each $s=1,\ldots,m$, output one integer: the count of good rooted binary trees with total weight exactly $s$ modulo $998{,}244{,}353$. One per line.}
\SAMPLES{Example 1 (conceptual): $n=1, m=5, c=\{1\}$. Output: $1,2,5,14,42$ (Catalan numbers), since weight equals node count. Example 2: $n=1, m=6, c=\{2\}$. Output: $0,1,0,2,0,5$ (only even weights $2k$ appear with Catalan$_k$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G(x)=\sum_{i=1}^n x^{c_i}$ be the weight-choice polynomial. Let $F(x)=\sum_{s\ge 0} a_s x^s$ where $a_s$ is the number of good trees of total weight $s$ (with $a_0=1$ for the empty tree). A rooted ordered binary tree is either empty or a node (with weight in $\{c_i\}$) with two independent subtrees.}
\varmapStart
\var{G(x)}{polynomial of allowed node weights}
\var{F(x)}{ordinary generating function of counts by total weight}
\var{H(x)}{auxiliary series $H(x)=G(x)F(x)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
F(x) &= 1 + G(x)\,F(x)^2,\\
H(x) &= G(x)F(x),\\
\Rightarrow\quad F(x) &= \frac{1}{1-H(x)},\qquad H(x)^2 - H(x) + G(x)=0,\\
H(x) &= \frac{1-\sqrt{1-4G(x)}}{2},\qquad F(x)=\frac{1}{1-H(x)}.
\end{aligned}
\]
}
\ASSUMPTIONS{Empty tree contributes $a_0=1$ (weight $0$). Distinct trees are ordered by left/right (plane) structure. Coefficients are taken modulo $998{,}244{,}353$.}
\INVARIANTS{Constant terms: $G(0)=0$, hence $H(0)=0$ and $F(0)=1$; thus $1-H$ is invertible as a formal power series. Coefficients are nonnegative integers mod prime.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Unroll the combinatorial specification at coefficient level:
$a_0=1$; for $s\ge 1$,
$a_s=\sum_{a\in C,\,a\le s}\ \sum_{i=0}^{s-a} a_i\cdot a_{s-a-i}$.}
\ASSUMPTIONS{Intended only for tiny $m$ due to quadratic summation per $s$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $a[0]=1$, and $a[s]=0$ for $s=1,\ldots,m$.
\item For $s=1$ to $m$: for every $a\in C$ with $a\le s$, sum over $i=0$ to $s-a$ the product $a[i]\cdot a[s-a-i]$ modulo $998{,}244{,}353$.
\item Output $a[1],\ldots,a[m]$.
\end{algosteps}
\COMPLEXITY{Let $K=|C|$.
\[
\begin{aligned}
T(m) &\le \sum_{s=1}^m \sum_{a\in C,\,a\le s} (s-a+1) = \Theta(K m^2),\\
S(m) &= \Theta(m).
\end{aligned}
\]
}
\CORRECTNESS{Directly mirrors the decomposition: choose root weight $a\in C$, then split remaining weight between left and right subtrees. Enumerating all splits exhausts possibilities and respects order.}
\EDGECASES{No $a\in C$ with $a\le s$ implies $a_s=0$. Distinct $c_i$ ensures no double counting of same root weight.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline O(|C| * m^2) DP; correct for tiny m (teaching/reference).
MOD = 998244353

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    c = [int(next(it)) for _ in range(n)]
    return n, m, c

def solve_case_baseline(n, m, c):
    cset = [x for x in c if x <= m]
    a = [0] * (m + 1)
    a[0] = 1
    for s in range(1, m + 1):
        total = 0
        for w in cset:
            if w <= s:
                rem = s - w
                # sum_{i=0..rem} a[i] * a[rem - i]
                # naive convolution for this s
                subt = 0
                for i in range(rem + 1):
                    subt += a[i] * a[rem - i]
                total += subt
        a[s] = total % MOD
    return a

def solve_all_baseline():
    n, m, c = read_input()
    if m == 0 and n == 0:
        return
    ans = solve_case_baseline(n, m, c)
    out = []
    for s in range(1, m + 1):
        out.append(str(ans[s] % MOD))
    print("\n".join(out))

def _test_baseline():
    # c = {1} -> Catalan numbers for weights 1..m
    n, m, c = 1, 5, [1]
    got = solve_case_baseline(n, m, c)
    # Catalan numbers: 1, 2, 5, 14, 42
    cat = [1, 1]
    for _ in range(10):
        cat.append(sum(cat[i]*cat[-1-i] for i in range(len(cat)-1)) % MOD)
    exp = [0, 1, 2, 5, 14, 42]
    assert got[:6] == exp
    # c = {2}: even weights only; weight 2k -> Catalan_k
    n, m, c = 1, 6, [2]
    got = solve_case_baseline(n, m, c)
    exp = [0, 0, 1, 0, 2, 0, 5]
    assert got[:7] == exp
    # c = {1,2}, small m cross-check by explicit enumeration equals recurrence itself
    n, m, c = 2, 4, [1, 2]
    got = solve_case_baseline(n, m, c)
    # quick sanity: nonnegative and increasing-ish
    assert all(x >= 0 for x in got)

if __name__ == "__main__" and False:
    _test_baseline()
    solve_all_baseline()
\end{minted}
\VALIDATION{The asserts check two exact families: $C=\{1\}$ yielding Catalan numbers and $C=\{2\}$ yielding Catalan on even indices.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Divide-and-Conquer Convolution}
\WHICHFORMULA{Speed up the inner convolution using polynomial multiplication: for fixed $C$, the recurrence is a sum of shifted self-convolutions of $F$. A D\&C over $s$ lets us reuse convolutions in $O(m \log m)$ time if we had fast convolution.}
\ASSUMPTIONS{Requires an efficient convolution (e.g., NTT) and careful trimming to ranges.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain $F[0..m]$, initially $F[0]=1$.
\item Recursively solve $F$ on segments $[L,M]$ then use known part to update the next segment via batched convolutions with mask $G$.
\item Use NTT to multiply and accumulate contributions for the next block.
\end{algosteps}
\COMPLEXITY{With NTT-backed convolutions,
\[
\begin{aligned}
T(m) &= O(m \log m), \quad S(m) = O(m).
\end{aligned}
\]
}
\CORRECTNESS{The D\&C ensures each coefficient uses only prior coefficients, matching the recurrence and preserving causality.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Skeleton reference: in practice, prefer the closed-form series route in Approach C.
# Here we keep the same API but omit a full D&C to avoid redundancy.
MOD = 998244353

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    c = [int(next(it)) for _ in range(n)]
    return n, m, c

def solve_case_improved(n, m, c):
    # Placeholder thin wrapper to delegate to optimal method for determinism.
    return solve_case_final(n, m, c)

def solve_all_improved():
    n, m, c = read_input()
    if m == 0 and n == 0:
        return
    ans = solve_case_improved(n, m, c)
    out = []
    for s in range(1, m + 1):
        out.append(str(ans[s] % MOD))
    print("\n".join(out))

def _test_improved():
    # Delegate tests to final method's tests for consistency.
    pass

if __name__ == "__main__" and False:
    solve_all_improved()
\end{minted}
\VALIDATION{Delegates to the optimal implementation to avoid duplication while keeping API integrity for testing.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Series Square Root and Inverse via NTT}
\WHICHFORMULA{Use
$H(x)=\dfrac{1-\sqrt{1-4G(x)}}{2}$ and $F(x)=\dfrac{1}{1-H(x)}$.
Compute $\sqrt{1-4G}$ by Newton iteration and invert $1-H$ by Newton iteration, both via NTT.}
\ASSUMPTIONS{Modulus $998{,}244{,}353$ supports NTT: primitive root $g=3$. Input degrees $\le m$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $G(x)$ with $G[d]=1$ for $d\in\{c_i\}$ and $d\le m$.
\item Form $A(x)=1-4G(x)$ truncated to degree $m$; compute $S(x)=\sqrt{A(x)}$ with $S(0)=1$ via Newton.
\item Let $H(x)=\tfrac{1-S(x)}{2}$ coefficient-wise.
\item Compute $F(x)=(1-H(x))^{-1}$ via series inverse Newton iteration.
\item Output $[x^s]F$ for $s=1,\ldots,m$.
\end{algosteps}
\OPTIMALITY{Each Newton iteration doubles precision; each step costs one or a few NTTs at the current length, yielding $O(m\log m)$ time. This matches known lower bounds for reading/writing $m$ coefficients.}
\COMPLEXITY{
\[
\begin{aligned}
T(m) &= O(m \log m),\quad S(m)=O(m).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final CF-ready solution: NTT + series sqrt + inverse
MOD = 998244353
PRIMITIVE_ROOT = 3

def _modinv(a):
    return pow(a, MOD - 2, MOD)

def _ntt(a, invert=False):
    n = len(a)
    j = 0
    for i in range(1, n):
        bit = n >> 1
        while j & bit:
            j ^= bit
            bit >>= 1
        j ^= bit
        if i < j:
            a[i], a[j] = a[j], a[i]
    len_ = 2
    while len_ <= n:
        wlen = pow(PRIMITIVE_ROOT, (MOD - 1) // len_, MOD)
        if invert:
            wlen = _modinv(wlen)
        for i in range(0, n, len_):
            w = 1
            half = len_ >> 1
            for j in range(i, i + half):
                u = a[j]
                v = a[j + half] * w % MOD
                a[j] = (u + v) % MOD
                a[j + half] = (u - v) % MOD
                w = w * wlen % MOD
        len_ <<= 1
    if invert:
        inv_n = _modinv(n)
        for i in range(n):
            a[i] = a[i] * inv_n % MOD

def _convolve(a, b, need=None):
    # multiply and optionally truncate to 'need' terms
    n = 1
    na = len(a); nb = len(b)
    if need is None:
        need = na + nb - 1
    else:
        need = min(need, na + nb - 1)
    size = 1
    while size < na + nb - 1:
        size <<= 1
    fa = a[:] + [0] * (size - na)
    fb = b[:] + [0] * (size - nb)
    _ntt(fa, invert=False)
    _ntt(fb, invert=False)
    for i in range(size):
        fa[i] = fa[i] * fb[i] % MOD
    _ntt(fa, invert=True)
    return fa[:need]

def _poly_inv(a, n):
    # inverse of a modulo x^n; requires a[0] != 0
    assert a[0] % MOD != 0
    inv_a0 = _modinv(a[0])
    g = [inv_a0]
    m = 1
    while m < n:
        m2 = min(2 * m, n)
        # t = a[:m2]
        t = a[:m2]
        # compute g * g * t? No: Newton: g' = g * (2 - t*g) mod x^m2
        tg = _convolve(t, g, need=m2)
        for i in range(len(tg)):
            tg[i] = (-tg[i]) % MOD
        tg[0] = (tg[0] + 2) % MOD
        g = _convolve(g, tg, need=m2)
        m = m2
    return g[:n]

def _poly_sqrt(a, n):
    # sqrt of a modulo x^n with a[0] = 1; returns s with s^2 = a
    assert a[0] % MOD == 1
    s = [1]
    inv2 = (MOD + 1) // 2
    m = 1
    while m < n:
        m2 = min(2 * m, n)
        # Compute s' = (s + a / s) / 2 modulo x^m2
        # Need inv_s modulo x^m2
        inv_s = _poly_inv(s, m2)
        a_cut = a[:m2]
        q = _convolve(a_cut, inv_s, need=m2)
        # s + q
        s_new = [0] * m2
        for i in range(m2):
            v = ( (s[i] if i < len(s) else 0) + q[i] ) % MOD
            s_new[i] = v * inv2 % MOD
        s = s_new
        m = m2
    return s[:n]

def solve_case_final(n, m, c):
    # Build G(x)
    G = [0] * (m + 1)
    for w in c:
        if 1 <= w <= m:
            G[w] = 1
    # A(x) = 1 - 4 G(x)
    A = [0] * (m + 1)
    A[0] = 1
    for i in range(1, m + 1):
        if G[i]:
            A[i] = (-4) % MOD
        else:
            A[i] = 0
    # S = sqrt(A)
    S = _poly_sqrt(A, m + 1)
    inv2 = (MOD + 1) // 2
    # H = (1 - S)/2
    H = [0] * (m + 1)
    for i in range(m + 1):
        H[i] = ((1 if i == 0 else 0) - S[i]) % MOD
        H[i] = H[i] * inv2 % MOD
    # denom = 1 - H
    denom = [0] * (m + 1)
    denom[0] = (1 - H[0]) % MOD
    for i in range(1, m + 1):
        denom[i] = (-H[i]) % MOD
    # F = inv(denom)
    F = _poly_inv(denom, m + 1)
    return F

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    c = [int(next(it)) for _ in range(n)]
    return n, m, c

def solve_all():
    n, m, c = read_input()
    if m == 0 and n == 0:
        return
    F = solve_case_final(n, m, c)
    out_lines = []
    for s in range(1, m + 1):
        out_lines.append(str(F[s] % MOD))
    print("\n".join(out_lines))

def _catalans(kmax):
    C = [0] * (kmax + 1)
    C[0] = 1
    for n in range(1, kmax + 1):
        s = 0
        for i in range(n):
            s = (s + C[i] * C[n - 1 - i]) % MOD
        C[n] = s
    return C

def _test_final():
    # Test 1: c={1} -> Catalan numbers
    n, m, c = 1, 8, [1]
    F = solve_case_final(n, m, c)
    cats = _catalans(m)
    assert F[0] == 1
    for s in range(1, m + 1):
        assert F[s] % MOD == cats[s] % MOD
    # Test 2: c={2} -> even weights 2k -> Catalan_k
    n, m, c = 1, 8, [2]
    F = solve_case_final(n, m, c)
    cats = _catalans(m // 2 + 2)
    for s in range(1, m + 1):
        if s % 2 == 1:
            assert F[s] == 0
        else:
            assert F[s] == cats[s // 2]
    # Test 3: random small set vs baseline
    n, m, c = 3, 6, [1, 2, 4]
    Fb = solve_case_baseline(n, m, c)
    F = solve_case_final(n, m, c)
    assert F[:m + 1] == Fb[:m + 1]

if __name__ == "__main__":
    # Run self-tests (lightweight) then solve
    _test_final()
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts families: (1) $C=\{1\}$ against Catalan; (2) $C=\{2\}$ against even-indexed Catalan; (3) small mixed set against baseline DP.}
\RESULT{For each $s=1,\ldots,m$, output $[x^s]F(x)$ where $F(x)=\dfrac{1}{1-\tfrac{1-\sqrt{1-4G(x)}}{2}}$ and $G(x)=\sum_{i=1}^n x^{c_i}$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test polynomial primitives (inverse and sqrt) on simple series; verify problem-specific identities on known families ($\{1\}$, $\{2\}$); cross-check against baseline for small $m$.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A and C on random small inputs; ensure parity patterns (e.g., only even weights for even-only $C$).}
\LINE{EDGE-CASE GENERATOR}{Generate tiny $m\le 8$ and random $C\subseteq[1..m]$; compare slow DP vs final NTT method.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
MOD = 998244353

def gen_cases():
    yield (1, 8, [1])
    yield (1, 8, [2])
    yield (0, 0, [])
    yield (3, 6, [1, 2, 4])
    yield (3, 6, [2, 3, 5])

def run_cross_checks():
    for n, m, c in gen_cases():
        if m == 0 and n == 0:
            continue
        fast = solve_case_final(n, m, c)
        slow = solve_case_baseline(n, m, c) if m <= 30 else None
        if slow is not None:
            assert fast[:m+1] == slow[:m+1]
    # Stress a random but deterministic case
    n, m = 10, 20
    c = [1, 3, 4, 7, 8, 9, 11, 12, 17, 19]
    fast = solve_case_final(n, m, c)
    # trivial sanity: F[0]=1 and nonnegativity modulo MOD
    assert fast[0] == 1
    assert all(0 <= x < MOD for x in fast)

if __name__ == "__main__" and False:
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Codeforces 438E — The Child and Binary Tree
# NTT-based series sqrt + inverse in O(m log m)
MOD = 998244353
PRIMITIVE_ROOT = 3

def _modinv(a): return pow(a, MOD - 2, MOD)

def _ntt(a, invert=False):
    n = len(a); j = 0
    for i in range(1, n):
        bit = n >> 1
        while j & bit:
            j ^= bit; bit >>= 1
        j ^= bit
        if i < j: a[i], a[j] = a[j], a[i]
    length = 2
    while length <= n:
        wlen = pow(PRIMITIVE_ROOT, (MOD - 1) // length, MOD)
        if invert: wlen = _modinv(wlen)
        for i in range(0, n, length):
            w = 1; half = length >> 1
            for j in range(i, i + half):
                u = a[j]; v = a[j + half] * w % MOD
                a[j] = (u + v) % MOD
                a[j + half] = (u - v) % MOD
                w = w * wlen % MOD
        length <<= 1
    if invert:
        inv_n = _modinv(n)
        for i in range(n):
            a[i] = a[i] * inv_n % MOD

def _convolve(a, b, need=None):
    na, nb = len(a), len(b)
    if na == 0 or nb == 0:
        return [] if need is None else [0] * need
    tot = na + nb - 1
    if need is None: need = tot
    else: need = min(need, tot)
    n = 1
    while n < tot: n <<= 1
    fa = a[:] + [0] * (n - na)
    fb = b[:] + [0] * (n - nb)
    _ntt(fa, False); _ntt(fb, False)
    for i in range(n): fa[i] = fa[i] * fb[i] % MOD
    _ntt(fa, True)
    return fa[:need]

def _poly_inv(a, n):
    assert a[0] % MOD != 0
    g = [_modinv(a[0])]
    m = 1
    while m < n:
        m2 = min(2 * m, n)
        t = a[:m2]
        tg = _convolve(t, g, need=m2)
        for i in range(len(tg)): tg[i] = (-tg[i]) % MOD
        tg[0] = (tg[0] + 2) % MOD
        g = _convolve(g, tg, need=m2)
        m = m2
    return g[:n]

def _poly_sqrt(a, n):
    # assumes a[0] == 1
    assert a[0] % MOD == 1
    s = [1]
    inv2 = (MOD + 1) // 2
    m = 1
    while m < n:
        m2 = min(2 * m, n)
        inv_s = _poly_inv(s, m2)
        q = _convolve(a[:m2], inv_s, need=m2)
        s_new = [0] * m2
        for i in range(m2):
            s_new[i] = ((s[i] if i < len(s) else 0) + q[i]) * inv2 % MOD
        s = s_new
        m = m2
    return s[:n]

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data: return 0, 0, []
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    c = [int(next(it)) for _ in range(n)]
    return n, m, c

def solve_case(n, m, c):
    G = [0] * (m + 1)
    for w in c:
        if 1 <= w <= m:
            G[w] = 1
    A = [0] * (m + 1)
    A[0] = 1
    for i in range(1, m + 1):
        A[i] = (-4) % MOD if G[i] else 0
    S = _poly_sqrt(A, m + 1)
    inv2 = (MOD + 1) // 2
    H = [0] * (m + 1)
    for i in range(m + 1):
        H[i] = ((1 if i == 0 else 0) - S[i]) % MOD
        H[i] = H[i] * inv2 % MOD
    denom = [0] * (m + 1)
    denom[0] = (1 - H[0]) % MOD
    for i in range(1, m + 1):
        denom[i] = (-H[i]) % MOD
    F = _poly_inv(denom, m + 1)
    return F

def solve_all():
    n, m, c = read_input()
    if m == 0 and n == 0:
        return
    F = solve_case(n, m, c)
    out = []
    for s in range(1, m + 1):
        out.append(str(F[s] % MOD))
    print("\n".join(out))

def _test():
    # c={1} -> Catalans
    def catalan(kmax):
        C = [0] * (kmax + 1)
        C[0] = 1
        for n in range(1, kmax + 1):
            s = 0
            for i in range(n):
                s = (s + C[i] * C[n - 1 - i]) % MOD
            C[n] = s
        return C
    n, m, c = 1, 8, [1]
    F = solve_case(n, m, c)
    cats = catalan(m)
    assert F[0] == 1
    for s in range(1, m + 1):
        assert F[s] == cats[s]
    # c={2} -> even weights
    n, m, c = 1, 10, [2]
    F = solve_case(n, m, c)
    cats = catalan(m // 2 + 3)
    for s in range(1, m + 1):
        if s % 2 == 1:
            assert F[s] == 0
        else:
            assert F[s] == cats[s // 2]
    # small mixed set vs slow DP
    def slow(n, m, c):
        a = [0] * (m + 1)
        a[0] = 1
        cs = [x for x in c if x <= m]
        for s in range(1, m + 1):
            val = 0
            for w in cs:
                if w <= s:
                    rem = s - w
                    tmp = 0
                    for i in range(rem + 1):
                        tmp += a[i] * a[rem - i]
                    val += tmp
            a[s] = val % MOD
        return a
    n, m, c = 3, 6, [1, 2, 4]
    F = solve_case(n, m, c)
    Fb = slow(n, m, c)
    assert F[:m + 1] == Fb[:m + 1]

if __name__ == "__main__":
    _test()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Binary tree GF: $F=1+G F^2 \Rightarrow H=\tfrac{1-\sqrt{1-4G}}{2}$ and $F=(1-H)^{-1}$. Compute via NTT-based series sqrt and inverse.}
\WHY{Tests fast formal power series operations under a friendly NTT modulus; appears in advanced generating functions and CF 3000+.}
\CHECKLIST{
\begin{bullets}
\item Build $G$ correctly as a $0/1$ mask up to degree $m$.
\item Form $A=1-4G$ and ensure $A[0]=1$ for series sqrt.
\item Newton for sqrt: start with $1$, double precision each step.
\item Compute $H=(1-S)/2$; verify $H[0]=0$.
\item Invert $1-H$ by Newton; output $F[1..m]$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $c_i>m$ contribute nothing.
\item $n=0$ impossible per statement; still safe if read.
\item $m=1$ trivial small output.
\item Only even $c_i$ implies odd coefficients are $0$.
\item Single $c=\{1\}$ recovers Catalan numbers.
\item Disjoint $c$ with large gaps: coefficients may be sparse early.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to truncate after each convolution step.
\item Wrong initial constant term for sqrt (must be $1$).
\item Dividing by a series with zero constant term; avoid by using $H$ route.
\item NTT inverse normalization missing.
\item Overflow if using Python integers is safe; in C\texttt{++} must mod-reduce aggressively.
\item Mixing in-place arrays across Newton steps causing aliasing.
\end{bullets}
}
\FAILMODES{Quadratic DP times out at $m=10^5$. Direct closed-form requiring division by $G$ fails as $G(0)=0$. The $H$-based formulation avoids non-invertibility and keeps constant term $1$ where needed.}
\ELI{We encode ``choose weight and two subtrees'' as an equation on power series, then use fast math (square roots and reciprocals of polynomials) to read off the counts. The NTT makes polynomial multiplications fast under the given prime.}
\NotePages{3}

\end{document}