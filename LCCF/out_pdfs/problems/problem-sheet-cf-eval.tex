% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Eval}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/470/C}}
\LINE{DIFFICULTY / RATING}{CF: 470/C, Rating: 1900}
\STATEMENT{You are given a simple arithmetic expression of the form a?b, where a and b are integer constants, and ? can be one of the following operations: `+' (addition), `-' (subtraction), `*' (multiplication), `/' (integer division) or `\%' (modulo operation).

Output the result of evaluation of this expression.

Input:
The input is a single line containing an expression a?b. Here a and b are integers between 1 and 999, inclusive; ? is an operation character: `+', `-' (ASCII code 45), `*', `/' or `\%'.

Output:
Output a single integer — the result of evaluation of this expression.}
\BREAKDOWN{Parse the operator and the two operands from the single-line expression, evaluate using integer arithmetic, and print the result.}
\ELI{Find the operator between two numbers, do that operation, and print the answer.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single line string of the exact form a?b with no spaces, where $a,b \in \{1,\ldots,999\}$ and $? \in \{+,-,*,/,\%\}$.}
\OUTPUTS{A single integer: $a+b$, $a-b$, $a\times b$, $\left\lfloor \tfrac{a}{b} \right\rfloor$ (for positive $a,b$), or $a\bmod b$ depending on the operator.}
\SAMPLES{Example 1:
Input
3+4
Output
7

Example 2:
Input
10\%3
Output
1}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given integers $a,b \in \{1,\ldots,999\}$ and an operation symbol $o \in \{+,-,*,/,\%\}$, compute $E(a,o,b)$.}
\varmapStart
\var{a}{left operand (positive integer)}
\var{b}{right operand (positive integer)}
\var{o}{operator, one of $+,-,*,/,\%$}
\var{E}{the evaluated integer result}
\varmapEnd
\GOVERN{
\[
E(a,o,b)=
\begin{cases}
a+b, & o=\texttt{+},\\
a-b, & o=\texttt{-},\\
a\cdot b, & o=\texttt{*},\\
\left\lfloor \dfrac{a}{b} \right\rfloor, & o=\texttt{/},\\
a\bmod b, & o=\texttt{\%}.
\end{cases}
\]
}
\ASSUMPTIONS{The input contains exactly one operator; $b\ge 1$ so division and modulo are defined; numbers have no leading signs and no spaces.}
\INVARIANTS{The operator position uniquely splits the string into two nonempty digit substrings. For $a,b\ge 1$, Python's integer division $a//b$ equals C/C\texttt{++} truncation.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Scan the string to locate the unique operator, split into $a$ and $b$, and apply the corresponding arithmetic.}
\ASSUMPTIONS{No spaces; both operands are positive; exactly one operator among $+,-,*,/,\%$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read the input line and strip trailing whitespace.
\item Find the index $i$ where the character is in $\{+,-,*,/,\%\}$.
\item Parse $a=\text{int}(\text{line}[:i])$, $b=\text{int}(\text{line}[i+1:])$, and compute by operator.
\end{algosteps}
\COMPLEXITY{All operations are on constant-length strings (at most 3 digits per number), so $T(n)=\mathcal{O}(1)$, $S(n)=\mathcal{O}(1)$.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(1)\ \text{(single pass over up to 7 chars)} \\
S(n) &= \mathcal{O}(1).
\end{aligned}
\]
\CORRECTNESS{Because operands are positive and the operator set is disjoint from digits, the unique operator split is well-defined; evaluation cases cover all possibilities.}
\EDGECASES{Minimums like 1+1; maximums like 999*999; divisive cases like 9/2 and 10\%3; subtraction 1-999 producing negatives is still correct as an integer.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import Tuple

OPS = set("+-*/%")

def read_input(data: str | None = None) -> str:
    if data is None:
        data = sys.stdin.read()
    return data

def parse_expr(expr: str) -> Tuple[int, str, int]:
    s = expr.strip()
    op_idx = -1
    for i, ch in enumerate(s):
        if ch in OPS:
            op_idx = i
            break
    assert op_idx > 0 and op_idx < len(s) - 1, "Invalid expression structure"
    a = int(s[:op_idx])
    b = int(s[op_idx + 1:])
    op = s[op_idx]
    return a, op, b

def eval_expr(a: int, op: str, b: int) -> int:
    if op == '+':
        return a + b
    if op == '-':
        return a - b
    if op == '*':
        return a * b
    if op == '/':
        # a, b >= 1 so // matches CF semantics
        return a // b
    if op == '%':
        return a % b
    raise ValueError("Unknown operator")

def solve_case(expr: str) -> str:
    a, op, b = parse_expr(expr)
    return str(eval_expr(a, op, b))

def solve_all(data: str) -> str:
    # Use the first non-empty line
    for line in data.splitlines():
        line = line.strip()
        if line:
            return solve_case(line)
    return ""

def _run_tests() -> None:
    assert solve_case("1+2") == "3"
    assert solve_case("10-3") == "7"
    assert solve_case("7*8") == "56"
    assert solve_case("9/2") == "4"
    assert solve_case("100%7") == "2"
    assert solve_case("999/1") == "999"

def main() -> None:
    data = sys.stdin.read()
    if data.strip():
        out = solve_all(data)
        if out:
            print(out)
    else:
        _run_tests()
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks: Parsing first operator works as there are no signs; division by zero cannot occur since $b\ge 1$; floor division equals truncation for positive operands.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use a tiny dispatch table (dictionary) mapping operators to functions for clarity and constant-time selection; optionally accept stray whitespace robustly.}
\ASSUMPTIONS{Same as baseline; tolerate incidental surrounding whitespace.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Strip input and identify the first operator index.
\item Convert substrings to integers.
\item Look up the operator in a dispatch dictionary and apply it.
\end{algosteps}
\COMPLEXITY{Same $\mathcal{O}(1)$ time and space; the dispatch removes conditional chains.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(1).
\end{aligned}
\]
\CORRECTNESS{The dispatch table is a bijection from the operator set to the intended arithmetic operation; hence evaluation is identical to the specification.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import Callable, Tuple

def read_input(data: str | None = None) -> str:
    if data is None:
        data = sys.stdin.read()
    return data

def find_op_index(s: str) -> int:
    for i, ch in enumerate(s):
        if ch in "+-*/%":
            return i
    return -1

def parse_expr(s: str) -> Tuple[int, str, int]:
    t = s.strip()
    i = find_op_index(t)
    assert 0 < i < len(t) - 1, "Invalid expression"
    a, op, b = int(t[:i]), t[i], int(t[i + 1:])
    return a, op, b

def solve_case(expr: str) -> str:
    a, op, b = parse_expr(expr)
    ops: dict[str, Callable[[int, int], int]] = {
        '+': lambda x, y: x + y,
        '-': lambda x, y: x - y,
        '*': lambda x, y: x * y,
        '/': lambda x, y: x // y,  # safe for positive x,y
        '%': lambda x, y: x % y,
    }
    return str(ops[op](a, b))

def solve_all(data: str) -> str:
    for line in data.splitlines():
        line = line.strip()
        if line:
            return solve_case(line)
    return ""

def _run_tests() -> None:
    assert solve_case("3+4") == "7"
    assert solve_case("12-20") == "-8"
    assert solve_case("81/9") == "9"
    assert solve_case("10%3") == "1"
    assert solve_case("25*40") == "1000"

def main() -> None:
    data = sys.stdin.read()
    if data.strip():
        ans = solve_all(data)
        if ans:
            print(ans)
    else:
        _run_tests()
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge inputs: smallest digits (1+1), largest digits (999*999), mixed operations; verified integer division and modulo behave as intended for $a,b\in[1,999]$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Single pass to locate operator and direct arithmetic; this is optimal under the I/O model as input length is constant-sized.}
\ASSUMPTIONS{Exactly one operator; $b\ge 1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read and strip the input line.
\item Loop once to find operator index; parse $a,b$.
\item Compute with a constant-time switch and print.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect at least one character to know the operator; with fixed-length inputs, a single pass with constant extra work is optimal.}
\COMPLEXITY{$T(n)=\mathcal{O}(1)$, $S(n)=\mathcal{O}(1)$; constants are minimal (one scan, one branch).}
\[
\begin{aligned}
T(n) &= \mathcal{O}(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str | None = None) -> str:
    if data is None:
        data = sys.stdin.read()
    return data

def solve_case(expr: str) -> str:
    s = expr.strip()
    i = -1
    for k, ch in enumerate(s):
        if ch in "+-*/%":
            i = k
            break
    assert 0 < i < len(s) - 1
    a = int(s[:i])
    b = int(s[i + 1:])
    op = s[i]
    if op == '+':
        res = a + b
    elif op == '-':
        res = a - b
    elif op == '*':
        res = a * b
    elif op == '/':
        res = a // b
    else:
        res = a % b
    return str(res)

def solve_all(data: str) -> str:
    line = ""
    for ln in data.splitlines():
        if ln.strip():
            line = ln.strip()
            break
    return solve_case(line) if line else ""

def _self_test() -> None:
    assert solve_case("1+2") == "3"
    assert solve_case("9/2") == "4"
    assert solve_case("10%3") == "1"

def main() -> None:
    data = sys.stdin.read()
    if data.strip():
        out = solve_all(data)
        if out:
            print(out)
    else:
        _self_test()
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts cover addition, integer division, and modulo; subtraction and multiplication are trivially analogous and covered in other sections.}
\RESULT{Print the evaluated integer of the expression; no extra spaces or lines beyond a single newline.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test each operator; boundary values (1 and 999); mixed-size operands; ensure integer division truncates as expected with positive inputs.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach A, B, and C on a curated set: all operators on pairs (1,1), (9,2), (10,3), (999,7), (123,456).}
\LINE{EDGE-CASE GENERATOR}{Deterministic generator enumerates representative edge cases: smallest/largest, primes, non-divisible pairs for division and modulo.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    ops = ["+", "-", "*", "/", "%"]
    nums = [1, 2, 7, 9, 10, 123, 456, 997, 998, 999]
    # Boundaries and selected pairs
    base_pairs = [(1, 1), (9, 2), (10, 3), (999, 7), (123, 456), (999, 999)]
    for a, b in base_pairs:
        for op in ops:
            if op in ("/", "%") and b == 0:
                continue
            yield f"{a}{op}{b}"

def reference_eval(expr: str) -> str:
    s = expr.strip()
    for i, ch in enumerate(s):
        if ch in "+-*/%":
            a, b, op = int(s[:i]), int(s[i+1:]), s[i]
            break
    if op == '+': return str(a + b)
    if op == '-': return str(a - b)
    if op == '*': return str(a * b)
    if op == '/': return str(a // b)
    return str(a % b)

# Quick cross-check using Approach C's solve_case signature
def cross_check() -> None:
    from typing import Callable
    def A(expr: str) -> str:
        # Inline Approach A's solver
        s = expr.strip()
        i = next(idx for idx, ch in enumerate(s) if ch in "+-*/%")
        a, b, op = int(s[:i]), int(s[i+1:]), s[i]
        if op == '+': return str(a + b)
        if op == '-': return str(a - b)
        if op == '*': return str(a * b)
        if op == '/': return str(a // b)
        return str(a % b)
    def B(expr: str) -> str:
        ops = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x // y,
            '%': lambda x, y: x % y,
        }
        s = expr.strip()
        i = next(idx for idx, ch in enumerate(s) if ch in ops)
        a, b, op = int(s[:i]), int(s[i+1:]), s[i]
        return str(ops[op](a, b))
    def C(expr: str) -> str:
        return reference_eval(expr)
    for expr in gen_cases():
        r = reference_eval(expr)
        assert A(expr) == r and B(expr) == r and C(expr) == r

if __name__ == "__main__":
    cross_check()
    print("Cross-check OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str | None = None) -> str:
    if data is None:
        data = sys.stdin.read()
    return data

def solve_case(expr: str) -> str:
    s = expr.strip()
    i = -1
    for k, ch in enumerate(s):
        if ch in "+-*/%":
            i = k
            break
    assert 0 < i < len(s) - 1
    a = int(s[:i])
    b = int(s[i + 1:])
    op = s[i]
    if op == '+':
        res = a + b
    elif op == '-':
        res = a - b
    elif op == '*':
        res = a * b
    elif op == '/':
        res = a // b
    else:
        res = a % b
    return str(res)

def solve_all(data: str) -> str:
    for line in data.splitlines():
        t = line.strip()
        if t:
            return solve_case(t)
    return ""

def _tests() -> None:
    assert solve_case("3+4") == "7"
    assert solve_case("12-20") == "-8"
    assert solve_case("81/9") == "9"
    assert solve_case("10%3") == "1"
    assert solve_case("25*40") == "1000"

def main() -> None:
    data = sys.stdin.read()
    if data.strip():
        out = solve_all(data)
        if out:
            print(out)
    else:
        _tests()
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Locate the operator between two positive integers and compute the corresponding arithmetic result.}
\WHY{Parsing tiny arithmetic expressions appears in warm-up tasks; correctness hinges on exact parsing and integer-division semantics.}
\CHECKLIST{%
\begin{bullets}
\item Strip input and ensure it is nonempty.
\item Find exactly one operator; index must be neither first nor last.
\item Convert substrings to integers safely.
\item Use integer division and modulo for positive numbers.
\item Print exactly the integer result with a trailing newline.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item Smallest values: 1+1, 1/1, 1\%1.
\item Largest values: 999*999, 999/1, 999\%1.
\item Non-divisible division: 9/2.
\item Subtraction producing negative: 1-999.
\item Multiplication near limits: 500*999.
\item Modulo with larger dividend: 10\%3.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to escape or handle \% in some languages (not an issue in Python code, but relevant in documentation).
\item Using floating-point division instead of integer division.
\item Mishandling whitespace or assuming multiple test cases.
\item Not validating operator position (start or end).
\item Accidentally reading extra lines or printing extra text in submission.
\item Treating minus as a sign (not applicable here since inputs are positive).
\end{bullets}
}
\FAILMODES{%
\begin{bullets}
\item Using true division (/) and then int-casting can fail for large values due to float; use //.
\item Assuming multiple operators or spaces would break the simple split; this solution intentionally adheres to the problem contract.
\end{bullets}
}
\ELI{This is a tiny calculator: find the math symbol between two numbers and compute using normal integer rules. Since numbers are positive, division and modulo behave predictably.}
\NotePages{3}

\end{document}