% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximum Score of Non-overlapping Intervals}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximum-score-of-non-overlapping-intervals/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a 2D integer array intervals, where intervals[i] = [l\_i, r\_i, weight\_i]. Interval i starts at position l\_i and ends at r\_i, and has a weight of weight\_i. You can choose up to 4 non-overlapping intervals. The score of the chosen intervals is defined as the total sum of their weights.

Return the lexicographically smallest array of at most 4 indices from intervals with maximum score, representing your choice of non-overlapping intervals.

Two intervals are said to be non-overlapping if they do not share any points. In particular, intervals sharing a left or right boundary are considered overlapping.

Example 1:
Input: intervals = [[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]
Output: [2,3]
Explanation:
You can choose the intervals with indices 2, and 3 with respective weights of 5, and 3.

Example 2:
Input: intervals = [[5,8,1],[6,7,7],[4,7,3],[9,10,6],[7,8,2],[11,14,3],[3,5,5]]
Output: [1,3,5,6]
Explanation:
You can choose the intervals with indices 1, 3, 5, and 6 with respective weights of 7, 6, 3, and 5.

Constraints:
- 1 \le \text{intervals.length} \le 5\times 10^4
- intervals[i].length = 3
- intervals[i] = [l\_i, r\_i, weight\_i]
- 1 \le l\_i \le r\_i \le 10^9
- 1 \le weight\_i \le 10^9}
\BREAKDOWN{We must select up to $K=4$ pairwise non-overlapping closed intervals maximizing the total weight; on ties, return the lexicographically smallest sorted list of original indices (0-based) of the chosen intervals. This is a small-$K$ weighted interval scheduling with strict non-overlap ($r_j<l_i$).}
\ELI{Do weighted interval scheduling with a small cap $K=4$, and carry the best index set to break ties lexicographically.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list intervals of length $n$, where each element is a list $[l, r, w]$ with integers satisfying $1\le l\le r\le 10^9$ and $1\le w\le 10^9$. Indices in the returned answer refer to the original 0-based positions in the input list.}
\OUTPUTS{Return a list of distinct 0-based indices of size at most 4, sorted ascending, that are pairwise non-overlapping (strictly $r_j<l_i$ for any chosen pair in chronological order) and maximize the total weight. Among all optimal-weight answers, choose the lexicographically smallest index list.}
\SAMPLES{Example A: intervals $=[[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]$ $\to$ output $[2,3]$.

Example B: intervals $=[[5,8,1],[6,7,7],[4,7,3],[9,10,6],[7,8,2],[11,14,3],[3,5,5]]$ $\to$ output $[1,3,5,6]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let intervals be $(l_i,r_i,w_i)$ with original indices $idx_i$ for $i=1,\ldots,n$. After sorting by nondecreasing end time $r_i$, define $p(i)=\max\{j<i: r_j<l_i\}$ or $0$ if none. Choose a set $S\subseteq\{1,\ldots,n\}$ with $|S|\le 4$ such that for all $i,j\in S$ with $i\ne j$, the original intervals do not overlap, and maximize $\sum_{i\in S} w_i$. Among maximizers, minimize the lexicographic order of the sorted list of original indices.}
\varmapStart
\var{n}{number of intervals}
\var{K}{selection cap, here $K=4$}
\var{p(i)}{compatibility link: latest index $<i$ with $r_{p(i)}<l_i$}
\var{S}{selected set of indices in the sorted-by-$r$ order}
\var{idx\_i}{original input index of interval $i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let } DP[k][i] = \max\text{ total weight using first }i\text{ intervals with at most }k\text{ picks}.\\
&DP[0][i]=0,\quad DP[k][0]=0.\\
&DP[k][i] = \max\Big(DP[k][i-1],\; w_i + DP[k-1][p(i)]\Big),\qquad 1\le k\le K,\;1\le i\le n.\\
&\text{On ties of the numeric value, break by lexicographically smaller tuple of chosen original indices.}
\end{aligned}
\]
}
\ASSUMPTIONS{Intervals are closed and overlap if and only if they share any point, so compatibility uses strict inequality $r_j<l_i$. Indices in the output are 0-based and sorted ascending to define lexicographic order canonically.}
\INVARIANTS{For each $(k,i)$ the stored set realizes $DP[k][i]$, and among all sets with the same weight it is lexicographically minimal; compatibility ensured by use of $p(i)$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate combinations of up to 4 intervals and test non-overlap, tracking the best by weight and tie-breaking by lexicographic order of sorted indices.}
\ASSUMPTIONS{Works for small $n$; serves as a correctness oracle and for intuition.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute an overlap predicate that returns true iff two intervals share any point (including boundaries).
\item For $t=1$ to $4$, enumerate all $t$-subsets of indices; prune early if any two overlap.
\item Track the best sum and the lexicographically smallest sorted index list on ties.
\end{algosteps}
\COMPLEXITY{For worst case, $\sum_{t=1}^4 \binom{n}{t}=O(n^4)$ candidates; each check costs up to $O(t^2)\le O(1)$ for $t\le 4$. Space $O(1)$ beyond the input.}
\[
\begin{aligned}
T(n) &= \binom{n}{1}+\binom{n}{2}+\binom{n}{3}+\binom{n}{4} = O(n^4),\\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Exhaustive search checks all feasible choices of up to 4 intervals and keeps the lexicographically smallest index list among those with maximum sum, hence correct.}
\EDGECASES{All intervals overlapping $\Rightarrow$ pick the single heaviest; empty list $\Rightarrow$ return empty; boundary-touching pairs are invalid.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import itertools

class Solution:
    def maximumScoreOfNonOverlappingIntervals(self, intervals: List[List[int]]) -> List[int]:
        n = len(intervals)
        if n == 0:
            return []
        best_sum = -1
        best_idxs: Tuple[int, ...] = tuple()
        def overlap(a: List[int], b: List[int]) -> bool:
            # overlap if share any point (closed intervals) -> not (a.r < b.l or b.r < a.l)
            return not (a[1] < b[0] or b[1] < a[0])
        def is_valid(combo: Tuple[int, ...]) -> bool:
            for i in range(len(combo)):
                for j in range(i + 1, len(combo)):
                    if overlap(intervals[combo[i]], intervals[combo[j]]):
                        return False
            return True
        for t in range(1, 5):
            for combo in itertools.combinations(range(n), t):
                if not is_valid(combo):
                    continue
                total = sum(intervals[i][2] for i in combo)
                cand = tuple(sorted(combo))
                if total > best_sum or (total == best_sum and cand < best_idxs):
                    best_sum = total
                    best_idxs = cand
        return list(best_idxs)

# Basic asserts (small n)
s = Solution()
assert s.maximumScoreOfNonOverlappingIntervals([[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2,3]
assert s.maximumScoreOfNonOverlappingIntervals([[5,8,1],[6,7,7],[4,7,3],[9,10,6],[7,8,2],[11,14,3],[3,5,5]]) == [1,3,5,6]
# Boundary overlap disallowed: cannot pick both
assert s.maximumScoreOfNonOverlappingIntervals([[1,2,5],[2,3,5]]) in ([0],[1])
\end{minted}
\VALIDATION{Checked on the two provided examples and a boundary-touching case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{DP with Compatibility Links (weights only)}
\WHICHFORMULA{Sort by end time, precompute $p(i)$ via binary search, and use $DP[k][i]=\max(DP[k][i-1], w_i+DP[k-1][p(i)])$ for $k\in[1..4]$. On ties, still use lexicographic sets, but here we might store only weight and reconstruct greedily as a heuristic.}
\ASSUMPTIONS{Small $K$ allows $O(Kn)$ DP; binary search gives $p(i)$ in $O(\log n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Relabel intervals by sorting on end $r$; store original indices.
\item Compute $p(i)$ as the rightmost $j<i$ with $r_j<l_i$ using binary search on the $r$-array.
\item Fill $DP$ for $k=1..4$, $i=1..n$ storing both weight and a candidate index set for tie-breaking.
\end{algosteps}
\COMPLEXITY{Preprocessing $O(n\log n)$; DP is $O(Kn)$; total $O(n\log n + Kn)$.}
\[
\begin{aligned}
T(n) &= O(n\log n + 4n) = O(n\log n),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Standard weighted interval scheduling recurrence ensures optimal weights; carrying candidate sets ensures lexicographic tie-breaking when weights tie.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import bisect

class Solution:
    def maximumScoreOfNonOverlappingIntervals(self, intervals: List[List[int]]) -> List[int]:
        n = len(intervals)
        if n == 0:
            return []
        # Sort by end; keep original index
        arr = sorted([(l, r, w, i) for i, (l, r, w) in enumerate(intervals)], key=lambda x: x[1])
        l = [0] * (n + 1)
        r = [0] * (n + 1)
        w = [0] * (n + 1)
        idx = [0] * (n + 1)
        for i, (li, ri, wi, oi) in enumerate(arr, start=1):
            l[i], r[i], w[i], idx[i] = li, ri, wi, oi
        ends = [0] + [r[i] for i in range(1, n + 1)]
        # p[i]: last j<i with r[j] < l[i]
        p = [0] * (n + 1)
        for i in range(1, n + 1):
            j = bisect.bisect_left(ends, l[i], 1, n + 1) - 1
            p[i] = j
        K = 4
        NEG = -10**30
        dpw = [[0] * (n + 1) for _ in range(K + 1)]
        dps = [[tuple() for _ in range(n + 1)] for _ in range(K + 1)]
        for k in range(1, K + 1):
            dpw[k][0] = 0
            dps[k][0] = tuple()
        for k in range(1, K + 1):
            for i in range(1, n + 1):
                # skip
                best_w = dpw[k][i - 1]
                best_s = dps[k][i - 1]
                # take
                tw = w[i] + dpw[k - 1][p[i]]
                ts = tuple(sorted(dps[k - 1][p[i]] + (idx[i],)))
                if tw > best_w or (tw == best_w and ts < best_s):
                    best_w, best_s = tw, ts
                dpw[k][i] = best_w
                dps[k][i] = best_s
        return list(dps[K][n])

# Asserts
s = Solution()
assert s.maximumScoreOfNonOverlappingIntervals([[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2,3]
assert s.maximumScoreOfNonOverlappingIntervals([[5,8,1],[6,7,7],[4,7,3],[9,10,6],[7,8,2],[11,14,3],[3,5,5]]) == [1,3,5,6]
assert s.maximumScoreOfNonOverlappingIntervals([]) == []
\end{minted}
\VALIDATION{Validated on the examples and empty input.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Weighted Interval Scheduling with $K=4$ and Lexicographic Tie-break}
\WHICHFORMULA{Compute compatibility links $p(i)$ and fill a $K\times n$ DP storing both best weight and the lexicographically minimal index tuple achieving it. This yields optimal weight and correct tie-breaking in $O(n\log n + Kn)$.}
\ASSUMPTIONS{Intervals are closed; non-overlap means $r_j<l_i$. $K$ is a small constant, here 4.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort intervals by end time $r$; keep original 0-based indices.
\item For each $i$, find $p(i)=\max\{j<i: r_j<l_i\}$ by binary search on the sorted $r$-array.
\item Initialize $DP[0][i]=0$ with empty tuple; for $k=1..4$, $i=1..n$ compute
$\max\big(DP[k][i-1],\; w_i+DP[k-1][p(i)]\big)$ and on ties choose the lexicographically smaller index tuple.
\item Return the tuple at $DP[4][n]$ as a sorted list.
\end{algosteps}
\OPTIMALITY{The recurrence is the classic optimal substructure of weighted interval scheduling. With $K$ as a cap, the DP explores all optimal choices up to $K$ picks. Storing the lexicographically minimal witness per numeric value establishes correct tie-breaking. Any algorithm must inspect at least all $n$ intervals and perform at least $n$ comparisons, so $O(n\log n)$ (due to sorting and $p$-search) is tight up to the $\log n$ factor.}
\COMPLEXITY{Sorting and $p$-computation cost $O(n\log n)$; the DP is $O(Kn)$ with $K=4$; tuple comparisons are $O(K)$ amortized constant.}
\[
\begin{aligned}
T(n) &= O(n\log n + Kn) = O(n\log n),\quad K=4,\\
S(n) &= O(Kn) \text{ to store weights and tuples.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
import bisect

class Solution:
    def maximumScoreOfNonOverlappingIntervals(self, intervals: List[List[int]]) -> List[int]:
        n = len(intervals)
        if n == 0:
            return []
        # Sort by end; track original index
        items = sorted(((l, r, w, i) for i, (l, r, w) in enumerate(intervals)), key=lambda x: x[1])
        l = [0] * (n + 1)
        r = [0] * (n + 1)
        w = [0] * (n + 1)
        idx = [0] * (n + 1)
        for i, (li, ri, wi, oi) in enumerate(items, start=1):
            l[i], r[i], w[i], idx[i] = li, ri, wi, oi
        # ends for binary search; ends[0]=0 sentinel
        ends = [0] + [r[i] for i in range(1, n + 1)]
        # p[i]: rightmost j<i with r[j] < l[i]
        p = [0] * (n + 1)
        for i in range(1, n + 1):
            p[i] = bisect.bisect_left(ends, l[i], 1, n + 1) - 1
        K = 4
        dpw = [[0] * (n + 1) for _ in range(K + 1)]
        dps = [[tuple() for _ in range(n + 1)] for _ in range(K + 1)]
        for k in range(1, K + 1):
            dpw[k][0] = 0
            dps[k][0] = tuple()
        for k in range(1, K + 1):
            for i in range(1, n + 1):
                # Option 1: skip i
                best_w = dpw[k][i - 1]
                best_s = dps[k][i - 1]
                # Option 2: take i
                take_w = w[i] + dpw[k - 1][p[i]]
                take_s = tuple(sorted(dps[k - 1][p[i]] + (idx[i],)))
                if take_w > best_w or (take_w == best_w and take_s < best_s):
                    best_w, best_s = take_w, take_s
                dpw[k][i] = best_w
                dps[k][i] = best_s
        return list(dps[K][n])

# Exactly 3 asserts
s = Solution()
assert s.maximumScoreOfNonOverlappingIntervals([[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2,3]
assert s.maximumScoreOfNonOverlappingIntervals([[5,8,1],[6,7,7],[4,7,3],[9,10,6],[7,8,2],[11,14,3],[3,5,5]]) == [1,3,5,6]
assert s.maximumScoreOfNonOverlappingIntervals([[1,2,5],[2,3,5],[4,6,1],[7,8,1]]) in ([0,2,3],[1,2,3])
\end{minted}
\VALIDATION{Three asserts: both examples plus a boundary-overlap tie case.}
\RESULT{Returns the lexicographically smallest ascending list (0-based) of up to 4 indices that achieves the maximum total weight under strict non-overlap ($r_j<l_i$).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on examples; adversarial overlaps (boundary-touching), all-overlap cases, many equal-weight intervals to stress lexicographic tie-breaking, and random fuzz with a slow oracle on small $n$.}
\LINE{CROSS-CHECKS}{Compare Baseline vs. Improved/Final on small $n\le 14$ random cases; ensure identical outputs and that final result is sorted and non-overlapping.}
\LINE{EDGE-CASE GENERATOR}{Generate intervals with identical boundaries, nested intervals, chains with exact $r=l$ adjacency (disallowed), and widely spaced disjoint sets.}
\begin{minted}{python}
from typing import List, Tuple
import random
import bisect
import itertools

def oracle(intervals: List[List[int]]) -> List[int]:
    # brute force oracle for small n
    n = len(intervals)
    best_sum = -1
    best = tuple()
    def overlap(a, b): return not (a[1] < b[0] or b[1] < a[0])
    for t in range(1, min(4, n) + 1):
        for comb in itertools.combinations(range(n), t):
            ok = True
            for i in range(t):
                for j in range(i+1, t):
                    if overlap(intervals[comb[i]], intervals[comb[j]]):
                        ok = False
                        break
                if not ok: break
            if not ok: continue
            s = sum(intervals[i][2] for i in comb)
            cand = tuple(sorted(comb))
            if s > best_sum or (s == best_sum and cand < best):
                best_sum, best = s, cand
    return list(best)

class Solution:
    def maximumScoreOfNonOverlappingIntervals(self, intervals: List[List[int]]) -> List[int]:
        n = len(intervals)
        if n == 0:
            return []
        items = sorted(((l, r, w, i) for i, (l, r, w) in enumerate(intervals)), key=lambda x: x[1])
        l = [0]*(n+1); r = [0]*(n+1); w = [0]*(n+1); idx = [0]*(n+1)
        for t, (li, ri, wi, oi) in enumerate(items, start=1):
            l[t], r[t], w[t], idx[t] = li, ri, wi, oi
        ends = [0] + [r[i] for i in range(1, n+1)]
        p = [0]*(n+1)
        for i in range(1, n+1):
            p[i] = bisect.bisect_left(ends, l[i], 1, n+1) - 1
        K = 4
        dpw = [[0]*(n+1) for _ in range(K+1)]
        dps = [[tuple() for _ in range(n+1)] for _ in range(K+1)]
        for k in range(1, K+1):
            for i in range(1, n+1):
                best_w = dpw[k][i-1]; best_s = dps[k][i-1]
                tw = w[i] + dpw[k-1][p[i]]
                ts = tuple(sorted(dps[k-1][p[i]] + (idx[i],)))
                if tw > best_w or (tw == best_w and ts < best_s):
                    best_w, best_s = tw, ts
                dpw[k][i] = best_w; dps[k][i] = best_s
        return list(dps[K][n])

# Cross-check on random small cases
random.seed(0)
for _ in range(50):
    n = random.randint(0, 10)
    intervals = []
    for i in range(n):
        a = random.randint(1, 10)
        b = random.randint(1, 10)
        if a > b: a, b = b, a
        w = random.randint(1, 9)
        intervals.append([a, b, w])
    sol = Solution().maximumScoreOfNonOverlappingIntervals(intervals)
    ref = oracle(intervals)
    assert sol == ref, (intervals, sol, ref)

# Reference Solution alias
ReferenceSolution = Solution
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple
import bisect

class Solution:
    def maximumScoreOfNonOverlappingIntervals(self, intervals: List[List[int]]) -> List[int]:
        n = len(intervals)
        if n == 0:
            return []
        items = sorted(((l, r, w, i) for i, (l, r, w) in enumerate(intervals)), key=lambda x: x[1])
        l = [0]*(n+1); r = [0]*(n+1); w = [0]*(n+1); idx = [0]*(n+1)
        for t, (li, ri, wi, oi) in enumerate(items, start=1):
            l[t], r[t], w[t], idx[t] = li, ri, wi, oi
        ends = [0] + [r[i] for i in range(1, n+1)]
        p = [0]*(n+1)
        for i in range(1, n+1):
            p[i] = bisect.bisect_left(ends, l[i], 1, n+1) - 1
        K = 4
        dpw = [[0]*(n+1) for _ in range(K+1)]
        dps = [[tuple() for _ in range(n+1)] for _ in range(K+1)]
        for k in range(1, K+1):
            for i in range(1, n+1):
                best_w = dpw[k][i-1]; best_s = dps[k][i-1]
                tw = w[i] + dpw[k-1][p[i]]
                ts = tuple(sorted(dps[k-1][p[i]] + (idx[i],)))
                if tw > best_w or (tw == best_w and ts < best_s):
                    best_w, best_s = tw, ts
                dpw[k][i] = best_w; dps[k][i] = best_s
        return list(dps[K][n])

# Sanity asserts
s = Solution()
assert s.maximumScoreOfNonOverlappingIntervals([[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]) == [2,3]
assert s.maximumScoreOfNonOverlappingIntervals([[5,8,1],[6,7,7],[4,7,3],[9,10,6],[7,8,2],[11,14,3],[3,5,5]]) == [1,3,5,6]
assert s.maximumScoreOfNonOverlappingIntervals([]) == []
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Small-$K$ weighted interval scheduling with strict non-overlap and lexicographic tie-break on the chosen index list.}
\WHY{Tests dynamic programming with compatibility links, careful boundary conditions ($r<l$), and stable tie-breaking.}
\CHECKLIST{%
\begin{bullets}
\item Sort by end time; compute $p(i)$ with $r_j<l_i$.
\item Cap picks at $K=4$.
\item Maintain both best weight and lexicographically minimal witness set.
\item Always sort the witness indices ascending before comparing.
\item Return original 0-based indices.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item Boundary-touching intervals ($r=l$) are overlapping; cannot take both.
\item All intervals mutually overlap $\Rightarrow$ answer is the single heaviest.
\item Multiple optimal solutions by weight $\Rightarrow$ pick lexicographically smallest indices.
\item Empty input $\Rightarrow$ empty answer.
\item Large coordinates up to $10^9$; comparisons only, no coordinate compression needed.
\item Many equal ends/starts; ensure $p(i)$ uses strict $<$.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Using $r\le l$ for compatibility (wrong per problem; must be $r<l$).
\item Forgetting to sort witness indices before tuple compare.
\item Overwriting DP states in-place across $i$; use proper dimensions.
\item Ties resolved by lexicographic order of original indices, not weights or durations.
\item Off-by-one in binary search bounds for $p(i)$.
\item Returning indices in sorted order; preserve original 0-based indexing.
\end{bullets}
}
\FAILMODES{Inputs with many equal-weight choices can break approaches that do not store witness sets; naive reconstructions may pick a non-lexicographic solution. The DP carrying tuples remains correct.}
\ELI{Sort intervals by when they finish. For each interval, either skip it or take it plus the best compatible plan with at most 3 more picks. Keep not only the best score but also the best index list; when scores tie, choose the alphabetically smaller list of indices.}
\NotePages{3}

\end{document}