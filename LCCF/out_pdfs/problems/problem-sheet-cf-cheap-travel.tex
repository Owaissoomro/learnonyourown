% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cheap Travel}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/466/A}}
\LINE{DIFFICULTY / RATING}{1200}
\STATEMENT{Ann has recently started commuting by subway. We know that a one ride subway ticket costs $a$ rubles. Besides, Ann found out that she can buy a special ticket for $m$ rides (she can buy it several times). It costs $b$ rubles. Ann did the math; she will need to use the subway $n$ times. Help Ann, tell her what is the minimum sum of money she will have to spend to make $n$ rides?

Input: The single line contains four space-separated integers $n, m, a, b$ ($1 \le n, m, a, b \le 1000$) — the number of rides Ann has planned, the number of rides covered by the $m$ ride ticket, the price of a one ride ticket and the price of an $m$ ride ticket.

Output: Print a single integer — the minimum sum in rubles that Ann will need to spend.

Note: In the first sample one of the optimal solutions is: each time buy a one ride ticket. There are other optimal solutions. For example, buy three $m$ ride tickets.}
\BREAKDOWN{We must minimize cost over combinations of single-ride tickets and $m$-ride bundle tickets to cover at least $n$ rides. Compare pure singles vs. bundles-only vs. a mix where the remainder is covered by either singles or one more bundle.}
\ELI{Choose between buying all singles, buying bundles for groups of $m$ and covering leftovers with singles, or buying one extra bundle if that is cheaper.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single line: four integers $n, m, a, b$ with $1 \le n, m, a, b \le 1000$.}
\OUTPUTS{One integer: the minimum total cost in rubles to enable at least $n$ rides.}
\SAMPLES{Example 1: Input: ``6 2 1 2''. Output: ``6''. Example 2: Input: ``5 2 2 3''. Output: ``8''.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $x$ be the number of $m$-ride bundles and $y$ the number of single-ride tickets. Minimize total cost subject to covering $n$ rides.}
\varmapStart
\var{x}{number of $m$-ride bundles purchased ($x \in \mathbb{Z}_{\ge 0}$)}
\var{y}{number of single-ride tickets purchased ($y \in \mathbb{Z}_{\ge 0}$)}
\var{n}{required number of rides}
\var{m}{rides per bundle}
\var{a}{cost per single ride}
\var{b}{cost per bundle}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{minimize}\quad & C = b x + a y \\
\text{subject to}\quad & m x + y \ge n,\quad x,y \in \mathbb{Z}_{\ge 0}.
\end{aligned}
\]
Equivalently, a closed-form optimal value is
\begin{BreakableEquation*}
C^\star = \min\Bigl( n a,\; \bigl\lfloor \tfrac{n}{m} \bigr\rfloor b + \min\bigl((n \bmod m) a,\; b\bigr) \Bigr).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Tickets are unlimited; rides are fungible; no partial bundles; costs are nonnegative integers.}
\INVARIANTS{Buying more than one extra bundle beyond $\lfloor n/m \rfloor$ is never optimal; the remainder $r=n \bmod m$ is optimally covered by either $r$ singles or one extra bundle, whichever is cheaper.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all feasible counts of bundles $x \in [0,\lceil n/m\rceil]$, cover the shortfall with singles, and take the minimum cost.}
\ASSUMPTIONS{Small search over possible bundle counts; straightforward arithmetic.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For $x$ from $0$ to $\lceil n/m\rceil$: compute $y=\max(0, n - x m)$.
\item Compute cost $C(x) = b x + a y$; track the minimum over all $x$.
\item Return the minimum cost.
\end{algosteps}
\COMPLEXITY{Looping over at most $\lceil n/m\rceil + 1 \le n+1$ bundle counts.}
\[
\begin{aligned}
T(n) &= O\!\left(\left\lceil \tfrac{n}{m}\right\rceil\right) \le O(n), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{For any optimal solution, the number of bundles cannot exceed $\lceil n/m\rceil$; covering the remainder with singles is optimal for a fixed $x$. Thus enumerating all $x$ in this range attains the optimum.}
\EDGECASES{$m>n$; $b \ge m a$ (bundles never beneficial); $b < m a$ (bundles beneficial); exact divisibility $n \bmod m = 0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import Optional, Tuple

def read_input() -> Optional[Tuple[int, int, int, int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, m, a, b = map(int, data[:4])
    return n, m, a, b

def solve_case(n: int, m: int, a: int, b: int) -> int:
    # Brute-force over possible bundle counts x in [0, ceil(n/m)]
    max_x = n // m + 1
    ans = n * a  # all singles as an initial bound
    for x in range(max_x + 1):
        y = max(0, n - x * m)
        cost = x * b + y * a
        if cost < ans:
            ans = cost
    return ans

def solve_all() -> None:
    parsed = read_input()
    if parsed is None:
        return
    n, m, a, b = parsed
    res = solve_case(n, m, a, b)
    sys.stdout.write(str(res))

def _self_test() -> None:
    # Known examples and edge checks (no output on success)
    assert solve_case(6, 2, 1, 2) == 6
    assert solve_case(5, 2, 2, 3) == 8
    assert solve_case(4, 5, 3, 14) == 12  # bundle too large/expensive, all singles
    assert solve_case(10, 3, 5, 12) == min(10*5, (10//3)*12 + min((10%3)*5, 12))

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Manually verify small cases; compare against closed form on random small inputs offline.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Eliminate enumeration by using a direct minimum over the only three meaningful strategies: all singles; bundles for full groups and singles for the remainder; bundles for full groups and one extra bundle for the remainder.}
\ASSUMPTIONS{At most one extra bundle beyond $\lfloor n/m \rfloor$ can be beneficial; otherwise discard.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $k=\lfloor n/m \rfloor$ and $r=n \bmod m$.
\item Compute candidates: $C_1 = n a$, $C_2 = k b + r a$, $C_3 = k b + b$ (if $r>0$, else $C_3 = k b$).
\item Return $\min(C_1, C_2, C_3)$.
\end{algosteps}
\COMPLEXITY{Constant time.}
\[
\begin{aligned}
T(n) &= O(1),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Any optimal solution uses $k$ or $k{+}1$ bundles where $k=\lfloor n/m \rfloor$. The remainder $r$ is most cheaply covered by either $r$ singles or one extra bundle. Taking the minimum across these cases is optimal.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import Optional, Tuple

def read_input() -> Optional[Tuple[int, int, int, int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, m, a, b = map(int, data[:4])
    return n, m, a, b

def solve_case(n: int, m: int, a: int, b: int) -> int:
    k = n // m
    r = n - k * m
    all_singles = n * a
    bundles_plus_singles = k * b + r * a
    bundles_plus_one = k * b + (b if r > 0 else 0)
    return min(all_singles, bundles_plus_singles, bundles_plus_one)

def solve_all() -> None:
    parsed = read_input()
    if parsed is None:
        return
    n, m, a, b = parsed
    res = solve_case(n, m, a, b)
    sys.stdout.write(str(res))

def _self_test() -> None:
    assert solve_case(6, 2, 1, 2) == 6
    assert solve_case(5, 2, 2, 3) == 8
    assert solve_case(4, 5, 3, 14) == 12
    # Consistency with brute-force thought experiment
    def brute(n, m, a, b):
        ans = n * a
        for x in range(n // m + 2):
            y = max(0, n - x * m)
            ans = min(ans, x * b + y * a)
        return ans
    assert solve_case(10, 3, 5, 12) == brute(10, 3, 5, 12)

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Edge inputs: $m=1$ (bundles are singles); $n<m$; $b \le a$; $b \ge m a$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Closed-form: $\min\bigl(n a,\; \lfloor n/m \rfloor b + \min\bigl((n \bmod m) a,\; b\bigr)\bigr)$.}
\ASSUMPTIONS{Costs and counts are integers; buying at most one extra bundle beyond full groups suffices.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $k=\lfloor n/m \rfloor$ and remainder $r=n-k m$.
\item Candidate costs: $n a$; $k b + r a$; $k b + b$ if $r>0$ (else identical to $k b$).
\item Return the minimum of these candidates.
\end{algosteps}
\OPTIMALITY{Lower bound: any feasible plan must pay at least $\lfloor n/m \rfloor b$ if using bundles for $k$ groups, plus the cheapest way to cover the $r$ remainder. Considering all three candidates attains this bound, hence optimal.}
\COMPLEXITY{$O(1)$ time and $O(1)$ space.}
\[
\begin{aligned}
T(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import Optional, Tuple

def read_input() -> Optional[Tuple[int, int, int, int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, m, a, b = map(int, data[:4])
    return n, m, a, b

def solve_case(n: int, m: int, a: int, b: int) -> int:
    k = n // m
    r = n - k * m
    return min(n * a, k * b + min(r * a, b))

def solve_all() -> None:
    parsed = read_input()
    if parsed is None:
        return
    n, m, a, b = parsed
    res = solve_case(n, m, a, b)
    sys.stdout.write(str(res))

def _self_test() -> None:
    # Exactly 3 asserts
    assert solve_case(6, 2, 1, 2) == 6
    assert solve_case(5, 2, 2, 3) == 8
    assert solve_case(4, 5, 3, 14) == 12

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Asserts on two samples and one crafted edge case.}
\RESULT{Print the minimal ruble cost as a single integer with no extra text.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on canonical cases; property test vs. brute force for small ranges; adversarial combinations such as $b \ll m a$ and $b \gg m a$.}
\LINE{CROSS-CHECKS}{Compare outputs of brute-force enumeration and closed-form on random small instances.}
\LINE{EDGE-CASE GENERATOR}{Covers $n<m$, $n$ multiple of $m$, $m=1$, extremes like $a=1$, $b=1$, and thresholds where $b \approx m a$.}
\begin{minted}{python}
import sys
import random
from typing import Optional, Tuple

def read_input() -> Optional[Tuple[int, int, int, int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    return tuple(map(int, data[:4]))  # n, m, a, b

def solve_case(n: int, m: int, a: int, b: int) -> int:
    k = n // m
    r = n - k * m
    return min(n * a, k * b + min(r * a, b))

def brute_case(n: int, m: int, a: int, b: int) -> int:
    best = n * a
    for x in range(n // m + 2):
        y = max(0, n - x * m)
        best = min(best, x * b + y * a)
    return best

def solve_all() -> None:
    parsed = read_input()
    if parsed is None:
        return
    n, m, a, b = parsed
    sys.stdout.write(str(solve_case(n, m, a, b)))

def _tests() -> None:
    # Deterministic property checks
    assert solve_case(6, 2, 1, 2) == 6
    assert solve_case(5, 2, 2, 3) == 8
    assert solve_case(4, 5, 3, 14) == 12
    # Cross-check random small cases
    rng = random.Random(12345)
    for _ in range(200):
        n = rng.randint(1, 30)
        m = rng.randint(1, 10)
        a = rng.randint(1, 20)
        b = rng.randint(1, 40)
        assert solve_case(n, m, a, b) == brute_case(n, m, a, b)

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import Optional, Tuple

def read_input() -> Optional[Tuple[int, int, int, int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, m, a, b = map(int, data[:4])
    return n, m, a, b

def solve_case(n: int, m: int, a: int, b: int) -> int:
    k = n // m
    r = n - k * m
    return min(n * a, k * b + min(r * a, b))

def solve_all() -> None:
    parsed = read_input()
    if parsed is None:
        return
    n, m, a, b = parsed
    res = solve_case(n, m, a, b)
    sys.stdout.write(str(res))

def _self_test() -> None:
    assert solve_case(6, 2, 1, 2) == 6
    assert solve_case(5, 2, 2, 3) == 8
    assert solve_case(4, 5, 3, 14) == 12

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize cost of covering $n$ rides using singles ($a$) and bundles of $m$ rides ($b$).}
\WHY{Classic cost-minimization with discrete bundles; tests ability to simplify a search to a closed-form expression.}
\CHECKLIST{
\begin{bullets}
\item Compute $k=\lfloor n/m \rfloor$ and $r=n \bmod m$.
\item Evaluate $n a$, $k b + r a$, and $k b + b$ (if $r>0$).
\item Answer is the minimum of these candidates.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n<m$: choose between $n a$ and $b$.
\item $n$ multiple of $m$: compare $n a$ vs. $(n/m) b$.
\item $m=1$: bundles are effectively singles of price $b$.
\item $b \ge m a$: bundles never help; answer $n a$.
\item $b \le a$: bundles likely help even when $m>n$.
\item Very small numbers (all ones); very large within bounds.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting that one extra bundle can cover the remainder cheaper than singles.
\item Off-by-one in the bundle loop (baseline) missing $x=\lceil n/m\rceil$.
\item Integer division mistakes with negative or wrong remainder handling (ensure $r \ge 0$).
\item Printing extra text or spaces not allowed by CF format.
\item Reading fewer than four integers if extra whitespace present.
\item Overflow is not an issue here, but keep types as integers.
\end{bullets}
}
\FAILMODES{A naive greedy that always prefers bundles when $b < m a$ can fail when $n<m$ unless it still compares against all singles. The closed form guards against this by evaluating all candidates.}
\ELI{Either buy all rides one-by-one, or buy bundles for the big chunks and cover the leftover with whichever is cheaper: a few singles or one more bundle. Just pick the cheapest of these.}
\NotePages{3}

\end{document}