% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Online Majority Element In Subarray}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/online-majority-element-in-subarray/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Design a data structure that efficiently finds the \textbf{majority element} of a given subarray.

The majority element of a subarray is an element that occurs \texttt{threshold} times or more in the subarray.

Implement the \texttt{MajorityChecker} class:
\begin{bullets}
\item \texttt{MajorityChecker(int[] arr)} initializes the instance of the class with the given array \texttt{arr}.
\item \texttt{int query(int left, int right, int threshold)} returns the element in the subarray \texttt{arr[left...right]} that occurs at least \texttt{threshold} times, or \texttt{-1} if no such element exists.
\end{bullets}

Example:
\begin{tcolorbox}
Input

\texttt{["MajorityChecker", "query", "query", "query"]}

\texttt{[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]}

Output

\texttt{[null, 1, -1, 2]}

Explanation

\texttt{MajorityChecker majorityChecker = new MajorityChecker([1, 1, 2, 2, 1, 1]);}

\texttt{majorityChecker.query(0, 5, 4);} returns \texttt{1}

\texttt{majorityChecker.query(0, 3, 3);} returns \texttt{-1}

\texttt{majorityChecker.query(2, 3, 2);} returns \texttt{2}
\end{tcolorbox}

Constraints:
\begin{bullets}
\item $1 \le n = \lvert \text{arr} \rvert \le 2 \times 10^4$.
\item $1 \le \text{arr}[i] \le 2 \times 10^4$.
\item $0 \le \text{left} \le \text{right} < n$.
\item $\text{threshold} \le \text{right} - \text{left} + 1$.
\item $2 \times \text{threshold} > \text{right} - \text{left} + 1$.
\item At most $10^4$ calls will be made to \texttt{query}.
\end{bullets}}
\BREAKDOWN{We must support many online range queries asking whether a majority (strictly more than half, due to $2 \times \text{threshold} > \text{len}$) exists and, if so, return it. Preprocessing should enable fast verification of a candidate inside any interval.}
\ELI{Find the element that takes up more than half of a slice of the array; prepare so you can quickly guess the candidate and double-check how often it appears.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A fixed array $\text{arr}$ of length $n$ with $1 \le \text{arr}[i] \le 2 \times 10^4$. Each query provides integers $(\text{left}, \text{right}, \text{threshold})$ such that $0 \le \text{left} \le \text{right} < n$, $\text{threshold} \le \text{right}-\text{left}+1$, and $2 \times \text{threshold} > \text{right}-\text{left}+1$.}
\OUTPUTS{For each query, return the majority element in $\text{arr}[\text{left}..\text{right}]$ if it occurs at least $\text{threshold}$ times; otherwise return $-1$.}
\SAMPLES{Examples:
\begin{bullets}
\item $\text{arr}=[1,1,2,2,1,1]$, query $(0,5,4) \to 1$, $(0,3,3) \to -1$, $(2,3,2) \to 2$.
\item $\text{arr}=[3,3,4]$, query $(0,2,2) \to 3$, query $(1,2,2) \to -1$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given array $A \in [1..V]^n$, process queries $Q = (\ell, r, \tau)$. A query is satisfied by value $x$ iff $f_{x,[\ell,r]} \ge \tau$ where $f_{x,[\ell,r]} = \lvert \{ i \in [\ell,r] : A_i = x \} \rvert$. Under the constraint $2\tau > (r-\ell+1)$, the majority (if any) is unique.}
\varmapStart
\var{A}{input array}
\var{n}{length of $A$}
\var{\ell,r}{query range, inclusive}
\var{\tau}{threshold}
\var{f_{x,[\ell,r]}}{frequency of value $x$ in $A[\ell..r]$}
\varmapEnd
\GOVERN{
\[
  \text{Answer}(\ell,r,\tau) =
  \begin{cases}
  x & \text{if } \exists x \text{ with } f_{x,[\ell,r]} \ge \tau, \\
  -1 & \text{otherwise.}
  \end{cases}
\]
}
\ASSUMPTIONS{0-based indexing. Values are integers in a small bounded range but not necessarily contiguous. Queries are online; preprocessing is allowed.}
\INVARIANTS{
\begin{bullets}
\item Uniqueness: If a value appears $\ge \tau$ with $2\tau > r-\ell+1$, no other distinct value can appear $\ge \tau$.
\item Verification: For any candidate $c$, we can compute $f_{c,[\ell,r]}$ by binary searching in the precomputed index list of $c$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly count frequencies in the subarray using a hash map, then check whether any count reaches the threshold.}
\ASSUMPTIONS{No preprocessing beyond storing the array.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each query $(\ell,r,\tau)$, initialize an empty dictionary.
\item Scan $i$ from $\ell$ to $r$, increment the count of $A_i$.
\item If any count reaches $\tau$, return that value; otherwise return $-1$ at the end.
\end{algosteps}
\COMPLEXITY{Per-query time $O(r-\ell+1)$, space $O(\min\{r-\ell+1,V\})$. Preprocessing $O(1)$.}
\[
\begin{aligned}
T_{\text{query}}(n) &= O(r-\ell+1) \le O(n), \\
S_{\text{query}}(n) &= O(\min\{r-\ell+1,V\}).
\end{aligned}
\]
\CORRECTNESS{Every element in the interval is counted exactly once; if any reaches $\tau$, it is returned. Due to $2\times \tau > r-\ell+1$, at most one such element can exist, but the algorithm does not rely on uniqueness to be correct.}
\EDGECASES{Single-element ranges; thresholds equal to range length; no majority present; many distinct values.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Dict

class MajorityChecker:
    def __init__(self, arr: List[int]):
        self.arr = arr

    def query(self, left: int, right: int, threshold: int) -> int:
        counts: Dict[int, int] = {}
        for i in range(left, right + 1):
            v = self.arr[i]
            c = counts.get(v, 0) + 1
            counts[v] = c
            if c >= threshold:
                return v
        return -1

if __name__ == "__main__":
    # Sample test from the prompt
    mc = MajorityChecker([1, 1, 2, 2, 1, 1])
    assert mc.query(0, 5, 4) == 1
    assert mc.query(0, 3, 3) == -1
    assert mc.query(2, 3, 2) == 2

    # Additional sanity checks
    mc2 = MajorityChecker([3, 3, 4])
    assert mc2.query(0, 2, 2) == 3
    assert mc2.query(1, 2, 2) == -1
\end{minted}
\VALIDATION{Validated on the given example and a small custom case with and without a majority.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Randomized Sampling + Precomputed Positions}
\WHICHFORMULA{Leverage the fact that a majority (if present) occupies $> \tfrac{1}{2}$ of the interval. Repeatedly sample positions in $[\ell,r]$; each sample yields a candidate whose true frequency we can verify in $O(\log n)$ using precomputed index lists.}
\ASSUMPTIONS{Precompute for each distinct value $x$ the sorted list of indices where it occurs. Fixed RNG seed ensures deterministic behavior for tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Preprocess: map each value $x$ to a sorted list of indices $\text{pos}[x]$.
\item For a query $(\ell,r,\tau)$, repeat $K$ times (e.g., $K=25$): pick a random index $p \in [\ell,r]$, let $c = A[p]$.
\item Compute $f_{c,[\ell,r]}$ via two binary searches in $\text{pos}[c]$. If $f_{c,[\ell,r]} \ge \tau$, return $c$.
\item If all trials fail, return $-1$.
\end{algosteps}
\COMPLEXITY{Preprocessing $O(n)$ time and space. Per query, $O(K \log n)$ expected time; with fixed $K$, this is $O(\log n)$.}
\[
\begin{aligned}
T_{\text{query}}(n) &= O(K \log n),\quad S_{\text{pre}}(n) = O(n).
\end{aligned}
\]
\CORRECTNESS{If a majority exists, each sample hits it with probability $> \tfrac{1}{2}$; with $K$ independent trials the failure probability is $(<\tfrac{1}{2})^K$. Verification ensures no false positives. With a fixed seed, outputs are deterministic for the same inputs.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Dict
from bisect import bisect_left, bisect_right
import random

class MajorityChecker:
    def __init__(self, arr: List[int]):
        self.arr = arr
        self.pos: Dict[int, List[int]] = {}
        for i, v in enumerate(arr):
            self.pos.setdefault(v, []).append(i)
        # Fixed-seed RNG for deterministic results
        self._rng = random.Random(0)
        self._K = 25

    def _count_in_range(self, val: int, left: int, right: int) -> int:
        idxs = self.pos.get(val)
        if not idxs:
            return 0
        lo = bisect_left(idxs, left)
        hi = bisect_right(idxs, right)
        return hi - lo

    def query(self, left: int, right: int, threshold: int) -> int:
        # Try a few deterministic anchor points to boost reliability
        anchors = [left, right, (left + right) // 2]
        for a in anchors:
            v = self.arr[a]
            if self._count_in_range(v, left, right) >= threshold:
                return v
        # Random sampling with fixed seed
        for _ in range(self._K):
            p = self._rng.randint(left, right)
            v = self.arr[p]
            if self._count_in_range(v, left, right) >= threshold:
                return v
        return -1

if __name__ == "__main__":
    mc = MajorityChecker([1, 1, 2, 2, 1, 1])
    assert mc.query(0, 5, 4) == 1
    assert mc.query(0, 3, 3) == -1
    assert mc.query(2, 3, 2) == 2

    mc2 = MajorityChecker([3, 3, 4])
    assert mc2.query(0, 2, 2) == 3
    assert mc2.query(1, 2, 2) == -1
\end{minted}
\VALIDATION{Checked on sample cases. Due to deterministic seeding, repeated runs yield identical outputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Segment Tree of Boyer–Moore Candidates + Verification}
\WHICHFORMULA{Store on each segment the Boyer–Moore majority candidate and its net count. A range query merges $O(\log n)$ nodes to get a candidate. Verify its actual frequency via precomputed positions.}
\ASSUMPTIONS{The Boyer–Moore candidate over a range, if a strict majority exists, must be that majority. Verification avoids false positives.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\text{pos}[x]$ as sorted index lists for every value $x$.
\item Build a segment tree where each node keeps a pair $(\text{val}, \text{cnt})$:
  merging two nodes $(a,c_a)$ and $(b,c_b)$ follows Boyer–Moore rules:
  if $a=b$ then $(a,c_a+c_b)$, else reduce the smaller count; the neutral element is $(0,0)$ given values $\ge 1$.
\item For query $(\ell,r,\tau)$, segment-tree query returns a candidate $c$; count $f_{c,[\ell,r]}$ via binary search in $\text{pos}[c]$; return $c$ if $f \ge \tau$, else $-1$.
\end{algosteps}
\OPTIMALITY{Preprocessing $O(n)$ space, $O(n)$ build. Each query is $O(\log n)$ to obtain the candidate plus $O(\log n)$ to verify, i.e., $O(\log n)$ worst-case deterministic. This is asymptotically optimal for comparison-based online queries given arbitrary values.}
\COMPLEXITY{Build $O(n)$, per-query $O(\log n)$ time, $O(n)$ extra space.}
\[
\begin{aligned}
T_{\text{build}}(n) &= O(n),\quad T_{\text{query}}(n) = O(\log n),\quad S(n) = O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple, Dict
from bisect import bisect_left, bisect_right

class MajorityChecker:
    def __init__(self, arr: List[int]):
        self.arr = arr
        self.n = len(arr)
        # positions map for O(log n) frequency queries
        self.pos: Dict[int, List[int]] = {}
        for i, v in enumerate(arr):
            self.pos.setdefault(v, []).append(i)
        # segment tree storing (candidate_value, net_count)
        n = self.n
        size = 1
        while size < n:
            size <<= 1
        self.size = size
        self.seg: List[Tuple[int, int]] = [(0, 0)] * (2 * size)

        def merge(a: Tuple[int, int], b: Tuple[int, int]) -> Tuple[int, int]:
            if a[0] == 0:
                return b
            if b[0] == 0:
                return a
            if a[0] == b[0]:
                return (a[0], a[1] + b[1])
            if a[1] > b[1]:
                return (a[0], a[1] - b[1])
            else:
                return (b[0], b[1] - a[1])

        self._merge = merge

        # build leaves
        for i in range(n):
            self.seg[self.size + i] = (arr[i], 1)
        # internal nodes
        for i in range(self.size - 1, 0, -1):
            self.seg[i] = merge(self.seg[i << 1], self.seg[i << 1 | 1])

    def _range_candidate(self, left: int, right: int) -> int:
        # inclusive [left, right]
        l = left + self.size
        r = right + self.size + 1
        res_left = (0, 0)
        res_right = (0, 0)
        while l < r:
            if l & 1:
                res_left = self._merge(res_left, self.seg[l])
                l += 1
            if r & 1:
                r -= 1
                res_right = self._merge(self.seg[r], res_right)
            l >>= 1
            r >>= 1
        res = self._merge(res_left, res_right)
        return res[0]

    def _count_in_range(self, val: int, left: int, right: int) -> int:
        idxs = self.pos.get(val)
        if not idxs:
            return 0
        lo = bisect_left(idxs, left)
        hi = bisect_right(idxs, right)
        return hi - lo

    def query(self, left: int, right: int, threshold: int) -> int:
        cand = self._range_candidate(left, right)
        if cand == 0:
            return -1
        cnt = self._count_in_range(cand, left, right)
        return cand if cnt >= threshold else -1

if __name__ == "__main__":
    # Provided example
    mc = MajorityChecker([1, 1, 2, 2, 1, 1])
    assert mc.query(0, 5, 4) == 1
    assert mc.query(0, 3, 3) == -1
    assert mc.query(2, 3, 2) == 2

    # Additional tests
    mc2 = MajorityChecker([3, 3, 4])
    assert mc2.query(0, 2, 2) == 3
    assert mc2.query(1, 2, 2) == -1

    # Edge: single element range
    mc3 = MajorityChecker([7, 8, 7, 7])
    assert mc3.query(1, 1, 1) == 8
\end{minted}
\VALIDATION{Three asserts: the prompt sample, a small custom example, and a single-element interval.}
\RESULT{For each query, return the unique strict majority if it exists (frequency $\ge \tau$), else $-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on short arrays; random arrays with synthetic queries; adversarial ranges with no majority; degenerate ranges of length 1 and full-array ranges.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs. Improved vs. Optimal on many tiny random cases to ensure agreement; assert that the Optimal never produces false positives thanks to verification.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with repeating blocks to create clear majorities; generate ranges with thresholds just above and just below half.}
\begin{minted}{python}
from typing import List, Tuple
from random import Random
from bisect import bisect_left, bisect_right

# Deterministic generators for boundaries, degenerates, adversarials
def gen_arrays() -> List[List[int]]:
    return [
        [1],
        [1,1],
        [1,2],
        [1,1,2,2,1,1],
        [3,3,4],
        [7,8,7,7,8,8,8],
        [i%3 for i in range(30)]
    ]

def all_ranges(n: int) -> List[Tuple[int,int]]:
    res = []
    for l in range(n):
        for r in range(l, n-1 if n>0 else -1):
            res.append((l,r))
    # Include full range
    if n > 0:
        res.append((0,n-1))
    return res

class MajorityCheckerRef:
    # Reference: segment tree candidate + verification (as in Optimal)
    def __init__(self, arr: List[int]):
        self.arr = arr
        self.n = len(arr)
        self.pos = {}
        for i, v in enumerate(arr):
            self.pos.setdefault(v, []).append(i)
        size = 1
        while size < self.n:
            size <<= 1
        self.size = size
        self.seg = [(0,0)]*(2*size)
        def merge(a,b):
            if a[0]==0: return b
            if b[0]==0: return a
            if a[0]==b[0]: return (a[0], a[1]+b[1])
            if a[1]>b[1]: return (a[0], a[1]-b[1])
            return (b[0], b[1]-a[1])
        self.merge = merge
        for i,v in enumerate(arr):
            self.seg[self.size+i]=(v,1)
        for i in range(self.size-1,0,-1):
            self.seg[i]=merge(self.seg[i<<1], self.seg[i<<1|1])

    def _cand(self,l,r):
        l+=self.size; r+=self.size+1
        L=(0,0); R=(0,0)
        while l<r:
            if l&1: L=self.merge(L,self.seg[l]); l+=1
            if r&1: r-=1; R=self.merge(self.seg[r],R)
            l>>=1; r>>=1
        return self.merge(L,R)[0]

    def _cnt(self,val,l,r):
        idxs=self.pos.get(val,[])
        return bisect_right(idxs,r)-bisect_left(idxs,l)

    def query(self,l,r,th):
        c=self._cand(l,r)
        if c==0: return -1
        return c if self._cnt(c,l,r)>=th else -1

def brute_query(arr: List[int], l: int, r: int, th: int) -> int:
    from collections import Counter
    cnt = Counter(arr[l:r+1])
    for v,c in cnt.items():
        if c >= th: return v
    return -1

if __name__ == "__main__":
    # Cross-check baseline brute vs reference on small randoms
    rng = Random(0)
    for _ in range(50):
        n = rng.randint(1, 25)
        arr = [rng.randint(1, 7) for _ in range(n)]
        ref = MajorityCheckerRef(arr)
        for _ in range(50):
            l = rng.randint(0, n-1)
            r = rng.randint(l, n-1)
            length = r - l + 1
            th = rng.randint((length//2)+1, length)  # enforce strict majority threshold
            assert ref.query(l,r,th) == brute_query(arr,l,r,th)

    # Smoke test on fixed arrays
    for arr in gen_arrays():
        ref = MajorityCheckerRef(arr)
        n = len(arr)
        if n == 0:
            continue
        for l in range(n):
            for r in range(l, n):
                length = r - l + 1
                th = (length // 2) + 1
                assert ref.query(l,r,th) == brute_query(arr,l,r,th)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple, Dict
from bisect import bisect_left, bisect_right

class MajorityChecker:
    def __init__(self, arr: List[int]):
        self.arr = arr
        self.n = len(arr)
        # Map value -> sorted indices (built in O(n))
        self.pos: Dict[int, List[int]] = {}
        for i, v in enumerate(arr):
            self.pos.setdefault(v, []).append(i)
        # Segment tree for Boyer-Moore candidate
        size = 1
        while size < self.n:
            size <<= 1
        self.size = size
        self.seg: List[Tuple[int, int]] = [(0, 0)] * (2 * size)

        def merge(a: Tuple[int, int], b: Tuple[int, int]) -> Tuple[int, int]:
            if a[0] == 0:
                return b
            if b[0] == 0:
                return a
            if a[0] == b[0]:
                return (a[0], a[1] + b[1])
            if a[1] > b[1]:
                return (a[0], a[1] - b[1])
            else:
                return (b[0], b[1] - a[1])

        self._merge = merge

        # Leaves
        for i, v in enumerate(arr):
            self.seg[self.size + i] = (v, 1)
        # Build internal nodes
        for i in range(self.size - 1, 0, -1):
            self.seg[i] = merge(self.seg[i << 1], self.seg[i << 1 | 1])

    def _candidate(self, left: int, right: int) -> int:
        # Inclusive range [left, right]
        l = left + self.size
        r = right + self.size + 1
        resL = (0, 0)
        resR = (0, 0)
        while l < r:
            if l & 1:
                resL = self._merge(resL, self.seg[l])
                l += 1
            if r & 1:
                r -= 1
                resR = self._merge(self.seg[r], resR)
            l >>= 1
            r >>= 1
        return self._merge(resL, resR)[0]

    def _count(self, val: int, left: int, right: int) -> int:
        idxs = self.pos.get(val)
        if not idxs:
            return 0
        lo = bisect_left(idxs, left)
        hi = bisect_right(idxs, right)
        return hi - lo

    def query(self, left: int, right: int, threshold: int) -> int:
        cand = self._candidate(left, right)
        if cand == 0:
            return -1
        return cand if self._count(cand, left, right) >= threshold else -1

if __name__ == "__main__":
    # Basic asserts including the prompt example
    mc = MajorityChecker([1, 1, 2, 2, 1, 1])
    assert mc.query(0, 5, 4) == 1
    assert mc.query(0, 3, 3) == -1
    assert mc.query(2, 3, 2) == 2

    mc2 = MajorityChecker([3, 3, 4])
    assert mc2.query(0, 2, 2) == 3
    assert mc2.query(1, 2, 2) == -1

    # Edge: single element, threshold 1
    mc3 = MajorityChecker([5])
    assert mc3.query(0, 0, 1) == 5
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Use a segment tree of Boyer–Moore candidates to get a candidate in $O(\log n)$ and verify with precomputed positions in another $O(\log n)$.}
\WHY{Range-majority queries with online constraints appear in advanced data-structure interviews; they test knowledge of voting algorithms, segment trees, and verification via binary search.}
\CHECKLIST{
\begin{bullets}
\item Precompute positions map for $O(\log n)$ verification.
\item Build segment tree nodes with correct Boyer–Moore merge.
\item Query range inclusively; be careful with $+1$ on the right bound in tree traversal.
\item Verify candidate frequency with two binary searches.
\item Return $-1$ if verification fails.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Single-element range $(\ell=r)$.
\item Threshold equals range length.
\item No majority exists.
\item All elements identical.
\item Alternating values.
\item Values near the allowed maximum $2 \times 10^4$.
\item Many queries on tiny ranges.
\item Majority just one above half.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one when making the right bound inclusive in segment-tree queries.
\item Using $0$ as neutral when values might be $0$; here values are $\ge 1$, so using $(0,0)$ is safe.
\item Forgetting to verify the candidate; Boyer–Moore alone can yield a non-majority.
\item Incorrectly merging candidate counts across nodes.
\item Misusing binary search bounds; must use \texttt{bisect\_left} and \texttt{bisect\_right}.
\item Building unsorted position lists and then binary searching them.
\item Handling empty position lists without checks.
\item Excess recursion depth if using recursive segment trees in Python; use iterative build/query.
\end{bullets}}
\FAILMODES{Pure random sampling can miss the majority with small probability; the segment-tree approach avoids this by deterministically extracting a candidate and validating it. The brute-force approach times out under many queries.}
\ELI{Pick a likely winner for the slice using a fast tree that mimics the Boyer–Moore vote, then count how many times it appears using a precomputed index list. If it is not frequent enough, say none.}
\NotePages{3}

\end{document}