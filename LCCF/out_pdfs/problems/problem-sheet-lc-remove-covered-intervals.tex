% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Remove Covered Intervals}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/remove-covered-intervals/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given an array \texttt{intervals} where \texttt{intervals[i] = [l\_i, r\_i]} represent the half-open interval $[l_i, r_i)$, remove all intervals that are covered by another interval in the list.

An interval $[a, b)$ is covered by an interval $[c, d)$ if and only if $c \le a$ and $b \le d$.

Return the number of remaining intervals.

Example 1:

Input: \texttt{intervals = [[1,4],[3,6],[2,8]]}

Output: \texttt{2}

Explanation: Interval $[3,6)$ is covered by $[2,8)$, therefore it is removed.

Example 2:

Input: \texttt{intervals = [[1,4],[2,3]]}

Output: \texttt{1}

Constraints:
\begin{bullets}
\item $1 \le \texttt{intervals.length} \le 1000$
\item $\texttt{intervals[i].length} = 2$
\item $0 \le l_i < r_i \le 10^5$
\item All the given intervals are unique.
\end{bullets}}
\BREAKDOWN{We need to remove any interval covered by another and count how many remain. Sorting by start ascending and end descending enables a single left-to-right scan to detect coverage.}
\ELI{Sort by left endpoint; keep the farthest right endpoint seen so far, and count any interval that extends beyond it.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list \texttt{intervals} of length $n$ with elements \texttt{[l, r]} integers satisfying $0 \le l < r \le 10^5$. All intervals are unique.}
\OUTPUTS{A single integer: the number of intervals not covered by any other interval in the list.}
\SAMPLES{
Example A:

Input: \texttt{[[1,4],[3,6],[2,8]]}

Output: \texttt{2}

Example B:

Input: \texttt{[[1,4],[2,3]]}

Output: \texttt{1}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n$ intervals $I_i = [l_i, r_i)$ for $i \in \{1,\ldots,n\}$, define coverage predicate
\begin{BreakableEquation*}
C(i,j) := (l_j \le l_i)\ \land\ (r_i \le r_j).
\end{BreakableEquation*}
Let the remaining set be
\begin{BreakableEquation*}
R := \{\, i \in \{1,\ldots,n\} : \neg\exists j \ne i \text{ with } C(i,j) \,\}.
\end{BreakableEquation*}
We seek $|R|$.}
\varmapStart
\var{n}{number of intervals}
\var{l_i}{left endpoint of interval $i$}
\var{r_i}{right endpoint of interval $i$}
\var{C(i,j)}{predicate that interval $j$ covers interval $i$}
\var{R}{indices of intervals not covered by any other}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
|R| \;=\; \sum_{i=1}^{n} \mathbf{1}\!\left[\, \forall j \ne i:\ \neg C(i,j) \,\right].
\end{BreakableEquation*}
}
\ASSUMPTIONS{Half-open intervals $[l_i,r_i)$; uniqueness of intervals; integer endpoints; coverage uses $\le$ on both comparisons.}
\INVARIANTS{
\begin{bullets}
\item If intervals are sorted by $(l \text{ asc}, r \text{ desc})$, then whenever $r \le r_{\max}$, the current interval is covered.
\item $r_{\max}$ is nondecreasing as we scan left to right.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly test coverage $C(i,j)$ for all ordered pairs $(i,j)$ to mark covered intervals, then count survivors.}
\ASSUMPTIONS{Use the coverage definition $l_j \le l_i$ and $r_i \le r_j$. Half-open vs closed does not affect coverage under $\le$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $i$, check if there exists $j \ne i$ such that $C(i,j)$ holds.
\item Mark interval $i$ as covered if any such $j$ exists.
\item Return the count of unmarked intervals.
\end{algosteps}
\COMPLEXITY{Double loop over $n$ intervals.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\\
S(n) &= \Theta(n)\ \text{for the covered flags}.
\end{aligned}
\]
\CORRECTNESS{By definition, an interval is removed iff there exists another interval that covers it; enumerating all pairs exactly realizes this predicate.}
\EDGECASES{Disjoint intervals; identical starts; nested chains; full containment with equal right ends.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        n = len(intervals)
        covered = [False] * n
        # Compare every pair (i, j), i != j
        for i in range(n):
            li, ri = intervals[i]
            for j in range(n):
                if i == j:
                    continue
                lj, rj = intervals[j]
                # j covers i if lj <= li and ri <= rj
                if lj <= li and ri <= rj:
                    covered[i] = True
                    break
        return sum(1 for i in range(n) if not covered[i])

# Asserts (Baseline)
s = Solution()
assert s.removeCoveredIntervals([[1,4],[3,6],[2,8]]) == 2
assert s.removeCoveredIntervals([[1,4],[2,3]]) == 1
assert s.removeCoveredIntervals([[1,2],[2,3],[3,4]]) == 3
assert s.removeCoveredIntervals([[1,10],[2,9],[3,8],[4,7]]) == 1
\end{minted}
\VALIDATION{Tiny checks cover disjoint intervals, simple cover, and nested chain.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sort and Single Scan}
\WHICHFORMULA{Sort by $(l \text{ asc}, r \text{ desc})$ so any potential cover appears before a covered interval with the same left; a running maximum right endpoint detects coverage.}
\ASSUMPTIONS{Sorting order ensures that if two intervals share the same left, the longer one comes first, causing the shorter to satisfy $r \le r_{\max}$ and hence be covered.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort intervals by key $(l, -r)$.
\item Initialize $r_{\max} = -\infty$, count $= 0$.
\item For each $(l,r)$ in order:
  \begin{bullets}
  \item If $r \le r_{\max}$, it is covered; skip.
  \item Else, increment count and set $r_{\max} \leftarrow r$.
  \end{bullets}
\end{algosteps}
\COMPLEXITY{Sorting dominates.}
\[
\begin{aligned}
T(n) &= \Theta(n \log n) + \Theta(n) = \Theta(n \log n),\\
S(n) &= \Theta(1)\ \text{extra (in-place sort or } \Theta(n) \text{ if copying)}.
\end{aligned}
\]
\CORRECTNESS{With $(l \text{ asc}, r \text{ desc})$, any interval with $r \le r_{\max}$ is covered by a preceding interval whose right endpoint is $\ge r$. Otherwise it extends coverage frontier and cannot be covered.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        # Sort by left asc, right desc
        intervals.sort(key=lambda x: (x[0], -x[1]))
        rmax = -10**18
        remaining = 0
        for l, r in intervals:
            if r <= rmax:
                # covered by some previous interval
                continue
            remaining += 1
            rmax = r
        return remaining

# Asserts (Improved)
s = Solution()
assert s.removeCoveredIntervals([[1,4],[3,6],[2,8]]) == 2
assert s.removeCoveredIntervals([[1,4],[2,3]]) == 1
assert s.removeCoveredIntervals([[1,2],[2,3],[3,4]]) == 3
assert s.removeCoveredIntervals([[1,10],[2,9],[3,8],[4,7]]) == 1
assert s.removeCoveredIntervals([[1,4],[1,3],[1,2]]) == 1
\end{minted}
\VALIDATION{Adds a tie-on-left test to ensure correct descending-right tie-break behavior.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Greedy After Sort (Provably Optimal)}
\WHICHFORMULA{Same sorting plus greedy frontier maintenance is optimal; any algorithm must inspect endpoints, implying an $\Omega(n \log n)$ lower bound under comparison sorting.}
\ASSUMPTIONS{Endpoints are arbitrary integers; comparison-based sorting lower bound applies.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort by $(l \text{ asc}, r \text{ desc})$.
\item Maintain $r_{\max}$.
\item Count intervals with $r > r_{\max}$ and update $r_{\max}$.
\end{algosteps}
\OPTIMALITY{Given arbitrary integer endpoints, distinguishing order requires $\Omega(n \log n)$ comparisons; the linear scan after sorting is tight, so total time is optimal up to constant factors.}
\COMPLEXITY{
\begin{BreakableEquation*}
T(n) = \Theta(n \log n),\quad S(n) = \Theta(1)\ \text{extra}.
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        # Greedy after sorting: (l asc, r desc)
        intervals.sort(key=lambda x: (x[0], -x[1]))
        rmax = -10**18
        ans = 0
        for l, r in intervals:
            if r <= rmax:
                continue
            ans += 1
            rmax = r
        return ans

# Exact 3 asserts
s = Solution()
assert s.removeCoveredIntervals([[1,4],[3,6],[2,8]]) == 2
assert s.removeCoveredIntervals([[1,4],[2,3]]) == 1
assert s.removeCoveredIntervals([[0,5],[2,5],[2,4],[6,7]]) == 2
\end{minted}
\VALIDATION{Covers nested, simple coverage, and equal-right containment cases.}
\RESULT{Returns the count of intervals not covered by any other interval; when starts tie, longer intervals are kept and shorter are removed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for examples, disjoint sets, chains of nested intervals, same-left ties, and random fuzz tests comparing $O(n^2)$ baseline vs final greedy for small $n$.}
\LINE{CROSS-CHECKS}{On small $n$, generate random intervals and assert baseline count equals optimal count; include adversarial patterns: identical lefts with decreasing rights, alternating overlaps, and staircases.}
\LINE{EDGE-CASE GENERATOR}{Produces deterministic sets with seeds; ensures coverage of equal-left, equal-right, strictly increasing, and nested patterns.}
\begin{minted}{python}
from typing import List, Tuple
import random

def gen_intervals(n: int, seed: int = 0, lo: int = 0, hi: int = 20) -> List[List[int]]:
    random.seed(seed)
    arr = []
    for _ in range(n):
        a = random.randint(lo, hi-1)
        b = random.randint(a+1, hi)
        arr.append([a, b])
    # ensure uniqueness by converting to set then back (deterministic due to sort)
    arr = sorted(list({(l, r) for l, r in arr}))
    return [list(x) for x in arr]

def baseline(intervals: List[List[int]]) -> int:
    n = len(intervals)
    covered = [False] * n
    for i in range(n):
        li, ri = intervals[i]
        for j in range(n):
            if i == j: continue
            lj, rj = intervals[j]
            if lj <= li and ri <= rj:
                covered[i] = True
                break
    return sum(1 for i in range(n) if not covered[i])

def optimal(intervals: List[List[int]]) -> int:
    intervals = intervals[:]  # copy
    intervals.sort(key=lambda x: (x[0], -x[1]))
    rmax = -10**18
    ans = 0
    for l, r in intervals:
        if r <= rmax:
            continue
        ans += 1
        rmax = r
    return ans

# Cross-checks
for seed in range(20):
    ints = gen_intervals(15, seed=seed)
    assert baseline(ints) == optimal(ints)

# Adversarials
assert optimal([[1,10],[1,9],[1,8],[1,7]]) == 1
assert optimal([[1,2],[2,5],[1,5],[3,4],[2,3]]) == 2
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        # Sort by left ascending, right descending to expose coverage
        intervals.sort(key=lambda x: (x[0], -x[1]))
        rmax = -10**18
        count = 0
        for l, r in intervals:
            if r <= rmax:
                # covered by a previous interval
                continue
            count += 1
            rmax = r
        return count

# Quick asserts
if __name__ == "__main__":
    s = Solution()
    assert s.removeCoveredIntervals([[1,4],[3,6],[2,8]]) == 2
    assert s.removeCoveredIntervals([[1,4],[2,3]]) == 1
    assert s.removeCoveredIntervals([[0,5],[2,5],[2,4],[6,7]]) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort by $(l \text{ asc}, r \text{ desc})$ and count intervals that extend the running rightmost endpoint.}
\WHY{Common interval-greedy pattern; tests sorting with custom tie-breaks and single-pass reasoning.}
\CHECKLIST{
\begin{bullets}
\item Sort by left ascending, right descending.
\item Initialize $r_{\max}$ to $-\infty$.
\item If current right $\le r_{\max}$ then covered; else count and update $r_{\max}$.
\item Return count.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Same left endpoints: keep the longest only.
\item Equal right endpoints with different lefts.
\item Fully nested chains.
\item All disjoint intervals.
\item Single interval ($n=1$).
\item Large $n$ with many duplicates avoided by uniqueness.
\item Half-open endpoints do not change coverage rule (uses $\le$).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Wrong tie-break (sorting right ascending) misclassifies same-left intervals.
\item Using $<$ instead of $\le$ on right endpoint breaks equal-right coverage.
\item Updating $r_{\max}$ when covered corrupts future decisions.
\item Forgetting to copy before sort if original order must be preserved elsewhere.
\item Overflow not an issue in Python, but sentinel must be low enough.
\item Misinterpreting half-open vs closed; coverage here is with $\le$.
\end{bullets}}
\FAILMODES{Baseline $O(n^2)$ is correct but slow; arbitrary sweep without the right tie-break fails when lefts tie; hash-based dedup not needed due to uniqueness.}
\ELI{Line up intervals by start; whenever a new one ends no later than the best-so-far, it is inside and removed. Only those that push the farthest right boundary remain.}
\NotePages{3}

\end{document}