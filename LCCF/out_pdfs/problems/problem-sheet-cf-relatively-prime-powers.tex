% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Relatively Prime Powers}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1036/F}}
\LINE{DIFFICULTY / RATING}{2400}
\STATEMENT{Consider a positive integer $x$. Its prime factorization is of the form $x = 2^{k_1} \cdot 3^{k_2} \cdot 5^{k_3} \cdot \ldots$.

Call $x$ \emph{elegant} if $\gcd(k_1,k_2,\ldots)=1$. For example, numbers $5=5^1$, $12=2^2 \cdot 3$, $72=2^3 \cdot 3^2$ are elegant, and numbers $8=2^3$ ($GCD=3$), $2500=2^2 \cdot 5^4$ ($GCD=2$) are not.

Count the number of elegant integers from $2$ to $n$.

Each test contains several values of $n$, and each must be solved independently.

Input:
The first line contains an integer $T$ ($1 \le T \le 10^5$) — the number of queries.
Each of the next $T$ lines contains an integer $n_i$ ($2 \le n_i \le 10^{18}$).

Output:
Print $T$ lines, where the $i$-th line is the number of elegant integers from $2$ to $n_i$.

Note: Non-elegant numbers up to $10$ are:
$4=2^2$ ($GCD=2$), $8=2^3$ ($GCD=3$), $9=3^2$ ($GCD=2$). The rest have $GCD=1$.}
\BREAKDOWN{An integer is non-elegant iff it is a perfect power $y^d$ with $d \ge 2$. So the answer for each $n$ equals the count of integers in $[2,n]$ that are not perfect powers. Use inclusion--exclusion via the M\"obius function on exponents, or precompute non-square perfect powers.}
\ELI{Elegant means ``not a perfect power''. Count all numbers $2..n$ and subtract those that are perfect powers.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test file: integer $T$ followed by $T$ lines of $n_i$.
- $1 \le T \le 10^5$.
- $2 \le n_i \le 10^{18}$.}
\OUTPUTS{For each $n_i$, output the number of elegant integers in $[2,n_i]$. One integer per line.}
\SAMPLES{Example:
- Input: $T=3$, $n \in \{2,10,16\}$.
- Output: $1,6,11$. Explanation: Up to $10$, exclude $\{4,8,9\}$, leaving $6$; up to $16$, exclude $\{4,8,9,16\}$, leaving $11$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $E(n)$ be the number of integers $x \in [2,n]$ with $\gcd$ of prime exponents equal to $1$. Let $\mu$ be the M\"obius function on positive integers.}
\varmapStart
\var{n}{query upper bound}
\var{d}{exponent divisor; $d \ge 1$}
\var{\mu(d)}{M\"obius function}
\var{\lfloor n^{1/d} \rfloor}{count of $d$-th powers $\le n$ with base $\ge 1$}
\varmapEnd
\GOVERN{
\[
E(n) \;=\; \sum_{d \ge 1} \mu(d)\,\bigl(\lfloor n^{1/d}\rfloor - 1\bigr)
\quad\text{for } d \le \lfloor \log_2 n \rfloor,
\]
since ``$d$ divides all prime exponents'' $\iff$ ``$x$ is a perfect $d$-th power'', and we exclude base $1$ by subtracting $1$.}
\ASSUMPTIONS{Treat prime exponents for primes not dividing $x$ as $0$. Only $d \le \lfloor \log_2 n \rfloor$ matter, because $2^d \le n$ must hold for any nontrivial $d$-th power.}
\INVARIANTS{
- Inclusion--exclusion on the lattice of exponent divisibility via $\mu$ yields exact counting (no over/undercount).
- $\lfloor n^{1/d}\rfloor$ is monotone nonincreasing in $d$ and equals $1$ for large $d$, so the finite cutoff is sound.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly test each $x \in [2,n]$: factor $x$, gather exponents, compute their $\gcd$, and count those with $\gcd=1$.}
\ASSUMPTIONS{Works only for very small $n$. Used for verification.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $x$ from $2$ to $n$, factor $x$ by trial division.
\item Record the multiset of positive exponents in its prime factorization.
\item If the $\gcd$ of those exponents equals $1$, increment the answer.
\end{algosteps}
\COMPLEXITY{Let $\pi$ be the number of primes up to $\sqrt{n}$. Trial division per $x$ costs $O(\sqrt{x})$ in the worst case; overall time $T(n)=\Theta(n^{3/2})$; space $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &\approx \sum_{x=2}^{n} O(\sqrt{x}) \;=\; O\!\bigl(n^{3/2}\bigr).
\end{aligned}
\]
\CORRECTNESS{This exactly checks the definition and thus is correct for any $n$, modulo its runtime.}
\EDGECASES{Powers of a prime; mixed exponents like $2^a3^b$; large primes (exponent $1$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math

def is_elegant(x: int) -> bool:
    # Factor x by trial division; compute gcd of positive exponents.
    exp_gcd = 0
    n = x
    p = 2
    while p * p <= n:
        if n % p == 0:
            cnt = 0
            while n % p == 0:
                n //= p
                cnt += 1
            exp_gcd = cnt if exp_gcd == 0 else math.gcd(exp_gcd, cnt)
        p += 1 if p == 2 else 2  # small speed: after 2, test odds
    if n > 1:
        # remaining prime factor with exponent 1
        exp_gcd = 1 if exp_gcd == 0 else math.gcd(exp_gcd, 1)
    return exp_gcd == 1

def solve_case(n: int) -> int:
    # Brute force: count elegant numbers in [2..n]
    ans = 0
    for x in range(2, n + 1):
        if is_elegant(x):
            ans += 1
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    qs = [int(next(it)) for _ in range(T)]
    return T, qs

def solve_all(qs):
    out = []
    for n in qs:
        out.append(str(solve_case(min(n, 10000))))  # WARNING: extremely slow; hard cap for safety
    return "\n".join(out)

def main():
    # Self-checks for tiny n
    assert is_elegant(2) and is_elegant(3)
    assert not is_elegant(4) and not is_elegant(8) and not is_elegant(9)
    assert solve_case(10) == 6  # matches statement reasoning
    T, qs = read_input()
    if T:
        print(solve_all(qs))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked: $n=2 \mapsto 1$, $n=4 \mapsto 2$ (exclude $4$), $n=10 \mapsto 6$ (exclude $4,8,9$).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Precompute Non-Square Perfect Powers}
\WHICHFORMULA{An integer is a perfect power iff it is a square or a non-square perfect power of exponent $\ge 3$. Count squares with $\lfloor\sqrt{n}\rfloor$ and precompute all non-square perfect powers $\le n_{\max}$ once. Then $E(n) = n - \lfloor\sqrt{n}\rfloor - \#\{p \in \mathcal{P} : p \le n\}$.}
\ASSUMPTIONS{Precomputation up to $n_{\max}=\max n_i \le 10^{18}$. Non-square perfect powers up to $10^{18}$ are about $10^6$; feasible to store and binary-search.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute a sorted list $\mathcal{P}$ of all $b^k \le n_{\max}$ for integers $b \ge 2$, $k \ge 3$, such that $b^k$ is not a perfect square.
\item For each query $n$: let $s = \lfloor\sqrt{n}\rfloor$; let $m = |\{p \in \mathcal{P}: p \le n\}|$ by binary search.
\item Answer $E(n) = n - s - m$.
\end{algosteps}
\COMPLEXITY{Precompute time $\approx \sum_{k=3}^{60} n_{\max}^{1/k} \approx 10^6$ insertions; sorting $O(M\log M)$ with $M\approx 10^6$. Per query: $O(\log M)$ time, $O(1)$ memory.}
\[
\begin{aligned}
T_{\text{build}} &\approx 10^6, \quad
T_{\text{query}} = O(\log 10^6).
\end{aligned}
\]
\CORRECTNESS{Squares and non-square higher powers form a disjoint union of perfect powers $\ge 2$, so subtraction gives exactly the non-perfect-powers (elegant numbers).}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math, bisect

def is_square(x: int) -> bool:
    r = math.isqrt(x)
    return r * r == x

def precompute_non_square_powers(limit: int):
    # Collect all b^k <= limit for k>=3 that are NOT perfect squares.
    S = set()
    # Max base for k>=3 is cube root
    max_b = int(round(limit ** (1.0 / 3))) + 2
    for b in range(2, max_b + 1):
        val = b * b * b
        while val <= limit:
            if not is_square(val):
                S.add(val)
            # Prevent infinite loop if b==1 (not possible here) or overflow:
            # Python ints are unbounded; we only need to stop by limit
            val *= b
    P = sorted(S)
    return P

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    qs = [int(next(it)) for _ in range(T)]
    return T, qs

def solve_all(qs):
    if not qs:
        return ""
    nmax = max(qs)
    P = precompute_non_square_powers(nmax)
    out_lines = []
    for n in qs:
        s = math.isqrt(n)  # squares including 1
        m = bisect.bisect_right(P, n)  # non-square perfect powers (>= 8)
        # Perfect powers in [2..n] = (s - 1) + m
        ans = n - s - m  # = (n-1) - ((s-1)+m)
        out_lines.append(str(ans))
    return "\n".join(out_lines)

def main():
    # Tiny checks
    assert precompute_non_square_powers(10) == [8]
    # For n=10: squares s=3 (1,4,9) -> (s-1)=2, non-square powers m=1 (8): total 3; 9 numbers [1..10]
    # Elegant in [2..10] = 9 - 3 = 6
    assert solve_all([10]) == "6"
    T, qs = read_input()
    if T:
        print(solve_all(qs))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge checks: $n=2 \mapsto 1$, $n=8 \mapsto 5$ (exclude $4,8$), $n=10 \mapsto 6$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{M\"obius Inversion on Exponents}
\WHICHFORMULA{By M\"obius inversion on the divisor lattice of exponents: an integer has $\gcd$ of prime exponents equal to $1$ iff $\sum_{d \mid \gcd} \mu(d) = 1$. Hence
$E(n)=\sum_{d \ge 1} \mu(d) \bigl(\lfloor n^{1/d}\rfloor - 1\bigr)$ with $d \le \lfloor \log_2 n \rfloor$.}
\ASSUMPTIONS{Accurate integer $d$-th roots, and $\mu(d)$ for $d \le 60$ (since $2^{60} > 10^{18}$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\mu(d)$ for $1 \le d \le 60$.
\item For each query $n$, compute integer roots $r_d=\lfloor n^{1/d}\rfloor$ for $d=1..60$.
\item Sum $E(n)=\sum_{d=1}^{60} \mu(d)\,(r_d - 1)$.
\end{algosteps}
\OPTIMALITY{Each query does $O(60)$ constant-time steps with cheap integer roots; asymptotically optimal under word RAM. Matches known solution for CF 1036F.}
\COMPLEXITY{Per query $O(60)$ time, $O(1)$ space. Precompute $O(60)$ for $\mu$.}
\[
\begin{aligned}
T(n) &= O(60) \quad \text{per query.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys, math

def mobius_up_to(K: int):
    mu = [0] * (K + 1)
    mu[1] = 1
    for d in range(2, K + 1):
        x = d
        mu_d = 1
        p = 2
        while p * p <= x:
            if x % p == 0:
                x //= p
                mu_d = -mu_d
                if x % p == 0:
                    mu_d = 0
                    break
                # remove remaining powers (none left since we checked square)
                while x % p == 0:
                    x //= p
            p += 1
        if mu_d != 0 and x > 1:
            mu_d = -mu_d
        mu[d] = mu_d
    return mu

def kth_root_floor(n: int, k: int) -> int:
    if k == 1:
        return n
    if k == 2:
        return math.isqrt(n)
    # floating estimate + fix-up
    y = int(n ** (1.0 / k))
    if y < 1:
        y = 1
    # adjust upward if needed
    while pow(y + 1, k) <= n:
        y += 1
    # adjust downward if needed
    while pow(y, k) > n:
        y -= 1
    return y

def solve_case(n: int, mu, K: int) -> int:
    ans = 0
    for d in range(1, K + 1):
        if mu[d] == 0:
            continue
        r = kth_root_floor(n, d)
        if r <= 1 and d > 1:
            # For d>1, (r - 1) would be 0 or negative; no further d will help
            # But keep the loop cheap; early break is optional
            pass
        ans += mu[d] * (r - 1)
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    qs = [int(next(it)) for _ in range(T)]
    return T, qs

def solve_all(qs):
    if not qs:
        return ""
    K = 60  # since 2^60 > 1e18
    mu = mobius_up_to(K)
    out = []
    for n in qs:
        out.append(str(solve_case(n, mu, K)))
    return "\n".join(out)

def main():
    # Spot checks vs small truths
    K = 60
    mu = mobius_up_to(K)
    def brute(n):
        # tiny brute for validation
        def is_elegant(x):
            g = 0
            t = x
            p = 2
            while p * p <= t:
                if t % p == 0:
                    c = 0
                    while t % p == 0:
                        t //= p
                        c += 1
                    g = c if g == 0 else math.gcd(g, c)
                p += 1 if p == 2 else 2
            if t > 1:
                g = 1 if g == 0 else math.gcd(g, 1)
            return g == 1
        return sum(1 for x in range(2, n + 1) if is_elegant(x))
    assert solve_case(2, mu, K) == 1
    assert solve_case(4, mu, K) == 2
    assert solve_case(10, mu, K) == 6
    # Random small cross-check
    for n in [15, 25, 50, 100]:
        assert solve_case(n, mu, K) == brute(n)
    T, qs = read_input()
    if T:
        print(solve_all(qs))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts: $E(2)=1$, $E(4)=2$, $E(10)=6$. Cross-checks for $n\in\{15,25,50,100\}$ agree with brute force.}
\RESULT{For each query $n$, output $E(n)=\sum_{d=1}^{60}\mu(d)\,(\lfloor n^{1/d}\rfloor-1)$, i.e., the count of non-perfect-powers in $[2,n]$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-check the M\"obius values for $d\le 10$; verify $k$-th root routine around boundaries $2^k-1$, $2^k$, $2^k+1$; property-test $E(n)$ vs brute force up to $n=200$.}
\LINE{CROSS-CHECKS}{Compare Approach B (precomputed non-square powers) and Approach C (M\"obius) on random samples and ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate inputs near perfect powers: $n \in \{p^k-1,p^k,p^k+1\}$ for small $p,k$, plus minimal $n=2$ and maximal $n=10^{18}$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import math
def gen_perfect_power_edges(limit_k=10, limit_p=100):
    cases = [2, 3, 4, 8, 9, 10]
    for k in range(2, limit_k + 1):
        p = 2
        while p <= limit_p:
            v = p ** k
            cases.extend([max(2, v - 1), v, v + 1])
            p += 1
    # Deduplicate and sort
    cases = sorted(set(cases))
    return cases

def brute_elegant(n: int) -> int:
    import math
    def is_elegant(x):
        g = 0
        t = x
        d = 2
        while d * d <= t:
            if t % d == 0:
                c = 0
                while t % d == 0:
                    t //= d
                    c += 1
                g = c if g == 0 else math.gcd(g, c)
            d += 1 if d == 2 else 2
        if t > 1:
            g = 1 if g == 0 else math.gcd(g, 1)
        return g == 1
    return sum(1 for x in range(2, n + 1) if is_elegant(x))

# Quick self-test of generator and brute
edges = gen_perfect_power_edges(6, 20)
assert 4 in edges and 8 in edges and 9 in edges
assert brute_elegant(10) == 6
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys, math

def mobius_up_to(K: int):
    mu = [0] * (K + 1)
    mu[1] = 1
    for d in range(2, K + 1):
        x = d
        mu_d = 1
        p = 2
        while p * p <= x:
            if x % p == 0:
                x //= p
                mu_d = -mu_d
                if x % p == 0:
                    mu_d = 0
                    break
                while x % p == 0:
                    x //= p
            p += 1
        if mu_d != 0 and x > 1:
            mu_d = -mu_d
        mu[d] = mu_d
    return mu

def kth_root_floor(n: int, k: int) -> int:
    if k == 1:
        return n
    if k == 2:
        return math.isqrt(n)
    y = int(n ** (1.0 / k))
    if y < 1:
        y = 1
    while pow(y + 1, k) <= n:
        y += 1
    while pow(y, k) > n:
        y -= 1
    return y

def solve_case(n: int, mu, K: int) -> int:
    ans = 0
    for d in range(1, K + 1):
        md = mu[d]
        if md == 0:
            continue
        r = kth_root_floor(n, d)
        ans += md * (r - 1)
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    qs = [int(next(it)) for _ in range(T)]
    return T, qs

def solve_all(qs):
    if not qs:
        return ""
    K = 60
    mu = mobius_up_to(K)
    return "\n".join(str(solve_case(n, mu, K)) for n in qs)

def main():
    # Local assertions
    K = 60
    mu = mobius_up_to(K)
    assert solve_case(2, mu, K) == 1
    assert solve_case(4, mu, K) == 2
    assert solve_case(10, mu, K) == 6
    T, qs = read_input()
    if T:
        print(solve_all(qs))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Elegant numbers are exactly the non-perfect-powers. Count with M\"obius inversion over exponents.}
\WHY{This blends number theory (M\"obius, inclusion--exclusion) with careful integer root computation; a common CF pattern.}
\CHECKLIST{
- Reduce to ``not a perfect power''.
- Pick method: M\"obius or precompute non-square powers.
- Implement exact integer $k$-th root.
- Precompute $\mu(d)$ for $d \le 60$.
- Sum $\sum \mu(d)\,(\lfloor n^{1/d}\rfloor - 1)$ per query.}
\EDGECASES{
- $n=2$ minimal boundary.
- $n$ exactly a perfect power $p^k$.
- Near boundaries: $p^k-1$, $p^k+1$.
- Large $n=10^{18}$.
- Sixth powers $p^6$ (both square and cube).
- Primes and prime powers.}
\PITFALLS{
- Using floating roots without integer fix-up can off-by-one.
- Forgetting to exclude base $1$ ($-1$ term).
- Iterating $d$ past $60$ (wasted work).
- Computing $\mu(d)$ incorrectly for non-square-free $d$.
- Big-integer overflow concerns in other languages (not in Python).
- Double-counting squares if using the precomputed set approach without filtering squares.}
\FAILMODES{Brute force factoring dies for $n \approx 10^{18}$. Precomputing all powers including squares naively may double-count; M\"obius method avoids this.}
\ELI{Numbers are elegant unless they are a perfect square, cube, fourth power, etc. M\"obius inversion compactly subtracts overlaps between these sets using $\mu(d)$. Compute a handful of integer roots and add with signs.}
\NotePages{3}

\end{document}