% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lexicographically Smallest String After Applying Operations}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given a string \texttt{s} of even length consisting of digits from \texttt{0} to \texttt{9}, and two integers \texttt{a} and \texttt{b}. You can apply either of the following two operations any number of times and in any order on \texttt{s}: 
\begin{bullets}
\item Add \texttt{a} to all odd indices of \texttt{s} (0-indexed). Digits past \texttt{9} are cycled back to \texttt{0}. For example, if \texttt{s = "3456"} and \texttt{a = 5}, \texttt{s} becomes \texttt{"3951"}.
\item Rotate \texttt{s} to the right by \texttt{b} positions. For example, if \texttt{s = "3456"} and \texttt{b = 1}, \texttt{s} becomes \texttt{"6345"}.
\end{bullets}
Return the lexicographically smallest string you can obtain by applying the above operations any number of times on \texttt{s}. A string \texttt{u} is lexicographically smaller than a string \texttt{v} (of the same length) if in the first position where they differ, \texttt{u} has a digit that is smaller than the corresponding digit in \texttt{v}. For example, \texttt{"0158"} is lexicographically smaller than \texttt{"0190"} because the first position they differ is at the third digit, and \texttt{5} comes before \texttt{9}.

Examples:
\begin{bullets}
\item Input: \texttt{s = "5525"}, \texttt{a = 9}, \texttt{b = 2}. Output: \texttt{"2050"}. One sequence: \texttt{"5525"} $\to$ rotate $\to$ \texttt{"2555"} $\to$ add $\to$ \texttt{"2454"} $\to$ add $\to$ \texttt{"2353"} $\to$ rotate $\to$ \texttt{"5323"} $\to$ add $\to$ \texttt{"5222"} $\to$ add $\to$ \texttt{"5121"} $\to$ rotate $\to$ \texttt{"2151"} $\to$ add $\to$ \texttt{"2050"}.
\item Input: \texttt{s = "74"}, \texttt{a = 5}, \texttt{b = 1}. Output: \texttt{"24"}.
\item Input: \texttt{s = "0011"}, \texttt{a = 4}, \texttt{b = 2}. Output: \texttt{"0011"}.
\end{bullets}
Constraints: \texttt{2 \le s.length \le 100}, \texttt{s.length} is even, digits only, \texttt{1 \le a \le 9}, \texttt{1 \le b \le s.length - 1}.}
\BREAKDOWN{We must search over all strings reachable via: (i) adding \texttt{a} modulo 10 to digits at odd positions, and (ii) rotating right by \texttt{b}. The task is to find the lexicographically minimum string among all reachable states.}
\ELI{The operations form a finite state graph; either BFS all states, or exploit modular cycles and rotation periodicity to enumerate a much smaller canonical set and pick the minimum.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test instance with:
\begin{bullets}
\item \texttt{s}: a string of even length \texttt{n} with characters in \texttt{\{0,\ldots,9\}}.
\item \texttt{a}: integer in \texttt{[1,9]}.
\item \texttt{b}: integer in \texttt{[1,n-1]}.
\end{bullets}}
\OUTPUTS{A single string: the lexicographically smallest string reachable from \texttt{s} by any sequence of allowed operations.}
\SAMPLES{Examples (compact LC-style):
\begin{bullets}
\item Input: \texttt{s = "5525"}, \texttt{a = 9}, \texttt{b = 2} $\Rightarrow$ Output: \texttt{"2050"}.
\item Input: \texttt{s = "74"}, \texttt{a = 5}, \texttt{b = 1} $\Rightarrow$ Output: \texttt{"24"}.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the state space be all strings of length $n$ over $\{0,\ldots,9\}$. Define two functions on strings:
\[
A_a(s)_i = \begin{cases}
(s_i + a) \bmod 10, & i \text{ odd},\\
s_i, & i \text{ even},
\end{cases}
\quad
R_b(s)_i = s_{(i - b) \bmod n}.
\]
We consider the monoid generated by $A_a$ and $R_b$ acting on the initial string $s$. The goal is $\min_{\preceq}\{ t \mid t \in \langle A_a, R_b\rangle \cdot s\}$ under lexicographic order $\preceq$.}
\varmapStart
\var{n}{length of the string $s$ (even)}
\var{a}{increment applied to odd indices, modulo 10}
\var{b}{right-rotation step size}
\var{G}{set of strings reachable by composing $A_a$ and $R_b$}
\var{t^\star}{lexicographically smallest element of $G$}
\varmapEnd
\GOVERN{
\[
G = \{\, \phi_k \circ \cdots \circ \phi_1 (s) \mid \phi_j \in \{A_a, R_b\},~k \ge 0 \,\},
\qquad
t^\star = \min\nolimits_{\preceq}\, G.
\]
}
\ASSUMPTIONS{Indices are 0-based; $n$ is even; rotations use modulo-$n$ indexing; additions use modulo 10 arithmetic.}
\INVARIANTS{
\begin{bullets}
\item The multiset of digits mod 10 is preserved up to the action of additions on affected indices.
\item The parity of indices is preserved by rotation iff $b$ is even; if $b$ is odd, parity can flip under repeated rotations, enabling both parities to be incremented.
\item The set $G$ is finite since each position has 10 possibilities and there are finitely many rotations; thus a minimum exists.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Model all reachable strings as nodes in a finite graph with edges for $A_a$ and $R_b$. Use BFS/DFS to traverse all states, tracking the smallest string.}
\ASSUMPTIONS{State space size is manageable due to $n \le 100$ and the strong periodicity of operations; visited-set prevents revisits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a queue with the start string \texttt{s}, a visited set, and best string as \texttt{s}.
\item While the queue is non-empty, pop a state \texttt{t}, update the best string.
\item Generate \texttt{t1 = add\_odd(t, a)} and \texttt{t2 = rotate\_right(t, b)}; if unseen, mark visited and push.
\end{algosteps}
\COMPLEXITY{Let $S$ be the number of reachable states (finite). Each state generates at most 2 edges and costs $O(n)$ to realize.}
\[
\begin{aligned}
T(n) &\in O(S \cdot n), \\
S(n) &\in O(S \cdot n) \text{ for storing visited strings (or $O(S)$ if interning).}
\end{aligned}
\]
\CORRECTNESS{BFS explores the entire connected component reachable from \texttt{s}. Since lexicographic minimum is well-defined over a finite set, the minimum encountered during traversal is the desired answer.}
\EDGECASES{When $b$ is a multiple of $n$ the rotation is identity; when $a \equiv 0 \pmod{10}$ the add operation is identity. Both are handled naturally by visited detection.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
from typing import Deque, Set

class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        n = len(s)
        def add_odd(t: str) -> str:
            arr = list(t)
            for i in range(1, n, 2):
                arr[i] = str((int(arr[i]) + a) % 10)
            return "".join(arr)
        def rotate_right(t: str) -> str:
            k = b % n
            if k == 0:
                return t
            return t[-k:] + t[:-k]

        best = s
        q: Deque[str] = deque([s])
        seen: Set[str] = {s}
        while q:
            cur = q.popleft()
            if cur < best:
                best = cur
            nxt1 = add_odd(cur)
            if nxt1 not in seen:
                seen.add(nxt1)
                q.append(nxt1)
            nxt2 = rotate_right(cur)
            if nxt2 not in seen:
                seen.add(nxt2)
                q.append(nxt2)
        return best

if __name__ == "__main__":
    sol = Solution()
    assert sol.findLexSmallestString("5525", 9, 2) == "2050"
    assert sol.findLexSmallestString("74", 5, 1) == "24"
    assert sol.findLexSmallestString("0011", 4, 2) == "0011"
    # Extra checks
    assert sol.findLexSmallestString("43987654", 7, 3) <= "43987654"
    assert sol.findLexSmallestString("10", 1, 1) == "01"
\end{minted}
\VALIDATION{Sanity checks ensure sample outputs match; extra asserts verify monotonic improvement and small crafted cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Enumeration via Periodicity}
\WHICHFORMULA{Use rotation period $\mathrm{per} = n / \gcd(n,b)$ and addition cycle length $10 / \gcd(10,a)$ to limit enumeration. For each distinct rotation, try only distinct add counts modulo this cycle.}
\ASSUMPTIONS{Modulo-10 addition on a digit cycles after $10 / \gcd(10,a)$ steps; rotations repeat after $n / \gcd(n,b)$ steps. If $b$ is odd, parity mixing allows affecting both parities with separate add counts.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute period $\mathrm{per} = n / \gcd(n,b)$ and addition cycle $m = 10 / \gcd(10,a)$.
\item For each rotation offset $r \in \{0,b,2b,\ldots\}$ modulo $n$ with length $\mathrm{per}$, form $t = \mathrm{rot}(s,r)$.
\item For $x \in [0,m-1]$ apply $x$-times addition to odd indices. If $b$ is odd, also loop $y \in [0,m-1]$ to apply to even indices via parity mixing; otherwise fix $y=0$. Track the minimum over all candidates.
\end{algosteps}
\COMPLEXITY{Beats brute force by bounding loops to arithmetic periods.}
\[
\begin{aligned}
T(n) &\in O\Bigl(\frac{n}{\gcd(n,b)} \cdot \frac{10}{\gcd(10,a)} \cdot \Bigl(\mathbf{1}_{b\ \text{odd}}\cdot \frac{10}{\gcd(10,a)} + \mathbf{1}_{b\ \text{even}}\cdot 1\Bigr) \cdot n\Bigr),\\
S(n) &\in O(n).
\end{aligned}
\]
\CORRECTNESS{Every reachable string can be represented by some rotation in the orbit of $b$ and some number of additions on odd indices; when $b$ is odd, further rotations allow targeting even indices as odd in a subsequent step, giving an independent add count there. Enumerating these canonical representatives covers $G$; taking the minimum yields the answer.}
\textbf{Code (Improved)}
\begin{minted}{python}
import math
from typing import List

class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        n = len(s)
        g_ab = math.gcd(a, 10)
        add_cycle = 10 // g_ab

        def rotate_right(t: str, k: int) -> str:
            k %= n
            if k == 0:
                return t
            return t[-k:] + t[:-k]

        def apply_adds(t: str, add_odd: int, add_even: int) -> str:
            add_odd %= 10
            add_even %= 10
            arr = list(t)
            for i, ch in enumerate(arr):
                d = int(ch)
                if i % 2 == 1:
                    d = (d + add_odd) % 10
                else:
                    d = (d + add_even) % 10
                arr[i] = str(d)
            return "".join(arr)

        per = n // math.gcd(n, b)
        best = s
        # iterate distinct rotations
        for k in range(per):
            t = rotate_right(s, k * b)
            # odd positions add count
            for x in range(add_cycle):
                if b % 2 == 0:
                    cand = apply_adds(t, x * a, 0)
                    if cand < best:
                        best = cand
                else:
                    for y in range(add_cycle):
                        cand = apply_adds(t, x * a, y * a)
                        if cand < best:
                            best = cand
        return best

if __name__ == "__main__":
    sol = Solution()
    assert sol.findLexSmallestString("5525", 9, 2) == "2050"
    assert sol.findLexSmallestString("74", 5, 1) == "24"
    assert sol.findLexSmallestString("0011", 4, 2) == "0011"
    # Additional coverage
    assert sol.findLexSmallestString("109090", 3, 4) <= "109090"
    assert sol.findLexSmallestString("8888", 1, 2) == "0088"
\end{minted}
\VALIDATION{Checked on samples; extra asserts target both $b$ even and odd, and symmetry cases with repeated digits.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Canonical Enumeration with Tight Cycles}
\WHICHFORMULA{Enumerate only $\mathrm{per} = n/\gcd(n,b)$ rotations and distinct add counts modulo $10/\gcd(10,a)$ for the parities, building candidates in $O(n)$ time each.}
\ASSUMPTIONS{Modulo cycles are tight; no further pruning is necessary. Works for all even $n$, any $a \in [1,9]$, and $b \in [1,n-1]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $m = 10/\gcd(10,a)$ and $\mathrm{per} = n/\gcd(n,b)$.
\item For each rotation offset among $\mathrm{per}$ distinct ones, form the rotated string.
\item For each $x \in [0,m-1]$ (odd positions) and, if $b$ is odd, each $y \in [0,m-1]$ (even positions), synthesize the candidate by adding $(x\cdot a)\bmod 10$ on odd indices and $(y\cdot a)\bmod 10$ on even indices; keep the lexicographic minimum.
\end{algosteps}
\OPTIMALITY{Lower bound: any correct algorithm must distinguish among the $\mathrm{per}$ distinct rotations and among distinct add residues modulo $10/\gcd(10,a)$ per affected parity. This method matches that bound up to constant factors, thus is optimal up to $O(n)$ per candidate construction.}
\COMPLEXITY{Let $m = 10/\gcd(10,a) \in \{1,2,5,10\}$ and $\mathrm{per} = n/\gcd(n,b) \le n$.}
\[
\begin{aligned}
T(n) &\in \begin{cases}
O(\mathrm{per}\cdot m \cdot n), & b \text{ even},\\
O(\mathrm{per}\cdot m^2 \cdot n), & b \text{ odd},
\end{cases}
\quad
S(n) \in O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import math

class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        n = len(s)
        per = n // math.gcd(n, b)
        m = 10 // math.gcd(10, a)

        def rotate_right(t: str, k: int) -> str:
            k %= n
            if k == 0:
                return t
            return t[-k:] + t[:-k]

        def build(t: str, add_odd: int, add_even: int) -> str:
            add_odd %= 10
            add_even %= 10
            arr = list(t)
            for i, ch in enumerate(arr):
                d = int(ch)
                if i % 2 == 1:
                    d = (d + add_odd) % 10
                else:
                    d = (d + add_even) % 10
                arr[i] = str(d)
            return "".join(arr)

        best = s
        for k in range(per):
            t = rotate_right(s, k * b)
            if b % 2 == 0:
                for x in range(m):
                    cand = build(t, x * a, 0)
                    if cand < best:
                        best = cand
            else:
                for x in range(m):
                    for y in range(m):
                        cand = build(t, x * a, y * a)
                        if cand < best:
                            best = cand
        return best

if __name__ == "__main__":
    sol = Solution()
    # Exactly 3 asserts
    assert sol.findLexSmallestString("5525", 9, 2) == "2050"
    assert sol.findLexSmallestString("74", 5, 1) == "24"
    assert sol.findLexSmallestString("0011", 4, 2) == "0011"
\end{minted}
\VALIDATION{Three asserts cover the official samples, spanning both $b$ even and odd.}
\RESULT{Returns the lexicographically smallest string reachable; ties are impossible under total order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Use sample-based tests, parity-mixing cases ($b$ odd), identity cases ($a \equiv 0 \bmod 10$ or $b \equiv 0 \bmod n$), and random small instances cross-checked between BFS (Approach A) and Optimal (Approach C).}
\LINE{CROSS-CHECKS}{For small $n \le 8$, enumerate via BFS and compare to the optimal enumeration answer over many random seeds.}
\LINE{EDGE-CASE GENERATOR}{Generate strings with repeated digits, alternating patterns, and extremes like \texttt{"0...0"} and \texttt{"9...9"}; vary $a \in \{1,2,5,9\}$ and $b$ co-prime or not with $n$.}
\begin{minted}{python}
import random
import math
from collections import deque
from typing import Deque, Set

def bfs_ref(s: str, a: int, b: int) -> str:
    n = len(s)
    def add_odd(t: str) -> str:
        arr = list(t)
        for i in range(1, n, 2):
            arr[i] = str((int(arr[i]) + a) % 10)
        return "".join(arr)
    def rotate_right(t: str) -> str:
        k = b % n
        return t[-k:] + t[:-k] if k else t
    best = s
    q: Deque[str] = deque([s])
    seen: Set[str] = {s}
    while q:
        cur = q.popleft()
        if cur < best:
            best = cur
        for nxt in (add_odd(cur), rotate_right(cur)):
            if nxt not in seen:
                seen.add(nxt)
                q.append(nxt)
    return best

def opt_ans(s: str, a: int, b: int) -> str:
    n = len(s)
    per = n // math.gcd(n, b)
    m = 10 // math.gcd(10, a)
    def rot(t: str, k: int) -> str:
        k %= n
        return t[-k:] + t[:-k] if k else t
    def build(t: str, add_odd: int, add_even: int) -> str:
        add_odd %= 10
        add_even %= 10
        arr = list(t)
        for i, ch in enumerate(arr):
            d = int(ch)
            if i % 2 == 1:
                d = (d + add_odd) % 10
            else:
                d = (d + add_even) % 10
            arr[i] = str(d)
        return "".join(arr)
    best = s
    for k in range(per):
        t = rot(s, k * b)
        if b % 2 == 0:
            for x in range(m):
                best = min(best, build(t, x * a, 0))
        else:
            for x in range(m):
                for y in range(m):
                    best = min(best, build(t, x * a, y * a))
    return best

if __name__ == "__main__":
    random.seed(0)
    # Property tests for small n
    for n in range(2, 9, 2):
        for _ in range(100):
            s = "".join(str(random.randrange(10)) for _ in range(n))
            a = random.randint(1, 9)
            b = random.randint(1, n - 1)
            assert bfs_ref(s, a, b) == opt_ans(s, a, b)
    # Spot checks
    assert opt_ans("5525", 9, 2) == "2050"
    assert opt_ans("74", 5, 1) == "24"
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import math

class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        n = len(s)
        per = n // math.gcd(n, b)
        m = 10 // math.gcd(10, a)

        def rotate_right(t: str, k: int) -> str:
            k %= n
            if k == 0:
                return t
            return t[-k:] + t[:-k]

        def build(t: str, add_odd: int, add_even: int) -> str:
            add_odd %= 10
            add_even %= 10
            arr = list(t)
            for i, ch in enumerate(arr):
                d = int(ch)
                if i % 2 == 1:
                    d = (d + add_odd) % 10
                else:
                    d = (d + add_even) % 10
                arr[i] = str(d)
            return "".join(arr)

        best = s
        for k in range(per):
            t = rotate_right(s, k * b)
            if b % 2 == 0:
                for x in range(m):
                    cand = build(t, x * a, 0)
                    if cand < best:
                        best = cand
            else:
                for x in range(m):
                    for y in range(m):
                        cand = build(t, x * a, y * a)
                        if cand < best:
                            best = cand
        return best

if __name__ == "__main__":
    sol = Solution()
    assert sol.findLexSmallestString("5525", 9, 2) == "2050"
    assert sol.findLexSmallestString("74", 5, 1) == "24"
    assert sol.findLexSmallestString("0011", 4, 2) == "0011"
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Enumerate canonical representatives using rotation and modulo-10 addition cycles; take the minimum string.}
\WHY{This pattern appears in problems where limited local transformations and periodicity enable full coverage without exhaustive graph traversal.}
\CHECKLIST{
\begin{bullets}
\item Compute $\gcd(n,b)$ and $\gcd(10,a)$ correctly.
\item Determine if $b$ is odd to allow affecting even indices.
\item Loop only distinct residues: $0,\ldots,10/\gcd(10,a)-1$.
\item Build candidates in $O(n)$ and track the minimum lexicographically.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $b$ even: even indices cannot be altered at all.
\item $a$ divisible by 10: add has no effect.
\item $b$ co-prime to $n$: rotation period equals $n$.
\item Repeated digits like \texttt{"0000"} or \texttt{"9999"}.
\item Minimal already at start: answer is \texttt{s}.
\item $n=2$: smallest nontrivial case with full parity mixing if $b=1$.
\item Large $n$ with small $b$: period shortens to $n/\gcd(n,b)$.
\item Leading zeros are allowed and often desirable.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Misinterpreting parity (odd indices are 1-based in the statement but 0-indexed in code: use indices $1,3,5,\ldots$).
\item Forgetting modulo 10 on each addition step.
\item Rotating left instead of right (ensure right rotation by $b$).
\item Not normalizing rotation by $b \bmod n$.
\item Over-iterating add counts beyond the true cycle $10/\gcd(10,a)$.
\item Building candidates with integer digits but forgetting to convert back to characters.
\item Comparing strings numerically instead of lexicographically (strings in Python compare lexicographically by default).
\item Mutating shared lists across iterations unintentionally.
\end{bullets}}
\FAILMODES{Pure greedy local changes can get stuck in nonminimal states; naive DFS without visited can loop forever. The periodic enumeration method avoids both issues and guarantees coverage.}
\ELI{Because additions and rotations repeat in predictable cycles, we can try every meaningful rotation and every meaningful amount of adding to the two parity groups, then pick the smallest result. This is much faster than exploring every possible sequence of operations.}
\NotePages{3}

\end{document}