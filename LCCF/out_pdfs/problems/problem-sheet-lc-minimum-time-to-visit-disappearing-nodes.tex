% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Time to Visit Disappearing Nodes}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-time-to-visit-disappearing-nodes/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{There is an undirected graph of \texttt{n} nodes. You are given a 2D array \texttt{edges}, where \texttt{edges[i] = [ui, vi, lengthi]} describes an edge between node \texttt{ui} and node \texttt{vi} with a traversal time of \texttt{lengthi} units.

Additionally, you are given an array \texttt{disappear}, where \texttt{disappear[i]} denotes the time when the node \texttt{i} disappears from the graph and you will not be able to visit it.

\textbf{Note} that the graph might be \textit{disconnected} and might contain \textit{multiple edges}.

Return the array \texttt{answer}, with \texttt{answer[i]} denoting the \textbf{minimum} units of time required to reach node \texttt{i} from node \texttt{0}. If node \texttt{i} is \textbf{unreachable} from node \texttt{0} then \texttt{answer[i]} is \texttt{-1}.

A node \texttt{v} can be visited at time \texttt{t} only if \texttt{t < disappear[v]}. Arriving exactly at its disappearance time does not count as a successful visit.

\textbf{Example 1:}

\textbf{Input:} \texttt{n = 3}, \texttt{edges = [[0,1,2],[1,2,1],[0,2,4]]}, \texttt{disappear = [1,1,5]}

\textbf{Output:} \texttt{[0,-1,4]}

\textbf{Explanation:}
We are starting our journey from node \texttt{0}, and our goal is to find the minimum time required to reach each node before it disappears.
\begin{itemize}
\item For node \texttt{0}, we do not need any time as it is our starting point.
\item For node \texttt{1}, we need at least \texttt{2} units of time to traverse \texttt{edges[0]}. Unfortunately, it disappears at that moment, so we will not be able to visit it.
\item For node \texttt{2}, we need at least \texttt{4} units of time to traverse \texttt{edges[2]}.
\end{itemize}

\textbf{Example 2:}

\textbf{Input:} \texttt{n = 3}, \texttt{edges = [[0,1,2],[1,2,1],[0,2,4]]}, \texttt{disappear = [1,3,5]}

\textbf{Output:} \texttt{[0,2,3]}

\textbf{Explanation:}
We are starting our journey from node \texttt{0}, and our goal is to find the minimum time required to reach each node before it disappears.
\begin{itemize}
\item For node \texttt{0}, we do not need any time as it is the starting point.
\item For node \texttt{1}, we need at least \texttt{2} units of time to traverse \texttt{edges[0]}.
\item For node \texttt{2}, we need at least \texttt{3} units of time to traverse \texttt{edges[0]} and \texttt{edges[1]}.
\end{itemize}

\textbf{Example 3:}

\textbf{Input:} \texttt{n = 2}, \texttt{edges = [[0,1,1]]}, \texttt{disappear = [1,1]}

\textbf{Output:} \texttt{[0,-1]}

\textbf{Explanation:}
Exactly when we reach node \texttt{1}, it disappears.

\textbf{Constraints:}
\begin{itemize}
\item $1 \le n \le 5 \times 10^4$
\item $0 \le \lvert \text{edges} \rvert \le 10^5$
\item $\text{edges}[i] = [u_i, v_i, \text{length}_i]$
\item $0 \le u_i, v_i \le n - 1$
\item $1 \le \text{length}_i \le 10^5$
\item $\lvert \text{disappear} \rvert = n$
\item $1 \le \text{disappear}[i] \le 10^5$
\end{itemize}}
\BREAKDOWN{Compute shortest path times from node $0$ under node deadlines. Traversal along an edge $(u,v,w)$ is valid only if arrival time at $u$ is $< \text{disappear}[u]$ and arrival time at $v$ after the edge is $< \text{disappear}[v]$.}
\ELI{Run Dijkstra, but never step into a node at or after its disappearance time; arrivals must be strictly earlier than the node's deadline.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n$; list \texttt{edges} of triples $[u,v,w]$ for an undirected weighted edge; list \texttt{disappear} of nonnegative integers as deadlines. Constraints as above.}
\OUTPUTS{Array \texttt{answer} of length $n$, where \texttt{answer[i]} is the minimum time to reach node $i$ from node $0$ with arrival time $< \texttt{disappear[i]}$; if unreachable or only reachable at time $\ge \texttt{disappear[i]}$, output \texttt{-1}.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{n=3}, \texttt{edges=[[0,1,2],[1,2,1],[0,2,4]]}, \texttt{disappear=[1,1,5]} $\Rightarrow$ Output: \texttt{[0,-1,4]}.
\item Input: \texttt{n=2}, \texttt{edges=[[0,1,1]]}, \texttt{disappear=[1,1]} $\Rightarrow$ Output: \texttt{[0,-1]}.
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be an undirected graph with $V=\{0,\ldots,n-1\}$ and positive edge weights $w:E\to\mathbb{R}_{>0}$. Each node $i$ has a deadline $D(i)=\text{disappear}[i]$. We seek minimum arrival times $d(i)$ from source $s=0$ such that if $d(i)<\infty$ then $d(i)<D(i)$ and for any edge $\{u,v\}$ of weight $w$, traversals must satisfy the deadlines along the path.}
\varmapStart
\var{G}{Undirected graph}
\var{w}{Positive edge weights}
\var{D(i)}{Deadline time when node $i$ disappears}
\var{d(i)}{Earliest feasible arrival time at node $i$}
\var{s}{Source node $0$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&d(s) = 
\begin{cases}
0,& 0 < D(s),\\
+\infty,& \text{otherwise,}
\end{cases}\\
&\text{For } \{u,v\}\in E \text{ with weight } w:\ \ 
\begin{cases}
\text{if } d(u) < D(u)\ \text{and } d(u)+w < D(v),\ \ d(v) \le d(u)+w,\\
\text{if } d(v) < D(v)\ \text{and } d(v)+w < D(u),\ \ d(u) \le d(v)+w.
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{All edge weights are positive; deadlines are integers but treated as real times. A visit is valid only if arrival time is strictly less than the node's deadline. Multiple edges and disconnected graphs are allowed.}
\INVARIANTS{
\begin{itemize}
\item Feasibility: Any maintained $d(i)$ always respects $d(i) < D(i)$.
\item Monotonicity: Improvements to $d(\cdot)$ are nonincreasing over iterations.
\item Optimal substructure: A shortest feasible path to $v$ is composed of shortest feasible paths to its predecessors.
\end{itemize}
}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Bellman–Ford style relaxation for $n-1$ rounds on an undirected graph, with feasibility checks against node deadlines during each relaxation.}
\ASSUMPTIONS{Positive weights ensure no negative cycles; however, Bellman–Ford does not rely on that and serves as a correctness baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $d(0)=0$ if $0 < \text{disappear}[0]$, else all nodes are unreachable and return all \texttt{-1}.
\item Repeat up to $n-1$ times: for each edge $(u,v,w)$, try to relax $v$ from $u$ if $d(u)<\text{disappear}[u]$ and $d(u)+w < \text{disappear}[v]$; similarly relax $u$ from $v$.
\item Early exit if no update occurs in an iteration. Output $d(i)$ where finite and $<\text{disappear}[i]$, else \texttt{-1}.
\end{algosteps}
\COMPLEXITY{Bellman–Ford runs $O(n)$ passes over $m$ edges.}
\[
\begin{aligned}
T(n,m) &= O(n\cdot m),\\
S(n,m) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Standard Bellman–Ford guarantees to find shortest paths in $n-1$ rounds when edge weights are nonnegative or even with negatives if no negative cycles. Adding the deadline predicates simply discards infeasible relaxations, preserving correctness among feasible paths.}
\EDGECASES{Source disappears at time $0$; a neighbor disappears exactly at arrival time; isolated nodes; multiple edges with different weights.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        # If source cannot be visited at t=0, nothing is reachable
        if disappear[0] <= 0:
            return [-1] * n

        INF = 10**20
        dist = [INF] * n
        dist[0] = 0

        # Bellman–Ford with feasibility checks
        for _ in range(n - 1):
            changed = False
            for u, v, w in edges:
                du = dist[u]
                dv = dist[v]
                # relax v via u
                if du < disappear[u]:
                    cand = du + w
                    if cand < disappear[v] and cand < dv:
                        dist[v] = cand
                        changed = True
                # relax u via v
                if dv < disappear[v]:
                    cand = dv + w
                    if cand < disappear[u] and cand < du:
                        dist[u] = cand
                        changed = True
            if not changed:
                break

        # Finalize: only times strictly before disappearance are valid
        res = []
        for i, d in enumerate(dist):
            if d < disappear[i] and d < INF:
                res.append(d)
            else:
                res.append(-1)
        return res

# basic asserts (examples)
sol = Solution()
assert sol.minimumTime(3, [[0,1,2],[1,2,1],[0,2,4]], [1,1,5]) == [0,-1,4]
assert sol.minimumTime(3, [[0,1,2],[1,2,1],[0,2,4]], [1,3,5]) == [0,2,3]
assert sol.minimumTime(2, [[0,1,1]], [1,1]) == [0,-1]
\end{minted}
\VALIDATION{Validated on the three examples. Also try a disconnected graph and a graph where a node has a very tight deadline to ensure strict inequality is enforced.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Dijkstra with a binary heap. Positive weights imply the greedy selection of the next closest feasible node yields optimal feasible arrival times.}
\ASSUMPTIONS{All edge weights are positive; deadlines are enforced during expansions and relaxations; skip expanding nodes that have already disappeared at their popped time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $\text{disappear}[0] \le 0$, return all \texttt{-1}.
\item Build adjacency lists for the undirected graph.
\item Run Dijkstra: pop $(d,u)$. If $d \ne \text{dist}[u]$ continue; if $d \ge \text{disappear}[u]$ skip expansion. For each $(v,w)$, let $nd=d+w$; if $nd < \text{disappear}[v]$ and $nd < \text{dist}[v]$, relax.
\item Emit $\text{dist}[i]$ where finite and $< \text{disappear}[i]$, else \texttt{-1}.
\end{algosteps}
\COMPLEXITY{The heap-based method improves to near-linear time in $m$ with a logarithmic factor.}
\[
\begin{aligned}
T(n,m) &= O\big((n+m)\log n\big),\\
S(n,m) &= O(n+m).
\end{aligned}
\]
\CORRECTNESS{By nonnegative weights, Dijkstra's invariant holds: when a node $u$ is popped with minimal tentative distance, no shorter feasible path to $u$ exists. Deadline checks only remove infeasible relaxations; they do not invalidate the greedy choice among feasible paths.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        if disappear[0] <= 0:
            return [-1] * n

        g: List[List[Tuple[int, int]]] = [[] for _ in range(n)]
        for u, v, w in edges:
            g[u].append((v, w))
            g[v].append((u, w))

        INF = 10**20
        dist = [INF] * n
        dist[0] = 0
        pq: List[Tuple[int, int]] = [(0, 0)]

        while pq:
            d, u = heapq.heappop(pq)
            if d != dist[u]:
                continue
            if d >= disappear[u]:
                # Reaching u at or after its disappearance is useless; do not expand
                continue
            for v, w in g[u]:
                nd = d + w
                if nd < disappear[v] and nd < dist[v]:
                    dist[v] = nd
                    heapq.heappush(pq, (nd, v))

        res = []
        for i, d in enumerate(dist):
            res.append(d if d < disappear[i] and d < INF else -1)
        return res

# basic asserts (examples)
sol = Solution()
assert sol.minimumTime(3, [[0,1,2],[1,2,1],[0,2,4]], [1,1,5]) == [0,-1,4]
assert sol.minimumTime(3, [[0,1,2],[1,2,1],[0,2,4]], [1,3,5]) == [0,2,3]
assert sol.minimumTime(2, [[0,1,1]], [1,1]) == [0,-1]
\end{minted}
\VALIDATION{Checked on the given examples; also verify that when \texttt{disappear[0]} is \texttt{0}, all answers are \texttt{-1}.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Dijkstra with strict-deadline relaxations and pop-time pruning is optimal for graphs with positive weights.}
\ASSUMPTIONS{Positive edge weights; feasibility requires strict inequality relative to deadlines; graph may be disconnected and have multi-edges.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $\text{dist}[0]=0$ if $0<\text{disappear}[0]$, otherwise return all \texttt{-1}.
\item Use a min-heap; when popping $(d,u)$, if $d\ge \text{disappear}[u]$, skip expanding $u$.
\item For each neighbor $v$ with weight $w$, relax only if $d+w<\text{disappear}[v]$ and $d+w<\text{dist}[v]$.
\end{algosteps}
\OPTIMALITY{Dijkstra is optimal for nonnegative weights; any feasible path has nondecreasing arrival times along edges, and the deadline filter only discards paths that could never be valid answers. Thus, the method attains the best possible time complexity for comparison-based SSSP with heaps.}
\COMPLEXITY{Same as Approach B.}
\[
\begin{aligned}
T(n,m) &= O\big((n+m)\log n\big),\quad S(n,m)=O(n+m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        # If the source is gone at t=0, nothing is reachable.
        if disappear[0] <= 0:
            return [-1] * n

        # Build adjacency list
        g: List[List[Tuple[int, int]]] = [[] for _ in range(n)]
        for u, v, w in edges:
            g[u].append((v, w))
            g[v].append((u, w))

        INF = 10**20
        dist = [INF] * n
        dist[0] = 0
        pq: List[Tuple[int, int]] = [(0, 0)]  # (time, node)

        while pq:
            t, u = heapq.heappop(pq)
            if t != dist[u]:
                continue
            # Cannot stand on or arrive at u at or after its disappearance
            if t >= disappear[u]:
                continue
            for v, w in g[u]:
                nt = t + w
                if nt < disappear[v] and nt < dist[v]:
                    dist[v] = nt
                    heapq.heappush(pq, (nt, v))

        # Prepare result
        ans = [d if d < disappear[i] and d < INF else -1 for i, d in enumerate(dist)]
        return ans

# Exact 3 asserts (problem examples)
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumTime(3, [[0,1,2],[1,2,1],[0,2,4]], [1,1,5]) == [0,-1,4]
    assert sol.minimumTime(3, [[0,1,2],[1,2,1],[0,2,4]], [1,3,5]) == [0,2,3]
    assert sol.minimumTime(2, [[0,1,1]], [1,1]) == [0,-1]
\end{minted}
\VALIDATION{Three asserts reproduce the provided examples exactly.}
\RESULT{For each node $i$, the output is the minimum feasible arrival time from node $0$, requiring strict arrival before $\text{disappear}[i]$; otherwise output \texttt{-1}. Ties are irrelevant because times are unique minima under nonnegative weights.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Use the three official examples; add corner cases: source disappears at time $0$; isolated nodes; multiple parallel edges favoring the cheaper one; tight deadlines that invalidate late relaxations.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C on tiny graphs to ensure identical outputs; ensure that strict inequality on deadlines yields \texttt{-1} when arrival equals the deadline.}
\LINE{EDGE-CASE GENERATOR}{Generate random small graphs with random deadlines, then brute force all simple paths up to a small length to cross-validate Dijkstra outputs.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random
import heapq

def gen_graph(n: int, m: int, maxw: int = 10, seed: int = 0) -> Tuple[int, List[List[int]], List[int]]:
    random.seed(seed)
    edges: List[List[int]] = []
    for _ in range(m):
        u = random.randrange(n)
        v = random.randrange(n)
        while v == u:
            v = random.randrange(n)
        w = random.randint(1, maxw)
        edges.append([u, v, w])
    disappear = [random.randint(1, maxw * n) for _ in range(n)]
    return n, edges, disappear

class RefDijkstra:
    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        if disappear[0] <= 0:
            return [-1] * n
        g = [[] for _ in range(n)]
        for u, v, w in edges:
            g[u].append((v, w))
            g[v].append((u, w))
        INF = 10**18
        dist = [INF] * n
        dist[0] = 0
        pq = [(0, 0)]
        while pq:
            d, u = heapq.heappop(pq)
            if d != dist[u]:
                continue
            if d >= disappear[u]:
                continue
            for v, w in g[u]:
                nd = d + w
                if nd < disappear[v] and nd < dist[v]:
                    dist[v] = nd
                    heapq.heappush(pq, (nd, v))
        return [d if d < disappear[i] and d < INF else -1 for i, d in enumerate(dist)]

def cross_check():
    for seed in range(5):
        n, edges, disappear = gen_graph(6, 10, maxw=7, seed=seed)
        ans = RefDijkstra().minimumTime(n, edges, disappear)
        # Cross-check with itself for determinism and stability
        ans2 = RefDijkstra().minimumTime(n, edges, disappear)
        assert ans == ans2

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        # If the source vanishes at t=0, nothing can be visited.
        if disappear[0] <= 0:
            return [-1] * n

        # Build adjacency list for undirected graph
        g: List[List[Tuple[int, int]]] = [[] for _ in range(n)]
        for u, v, w in edges:
            g[u].append((v, w))
            g[v].append((u, w))

        INF = 10**20
        dist = [INF] * n
        dist[0] = 0
        pq: List[Tuple[int, int]] = [(0, 0)]  # (time, node)

        while pq:
            t, u = heapq.heappop(pq)
            if t != dist[u]:
                continue
            # Cannot stand at u at or after its disappearance
            if t >= disappear[u]:
                continue
            for v, w in g[u]:
                nt = t + w
                if nt < disappear[v] and nt < dist[v]:
                    dist[v] = nt
                    heapq.heappush(pq, (nt, v))

        return [d if d < disappear[i] and d < INF else -1 for i, d in enumerate(dist)]

# Simple sanity checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumTime(3, [[0,1,2],[1,2,1],[0,2,4]], [1,1,5]) == [0,-1,4]
    assert sol.minimumTime(3, [[0,1,2],[1,2,1],[0,2,4]], [1,3,5]) == [0,2,3]
    assert sol.minimumTime(2, [[0,1,1]], [1,1]) == [0,-1]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Shortest paths with node deadlines: Dijkstra with strict arrival-time feasibility checks.}
\WHY{Variants of shortest paths with constraints (time windows/deadlines) are common in interviews to test adaptation of classical algorithms.}
\CHECKLIST{
\begin{itemize}
\item Build adjacency for undirected graph.
\item Initialize source only if its deadline is strictly after $0$.
\item Pop from heap; discard outdated entries.
\item Skip expanding nodes popped at or after their deadline.
\item Relax neighbor only if new time is strictly less than neighbor deadline.
\item Final answers must still satisfy strict deadline.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item $\text{disappear}[0]=0$ $\Rightarrow$ all \texttt{-1}.
\item Arrival exactly equals a node deadline $\Rightarrow$ infeasible.
\item Isolated nodes remain \texttt{-1}.
\item Multiple edges: ensure the cheaper one is used.
\item Very tight deadlines that block intermediate hubs.
\item Large $n,m$: ensure $O((n+m)\log n)$ complexity.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Using $\le$ instead of $<$ for deadlines.
\item Expanding a node even when popped time $\ge$ its deadline.
\item Forgetting undirected symmetry while building edges.
\item Not guarding against stale heap entries.
\item Post-processing that forgets to re-validate deadlines.
\item Treating source as reachable when it disappears at $t=0$.
\end{itemize}
}
\FAILMODES{Bellman–Ford times out at large sizes; plain Dijkstra without deadline checks may erroneously accept arrivals at or after deadlines; BFS is incorrect due to weights. The presented Dijkstra survives all such inputs.}
\ELI{Think of each node having a closing time; you can only enter before it closes. Run standard shortest path but never step into a node after it closes and you will get the minimum valid times.}
\NotePages{3}

\end{document}