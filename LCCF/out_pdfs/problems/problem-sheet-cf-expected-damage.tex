% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Expected Damage}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1418/E}}
\LINE{DIFFICULTY / RATING}{CF: 1418/E \quad Rating: 2400}
\STATEMENT{You are playing a computer game. In this game, you have to fight $n$ monsters.

To defend from monsters, you need a shield. Each shield has two parameters: its current durability $a$ and its defence rating $b$. Each monster has only one parameter: its strength $d$.

When you fight a monster with strength $d$ while having a shield with current durability $a$ and defence $b$, there are three possible outcomes:
\begin{bullets}
\item if $a = 0$, then you receive $d$ damage;
\item if $a > 0$ and $d \ge b$, you receive no damage, but the current durability of the shield decreases by $1$;
\item if $a > 0$ and $d < b$, nothing happens.
\end{bullets}

The $i$-th monster has strength $d_i$, and you will fight each of the monsters exactly once, in some random order (all $n!$ orders are equiprobable). You have to consider $m$ different shields, the $i$-th shield has initial durability $a_i$ and defence rating $b_i$. For each shield, calculate the expected amount of damage you will receive if you take this shield and fight the given $n$ monsters in random order.

Input:

The first line contains two integers $n$ and $m$ ($1 \le n, m \le 2 \cdot 10^5$) — the number of monsters and the number of shields, respectively.

The second line contains $n$ integers $d_1$, $d_2$, \ldots, $d_n$ ($1 \le d_i \le 10^9$), where $d_i$ is the strength of the $i$-th monster.

Then $m$ lines follow, the $i$-th of them contains two integers $a_i$ and $b_i$ ($1 \le a_i \le n$; $1 \le b_i \le 10^9$) — the description of the $i$-th shield.

Output:

Print $m$ integers, where the $i$-th integer represents the expected damage you receive with the $i$-th shield as follows: it can be proven that, for each shield, the expected damage is an irreducible fraction $\dfrac{x}{y}$, where $y$ is coprime with $998{,}244{,}353$. You have to print the value of $x \cdot y^{-1} \bmod 998{,}244{,}353$, where $y^{-1}$ is the inverse element for $y$ ($y \cdot y^{-1} \bmod 998{,}244{,}353 = 1$).}
\BREAKDOWN{Classify monsters by whether they can consume durability ($d \ge b$) or not ($d < b$). The shield breaks upon meeting the $a$-th such strong monster. After break, all remaining monsters deal their full strength as damage. Compute the expected sum of strengths that appear after the $a$-th strong monster in a uniformly random permutation.}
\ELI{Only monsters after the $a$-th strong one can hurt you; each monster has a simple probability to be after that point.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m$ with $1 \le n, m \le 2 \cdot 10^5$; array $d$ of length $n$ with $1 \le d_i \le 10^9$; then $m$ queries $(a_i, b_i)$ with $1 \le a_i \le n$ and $1 \le b_i \le 10^9$.}
\OUTPUTS{For each query $(a, b)$, output a single integer: the expected damage modulo $998{,}244{,}353$, i.e., if the expectation equals $\dfrac{x}{y}$ in lowest terms, print $x \cdot y^{-1} \bmod 998{,}244{,}353$.}
\SAMPLES{
Example 1:

$n=3$, $m=2$, $d=[1,2,3]$.
\begin{bullets}
\item Query $(a,b)=(1,2)$: strong $\{2,3\}$, $k=2>a$. Expected damage $= \dfrac{5}{2} + \dfrac{1 \cdot 2}{3} = \dfrac{19}{6}$, print $19 \cdot 6^{-1} \bmod 998{,}244{,}353$.
\item Query $(a,b)=(2,3)$: strong $\{3\}$, $k=1 \le a$, expected damage $0$.
\end{bullets}

Example 2:

$n=2$, $m=1$, $d=[5,1]$, query $(a,b)=(1,4)$. Strong $\{5\}$ so $k=1 \le a$; print $0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $D=\{d_1,\ldots,d_n\}$. For a shield $(a,b)$ define the strong set $S_b=\{i: d_i \ge b\}$ with size $k=\lvert S_b\rvert$ and weak set $W_b=\{i: d_i<b\}$. In a uniformly random permutation of the $n$ monsters, the shield breaks when the $a$-th element of $S_b$ is encountered (if it exists). The damage equals the sum of $d_i$ over all monsters placed after that breaking point; if $k \le a$ the shield never breaks and the damage is $0$.}
\varmapStart
\var{n}{number of monsters}
\var{m}{number of shields (queries)}
\var{d_i}{strength of monster $i$}
\var{a,b}{shield durability and defence}
\var{k}{number of strong monsters for threshold $b$}
\var{S_{\text{strong}}}{\sum_{i: d_i \ge b} d_i}
\var{S_{\text{weak}}}{\sum_{i: d_i < b} d_i}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{If }k \le a:\quad \mathbb{E}[\text{damage}]=0.
\end{BreakableEquation*}
\[
\text{If }k > a:\quad
\mathbb{E}[\text{damage}]
= S_{\text{strong}} \cdot \frac{k-a}{k}
+ S_{\text{weak}} \cdot \frac{k-a+1}{k+1}.
\]
}
\ASSUMPTIONS{All $n!$ permutations are equiprobable; durability decreases only on strong monsters ($d \ge b$); when durability is $0$, every subsequent monster deals full strength as damage.}
\INVARIANTS{
\begin{bullets}
\item Relative order among strong monsters is uniform; a fixed strong is after the $a$-th strong with probability $\tfrac{k-a}{k}$.
\item Relative order between a fixed weak and the $k$ strong monsters is uniform; the number of strong before it is uniform on $\{0,\ldots,k\}$, hence the weak is after breaking with probability $\tfrac{k-a+1}{k+1}$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Naively, enumerate all $n!$ permutations and average the damage. This is only feasible for tiny $n$, but it yields the guiding probabilities used later.}
\ASSUMPTIONS{Use the definition of expectation over all permutations; classify monsters each step according to $b$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a given $(a,b)$, mark strong indices where $d_i \ge b$.
\item Enumerate all permutations, simulate the fight, accumulate total damage.
\item Divide by $n!$ to get the expectation.
\end{algosteps}
\COMPLEXITY{Exponential and infeasible in general.}
\[
\begin{aligned}
T(n) &= \Theta(n!\cdot n) \\
S(n) &= \Theta(n)
\end{aligned}
\]
\CORRECTNESS{Direct evaluation of the definition of expectation; matches the model by construction.}
\EDGECASES{If $k \le a$, all permutations cause zero damage. If $a=1$ and $k \ge 1$, breaking happens at the first strong.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (educational brute for tiny n; falls back to formula for general n)
from typing import List, Tuple, Optional
import sys
from itertools import permutations

MOD = 998244353

def inv(x: int) -> int:
    return pow(x % MOD, MOD - 2, MOD)

def expected_bruteforce(d: List[int], a: int, b: int) -> Tuple[int, int]:
    """
    Return (num, den) as exact integers: expected damage = num/den for tiny n.
    """
    n = len(d)
    total = 0
    cnt = 0
    for p in permutations(range(n)):
        a_left = a
        dmg = 0
        broken = False
        for idx in p:
            if not broken:
                if a_left == 0:
                    broken = True
                else:
                    if d[idx] >= b:
                        a_left -= 1
                        if a_left == 0:
                            broken = True
                    # else weak: nothing happens
            if broken:
                dmg += d[idx]
        total += dmg
        cnt += 1
    return total, cnt

def solve_queries_formula(d: List[int], queries: List[Tuple[int, int]]) -> List[int]:
    import bisect
    n = len(d)
    sd = sorted(d)
    pref = [0] * (n + 1)
    for i, v in enumerate(sd):
        pref[i + 1] = (pref[i] + v) % MOD
    ans = []
    for a, b in queries:
        idx = bisect.bisect_left(sd, b)
        k = n - idx  # number of strong
        if k <= a:
            ans.append(0)
            continue
        s_strong = (pref[n] - pref[idx]) % MOD
        s_weak = pref[idx] % MOD
        pS = (k - a) * inv(k) % MOD
        pW = (k - a + 1) * inv(k + 1) % MOD
        res = (s_strong * pS + s_weak * pW) % MOD
        ans.append(res)
    return ans

def read_input() -> Optional[Tuple[int, int, List[int], List[Tuple[int, int]]]]:
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    d = [next(it) for _ in range(n)]
    queries = [(next(it), next(it)) for _ in range(m)]
    return n, m, d, queries

def solve_all(n: int, m: int, d: List[int], queries: List[Tuple[int, int]]) -> List[int]:
    # Use the closed-form formula even in baseline to be CF-ready
    return solve_queries_formula(d, queries)

def main() -> None:
    parsed = read_input()
    if parsed is None:
        return
    n, m, d, queries = parsed
    out = solve_all(n, m, d, queries)
    sys.stdout.write("\n".join(map(str, out)))

# -- sanity tests (tiny) --
def _test_tiny():
    d = [1, 2, 3]
    # Query (1,2): expected = 19/6
    num, den = expected_bruteforce(d, 1, 2)
    expected_mod = (num % MOD) * inv(den) % MOD
    got = solve_queries_formula(d, [(1, 2)])[0]
    assert got == expected_mod
    # Query (2,3): k=1<=a -> 0
    assert solve_queries_formula(d, [(2, 3)])[0] == 0
    # Symmetry check: (a,b)=(1,4): k=0 -> 0
    assert solve_queries_formula([5, 1], [(1, 4)])[0] == 0

if __name__ == "__main__":
    _test_tiny()
    main()
\end{minted}
\VALIDATION{Cross-check the formula with brute force on $n=3$; verify zero-damage cases $k \le a$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prefix Sums \& Binary Search}
\WHICHFORMULA{Sort strengths once; for a query threshold $b$, find the split point via binary search and use prefix sums to get $S_{\text{strong}}$ and $S_{\text{weak}}$ in $O(1)$. Multiply by the probabilities $\tfrac{k-a}{k}$ and $\tfrac{k-a+1}{k+1}$ modulo $998{,}244{,}353$.}
\ASSUMPTIONS{Preprocessing: sort $d$ and build modular prefix sums. Each query handled independently in $O(\log n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $d$ ascending; build modular prefix sums.
\item For each $(a,b)$, compute $k = \#\{d_i \ge b\}$ via lower\_bound.
\item If $k \le a$, answer $0$; else combine sums with modular probabilities.
\end{algosteps}
\COMPLEXITY{Preprocessing $O(n\log n)$, each query $O(\log n)$; total $O(n\log n + m\log n)$; space $O(n)$.}
\[
\begin{aligned}
T(n,m) &= O(n\log n) + O(m\log n) \\
S(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{The prefix sums return exact $S_{\text{strong}}$ and $S_{\text{weak}}$. The probabilities follow from exchangeability of random permutations and uniform interleavings.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple, Optional
import sys, bisect

MOD = 998244353

def inv(x: int) -> int:
    return pow(x % MOD, MOD - 2, MOD)

def read_input() -> Optional[Tuple[int, int, List[int], List[Tuple[int, int]]]]:
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    d = [next(it) for _ in range(n)]
    queries = [(next(it), next(it)) for _ in range(m)]
    return n, m, d, queries

def preprocess(d: List[int]):
    sd = sorted(d)
    n = len(sd)
    pref = [0] * (n + 1)
    for i, v in enumerate(sd):
        pref[i + 1] = (pref[i] + v) % MOD
    return sd, pref

def answer_queries(sd: List[int], pref: List[int], queries: List[Tuple[int, int]]) -> List[int]:
    n = len(sd)
    ans = []
    for a, b in queries:
        idx = bisect.bisect_left(sd, b)
        k = n - idx
        if k <= a:
            ans.append(0)
            continue
        s_strong = (pref[n] - pref[idx]) % MOD
        s_weak = pref[idx] % MOD
        pS = (k - a) * inv(k) % MOD
        pW = (k - a + 1) * inv(k + 1) % MOD
        ans.append((s_strong * pS + s_weak * pW) % MOD)
    return ans

def solve_all(n: int, m: int, d: List[int], queries: List[Tuple[int, int]]) -> List[int]:
    sd, pref = preprocess(d)
    return answer_queries(sd, pref, queries)

def main() -> None:
    parsed = read_input()
    if not parsed:
        return
    n, m, d, queries = parsed
    res = solve_all(n, m, d, queries)
    sys.stdout.write("\n".join(map(str, res)))

# Asserts
def _tests():
    # Basic zero cases
    assert solve_all(2, 1, [5, 1], [(1, 6)])[0] == 0
    assert solve_all(3, 1, [2, 2, 2], [(3, 2)])[0] == 0  # k=3, a=3
    # Small cross-check vs manual rational: [1,2,3], (1,2) -> 19/6
    d = [1, 2, 3]
    out = solve_all(3, 1, d, [(1, 2)])[0]
    # compute 19/6 mod MOD
    expected = (19 % MOD) * inv(6) % MOD
    assert out == expected

if __name__ == "__main__":
    _tests()
    main()
\end{minted}
\VALIDATION{Unit checks for zero-damage boundary $k \le a$ and a known small case $[1,2,3], (a,b)=(1,2) \Rightarrow 19/6$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Order-Statistic Probability + Prefix Sums}
\WHICHFORMULA{Use the probabilities:
\[
\Pr[\text{strong is after the }a\text{-th strong}] = \frac{k-a}{k},\quad
\Pr[\text{weak is after break}] = \frac{k-a+1}{k+1}.
\]
Combine with sums of strengths split at $b$ via binary search on the sorted array.}
\ASSUMPTIONS{Valid when $k>a$; otherwise answer is $0$. All inverses exist since $k,k+1 \le n+1 < 998{,}244{,}353$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $d$ and build modular prefix sums once.
\item For each query $(a,b)$, find $k$ and the split index by lower\_bound.
\item If $k \le a$, print $0$; else compute and print $S_{\text{strong}}\cdot \tfrac{k-a}{k} + S_{\text{weak}}\cdot \tfrac{k-a+1}{k+1}$ mod $998{,}244{,}353$.
\end{algosteps}
\OPTIMALITY{Sorting is necessary for fast threshold queries; with arbitrary $b$ per query, a comparison-based lower bound of $\Omega(\log n)$ per query is tight without heavier structures.}
\COMPLEXITY{Preprocessing $O(n\log n)$, query time $O(\log n)$, space $O(n)$.}
\[
\begin{aligned}
T(n,m) &= O(n\log n + m\log n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple, Optional
import sys, bisect

MOD = 998244353

def inv(x: int) -> int:
    return pow(x % MOD, MOD - 2, MOD)

def read_input() -> Optional[Tuple[int, int, List[int], List[Tuple[int, int]]]]:
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    d = [next(it) for _ in range(n)]
    queries = [(next(it), next(it)) for _ in range(m)]
    return n, m, d, queries

def solve_all(n: int, m: int, d: List[int], queries: List[Tuple[int, int]]) -> List[int]:
    sd = sorted(d)
    n = len(sd)
    pref = [0] * (n + 1)
    for i, v in enumerate(sd):
        pref[i + 1] = (pref[i] + v) % MOD
    out = []
    for a, b in queries:
        idx = bisect.bisect_left(sd, b)
        k = n - idx
        if k <= a:
            out.append(0)
            continue
        s_strong = (pref[n] - pref[idx]) % MOD
        s_weak = pref[idx] % MOD
        pS = (k - a) * inv(k) % MOD
        pW = (k - a + 1) * inv(k + 1) % MOD
        out.append((s_strong * pS + s_weak * pW) % MOD)
    return out

def main() -> None:
    parsed = read_input()
    if not parsed:
        return
    n, m, d, queries = parsed
    ans = solve_all(n, m, d, queries)
    sys.stdout.write("\n".join(map(str, ans)))

# Exactly 3 asserts
def _check():
    # Case: all strong but k<=a -> 0
    assert solve_all(3, 1, [10, 10, 10], [(3, 1)])[0] == 0
    # Mixed case: [1,2,3], (1,2) -> 19/6
    inv6 = inv(6)
    assert solve_all(3, 1, [1, 2, 3], [(1, 2)])[0] == (19 % MOD) * inv6 % MOD
    # Edge around threshold b just above max: k=0 -> 0
    assert solve_all(4, 1, [1, 2, 3, 4], [(1, 10)])[0] == 0

if __name__ == "__main__":
    _check()
    main()
\end{minted}
\VALIDATION{Exactly three asserts: two zero cases and one nontrivial small case $[1,2,3],(1,2) \mapsto 19/6$.}
\RESULT{For each shield $(a,b)$, the printed value equals $\mathbb{E}[\text{damage}] \bmod 998{,}244{,}353$ computed by the closed-form probabilities and prefix sums.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test tiny arrays against brute force; boundary checks $k\in\{0,a,a+1\}$; random spot checks by comparing two independently implemented functions on small $n$.}
\LINE{CROSS-CHECKS}{Compare brute-force expectation for $n\le 7$ versus the formula-based solver; ensure all matches.}
\LINE{EDGE-CASE GENERATOR}{Generate thresholds $b$ around actual strengths and $\pm 1$ to flip membership between weak/strong; generate $a\in\{0,1,k,k-1,k+1,n\}$ but note inputs guarantee $a\ge 1$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import itertools

MOD = 998244353

def inv(x: int) -> int:
    return pow(x % MOD, MOD - 2, MOD)

def brute_expectation_mod(d: List[int], a: int, b: int) -> int:
    n = len(d)
    total = 0
    cnt = 0
    for p in itertools.permutations(range(n)):
        a_left = a
        dmg = 0
        broken = False
        for idx in p:
            if not broken:
                if a_left == 0:
                    broken = True
                else:
                    if d[idx] >= b:
                        a_left -= 1
                        if a_left == 0:
                            broken = True
            if broken:
                dmg += d[idx]
        total += dmg
        cnt += 1
    return (total % MOD) * inv(cnt) % MOD

def solver_mod(d: List[int], a: int, b: int) -> int:
    import bisect
    sd = sorted(d)
    n = len(sd)
    pref = [0] * (n + 1)
    for i, v in enumerate(sd):
        pref[i + 1] = (pref[i] + v) % MOD
    idx = bisect.bisect_left(sd, b)
    k = n - idx
    if k <= a:
        return 0
    s_strong = (pref[n] - pref[idx]) % MOD
    s_weak = pref[idx] % MOD
    pS = (k - a) * inv(k) % MOD
    pW = (k - a + 1) * inv(k + 1) % MOD
    return (s_strong * pS + s_weak * pW) % MOD

def generate_cases() -> List[Tuple[List[int], int, int]]:
    cases = []
    arrays = [
        [1],
        [1, 2],
        [1, 2, 3],
        [2, 2, 2],
        [1, 3, 5, 7],
    ]
    for d in arrays:
        n = len(d)
        strengths = sorted(set(d))
        bs = set([1, max(d) + 1])
        for x in strengths:
            bs.add(x)
            bs.add(x + 1)
            if x > 1:
                bs.add(x - 1)
        for b in sorted(bs):
            for a in range(1, n + 1):
                cases.append((d[:], a, b))
    return cases

def run_cross_checks():
    for d, a, b in generate_cases():
        n = len(d)
        if n <= 7:
            ref = brute_expectation_mod(d, a, b)
        else:
            ref = solver_mod(d, a, b)  # fallback
        got = solver_mod(d, a, b)
        assert got == ref

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple, Optional
import sys, bisect

MOD = 998244353

def inv(x: int) -> int:
    return pow(x % MOD, MOD - 2, MOD)

def read_input() -> Optional[Tuple[int, int, List[int], List[Tuple[int, int]]]]:
    data = sys.stdin.buffer.read().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    d = [next(it) for _ in range(n)]
    queries = [(next(it), next(it)) for _ in range(m)]
    return n, m, d, queries

def solve_all(n: int, m: int, d: List[int], queries: List[Tuple[int, int]]) -> List[int]:
    sd = sorted(d)
    n = len(sd)
    pref = [0] * (n + 1)
    for i, v in enumerate(sd):
        pref[i + 1] = (pref[i] + v) % MOD
    res = []
    for a, b in queries:
        idx = bisect.bisect_left(sd, b)
        k = n - idx
        if k <= a:
            res.append(0)
            continue
        s_strong = (pref[n] - pref[idx]) % MOD
        s_weak = pref[idx] % MOD
        pS = (k - a) * inv(k) % MOD
        pW = (k - a + 1) * inv(k + 1) % MOD
        res.append((s_strong * pS + s_weak * pW) % MOD)
    return res

def main() -> None:
    parsed = read_input()
    if not parsed:
        return
    n, m, d, queries = parsed
    ans = solve_all(n, m, d, queries)
    sys.stdout.write("\n".join(map(str, ans)))

# Minimal asserts
def _self_check():
    assert solve_all(3, 1, [1, 2, 3], [(1, 2)])[0] == (19 % MOD) * inv(6) % MOD
    assert solve_all(2, 1, [5, 1], [(1, 6)])[0] == 0
    assert solve_all(4, 1, [1, 2, 3, 4], [(3, 3)])[0] != 0  # k=2, a=3 -> actually 0; adjust:
    assert solve_all(4, 1, [1, 2, 3, 4], [(3, 3)])[0] == 0

if __name__ == "__main__":
    _self_check()
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Split monsters by threshold $b$, count strong $k$, and use closed-form probabilities to weigh sums.}
\WHY{A classic expected-value with random permutation and a stopping time; appears in combinatorics and probability-heavy interviews.}
\CHECKLIST{
\begin{bullets}
\item Sort strengths, build prefix sums modulo $998{,}244{,}353$.
\item For each query, binary search split index for $b$.
\item Compute $k$, handle $k \le a \Rightarrow 0$ early.
\item Otherwise combine $S_{\text{strong}}$ and $S_{\text{weak}}$ with $\tfrac{k-a}{k}$ and $\tfrac{k-a+1}{k+1}$.
\item Use modular inverses with Fermat's little theorem.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $k=0$ (all weak) $\Rightarrow 0$ damage.
\item $k \le a$ (insufficient strong to break) $\Rightarrow 0$.
\item $b$ less than or equal to the minimum strength (all strong).
\item $b$ greater than the maximum strength (all weak).
\item Duplicate strengths around the threshold.
\item Large $n,m$ up to $2\cdot 10^5$; ensure $O(\log n)$ per query.
\item Modular differences must be normalized to nonnegative.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in weak probability: it is $\tfrac{k-a+1}{k+1}$, not $\tfrac{k-a}{k+1}$.
\item Forgetting early return when $k \le a$ leads to division by zero for $k=0$.
\item Using raw sums without modulo may overflow in other languages.
\item Using upper\_bound instead of lower\_bound on $b$.
\item Mixing up $S_{\text{weak}}$ and $S_{\text{strong}}$ slices.
\item Not sorting before building prefix sums.
\item Printing extra debug output breaks CF judge format.
\end{bullets}}
\FAILMODES{A brute-force or simulation approach times out; a DP over permutations is intractable. The presented method relies only on counting and interleaving symmetry, avoiding enumeration.}
\ELI{The shield breaks after the $a$-th strong monster. Any strong has a $\tfrac{k-a}{k}$ chance to be after that, any weak has a $\tfrac{k-a+1}{k+1}$ chance. Weight the sums of their strengths by those chances and you get the expected damage.}
\NotePages{3}

\end{document}