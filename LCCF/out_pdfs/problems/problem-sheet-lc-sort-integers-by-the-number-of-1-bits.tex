% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Sort Integers by The Number of 1 Bits}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given an integer array \texttt{arr}. Sort the integers in the array in ascending order by the number of \texttt{1}'s in their binary representation and, in case two or more integers have the same number of \texttt{1}'s, sort them in ascending order by value. Return \emph{the array after sorting it}.

\textbf{Example 1:}
Input: \texttt{arr = [0,1,2,3,4,5,6,7,8]}
Output: \texttt{[0,1,2,4,8,3,5,6,7]}
Explanation: \texttt{[0]} is the only integer with 0 bits. \texttt{[1,2,4,8]} all have 1 bit. \texttt{[3,5,6]} have 2 bits. \texttt{[7]} has 3 bits. The sorted array by bits is \texttt{[0,1,2,4,8,3,5,6,7]}.

\textbf{Example 2:}
Input: \texttt{arr = [1024,512,256,128,64,32,16,8,4,2,1]}
Output: \texttt{[1,2,4,8,16,32,64,128,256,512,1024]}
Explanation: All integers have 1 bit in the binary representation; you should just sort them in ascending order.

\textbf{Constraints:}
\begin{itemize}
\item $1 \le \texttt{arr.length} \le 500$
\item $0 \le \texttt{arr[i]} \le 10^4$
\end{itemize}}
\BREAKDOWN{Compute a stable ordering key for each integer: the pair (number of 1-bits in binary, value). Then sort by this key.}
\ELI{Count the 1s in each number's binary form and sort by that count, breaking ties by the number itself.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer list \texttt{arr} with length between 1 and 500 inclusive, where each element is an integer in $[0,10^4]$.}
\OUTPUTS{Return a new list with the same integers, sorted by increasing popcount (number of 1 bits), with ties broken by numeric value ascending.}
\SAMPLES{\textbf{Sample A}
Input: \texttt{arr = [0,1,2,3,4,5,6,7,8]}
Output: \texttt{[0,1,2,4,8,3,5,6,7]}

\textbf{Sample B}
Input: \texttt{arr = [2,3,5,7,11]}
Binary 1-bits: \texttt{[1,2,2,3,3]} so result is \texttt{[2,3,5,11,7]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=\{a_1,\ldots,a_n\}$ be the multiset of given integers. Define $b(x)=\#\{i \mid \text{the $i$-th bit of $x$ equals }1\}$, i.e., the popcount of $x$. We seek a permutation $\pi$ of $\{1,\ldots,n\}$ such that the sequence $(a_{\pi(1)},\ldots,a_{\pi(n)})$ is nondecreasing under the lexicographic key $(b(x),x)$.}
\varmapStart
\var{n}{length of the array}
\var{a_i}{the $i$-th input value}
\var{b(x)}{popcount, the number of 1-bits in $x$}
\var{\pi}{a permutation index mapping to sorted order}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{For all } i<j:\quad &(b(a_{\pi(i)}),a_{\pi(i)}) \le (b(a_{\pi(j)}),a_{\pi(j)})) \\
&\text{(lexicographic order on } \mathbb{N}\times\mathbb{Z}\text{).}
\end{aligned}
\]
}
\ASSUMPTIONS{All inputs are integers within the given bounds; popcount is well-defined for nonnegative integers; stable lexicographic comparison.}
\INVARIANTS{During sorting, comparisons respect a total preorder induced by the tuple $(b(x),x)$; popcount values are constant per element.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the tuple key $(\text{popcount}(x),x)$ and a standard sort. Popcount via converting to binary string and counting \texttt{'1'}.}
\ASSUMPTIONS{Rely on Python's Timsort for $O(n\log n)$ with a custom key; popcount computed per element.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define $\text{popcount}(x)$ as the number of \texttt{'1'} characters in \texttt{bin(x)}.
\item Sort the array with key $\kappa(x)=(\text{popcount}(x),x)$.
\item Return the sorted list.
\end{algosteps}
\COMPLEXITY{Let $n=\lvert \texttt{arr}\rvert$ and assume integer width is bounded (here up to $10^4$). Sorting dominates.}
\[
\begin{aligned}
T(n) &= O(n\log n) \quad \text{(key computed once per element)} \\
S(n) &= O(n) \quad \text{(output list and sort buffers)}
\end{aligned}
\]
\CORRECTNESS{Lexicographic sort by $(\text{popcount}(x),x)$ enforces primary ordering by popcount and tie-breaking by value, which matches the specification.}
\EDGECASES{All zeros; single element; multiple equal values; maximum values near $10^4$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        def popcount(x: int) -> int:
            # Baseline: use binary string count
            return bin(x).count("1")
        return sorted(arr, key=lambda x: (popcount(x), x))

# Tests (baseline)
if __name__ == "__main__":
    s = Solution()
    assert s.sortByBits([0,1,2,3,4,5,6,7,8]) == [0,1,2,4,8,3,5,6,7]
    assert s.sortByBits([1024,512,256,128,64,32,16,8,4,2,1]) == [1,2,4,8,16,32,64,128,256,512,1024]
    assert s.sortByBits([2,3,5,7,11]) == [2,3,5,11,7]
\end{minted}
\VALIDATION{Checked against the two official samples and an extra case with primes.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Bucket by Popcount}
\WHICHFORMULA{Reduce comparator/key overhead by computing popcount once per element and distributing into buckets by popcount, then sort within each bucket by value and concatenate.}
\ASSUMPTIONS{Popcount range is small for bounded integers. For $0 \le x \le 10^4$, popcount $\in [0,14]$ fits safely in a small number of buckets.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $x$ in \texttt{arr}, compute $c=\text{popcount}(x)$ using Kernighan's trick (loop clearing the lowest set bit).
\item Append $x$ to bucket $B[c]$.
\item For $c$ from $0$ to $\max c$, sort $B[c]$ ascending and extend the answer list.
\end{algosteps}
\COMPLEXITY{Each element's popcount is computed once. Sorting happens within buckets. In the worst case (all in one bucket) it matches baseline; often it's cheaper.}
\[
\begin{aligned}
T(n) &= O(n + \sum_c \lvert B[c]\rvert \log \lvert B[c]\rvert) \le O(n\log n) \\
S(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{Buckets group equal-popcount numbers. Sorting within each bucket by value and concatenating in increasing $c$ ensures lexicographic order by $(c,x)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        def popcount(x: int) -> int:
            # Kernighan's algorithm
            cnt = 0
            while x:
                x &= x - 1
                cnt += 1
            return cnt

        if not arr:
            return []

        # Safe bucket count for values up to 10^4 (<= 14 ones), allocate a bit more for simplicity.
        MAXC = 32
        buckets: List[List[int]] = [[] for _ in range(MAXC)]
        maxc = 0
        for x in arr:
            c = popcount(x)
            buckets[c].append(x)
            if c > maxc:
                maxc = c
        ans: List[int] = []
        for c in range(maxc + 1):
            buckets[c].sort()
            ans.extend(buckets[c])
        return ans

# Tests (improved)
if __name__ == "__main__":
    s = Solution()
    assert s.sortByBits([0,1,2,3,4,5,6,7,8]) == [0,1,2,4,8,3,5,6,7]
    assert s.sortByBits([1024,512,256,128,64,32,16,8,4,2,1]) == [1,2,4,8,16,32,64,128,256,512,1024]
    # Edge: duplicates and zeros
    assert s.sortByBits([0,0,1,1,2,2,3,3]) == [0,0,1,2,1,2,3,3]
\end{minted}
\VALIDATION{Covers samples and a case with duplicates and zeros; verifies stable bucket concatenation by increasing popcount.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single Pass Key with Built-in Popcount}
\WHICHFORMULA{Use Python's efficient built-in popcount \texttt{int.bit\_count()} and sort by the tuple key $(x.\texttt{bit\_count}(),x)$. This is concise and fast.}
\ASSUMPTIONS{Runtime provides \texttt{int.bit\_count()} (available in modern Python versions). If not, a fallback can be used, but LC supports it.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define key $\kappa(x)=(x.\texttt{bit\_count}(),x)$.
\item Return \texttt{sorted(arr, key=kappa)}.
\item Timsort guarantees $O(n\log n)$ comparisons and calls the key exactly once per element.
\end{algosteps}
\OPTIMALITY{Comparison-based sorting requires $\Omega(n\log n)$ in the worst case; computing the popcount once per element is $\Theta(n)$. Thus this meets the standard lower bound.}
\COMPLEXITY{Sorting dominates; key computation is linear.}
\[
\begin{aligned}
T(n) &= O(n\log n) \\
S(n) &= O(n)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        return sorted(arr, key=lambda x: (x.bit_count(), x))

# Tests (final)
if __name__ == "__main__":
    s = Solution()
    assert s.sortByBits([0,1,2,3,4,5,6,7,8]) == [0,1,2,4,8,3,5,6,7]
    assert s.sortByBits([1024,512,256,128,64,32,16,8,4,2,1]) == [1,2,4,8,16,32,64,128,256,512,1024]
    assert s.sortByBits([10,100,1000,7]) == [10,100,7,1000]
\end{minted}
\VALIDATION{Three asserts: both official samples and a mixed case verifying tie-breaking by numeric value.}
\RESULT{Returns a list containing the same integers as input, ordered ascending by number of 1-bits in binary; ties broken by integer value ascending.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Use unit asserts on:
\begin{itemize}
\item Sample cases from the statement.
\item Edge cases: all zeros, single element, all equal elements, strictly increasing and strictly decreasing inputs, random arrays within bounds.
\item Adversarial: many numbers sharing the same popcount to stress tie-breaking.
\end{itemize}}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A, B, and C on small random arrays ($n \le 20$) to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays containing boundary values $0$ and $10^4$, plus values with extreme popcounts like $1,2,3,7,15,31,\ldots$ to exercise bucket boundaries.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_boundaries() -> List[int]:
    return [0, 1, 2, 3, 7, 8, 15, 16, 31, 32, 63, 64, 127, 255, 511, 1023, 2047, 4095, 8191, 10000]

def gen_all_equal(n: int, v: int) -> List[int]:
    return [v] * n

def gen_random(n: int, seed: int = 42) -> List[int]:
    rng = random.Random(seed)
    return [rng.randint(0, 10_000) for _ in range(n)]

def oracle(arr: List[int]) -> List[int]:
    # Reference oracle using Python's bit_count
    return sorted(arr, key=lambda x: (x.bit_count(), x))

if __name__ == "__main__":
    # Smoke tests
    b = gen_boundaries()
    assert oracle(b) == sorted(b, key=lambda x: (x.bit_count(), x))
    assert oracle(gen_all_equal(10, 1234)) == [1234] * 10
    r = gen_random(50, seed=7)
    assert oracle(r) == sorted(r, key=lambda x: (x.bit_count(), x))
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        # Final LC-ready solution: concise and optimal
        return sorted(arr, key=lambda x: (x.bit_count(), x))

# Reference asserts
if __name__ == "__main__":
    s = Solution()
    assert s.sortByBits([0]) == [0]
    assert s.sortByBits([3,8,3,8]) == [8,8,3,3]
    assert s.sortByBits([0,1,2,3,4,5,6,7,8]) == [0,1,2,4,8,3,5,6,7]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort by the tuple key (popcount, value).}
\WHY{Common interview filter for sorting by derived keys, and a gentle intro to bit operations.}
\CHECKLIST{
\begin{itemize}
\item Define a correct popcount.
\item Build the key as $(\text{popcount}(x),x)$.
\item Use a stable, $O(n\log n)$ sort.
\item Verify tie-breaking by value.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item All elements identical.
\item Presence of zeros.
\item Single element input.
\item Many elements sharing the same popcount.
\item Maximum range values near $10^4$.
\item Already sorted vs. reverse-sorted inputs.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Miscomputing popcount for $0$ (should be $0$).
\item Forgetting to break ties by value.
\item Using comparison function instead of key (slower and unnecessary in Python).
\item Recomputing expensive keys repeatedly; prefer key functions.
\item Assuming fixed bit-width tricks that fail for Python's unbounded ints.
\item Non-deterministic tests; keep seeds fixed.
\end{itemize}}
\FAILMODES{A sort without tie-breaking by value will yield unstable or platform-dependent order for equal popcounts; bucketing without sorting within buckets breaks the spec.}
\ELI{Count how many 1s each number has in binary, then sort by that count. If two numbers have the same count, put the smaller number first. That's it.}
\NotePages{3}

\end{document}