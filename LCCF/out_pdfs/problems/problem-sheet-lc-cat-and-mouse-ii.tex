% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cat and Mouse II}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/cat-and-mouse-ii/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{A game is played by a cat and a mouse named Cat and Mouse. The environment is represented by a \texttt{grid} of size \texttt{rows x cols}, where each element is a wall, floor, player (Cat, Mouse), or food.
\begin{bullets}
\item Players are represented by the characters \texttt{'C'} (Cat), \texttt{'M'} (Mouse).
\item Floors are represented by the character \texttt{'.'} and can be walked on.
\item Walls are represented by the character \texttt{'\#'} and cannot be walked on.
\item Food is represented by the character \texttt{'F'} and can be walked on.
\item There is only one of each character \texttt{'C'}, \texttt{'M'}, and \texttt{'F'} in \texttt{grid}.
\end{bullets}
Mouse and Cat play according to the following rules:
\begin{bullets}
\item Mouse moves first, then they take turns to move.
\item During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the \texttt{grid}.
\item \texttt{catJump}, \texttt{mouseJump} are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.
\item Staying in the same position is allowed.
\item Mouse can jump over Cat.
\end{bullets}
The game can end in 4 ways:
\begin{bullets}
\item If Cat occupies the same position as Mouse, Cat wins.
\item If Cat reaches the food first, Cat wins.
\item If Mouse reaches the food first, Mouse wins.
\item If Mouse cannot get to the food within 1000 turns, Cat wins.
\end{bullets}
Given a \texttt{rows x cols} matrix \texttt{grid} and two integers \texttt{catJump} and \texttt{mouseJump}, return \texttt{true} if Mouse can win the game if both Cat and Mouse play optimally, otherwise return \texttt{false}.
\par
Example 1:
\begin{verbatim}
Input: grid = ["####F","#C...","M...."], catJump = 1, mouseJump = 2
Output: true
Explanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.
\end{verbatim}
Example 2:
\begin{verbatim}
Input: grid = ["M.C...F"], catJump = 1, mouseJump = 4
Output: true
\end{verbatim}
Example 3:
\begin{verbatim}
Input: grid = ["M.C...F"], catJump = 1, mouseJump = 3
Output: false
\end{verbatim}
Constraints:
\begin{bullets}
\item \texttt{rows == grid.length}
\item \texttt{cols = grid[i].length}
\item \texttt{1 <= rows, cols <= 8}
\item \texttt{grid[i][j]} consist only of characters \texttt{'C'}, \texttt{'M'}, \texttt{'F'}, \texttt{'.'}, and \texttt{'\#'}.
\item There is only one of each character \texttt{'C'}, \texttt{'M'}, and \texttt{'F'} in \texttt{grid}.
\item \texttt{1 <= catJump, mouseJump <= 8}
\end{bullets}}
\BREAKDOWN{Model as a finite impartial game on a directed state graph with positions $(m, c, t)$: mouse cell, cat cell, and whose turn. Identify terminal states and solve by game DP or retrograde analysis to determine if the mouse has a forced win from the initial state.}
\ELI{Think of every board configuration and whose turn it is; work backward from obvious wins/losses to see if the mouse can force a win.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode function signature: \texttt{canMouseWin(grid: List[str], catJump: int, mouseJump: int) -> bool}. Here \texttt{grid} is an array of strings of equal length, with characters from \{\texttt{'.'}, \texttt{'\#'}, \texttt{'C'}, \texttt{'M'}, \texttt{'F'}\}; \texttt{1 \le rows, cols \le 8}; \texttt{1 \le catJump, mouseJump \le 8}.}
\OUTPUTS{Boolean \texttt{True} if the mouse can force reaching the food under optimal play, else \texttt{False}.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{grid = ["\#\#\#\#F","\#C...","M...."]}, \texttt{catJump = 1}, \texttt{mouseJump = 2} $\to$ Output: \texttt{True}.
\item Input: \texttt{grid = ["M.C...F"]}, \texttt{catJump = 1}, \texttt{mouseJump = 3} $\to$ Output: \texttt{False}.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Cells form a finite set $V \subseteq [0, r)\times[0, c)$ of walkable squares (not walls). A state is $(m, c, t)$ with $m \in V$ mouse cell, $c \in V$ cat cell, and $t \in \{\text{Mouse}, \text{Cat}\}$. Directed edges represent legal single-turn moves (including staying). Terminal predicates encode immediate wins.}
\varmapStart
\var{r,c}{rows and cols}
\var{V}{set of non-wall cells}
\var{m,c}{mouse and cat positions as cells in $V$}
\var{t}{turn bit: 0 for Mouse, 1 for Cat}
\var{F}{food cell in $V$}
\var{J_M,J_C}{mouse and cat jump limits}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Win}(m,c,\text{Mouse}) &\iff (m=F)\ \lor\ \exists m'\in N_M(m): \neg \text{Win}(m',c,\text{Cat}) \\
\text{Win}(m,c,\text{Cat}) &\iff (m=c)\ \lor\ (c=F)\ \lor\ \forall m'\in N_M(m): \text{Win}(m',c,\text{Cat}) \\
\text{Win}(m,c,\text{Cat}) &\iff (c=F)\ \lor\ (m=c)\ \lor\ \exists c'\in N_C(c): \neg \text{Win}(m,c',\text{Mouse}) \\
\text{Win}(m,c,\text{Mouse}) &\iff (m=F)\ \lor\ \forall c'\in N_C(c): \text{Win}(m,c',\text{Mouse})
\end{aligned}
\]
with $N_M, N_C$ the legal move neighborhoods (four directions up to $J_M, J_C$ without crossing walls, plus staying). A standard bound on play length is $T_{\max}=2|V| \le 128$, within the stated 1000-turn limit.}
\ASSUMPTIONS{Indices are 0-based; at most one of each \texttt{C}, \texttt{M}, \texttt{F}; staying in place allowed; moving cannot cross walls or leave the grid; Mouse may move through Cat but landing on the Cat loses immediately (Cat occupies same cell).}
\INVARIANTS{
\begin{bullets}
\item If $m=c$, Cat has already won.
\item If $c=F$, Cat has already won; if $m=F$ and $m\neq c$, Mouse has already won.
\item Play need not exceed $2|V|$ plies to decide the outcome under optimal play; otherwise a state repeats.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct game-tree search (minimax) with a strict turn cap: recursively try all legal moves for the current player and check terminals.}
\ASSUMPTIONS{Cap total plies at $T_{\max} = 2|V|$ (which is $\le 128$) to comply with and strengthen the 1000-turn rule.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse grid; locate \texttt{M}, \texttt{C}, \texttt{F}; precompute legal moves per cell and piece.
\item DFS state $(m,c,t,\tau)$ where $\tau$ is the number of plies so far; stop with Cat win if $\tau \ge T_{\max}$.
\item Mouse turn: return True if any move leads to True. Cat turn: return False if any move leads to False; otherwise True.
\end{algosteps}
\COMPLEXITY{Exponential in general; with $b$ average branching and depth $d=T_{\max}$, $T(n)\approx O(b^{d})$; space $O(d)$ recursion plus memo if used. Small $d\le 128$ caps explosion on $8\times 8$.}
\[
\begin{aligned}
T(n) &\le b^{T_{\max}} \\
S(n) &= O(T_{\max})
\end{aligned}
\]
\CORRECTNESS{By definition of optimal play: Mouse picks any winning child; Cat picks any child that avoids Mouse win. The cap ensures compliance with the 1000-turn rule.}
\EDGECASES{Start already terminal (same cell or someone on food); no legal moves except staying; jumps blocked by immediate walls.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        R, C = len(grid), len(grid[0])
        dirs = [(1,0),(-1,0),(0,1),(0,-1)]
        def inb(r,c): return 0 <= r < R and 0 <= c < C
        # Collect cells
        cells = []
        pos_to_idx = {}
        mouse = cat = food = (-1, -1)
        for r in range(R):
            for c in range(C):
                ch = grid[r][c]
                if ch != '#':
                    pos_to_idx[(r,c)] = len(cells)
                    cells.append((r,c))
                if ch == 'M':
                    mouse = (r,c)
                elif ch == 'C':
                    cat = (r,c)
                elif ch == 'F':
                    food = (r,c)
        P = len(cells)
        # Precompute moves (including staying)
        def build_moves(J: int):
            moves = [[] for _ in range(P)]
            for i, (r,c) in enumerate(cells):
                seen = set()
                seen.add(i)  # staying allowed
                for dr, dc in dirs:
                    for k in range(1, J+1):
                        nr, nc = r + dr*k, c + dc*k
                        if not inb(nr, nc) or grid[nr][nc] == '#':
                            break
                        seen.add(pos_to_idx[(nr,nc)])
                moves[i] = list(seen)
            return moves
        M_moves = build_moves(mouseJump)
        C_moves = build_moves(catJump)
        m0 = pos_to_idx[mouse]
        c0 = pos_to_idx[cat]
        f  = pos_to_idx[food]
        # Terminal quick checks
        if m0 == c0: return False
        if c0 == f: return False
        if m0 == f: return True
        # Depth limit: standard safe bound <= 2*P <= 128 <= 1000
        TMAX = 2 * P
        from functools import lru_cache
        @lru_cache(None)
        def dfs(m: int, c: int, turn: int, t: int) -> bool:
            # True if mouse can force win from this state
            if m == c: return False
            if c == f: return False
            if m == f: return True
            if t >= TMAX:  # exceeds safe horizon -> Cat wins by rule
                return False
            if turn == 0:  # mouse to move
                for m2 in M_moves[m]:
                    # Mouse can jump over cat, but landing on cat loses immediately
                    if m2 == c:
                        continue
                    if dfs(m2, c, 1, t+1):
                        return True
                return False
            else:  # cat to move
                for c2 in C_moves[c]:
                    # Cat can move onto food or mouse
                    if c2 == f or c2 == m:
                        return False
                    if not dfs(m, c2, 0, t+1):
                        return False
                return True
        return dfs(m0, c0, 0, 0)

# Basic asserts from the prompt
assert Solution().canMouseWin(["####F","#C...","M...."], 1, 2) == True
assert Solution().canMouseWin(["M.C...F"], 1, 4) == True
assert Solution().canMouseWin(["M.C...F"], 1, 3) == False
\end{minted}
\VALIDATION{Smoke-test terminals: if Mouse starts on food and not collocated with Cat, returns True; if Cat starts on food or on Mouse, returns False. The asserts above match the examples.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Memoized Minimax with Precomputed Reachability}
\WHICHFORMULA{Same minimax recurrence, but cache states and precompute legal moves once to reduce recomputation; leverage the bounded horizon $T_{\max}=2|V|$.}
\ASSUMPTIONS{The safe horizon $2|V|$ is within 1000 and suffices to decide outcomes on an $8\times 8$ grid.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute for each cell the legal destinations for Mouse and Cat including staying.
\item Use DFS with memoization keyed by $(m,c,t,\tau)$; prune immediately on terminals and time cap.
\item Mouse turn: OR over children; Cat turn: AND over children with negation (avoid Mouse win).
\end{algosteps}
\COMPLEXITY{Each state is solved once: $O(|V|^2)$ states $\times$ average branching ($\le 1+4\max(J_M,J_C)$). Space $O(|V|^2)$ for memo. This is a large improvement over naive recomputation.}
\[
\begin{aligned}
T(n) &= O\big(|V|^2 \cdot (J_M+J_C)\big),\quad S(n) = O(|V|^2)
\end{aligned}
\]
\CORRECTNESS{Memoization preserves the same optimality conditions while ensuring no repeated subproblem work; the cap enforces the problem's turn limit.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        R, C = len(grid), len(grid[0])
        dirs = [(1,0),(-1,0),(0,1),(0,-1)]
        def inb(r,c): return 0 <= r < R and 0 <= c < C
        # Map open cells
        pos_to_idx, cells = {}, []
        m0 = c0 = f = -1
        for r in range(R):
            for c in range(C):
                if grid[r][c] != '#':
                    pos_to_idx[(r,c)] = len(cells)
                    cells.append((r,c))
        for r in range(R):
            for c in range(C):
                if grid[r][c] == 'M':
                    m0 = pos_to_idx[(r,c)]
                elif grid[r][c] == 'C':
                    c0 = pos_to_idx[(r,c)]
                elif grid[r][c] == 'F':
                    f = pos_to_idx[(r,c)]
        P = len(cells)
        # Moves
        def build_moves(J: int):
            moves = [[] for _ in range(P)]
            for i,(r,c) in enumerate(cells):
                reach = [i]  # stay
                for dr,dc in dirs:
                    for k in range(1, J+1):
                        nr, nc = r+dr*k, c+dc*k
                        if not inb(nr,nc) or grid[nr][nc] == '#':
                            break
                        reach.append(pos_to_idx[(nr,nc)])
                moves[i] = reach
            return moves
        M_moves = build_moves(mouseJump)
        C_moves = build_moves(catJump)
        # Terminals
        if m0 == c0: return False
        if c0 == f: return False
        if m0 == f: return True
        TMAX = 2 * P  # <= 128
        from functools import lru_cache
        @lru_cache(None)
        def dp(m: int, c: int, turn: int, t: int) -> bool:
            if m == c or c == f:
                return False
            if m == f:
                return True
            if t >= TMAX:
                return False
            if turn == 0:
                for m2 in M_moves[m]:
                    if m2 == c:  # landing on cat loses; skip
                        continue
                    if dp(m2, c, 1, t+1):
                        return True
                return False
            else:
                for c2 in C_moves[c]:
                    if c2 == f or c2 == m:
                        return False
                    if not dp(m, c2, 0, t+1):
                        return False
                return True
        return dp(m0, c0, 0, 0)

# Cross-check small cases
assert Solution().canMouseWin(["####F","#C...","M...."], 1, 2) == True
assert Solution().canMouseWin(["M.C...F"], 1, 4) == True
assert Solution().canMouseWin(["M.C...F"], 1, 3) == False
\end{minted}
\VALIDATION{Matches examples. Additional quick check: if \texttt{grid = ["MF","C."]} with small jumps, Mouse immediately wins.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Retrograde Analysis (Reverse BFS) on the State Graph}
\WHICHFORMULA{Coloring states by winners using degrees and predecessors. Initialize terminal wins, then propagate: a player-to-move state is winning if it has any move to a state already colored as that player's win; otherwise, if all moves lead to opponent wins, it is losing.}
\ASSUMPTIONS{On an $r\times c$ grid with $|V|\le 64$, any forced win occurs within $2|V| \le 128 \le 1000$ plies, so resolving colors without explicit turn counters respects the 1000-turn constraint.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate passable cells and index them. Build legal move lists for Mouse and Cat, and reverse move lists for parent generation.
\item For each $(m,c)$ and turn, set degree to number of legal moves for the player to move. Color terminals: $m=c$ or $c=F$ as Cat win; $m=F\neq c$ as Mouse win; enqueue both turns.
\item While queue nonempty, pop a colored state and update all parents. If a parent (player $P$ to move) has a child colored as $P$-win, color the parent as $P$-win. Otherwise, decrement the parent degree for each opponent-win child; when it drops to 0, color the parent as opponent-win.
\end{algosteps}
\OPTIMALITY{This is standard retrograde game solving on a finite graph; it labels every state that is winning for either side without search duplication and in near-linear time in the state graph size.}
\COMPLEXITY{There are $2|V|^2$ states and $O((J_M+J_C)|V|^2)$ edges. Reverse BFS colors each state once: time $O((J_M+J_C)|V|^2)$, space $O(|V|^2)$.}
\[
\begin{aligned}
T(n) &= O\big((J_M+J_C)\,|V|^2\big), \quad S(n) = O(|V|^2)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Deque
from collections import deque

class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        R, C = len(grid), len(grid[0])
        dirs = [(1,0),(-1,0),(0,1),(0,-1)]
        def inb(r,c): return 0 <= r < R and 0 <= c < C

        # Map passable cells to indices
        pos_to_idx, cells = {}, []
        mouse = cat = food = (-1, -1)
        for r in range(R):
            for c in range(C):
                if grid[r][c] != '#':
                    pos_to_idx[(r,c)] = len(cells)
                    cells.append((r,c))
                if grid[r][c] == 'M':
                    mouse = (r,c)
                elif grid[r][c] == 'C':
                    cat = (r,c)
                elif grid[r][c] == 'F':
                    food = (r,c)
        P = len(cells)
        m0 = pos_to_idx[mouse]
        c0 = pos_to_idx[cat]
        f  = pos_to_idx[food]

        # Precompute forward moves (including staying)
        def build_moves(J: int):
            moves = [[] for _ in range(P)]
            for i,(r,c) in enumerate(cells):
                reach = [i]  # staying allowed
                for dr, dc in dirs:
                    for k in range(1, J+1):
                        nr, nc = r + dr*k, c + dc*k
                        if not inb(nr,nc) or grid[nr][nc] == '#':
                            break
                        reach.append(pos_to_idx[(nr,nc)])
                moves[i] = reach
            return moves
        M_moves = build_moves(mouseJump)
        C_moves = build_moves(catJump)

        # Precompute reverse move lists: for each target, which sources can move to it
        def build_rev_moves(moves: List[List[int]]):
            rev = [[] for _ in range(P)]
            for src in range(P):
                for dst in moves[src]:
                    rev[dst].append(src)
            return rev
        M_rev = build_rev_moves(M_moves)
        C_rev = build_rev_moves(C_moves)

        # Constants for turns and colors
        MOUSE, CAT = 0, 1
        UNKNOWN, MWIN, CWIN = 0, 1, 2

        # Degrees: number of moves available for the player to move at (m,c,turn)
        deg = [[[0,0] for _ in range(P)] for __ in range(P)]
        for m in range(P):
            for c in range(P):
                deg[m][c][MOUSE] = len(M_moves[m])
                deg[m][c][CAT]   = len(C_moves[c])

        color = [[[UNKNOWN, UNKNOWN] for _ in range(P)] for __ in range(P)]
        q: Deque[tuple] = deque()

        # Initialize terminals with careful precedence:
        # If m == c or c == f -> Cat win. Else if m == f -> Mouse win.
        for m in range(P):
            for c in range(P):
                if m == c or c == f:
                    if color[m][c][MOUSE] == UNKNOWN:
                        color[m][c][MOUSE] = CWIN
                        q.append((m,c,MOUSE,CWIN))
                    if color[m][c][CAT] == UNKNOWN:
                        color[m][c][CAT] = CWIN
                        q.append((m,c,CAT,CWIN))
                elif m == f:
                    if color[m][c][MOUSE] == UNKNOWN:
                        color[m][c][MOUSE] = MWIN
                        q.append((m,c,MOUSE,MWIN))
                    if color[m][c][CAT] == UNKNOWN:
                        color[m][c][CAT] = MWIN
                        q.append((m,c,CAT,MWIN))

        # Helper to iterate parents of a given state
        def parents(m: int, c: int, turn: int):
            if turn == MOUSE:
                # Child is mouse-to-move; parents are cat-to-move states that moved cat into c
                for c_prev in C_rev[c]:
                    yield (m, c_prev, CAT)
            else:
                # Child is cat-to-move; parents are mouse-to-move states that moved mouse into m
                for m_prev in M_rev[m]:
                    yield (m_prev, c, MOUSE)

        # Reverse BFS coloring
        while q:
            m, c, turn, res = q.popleft()
            for pm, pc, pturn in parents(m, c, turn):
                if color[pm][pc][pturn] != UNKNOWN:
                    continue
                # If parent player can move into a state that is a win for the parent player,
                # then parent becomes that win immediately.
                if pturn == MOUSE and res == MWIN:
                    color[pm][pc][pturn] = MWIN
                    q.append((pm,pc,pturn,MWIN))
                elif pturn == CAT and res == CWIN:
                    color[pm][pc][pturn] = CWIN
                    q.append((pm,pc,pturn,CWIN))
                else:
                    # This child is a win for the opponent; decrement degree.
                    deg[pm][pc][pturn] -= 1
                    if deg[pm][pc][pturn] == 0:
                        # All moves lead to opponent wins -> parent loses
                        lose_color = CWIN if pturn == MOUSE else MWIN
                        color[pm][pc][pturn] = lose_color
                        q.append((pm,pc,pturn,lose_color))

        # Mouse moves first
        return color[m0][c0][MOUSE] == MWIN

# Final asserts
assert Solution().canMouseWin(["####F","#C...","M...."], 1, 2) == True
assert Solution().canMouseWin(["M.C...F"], 1, 4) == True
assert Solution().canMouseWin(["M.C...F"], 1, 3) == False
\end{minted}
\VALIDATION{Exactly 3 asserts above match the prompt examples.}
\RESULT{Return True iff the initial state $(m_0,c_0,\text{Mouse})$ is colored as Mouse win by retrograde analysis. Ties/cycles that are not winning for Mouse are treated as non-wins, consistent with the 1000-turn cap since any true Mouse win occurs within $2|V| \le 128$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: terminals (Mouse on food, Cat on food, same cell), small lines/blocks, varying jumps, blocked paths by walls, staying-in-place allowed.}
\LINE{CROSS-CHECKS}{Compare Approach B (memoized DFS) vs Approach C (retrograde) on random tiny grids to ensure identical outcomes.}
\LINE{EDGE-CASE GENERATOR}{Generate small $r,c\in\{1,\ldots,4\}$ grids with random walls ensuring connectivity of at least \texttt{M}, \texttt{C}, \texttt{F}; random jumps in $[1,4]$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_grid(r: int, c: int, wall_prob: float, seed: int) -> List[str]:
    random.seed(seed)
    g = [['.' for _ in range(c)] for __ in range(r)]
    # sprinkle walls
    for i in range(r):
        for j in range(c):
            if random.random() < wall_prob:
                g[i][j] = '#'
    # ensure placements on open cells
    opens = [(i,j) for i in range(r) for j in range(c) if g[i][j] != '#']
    if len(opens) < 3:
        # fallback: clear grid
        g = [['.' for _ in range(c)] for __ in range(r)]
        opens = [(i,j) for i in range(r) for j in range(c)]
    random.shuffle(opens)
    (mi,mj),(ci,cj),(fi,fj) = opens[:3]
    g[mi][mj] = 'M'
    g[ci][cj] = 'C'
    g[fi][fj] = 'F'
    return [''.join(row) for row in g]

# Tiny sanity runs comparing both approaches on random seeds
from collections import deque

def run_compare(trials: int = 5):
    for s in range(trials):
        grid = gen_grid(3, 4, 0.2, seed=123+s)
        cj = 1 + (s % 3)
        mj = 1 + ((s+1) % 3)
        b = SolutionB().canMouseWin(grid, cj, mj)
        c = SolutionC().canMouseWin(grid, cj, mj)
        assert b == c, f"mismatch on seed {s}, grid={grid}, cj={cj}, mj={mj}"

class SolutionB(Solution):  # uses Approach B code via inheritance if available
    pass

class SolutionC(Solution):  # uses Approach C code via inheritance if available
    pass

# Note: In this snippet, Solution is the latest defined class (Approach C).
# For real cross-checks, import or paste both variants.
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Deque
from collections import deque

class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        R, C = len(grid), len(grid[0])
        dirs = [(1,0),(-1,0),(0,1),(0,-1)]
        def inb(r,c): return 0 <= r < R and 0 <= c < C

        # Map passable cells to indices
        pos_to_idx, cells = {}, []
        mouse = cat = food = (-1, -1)
        for r in range(R):
            for c in range(C):
                if grid[r][c] != '#':
                    pos_to_idx[(r,c)] = len(cells)
                    cells.append((r,c))
                if grid[r][c] == 'M':
                    mouse = (r,c)
                elif grid[r][c] == 'C':
                    cat = (r,c)
                elif grid[r][c] == 'F':
                    food = (r,c)
        P = len(cells)
        m0 = pos_to_idx[mouse]
        c0 = pos_to_idx[cat]
        f  = pos_to_idx[food]

        # Precompute forward moves (including staying)
        def build_moves(J: int):
            moves = [[] for _ in range(P)]
            for i,(r,c) in enumerate(cells):
                reach = [i]  # staying allowed
                for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    for k in range(1, J+1):
                        nr, nc = r + dr*k, c + dc*k
                        if not inb(nr,nc) or grid[nr][nc] == '#':
                            break
                        reach.append(pos_to_idx[(nr,nc)])
                moves[i] = reach
            return moves
        M_moves = build_moves(mouseJump)
        C_moves = build_moves(catJump)

        # Precompute reverse move lists: for each target, which sources can move to it
        def build_rev_moves(moves: List[List[int]]):
            rev = [[] for _ in range(P)]
            for src in range(P):
                for dst in moves[src]:
                    rev[dst].append(src)
            return rev
        M_rev = build_rev_moves(M_moves)
        C_rev = build_rev_moves(C_moves)

        # Constants for turns and colors
        MOUSE, CAT = 0, 1
        UNKNOWN, MWIN, CWIN = 0, 1, 2

        # Degrees: number of moves available for the player to move at (m,c,turn)
        deg = [[[0,0] for _ in range(P)] for __ in range(P)]
        for m in range(P):
            for c in range(P):
                deg[m][c][MOUSE] = len(M_moves[m])
                deg[m][c][CAT]   = len(C_moves[c])

        color = [[[UNKNOWN, UNKNOWN] for _ in range(P)] for __ in range(P)]
        q: Deque[tuple] = deque()

        # Initialize terminals
        for m in range(P):
            for c in range(P):
                if m == c or c == f:
                    if color[m][c][MOUSE] == UNKNOWN:
                        color[m][c][MOUSE] = CWIN
                        q.append((m,c,MOUSE,CWIN))
                    if color[m][c][CAT] == UNKNOWN:
                        color[m][c][CAT] = CWIN
                        q.append((m,c,CAT,CWIN))
                elif m == f:
                    if color[m][c][MOUSE] == UNKNOWN:
                        color[m][c][MOUSE] = MWIN
                        q.append((m,c,MOUSE,MWIN))
                    if color[m][c][CAT] == UNKNOWN:
                        color[m][c][CAT] = MWIN
                        q.append((m,c,CAT,MWIN))

        def parents(m: int, c: int, turn: int):
            if turn == MOUSE:
                for c_prev in C_rev[c]:
                    yield (m, c_prev, CAT)
            else:
                for m_prev in M_rev[m]:
                    yield (m_prev, c, MOUSE)

        while q:
            m, c, turn, res = q.popleft()
            for pm, pc, pturn in parents(m, c, turn):
                if color[pm][pc][pturn] != UNKNOWN:
                    continue
                if pturn == MOUSE and res == MWIN:
                    color[pm][pc][pturn] = MWIN
                    q.append((pm,pc,pturn,MWIN))
                elif pturn == CAT and res == CWIN:
                    color[pm][pc][pturn] = CWIN
                    q.append((pm,pc,pturn,CWIN))
                else:
                    deg[pm][pc][pturn] -= 1
                    if deg[pm][pc][pturn] == 0:
                        color[pm][pc][pturn] = CWIN if pturn == MOUSE else MWIN
                        q.append((pm,pc,pturn,color[pm][pc][pturn]))

        return color[m0][c0][MOUSE] == MWIN

# Reference asserts
assert Solution().canMouseWin(["####F","#C...","M...."], 1, 2) == True
assert Solution().canMouseWin(["M.C...F"], 1, 4) == True
assert Solution().canMouseWin(["M.C...F"], 1, 3) == False
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Solve a finite two-player perfect-information game by retrograde analysis (or memoized minimax) on $(\text{mouse},\text{cat},\text{turn})$ states.}
\WHY{Classic game-DP pattern: turn-based moves, terminals, and optimal play; tests ability to convert rules into a state graph and reason about forced wins.}
\CHECKLIST{
\begin{bullets}
\item Parse grid, index passable cells, locate M/C/F.
\item Generate legal moves up to jump limit per direction; include staying; stop at walls.
\item Define terminals: $m=c$, $c=F$, $m=F$.
\item Choose solver: memoized DFS with cap or reverse BFS with degrees.
\item Return color at start state with Mouse to move.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Start already terminal: $m=c$ or $c=F$ or $m=F$.
\item Jumps blocked immediately by adjacent wall.
\item Single-row/column grids.
\item Cat or Mouse with jump $1$ vs large jump asymmetry.
\item Food adjacent to both players.
\item Staying in place is optimal for delaying or forcing moves.
\item Mouse landing on Cat is an immediate Cat win (avoid as Mouse).
\item Both targeting the same food square; Cat reaching food first wins.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to include the ``stay'' move.
\item Allowing jumps to pass through walls instead of stopping at them.
\item Mishandling precedence: when $m=c$ on $F$, Cat wins, not Mouse.
\item Not bounding recursion, violating the 1000-turn rule.
\item Incorrect parent generation in reverse BFS (must use reverse move lists).
\item Off-by-one in jump length iteration.
\item Not treating Mouse jump over Cat as allowed.
\item Counting degrees incorrectly (must be per-turn, per-state).
\end{bullets}
}
\FAILMODES{Pure naive DFS without memo will explode on loopy positions; incorrect propagation may leave states uncolored; missing stay move alters degrees and can miscolor draws. The reverse-BFS method with degrees avoids these.}
\ELI{List every configuration and whose turn it is, mark obvious wins and losses, then propagate those labels backward. The mouse wins if its starting configuration is marked as a mouse win; otherwise the cat can stop it within the allowed number of turns.}
\NotePages{3}

\end{document}