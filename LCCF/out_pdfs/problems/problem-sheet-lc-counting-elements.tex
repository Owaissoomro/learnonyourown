% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Counting Elements}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/counting-elements/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given an integer array $arr$. Count how many elements $x$ in $arr$ satisfy that $x+1$ also appears in $arr$. Return this count.

Each occurrence in $arr$ is counted separately. Concretely, for every index $i$, if there exists some index $j$ with $arr[j] = arr[i] + 1$, then the occurrence at $i$ contributes $1$ to the answer (even if there are multiple such $j$).}
\BREAKDOWN{We need to test, for each element $x$, whether $x+1$ exists somewhere in the array. Duplicates of $x$ each count once if $x+1$ exists at least once. The key is a fast membership query for $x+1$.}
\ELI{Put all numbers into a lookup table, then for each number add $1$ if the next number is present.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function signature (LC): \texttt{def countElements(self, arr: List[int]) -> int}.

Valid inputs:
\begin{bullets}
\item $arr$: list of integers, length $n \ge 0$.
\item Elements fit in 32-bit signed integer; duplicates allowed; order arbitrary.
\end{bullets}}
\OUTPUTS{Return a single integer: the number of indices $i$ such that $arr[i] + 1$ exists as a value somewhere in $arr$.}
\SAMPLES{
Example 1:\quad $arr=[1,2,3] \Rightarrow 2$ \ (elements $1$ and $2$ are counted).

Example 2:\quad $arr=[1,1,3,3,5,5,7,7] \Rightarrow 0$ \ (no $x$ has $x+1$ present).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given integers $a_1,\ldots,a_n$, let $S=\{a_1,\ldots,a_n\}$ be the set of distinct values. The objective is to compute
\begin{BreakableEquation*}
\text{Ans} = \sum_{i=1}^{n} \mathbf{1}\{a_i+1 \in S\}.
\end{BreakableEquation*}
Duplicates are handled naturally because the sum runs over indices (occurrences).}
\varmapStart
\var{n}{length of the input array}
\var{a_i}{the $i$-th element of the array}
\var{S}{set of distinct values appearing in $arr$}
\var{\mathbf{1}\{\cdot\}}{indicator function: $1$ if the predicate is true, else $0$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Ans} = \sum_{i=1}^{n} \mathbf{1}\{a_i+1 \in S\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Array indexing is $1$-based in math; the input can be empty; integer arithmetic has no overflow concerns for forming $a_i+1$ in typical 32-bit bounds.}
\INVARIANTS{
\begin{bullets}
\item Membership set $S$ remains unchanged while scanning $arr$.
\item Partial sum after processing $k$ elements equals the number of indices $i \le k$ with $a_i+1 \in S$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly implement $\text{Ans} = \sum_i \mathbf{1}\{a_i+1 \in S\}$ using $S$ implicitly as a scan: for each $a_i$, linearly search the array for $a_i+1$.}
\ASSUMPTIONS{No precomputation; rely on nested loops.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $ans\gets 0$.
\item For each index $i$ from $1$ to $n$: scan all $j$ from $1$ to $n$ and check if $a_j=a_i+1$.
\item If found, increment $ans$. Return $ans$ at the end.
\end{algosteps}
\COMPLEXITY{Let $n=\lvert arr\rvert$. Time $T(n)=\Theta(n^2)$ due to the nested scan; space $S(n)=\Theta(1)$ extra.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} \Theta(n) \\
     &= \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{Every pair $(i,j)$ is considered; if there exists any $j$ with $a_j=a_i+1$, the algorithm counts index $i$ once. Duplicates of $a_i$ are handled per occurrence.}
\EDGECASES{Empty array returns $0$; all-equal arrays return $0$ unless the value immediately below exists; negative numbers are fine.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def countElements(self, arr: List[int]) -> int:
        n = len(arr)
        ans = 0
        for i in range(n):
            x = arr[i]
            found = False
            for j in range(n):
                if arr[j] == x + 1:
                    found = True
                    break
            if found:
                ans += 1
        return ans

# baseline tests
if __name__ == "__main__":
    s = Solution()
    assert s.countElements([1, 2, 3]) == 2
    assert s.countElements([1, 1, 3, 3, 5, 5, 7, 7]) == 0
    assert s.countElements([1, 1, 2, 2]) == 2  # both 1s count; 2s do not
\end{minted}
\VALIDATION{Checks cover a simple increasing case, a case with no successors, and a duplicate-sensitive case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Precompute a membership set $S$ of all values in $arr$, then for each $x$ in $arr$ check $x+1 \in S$ in $O(1)$ average time.}
\ASSUMPTIONS{Hash set lookups are $O(1)$ average-case; input size fits memory.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $S \gets \text{set}(arr)$.
\item Initialize $ans\gets 0$.
\item For each $x$ in $arr$, if $x+1 \in S$, increment $ans$. Return $ans$.
\end{algosteps}
\COMPLEXITY{Building $S$ takes $O(n)$ and scanning takes $O(n)$; total $T(n)=\Theta(n)$ time, $S(n)=\Theta(n)$ space for the set.}
\[
\begin{aligned}
T(n) &= \Theta(n) + \Theta(n) = \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Because $S$ contains exactly the distinct values of $arr$, the predicate $x+1 \in S$ is equivalent to ``there exists an index $j$ with $arr[j]=x+1$''. Counting per occurrence over the original array preserves duplicate semantics.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def countElements(self, arr: List[int]) -> int:
        S = set(arr)
        ans = 0
        for x in arr:
            if x + 1 in S:
                ans += 1
        return ans

# improved tests
if __name__ == "__main__":
    s = Solution()
    assert s.countElements([1, 2, 3]) == 2
    assert s.countElements([1, 1, 3, 3, 5, 5, 7, 7]) == 0
    assert s.countElements([-2, -1, -1, 0, 0]) == 4  # both -2 and -1s count; 0s do not
\end{minted}
\VALIDATION{Includes negatives and duplicates to confirm membership logic and per-occurrence counting.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Hash-set membership per occurrence: $S=\text{set}(arr)$ and sum $\mathbf{1}\{x+1\in S\}$ over $x\in arr$. This achieves $\Theta(n)$ time which is optimal up to constant factors because every input element must be examined at least once.}
\ASSUMPTIONS{Standard RAM model; set lookup average-case $O(1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $S\gets\text{set}(arr)$.
\item Initialize $ans\gets 0$.
\item For each $x$ in $arr$, if $x+1\in S$, increment $ans$. Return $ans$.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must read all $n$ elements, yielding a lower bound $\Omega(n)$. This approach meets that bound with $\Theta(n)$ time and is therefore asymptotically optimal.}
\COMPLEXITY{Time $\Theta(n)$; space $\Theta(n)$.}
\[
\begin{aligned}
T(n) &= \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def countElements(self, arr: List[int]) -> int:
        S = set(arr)
        return sum(1 for x in arr if x + 1 in S)

# final checks (exactly 3)
if __name__ == "__main__":
    s = Solution()
    assert s.countElements([1, 2, 3]) == 2
    assert s.countElements([1, 1, 2, 2]) == 2
    assert s.countElements([]) == 0
\end{minted}
\VALIDATION{Three asserts: increasing sequence, duplicates sensitivity, empty input.}
\RESULT{Return the count of occurrences $x$ such that $x+1$ appears at least once in the array; duplicates of $x$ each count once if $x+1$ exists.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests should cover: empty input; single-element arrays; all-equal arrays; strictly increasing sequences; arrays with negatives; random-like arrays; adversarial cases with large duplicates.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline $O(n^2)$ and Improved/Final $O(n)$ on small crafted cases to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Deterministic pseudo-random generator without external randomness: linear congruential construction to create varied yet repeatable arrays, plus hand-crafted edge cases.}
\begin{minted}{python}
from typing import List, Iterable

def gen_lc_cases() -> Iterable[List[int]]:
    # Hand-crafted basics
    yield []
    yield [0]
    yield [5, 5, 5]
    yield [1, 2, 3, 4]
    yield [-3, -2, -2, -1, 0]
    yield [1, 1, 3, 3, 5, 5, 7, 7]

    # Deterministic pseudo-random via simple LCG (no imports)
    def lcg(n: int, seed: int = 7) -> List[int]:
        a, c, m = 1103515245, 12345, 1 << 31
        x = seed
        out = []
        for _ in range(n):
            x = (a * x + c) % m
            # Map to small integer range with sign
            out.append(((x >> 16) % 21) - 10)  # in [-10, 10]
        return out

    for sz in range(1, 10):
        yield lcg(sz, seed=sz * 17 + 3)

class Baseline:
    @staticmethod
    def countElements(arr: List[int]) -> int:
        n = len(arr)
        ans = 0
        for i in range(n):
            x = arr[i]
            for j in range(n):
                if arr[j] == x + 1:
                    ans += 1
                    break
        return ans

class Final:
    @staticmethod
    def countElements(arr: List[int]) -> int:
        S = set(arr)
        return sum(1 for x in arr if x + 1 in S)

def self_test():
    for arr in gen_lc_cases():
        assert Baseline.countElements(arr) == Final.countElements(arr)
    # Boundary-like stress within constraints of simple runtime
    big = [0] * 1000  # all equal; answer 0
    assert Final.countElements(big) == 0
    stair = list(range(-200, 200))
    assert Final.countElements(stair) == len(stair) - 1

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def countElements(self, arr: List[int]) -> int:
        S = set(arr)
        return sum(1 for x in arr if x + 1 in S)

# Reference self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.countElements([1, 2, 3]) == 2
    assert s.countElements([1, 1, 3, 3, 5, 5, 7, 7]) == 0
    assert s.countElements([-2, -1, -1, 0, 0]) == 4
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count occurrences $x$ such that $x+1$ exists anywhere in the array.}
\WHY{This tests the ability to convert a counting condition into fast membership queries using a hash set.}
\CHECKLIST{
\begin{bullets}
\item Build a set of values from the array.
\item Loop through the original array to preserve per-occurrence semantics.
\item Check membership for $x+1$; increment answer.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Empty array $\Rightarrow 0$.
\item Single element $\Rightarrow 0$ unless impossible $x+1$ exists.
\item All elements equal $\Rightarrow 0$.
\item Strictly increasing sequence of length $n$ $\Rightarrow n-1$.
\item Arrays with negatives and zeros.
\item Large duplicates of a value with successor present: all those occurrences count.
\item Successor at multiple positions still counts each $x$ only once per occurrence.
\item Max/min integer values: ensure $x+1$ does not overflow typical bounds.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Accidentally counting occurrences of $x+1$ instead of counting $x$.
\item Double-counting due to nested loops without early break.
\item Using the set incorrectly (e.g., iterating the set instead of the array, losing duplicate semantics).
\item Off-by-one on the successor check ($x-1$ vs $x+1$).
\item Mutating the set while iterating.
\item Assuming sorted input and using adjacent comparisons only.
\item Forgetting negatives or zero.
\item Inefficient $O(n^2)$ solution on large inputs causing timeouts.
\end{bullets}}
\FAILMODES{Approaches that sort and only compare neighbors fail on inputs like $[1,1,2]$ if not careful with duplicates; the set-based approach is robust.}
\ELI{Make a quick list of which numbers appear. For each number in the array, if the next number exists in that list, count it. Add up all such occurrences.}
\NotePages{3}

\end{document}