% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cheapest Flights Within K Stops}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/cheapest-flights-within-k-stops/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{There are $n$ cities connected by some number of flights. You are given an array $flights$ where $flights[i] = [from_i, to_i, price_i]$ indicates that there is a flight from city $from_i$ to city $to_i$ with cost $price_i$. You are also given three integers $src$, $dst$, and $k$. Return the cheapest price from $src$ to $dst$ with at most $k$ stops. If there is no such route, return $-1$.\par
Examples:\par
Example 1: Input: $n = 4$, $flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]]$, $src = 0$, $dst = 3$, $k = 1$. Output: $700$. Explanation: The optimal path with at most $1$ stop from city $0$ to $3$ has cost $100 + 600 = 700$. The path $[0,1,2,3]$ is cheaper but invalid because it uses $2$ stops.\par
Example 2: Input: $n = 3$, $flights = [[0,1,100],[1,2,100],[0,2,500]]$, $src = 0$, $dst = 2$, $k = 1$. Output: $200$. Explanation: The optimal path with at most $1$ stop from city $0$ to $2$ has cost $100 + 100 = 200$.\par
Example 3: Input: $n = 3$, $flights = [[0,1,100],[1,2,100],[0,2,500]]$, $src = 0$, $dst = 2$, $k = 0$. Output: $500$. Explanation: The optimal path with no stops from city $0$ to $2$ has cost $500$.\par
Constraints: $1 \le n \le 100$; $0 \le \lvert flights \rvert \le \tfrac{n(n-1)}{2}$; each $flights[i]$ has length $3$; $0 \le from_i,to_i < n$ with $from_i \ne to_i$; $1 \le price_i \le 10^4$; no multiple flights between two cities; $0 \le src,dst,k < n$ with $src \ne dst$.}
\BREAKDOWN{Model this as a directed weighted graph. We seek a minimum-cost $src \to dst$ path using at most $k$ stops, i.e., at most $k{+}1$ edges. Translate to either a bounded-edge shortest path (layered DP/Bellman--Ford) or a state-augmented Dijkstra with $(node,edges\_used)$.}
\ELI{Find the cheapest route from start to end if you are only allowed to change planes at most $k$ times.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, src, dst, k$; list $flights$ of triples $[u,v,w]$ with $u,v \in \{0,\ldots,n{-}1\}$, $u \ne v$, $w \in \{1,\ldots,10^4\}$. Valid ranges: $1 \le n \le 100$, $0 \le k < n$, $0 \le \lvert flights \rvert \le \tfrac{n(n-1)}{2}$.}
\OUTPUTS{An integer: the minimum total cost of a path from $src$ to $dst$ using at most $k$ stops (i.e., at most $k{+}1$ edges). If impossible, output $-1$.}
\SAMPLES{Example A: $n{=}3$, $flights{=}\bigl[[0,1,100],[1,2,100],[0,2,500]\bigr]$, $src{=}0$, $dst{=}2$, $k{=}1$ $\to 200$.\par Example B: $n{=}4$, $flights{=}\bigl[[0,1,100],[1,2,100],[2,3,200]\bigr]$, $src{=}0$, $dst{=}3$, $k{=}0$ $\to -1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Directed weighted graph $G=(V,E)$ with $\lvert V \rvert = n$, edges $E \subseteq V \times V$ with nonnegative weights $w:E \to \mathbb{R}_{\ge 0}$. Given $s{=}src$, $t{=}dst$, and $K{=}k$, find a path $P=(v_0,\ldots,v_m)$ with $v_0{=}s$, $v_m{=}t$, $m \le K{+}1$ minimizing total cost $\sum_{i=0}^{m-1} w(v_i,v_{i+1})$.}
\varmapStart
\var{n}{number of cities}
\var{E}{directed flights with weights}
\var{w(e)}{ticket price on edge $e$}
\var{s,t}{source and destination}
\var{K}{maximum allowed stops}
\var{m}{number of edges on path; constraint $m \le K{+}1$}
\varmapEnd
\GOVERN{
\[
\min_{(v_0,\ldots,v_m)}~ \sum_{i=0}^{m-1} w(v_i,v_{i+1})
\quad\text{s.t.}\quad
v_0=s,\ v_m=t,\ m \le K{+}1,\ (v_i,v_{i+1}) \in E~\forall i.
\]
}
\ASSUMPTIONS{All weights are nonnegative integers; no parallel edges; node indices are $0$-based; stops count intermediate nodes only, hence edges $\le K{+}1$.}
\INVARIANTS{(i) Relaxations never decrease costs below $0$. (ii) In layered DP, layer $r$ only depends on layer $r{-}1$, preventing paths with more than $r$ edges.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all simple paths up to $K{+}1$ edges from $s$ to $t$ and take the minimum cost. Use pruning by current best cost.}
\ASSUMPTIONS{Graph is small enough that exponential exploration with depth limit is feasible on tiny inputs; all weights are nonnegative so branch-and-bound by cost is sound.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency list from $flights$.
\item Depth-first search from $s$ with parameters $(u,edges\_used,cost)$ and a visited set to avoid cycles.
\item Stop recursing if $edges\_used > K{+}1$ or cost exceeds best known; update best on reaching $t$.
\end{algosteps}
\COMPLEXITY{Exponential in worst case. In the worst case $T(n) = O\!\bigl(b^{K+1}\bigr)$ where $b$ is branching factor; $S(n)=O(K)$ recursion depth plus $O(n)$ for visited.}
\[
\begin{aligned}
T(n) &\le \sum_{r=0}^{K+1} b^r \;=\; \frac{b^{K+2}-1}{b-1}\;=\;O\!\bigl(b^{K+1}\bigr).
\end{aligned}
\]
\CORRECTNESS{By exploring all paths with up to $K{+}1$ edges and tracking the minimum cost, the algorithm returns the optimal cost under the constraint. Pruning by best-so-far does not eliminate any potentially optimal path because costs are nonnegative.}
\EDGECASES{No outgoing edges from $s$; $k=0$; direct edge absent; graph with cycles; multiple routes with same cost.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Dict, Set

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]],
                          src: int, dst: int, k: int) -> int:
        # Build adjacency list
        adj: Dict[int, List[Tuple[int, int]]] = {i: [] for i in range(n)}
        for u, v, w in flights:
            adj[u].append((v, w))

        best = [float('inf')]

        def dfs(u: int, edges_used: int, cost: int, seen: Set[int]) -> None:
            if edges_used > k + 1:
                return
            if cost >= best[0]:
                return
            if u == dst:
                best[0] = cost
                return
            for v, w in adj[u]:
                if v in seen:
                    continue  # avoid cycles to keep search finite
                seen.add(v)
                dfs(v, edges_used + 1, cost + w, seen)
                seen.remove(v)

        seen: Set[int] = set([src])
        dfs(src, 0, 0, seen)
        return -1 if best[0] == float('inf') else int(best[0])

# Tiny baseline checks (on small inputs due to exponential nature)
sol = Solution()
assert sol.findCheapestPrice(3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 1) == 200
assert sol.findCheapestPrice(3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 0) == 500
assert sol.findCheapestPrice(4, [[0,1,100],[1,2,100],[2,3,200]], 0, 3, 0) == -1
\end{minted}
\VALIDATION{Validated on the three examples and a no-path scenario. This baseline is for understanding; not efficient for worst-case $n=100$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use $K{+}1$ rounds of Bellman--Ford style relaxations. Each round $r$ allows paths with at most $r$ edges.}
\ASSUMPTIONS{Nonnegative weights; at most $K{+}1$ relaxations needed; using a copy of the previous layer prevents overusing edges within the same round.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dist[v]=+\infty$ for all $v$, $dist[src]=0$.
\item Repeat $K{+}1$ times: set $next=dist$ copy; for each edge $(u,v,w)$ do $next[v] = \min(next[v], dist[u]+w)$.
\item After rounds, answer is $dist[dst]$ if finite; else $-1$.
\end{algosteps}
\COMPLEXITY{Each round scans all edges. Time $T(n)=O((K{+}1)\lvert E\rvert)$, space $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= (K{+}1)\cdot \lvert E\rvert, \quad S(n) = O(n).
\end{aligned}
\]
\CORRECTNESS{By induction on the number of edges, after $r$ rounds, $dist[v]$ is the minimum cost to reach $v$ using at most $r$ edges. The copy prevents using more than one edge per round. Thus after $K{+}1$ rounds we have the optimum under the constraint.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]],
                          src: int, dst: int, k: int) -> int:
        INF = 10**18
        dist = [INF] * n
        dist[src] = 0
        for _ in range(k + 1):
            nxt = dist[:]  # layer copy
            for u, v, w in flights:
                if dist[u] + w < nxt[v]:
                    nxt[v] = dist[u] + w
            dist = nxt
        return -1 if dist[dst] >= INF else int(dist[dst])

# Checks from the statement
sol = Solution()
assert sol.findCheapestPrice(
    4, [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], 0, 3, 1
) == 700
assert sol.findCheapestPrice(
    3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 1
) == 200
assert sol.findCheapestPrice(
    3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 0
) == 500
\end{minted}
\VALIDATION{This DP passes provided samples and naturally enforces the edge budget via rounds.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Run Dijkstra over a layered state space: states are $(v, e)$ where $v$ is a node and $e$ the number of edges used. Priority by cumulative cost; transitions add one edge until $e \le K{+}1$.}
\ASSUMPTIONS{Nonnegative weights ensure best-first expansion is safe. Using layers up to $K{+}1$ edges encodes the stop constraint.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency list.
\item Maintain $dist[v][e]$ = best cost to reach $v$ with exactly $e$ edges, initialized to $+\infty$, except $dist[src][0]=0$.
\item Use a min-heap of triples $(cost,u,e)$. Pop, early exit if $u{=}dst$. Relax neighbors $(u\to v)$ into layer $e{+}1$ if $e{+}1 \le K{+}1$ and cost improves.
\end{algosteps}
\OPTIMALITY{This is Dijkstra on an expanded DAG with $(K{+}2)\cdot n$ nodes and directed edges only from layer $e$ to $e{+}1$. Nonnegative weights guarantee that the first time we pop any $(dst, e)$ it is globally optimal given the layer constraint, hence optimal among all $e \le K{+}1$.}
\COMPLEXITY{Let $E=\lvert E\rvert$, $V=n$. Each real edge lifts to at most $K{+}1$ layer-edges.}
\[
\begin{aligned}
T(n) &= O\bigl((K{+}1)E \log((K{+}2)V)\bigr),\quad
S(n) = O\bigl((K{+}2)V + (K{+}1)E\bigr).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]],
                          src: int, dst: int, k: int) -> int:
        adj: List[List[Tuple[int,int]]] = [[] for _ in range(n)]
        for u, v, w in flights:
            adj[u].append((v, w))

        INF = 10**18
        max_edges = k + 1
        dist = [[INF] * (max_edges + 1) for _ in range(n)]
        dist[src][0] = 0
        pq: List[Tuple[int,int,int]] = [(0, src, 0)]  # (cost, node, edges_used)

        while pq:
            cost, u, e = heapq.heappop(pq)
            # If this is an outdated state, skip
            if cost != dist[u][e]:
                continue
            if u == dst:
                return cost  # optimal due to best-first on layered graph
            if e == max_edges:
                continue
            for v, w in adj[u]:
                nc = cost + w
                ne = e + 1
                if nc < dist[v][ne]:
                    dist[v][ne] = nc
                    heapq.heappush(pq, (nc, v, ne))

        # No path within k stops
        best = min(dist[dst])
        return -1 if best >= INF else int(best)

# Exactly 3 asserts
sol = Solution()
assert sol.findCheapestPrice(
    4, [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], 0, 3, 1
) == 700
assert sol.findCheapestPrice(
    3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 1
) == 200
assert sol.findCheapestPrice(
    3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 0
) == 500
\end{minted}
\VALIDATION{The heap-based solution returns the sample answers and is efficient for $n \le 100$.}
\RESULT{Returns the minimum price achievable with at most $k$ stops; if no such path, returns $-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on given samples; random small graphs comparing DP (Approach B) vs PQ (Approach C); adversarial cases: no edges, only direct edge, cycles, large $k$ that still cannot reach $dst$.}
\LINE{CROSS-CHECKS}{For small $n$ and $k$, Bellman--Ford layering and the PQ-layered Dijkstra must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate sparse/dense graphs, ensure no parallel edges, positive weights, and test various $k$ including $0$ and $n{-}1$.}
\begin{minted}{python}
from typing import List, Tuple
import random
import heapq

def bf_k_edges(n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
    INF = 10**18
    dist = [INF] * n
    dist[src] = 0
    for _ in range(k + 1):
        nxt = dist[:]
        for u, v, w in flights:
            if dist[u] + w < nxt[v]:
                nxt[v] = dist[u] + w
        dist = nxt
    return -1 if dist[dst] >= INF else int(dist[dst])

def pq_layered(n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
    adj: List[List[Tuple[int,int]]] = [[] for _ in range(n)]
    for u, v, w in flights:
        adj[u].append((v, w))
    INF = 10**18
    max_edges = k + 1
    dist = [[INF] * (max_edges + 1) for _ in range(n)]
    dist[src][0] = 0
    pq: List[Tuple[int,int,int]] = [(0, src, 0)]
    while pq:
        cost, u, e = heapq.heappop(pq)
        if cost != dist[u][e]:
            continue
        if u == dst:
            return cost
        if e == max_edges:
            continue
        for v, w in adj[u]:
            nc = cost + w
            ne = e + 1
            if nc < dist[v][ne]:
                dist[v][ne] = nc
                heapq.heappush(pq, (nc, v, ne))
    best = min(dist[dst])
    return -1 if best >= INF else int(best)

def gen_cases(seed: int = 7) -> List[Tuple[int, List[List[int]], int, int, int]]:
    random.seed(seed)
    cases = []
    for n in range(2, 8):
        nodes = list(range(n))
        # generate a DAG-ish set + some back edges to allow cycles
        edges = set()
        for u in range(n):
            for v in range(n):
                if u != v and random.random() < 0.3:
                    edges.add((u, v))
        flights = []
        for (u, v) in sorted(edges):
            w = random.randint(1, 20)
            flights.append([u, v, w])
        for _ in range(5):
            src = random.randrange(n)
            dst = random.randrange(n)
            while dst == src:
                dst = random.randrange(n)
            k = random.randrange(n)
            cases.append((n, flights, src, dst, k))
    return cases

def run_cross_checks():
    # Provided examples
    ex = [
        (4, [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], 0, 3, 1, 700),
        (3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 1, 200),
        (3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 0, 500),
    ]
    for n, fl, s, d, k, ans in ex:
        assert bf_k_edges(n, fl, s, d, k) == ans
        assert pq_layered(n, fl, s, d, k) == ans

    # Random cross-checks
    for (n, fl, s, d, k) in gen_cases():
        a = bf_k_edges(n, fl, s, d, k)
        b = pq_layered(n, fl, s, d, k)
        assert a == b, f"Mismatch: BF={a}, PQ={b}, n={n}, k={k}"

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]],
                          src: int, dst: int, k: int) -> int:
        adj: List[List[Tuple[int,int]]] = [[] for _ in range(n)]
        for u, v, w in flights:
            adj[u].append((v, w))
        INF = 10**18
        max_edges = k + 1
        dist = [[INF] * (max_edges + 1) for _ in range(n)]
        dist[src][0] = 0
        pq: List[Tuple[int,int,int]] = [(0, src, 0)]
        while pq:
            cost, u, e = heapq.heappop(pq)
            if cost != dist[u][e]:
                continue
            if u == dst:
                return cost
            if e == max_edges:
                continue
            for v, w in adj[u]:
                nc = cost + w
                ne = e + 1
                if nc < dist[v][ne]:
                    dist[v][ne] = nc
                    heapq.heappush(pq, (nc, v, ne))
        best = min(dist[dst])
        return -1 if best >= INF else int(best)

# Quick self-checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.findCheapestPrice(
        4, [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], 0, 3, 1
    ) == 700
    assert sol.findCheapestPrice(
        3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 1
    ) == 200
    assert sol.findCheapestPrice(
        3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 0
    ) == 500
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Bounded-edge shortest path: minimize cost $s \to t$ subject to at most $k$ stops (i.e., at most $k{+}1$ edges).}
\WHY{Shows up in interviews to test graph modeling, DP layering, and when to adapt Dijkstra with augmented state.}
\CHECKLIST{Model as directed weighted graph; translate stops to edge budget; pick method: Bellman--Ford $(K{+}1)$ rounds or layered Dijkstra; handle early exit and pruning; return $-1$ if unreachable.}
\EDGECASES{No path; $k{=}0$; multiple routes tie in cost; cycles; graph with edges only out of or into $dst$; $k \ge n{-}1$ effectively unbounded; disconnected components; large weights near $10^4$.}
\PITFALLS{Off-by-one: stops vs edges ($K$ vs $K{+}1$); forgetting to copy distances per round in Bellman--Ford; allowing same-round chained relaxations; premature visited pruning in PQ that discards better cost with more stops; not early-exiting on $dst$ in PQ; integer overflow in languages without big ints.}
\FAILMODES{Plain Dijkstra without state may fail the stop constraint; naive BFS by stops fails to account for weights; DFS without pruning explodes. Layered DP/PQ survives due to strict edge-budget enforcement.}
\ELI{Think of each extra stop as moving down one floor in a building of floors $0$ to $K{+}1$. We find the cheapest way to reach the destination on any floor up to $K{+}1$, either by dynamic programming floor-by-floor or by best-first search across floors.}
\NotePages{3}

\end{document}