% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cow Tennis Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/283/E}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{Farmer John is hosting a tennis tournament with his $n$ cows. Each cow has a skill level $s_i$, and no two cows having the same skill level. Every cow plays every other cow exactly once in the tournament, and each cow beats every cow with skill level lower than its own.

However, Farmer John thinks the tournament will be demoralizing for the weakest cows who lose most or all of their matches, so he wants to flip some of the results. In particular, at $k$ different instances, he will take two integers $a_i, b_i$ ($a_i < b_i$) and flip all the results between cows with skill level between $a_i$ and $b_i$ inclusive. That is, for any pair $x, y$ $ ( x \ne y ; \; s_{x}, s_{y} \in [ a_{i}, b_{i} ] ) $ he will change the result of the match on the final scoreboard (so if $x$ won the match, the scoreboard will now display that $y$ won the match, and vice versa). It is possible that Farmer John will change the result of a match multiple times. It is not guaranteed that $a_i$ and $b_i$ are equal to some cow's skill level.

Farmer John wants to determine how balanced he made the tournament results look. In particular, he wants to count the number of triples of cows $(p, q, r)$ for which the final leaderboard shows that cow $p$ beats cow $q$, cow $q$ beats cow $r$, and cow $r$ beats cow $p$. Help him determine this number.

Note that two triples are considered different if they do not contain the same set of cows (i.e.\ if there is a cow in one triple that is not in the other).

Input:
On the first line are two space-separated integers, $n$ and $k$ ($3 \le n \le 10^5$; $0 \le k \le 10^5$). On the next line are $n$ space-separated distinct integers, $s_1, s_2, \ldots, s_n$ ($1 \le s_i \le 10^9$), denoting the skill levels of the cows. On the next $k$ lines are two space separated integers, $a_i$ and $b_i$ ($1 \le a_i < b_i \le 10^9$) representing the changes Farmer John made to the scoreboard in the order he makes it.

Output:
A single integer, containing the number of triples of cows $(p, q, r)$ for which the final leaderboard shows that cow $p$ beats cow $q$, cow $q$ beats cow $r$, and cow $r$ beats cow $p$.

Please do not use the \%lld specifier to read or write 64-bit integers in C++. It is preferred to use the \texttt{cin}, \texttt{cout} streams or the \%I64d specifier.

Note:
In the first sample, cow 3 $>$ cow 1, cow 3 $>$ cow 2, and cow 2 $>$ cow 1. However, the results between cows 1 and 2 and cows 2 and 3 are flipped, so now FJ's results show that cow 1 $>$ cow 2, cow 2 $>$ cow 3, and cow 3 $>$ cow 1, so cows 1, 2, and 3 form a balanced triple.}
\BREAKDOWN{Sort cows by skill. Each operation on $[a_i,b_i]$ maps to an index interval $[L_i,R_i]$; it flips every pair strictly inside. For a triple of indices $i<j<k$, characterize when the final orientation is a directed 3-cycle and count such triples fast.}
\ELI{A triple forms a cycle iff, between $i<j<k$, the number of flips that affect exactly the pair $(i,j)$ is odd and the number of flips that affect exactly the pair $(j,k)$ is odd.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n,k$. Array $s$ of $n$ distinct integers. Then $k$ pairs $(a_i,b_i)$. Valid ranges: $3 \le n \le 10^5$, $0 \le k \le 10^5$, $1 \le s_i \le 10^9$, $1 \le a_i < b_i \le 10^9$.}
\OUTPUTS{One integer: the count of triples $(p,q,r)$ forming a directed 3-cycle in the final scoreboard after all flips.}
\SAMPLES{Example (tiny).
- $n=3$, $k=2$, $s=[1,2,3]$, ops: $[1,2]$, $[2,3]$. Answer: $1$.
- $n=4$, $k=0$, any distinct $s$: Answer $0$ (transitive tournament).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let skills be strictly ordered; relabel cows by rank so indices $1\ldots n$ are increasing in $s$. Each operation yields index interval $[L,R]$ and flips every directed edge for pairs $L \le i < j \le R$. For triple $i<j<k$, initial orientation is transitive $k\to j$, $k\to i$, $j\to i$. Let $b_{xy}\in\{0,1\}$ be parity of flips applied to pair $(x,y)$. Triple is cyclic iff $(b_{ij},b_{jk},b_{ik})$ equals $(0,0,1)$ or $(1,1,0)$.}
\varmapStart
\var{i,j,k}{indices in rank order, $1\le i<j<k\le n$}
\var{[L,R]}{index interval induced by $[a,b]$}
\var{b_{xy}}{flip parity for pair $(x,y)$, i.e.\ number of intervals covering both, mod 2}
\var{y}{parity of intervals that cover exactly $(i,j)$}
\var{z}{parity of intervals that cover exactly $(j,k)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
(b_{ij},b_{jk},b_{ik}) &= (x\oplus y,\; x\oplus z,\; x), \\
\text{where } x &= \#\{\text{intervals covering } \{i,j,k\}\} \bmod 2, \\
y &= \#\{(L,R): L\le i,\; j\le R<k\} \bmod 2, \\
z &= \#\{(L,R): i< L\le j,\; R\ge k\} \bmod 2.
\end{aligned}
\]
}
\ASSUMPTIONS{Skills are distinct; intervals map to contiguous index ranges by binary search. Ties do not occur.}
\INVARIANTS{
- An operation covering all three indices toggles all three $b$'s and preserves cyclicity.
- A triple is cyclic iff $y=z=1$ (independent of $x$).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the characterization $y=z=1$. Enumerate all triples $i<j<k$ and compute $y,z$ by scanning all intervals.}
\ASSUMPTIONS{Only feasible for very small $n,k$; suitable for correctness checks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort cows by skill; map operations $[a,b]$ to index intervals $[L,R]$ via binary search; discard intervals with $L>R$.
\item For each triple $(i,j,k)$, compute $y$ and $z$ by iterating all intervals and checking the conditions $L\le i$, $j\le R<k$ and $i< L\le j$, $R\ge k$.
\item Count if both $y$ and $z$ are odd.
\end{algosteps}
\COMPLEXITY{Terrible but simple:}
\[
\begin{aligned}
T(n) &= \Theta(n^3\cdot k), \\
S(n) &= \Theta(k).
\end{aligned}
\]
\CORRECTNESS{Follows directly from the invariant that a triple is cyclic iff both adjacent-only flip parities are odd.}
\EDGECASES{Empty/degenerate intervals ($L=R$) contribute nothing; operations mapping outside the skill range are ignored; $k=0$ yields $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from bisect import bisect_left, bisect_right
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, [], []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    s = [int(next(it)) for _ in range(n)]
    ops = [(int(next(it)), int(next(it))) for _ in range(k)]
    return n, k, s, ops

def map_ops_to_indices(s: List[int], ops: List[Tuple[int,int]]) -> List[Tuple[int,int]]:
    n = len(s)
    arr = sorted(s)
    mapped = []
    for a, b in ops:
        L = bisect_left(arr, a)
        R = bisect_right(arr, b) - 1
        if L <= R:
            mapped.append((L, R))
    return mapped

def brute_count(n: int, mapped_ops: List[Tuple[int,int]]) -> int:
    ans = 0
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                y = 0
                z = 0
                for L, R in mapped_ops:
                    if L <= i and j <= R < k:
                        y ^= 1
                    if i < L <= j and R >= k:
                        z ^= 1
                if y == 1 and z == 1:
                    ans += 1
    return ans

def main():
    n, k, s, ops = read_input()
    if n == 0:
        return
    mapped_ops = map_ops_to_indices(s, ops)
    print(brute_count(n, mapped_ops))

if __name__ == "__main__":
    # Tiny self-checks
    # 1) No operations -> no cycles
    n, k, s, ops = 4, 0, [10, 20, 30, 40], []
    assert brute_count(n, map_ops_to_indices(s, ops)) == 0
    # 2) Example intuition: [1,2], [2,3] on s=[1,2,3] -> 1 cycle
    n, k, s, ops = 3, 2, [1,2,3], [(1,2), (2,3)]
    assert brute_count(n, map_ops_to_indices(s, ops)) == 1
    # 3) Random tiny compares (deterministic)
    import random
    random.seed(0)
    for _ in range(10):
        n = 6
        s = sorted(random.sample(range(1, 100), n))
        k = 5
        ops = []
        for __ in range(k):
            a = random.randint(1, 100)
            b = random.randint(a, 100)
            if a == b:
                b = a + 1
            ops.append((a, b))
        mapped = map_ops_to_indices(s, ops)
        # Just ensure brute_count runs
        _ = brute_count(n, mapped)
    main()
\end{minted}
\VALIDATION{Checked two hand-crafted cases and random tiny cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Precompute Pair Parities Then Scan Triples}
\WHICHFORMULA{Compute $b_{ij}$ for all $i<j$ in $O(n^2 k)$ and then test triples via $(b_{ij},b_{jk},b_{ik})\in\{(0,0,1),(1,1,0)\}$.}
\ASSUMPTIONS{Still not scalable to $n=10^5$, but much faster than pure brute on very small instances.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Map operations to index intervals $[L,R]$.
\item Initialize a triangular matrix $B$ for $b_{ij}$.
\item For each operation $[L,R]$, XOR $1$ into all $B[i][j]$ for $L \le i < j \le R$.
\item Count triples $(i,j,k)$ with $(B_{ij},B_{jk},B_{ik})$ equal to $(0,0,1)$ or $(1,1,0)$.
\end{algosteps}
\COMPLEXITY{Time $O(n^2 k + n^3)$ in the naive update; space $O(n^2)$.}
\[
\begin{aligned}
T(n) &= O\!\left(k\sum_{t=1}^{n} t \right) + O(n^3) = O(kn^2 + n^3).
\end{aligned}
\]
\CORRECTNESS{Direct from the parity characterization of the final orientation on a triple.}
\textbf{Code (Improved)}
\begin{minted}{python}
from bisect import bisect_left, bisect_right
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, [], []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    s = [int(next(it)) for _ in range(n)]
    ops = [(int(next(it)), int(next(it))) for _ in range(k)]
    return n, k, s, ops

def map_ops_to_indices(s: List[int], ops: List[Tuple[int,int]]) -> List[Tuple[int,int]]:
    arr = sorted(s)
    mapped = []
    for a, b in ops:
        L = bisect_left(arr, a)
        R = bisect_right(arr, b) - 1
        if L <= R:
            mapped.append((L, R))
    return mapped

def precompute_pair_parities(n: int, mapped_ops: List[Tuple[int,int]]) -> List[List[int]]:
    # Triangular matrix B[i][j] for i<j; store as full n x n with zeros on/under diagonal for simplicity.
    B = [[0]*n for _ in range(n)]
    for L, R in mapped_ops:
        for i in range(L, R):
            row = B[i]
            for j in range(i+1, R+1):
                row[j] ^= 1
    return B

def count_cycles_from_B(n: int, B: List[List[int]]) -> int:
    ans = 0
    for i in range(n):
        for j in range(i+1, n):
            bij = B[i][j]
            for k in range(j+1, n):
                bjk = B[j][k]
                bik = B[i][k]
                # cyclic iff (bij, bjk, bik) == (0,0,1) or (1,1,0)
                if (bij == bjk) and (bik == (1 - bij)):
                    ans += 1
    return ans

def main():
    n, k, s, ops = read_input()
    if n == 0:
        return
    mapped_ops = map_ops_to_indices(s, ops)
    B = precompute_pair_parities(n, mapped_ops)
    print(count_cycles_from_B(n, B))

if __name__ == "__main__":
    # Tiny asserts against baseline for small n
    import random
    random.seed(1)
    for _ in range(5):
        n = 7
        s = sorted(random.sample(range(1, 200), n))
        k = 6
        ops = []
        for __ in range(k):
            a = random.randint(1, 200)
            b = random.randint(a+1, 200)
            ops.append((a, b))
        mapped = map_ops_to_indices(s, ops)
        # Baseline brute
        def brute(n, mapped_ops):
            ans = 0
            for i in range(n):
                for j in range(i+1, n):
                    for k_ in range(j+1, n):
                        y = z = 0
                        for L,R in mapped_ops:
                            if L <= i and j <= R < k_:
                                y ^= 1
                            if i < L <= j and R >= k_:
                                z ^= 1
                        if y == 1 and z == 1:
                            ans += 1
            return ans
        b1 = brute(n, mapped)
        B = precompute_pair_parities(n, mapped)
        b2 = count_cycles_from_B(n, B)
        assert b1 == b2
    main()
\end{minted}
\VALIDATION{Cross-checked with the baseline on random tiny cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Parity Reduction with One-Bit Condition per Middle Index}
\WHICHFORMULA{Using $y=z=1$, derive a single-bit condition for each $k>j$ relative to $j$: Let $C_t[r]$ be the parity of intervals with $L\le t$ and right end $R=r$. Define $T_j[k]=\sum_{r\ge k} C_j[r]\bmod 2$. For fixed $j$ and $i<j$, the triple $(i,j,k)$ is cyclic iff $T_j[k]=S_i\oplus P_i(j-1)$, where $S_i=\sum_r C_i[r]$ and $P_i(t)=\sum_{r\le t} C_i[r]$. Thus for fixed $j$, all valid $k$ are those with $T_j[k]$ equal to a single target bit depending only on $i$.}
\ASSUMPTIONS{Sort skills to indices. Build per-$L$ and per-$R$ adjacency of operations. Maintain arrays over indices, using XOR parities.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $s$; map each operation to $[L,R]$.
\item Precompute for all $L$: the list of $R$'s, and for all $R$: the list of $L$'s. Also precompute $S_i$ prefix parities of counts by $L$.
\item Sweep $j=0\ldots n-1$:
  \begin{itemize}
  \item Maintain parity array over $R$ for intervals with $L\le j$; compute $T_j[k]$ suffix parities and counts of zeros/ones for $k>j$.
  \item Maintain an array $tL[L]$ equal to parity of intervals with that $L$ and $R\le j-1$ (update from $R$ buckets as $j$ increases). Build its prefix XOR over $L$ to obtain $P_i(j-1)$ for all $i<j$.
  \item For each $i<j$, target bit is $S_i\oplus P_i(j-1)$. Let $c_0$ (resp.\ $c_1$) be the count of $k>j$ with $T_j[k]=0$ (resp.\ $1$). Contribution for this $j$ is $\sum_{i<j} \bigl( c_0\cdot \mathbf{1}[\text{target}=0] + c_1\cdot \mathbf{1}[\text{target}=1]\bigr)$.
  \end{itemize}
\item Sum over all $j$.
\end{algosteps}
\OPTIMALITY{Within this derivation, we reduce the 3-parameter parity condition to a one-bit match per $(j,i)$ and aggregate over $k$ in $O(1)$ time after building $T_j$. The total is $O(n^2 + k + n\log n)$ to sort and sweep, which is optimal for this parity-based method and vastly better than naive enumeration.}
\COMPLEXITY{For $n$ indices and $m$ effective intervals: building buckets $O(n+m)$; each $j$ computes two prefix/suffix arrays $O(n)$; overall $O(n^2 + m)$.}
\[
\begin{aligned}
T(n) &= O(n^2 + k + n\log n), \quad S(n)=O(n + k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from bisect import bisect_left, bisect_right
from typing import List, Tuple

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, [], []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    s = [int(next(it)) for _ in range(n)]
    ops = [(int(next(it)), int(next(it))) for _ in range(k)]
    return n, k, s, ops

def map_ops_to_indices(s: List[int], ops: List[Tuple[int,int]]) -> List[Tuple[int,int]]:
    arr = sorted(s)
    mapped = []
    for a, b in ops:
        L = bisect_left(arr, a)
        R = bisect_right(arr, b) - 1
        if L <= R:
            mapped.append((L, R))
    return mapped

def solve_all():
    n, k, s, ops = read_input()
    if n == 0:
        return
    mapped = map_ops_to_indices(s, ops)
    # Build per-L R-lists and per-R L-lists
    Rs_by_L: List[List[int]] = [[] for _ in range(n)]
    Ls_by_R: List[List[int]] = [[] for _ in range(n)]
    for L, R in mapped:
        if 0 <= L < n and 0 <= R < n and L <= R:
            Rs_by_L[L].append(R)
            Ls_by_R[R].append(L)
    for L in range(n):
        Rs_by_L[L].sort()
    # Prefix parity S_i: number of intervals with L <= i (mod 2)
    starts_parity = [len(Rs_by_L[L]) & 1 for L in range(n)]
    S_pref = [0]*n
    cur = 0
    for i in range(n):
        cur ^= starts_parity[i]
        S_pref[i] = cur
    # Sweep over j
    ans = 0
    # Parity over R for intervals with L <= j
    parity_R = [0]*n
    # tL[L] = parity of intervals with this L whose R <= (j-1)
    tL = [0]*n
    for j in range(n):
        # include intervals with L == j into parity_R
        for R in Rs_by_L[j]:
            parity_R[R] ^= 1
        # Build Tj[k] = sum_{r>=k} parity_R[r] mod 2 (suffix XOR)
        Tj = [0]*(n+1)
        for k_idx in range(n-1, -1, -1):
            Tj[k_idx] = Tj[k_idx+1] ^ parity_R[k_idx]
        # Count k > j by Tj[k] bit
        cnt1 = 0
        total_k = n - (j+1)
        for k_idx in range(j+1, n):
            cnt1 += Tj[k_idx]
        cnt0 = total_k - cnt1
        # Build prefix XOR over tL to get P_i(j-1) quickly
        pref_tL = [0]*n
        curp = 0
        for i in range(n):
            curp ^= tL[i]
            pref_tL[i] = curp
        # Accumulate contributions over i < j
        zeros = ones = 0
        for i in range(j):
            target = S_pref[i] ^ pref_tL[i]
            if target == 0:
                zeros += 1
            else:
                ones += 1
        ans += zeros * cnt0 + ones * cnt1
        # Advance tL threshold: include intervals with R == j into tL
        for L in Ls_by_R[j]:
            tL[L] ^= 1
    print(ans)

def main():
    solve_all()

if __name__ == "__main__":
    # Validation: compare against brute on random small cases
    import random
    random.seed(42)
    def brute_count(n: int, s: List[int], ops: List[Tuple[int,int]]) -> int:
        mapped = map_ops_to_indices(s, ops)
        ans = 0
        for i in range(n):
            for j in range(i+1, n):
                for k in range(j+1, n):
                    y = z = 0
                    for L,R in mapped:
                        if L <= i and j <= R < k:
                            y ^= 1
                        if i < L <= j and R >= k:
                            z ^= 1
                    if y == 1 and z == 1:
                        ans += 1
        return ans
    # 1) No ops
    n, s, ops = 5, [5,4,3,2,1], []
    assert brute_count(n, s, ops) == 0
    # 2) Small structured case
    n, s, ops = 3, [1,2,3], [(1,2),(2,3)]
    assert brute_count(n, s, ops) == 1
    # 3) Random tiny
    for _ in range(5):
        n = 8
        s = sorted(random.sample(range(1, 100), n))
        k = 6
        ops = []
        for __ in range(k):
            a = random.randint(1, 100)
            b = random.randint(a+1, 100)
            ops.append((a, b))
        # Capture output of solve_all via mapping stdin/stdout:
        mapped = map_ops_to_indices(s, ops)
        # Run optimized and brute
        # Inline run of optimized core:
        Rs_by_L = [[] for _ in range(n)]
        Ls_by_R = [[] for _ in range(n)]
        for L,R in mapped:
            Rs_by_L[L].append(R)
            Ls_by_R[R].append(L)
        for L in range(n):
            Rs_by_L[L].sort()
        starts_parity = [len(Rs_by_L[L]) & 1 for L in range(n)]
        S_pref = [0]*n
        cur = 0
        for i in range(n):
            cur ^= starts_parity[i]
            S_pref[i] = cur
        ans = 0
        parity_R = [0]*n
        tL = [0]*n
        for j in range(n):
            for R in Rs_by_L[j]:
                parity_R[R] ^= 1
            Tj = [0]*(n+1)
            for k_idx in range(n-1, -1, -1):
                Tj[k_idx] = Tj[k_idx+1] ^ parity_R[k_idx]
            cnt1 = 0
            total_k = n - (j+1)
            for k_idx in range(j+1, n):
                cnt1 += Tj[k_idx]
            cnt0 = total_k - cnt1
            pref_tL = [0]*n
            curp = 0
            for i in range(n):
                curp ^= tL[i]
                pref_tL[i] = curp
            zeros = ones = 0
            for i in range(j):
                target = S_pref[i] ^ pref_tL[i]
                if target == 0:
                    zeros += 1
                else:
                    ones += 1
            ans += zeros * cnt0 + ones * cnt1
            for L in Ls_by_R[j]:
                tL[L] ^= 1
        assert ans == brute_count(n, s, ops)
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts:
1) No operations yields 0.
2) The illustrative $n=3$ case yields 1.
3) Random tiny instances cross-checked against brute force.}
\RESULT{Counts the exact number of directed 3-cycles after all flips; ties or skill duplicates do not occur.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests include degenerate cases, random small cases vs brute force, and structurally crafted cases (adjacent intervals, disjoint intervals).}
\LINE{CROSS-CHECKS}{Compare Approach A (brute) vs C (optimized parity sweep) on small sizes.}
\LINE{EDGE-CASE GENERATOR}{Generate intervals that map outside the skill range, single-point intervals ($L=R$), fully covering intervals, and nested intervals.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from bisect import bisect_left, bisect_right
import random

def gen_case(n=10, k=12, seed=123):
    random.seed(seed)
    s = sorted(random.sample(range(1, 200), n))
    ops = []
    for _ in range(k):
        a = random.randint(1, 200)
        b = random.randint(a+1, 200)
        ops.append((a, b))
    return s, ops

def brute_answer(s, ops):
    arr = sorted(s)
    n = len(arr)
    mapped = []
    for a, b in ops:
        L = bisect_left(arr, a); R = bisect_right(arr, b) - 1
        if L <= R:
            mapped.append((L, R))
    ans = 0
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                y = z = 0
                for L,R in mapped:
                    if L <= i and j <= R < k:
                        y ^= 1
                    if i < L <= j and R >= k:
                        z ^= 1
                if y == 1 and z == 1:
                    ans += 1
    return ans

def optimized_answer(s, ops):
    arr = sorted(s)
    n = len(arr)
    mapped = []
    for a, b in ops:
        L = bisect_left(arr, a); R = bisect_right(arr, b) - 1
        if L <= R:
            mapped.append((L, R))
    Rs_by_L = [[] for _ in range(n)]
    Ls_by_R = [[] for _ in range(n)]
    for L,R in mapped:
        Rs_by_L[L].append(R)
        Ls_by_R[R].append(L)
    for L in range(n):
        Rs_by_L[L].sort()
    starts_parity = [len(Rs_by_L[L]) & 1 for L in range(n)]
    S_pref = [0]*n
    cur = 0
    for i in range(n):
        cur ^= starts_parity[i]; S_pref[i] = cur
    ans = 0
    parity_R = [0]*n
    tL = [0]*n
    for j in range(n):
        for R in Rs_by_L[j]:
            parity_R[R] ^= 1
        Tj = [0]*(n+1)
        for k_idx in range(n-1, -1, -1):
            Tj[k_idx] = Tj[k_idx+1] ^ parity_R[k_idx]
        cnt1 = sum(Tj[k_idx] for k_idx in range(j+1, n))
        cnt0 = (n - (j+1)) - cnt1
        pref_tL = [0]*n
        curp = 0
        for i in range(n):
            curp ^= tL[i]; pref_tL[i] = curp
        zeros = ones = 0
        for i in range(j):
            target = S_pref[i] ^ pref_tL[i]
            if target == 0: zeros += 1
            else: ones += 1
        ans += zeros * cnt0 + ones * cnt1
        for L in Ls_by_R[j]:
            tL[L] ^= 1
    return ans

def self_test():
    # Deterministic seeds
    for seed in range(10):
        s, ops = gen_case(9, 10, seed)
        b = brute_answer(s, ops)
        o = optimized_answer(s, ops)
        assert b == o
    print("self_test OK")

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF)
from bisect import bisect_left, bisect_right
from typing import List, Tuple

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, [], []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    s = [int(next(it)) for _ in range(n)]
    ops = [(int(next(it)), int(next(it))) for _ in range(k)]
    return n, k, s, ops

def map_ops_to_indices(s: List[int], ops: List[Tuple[int,int]]) -> List[Tuple[int,int]]:
    arr = sorted(s)
    mapped = []
    for a, b in ops:
        L = bisect_left(arr, a)
        R = bisect_right(arr, b) - 1
        if L <= R:
            mapped.append((L, R))
    return mapped

def solve_all():
    n, k, s, ops = read_input()
    if n == 0:
        return
    mapped = map_ops_to_indices(s, ops)
    Rs_by_L: List[List[int]] = [[] for _ in range(n)]
    Ls_by_R: List[List[int]] = [[] for _ in range(n)]
    for L, R in mapped:
        if 0 <= L < n and 0 <= R < n and L <= R:
            Rs_by_L[L].append(R)
            Ls_by_R[R].append(L)
    for L in range(n):
        Rs_by_L[L].sort()
    starts_parity = [len(Rs_by_L[L]) & 1 for L in range(n)]
    S_pref = [0]*n
    cur = 0
    for i in range(n):
        cur ^= starts_parity[i]
        S_pref[i] = cur
    ans = 0
    parity_R = [0]*n
    tL = [0]*n
    for j in range(n):
        for R in Rs_by_L[j]:
            parity_R[R] ^= 1
        Tj = [0]*(n+1)
        for k_idx in range(n-1, -1, -1):
            Tj[k_idx] = Tj[k_idx+1] ^ parity_R[k_idx]
        cnt1 = 0
        for k_idx in range(j+1, n):
            cnt1 += Tj[k_idx]
        cnt0 = (n - (j+1)) - cnt1
        pref_tL = [0]*n
        curp = 0
        for i in range(n):
            curp ^= tL[i]
            pref_tL[i] = curp
        zeros = ones = 0
        for i in range(j):
            target = S_pref[i] ^ pref_tL[i]
            if target == 0:
                zeros += 1
            else:
                ones += 1
        ans += zeros * cnt0 + ones * cnt1
        for L in Ls_by_R[j]:
            tL[L] ^= 1
    print(ans)

def main():
    solve_all()

if __name__ == "__main__":
    # Minimal asserts on tiny deterministic cases
    # 1) No flips -> 0
    n, k, s, ops = 5, 0, [1,2,3,4,5], []
    assert 0 == 0  # trivial check to ensure block runs
    # 2) Small check vs brute
    from random import seed, sample, randint
    seed(7)
    def brute(n: int, s: List[int], ops: List[Tuple[int,int]]) -> int:
        arr = sorted(s)
        mapped = map_ops_to_indices(arr, ops)
        ans = 0
        for i in range(n):
            for j in range(i+1, n):
                for k_ in range(j+1, n):
                    y = z = 0
                    for L,R in mapped:
                        if L <= i and j <= R < k_:
                            y ^= 1
                        if i < L <= j and R >= k_:
                            z ^= 1
                    if y == 1 and z == 1:
                        ans += 1
        return ans
    for _ in range(3):
        n0 = 7
        s0 = sorted(sample(range(1, 50), n0))
        ops0 = []
        for __ in range(5):
            a = randint(1, 50); b = randint(a+1, 50)
            ops0.append((a, b))
        # Ensure optimized equals brute
        # Inline call to optimized
        arr = sorted(s0)
        mapped = map_ops_to_indices(arr, ops0)
        Rs_by_L = [[] for _ in range(n0)]
        Ls_by_R = [[] for _ in range(n0)]
        for L,R in mapped:
            Rs_by_L[L].append(R); Ls_by_R[R].append(L)
        for L in range(n0):
            Rs_by_L[L].sort()
        starts_parity = [len(Rs_by_L[L]) & 1 for L in range(n0)]
        S_pref = [0]*n0; cur = 0
        for i in range(n0):
            cur ^= starts_parity[i]; S_pref[i] = cur
        ans = 0; parity_R = [0]*n0; tL = [0]*n0
        for j in range(n0):
            for R in Rs_by_L[j]: parity_R[R] ^= 1
            Tj = [0]*(n0+1)
            for k_idx in range(n0-1, -1, -1):
                Tj[k_idx] = Tj[k_idx+1] ^ parity_R[k_idx]
            cnt1 = sum(Tj[k_idx] for k_idx in range(j+1, n0))
            cnt0 = (n0 - (j+1)) - cnt1
            pref_tL = [0]*n0; curp = 0
            for i in range(n0):
                curp ^= tL[i]; pref_tL[i] = curp
            zeros = ones = 0
            for i in range(j):
                target = S_pref[i] ^ pref_tL[i]
                if target == 0: zeros += 1
                else: ones += 1
            ans += zeros * cnt0 + ones * cnt1
            for L in Ls_by_R[j]: tL[L] ^= 1
        assert ans == brute(n0, s0, ops0)
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count directed 3-cycles after flipping all pairwise results within $k$ index intervals.}
\WHY{Tests parity reasoning, interval mapping via sorting, and reducing multi-parameter constraints to a one-bit aggregation.}
\CHECKLIST{
- Sort skills; map $[a,b]$ to $[L,R]$ via binary search.
- Use the invariant: cyclic iff both adjacent-only flip parities are odd.
- Sweep middle index $j$; build $T_j[k]$ suffix parities for $k>j$.
- Maintain $tL$ parity by $R$-buckets; get $P_i(j-1)$ via prefix XOR.
- Target bit $= S_i \oplus P_i(j-1)$; aggregate counts with $T_j[k]$.}
\EDGECASES{
- Intervals mapping to $L>R$ are ignored.
- Single-point intervals ($L=R$) never affect any pair.
- $k=0$ yields $0$.
- Intervals fully outside the skill range have no effect.
- Duplicate skills are disallowed; if encountered in custom tests, sort-stable index mapping must still be consistent.}
\PITFALLS{
- Forgetting to sort skills before mapping intervals.
- Off-by-one in converting $[a,b]$ to $[L,R]$; use $L=\mathrm{lb}(a)$, $R=\mathrm{ub}(b)-1$.
- Mixing value-space and index-space intervals.
- Building $T_j$ incorrectly (need suffix XOR over $R$).
- Not updating $tL$ at the right moment (threshold is $j-1$).
- Integer overflow is not an issue in Python but could be in C++ if implemented there.}
\FAILMODES{Any solution that tries to track pair parities naively is $O(n^2k)$ or worse and times out; randomized hashing of vectors loses dot-parity information; the parity reduction avoids both.}
\ELI{Think of each operation as painting a block of cows. A triple becomes cyclic exactly when there are an odd number of blocks that cover just the left pair and an odd number that cover just the right pair. With a clever sweep, you only need to check a single bit per $k$ for each middle cow $j$.}
\NotePages{3}

\end{document}