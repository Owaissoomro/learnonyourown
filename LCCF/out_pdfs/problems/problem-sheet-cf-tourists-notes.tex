% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tourist's Notes}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/537/C}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{A tourist hiked along the mountain range. The hike lasted for $n$ days; during each day the tourist noted height above the sea level. On the $i$-th day, the height was equal to some integer $h_i$. The tourist picked a smooth enough route for the hike, meaning that between any two consecutive days the height changes by at most $1$, i.e., for all $i$ from $1$ to $n-1$ the inequality $\lvert h_i - h_{i+1} \rvert \le 1$ holds.

At the end of the route the tourist rafted down a mountain river and some notes in the journal were washed away. Moreover, the numbers in the notes could have been distorted. Now the tourist wonders what could be the maximum height during the hike. Help him restore the maximum possible value of the maximum height throughout the hike or determine that the notes were so much distorted that they do not represent any possible height values that meet limits $\lvert h_i - h_{i+1} \rvert \le 1$.

Input:
The first line contains two space-separated integers, $n$ and $m$ ($1 \le n \le 10^8$, $1 \le m \le 10^5$) — the number of days of the hike and the number of notes left in the journal.

Next $m$ lines contain two space-separated integers $d_i$ and $h_{d_i}$ ($1 \le d_i \le n$, $0 \le h_{d_i} \le 10^8$) — the day index when the $i$-th note was made and the height on day $d_i$. It is guaranteed that the notes are given in chronological order: for all $i$ from $1$ to $m-1$ we have $d_i < d_{i+1}$.

Output:
If the notes are not contradictory, print a single integer — the maximum possible height value throughout the whole route.

If the notes do not correspond to any set of heights, print a single word \texttt{IMPOSSIBLE} (without the quotes).

Note:
For the first sample, an example of a correct height sequence with a maximum of $2$: $(0, 0, 1, 2, 1, 1, 0, 1)$.

In the second sample the inequality between $h_7$ and $h_8$ does not hold; thus the information is inconsistent.}
\BREAKDOWN{Validate feasibility between every pair of consecutive notes under the slope-$1$ constraint; if feasible, compute the maximal attainable peak either inside some interval or at the prefix/suffix edges. Output that maximum.}
\ELI{Between notes you can climb at $+1$ per day and must end at the next note; any leftover days after matching the height difference allow a centered peak raising the maximum by half the slack.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integers $n$, $m$.
- Then $m$ lines with pairs $(d_i, h_{d_i})$, strictly increasing $d_i$.}
\OUTPUTS{A single line: either the integer maximum possible height over all $n$ days, or the word \texttt{IMPOSSIBLE}.}
\SAMPLES{Example 1:
- Input:
  8 3
  2 0
  4 2
  7 1
- Output:
  3

Explanation: Max inside $[d_1,d_2]$ is $\max(0,2) + \lfloor (2 - 2)/2 \rfloor = 2$; inside $[d_2,d_3]$ is $\max(2,1) + \lfloor (3 - 1)/2 \rfloor = 3$; prefix gives $0+1=1$; suffix gives $1+1=2$; overall $3$.

Example 2:
- Input:
  8 2
  7 3
  8 1
- Output:
  IMPOSSIBLE

Explanation: $\lvert 1 - 3 \rvert = 2 \nleq 1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n \in \mathbb{N}$, and constraints $(d_i, h_{d_i})$ with $1 \le d_1 < \cdots < d_m \le n$, find a sequence $(h_1,\ldots,h_n) \in \mathbb{Z}^n$ maximizing $\max_j h_j$ subject to:
- $\lvert h_{t+1} - h_t \rvert \le 1$ for all $t$,
- $h_{d_i} = h_{d_i}$ as given for each note.}
\varmapStart
\var{n}{number of days}
\var{m}{number of notes}
\var{(d_i,h_i)}{day index and noted height, strictly increasing $d_i$}
\var{\Delta d}{gap $d_{i+1}-d_i$}
\var{\Delta h}{height gap $\lvert h_{i+1}-h_i \rvert$}
\var{A}{answer: maximum achievable height}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Feasibility:}\quad & \Delta h \le \Delta d \quad \text{for all consecutive notes.}\\
\text{Peak inside }[d_i,d_{i+1}]:\quad & \max(h_i,h_{i+1}) + \left\lfloor \frac{\Delta d - \Delta h}{2} \right\rfloor.\\
\text{Prefix peak:}\quad & h_{d_1} + (d_1-1).\\
\text{Suffix peak:}\quad & h_{d_m} + (n - d_m).\\
A \;=\; & \max\Bigl(\text{prefix, suffix, all interval peaks}\Bigr).
\end{aligned}
\]
}
\ASSUMPTIONS{Heights between notes are unconstrained integers beyond the slope-$1$ bound; note heights are within $[0,10^8]$. The optimal construction can always realize the interval peak by symmetric ascent/descent centered within the slack days.}
\INVARIANTS{Between fixed endpoints $(d_i,h_i)$ and $(d_{i+1},h_{i+1})$, any feasible path must spend at least $\Delta h$ days to match the height difference; the remaining $\Delta d - \Delta h$ slack is distributed around the apex, giving a $\lfloor \tfrac{\text{slack}}{2} \rfloor$ boost over the higher endpoint.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly validate each consecutive pair and compute the interval peak formula, plus prefix/suffix maxima.}
\ASSUMPTIONS{Notes are provided sorted by $d_i$. Heights on non-noted days can be chosen arbitrarily to respect the slope constraint.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$, $m$, and the $m$ pairs $(d_i, h_i)$.
\item For each consecutive pair, compute $\Delta d$ and $\Delta h$; if $\Delta h > \Delta d$, print \texttt{IMPOSSIBLE}.
\item Track the maximum of: prefix $h_1 + (d_1-1)$, each interval peak $\max(h_i,h_{i+1}) + \lfloor \tfrac{\Delta d - \Delta h}{2} \rfloor$, and suffix $h_m + (n-d_m)$. Print the maximum. 
\end{algosteps}
\COMPLEXITY{Linear in the number of notes.}
\[
\begin{aligned}
T(m) &= \Theta(m), \\
S(m) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Feasibility is necessary and sufficient: if any pair violates the per-day slope bound, there is no valid sequence. Otherwise, within each interval, the tallest attainable height occurs at the centered apex obtained by using the slack days equally around the peak; edges allow monotone extension at slope $1$. Taking the maximum over all such candidates yields the global maximum.}
\EDGECASES{Single note ($m=1$); large gaps; equal heights; increasing/decreasing heights; prefix/suffix dominating the answer; potential duplicate $d_i$ (treat as infeasible unless heights equal and gap $0$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Optional

def read_input() -> Tuple[int, List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    m = int(next(it))
    notes: List[Tuple[int, int]] = []
    for _ in range(m):
        d = int(next(it)); h = int(next(it))
        notes.append((d, h))
    return n, notes

def compute_max_height(n: int, notes: List[Tuple[int, int]]) -> Optional[int]:
    if n <= 0 or not notes:
        return None
    # Ensure notes sorted and strictly increasing in day
    for i in range(len(notes) - 1):
        if not (notes[i][0] < notes[i + 1][0]):
            return None
    ans = -10**30
    d1, h1 = notes[0]
    # prefix
    ans = max(ans, h1 + (d1 - 1))
    # intervals
    for (d0, h0), (d1, h1) in zip(notes, notes[1:]):
        dd = d1 - d0
        dh = abs(h1 - h0)
        if dh > dd:
            return None
        peak = max(h0, h1) + (dd - dh) // 2
        ans = max(ans, peak)
    # suffix
    dm, hm = notes[-1]
    ans = max(ans, hm + (n - dm))
    return ans

def solve_case(n: int, notes: List[Tuple[int, int]]) -> str:
    res = compute_max_height(n, notes)
    return "IMPOSSIBLE" if res is None else str(res)

def solve_all() -> None:
    n, notes = read_input()
    if n == 0 and not notes:
        return
    print(solve_case(n, notes))

def main() -> None:
    solve_all()

if __name__ == "__main__":
    # Simple asserts (not executed by judges unless run locally)
    assert compute_max_height(8, [(2, 0), (4, 2), (7, 1)]) == 3
    assert compute_max_height(8, [(7, 3), (8, 1)]) is None
    assert compute_max_height(1, [(1, 0)]) == 0
    main()
\end{minted}
\VALIDATION{Checked two samples and a trivial case. Monotone cases and large gaps behave as expected.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Single Pass With Early Abort}
\WHICHFORMULA{Same formulas, but abort immediately on the first infeasible interval to avoid unnecessary work on large inputs.}
\ASSUMPTIONS{Streaming the input and processing on the fly suffices; maintain only previous note.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$, $m$.
\item Read the first note $(d_{\text{prev}}, h_{\text{prev}})$; set $ans = h_{\text{prev}} + (d_{\text{prev}} - 1)$.
\item For each next note $(d, h)$:
  - If $h - h_{\text{prev}} \gt d - d_{\text{prev}}$ in absolute value, print \texttt{IMPOSSIBLE} and exit.
  - Update $ans$ with interval peak and proceed; set previous to current.
\item After the loop, update $ans$ with the suffix $h_{\text{last}} + (n - d_{\text{last}})$ and print. 
\end{algosteps}
\COMPLEXITY{Same as baseline; improved constant factors and memory.}
\[
\begin{aligned}
T(m) &= \Theta(m), \quad S(m) = \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Identical to baseline; early abort does not change correctness since infeasibility is local and decisive.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import Tuple, Optional

def read_input() -> Tuple[int, int, Tuple[int, int], list]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, (0, 0), []
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    notes = []
    for _ in range(m):
        d = int(next(it)); h = int(next(it))
        notes.append((d, h))
    return n, m, notes[0] if m > 0 else (0, 0), notes

def solve_all() -> None:
    n, m, first, notes = read_input()
    if m == 0:
        return
    d_prev, h_prev = first
    # prefix
    ans = h_prev + (d_prev - 1)
    # intervals
    for i in range(1, m):
        d, h = notes[i]
        if d <= d_prev:
            print("IMPOSSIBLE")
            return
        dd = d - d_prev
        dh = abs(h - h_prev)
        if dh > dd:
            print("IMPOSSIBLE")
            return
        peak = max(h_prev, h) + (dd - dh) // 2
        if peak > ans:
            ans = peak
        d_prev, h_prev = d, h
    # suffix
    ans = max(ans, h_prev + (n - d_prev))
    print(ans)

def main() -> None:
    # Local asserts (not run by CF; here for completeness)
    def compute(n: int, notes: list) -> Optional[int]:
        if not notes:
            return None
        ans = notes[0][1] + (notes[0][0] - 1)
        for (d0, h0), (d1, h1) in zip(notes, notes[1:]):
            dd = d1 - d0
            if dd <= 0:
                return None
            dh = abs(h1 - h0)
            if dh > dd:
                return None
            ans = max(ans, max(h0, h1) + (dd - dh) // 2)
        ans = max(ans, notes[-1][1] + (n - notes[-1][0]))
        return ans
    assert compute(8, [(2, 0), (4, 2), (7, 1)]) == 3
    assert compute(8, [(7, 3), (8, 1)]) is None
    assert compute(5, [(3, 2)]) == 4
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts cover feasible multi-interval, infeasible adjacent notes, and single-note scenarios.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Greedy Peak Formula With Proof of Optimality}
\WHICHFORMULA{Use the necessary-and-sufficient feasibility check $\Delta h \le \Delta d$ and the tight peak formula $\max(h_i,h_{i+1}) + \lfloor \tfrac{\Delta d - \Delta h}{2} \rfloor$, combined with edge ramps.}
\ASSUMPTIONS{The per-day Lipschitz-$1$ constraint fully characterizes feasible paths between fixed endpoints; optimal peaks are obtained by symmetric slack usage.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $ans$ with prefix $h_{d_1} + (d_1 - 1)$.
\item For each adjacent pair $(d_i,h_i)$, $(d_{i+1},h_{i+1})$:
  - If $\lvert h_{i+1} - h_i \rvert > d_{i+1} - d_i$, return \texttt{IMPOSSIBLE}.
  - Update $ans$ with $\max(h_i,h_{i+1}) + \left\lfloor \tfrac{(d_{i+1}-d_i) - \lvert h_{i+1}-h_i \rvert}{2} \right\rfloor$.
\item Update $ans$ with suffix $h_{d_m} + (n - d_m)$ and print $ans$. 
\end{algosteps}
\OPTIMALITY{For any interval, the highest feasible path between endpoints is to ascend at slope $+1$ from the lower endpoint until reaching a centered apex, then descend at slope $-1$ to meet the higher endpoint; any deviation lowers the peak or violates feasibility. The peak height obtained is exactly the stated formula, which is tight. Prefix/suffix monotone ramps at slope $1$ are maximal given the fixed boundary values at $d_1$ and $d_m$. Therefore the maximum over all intervals and edges is globally optimal.}
\COMPLEXITY{Linear in $m$ with constant memory.}
\[
\begin{aligned}
T(m) &= \Theta(m), \quad S(m) = \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Optional

def read_input() -> Tuple[int, List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    notes: List[Tuple[int, int]] = []
    for _ in range(m):
        d = int(next(it)); h = int(next(it))
        notes.append((d, h))
    return n, notes

def compute_max_height(n: int, notes: List[Tuple[int, int]]) -> Optional[int]:
    # Assumes notes length >= 1
    ans = notes[0][1] + (notes[0][0] - 1)  # prefix
    for (d0, h0), (d1, h1) in zip(notes, notes[1:]):
        dd = d1 - d0
        if dd <= 0:
            return None
        dh = abs(h1 - h0)
        if dh > dd:
            return None
        ans = max(ans, max(h0, h1) + (dd - dh) // 2)
    # suffix
    ans = max(ans, notes[-1][1] + (n - notes[-1][0]))
    return ans

def solve_case(n: int, notes: List[Tuple[int, int]]) -> str:
    res = compute_max_height(n, notes)
    return "IMPOSSIBLE" if res is None else str(res)

def solve_all() -> None:
    n, notes = read_input()
    print(solve_case(n, notes))

def main() -> None:
    # Embedded unit checks (not executed by CF by default)
    def _t(n, notes, expect):
        got = compute_max_height(n, notes)
        assert (expect is None and got is None) or (got == expect), (got, expect)
    _t(8, [(2, 0), (4, 2), (7, 1)], 3)
    _t(8, [(7, 3), (8, 1)], None)
    _t(5, [(1, 2), (5, 4)], 4)
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts check: multi-interval feasible with interior peak, infeasible adjacent pair, and edge-dominated case.}
\RESULT{Print the maximum possible height over all $n$ days if feasible; otherwise print \texttt{IMPOSSIBLE}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test compute routine on: (a) increasing/decreasing/flat endpoints; (b) large slack vs tight intervals; (c) single-note cases; (d) infeasible note pairs; (e) dominance by prefix or suffix.}
\LINE{CROSS-CHECKS}{Randomly generate feasible pairs, compare Approach A/B/C outputs; they must match. Also verify that any violation of $\Delta h \le \Delta d$ is detected by all.}
\LINE{EDGE-CASE GENERATOR}{Generate random $m$, strictly increasing $d_i$, then sample $h_i$ and adjust to satisfy $\lvert h_{i+1}-h_i \rvert \le d_{i+1}-d_i$; optionally inject a single violation to test \texttt{IMPOSSIBLE}.}
\begin{minted}{python}
import random

def gen_feasible_case(n: int, m: int) -> tuple:
    days = sorted(random.sample(range(1, n + 1), m))
    hs = [random.randint(0, 10) for _ in range(m)]
    # Enforce feasibility by adjusting forward
    for i in range(1, m):
        dd = days[i] - days[i - 1]
        lo = hs[i - 1] - dd
        hi = hs[i - 1] + dd
        hs[i] = max(lo, min(hi, hs[i]))
    return n, list(zip(days, hs))

def gen_infeasible_case(n: int, m: int) -> tuple:
    n, notes = gen_feasible_case(n, m)
    if len(notes) >= 2:
        i = random.randrange(0, len(notes) - 1)
        d0, h0 = notes[i]; d1, h1 = notes[i + 1]
        # Force violation
        notes[i + 1] = (d1, h0 + (d1 - d0) + 10)
    return n, notes

def reference_solve(n: int, notes: list) -> str:
    def compute_max_height(n: int, notes: list):
        ans = notes[0][1] + (notes[0][0] - 1)
        for (d0, h0), (d1, h1) in zip(notes, notes[1:]):
            dd = d1 - d0
            if dd <= 0:
                return None
            dh = abs(h1 - h0)
            if dh > dd:
                return None
            ans = max(ans, max(h0, h1) + (dd - dh) // 2)
        ans = max(ans, notes[-1][1] + (n - notes[-1][0]))
        return ans
    res = compute_max_height(n, notes)
    return "IMPOSSIBLE" if res is None else str(res)

# Quick cross-check
for _ in range(50):
    n, notes = gen_feasible_case(50, random.randint(1, 10))
    out = reference_solve(n, notes)
    assert out != "IMPOSSIBLE"
for _ in range(10):
    n, notes = gen_infeasible_case(50, random.randint(2, 10))
    out = reference_solve(n, notes)
    assert out == "IMPOSSIBLE"
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Optional

def read_input() -> Tuple[int, List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    notes: List[Tuple[int, int]] = []
    for _ in range(m):
        d = int(next(it)); h = int(next(it))
        notes.append((d, h))
    return n, notes

def compute_max_height(n: int, notes: List[Tuple[int, int]]) -> Optional[int]:
    ans = notes[0][1] + (notes[0][0] - 1)
    for (d0, h0), (d1, h1) in zip(notes, notes[1:]):
        dd = d1 - d0
        if dd <= 0:
            return None
        dh = abs(h1 - h0)
        if dh > dd:
            return None
        ans = max(ans, max(h0, h1) + (dd - dh) // 2)
    ans = max(ans, notes[-1][1] + (n - notes[-1][0]))
    return ans

def solve_case(n: int, notes: List[Tuple[int, int]]) -> str:
    res = compute_max_height(n, notes)
    return "IMPOSSIBLE" if res is None else str(res)

def main() -> None:
    n, notes = read_input()
    print(solve_case(n, notes))

if __name__ == "__main__":
    # Non-intrusive sanity checks
    assert compute_max_height(8, [(2, 0), (4, 2), (7, 1)]) == 3
    assert compute_max_height(8, [(7, 3), (8, 1)]) is None
    assert compute_max_height(3, [(2, 1)]) == 2
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Check feasibility between notes ($\Delta h \le \Delta d$); answer is the max of prefix, suffix, and interval-peak formulas.}
\WHY{This is a classic constraint-satisfaction under a Lipschitz-$1$ bound, common in interview rounds for testing reasoning with bounds and local-global optimality.}
\CHECKLIST{
- Are $d_i$ strictly increasing?
- For every pair, is $\lvert h_{i+1}-h_i \rvert \le d_{i+1}-d_i$?
- Track prefix $h_{d_1} + (d_1 - 1)$.
- For each interval, update with $\max(h_i,h_{i+1}) + \lfloor \tfrac{\Delta d - \Delta h}{2} \rfloor$.
- Track suffix $h_{d_m} + (n - d_m)$.
- Take the maximum over all candidates.}
\EDGECASES{
- $m=1$ (answer from edges only).
- Very large gaps with equal endpoints (big interior peak).
- Tight gaps where $\Delta h = \Delta d$ (no interior boost).
- Non-monotone endpoint heights.
- $d_{i+1} = d_i + 1$ (adjacent days).
- Potential duplicate day indices (must be ruled infeasible if encountered).}
\PITFALLS{
- Forgetting to consider prefix/suffix.
- Off-by-one in prefix $(d_1-1)$ or suffix $(n-d_m)$.
- Using $\lceil \cdot \rceil$ instead of $\lfloor \cdot \rfloor$ for the slack split.
- Integer division mistakes.
- Not aborting on infeasible intervals.
- Assuming non-negativity on non-noted days (not required for maximizing the peak).}
\FAILMODES{Approaches that only consider endpoints miss tall interior peaks when there is slack. Greedy that always climbs to the next note may exceed slope bounds; our method respects bounds and attains the exact maximum.}
\ELI{You can only climb or descend one unit per day. Between two fixed heights $h_i$ and $h_{i+1}$, after using enough days to cover their difference, you can spend the extra days evenly around a peak. That gives a simple formula for the tallest possible point. Take the best among all intervals and edges.}
\NotePages{3}

\end{document}