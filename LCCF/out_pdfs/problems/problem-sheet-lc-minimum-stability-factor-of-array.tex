% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Stability Factor of Array}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-stability-factor-of-array/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an integer array \texttt{nums} and an integer \texttt{maxC}. A \textbf{subarray} is called \textbf{stable} if the \emph{highest common factor (HCF)} of all its elements is \textbf{greater than or equal to} 2. The \textbf{stability factor} of an array is defined as the length of its \textbf{longest} stable subarray. You may modify \textbf{at most} \texttt{maxC} elements of the array to any integer. Return the \textbf{minimum} possible stability factor of the array after at most \texttt{maxC} modifications. If no stable subarray remains, return 0.

\textbf{Note:}
\begin{bullets}
\item The \textbf{highest common factor (HCF)} of an array is the largest integer that evenly divides all the array elements.
\item A \textbf{subarray} of length 1 is stable if its only element is greater than or equal to 2, since \(\text{HCF}([x]) = x\).
\end{bullets}

\textbf{Example 1:}

\textbf{Input:} \(\text{nums} = [3,5,10],~\text{maxC} = 1\)

\textbf{Output:} 1

\textbf{Explanation:}
\begin{bullets}
\item The stable subarray \([5, 10]\) has \(\text{HCF} = 5\), which has a stability factor of 2.
\item Since \(\text{maxC} = 1\), one optimal strategy is to change \(\text{nums}[1]\) to \(7\), resulting in \(\text{nums} = [3, 7, 10]\).
\item Now, no subarray of length greater than 1 has \(\text{HCF} \ge 2\). Thus, the minimum possible stability factor is 1.
\end{bullets}

\textbf{Example 2:}

\textbf{Input:} \(\text{nums} = [2,6,8],~\text{maxC} = 2\)

\textbf{Output:} 1

\textbf{Explanation:}
\begin{bullets}
\item The subarray \([2, 6, 8]\) has \(\text{HCF} = 2\), which has a stability factor of 3.
\item Since \(\text{maxC} = 2\), one optimal strategy is to change \(\text{nums}[1]\) to 3 and \(\text{nums}[2]\) to 5, resulting in \(\text{nums} = [2, 3, 5]\).
\item Now, no subarray of length greater than 1 has \(\text{HCF} \ge 2\). Thus, the minimum possible stability factor is 1.
\end{bullets}

\textbf{Example 3:}

\textbf{Input:} \(\text{nums} = [2,4,9,6],~\text{maxC} = 1\)

\textbf{Output:} 2

\textbf{Explanation:}
\begin{bullets}
\item The stable subarrays are:
\begin{bullets}
\item \([2, 4]\) with \(\text{HCF} = 2\) and stability factor of 2.
\item \([9, 6]\) with \(\text{HCF} = 3\) and stability factor of 2.
\end{bullets}
\item Since \(\text{maxC} = 1\), the stability factor of 2 cannot be reduced due to two separate stable subarrays. Thus, the minimum possible stability factor is 2.
\end{bullets}

\textbf{Constraints:}
\begin{bullets}
\item \(1 \le n = \text{nums.length} \le 10^{5}\)
\item \(1 \le \text{nums}[i] \le 10^{9}\)
\item \(0 \le \text{maxC} \le n\)
\end{bullets}}
\BREAKDOWN{We must minimize the maximum length of a subarray whose gcd is at least 2 after at most \(\text{maxC}\) changes. A key equivalence: a window of length \(m\) is stable iff \(\gcd\) of the window is \(\ge 2\). For a target bound \(L\), it suffices and is necessary to destroy every stable window of length \(L{+}1\); any longer stable subarray contains such a subwindow. This reduces feasibility to an interval stabbing problem solved greedily, with gcd queries answered by a sparse table.}
\ELI{Binary search the answer \(L\). For each \(L\), mark every length-\(L{+}1\) window whose gcd \(\ge 2\); greedily change the rightmost element of each uncovered bad window. If we need at most \(\text{maxC}\) changes, \(L\) is feasible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function signature (LC): \texttt{def minStabilityFactor(self, nums: List[int], maxC: int) -\textgreater~int}. Here:
\begin{bullets}
\item \(\text{nums}\): list of \(n\) integers, \(1 \le n \le 10^{5}\), \(1 \le \text{nums}[i] \le 10^{9}\).
\item \(\text{maxC}\): integer, \(0 \le \text{maxC} \le n\).
\end{bullets}}
\OUTPUTS{An integer: the minimum possible stability factor (the length of the longest stable subarray) after at most \(\text{maxC}\) modifications.}
\SAMPLES{
\begin{bullets}
\item \(\text{nums}=[3,5,10],~\text{maxC}=1 \Rightarrow 1\).
\item \(\text{nums}=[2,4,9,6],~\text{maxC}=1 \Rightarrow 2\).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let \(a \in \mathbb{Z}_{\ge 1}^{n}\) be the array, \(k=\text{maxC}\). For an interval \(I=[\ell,r]\), define \(g(I)=\gcd(a[\ell],\ldots,a[r])\). A window \(I\) is stable iff \(g(I) \ge 2\). After modifying at most \(k\) positions arbitrarily, we wish to minimize \(\max\{|I| : g(I) \ge 2\}\). For a candidate \(L\), define \(m=L{+}1\) and the family of ``bad'' intervals
\begin{BreakableEquation*}
\mathcal{F}_{m} \coloneqq \{[\ell,\ell{+}m{-}1] : 1 \le \ell \le n{-}m{+}1,\; g([\ell,\ell{+}m{-}1]) \ge 2\}.
\end{BreakableEquation*}
We must pick a set of indices \(S \subseteq \{1,\ldots,n\}\) with \(|S| \le k\) that intersects every interval in \(\mathcal{F}_{m}\) (interval stabbing).}
\varmapStart
\var{n}{array length}
\var{k}{change budget \(\le n\)}
\var{a[i]}{array entries in \([1,10^{9}]\)}
\var{L}{candidate maximum stability factor after edits}
\var{m}{window size \(L{+}1\)}
\var{\mathcal{F}_{m}}{set of length-\(m\) stable windows}
\var{S}{index set of edits; must stab all intervals in \(\mathcal{F}_{m}\)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Feasible}(L) \iff \exists S \subseteq \{1,\ldots,n\},~|S|\le k,~\text{s.t.}~S \cap I \ne \emptyset~\forall I \in \mathcal{F}_{L+1}. \\
&\text{Answer} = \min\{L \in \{0,\ldots,n\} : \text{Feasible}(L)\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Windows are contiguous; gcd over integers is associative, commutative, idempotent. Replacing an index by 1 destroys stability of any window containing it.}
\INVARIANTS{
\begin{bullets}
\item If a window \(I\) is stable, every subwindow of \(I\) is also stable.
\item Stabbing all stable windows of a fixed length \(m\) eliminates all stable windows of any length \(\ge m\).
\item Greedy stabbing by right endpoints is optimal for interval families \(\mathcal{F}_{m}\) (sorted by nondecreasing right endpoints).
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Binary search on \(L\) with a feasibility check that destroys all stable windows of size \(m=L{+}1\). Compute gcd of each window naively in \(O(m)\) time and apply greedy stabbing on the resulting intervals.}
\ASSUMPTIONS{Small \(n\) or for correctness scaffolding; not efficient for \(n\) up to \(10^{5}\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Binary search \(L \in [0,n]\).
\item For fixed \(L\), set \(m=L{+}1\); enumerate windows \([\ell,\ell{+}m{-}1]\).
\item Compute window gcd by looping \(m\) elements; mark window as bad if gcd \(\ge 2\).
\item Greedy stabbing: iterate windows by increasing right endpoint, place a hit at the right endpoint if the current window is not already covered; count hits.
\item If hits \(\le k\), \(L\) is feasible; shrink search; else grow \(L\).
\end{algosteps}
\COMPLEXITY{Let \(W=n{-}m{+}1\) windows per check. Naively computing each gcd in \(O(m)\) time yields \(O(W\cdot m)=O(n\cdot m)\) per check; with \(O(\log n)\) checks overall \(O(n \cdot m \cdot \log n)\) in the worst case, up to \(O(n^{2}\log n)\).}
\[
\begin{aligned}
T(n) &\le \sum_{\text{BS iters}} O(n \cdot m) \le O(n^{2}\log n), \\
S(n) &= O(1) \text{ additional (besides input)}.
\end{aligned}
\]
\CORRECTNESS{By interval stabbing optimality, greedy using right endpoints yields the minimum number of edits required to eliminate all length-\(m\) stable windows. Eliminating all such windows eliminates all longer stable windows by the subwindow property of gcd. Binary search finds the minimum feasible \(L\).}
\EDGECASES{All ones (answer 0); all primes equal (long runs); \(k=0\); \(m>n\) (no windows, zero edits suffice).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from math import gcd
from typing import List

class Solution_Baseline:
    def minStabilityFactor(self, nums: List[int], maxC: int) -> int:
        n = len(nums)

        def feasible(L: int) -> bool:
            m = L + 1
            if m > n:
                return True
            hits = 0
            last_hit = -1  # index of last placed edit
            # windows [l, r] with r = l + m - 1
            for l in range(0, n - m + 1):
                r = l + m - 1
                # compute gcd of window [l, r] naively
                g = 0
                for i in range(l, r + 1):
                    g = gcd(g, nums[i])
                    if g == 1:
                        break
                if g >= 2 and last_hit < l:
                    # need to place an edit at r (greedy right endpoint)
                    hits += 1
                    last_hit = r
                    if hits > maxC:
                        return False
            return hits <= maxC

        # Binary search on L
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        return ans

# Quick asserts for sanity
if __name__ == "__main__":
    sb = Solution_Baseline()
    assert sb.minStabilityFactor([3,5,10], 1) == 1
    assert sb.minStabilityFactor([2,6,8], 2) == 1
    assert sb.minStabilityFactor([2,4,9,6], 1) == 2
\end{minted}
\VALIDATION{The asserts validate the three provided examples. For tiny arrays, this baseline agrees with the improved method shown later.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized GCD Queries via Sparse Table}
\WHICHFORMULA{Replace \(O(m)\) gcd per window with \(O(1)\) using a gcd sparse table. This drops each feasibility check to \(O(n)\).}
\ASSUMPTIONS{Gcd is idempotent: \(f(x,x)=x\) and associative; sparse table supports idempotent range queries in \(O(1)\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute \(\lfloor \log_{2} \rfloor\) and a gcd sparse table \(st[k][i]\) for ranges of length \(2^{k}\).
\item Binary search \(L\).
\item For fixed \(L\), set \(m=L{+}1\) and scan windows \([\ell,\ell{+}m{-}1]\).
\item Query \(\gcd\) by combining two overlapping blocks of length \(2^{\lfloor\log m\rfloor}\).
\item Greedy stabbing by right endpoints; count hits and compare to \(k\).
\end{algosteps}
\COMPLEXITY{Preprocessing \(O(n\log n)\). Each feasibility check \(O(n)\). Binary search multiplies by \(O(\log n)\).}
\[
\begin{aligned}
T(n) &= O(n\log n) + O(n\log n) = O(n\log n),\\
S(n) &= O(n\log n) \text{ for the sparse table}.
\end{aligned}
\]
\CORRECTNESS{Same correctness as baseline by the optimality of interval stabbing. Sparse table preserves exact gcd values; thus feasibility decisions are unchanged.}
\textbf{Code (Improved)}
\begin{minted}{python}
from math import gcd, log2
from typing import List

class Solution_Improved:
    def minStabilityFactor(self, nums: List[int], maxC: int) -> int:
        n = len(nums)
        if n == 0:
            return 0

        # Build logs
        logs = [0] * (n + 1)
        for i in range(2, n + 1):
            logs[i] = logs[i // 2] + 1

        K = logs[n] + 1
        st = [[0] * n for _ in range(K)]
        st[0] = nums[:]  # length 1 blocks
        for k in range(1, K):
            span = 1 << k
            half = span >> 1
            for i in range(0, n - span + 1):
                st[k][i] = gcd(st[k - 1][i], st[k - 1][i + half])

        def range_gcd(l: int, r: int) -> int:
            length = r - l + 1
            k = logs[length]
            span = 1 << k
            return gcd(st[k][l], st[k][r - span + 1])

        def feasible(L: int) -> bool:
            m = L + 1
            if m > n:
                return True
            hits = 0
            last_hit = -1
            for l in range(0, n - m + 1):
                r = l + m - 1
                if range_gcd(l, r) >= 2 and last_hit < l:
                    hits += 1
                    last_hit = r
                    if hits > maxC:
                        return False
            return True

        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        return ans

# Checks on edge inputs
if __name__ == "__main__":
    si = Solution_Improved()
    assert si.minStabilityFactor([3,5,10], 1) == 1
    assert si.minStabilityFactor([2,6,8], 2) == 1
    assert si.minStabilityFactor([2,4,9,6], 1) == 2
    # all ones -> already no stable subarray
    assert si.minStabilityFactor([1,1,1], 0) == 0
\end{minted}
\VALIDATION{Covers provided examples and a degenerate all-ones case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Binary Search + Interval Stabbing on Stable Windows}
\WHICHFORMULA{Feasibility for a target \(L\) reduces exactly to hitting all length-\(L{+}1\) windows with gcd \(\ge 2\). These are intervals on a line; minimum hitting set is solved optimally by greedy picking right endpoints. Gcd queries are answered in \(O(1)\) via a sparse table.}
\ASSUMPTIONS{gcd sparse table correctness; interval stabbing greedy optimality for intervals sorted by right endpoints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute gcd sparse table in \(O(n\log n)\).
\item Binary search \(L \in [0,n]\).
\item For each \(L\), let \(m=L{+}1\). Scan \(\ell=0\) to \(n-m\):
\begin{bullets}
\item If \(\gcd([\ell,\ell{+}m{-}1]) \ge 2\) and current hit index \(< \ell\), place a hit at \(r=\ell{+}m{-}1\), increment hits.
\end{bullets}
\item If hits \(\le k\), feasible; otherwise infeasible.
\item Return the smallest feasible \(L\).
\end{algosteps}
\OPTIMALITY{Any stable subarray of length \(\ge m\) contains a stable subwindow of length \(m\); thus stabbing all stable length-\(m\) windows eliminates all longer stable subarrays. For intervals on a line, the greedy by right endpoints achieves the minimum number of points needed to hit all intervals; hence we minimize required edits exactly. Binary search yields the minimal \(L\).}
\COMPLEXITY{Preprocessing \(O(n\log n)\); each feasibility scan \(O(n)\); overall \(O(n\log n)\) time and \(O(n\log n)\) space.}
\[
\begin{aligned}
T(n) &= O(n\log n) + O(n\log n) = O(n\log n), \\
S(n) &= O(n\log n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from math import gcd
from typing import List

class Solution:
    def minStabilityFactor(self, nums: List[int], maxC: int) -> int:
        n = len(nums)
        if n == 0:
            return 0

        # Precompute floor logs
        logs = [0] * (n + 1)
        for i in range(2, n + 1):
            logs[i] = logs[i // 2] + 1

        K = logs[n] + 1
        # Build gcd sparse table
        st = [[0] * n for _ in range(K)]
        st[0] = nums[:]  # intervals of length 1
        for k in range(1, K):
            span = 1 << k
            half = span >> 1
            # Only fill valid starts
            lim = n - span + 1
            row_prev = st[k - 1]
            row_cur = st[k]
            for i in range(lim):
                row_cur[i] = gcd(row_prev[i], row_prev[i + half])

        def range_gcd(l: int, r: int) -> int:
            length = r - l + 1
            k = logs[length]
            span = 1 << k
            return gcd(st[k][l], st[k][r - span + 1])

        def feasible(L: int) -> bool:
            m = L + 1
            if m > n:
                return True  # vacuously no windows to break
            hits = 0
            last_hit = -1
            # Enumerate windows in increasing right endpoint
            for l in range(0, n - m + 1):
                r = l + m - 1
                if range_gcd(l, r) >= 2 and last_hit < l:
                    hits += 1
                    last_hit = r
                    if hits > maxC:
                        return False
            return True

        # Binary search the minimal feasible L
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        return ans

# Exact 3 asserts (I/O mini-tests)
if __name__ == "__main__":
    s = Solution()
    assert s.minStabilityFactor([3,5,10], 1) == 1
    assert s.minStabilityFactor([2,6,8], 2) == 1
    assert s.minStabilityFactor([2,4,9,6], 1) == 2
\end{minted}
\VALIDATION{Three asserts cover all examples verbatim.}
\RESULT{Returns the minimum possible length of the longest stable subarray after at most \(\text{maxC}\) edits. If all stable subarrays can be eliminated, returns 0.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on given examples; random small arrays cross-checking baseline vs optimal; edge cases: all ones, all equal primes, alternating coprime pairs, \(k=0\), \(k=n\).}
\LINE{CROSS-CHECKS}{For small \(n\le 60\), compare \texttt{Solution\_Baseline} and \texttt{Solution} results over random seeds to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Produces arrays of 1s, all same even number, and random in \([1,50]\); varies \(k\) from 0 to \(n\).}
\begin{minted}{python}
from random import randint, seed
from math import gcd
from typing import List

# Reuse prior classes
class Solution_Baseline:
    def minStabilityFactor(self, nums: List[int], maxC: int) -> int:
        n = len(nums)
        def feasible(L: int) -> bool:
            m = L + 1
            if m > n:
                return True
            hits = 0
            last_hit = -1
            for l in range(0, n - m + 1):
                r = l + m - 1
                g = 0
                for i in range(l, r + 1):
                    g = gcd(g, nums[i])
                    if g == 1:
                        break
                if g >= 2 and last_hit < l:
                    hits += 1
                    last_hit = r
                    if hits > maxC:
                        return False
            return True
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        return ans

class Solution:
    def minStabilityFactor(self, nums: List[int], maxC: int) -> int:
        n = len(nums)
        if n == 0:
            return 0
        logs = [0] * (n + 1)
        for i in range(2, n + 1):
            logs[i] = logs[i // 2] + 1
        K = logs[n] + 1
        st = [[0] * n for _ in range(K)]
        st[0] = nums[:]
        for k in range(1, K):
            span = 1 << k
            half = span >> 1
            lim = n - span + 1
            for i in range(lim):
                st[k][i] = gcd(st[k - 1][i], st[k - 1][i + half])
        def range_gcd(l: int, r: int) -> int:
            length = r - l + 1
            k = logs[length]
            span = 1 << k
            return gcd(st[k][l], st[k][r - span + 1])
        def feasible(L: int) -> bool:
            m = L + 1
            if m > n:
                return True
            hits = 0
            last_hit = -1
            for l in range(0, n - m + 1):
                r = l + m - 1
                if range_gcd(l, r) >= 2 and last_hit < l:
                    hits += 1
                    last_hit = r
                    if hits > maxC:
                        return False
            return True
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        return ans

def cross_check():
    sb = Solution_Baseline()
    so = Solution()
    seed(0)
    for n in range(1, 31):
        for _ in range(40):
            nums = [randint(1, 50) for _ in range(n)]
            for k in (0, 1, n // 2, n):
                a = sb.minStabilityFactor(nums, k)
                b = so.minStabilityFactor(nums, k)
                assert a == b, (n, nums, k, a, b)

if __name__ == "__main__":
    # Directed tests
    so = Solution()
    assert so.minStabilityFactor([3,5,10], 1) == 1
    assert so.minStabilityFactor([2,6,8], 2) == 1
    assert so.minStabilityFactor([2,4,9,6], 1) == 2
    # Stress small cross-checks
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from math import gcd
from typing import List

class Solution:
    def minStabilityFactor(self, nums: List[int], maxC: int) -> int:
        n = len(nums)
        if n == 0:
            return 0

        # Precompute floor logs
        logs = [0] * (n + 1)
        for i in range(2, n + 1):
            logs[i] = logs[i // 2] + 1

        # Build gcd sparse table
        K = logs[n] + 1
        st = [[0] * n for _ in range(K)]
        st[0] = nums[:]
        for k in range(1, K):
            span = 1 << k
            half = span >> 1
            lim = n - span + 1
            row_prev = st[k - 1]
            row_cur = st[k]
            for i in range(lim):
                row_cur[i] = gcd(row_prev[i], row_prev[i + half])

        def range_gcd(l: int, r: int) -> int:
            length = r - l + 1
            k = logs[length]
            span = 1 << k
            return gcd(st[k][l], st[k][r - span + 1])

        def feasible(L: int) -> bool:
            m = L + 1
            if m > n:
                return True
            hits = 0
            last_hit = -1
            for l in range(0, n - m + 1):
                r = l + m - 1
                if range_gcd(l, r) >= 2 and last_hit < l:
                    hits += 1
                    last_hit = r
                    if hits > maxC:
                        return False
            return True

        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        return ans

# Simple self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.minStabilityFactor([3,5,10], 1) == 1
    assert s.minStabilityFactor([2,6,8], 2) == 1
    assert s.minStabilityFactor([2,4,9,6], 1) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize the longest stable subarray length by stabbing all length-\(L{+}1\) windows with gcd \(\ge 2\) using the fewest edits; binary search the minimal feasible \(L\).}
\WHY{Transforms a gcd subarray property into a classic interval stabbing problem, enabling an optimal greedy under a fast range-gcd data structure—bread-and-butter hard interview reduction.}
\CHECKLIST{
\begin{bullets}
\item Observe: stable iff window gcd \(\ge 2\).
\item For target \(L\), consider windows of length \(L{+}1\).
\item Build gcd sparse table.
\item Greedy stabbing by right endpoints; count hits.
\item Binary search minimal feasible \(L\).
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item \(m=L{+}1>n\): zero windows; always feasible.
\item \(L=0\): must edit every element \(\ge 2\) to kill length-1 stability.
\item All ones: answer \(0\) regardless of \(k\).
\item All equal even values: initial answer \(n\); with budget \(k\), minimal \(L\) satisfies \(\lfloor n/(L{+}1)\rfloor \le k\).
\item \(k=0\): answer is the initial maximum stable window length.
\item Large primes: windows still handled by gcd without explicit factorization.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Trying to maintain sliding gcd by subtracting the left value (not invertible).
\item Overcounting edits by stabbing each bad window without greedy consolidation.
\item Mixing 0-based and 1-based indices in window bounds.
\item Not handling \(m>n\) early exit.
\item Sparse table limits: only fill valid starts \(i \le n-2^{k}\).
\item Forgetting that killing all length-\(m\) windows suffices to kill longer ones.
\end{bullets}}
\FAILMODES{Approaches that attempt per-prime run breaking overcount edits because one edit can kill multiple primes; interval stabbing on gcd-based windows avoids this and is exact.}
\ELI{We only need to break every fixed-size window whose gcd is at least 2. Those windows are just intervals; the fewest edits to break them all is a classic greedy. By trying different window sizes via binary search, we find the smallest maximum stable length we can force within the edit budget.}
\NotePages{3}

\end{document}