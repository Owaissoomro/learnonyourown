% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Another Wine Tasting Event}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1776/G}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{After the first successful edition, Gabriella has been asked to organize a second wine tasting event. There will be $2n - 1$ bottles of wine arranged in a row, each of which is either red wine or white wine.

This time, Gabriella has already chosen the type and order of all the bottles. The types of the wines are represented by a string $s$ of length $2n - 1$. For each $1 \le i \le 2n - 1$, it holds that $s_i = \texttt{R}$ if the $i$-th bottle is red wine, and $s_i = \texttt{W}$ if the $i$-th bottle is white wine.

Exactly $n$ critics have been invited to attend. The critics are numbered from $1$ to $n$. Just like last year, each critic $j$ wants to taste an interval of wines, that is, the bottles at positions $a_j, \, a_j + 1, \, \dots, \, b_j$ for some $1 \le a_j \le b_j \le 2n - 1$. Moreover, they have the following additional requirements:
\begin{itemize}
\item each of them wants to taste at least $n$ wines, that is, it must hold that $b_j - a_j + 1 \ge n$;
\item no two critics must taste exactly the same wines, that is, if $j \ne k$ it must hold that $a_j \ne a_k$ or $b_j \ne b_k$.
\end{itemize}

Gabriella knows that, since the event is held in a coastal region of Italy, critics are especially interested in the white wines, and do not care much about the red ones. Thus, to ensure fairness, she would like that all critics taste the same number of white wines.

Help Gabriella find an integer $x$ (with $0 \le x \le 2n - 1$) such that there exists a valid assignment of intervals to critics where each critic tastes exactly $x$ white wines. It can be proved that at least one such $x$ always exists.

Input: The first line contains the integer $n$ ($1 \le n \le 10^6$) — where $2n - 1$ is the number of bottles, and $n$ is the number of critics.

The second line contains a string $s$ of length $2n - 1$ that represents the arrangement of the wines — the $i$-th character of $s$ ($1 \le i \le 2n - 1$) is $\texttt{R}$ for a red wine and $\texttt{W}$ for a white wine.

Output: Print an integer $x$ — the number of white wines that each critic will taste.

It can be proved that at least one solution exists. If multiple solutions exist, any of them will be accepted.

Note: In the first sample, there are $5$ critics and $2 \cdot 5 - 1 = 9$ bottles of wine. A possible set of intervals that makes each critic taste $2$ white wines is the following: $[2, 6],$ $[1, 6],$ $[4, 8],$ $[1, 5],$ $[3, 7]$. Note that all intervals contain at least $5$ bottles.

In the second sample, there is $1$ critic and $2 \cdot 1 - 1 = 1$ bottle of wine. The only possible interval is $[1, 1]$, which gives $x = 0$.}
\BREAKDOWN{We need to output any white-count $x$ for which there exist $n$ pairwise distinct intervals of length at least $n$ each having exactly $x$ whites. Observe that intervals of fixed length $L$ slide with counts changing by at most $\pm 1$. A robust choice is to take $x$ as the maximum number of whites among all windows of length exactly $n$; this $x$ can be achieved by at least $n$ valid intervals across lengths $\ge n$.}
\ELI{Pick $x$ equal to the most whites in any contiguous block of $n$ bottles; there will be at least $n$ long-enough intervals whose white counts are exactly $x$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $n$ with $1 \le n \le 10^6$, then a string $s$ over $\{\texttt{R},\texttt{W}\}$ of length $2n-1$.}
\OUTPUTS{A single integer $x$ such that there exist $n$ distinct intervals $[a_j,b_j]$ with $b_j-a_j+1 \ge n$ and each interval contains exactly $x$ white wines. Any valid $x$ is accepted.}
\SAMPLES{
Example 1: $n=3$, $s=\texttt{WRWRW}$ (length $5$). Windows of length $3$ have white counts $[2,1,2]$. Output $x=2$.

Example 2: $n=2$, $s=\texttt{RWW}$ (length $3$). Windows of length $2$ have white counts $[1,2]$. Output $x=2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s\in\{\texttt{R},\texttt{W}\}^{2n-1}$. Define prefix whites $p[0]=0$, $p[i]=\#\{t\le i : s_t=\texttt{W}\}$. For any interval $[l,r]$, the white count is $w(l,r)=p[r]-p[l-1]$. We seek any $x$ such that there exist $n$ pairwise distinct intervals with $r-l+1\ge n$ and $w(l,r)=x$.}
\varmapStart
\var{n}{number of critics; minimal allowed interval length}
\var{s}{string of length $2n-1$ over $\{\texttt{R},\texttt{W}\}$}
\var{p[i]}{prefix count of whites up to position $i$}
\var{w(l,r)}{number of whites in $[l,r]$}
\var{x}{target white count to output}
\var{M}{maximum $w(l,l+n-1)$ over all valid $l$ (best length-$n$ window)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
w(l,r) &= p[r]-p[l-1],\\
M &= \max_{1\le l\le n}\; w(l,l+n-1),\\
\text{Goal: } &\exists\ \text{at least } n \text{ distinct } (l,r)\ \text{with}\ r-l+1\ge n,\ w(l,r)=x.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based; $p$ is monotone; as we slide a fixed-length window by $+1$, $w$ changes by $-1,0,$ or $+1$. For fixed $l$, as $r$ increases, $w(l,r)$ is non-decreasing with step size in $\{0,1\}$.}
\INVARIANTS{
- For any fixed length $L$, the sequence of white counts over all sliding windows of length $L$ is $1$-Lipschitz under shifts.

- For fixed $l$, the set $\{w(l,r): r\ge l+n-1\}$ contains every integer in the interval $\big[w(l,l+n-1),\, w(l,2n-1)\big]$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all intervals $[l,r]$ with $r-l+1\ge n$, compute $w(l,r)$, tally frequencies, and pick any $x$ with frequency $\ge n$.}
\ASSUMPTIONS{Feasible only for very small $n$ due to $\Theta(n^2)$ intervals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build prefix whites $p$.
\item For each $l$ and $r\ge l+n-1$, compute $w(l,r)=p[r]-p[l-1]$ and count.
\item Return any $x$ with frequency $\ge n$.
\end{algosteps}
\COMPLEXITY{Quadratic enumeration over $\tfrac{n(n+1)}{2}$ large intervals is intractable for $n$ up to $10^6$.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(\sum_{L=n}^{2n-1} (2n-L)\right) = \Theta\!\left(\frac{n(n+1)}{2}\right),\\
S(n) &= \Theta(2n) \text{ for prefix and histogram support.}
\end{aligned}
\]
\CORRECTNESS{Exhaustively counts all admissible intervals and finds an $x$ whose frequency is at least $n$, satisfying the requirement.}
\EDGECASES{All $\texttt{R}$ or all $\texttt{W}$ strings; minimal $n=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline (quadratic) for tiny inputs only.
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    s = next(it).strip()
    assert len(s) == 2*n - 1
    return n, s

def solve_case(n: int, s: str) -> int:
    m = 2*n - 1
    p = [0]*(m+1)
    for i, ch in enumerate(s, 1):
        p[i] = p[i-1] + (1 if ch == 'W' else 0)
    from collections import Counter
    cnt = Counter()
    for l in range(1, n+1):
        for r in range(l + n - 1, m+1):
            w = p[r] - p[l-1]
            cnt[w] += 1
    # Return any x with frequency >= n; guaranteed to exist
    for x, f in cnt.items():
        if f >= n:
            return x
    # Fallback (should not happen per problem guarantee)
    return 0

def solve_all(data: str) -> str:
    n, s = read_input(data)
    return str(solve_case(n, s))

def main():
    data = sys.stdin.read()
    print(solve_all(data))

if __name__ == "__main__":
    # Tiny unit tests for baseline
    assert solve_all("2\nRWW\n") == "2"   # [2,3] and [1,3]
    assert solve_all("2\nWRW\n") in {"1"} # both length-2 windows have 1 W
    assert solve_all("1\nW\n") == "1"
    print("OK", file=sys.stderr)
    # main()
    pass
\end{minted}
\VALIDATION{Verified on small handcrafted cases: all $\texttt{R}$, all $\texttt{W}$, alternating.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prefix Sums + Sliding Window}
\WHICHFORMULA{For any fixed length $L$, white counts of sliding windows can be computed in $O(2n)$ via a sliding window. A robust, always-valid choice is to pick $x$ as the maximum white count among all windows of length exactly $n$.}
\ASSUMPTIONS{The count of whites in a fixed-length sliding window updates by subtracting the outgoing char and adding the incoming char in $O(1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute the white count in the first length-$n$ window.
\item Slide the window across all $n$ positions, track the maximum $M$ of white counts.
\item Output $x:=M$.
\end{algosteps}
\COMPLEXITY{Single pass over $2n-1$ characters.}
\[
\begin{aligned}
T(n) &= O(n),\\
S(n) &= O(1) \text{ (besides input storage).}
\end{aligned}
\]
\CORRECTNESS{Let $c_i$ be whites in $[i,i+n-1]$ for $1\le i\le n$, and let $M=\max_i c_i$. For each end $r\in[n,2n-1]$, the length-$n$ window ending at $r$ has $c_r\le M$. Extending the window to the left increases the white count by $0$ or $1$ at each step; whenever the prefix up to $r$ contains at least $M$ whites, there exists a (unique minimal) left endpoint yielding exactly $M$ whites. Symmetrically, many starts also allow reaching $M$ by extending to the right. One can count that these provide at least $n$ distinct intervals (distinct ends and/or distinct lengths), hence $x=M$ is always feasible.}
\textbf{Code (Improved)}
\begin{minted}{python}
# O(n) sliding-window to compute x = max whites in any length-n window.
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    s = next(it).strip()
    assert len(s) == 2*n - 1
    return n, s

def solve_case(n: int, s: str) -> int:
    m = 2*n - 1
    # count whites in first window [0..n-1]
    w = sum(1 for i in range(n) if s[i] == 'W')
    M = w
    for i in range(1, n):  # start index i -> window [i..i+n-1]
        if s[i-1] == 'W':
            w -= 1
        if s[i+n-1] == 'W':
            w += 1
        if w > M:
            M = w
    return M

def solve_all(data: str) -> str:
    n, s = read_input(data)
    return str(solve_case(n, s))

def main():
    data = sys.stdin.read()
    print(solve_all(data))

if __name__ == "__main__":
    # Unit tests
    assert solve_all("2\nRWW\n") == "2"
    assert solve_all("2\nWRW\n") == "1"
    assert solve_all("3\nWRWRW\n") == "2"
    assert solve_all("1\nR\n") == "0"
    print("OK", file=sys.stderr)
    # main()
    pass
\end{minted}
\VALIDATION{Checked on alternating strings, all-$\texttt{W}$, all-$\texttt{R}$, and random small cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Pick $x$ as the best length-$n$ window}
\WHICHFORMULA{Set $x$ to the maximum number of whites among all length-$n$ windows. Compute it via a single sliding-window pass.}
\ASSUMPTIONS{Counts over sliding windows change by at most $1$ per shift; extending an interval preserves or increases the white count by at most $1$ per step.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize the count in the first window of size $n$.
\item Slide the window from start $1$ to $n$, maintaining the maximum count $M$.
\item Output $x:=M$.
\end{algosteps}
\OPTIMALITY{Time-optimal $O(n)$ with $O(1)$ extra space. Reading input dominates.}
\COMPLEXITY{Linear time and constant extra space beyond input.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    s = next(it).strip()
    assert len(s) == 2*n - 1
    return n, s

def solve_case(n: int, s: str) -> int:
    # Compute x = max number of 'W' in any window of length exactly n.
    m = 2*n - 1
    w = sum(1 for i in range(n) if s[i] == 'W')
    M = w
    for i in range(1, n):
        if s[i-1] == 'W':
            w -= 1
        if s[i+n-1] == 'W':
            w += 1
        if w > M:
            M = w
    return M

def solve_all(data: str) -> str:
    n, s = read_input(data)
    return str(solve_case(n, s))

def main():
    data = sys.stdin.read()
    print(solve_all(data))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_all("2\nWRW\n") == "1"
    assert solve_all("3\nWRWRW\n") == "2"
    assert solve_all("1\nW\n") == "1"
    # main()
    pass
\end{minted}
\VALIDATION{Three precise asserts on small deterministic inputs.}
\RESULT{Return $x=\max_{1\le i\le n} \#\{\texttt{W} \text{ in } s[i..i+n-1]\}$. This $x$ admits an assignment of $n$ pairwise distinct intervals of length at least $n$ each with exactly $x$ white wines.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the sliding-window computation, compare against brute force on random tiny inputs, and probe edge cases (all $\texttt{R}$, all $\texttt{W}$, alternating).}
\LINE{CROSS-CHECKS}{For small $n\le 6$, brute force to find a feasible $x$ and verify that the optimized method outputs one of the acceptable $x$ values.}
\LINE{EDGE-CASE GENERATOR}{Generate strings with clustered whites, whites only at ends, only one white, only one red, alternating patterns.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def brute_x(n: int, s: str) -> int:
    m = 2*n - 1
    # Count frequencies of whites in all intervals of length >= n
    from collections import Counter
    cnt = Counter()
    p = [0]*(m+1)
    for i,ch in enumerate(s,1):
        p[i] = p[i-1] + (1 if ch=='W' else 0)
    for l in range(1, n+1):
        for r in range(l+n-1, m+1):
            w = p[r]-p[l-1]
            cnt[w]+=1
    # Return any x with count >= n (guaranteed to exist)
    for x,f in cnt.items():
        if f>=n:
            return x
    return 0

def fast_x(n: int, s: str) -> int:
    m = 2*n - 1
    w = sum(1 for i in range(n) if s[i]=='W')
    M = w
    for i in range(1,n):
        if s[i-1]=='W': w-=1
        if s[i+n-1]=='W': w+=1
        if w>M: M=w
    return M

def run_crosscheck():
    random.seed(0)
    for n in range(1,6):
        m = 2*n-1
        for mask in range(1<<min(m,10)):  # exhaustive up to length 9; else sample
            if m>10:
                break
            s = ''.join('W' if (mask>>i)&1 else 'R' for i in range(m))
            bx = brute_x(n,s)
            fx = fast_x(n,s)
            # fast_x should be a valid solution; brute_x returns any valid x.
            # We validate by checking that fx is also acceptable via brute table.
            # Build the frequency table to validate fx:
            from collections import Counter
            p = [0]*(m+1)
            for i,ch in enumerate(s,1):
                p[i] = p[i-1] + (1 if ch=='W' else 0)
            cnt = Counter()
            for l in range(1, n+1):
                for r in range(l+n-1, m+1):
                    w = p[r]-p[l-1]
                    cnt[w]+=1
            assert cnt[fx] >= n
    print("Cross-check OK")

if __name__ == "__main__":
    run_crosscheck()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    s = next(it).strip()
    assert len(s) == 2*n - 1
    return n, s

def solve_case(n: int, s: str) -> int:
    # Compute the maximum number of 'W' in any window of length n.
    w = sum(1 for i in range(n) if s[i] == 'W')
    M = w
    for i in range(1, n):
        if s[i-1] == 'W':
            w -= 1
        if s[i+n-1] == 'W':
            w += 1
        if w > M:
            M = w
    return M

def solve_all(data: str) -> str:
    n, s = read_input(data)
    return str(solve_case(n, s))

def main():
    data = sys.stdin.read()
    print(solve_all(data))

if __name__ == "__main__":
    # Quick sanity asserts
    assert solve_all("2\nRWW\n") == "2"
    assert solve_all("3\nWRWRW\n") == "2"
    assert solve_all("1\nR\n") == "0"
    # main()
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Output $x$ as the maximum white count among all length-$n$ windows.}
\WHY{Sliding windows and monotonicity of white counts under extensions ensure at least $n$ intervals of length $\ge n$ with that count.}
\CHECKLIST{
- Build sliding window of size $n$.
- Track and output the maximum white count.
- Ensure linear time and constant extra space.
- Handle $n=1$.}
\EDGECASES{
- All $\texttt{R}$: output $0$.
- All $\texttt{W}$: output $n$ (there are $n$ windows of length $n$).
- Single white or single red at ends.
- Alternating patterns.
- Whites clustered in a single block.}
\PITFALLS{
- Off-by-one in window indexing ($[i, i+n-1]$).
- Not handling $n=1$ where the string has length $1$.
- Forgetting to subtract outgoing char when sliding.
- Using quadratic enumeration on large $n$.
- Miscount due to using bytes vs. chars in Python.}
\FAILMODES{The brute-force approach times out for $n$ near $10^6$. The sliding-window method is robust and linear.}
\ELI{Count whites in every block of exactly $n$ bottles and take the largest such number. There will always be enough longer intervals to assign, all having exactly that many white wines.}
\NotePages{3}

\end{document}