% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — E-reader Display}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/126/C}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{After years of hard work scientists invented an absolutely new e-reader display. The new display has a larger resolution, consumes less energy and its production is cheaper. And besides, one can bend it. The only inconvenience is highly unusual management. For that very reason the developers decided to leave the e-readers' software to programmers.

The display is represented by $n \times n$ square of pixels, each of which can be either black or white. The display rows are numbered with integers from $1$ to $n$ upside down, the columns are numbered with integers from $1$ to $n$ from the left to the right. The display can perform commands like ``$x, y$''. When a traditional display fulfills such command, it simply inverts a color of $(x, y)$, where $x$ is the row number and $y$ is the column number. But in our new display every pixel that belongs to at least one of the segments $(x, x)$ -- $(x, y)$ and $(y, y)$ -- $(x, y)$ (both ends of both segments are included) inverts a color.

For example, if initially a display $5 \times 5$ in size is absolutely white, then the sequence of commands $(1, 4)$, $(3, 5)$, $(5, 1)$, $(3, 3)$ leads to the following changes:

You are an e-reader software programmer and you should calculate minimal number of commands needed to display the picture. You can regard all display pixels as initially white.

Input:
The first line contains number $n$ ($1 \le n \le 2000$).

Next $n$ lines contain $n$ characters each: the description of the picture that needs to be shown. ``0'' represents the white color and ``1'' represents the black color.

Output:
Print one integer $z$ — the least number of commands needed to display the picture.}
\BREAKDOWN{Each command toggles an ``L'' that connects a cell $(x,y)$ to the main diagonal via the row segment $(x,x)$--$(x,y)$ and the column segment $(y,y)$--$(x,y)$. We need the minimum number of such commands to transform the all-white grid into the target pattern, i.e., solve a parity system over $\mathbb{F}_2$. Leverage structure: each operation affects only cells not farther from the main diagonal than its corner, enabling a greedy from the farthest anti-diagonals inward.}
\ELI{Process cells by decreasing distance to the main diagonal; if a cell is wrong after accounting for earlier outer L-flips, flip at its corner to fix it, and track row/column parities towards the diagonal.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $n$ ($1 \le n \le 2000$). Then $n$ lines, each a string of length $n$ consisting of characters ``0'' or ``1'', describing the target grid from top row to bottom, left to right per row.}
\OUTPUTS{A single integer: the minimum number of commands (L-flips) needed to obtain the picture from the all-white grid.}
\SAMPLES{
- Example 1:
Input
3
010
000
000
Output
3

- Example 2:
Input
2
01
00
Output
3
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in \{0,1\}^{n \times n}$ be the target picture. For each ordered pair $(i,j)$, define a decision variable $O_{i,j} \in \{0,1\}$ indicating whether we apply a command at $(i,j)$. Let $E_{i,j}$ be the resulting color at $(i,j)$ (mod 2). We want to minimize $\sum_{i,j} O_{i,j}$ subject to $E_{i,j} = A_{i,j}$ for all $i,j$.}
\varmapStart
\var{A_{i,j}}{target color at cell $(i,j)$}
\var{O_{i,j}}{whether we execute the L-flip with corner at $(i,j)$}
\var{E_{i,j}}{final color at $(i,j)$ after all flips}
\var{a}{$\min(i,j)$}
\var{c}{$\max(i,j)$}
\varmapEnd
\GOVERN{
\[
\forall~i,j:\quad
E_{i,j} \equiv \left(\sum_{t=a}^{c} O_{i,t}\right) ~+~ \left(\sum_{s=a}^{c} O_{s,j}\right) ~+~ O_{i,j} \pmod 2,
\]
where $a=\min(i,j)$ and $c=\max(i,j)$. The two sums represent the row- and column-leg contributions; the extra $O_{i,j}$ corrects the double count at the corner. We require $E_{i,j}=A_{i,j}$.
}
\ASSUMPTIONS{Rows and columns are $1$-indexed. Each L-flip toggles each affected pixel exactly once (union of the row and column segments).}
\INVARIANTS{
- An L-flip at $(x,y)$ only affects cells at distance $\le |x-y|$ from the main diagonal.
- Processing cells in strictly decreasing $|i-j|$ ensures future flips never touch already processed cells.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the distance-from-diagonal ordering. Maintain the current grid explicitly; whenever a processed cell disagrees with the target, apply an L-flip at that cell and explicitly toggle its two legs.}
\ASSUMPTIONS{Explicit toggling is acceptable for small $n$; complexity is high but simple and correct.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a working grid $C$ of zeros (all white).
\item For $d$ from $n-1$ down to $1$:
  \begin{itemize}
  \item For $u=1$ to $n-d$: let $v=u+d$. If $C[u,v]\ne A[u,v]$, flip at $(u,v)$ and toggle row $u$ from $u$ to $v$ and column $v$ from $u$ to $v$, counting the corner once.
  \item Similarly, if $C[v,u]\ne A[v,u]$, flip at $(v,u)$, toggling its legs.
  \end{itemize}
\item For each diagonal cell $(i,i)$, if $C[i,i]\ne A[i,i]$, apply the flip $(i,i)$ which toggles only that cell.
\item Count flips used.
\end{algosteps}
\COMPLEXITY{Each flip may toggle $O(n)$ cells. In the worst case we flip $O(n^2)$ times. So $T(n)=O(n^3)$ and $S(n)=O(n^2)$ for the working grid.}
\[
\begin{aligned}
T(n) &\le \sum_{d=1}^{n-1}\sum_{u=1}^{n-d} O(d) + O(n) \\
     &= O\!\left(\sum_{d=1}^{n-1} (n-d)\cdot d\right) + O(n) \\
     &= O(n^3).
\end{aligned}
\]
\CORRECTNESS{By invariant, an L-flip at distance $d$ affects only cells with distance $\le d$. Thus when scanning from larger $d$ to smaller, no future flip can change an already processed cell. Greedily fixing a disagreeing cell at its corner is necessary and sufficient.}
\EDGECASES{Single cell $n=1$; all zeros; all ones; asymmetric patterns far from the main diagonal; correctness of counting the corner once.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    grid = []
    for _ in range(n):
        s = list(next(it).strip())
        grid.append([1 if ch == '1' else 0 for ch in s])
    return n, grid

def solve_case(n: int, A: List[List[int]]) -> int:
    if n == 0:
        return 0
    # Working grid C: current colors after applied flips
    C = [[0]*n for _ in range(n)]
    ans = 0
    # Process anti-diagonals by decreasing distance
    for d in range(n-1, 0, -1):
        for u in range(1, n - d + 1):
            v = u + d
            iu, iv = u-1, v-1
            # cell (u, v)
            if C[iu][iv] != A[iu][iv]:
                ans += 1
                lo, hi = (u, v) if u <= v else (v, u)
                # toggle row u, columns lo..hi
                for col in range(lo-1, hi):
                    C[iu][col] ^= 1
                # toggle column v, rows lo..hi, but skip corner (u,v) to count once
                for row in range(lo-1, hi):
                    if row == iu:
                        continue
                    C[row][iv] ^= 1
            # cell (v, u)
            ivu, iuv = v-1, u-1
            if C[ivu][iuv] != A[ivu][iuv]:
                ans += 1
                lo, hi = (u, v) if u <= v else (v, u)
                # toggle row v, columns lo..hi
                for col in range(lo-1, hi):
                    C[ivu][col] ^= 1
                # toggle column u, rows lo..hi, skip corner (v,u)
                for row in range(lo-1, hi):
                    if row == ivu:
                        continue
                    C[row][iuv] ^= 1
    # Diagonal cells
    for i in range(n):
        if C[i][i] != A[i][i]:
            ans += 1
            C[i][i] ^= 1
    return ans

def solve_all() -> None:
    n, A = read_input()
    if n == 0:
        return
    print(solve_case(n, A))

def _run_io(inp: str) -> str:
    import io
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(inp)
        sys.stdout = io.StringIO()
        solve_all()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

if __name__ == "__main__":
    # Tiny asserts
    assert _run_io("1\n0\n") == "0\n"
    assert _run_io("1\n1\n") == "1\n"
    # From samples in the sheet
    assert _run_io("2\n01\n00\n") == "3\n"
    # Symmetry check
    out1 = _run_io("2\n10\n00\n")
    assert out1 == "3\n"
    solve_all()
\end{minted}
\VALIDATION{Checked $n=1$ cases, small $2\times 2$ asymmetric targets, and ensured corner counting yields correct parity.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use four directional accumulators capturing pending parities flowing toward the main diagonal: for each row $i$, keep two bits for left/right wings; for each column $j$, keep two bits for up/down wings. Process anti-diagonals from far to near; at cell $(u,v)$ with $u<v$, the current color is $A_{u,v}\oplus \text{rowRight}[u]\oplus \text{colUp}[v]$, and similarly for $(v,u)$.}
\ASSUMPTIONS{Ordering by decreasing $|i-j|$ guarantees no future operation can affect an already processed cell. Directional accumulators are sufficient because only flips farther from the diagonal along the same row/column can reach a given cell.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize four arrays: rowRight, rowLeft, colUp, colDown to zeros.
\item For $d$ from $n-1$ down to $1$ and $u$ from $1$ to $n-d$, let $v=u+d$:
\begin{itemize}
\item Below-diagonal cell $(u,v)$: if $A_{u,v}\oplus\text{rowRight}[u]\oplus\text{colUp}[v]=1$, flip at $(u,v)$ and toggle rowRight$[u]$ and colUp$[v]$.
\item Above-diagonal cell $(v,u)$: if $A_{v,u}\oplus\text{rowLeft}[v]\oplus\text{colDown}[u]=1$, flip at $(v,u)$ and toggle rowLeft$[v]$ and colDown$[u]$.
\end{itemize}
\item For each diagonal $(i,i)$, if $A_{i,i}\oplus\text{rowRight}[i]\oplus\text{rowLeft}[i]\oplus\text{colUp}[i]\oplus\text{colDown}[i]=1$, flip at $(i,i)$.
\end{algosteps}
\COMPLEXITY{Each cell is processed in $O(1)$ with constant-time updates: total $T(n)=O(n^2)$ and $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= \sum_{d=0}^{n-1} 2(n-d) - (n) = O(n^2), \quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{By the distance invariant, future flips cannot affect processed cells. The directional parity decomposition is exhaustive and disjoint per wing; thus the parity at each cell is exactly the XOR of its wing accumulators with $A_{i,j}$. Flipping when mismatched is both necessary and sufficient.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    grid = []
    for _ in range(n):
        s = list(next(it).strip())
        grid.append([1 if ch == '1' else 0 for ch in s])
    return n, grid

def solve_case(n: int, A: List[List[int]]) -> int:
    if n == 0:
        return 0
    rowRight = [0]*(n+1)
    rowLeft  = [0]*(n+1)
    colUp    = [0]*(n+1)
    colDown  = [0]*(n+1)
    ans = 0
    # Process by decreasing distance to diagonal
    for d in range(n-1, 0, -1):
        for u in range(1, n - d + 1):
            v = u + d
            # (u, v): u < v, uses rowRight[u] and colUp[v]
            cur = A[u-1][v-1] ^ rowRight[u] ^ colUp[v]
            if cur == 1:
                ans += 1
                rowRight[u] ^= 1
                colUp[v] ^= 1
            # (v, u): v > u, uses rowLeft[v] and colDown[u]
            cur2 = A[v-1][u-1] ^ rowLeft[v] ^ colDown[u]
            if cur2 == 1:
                ans += 1
                rowLeft[v] ^= 1
                colDown[u] ^= 1
    # Diagonal cells: combine all four wings
    for i in range(1, n+1):
        curd = A[i-1][i-1] ^ rowRight[i] ^ rowLeft[i] ^ colUp[i] ^ colDown[i]
        if curd == 1:
            ans += 1
    return ans

def solve_all() -> None:
    n, A = read_input()
    if n == 0:
        return
    print(solve_case(n, A))

def _run_io(inp: str) -> str:
    import io
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(inp)
        sys.stdout = io.StringIO()
        solve_all()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

if __name__ == "__main__":
    # Basic consistency with baseline expectations
    assert _run_io("1\n0\n") == "0\n"
    assert _run_io("1\n1\n") == "1\n"
    assert _run_io("2\n01\n00\n") == "3\n"
    # Symmetry test
    assert _run_io("2\n10\n00\n") == "3\n"
    solve_all()
\end{minted}
\VALIDATION{Validated on tiny cases and symmetric counterparts; matches baseline outputs on these.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Greedy by decreasing distance to the main diagonal with four wing-accumulators: rowRight, rowLeft, colUp, colDown.}
\ASSUMPTIONS{The L-flip affects only cells not farther from the diagonal than its corner. Hence, at each distance layer, flipping when mismatched is required and cannot be undone by future flips.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize counters rowRight, rowLeft, colUp, colDown to zeros.
\item For $d=n-1$ down to $1$, for all pairs $(u,v)$ with $v=u+d$:
\begin{itemize}
\item If $A_{u,v}\oplus\text{rowRight}[u]\oplus\text{colUp}[v]=1$, flip $(u,v)$ and toggle rowRight$[u]$, colUp$[v]$.
\item If $A_{v,u}\oplus\text{rowLeft}[v]\oplus\text{colDown}[u]=1$, flip $(v,u)$ and toggle rowLeft$[v]$, colDown$[u]$.
\end{itemize}
\item For each $i$, if $A_{i,i}\oplus\text{rowRight}[i]\oplus\text{rowLeft}[i]\oplus\text{colUp}[i]\oplus\text{colDown}[i]=1$, flip $(i,i)$.
\end{algosteps}
\OPTIMALITY{At distance layer $d$, any flip at a smaller distance cannot affect those cells. Therefore, if a cell at layer $d$ is mismatched, at least one flip at layer $\ge d$ must target it; our greedy chooses exactly one, which is necessary. Conversely, our flip only affects cells at smaller distance, which we will still process, ensuring feasibility. Thus the solution is minimal.}
\COMPLEXITY{$T(n)=O(n^2)$, $S(n)=O(n)$, as each of the $n^2$ cells is touched O(1) times.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \quad S(n)=\Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    grid = []
    for _ in range(n):
        s = list(next(it).strip())
        grid.append([1 if ch == '1' else 0 for ch in s])
    return n, grid

def solve_case(n: int, A: List[List[int]]) -> int:
    if n == 0:
        return 0
    rowRight = [0]*(n+1)
    rowLeft  = [0]*(n+1)
    colUp    = [0]*(n+1)
    colDown  = [0]*(n+1)
    ans = 0
    for d in range(n-1, 0, -1):
        for u in range(1, n - d + 1):
            v = u + d
            # process (u, v)
            if (A[u-1][v-1] ^ rowRight[u] ^ colUp[v]) == 1:
                ans += 1
                rowRight[u] ^= 1
                colUp[v] ^= 1
            # process (v, u)
            if (A[v-1][u-1] ^ rowLeft[v] ^ colDown[u]) == 1:
                ans += 1
                rowLeft[v] ^= 1
                colDown[u] ^= 1
    for i in range(1, n+1):
        if (A[i-1][i-1] ^ rowRight[i] ^ rowLeft[i] ^ colUp[i] ^ colDown[i]) == 1:
            ans += 1
    return ans

def solve_all() -> None:
    n, A = read_input()
    if n == 0:
        return
    print(solve_case(n, A))

def _run_io(inp: str) -> str:
    import io
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(inp)
        sys.stdout = io.StringIO()
        solve_all()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

if __name__ == "__main__":
    # Exactly 3 asserts
    assert _run_io("1\n1\n") == "1\n"
    assert _run_io("2\n01\n00\n") == "3\n"
    assert _run_io("3\n000\n000\n000\n") == "0\n"
    solve_all()
\end{minted}
\VALIDATION{Ran on hand-crafted small cases, including all-zero, single-one on and off diagonal, and compared symmetric positions.}
\RESULT{The program prints the minimum number of L-flips; any order of flips achieving this number is acceptable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small $n$ to verify parity and corner counting; symmetry checks for $(i,j)$ vs $(j,i)$; random tiny grids comparing baseline and final outputs.}
\LINE{CROSS-CHECKS}{For $n\le 5$, compare Approach A (explicit toggling) vs Approach C (accumulators) on many patterns; outputs must match.}
\LINE{EDGE-CASE GENERATOR}{Generate grids with: only diagonal ones; only off-diagonal ones at fixed distance $d$; checkerboard; single one far from diagonal.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import sys
from typing import List, Tuple

def solve_final(n: int, A: List[List[int]]) -> int:
    rowRight = [0]*(n+1)
    rowLeft  = [0]*(n+1)
    colUp    = [0]*(n+1)
    colDown  = [0]*(n+1)
    ans = 0
    for d in range(n-1, 0, -1):
        for u in range(1, n - d + 1):
            v = u + d
            if (A[u-1][v-1] ^ rowRight[u] ^ colUp[v]) == 1:
                ans += 1
                rowRight[u] ^= 1
                colUp[v] ^= 1
            if (A[v-1][u-1] ^ rowLeft[v] ^ colDown[u]) == 1:
                ans += 1
                rowLeft[v] ^= 1
                colDown[u] ^= 1
    for i in range(1, n+1):
        if (A[i-1][i-1] ^ rowRight[i] ^ rowLeft[i] ^ colUp[i] ^ colDown[i]) == 1:
            ans += 1
    return ans

def ref_read_input() -> Tuple[int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    grid = []
    for _ in range(n):
        s = list(next(it).strip())
        grid.append([1 if ch == '1' else 0 for ch in s])
    return n, grid

def ref_main() -> None:
    n, A = ref_read_input()
    if n == 0:
        return
    print(solve_final(n, A))

def _run_io(inp: str) -> str:
    import io
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(inp)
        sys.stdout = io.StringIO()
        ref_main()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

# Cross-check small cases deterministically
if __name__ == "__main__":
    assert _run_io("1\n0\n") == "0\n"
    assert _run_io("1\n1\n") == "1\n"
    assert _run_io("2\n01\n00\n") == "3\n"
    assert _run_io("2\n10\n00\n") == "3\n"
    assert _run_io("3\n000\n010\n000\n") == "1\n"
    ref_main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    grid = []
    for _ in range(n):
        s = list(next(it).strip())
        grid.append([1 if ch == '1' else 0 for ch in s])
    return n, grid

def solve_case(n: int, A: List[List[int]]) -> int:
    if n == 0:
        return 0
    rowRight = [0]*(n+1)
    rowLeft  = [0]*(n+1)
    colUp    = [0]*(n+1)
    colDown  = [0]*(n+1)
    ans = 0
    for d in range(n-1, 0, -1):
        for u in range(1, n - d + 1):
            v = u + d
            if (A[u-1][v-1] ^ rowRight[u] ^ colUp[v]) == 1:
                ans += 1
                rowRight[u] ^= 1
                colUp[v] ^= 1
            if (A[v-1][u-1] ^ rowLeft[v] ^ colDown[u]) == 1:
                ans += 1
                rowLeft[v] ^= 1
                colDown[u] ^= 1
    for i in range(1, n+1):
        if (A[i-1][i-1] ^ rowRight[i] ^ rowLeft[i] ^ colUp[i] ^ colDown[i]) == 1:
            ans += 1
    return ans

def solve_all() -> None:
    n, A = read_input()
    if n == 0:
        return
    print(solve_case(n, A))

def _run_io(inp: str) -> str:
    import io
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(inp)
        sys.stdout = io.StringIO()
        solve_all()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

if __name__ == "__main__":
    # Final sanity asserts
    assert _run_io("1\n1\n") == "1\n"
    assert _run_io("2\n01\n00\n") == "3\n"
    assert _run_io("3\n000\n000\n000\n") == "0\n"
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Flip L-shapes whose legs run from the corner to the main diagonal; process by decreasing distance to the diagonal with four directional parity accumulators.}
\WHY{Greedy-by-distance with accumulator bookkeeping appears in matrix parity problems and tests ability to exploit geometric invariants for optimal transforms.}
\CHECKLIST{
- Compute distance $d=|i-j|$ layers and process from large to small.
- Maintain rowRight/rowLeft and colUp/colDown parities.
- For $(u,v)$ with $u<v$, use $A_{u,v}\oplus\text{rowRight}[u]\oplus\text{colUp}[v]$.
- For $(v,u)$, use $A_{v,u}\oplus\text{rowLeft}[v]\oplus\text{colDown}[u]$.
- For $(i,i)$, use XOR of all four wings.
- Flip if and only if the computed parity is $1$.}
\EDGECASES{
- $n=1$ with target $0$ or $1$.
- Entirely zero matrix (answer $0$).
- Single one far from diagonal.
- All ones on diagonal only.
- Patterns symmetric across the diagonal.
- Very thin bands near the diagonal.}
\PITFALLS{
- Double-counting the corner when simulating explicit flips; union should toggle once.
- Using a single row/column accumulator instead of per-wing accumulators.
- Processing order not strictly decreasing in $|i-j|$ can break correctness.
- Off-by-one errors in index conversion between $1$- and $0$-based.
- Forgetting that $(x,x)$ flip affects only that one cell.
- Mixing up which wing (up/down vs left/right) to update for a given cell.}
\FAILMODES{Naive row/column scan orders allow later flips to re-toggle already fixed cells, causing non-minimal or incorrect counts. The distance-layer greedy avoids this by design.}
\ELI{Start from the cells farthest from the main diagonal and move inward. Keep two bits per row and two per column telling you whether previous outer L-flips have already toggled along that direction. If a cell is wrong given those bits, flip at that cell and update the corresponding two bits. At the diagonal, resolve any remaining mismatches.}
\NotePages{3}

\end{document}