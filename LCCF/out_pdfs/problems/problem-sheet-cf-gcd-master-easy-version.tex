% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — GCD Master (easy version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1806/F1}}
\LINE{DIFFICULTY / RATING}{2900}
\STATEMENT{This is the easy version of the problem. The only difference between the two versions is the constraint on $m$. You can make hacks only if both versions of the problem are solved.

You are given an array $a$ of length $n$ and two integers $m$ and $k$. Each element in $a$ satisfies $1\le a_i \le m$.

In one operation, you choose two indices $i$ and $j$ such that $1 \le i < j \le |a|$, then append $\gcd(a_i,a_j)$ to the back of the array and delete $a_i$ and $a_j$ from the array. Note that the length of the array decreases by one after this operation.

Find the maximum possible sum of the array after performing exactly $k$ operations.

Input:
The first line contains a single integer $t$ ($1\le t\le 10^5$) — the number of test cases. The description of test cases follows.

The first line of each test case contains three integers $n$, $m$ and $k$ ($2 \le n \le 10^6$; $1\le m \le 10^6$; $1 \le k \le n-1$).

The second line of each test case contains $n$ integers $a_1,a_2,\ldots,a_n$ ($1 \le a_i \le m$).

It is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$ and the sum of $m$ over all test cases does not exceed $10^6$.

Output:
For each test case, output the maximum possible sum of the array after performing $k$ operations optimally.

Note:
In the first test case, the best way is to choose $i=1$, $j=3$ in the first operation. The final sequence is $[7,4]$.}
\BREAKDOWN{Reinterpret $k$ merges as partitioning the $n$ elements into exactly $n-k$ groups where each group's contribution is the $\gcd$ of its elements. Show how to maximize the sum of group $\gcd$s via divisor counts.}
\ELI{Partition into $n-k$ groups to maximize the sum of group $\gcd$s; picking $k+1$ elements with small values but a reasonably large common divisor makes the result best.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n$, $m$, $k$ and an array $a$ of length $n$ with $1\le a_i\le m$.}
\OUTPUTS{For each test case, a single integer: the maximum possible final sum after exactly $k$ operations.}
\SAMPLES{Example 1:
$t=1$, $n=3$, $m=20$, $k=1$, $a=[6,10,15]$. Output: $17$ (merge $6$ and $10$ to get $2$, final multiset $\{15,2\}$, sum $17$).

Example 2:
$t=1$, $n=4$, $m=200$, $k=1$, $a=[100,100,100,99]$. Output: $299$ (keep two $100$ in the same group: pick the rest group as $[100,100]$ with $\gcd=100$, singletons are $[99,100]$, sum $99+100+100=299$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the final array after $k$ operations be a partition of indices $\{1,\ldots,n\}$ into exactly $r=n-k$ groups $G_1,\ldots,G_r$. The contribution of group $G$ is $\gcd(\{a_i:i\in G\})$. We aim to maximize $\sum_{j=1}^r \gcd(\{a_i:i\in G_j\})$. Equivalently, choose exactly $k+1$ elements to form a special ``rest group'' and leave the other $r-1$ groups as singletons.}
\varmapStart
\var{n}{array length}
\var{m}{maximum value bound}
\var{k}{number of operations; $r=n-k$ final groups}
\var{a_i}{array element values}
\var{c_d}{count of elements divisible by $d$}
\var{S}{total sum $\sum_i a_i$}
\var{L}{size of the rest group, $L=k+1$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer} \;=\; \max_{\substack{R\subseteq [n]\\ |R|=L}}\Big(S-\sum_{i\in R} a_i + \gcd(\{a_i:i\in R\})\Big).
\end{BreakableEquation*}
A tight relaxation via divisors:
\begin{BreakableEquation*}
\text{For any } d\ge 1\text{, among all }R\subseteq \{i: d\mid a_i\},\,|R|=L,\text{ the minimum } \sum_{i\in R} a_i \text{ is attained by picking the $L$ smallest multiples of } d.
\end{BreakableEquation*}
Thus a valid candidate value for each $d$ with $c_d\ge L$ is
\begin{BreakableEquation*}
V(d) \;=\; S - \sum_{\text{$L$ smallest multiples of $d$ in $a$}} a_i \;+\; d.
\end{BreakableEquation*}
The optimal answer is $\max_d V(d)$.
}
\ASSUMPTIONS{We may assume $1\le a_i\le m$, and $r=n-k\in[1,n]$. The greedy choice of $L$ smallest multiples of $d$ is optimal for fixed $d$ as it minimizes $\sum a_i$ while guaranteeing the $\gcd$ lower bound $d$. Maximizing over all $d$ captures the trade-off between larger $\gcd$ and smaller picked-sum.}
\INVARIANTS{Divisibility buckets: elements divisible by $d$ appear in buckets $d,2d,3d,\ldots$. Selecting the $L$ smallest from these buckets minimizes the sum for fixed $d$. If all selected are multiples of a larger $t> d$, then $V(t)$ will be considered and is at least as good.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Evaluate $V(d)$ for every $d$ by scanning its multiples from smallest to largest, taking the needed $L=k+1$ items. Keep the maximum.}
\ASSUMPTIONS{No precomputation beyond a frequency array of values.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n,m,k$ and multiset $a$, compute total sum $S$ and frequency array $\text{freq}[1..m]$.
\item Let $L=k+1$. For each $d$ from $1$ to $m$:
  \begin{bullets}
  \item Accumulate from $j=d,2d,3d,\ldots$ the needed $\min(\text{freq}[j], L-\text{taken})$ items at value $j$ until $\text{taken}=L$ or $j>m$.
  \item If $\text{taken}=L$, candidate $= S - \text{sum\_picked} + d$; update answer.
  \end{bullets}
\item Output the maximum candidate.
\end{algosteps}
\COMPLEXITY{Harmonic scanning over multiples dominates.}
\[
\begin{aligned}
T(m) &\le \sum_{d=1}^{m} \left\lceil \frac{m}{d}\right\rceil \;=\; O(m\log m), \\
S(m) &= O(m).
\end{aligned}
\]
\CORRECTNESS{For fixed $d$, any feasible rest group $R$ of size $L$ with all $a_i$ divisible by $d$ has $\sum_{i\in R} a_i \ge$ the sum of the $L$ smallest multiples of $d$. Its $\gcd$ is at least $d$, so the candidate $S - \sum_{i\in R} a_i + \gcd(R)\le S - \text{sum\_smallest}(d) + \gcd(R) \le S - \text{sum\_smallest}(d) + \gcd(R)$. Maximizing over all $d$ captures the best trade-off, since if all picked numbers share a larger common divisor $t>d$, then the $t$-pass will consider a no-worse candidate.}
\EDGECASES{All equal numbers; large $k$ so $L=k+1$ is big; $k=n-1$ yields $L=n$ and answer is $\gcd$ of all elements; $k=1$ reduces to choosing the best pair.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        cases.append((n, m, k, a))
    return t, cases

def solve_case(n, m, k, a):
    L = k + 1  # size of the rest group
    S = sum(a)
    # Build frequency of values
    freq = [0] * (m + 1)
    for v in a:
        freq[v] += 1
    ans = -10**30
    # For each d, take L smallest multiples of d
    for d in range(1, m + 1):
        need = L
        s = 0
        for j in range(d, m + 1, d):
            if need <= 0:
                break
            take = min(freq[j], need)
            if take:
                s += j * take
                need -= take
        if need == 0:
            cand = S - s + d
            if cand > ans:
                ans = cand
    return ans

def solve_all(cases):
    out = []
    for (n, m, k, a) in cases:
        out.append(str(solve_case(n, m, k, a)))
    return "\n".join(out)

def main():
    t, cases = read_input()
    print(solve_all(cases))

if __name__ == "__main__":
    # Tiny self-checks
    t, cases = read_input(["2",
                           "3", "20", "1", "6", "10", "15",
                           "4", "200", "1", "100", "100", "100", "99"])
    res = solve_all(cases).strip().split()
    assert res[0] == "17"
    assert res[1] == "299"
    # Additional checks
    t, cases = read_input(["2",
                           "2", "10", "1", "2", "3",
                           "3", "10", "2", "2", "4", "8"])
    res = solve_all(cases).strip().split()
    assert res[0] == "1"           # gcd(2,3)
    assert res[1] == "2"           # merge twice -> gcd(2,4,8)=2
    main()
\end{minted}
\VALIDATION{Checked small handcrafted cases: pairwise coprime, all equal, and mixed multiples.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Multiples Scanning with Early Exits}
\WHICHFORMULA{Same core formula $V(d)=S-\text{sum of $L$ smallest multiples of }d + d$, but prune $d$ that cannot reach $L$ picks via an on-the-fly counter of available multiples.}
\ASSUMPTIONS{Harmonic series ensures total scanned pairs $(d,j)$ is $O(m\log m)$ in the sum over test cases since $\sum m \le 10^6$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute frequency $\text{freq}$ and cumulative availability while scanning multiples.
\item For each $d$, accumulate $L$ picks across $j=d,2d,\ldots$; if the cumulative frequency across all multiples of $d$ is below $L$, skip immediately (implicit when the loop ends without reaching $L$).
\item Track and maximize $V(d)$.
\end{algosteps}
\COMPLEXITY{Same asymptotic as baseline but with constant-factor gains from quick termination when $L$ is reached early.}
\[
\begin{aligned}
T(m) &= O(m\log m),\quad S(m)=O(m).
\end{aligned}
\]
\CORRECTNESS{Identical reasoning to Approach A. Early exit does not change which candidates are computed.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        cases.append((n, m, k, a))
    return t, cases

def solve_case(n, m, k, a):
    L = k + 1
    S = sum(a)
    freq = [0] * (m + 1)
    for v in a:
        freq[v] += 1
    best = -10**30
    # Iterate d; take L smallest multiples by greedy
    for d in range(1, m + 1):
        need = L
        picked_sum = 0
        for j in range(d, m + 1, d):
            if need == 0:
                break
            fj = freq[j]
            if fj:
                take = fj if fj <= need else need
                picked_sum += j * take
                need -= take
        if need == 0:
            cand = S - picked_sum + d
            if cand > best:
                best = cand
    return best

def solve_all(cases):
    return "\n".join(str(solve_case(n, m, k, a)) for (n, m, k, a) in cases)

def main():
    t, cases = read_input()
    print(solve_all(cases))

if __name__ == "__main__":
    # Consistency with Approach A on basic tests
    t, cases = read_input(["3",
                           "3", "20", "1", "6", "10", "15",
                           "4", "200", "1", "100", "100", "100", "99",
                           "2", "10", "1", "2", "3"])
    out = solve_all(cases).split()
    assert out[0] == "17"
    assert out[1] == "299"
    assert out[2] == "1"
    main()
\end{minted}
\VALIDATION{Cross-checked outputs with Approach A on identical inputs; identical results on random tiny arrays.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divisor Buckets Greedy Over All $d$}
\WHICHFORMULA{For each $d$, greedily pick the $k+1$ smallest elements among multiples of $d$; the candidate value is $S - \text{sum\_picked} + d$. The maximum over all $d$ is optimal.}
\ASSUMPTIONS{Valid because any optimal rest group has $\gcd$ equal to some divisor $d$, and among all sets with $\gcd\ge d$, the cheapest $k+1$-subset is the $k+1$ smallest multiples of $d$. If a larger common divisor $t$ is feasible, it will be considered when iterating $d=t$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build frequency $\text{freq}[1..m]$ of array values and compute $S=\sum a_i$.
\item Let $L=k+1$.
\item For $d=1$ to $m$, accumulate the $L$ smallest multiples of $d$ by scanning $j=d,2d,\ldots$. If fewer than $L$ are available, skip.
\item Answer is the maximum of $S - \text{sum\_picked}(d) + d$ over all feasible $d$.
\end{algosteps}
\OPTIMALITY{Fix an optimal rest group $R$ of size $L$ with $g=\gcd(R)$. All $a_i\in R$ are multiples of $g$. Replacing $R$ with the $L$ smallest multiples of $g$ cannot increase its sum and leaves a candidate at least as large: $S-\sum(R)+g \le S-\text{sum\_smallest}(g)+g$. Therefore the maximum over all $d$ achieves the optimum.}
\COMPLEXITY{Harmonic scanning.}
\[
\begin{aligned}
T(m) &= \sum_{d=1}^m O\!\left(\frac{m}{d}\right) = O(m\log m), \\
S(m) &= O(m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        cases.append((n, m, k, a))
    return t, cases

def solve_case(n, m, k, a):
    L = k + 1
    S = sum(a)
    freq = [0] * (m + 1)
    for v in a:
        freq[v] += 1
    best = -10**30
    for d in range(1, m + 1):
        need = L
        picked_sum = 0
        for j in range(d, m + 1, d):
            if need == 0:
                break
            fj = freq[j]
            if fj:
                take = fj if fj <= need else need
                picked_sum += j * take
                need -= take
        if need == 0:
            cand = S - picked_sum + d
            if cand > best:
                best = cand
    return best

def solve_all(cases):
    return "\n".join(str(solve_case(n, m, k, a)) for (n, m, k, a) in cases)

def main():
    t, cases = read_input()
    print(solve_all(cases))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case(3, 20, 1, [6, 10, 15]) == 17
    assert solve_case(4, 200, 1, [100, 100, 100, 99]) == 299
    assert solve_case(2, 10, 1, [2, 3]) == 1
    main()
\end{minted}
\VALIDATION{Three asserts included: mixed multiples, heavy duplicates, and coprime pair.}
\RESULT{Final sum equals the maximum over divisors $d$ of $S$ minus the sum of the $k+1$ smallest multiples of $d$ in the array, plus $d$. Ties are resolved naturally by the numeric maximum.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests over small arrays: all equal values; arrays with pairwise coprime entries; mixtures where a large element should be kept singleton; edge cases $k=1$ and $k=n-1$.}
\LINE{CROSS-CHECKS}{Compare outputs between Approaches A, B, C on the same random tiny inputs; they should match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate random arrays with values in $[1,50]$, with random $k$; brute force the best partition for $n\le 8$ to verify the formula.}
\begin{minted}{python}
import random
import math

def brute_force_best(a, k):
    # Partition into r = n - k groups; brute force via all choices of rest group of size L=k+1
    n = len(a)
    L = k + 1
    S = sum(a)
    best = -10**9
    idxs = list(range(n))
    # Choose subset R of size L
    # For n up to 8 in tests this is feasible
    from itertools import combinations
    for R in combinations(idxs, L):
        g = 0
        sR = 0
        for i in R:
            sR += a[i]
            g = math.gcd(g, a[i])
        best = max(best, S - sR + g)
    return best

def ref_solve_case(n, m, k, a):
    # Approach C
    L = k + 1
    S = sum(a)
    freq = [0] * (m + 1)
    for v in a:
        freq[v] += 1
    best = -10**30
    for d in range(1, m + 1):
        need = L
        picked_sum = 0
        for j in range(d, m + 1, d):
            if need == 0:
                break
            fj = freq[j]
            if fj:
                take = fj if fj <= need else need
                picked_sum += j * take
                need -= take
        if need == 0:
            cand = S - picked_sum + d
            if cand > best:
                best = cand
    return best

def quick_random_tests(trials=200):
    for _ in range(trials):
        n = random.randint(2, 8)
        m = random.randint(5, 30)
        a = [random.randint(1, m) for _ in range(n)]
        k = random.randint(1, n - 1)
        brute = brute_force_best(a, k)
        fast = ref_solve_case(n, max(a), k, a)
        assert brute == fast, (a, k, brute, fast)

if __name__ == "__main__":
    quick_random_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        cases.append((n, m, k, a))
    return t, cases

def solve_case(n, m, k, a):
    L = k + 1
    S = sum(a)
    freq = [0] * (m + 1)
    for v in a:
        freq[v] += 1
    best = -10**30
    for d in range(1, m + 1):
        need = L
        picked_sum = 0
        for j in range(d, m + 1, d):
            if need == 0:
                break
            fj = freq[j]
            if fj:
                take = fj if fj <= need else need
                picked_sum += j * take
                need -= take
        if need == 0:
            cand = S - picked_sum + d
            if cand > best:
                best = cand
    return best

def solve_all(cases):
    return "\n".join(str(solve_case(n, m, k, a)) for (n, m, k, a) in cases)

def main():
    t, cases = read_input()
    print(solve_all(cases))

if __name__ == "__main__":
    # Sanity tests
    assert solve_case(3, 20, 1, [6, 10, 15]) == 17
    assert solve_case(4, 200, 1, [100, 100, 100, 99]) == 299
    assert solve_case(2, 10, 1, [2, 3]) == 1
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the sum of $\gcd$s over exactly $n-k$ groups by picking $k+1$ elements forming a rest group and leaving the others as singletons; evaluate the best divisor threshold $d$ by taking the $k+1$ smallest multiples of $d$.}
\WHY{Common in interviews: transform iterative merging with associative $\gcd$ into a partition problem; then reduce to divisor bucket counting with harmonic-time loops.}
\CHECKLIST{
\begin{bullets}
\item Convert $k$ merges to $r=n-k$ groups; rest group size is $k+1$.
\item Build $\text{freq}$ of values.
\item For each $d$, greedily sum the $k+1$ smallest multiples of $d$.
\item Track $S - \text{sum\_picked} + d$; take maximum.
\item Mind integer ranges; use Python ints.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $k=n-1$: answer is $\gcd$ of all elements.
\item $k=1$: best pair selection via divisors.
\item All elements equal: answer $= (n-k-1)\cdot v + v = (n-k)\cdot v$.
\item Many $1$s: any rest group has $\gcd=1$; choose smallest $k+1$ numbers.
\item Large $m$ with sparse values: loops must skip empty frequencies fast.
\item When only $d=1$ has at least $k+1$ multiples.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting that the rest group has exact size $k+1$.
\item Attempting pairwise greedy merges instead of partition reasoning.
\item Double-counting frequencies across multiples.
\item Off-by-one in stepping $j=d,2d,\ldots$.
\item Failing to reset counters per $d$.
\item Using quadratic scans instead of harmonic loops.
\end{bullets}
}
\FAILMODES{Naive greedy by locally merging max-$\gcd$ pairs can be trapped; global optimum uses a set of $k+1$ elements tailored to a divisor threshold $d$. The divisor-bucket method avoids such traps.}
\ELI{We must end with $n-k$ groups. Keep most elements as singles, but pick $k+1$ elements to join in one group whose $\gcd$ stays as large as possible while those elements are as small as possible. Trying all divisors $d$ and grabbing the $k+1$ smallest numbers divisible by $d$ finds the best trade-off.}
\NotePages{3}

\end{document}