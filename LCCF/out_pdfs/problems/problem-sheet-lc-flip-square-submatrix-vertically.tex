% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Flip Square Submatrix Vertically}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/flip-square-submatrix-vertically/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given an $m \times n$ integer matrix \texttt{grid}, and three integers $x$, $y$, and $k$. The integers $x$ and $y$ represent the row and column indices of the top-left corner of a square submatrix and the integer $k$ represents the size (side length) of the square submatrix. Your task is to flip the submatrix by reversing the order of its rows vertically. Return the updated matrix.

Example 1:
Input: \texttt{grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], x = 1, y = 0, k = 3}
Output: \texttt{[[1,2,3,4],[13,14,15,8],[9,10,11,12],[5,6,7,16]]}
Explanation: The diagram above shows the grid before and after the transformation.

Example 2:
Input: \texttt{grid = [[3,4,2,3],[2,3,4,2]], x = 0, y = 2, k = 2}
Output: \texttt{[[3,4,4,2],[2,3,2,3]]}
Explanation: The diagram above shows the grid before and after the transformation.

Constraints:
\begin{bullets}
\item $m = \texttt{grid.length}$
\item $n = \texttt{grid}[i]\texttt{.length}$
\item $1 \le m, n \le 50$
\item $1 \le \texttt{grid}[i][j] \le 100$
\item $0 \le x < m$
\item $0 \le y < n$
\item $1 \le k \le \min(m - x, n - y)$
\end{bullets}}
\BREAKDOWN{Identify the $k \times k$ square starting at $(x,y)$ and reverse its rows in-place or by copying, leaving all other entries unchanged. Ensure indices and boundaries are handled correctly.}
\ELI{Swap the top row of the square with the bottom row, then the next with the next, until the middle—only within the $k \times k$ window.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer matrix \texttt{grid} of shape $m \times n$, integers $x$, $y$, $k$ with $1 \le m,n \le 50$, $0 \le x < m$, $0 \le y < n$, and $1 \le k \le \min(m-x,n-y)$.}
\OUTPUTS{Return a matrix of the same shape as \texttt{grid} where only the $k \times k$ submatrix with top-left corner $(x,y)$ has its rows reversed in order.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{grid=[[1,2],[3,4]]}, $x=0$, $y=0$, $k=2$; Output: \texttt{[[3,4],[1,2]]}
\item Input: \texttt{grid=[[1,2,3],[4,5,6]]}, $x=0$, $y=1$, $k=1$; Output: unchanged \texttt{[[1,2,3],[4,5,6]]}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G \in \mathbb{Z}^{m \times n}$ be the input matrix. Define the index set $I=\{x,\ldots,x+k-1\}$ and $J=\{y,\ldots,y+k-1\}$. The transformation produces $G' \in \mathbb{Z}^{m \times n}$ such that for all $(i,j)$:
\[
G'_{i,j} =
\begin{cases}
G_{x+(k-1-(i-x)),\, j} & \text{if } i \in I,~ j \in J,\\
G_{i,j} & \text{otherwise.}
\end{cases}
\]
This vertically reverses the rows within the selected $k \times k$ block.}
\varmapStart
\var{m,n}{matrix dimensions}
\var{G}{input grid}
\var{x,y}{top-left coordinates of the square}
\var{k}{side length of the square}
\var{G'}{output grid after vertical flip on the square}
\varmapEnd
\GOVERN{
\[
\forall r \in \{0,\ldots,k-1\},~\forall c \in \{0,\ldots,k-1\}:\quad
G'_{x+r,\,y+c} = G_{x+(k-1-r),\,y+c}.
\]
}
\ASSUMPTIONS{Zero-based indexing; the submatrix is fully inside bounds due to $1 \le k \le \min(m-x,n-y)$.}
\INVARIANTS{
\begin{bullets}
\item Entries outside rows $I$ or columns $J$ remain unchanged.
\item Within the $k \times k$ block, column order is preserved while row order is reversed.
\item Integer values are unchanged; only positions are permuted.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Copy the $k$ rows of the window, reverse the list of copied rows, then write back into the original positions.}
\ASSUMPTIONS{Sufficient memory to temporarily store $k \times k$ integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Slice the $k$ rows from $x$ to $x+k-1$ and, for each, slice columns $y$ to $y+k-1$ into a new list \texttt{sub}.
\item Reverse \texttt{sub}.
\item Overwrite the original block with rows from \texttt{sub} in order; return \texttt{grid}.
\end{algosteps}
\COMPLEXITY{Let $k$ be the side length of the square. Time is $O(k^2)$; extra space is $O(k^2)$ for the copy.}
\[
\begin{aligned}
T(k) &= \text{copy }k^2 + \text{reverse }k + \text{write }k^2 \\
     &= O(k^2).
\end{aligned}
\]
\CORRECTNESS{Reversing the list of rows preserves the elements within each row and exactly flips their vertical order; writing back to the original coordinates implements the governing equation.}
\EDGECASES{$k=1$ leaves the grid unchanged; $x=0$ or $y=0$ work identically; the bottommost or rightmost placements are valid by constraint.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def flipSubmatrix(self, grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:
        """
        Baseline: copy the kxk block, reverse rows, write back.
        """
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        assert 0 <= x < m and 0 <= y < n
        assert 1 <= k <= min(m - x, n - y)
        # Copy the kxk block
        sub = [row[y:y + k] for row in grid[x:x + k]]
        # Reverse row order
        sub.reverse()
        # Write back
        for i in range(k):
            grid[x + i][y:y + k] = sub[i]
        return grid

# --- tests (examples) ---
s = Solution()
g1 = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
assert s.flipSubmatrix([row[:] for row in g1], 1, 0, 3) == [[1,2,3,4],[13,14,15,8],[9,10,11,12],[5,6,7,16]]

g2 = [[3,4,2,3],[2,3,4,2]]
assert s.flipSubmatrix([row[:] for row in g2], 0, 2, 2) == [[3,4,4,2],[2,3,2,3]]

# edge: k=1 no-op inside the window
g3 = [[1,2,3],[4,5,6]]
assert s.flipSubmatrix([row[:] for row in g3], 0, 1, 1) == [[1,2,3],[4,5,6]]
\end{minted}
\VALIDATION{Validated on two provided examples and a no-op case; indices and bounds are asserted to hold.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{In-Place Two-Pointer Swap}
\WHICHFORMULA{Avoid the $O(k^2)$ copy by swapping corresponding rows in-place within the $k \times k$ window.}
\ASSUMPTIONS{In-place mutation is acceptable; only the target window may change.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For $i$ from $0$ to $\left\lfloor\tfrac{k}{2}\right\rfloor-1$, let $top=x+i$ and $bot=x+k-1-i$.
\item For each column $c$ in $[y, y+k-1]$, swap \texttt{grid[top][c]} with \texttt{grid[bot][c]}.
\item Return \texttt{grid}.
\end{algosteps}
\COMPLEXITY{Same $O(k^2)$ time but only $O(1)$ extra space.}
\[
\begin{aligned}
T(k) &= \sum_{i=0}^{\lfloor k/2\rfloor - 1} k \in \Theta(k^2), \quad S(k)=O(1).
\end{aligned}
\]
\CORRECTNESS{Each pair of symmetric rows within the window is swapped, which is equivalent to reversing the entire list of $k$ rows. Elements outside the window are untouched.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def flipSubmatrix(self, grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:
        """
        Improved: in-place swap of symmetric rows within the kxk window.
        """
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        assert 0 <= x < m and 0 <= y < n
        assert 1 <= k <= min(m - x, n - y)
        half = k // 2
        for d in range(0, half):
            top = x + d
            bot = x + (k - 1 - d)
            for c in range(y, y + k):
                grid[top][c], grid[bot][c] = grid[bot][c], grid[top][c]
        return grid

# --- tests ---
s = Solution()
g1 = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
assert s.flipSubmatrix([row[:] for row in g1], 1, 0, 3) == [[1,2,3,4],[13,14,15,8],[9,10,11,12],[5,6,7,16]]

g2 = [[3,4,2,3],[2,3,4,2]]
assert s.flipSubmatrix([row[:] for row in g2], 0, 2, 2) == [[3,4,4,2],[2,3,2,3]]

# single row swap when k=2
g3 = [[1,2],[3,4]]
assert s.flipSubmatrix([row[:] for row in g3], 0, 0, 2) == [[3,4],[1,2]]
\end{minted}
\VALIDATION{Checks include odd and even $k$, and full-corner placement.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Row-Pair Swapping with Column Slice Assignment}
\WHICHFORMULA{Use full-row segment swaps via slice assignment to swap $k$ contiguous elements at once for each row pair.}
\ASSUMPTIONS{Python list slice assignment is $O(k)$ and simplifies the inner loop without changing asymptotics.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For $d=0$ to $\left\lfloor\tfrac{k}{2}\right\rfloor-1$, set $top=x+d$, $bot=x+k-1-d$.
\item Swap the contiguous segments \texttt{grid[top][y:y+k]} and \texttt{grid[bot][y:y+k]} using a temporary copy of one segment.
\item Return the mutated grid.
\end{algosteps}
\OPTIMALITY{Time $\Theta(k^2)$ is information-theoretically tight because $k^2$ elements in the window must be touched; space $O(1)$ beyond a length-$k$ temporary buffer reused per pair.}
\COMPLEXITY{Time $O(k^2)$, space $O(k)$ transient per pair but $O(1)$ additional asymptotically relative to input size.}
\[
\begin{aligned}
T(k) &= \left\lfloor\tfrac{k}{2}\right\rfloor \cdot O(k) \in \Theta(k^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def flipSubmatrix(self, grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:
        """
        Final: swap row segments via slice assignment for clarity; in-place.
        """
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        assert 0 <= x < m and 0 <= y < n
        assert 1 <= k <= min(m - x, n - y)
        for d in range(k // 2):
            top = x + d
            bot = x + (k - 1 - d)
            seg_top = grid[top][y:y + k]
            seg_bot = grid[bot][y:y + k]
            grid[top][y:y + k] = seg_bot
            grid[bot][y:y + k] = seg_top
        return grid

# --- validation (exactly 3 asserts) ---
s = Solution()
g1 = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
assert s.flipSubmatrix([row[:] for row in g1], 1, 0, 3) == [[1,2,3,4],[13,14,15,8],[9,10,11,12],[5,6,7,16]]

g2 = [[3,4,2,3],[2,3,4,2]]
assert s.flipSubmatrix([row[:] for row in g2], 0, 2, 2) == [[3,4,4,2],[2,3,2,3]]

g3 = [[7,8,9],[1,2,3],[4,5,6]]
assert s.flipSubmatrix([row[:] for row in g3], 1, 1, 2) == [[7,8,9],[1,5,6],[4,2,3]]
\end{minted}
\VALIDATION{Three asserts: two from the statement and one custom partial-window flip.}
\RESULT{Returns the updated matrix with only the target $k \times k$ block vertically flipped; ties or ordering outside the block are unchanged.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: trivial $k=1$, minimal sizes, full-corner windows, odd and even $k$, and partial windows.}
\LINE{CROSS-CHECKS}{Compare outputs of copy-based (A) and in-place (B/C) implementations on an exhaustive set of tiny cases.}
\LINE{EDGE-CASE GENERATOR}{Systematically enumerates small matrices, positions, and sizes without randomness to keep tests deterministic and reproducible.}
\begin{minted}{python}
from typing import List, Iterable, Tuple

def solve_A(grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:
    sub = [row[y:y+k] for row in grid[x:x+k]]
    sub.reverse()
    out = [row[:] for row in grid]
    for i in range(k):
        out[x+i][y:y+k] = sub[i]
    return out

def solve_B(grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:
    out = [row[:] for row in grid]
    for d in range(k // 2):
        top = x + d
        bot = x + (k - 1 - d)
        for c in range(y, y + k):
            out[top][c], out[bot][c] = out[bot][c], out[top][c]
    return out

def gen_cases() -> Iterable[Tuple[List[List[int]], int, int, int]]:
    # Deterministic small cases: m,n in {1,2,3}; fill with consecutive ints.
    for m in range(1, 4):
        for n in range(1, 4):
            val = 1
            grid = []
            for _ in range(m):
                row = []
                for _ in range(n):
                    row.append(val)
                    val += 1
                grid.append(row)
            for x in range(m):
                for y in range(n):
                    max_k = min(m - x, n - y)
                    for k in range(1, max_k + 1):
                        yield ([row[:] for row in grid], x, y, k)

# Cross-check A vs B exhaustively on the generated tiny cases
for g, x, y, k in gen_cases():
    assert solve_A(g, x, y, k) == solve_B(g, x, y, k)

# Spot-check against statement examples
g1 = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
assert solve_B(g1, 1, 0, 3) == [[1,2,3,4],[13,14,15,8],[9,10,11,12],[5,6,7,16]]
g2 = [[3,4,2,3],[2,3,4,2]]
assert solve_B(g2, 0, 2, 2) == [[3,4,4,2],[2,3,2,3]]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def flipSubmatrix(self, grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:
        """
        Vertically flip the kxk submatrix with top-left (x,y) in-place and return grid.
        """
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        assert 0 <= x < m and 0 <= y < n
        assert 1 <= k <= min(m - x, n - y)
        for d in range(k // 2):
            top = x + d
            bot = x + (k - 1 - d)
            # swap contiguous segments
            tmp = grid[top][y:y + k]
            grid[top][y:y + k] = grid[bot][y:y + k]
            grid[bot][y:y + k] = tmp
        return grid

# Final quick sanity asserts
s = Solution()
g1 = [[1,2],[3,4]]
assert s.flipSubmatrix([row[:] for row in g1], 0, 0, 2) == [[3,4],[1,2]]
g2 = [[1,2,3],[4,5,6]]
assert s.flipSubmatrix([row[:] for row in g2], 0, 1, 1) == [[1,2,3],[4,5,6]]
g3 = [[5]]
assert s.flipSubmatrix([row[:] for row in g3], 0, 0, 1) == [[5]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Flip the $k \times k$ submatrix vertically by reversing row order within the window.}
\WHY{Common indexing and subarray manipulation shows up frequently in interviews and coding platforms.}
\CHECKLIST{
\begin{bullets}
\item Compute valid range: $1 \le k \le \min(m-x,n-y)$.
\item Identify rows $[x, x+k-1]$ and columns $[y, y+k-1]$.
\item Swap symmetric rows or reverse a copied list of rows.
\item Do not touch elements outside the window.
\item Return the mutated grid.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $k=1$ results in no change.
\item Window at bottom/right edges: $x+k=m$ or $y+k=n$.
\item Minimal sizes: $m=1$ or $n=1$.
\item Square equal to entire matrix: $k=\min(m,n)$ with $x=y=0$.
\item Odd $k$ leaves the middle row unchanged.
\item Even $k$ swaps exactly $k/2$ row pairs.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one in computing $bot=x+k-1-d$.
\item Accidentally reversing columns instead of rows.
\item Writing outside the $[y, y+k-1]$ column range.
\item Mutating the input when a copy is intended in tests.
\item Forgetting zero-based indexing.
\item Mixing up $m$ and $n$ when asserting bounds.
\end{bullets}
}
\FAILMODES{A column-wise reversal produces wrong answers; skipping the slice bounds can corrupt adjacent columns; missing symmetry in loops for odd $k$ can double-swap or miss rows. The in-place pair-swap method avoids extra memory and is robust.}
\ELI{We just flip the chosen square upside down. Swap the top row with the bottom row, the next with the next, and so on, leaving everything else alone.}
\NotePages{3}

\end{document}