% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Caesar Cipher}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/470/D}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{Caesar cipher is one of the simplest encryption techniques. To transform the original message into encrypted one using key $k$, one has to replace each letter with a letter which is $k$ positions later in the alphabet (if this takes the position beyond Z, the rest of it is counted from the start of the alphabet). In a more formal way, if letters of the alphabet are enumerated starting with $0$, the result of encryption for character $x$ will be $ (x + k) \bmod 26 $ (26 is the number of letters in the Latin alphabet).

You are given the original message and the encryption key $k$. Output the result of encryption.

Input:
The first line of input contains an integer $k$ ($0 \le k \le 25$) — the encryption key.

The second line contains the original message — a sequence of uppercase Latin letters ('A'-'Z'). The length of the message is from $1$ to $10$, inclusive.

Output:
Output the result of encryption.}
\BREAKDOWN{Map each character to its $0$-based alphabet index, add $k$ modulo $26$, and map back to an uppercase letter. Handle wrap-around and preserve length.}
\ELI{Shift every uppercase letter forward by $k$ spots around a circular $26$-letter alphabet.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two-line input:\\
-- Line 1: integer $k$, where $0 \le k \le 25$.\\
-- Line 2: string $s$ of length $1$ to $10$ consisting only of 'A'--'Z'.}
\OUTPUTS{Print one line: the encrypted string of the same length, obtained by shifting each character of $s$ forward by $k$ modulo $26$.}
\SAMPLES{Example 1:\\
Input:\\
2\\
ABC\\
Output:\\
CDE

Example 2 (wrap-around):\\
Input:\\
3\\
XYZ\\
Output:\\
ABC}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the alphabet be $\{0,1,\ldots,25\}$ with the mapping $A\mapsto 0,\ldots,Z\mapsto 25$. For input string $s = s_0 s_1 \ldots s_{n-1}$ and key $k\in\{0,\ldots,25\}$, the encrypted string $t$ is $t_i = \phi\!\big((\psi(s_i)+k)\bmod 26\big)$, where $\psi$ maps letters to indices and $\phi$ maps indices back to letters.}
\varmapStart
\var{k}{integer shift, $0 \le k \le 25$}
\var{s}{input uppercase string, $|s|=n$}
\var{n}{length of $s$}
\var{\psi}{letter-to-index map: $\psi(\text{`A'})=0,\ldots,\psi(\text{`Z'})=25$}
\var{\phi}{index-to-letter map: inverse of $\psi$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i\in\{0,\ldots,n-1\}:\quad t_i \;=\; \phi\!\left( \left( \psi(s_i) + k \right) \bmod 26 \right).
\end{BreakableEquation*}
}
\ASSUMPTIONS{All input characters are uppercase Latin letters. Indexing is $0$-based. No whitespace appears inside the message.}
\INVARIANTS{Length preservation: $|t|=|s|$.\\
Alphabet preservation: $t$ consists only of 'A'--'Z'.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly apply $t_i = \phi\!\big((\psi(s_i)+k)\bmod 26\big)$ per character.}
\ASSUMPTIONS{Characters are in 'A'--'Z', so subtraction by 'A' yields indices in $[0,25]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Normalize $k \leftarrow k \bmod 26$.
\item For each character $c$ in $s$, compute $x = \text{ord}(c) - \text{ord}(\text{`A'})$.
\item Output $\text{chr}(\text{ord}(\text{`A'}) + (x + k)\bmod 26)$ for each $c$ and concatenate.
\end{algosteps}
\COMPLEXITY{Linear in message length.}
\[
\begin{aligned}
T(n) &= \Theta(n), \\
S(n) &= \Theta(1) \text{ auxiliary (output excluded).}
\end{aligned}
\]
\CORRECTNESS{Each character is mapped via the canonical $0$-to-$25$ encoding and wrapped modulo $26$, which exactly matches the specification.}
\EDGECASES{Handle $k=0$ (identity), $k=25$ (shift by $-1$), and wrap-around at 'Z'.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, io, contextlib

def read_input(data: str | None = None) -> tuple[int, str]:
    if data is None:
        data = sys.stdin.read()
    toks = data.split()
    assert len(toks) >= 2, "Expected two tokens: k and the message"
    k = int(toks[0])
    s = toks[1].strip()
    return k, s

def encrypt_shift(s: str, k: int) -> str:
    k %= 26
    base = ord('A')
    out = []
    for ch in s:
        x = ord(ch) - base
        y = (x + k) % 26
        out.append(chr(base + y))
    return ''.join(out)

def solve_case(k: int, s: str) -> str:
    return encrypt_shift(s, k)

def solve_all() -> str:
    k, s = read_input()
    return solve_case(k, s)

def main() -> None:
    sys.stdout.write(solve_all())

def _self_test() -> None:
    assert encrypt_shift("ABC", 2) == "CDE"
    assert encrypt_shift("XYZ", 3) == "ABC"
    assert encrypt_shift("HELLOWORLD", 0) == "HELLOWORLD"
    # IO test
    data = "2\nABC\n"
    with contextlib.ExitStack() as st:
        fake_in = io.StringIO(data)
        fake_out = io.StringIO()
        st.enter_context(contextlib.redirect_stdin(fake_in))
        st.enter_context(contextlib.redirect_stdout(fake_out))
        main()
        assert fake_out.getvalue().strip() == "CDE"

if __name__ == "__main__":
    _self_test()
    main()
\end{minted}
\VALIDATION{Checked identity shift, wrap-around, and a small end-to-end I/O test.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Precompute a translation table via rotated alphabet and apply $s.\text{translate}(\cdot)$ in one pass.}
\ASSUMPTIONS{Python string translation is efficient and operates in $O(n)$ time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Normalize $k \leftarrow k \bmod 26$.
\item Build source alphabet $S = \text{``ABCDEFGHIJKLMNOPQRSTUVWXYZ''}$.
\item Build target alphabet $T = S[k:]+S[:k]$ and a translation table with \texttt{str.maketrans(S, T)}.
\item Return $s.\text{translate}(\text{table})$.
\end{algosteps}
\COMPLEXITY{Still linear, but with fewer Python-level operations per character.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S(n) = \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Translation table implements exactly the bijection $i \mapsto (i+k)\bmod 26$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, io, contextlib

ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def read_input(data: str | None = None) -> tuple[int, str]:
    if data is None:
        data = sys.stdin.read()
    toks = data.split()
    assert len(toks) >= 2
    k = int(toks[0])
    s = toks[1].strip()
    return k, s

def build_table(k: int) -> dict[int, int]:
    k %= 26
    src = ALPH
    dst = ALPH[k:] + ALPH[:k]
    return str.maketrans(src, dst)

def solve_case(k: int, s: str) -> str:
    table = build_table(k)
    return s.translate(table)

def solve_all() -> str:
    k, s = read_input()
    return solve_case(k, s)

def main() -> None:
    sys.stdout.write(solve_all())

def _self_test() -> None:
    # basic
    assert solve_case(2, "ABC") == "CDE"
    assert solve_case(3, "XYZ") == "ABC"
    # extremes
    assert solve_case(0, "Z") == "Z"
    assert solve_case(25, "A") == "Z"
    # IO test
    data = "3\nXYZ\n"
    with contextlib.ExitStack() as st:
        fake_in = io.StringIO(data)
        fake_out = io.StringIO()
        st.enter_context(contextlib.redirect_stdin(fake_in))
        st.enter_context(contextlib.redirect_stdout(fake_out))
        main()
        assert fake_out.getvalue().strip() == "ABC"

if __name__ == "__main__":
    _self_test()
    main()
\end{minted}
\VALIDATION{Verified wrap-around at alphabet end and table construction symmetry.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use a precomputed translation table and apply it once; this achieves the minimal asymptotic cost $\Theta(n)$ for reading and writing $n$ characters.}
\ASSUMPTIONS{The input consists solely of uppercase letters and a single integer key.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $k$ and $s$.
\item Compute translation table for shift $k \bmod 26$.
\item Output $s.\text{translate}(\cdot)$.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect all $n$ input characters and produce $n$ output characters, so $\Omega(n)$ time is necessary. The method matches this lower bound.}
\COMPLEXITY{Linear time and constant extra space.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S(n) = \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, io, contextlib

ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def read_input(data: str | None = None) -> tuple[int, str]:
    if data is None:
        data = sys.stdin.read()
    toks = data.split()
    assert len(toks) >= 2
    k = int(toks[0])
    s = toks[1].strip()
    return k, s

def solve_case(k: int, s: str) -> str:
    k %= 26
    trans = str.maketrans(ALPH, ALPH[k:] + ALPH[:k])
    return s.translate(trans)

def solve_all() -> str:
    k, s = read_input()
    return solve_case(k, s)

def main() -> None:
    sys.stdout.write(solve_all())

def _self_test() -> None:
    assert solve_case(2, "ABC") == "CDE"
    assert solve_case(3, "XYZ") == "ABC"
    assert solve_case(0, "HELLO") == "HELLO"
    # I/O test
    data = "25\nA\n"
    with contextlib.ExitStack() as st:
        fake_in = io.StringIO(data)
        fake_out = io.StringIO()
        st.enter_context(contextlib.redirect_stdin(fake_in))
        st.enter_context(contextlib.redirect_stdout(fake_out))
        main()
        assert fake_out.getvalue().strip() == "Z"

if __name__ == "__main__":
    _self_test()
    main()
\end{minted}
\VALIDATION{Exactly 3 assertions, including an I/O round-trip.}
\RESULT{Print the fully encrypted uppercase string; no ties or ambiguities.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the per-character mapping, wrap-around behavior, identity shift, and end-to-end I/O.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach A and B on random short strings and keys to ensure equivalence.}
\LINE{EDGE-CASE GENERATOR}{Generate smallest and largest lengths, and keys $k\in\{0,25\}$.}
\begin{minted}{python}
import random, string

def gen_random_case(n: int) -> tuple[int, str]:
    k = random.randint(0, 25)
    s = "".join(random.choice(string.ascii_uppercase) for _ in range(n))
    return k, s

def brute_encrypt(s: str, k: int) -> str:
    base = ord('A'); k %= 26
    return "".join(chr(base + ((ord(ch)-base + k) % 26)) for ch in s)

def table_encrypt(s: str, k: int) -> str:
    ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; k %= 26
    trans = str.maketrans(ALPH, ALPH[k:] + ALPH[:k])
    return s.translate(trans)

# Cross-check small randoms deterministically
random.seed(0)
for n in range(1, 11):
    for _ in range(20):
        k, s = gen_random_case(n)
        assert brute_encrypt(s, k) == table_encrypt(s, k)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def read_input(data: str | None = None) -> tuple[int, str]:
    if data is None:
        data = sys.stdin.read()
    toks = data.split()
    assert len(toks) >= 2
    k = int(toks[0])
    s = toks[1].strip()
    return k, s

def solve_case(k: int, s: str) -> str:
    k %= 26
    trans = str.maketrans(ALPH, ALPH[k:] + ALPH[:k])
    return s.translate(trans)

def solve_all() -> str:
    k, s = read_input()
    return solve_case(k, s)

def main() -> None:
    sys.stdout.write(solve_all())

# Basic asserts (won't print anything; safe for submission)
def _self_check() -> None:
    assert solve_case(2, "ABC") == "CDE"
    assert solve_case(3, "XYZ") == "ABC"
    assert solve_case(0, "A") == "A"

if __name__ == "__main__":
    _self_check()
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Shift each uppercase character by $k$ modulo $26$.}
\WHY{Classic warm-up that checks attention to modular arithmetic, mapping between letters and indices, and careful I/O.}
\CHECKLIST{%
\begin{bullets}
\item Normalize $k$ with $k \bmod 26$.
\item Map 'A' $\leftrightarrow 0$ via \texttt{ord}/\texttt{chr} or a translation table.
\item Preserve string length and character set.
\item Print exactly one line with no extra spaces.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $k=0$ should return the input unchanged.
\item $k=25$ shifts each letter backward by $1$.
\item Wrap-around: 'Z' with $k=1$ becomes 'A'.
\item Minimal length $|s|=1$.
\item Maximal length $|s|=10$.
\item All same letters, e.g., 'AAAAA'.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to apply modulo $26$ to $k$.
\item Off-by-one with base index (not subtracting 'A').
\item Handling lowercase or non-letters (not present here, but code should assume uppercase only).
\item Printing extra newlines or spaces.
\item Misreading input when there are trailing spaces.
\item Using locale-specific alphabets; must be fixed 'A'--'Z'.
\end{bullets}
}
\FAILMODES{Weaker approaches that assume ASCII contiguity without modulo will fail at wrap-around ('Z' + $1$). The presented method wraps correctly.}
\ELI{Think of letters around a circle of $26$ spots. Move each letter $k$ steps forward; if you pass 'Z', continue from 'A'.}
\NotePages{3}

\end{document}