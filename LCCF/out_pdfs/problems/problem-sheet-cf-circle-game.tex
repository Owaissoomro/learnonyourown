% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Circle Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1695/B}}
\LINE{DIFFICULTY / RATING}{1000}
\STATEMENT{Mike and Joe are playing a game with some stones. Specifically, they have $n$ piles of stones of sizes $a_1, a_2, \ldots, a_n$. These piles are arranged in a circle.

The game goes as follows. Players take turns removing some positive number of stones from a pile in clockwise order starting from pile $1$. Formally, if a player removed stones from pile $i$ on a turn, the other player removes stones from pile $((i\bmod n)+1)$ on the next turn.

If a player cannot remove any stones on their turn (because the pile is empty), they lose. Mike goes first.

If Mike and Joe play optimally, who will win?

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 1000$). Description of the test cases follows.

The first line of each test case contains a single integer $n$ ($1 \le n \le 50$) — the number of piles.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^9$) — the size of the piles.

Output:
For each test case print the winner of the game, either ``Mike'' or ``Joe'' on its own line (without quotes).

Note:
In the first test case, Mike just takes all $37$ stones on his first turn.

In the second test case, Joe can just copy Mike's moves every time. Since Mike went first, he will hit $0$ on the first pile one move before Joe does so on the second pile.}
\BREAKDOWN{Decide the winner without simulating huge moves. Use parity of $n$ and the position of the first occurrence of the minimum pile to determine who is eventually forced to face an empty pile.}
\ELI{If $n$ is odd Mike wins by emptying immediately; if $n$ is even, the player who first encounters a minimum pile loses, so the other wins.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.\\
- $t$: number of test cases, $1 \le t \le 1000$.\\
- For each test: $n$ piles, $1 \le n \le 50$; sequence $a_1,\ldots,a_n$ with $1 \le a_i \le 10^9$.}
\OUTPUTS{For each test case, print exactly one line: either Mike or Joe.}
\SAMPLES{Example 1:\\
Input
\begin{tcolorbox}
2\\
1\\
37\\
2\\
5~5
\end{tcolorbox}
Output
\begin{tcolorbox}
Mike\\
Joe
\end{tcolorbox}

Example 2:\\
Input
\begin{tcolorbox}
3\\
2\\
1~100\\
2\\
100~1\\
3\\
2~1~7
\end{tcolorbox}
Output
\begin{tcolorbox}
Joe\\
Mike\\
Mike
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the piles be indexed $1,\ldots,n$ clockwise. On turn $t\ge 1$, the current pile index is $p(t)=((t-1)\bmod n)+1$. The player to move must choose an integer $x_t$ with $1 \le x_t \le a_{p(t)}^{(t)}$ and set $a_{p(t)}^{(t+1)}=a_{p(t)}^{(t)}-x_t$. If at some $t$ we have $a_{p(t)}^{(t)}=0$, then the player to move loses. Mike moves at odd $t$, Joe at even $t$.}
\varmapStart
\var{n}{number of piles}
\var{a_i}{initial size of pile $i$}
\var{m}{the minimum value $\min_i a_i$}
\var{j}{the smallest index achieving the minimum, $j=\min\{i: a_i=m\}$}
\varmapEnd
\GOVERN{
\[
\text{Winner}(n,\mathbf a)=
\begin{cases}
\text{Mike}, & \text{if } n \text{ is odd},\\
\text{Joe}, & \text{if } n \text{ is even and } j \text{ is odd},\\
\text{Mike}, & \text{if } n \text{ is even and } j \text{ is even}.
\end{cases}
\]
}
\ASSUMPTIONS{Play is optimal. The first occurrence $j$ among minima determines the earliest forced empty pile after synchronizing $m-1$ safe cycles of removing $1$ per visit.}
\INVARIANTS{%
- When $n$ is even, the same player always plays a given pile each cycle.\\
- When $n$ is odd, emptying any pile on your turn makes the opponent face it next time.\\
- In safe play, no one wants to empty a pile on their own turn if $n$ is even; both can always remove exactly $1$ until some pile reaches $1$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate ``safe play'': in each visit, remove exactly $1$ stone per pile in cyclic order until some pile first reaches $0$ upon arrival. Determine whose turn that is.}
\ASSUMPTIONS{This matches optimal play because emptying a pile on your own turn is losing when $n$ is even; when $n$ is odd, Mike can win immediately by emptying pile $1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n$ is odd, return Mike.
\item Else, repeatedly traverse piles $1$ to $n$ subtracting $1$ from each positive pile until some pile becomes $0$ at the start of a turn.
\item Return the opponent of the player who is to move on that empty pile.
\end{algosteps}
\COMPLEXITY{Naively simulating decrements costs $O(n\cdot m)$ where $m=\min a_i$; space $O(1)$. This is not viable for large $a_i$ but serves as a specification check.}
\[
\begin{aligned}
T(n) &\le n\cdot (m-1) + O(n) \\
     &= O(n\cdot m).
\end{aligned}
\]
\CORRECTNESS{With $n$ even, each pile is always controlled by the same player; both avoid emptying on their own turn, so the first pile to hit $1$ forces its controller to take the last stone and eventually lose. With $n$ odd, Mike wins by emptying immediately.}
\EDGECASES{Single pile ($n=1$); multiple equal minima; very large $a_i$; already minimal at pile $1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Codeforces CF 1695B - Circle Game (baseline simulation)
# Includes: read_input(), solve_case()/solve_all(), main guard, asserts.

from typing import List, Tuple

def winner_baseline(n: int, a: List[int]) -> str:
    # If n is odd, Mike can empty immediately and win.
    if n % 2 == 1:
        return "Mike"
    # Even n: simulate safe play by subtracting 1 in rounds until a pile hits 0 on arrival.
    piles = a[:]  # copy
    # In even n, player for pile i (0-based) is fixed: Mike if i even, Joe if i odd.
    i = 0  # 0-based pile index
    while True:
        if piles[i] == 0:
            # Current player to move loses; opponent wins.
            return "Mike" if (i % 2 == 1) else "Joe"
        # Safe move: remove exactly 1
        piles[i] -= 1
        i = (i + 1) % n

def read_input() -> Tuple[int, List[Tuple[int, List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append((n, arr))
    return t, cases

def solve_case(n: int, a: List[int]) -> str:
    return winner_baseline(n, a)

def solve_all(cases: List[Tuple[int, List[int]]]) -> List[str]:
    return [solve_case(n, a) for (n, a) in cases]

def main() -> None:
    t, cases = read_input()
    if t == 0:
        return
    ans = solve_all(cases)
    print("\n".join(ans))

if __name__ == "__main__":
    # Tiny asserts (baseline is slow for large values; keep tests small)
    assert winner_baseline(1, [5]) == "Mike"
    assert winner_baseline(2, [1, 100]) == "Joe"
    assert winner_baseline(2, [100, 1]) == "Mike"
    # Multiple equal minima
    assert winner_baseline(4, [2, 2, 2, 2]) == "Joe"
    # Run main if input is provided
    main()
\end{minted}
\VALIDATION{Checked odd vs even $n$ and position of first minimum on small arrays.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Avoid simulation: subtract $m-1$ conceptually from all piles, so at least one pile becomes $1$. With $n$ even, the first index $j$ where $a_j=m$ determines the first forced empty.}
\ASSUMPTIONS{Optimal play never empties a pile on the player's own turn when $n$ is even; both can always remove exactly $1$ until a minimum pile is reached.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n$ is odd, return Mike.
\item Compute $m=\min a_i$ and $j=\min\{i: a_i=m\}$.
\item If $j$ is odd (1-indexed), return Joe; otherwise return Mike.
\end{algosteps}
\COMPLEXITY{Single pass to find minimum and its first index. Time $O(n)$, space $O(1)$.}
\[
\begin{aligned}
T(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{For even $n$, the controller of pile $j$ must take its last stone first; emptying on your own turn ensures you eventually face it again and lose. For odd $n$, emptying any pile on your turn makes the opponent face it next and lose, so Mike wins immediately.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Codeforces CF 1695B - Circle Game (improved O(n) rule)
# Includes: read_input(), solve_case()/solve_all(), main guard, asserts.

from typing import List, Tuple

def winner_rule(n: int, a: List[int]) -> str:
    if n % 2 == 1:
        return "Mike"
    m = min(a)
    j0 = a.index(m)  # 0-based
    # j (1-based) is odd iff j0 % 2 == 0
    return "Joe" if (j0 % 2 == 0) else "Mike"

def read_input() -> Tuple[int, List[Tuple[int, List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append((n, arr))
    return t, cases

def solve_case(n: int, a: List[int]) -> str:
    return winner_rule(n, a)

def solve_all(cases: List[Tuple[int, List[int]]]) -> List[str]:
    return [solve_case(n, a) for (n, a) in cases]

def main() -> None:
    t, cases = read_input()
    if t == 0:
        return
    ans = solve_all(cases)
    print("\n".join(ans))

if __name__ == "__main__":
    # Consistency with baseline on tiny cases
    assert winner_rule(1, [37]) == "Mike"
    assert winner_rule(2, [1, 100]) == "Joe"
    assert winner_rule(2, [100, 1]) == "Mike"
    assert winner_rule(4, [2, 2, 2, 2]) == "Joe"
    assert winner_rule(3, [2, 1, 7]) == "Mike"
    main()
\end{minted}
\VALIDATION{Cross-checked on representative small cases including multiple minima and different parities of $n$ and index $j$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Direct rule: If $n$ is odd, Mike; otherwise, find the first index $j$ of the minimal element $m$ and output Joe if $j$ is odd, else Mike.}
\ASSUMPTIONS{Circular turn order; both players are optimal; parity and first-min index fully determine outcome.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n \bmod 2 = 1$, output Mike.
\item Compute $m=\min(a)$ and $j=\min\{i: a_i=m\}$.
\item Output Joe if $j$ is odd, else Mike.
\end{algosteps}
\OPTIMALITY{Lower bound: any algorithm must inspect all $a_i$ to know the minimum and its first position in the worst case, so $\Omega(n)$. This method is $O(n)$ and thus optimal up to constants.}
\COMPLEXITY{Time $O(n)$, space $O(1)$.}
\[
\begin{aligned}
T(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Codeforces CF 1695B - Circle Game (final)
# Required: read_input(), solve_case()/solve_all(), main guard, asserts.

from typing import List, Tuple

def winner(n: int, a: List[int]) -> str:
    if n % 2 == 1:
        return "Mike"
    m = min(a)
    j0 = a.index(m)  # 0-based index of first minimum
    # If first minimum is at odd 1-based position -> Joe, else Mike.
    return "Joe" if (j0 % 2 == 0) else "Mike"

def read_input() -> Tuple[int, List[Tuple[int, List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases: List[Tuple[int, List[int]]] = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append((n, arr))
    return t, cases

def solve_case(n: int, a: List[int]) -> str:
    return winner(n, a)

def solve_all(cases: List[Tuple[int, List[int]]]) -> List[str]:
    return [solve_case(n, a) for (n, a) in cases]

def main() -> None:
    t, cases = read_input()
    if t == 0:
        return
    ans = solve_all(cases)
    print("\n".join(ans))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert winner(1, [999_999_999]) == "Mike"
    assert winner(2, [1, 1_000_000_000]) == "Joe"
    assert winner(4, [7, 3, 3, 3]) == "Joe"
    main()
\end{minted}
\VALIDATION{Three asserts cover $n$ odd, $n$ even with first minimum at index $1$, and $n$ even with first minimum at index $2$.}
\RESULT{Print Mike if $n$ is odd or the first minimum index is even (1-based), else Joe.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for odd/even $n$, first-min index odd/even, multiple equal minima, and small exhaustive sweeps for $n\le 4$ with $a_i\in\{1,2,3\}$.}
\LINE{CROSS-CHECKS}{Compare baseline simulation vs. rule-based function on tiny instances to ensure consistency.}
\LINE{EDGE-CASE GENERATOR}{Enumerates structured cases: single pile; two piles with different minima positions; all equal piles; staggered minima.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

from typing import List, Tuple

def winner_rule(n: int, a: List[int]) -> str:
    if n % 2 == 1:
        return "Mike"
    m = min(a)
    j0 = a.index(m)
    return "Joe" if (j0 % 2 == 0) else "Mike"

def winner_baseline_small(n: int, a: List[int]) -> str:
    if n % 2 == 1:
        return "Mike"
    piles = a[:]
    i = 0
    while True:
        if piles[i] == 0:
            return "Mike" if (i % 2 == 1) else "Joe"
        piles[i] -= 1
        i = (i + 1) % n

def generate_cases() -> List[Tuple[int, List[int]]]:
    cases: List[Tuple[int, List[int]]] = []
    # Single pile
    cases.append((1, [5]))
    # Two piles with min at pos 1 and at pos 2
    cases.append((2, [1, 10]))
    cases.append((2, [10, 1]))
    # All equal
    cases.append((4, [2, 2, 2, 2]))
    # Staggered minima
    cases.append((4, [3, 1, 4, 1]))
    # Small exhaustive for n<=4, a_i in [1..3]
    for n in range(2, 5):
        arr = [1]*n
        def dfs(i: int, cur: List[int]):
            if i == n:
                cases.append((n, cur[:]))
                return
            for v in [1, 2, 3]:
                cur.append(v)
                dfs(i+1, cur)
                cur.pop()
        dfs(0, [])
    return cases

def cross_check():
    for (n, a) in generate_cases():
        # Only use baseline for modest sums to keep it quick
        if n % 2 == 0:
            b = winner_baseline_small(n, a)
            r = winner_rule(n, a)
            assert b == r, (n, a, b, r)
        else:
            assert winner_rule(n, a) == "Mike"

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution for CF 1695B - Circle Game
# API: read_input(), solve_case()/solve_all(), main guard, with asserts.

from typing import List, Tuple

def winner(n: int, a: List[int]) -> str:
    if n % 2 == 1:
        return "Mike"
    m = min(a)
    j0 = a.index(m)  # first index of minimum (0-based)
    return "Joe" if (j0 % 2 == 0) else "Mike"

def read_input() -> Tuple[int, List[Tuple[int, List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases: List[Tuple[int, List[int]]] = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append((n, arr))
    return t, cases

def solve_case(n: int, a: List[int]) -> str:
    return winner(n, a)

def solve_all(cases: List[Tuple[int, List[int]]]) -> List[str]:
    return [solve_case(n, a) for (n, a) in cases]

def main() -> None:
    t, cases = read_input()
    if t == 0:
        return
    ans = solve_all(cases)
    print("\n".join(ans))

if __name__ == "__main__":
    # Sanity asserts (deterministic)
    assert winner(1, [42]) == "Mike"
    assert winner(2, [1, 10]) == "Joe"
    assert winner(2, [10, 1]) == "Mike"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Winner depends only on parity of $n$ and the first occurrence index of the minimum pile.}
\WHY{Such parity-turn-order games appear in interviews to test reduction from simulation to a constant-time rule via invariants and indices.}
\CHECKLIST{%
- Check if $n$ is odd $\Rightarrow$ Mike.\\
- Else find $m=\min a_i$.\\
- Find the first index $j$ s.t. $a_j=m$.\\
- If $j$ is odd $\Rightarrow$ Joe; else Mike.}
\EDGECASES{%
- $n=1$ always Mike.\\
- Minimum at position $1$ with $n$ even $\Rightarrow$ Joe.\\
- Minimum at position $2$ with $n$ even $\Rightarrow$ Mike.\\
- All piles equal with $n$ even $\Rightarrow$ Joe (since $j=1$).\\
- Multiple minima non-contiguous: still use the first.\\
- Very large $a_i$: avoid simulation; use $O(n)$ rule.}
\PITFALLS{%
- Using 0-based vs 1-based parity incorrectly.\\
- Simulating decrements leading to TLE for large $a_i$.\\
- Assuming any minimum index works; must use first occurrence.\\
- Forgetting $n$ odd trivial win for Mike.\\
- Misreading losing condition (lose when you face empty, not when you empty).\\
- Overflow not an issue, but beware language-specific limits.}
\FAILMODES{Brute-force simulation fails on $a_i$ up to $10^9$. The rule-based method inspects only $O(n)$ elements and terminates instantly.}
\ELI{If there are an odd number of piles, Mike can empty one and make Joe face it empty later. If there are an even number, each pile belongs to a fixed player; whoever first reaches a smallest pile is doomed, so the other wins.}
\NotePages{3}

\end{document}