% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Difference in Sums After Removal of Elements}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a 0-indexed integer array \texttt{nums} consisting of $3n$ elements. You are allowed to remove any subsequence of elements of size exactly $n$ from \texttt{nums}. The remaining $2n$ elements will be divided into two equal parts in their original order:
\begin{bullets}
\item The first $n$ remaining elements form the first part with sum denoted $ \texttt{sumfirst}$.
\item The next $n$ remaining elements form the second part with sum denoted $ \texttt{sumsecond}$.
\end{bullets}
The difference in sums is defined as $ \texttt{sumfirst} - \texttt{sumsecond}$. For example, if \texttt{sumfirst} $=3$ and \texttt{sumsecond} $=2$, the difference is $1$; if \texttt{sumfirst} $=2$ and \texttt{sumsecond} $=3$, the difference is $-1$.

Return the minimum possible value of $ \texttt{sumfirst} - \texttt{sumsecond}$ that can be achieved after removing exactly $n$ elements.

Examples:
\begin{bullets}
\item Input: \texttt{nums = [3,1,2]}. Output: \texttt{-1}. Explanation: $n=1$. If we remove \texttt{nums[0]}$=3$, the remaining array is \texttt{[1,2]} and the difference is $1-2=-1$, which is minimal.
\item Input: \texttt{nums = [7,9,5,8,1,3]}. Output: \texttt{1}. Explanation: $n=2$. Removing \texttt{nums[1]}$=9$ and \texttt{nums[4]}$=1$ yields \texttt{[7,5,8,3]} with difference $(7+5)-(8+3)=1$, which is minimal.
\end{bullets}
Constraints:
\begin{bullets}
\item \texttt{nums.length} $= 3n$.
\item $1 \le n \le 10^5$.
\item $1 \le \texttt{nums[i]} \le 10^5$.
\end{bullets}}
\BREAKDOWN{We must choose exactly $n$ elements to delete so that, when the remaining $2n$ elements are split in order, the difference of the sums of the two $n$-blocks is minimized. Reformulate the choice as: choose $n$ kept elements among the first $2n$ positions (forming the left block) and $n$ kept elements among the last $2n$ positions (forming the right block). Precompute minimal achievable left sums and maximal achievable right sums, then scan a split.}
\ELI{Pick $n$ small numbers early and $n$ large numbers late to make left sum small and right sum large, then try all valid split points efficiently with heaps.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode method signature: \texttt{minimumDifference(self, nums: List[int]) -> int}. The array \texttt{nums} has length $3n$ with $1 \le n \le 10^5$ and each element in $[1, 10^5]$.}
\OUTPUTS{Return the minimum possible value of $\texttt{sumfirst}-\texttt{sumsecond}$ after removing exactly $n$ elements and keeping order among the remaining elements.}
\SAMPLES{
\begin{bullets}
\item \texttt{nums = [3,1,2]} $\to$ \texttt{-1}
\item \texttt{nums = [7,9,5,8,1,3]} $\to$ \texttt{1}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the original indices be $\{0,1,\ldots,3n-1\}$. We remove exactly $n$ indices to form a kept sequence $K$ of length $2n$ preserving order. The first $n$ elements of $K$ form set (ordered) $L$ and the last $n$ form $R$. Objective: minimize
\begin{BreakableEquation*}
\sum_{i \in L} \texttt{nums}[i] - \sum_{j \in R} \texttt{nums}[j].
\end{BreakableEquation*}
Equivalently, pick a split $s \in \{n-1,\ldots,2n-1\}$, pick $n$ kept indices in $[0..s]$ and $n$ kept indices in $[s+1..3n-1]$, minimizing the left sum and maximizing the right sum.}
\varmapStart
\var{n}{one third of the array length}
\var{s}{split index where the left kept block ends in the original array}
\var{L}{indices of the $n$ kept elements on the left side, $L \subseteq [0..s]$}
\var{R}{indices of the $n$ kept elements on the right side, $R \subseteq [s+1..3n-1]$}
\var{l\_min[s]}{minimal possible sum of $n$ elements chosen from prefix $[0..s]$}
\var{r\_max[s+1]}{maximal possible sum of $n$ elements chosen from suffix $[s+1..3n-1]$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\min_{s \in [n-1,\,2n-1]} \Big( l\_min[s] - r\_max[s+1] \Big)
\end{BreakableEquation*}
}
\ASSUMPTIONS{Order is preserved after removals. All elements are integers. A feasible split exists for each $s \in [n-1,2n-1]$ because the prefix has at least $n$ elements and the suffix has at least $n$ elements.}
\INVARIANTS{
\begin{bullets}
\item For each $s$, $l\_min[s]$ is the sum of the $n$ smallest values in \texttt{nums}$[0..s]$.
\item For each $t$, $r\_max[t]$ is the sum of the $n$ largest values in \texttt{nums}$[t..3n-1]$.
\item The optimal solution can be realized by some split $s$ with the left and right halves selected independently on their respective ranges.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all choices of exactly $n$ deletions, keep the remaining $2n$ elements, and compute the difference between the first $n$ and last $n$ kept elements.}
\ASSUMPTIONS{Only feasible for tiny $n$, as the number of deletion sets is $\binom{3n}{n}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all $\binom{3n}{n}$ subsets of indices to delete.
\item Build the kept sequence by filtering out the deleted indices.
\item Compute difference as sum of the first $n$ kept elements minus sum of the last $n$ kept elements. Track the minimum.
\end{algosteps}
\COMPLEXITY{Exponential in $n$. Time $\Theta\!\big(\binom{3n}{n} \cdot n\big)$, space $\Theta(n)$ for building the kept sequence.}
\[
\begin{aligned}
T(n) &= \binom{3n}{n}\cdot O(n) \\
     &\text{(hopeless for large $n$, but good as a correctness oracle on tiny cases).}
\end{aligned}
\]
\CORRECTNESS{Complete search considers every valid deletion set and computes the exact objective for each, hence returns the true minimum.}
\EDGECASES{Smallest case $n=1$; duplicates; strictly increasing/decreasing arrays.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
import itertools

class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 3
        N = len(nums)
        best = None
        idx = list(range(N))
        for rem in itertools.combinations(idx, n):
            rem_set = set(rem)
            kept = [nums[i] for i in idx if i not in rem_set]
            diff = sum(kept[:n]) - sum(kept[n:])
            if best is None or diff < best:
                best = diff
        return 0 if best is None else best

# Tiny validation (baseline suitable only for tiny inputs)
assert Solution().minimumDifference([3,1,2]) == -1
assert Solution().minimumDifference([7,9,5,8,1,3]) == 1
assert Solution().minimumDifference([1,2,3]) == -1
\end{minted}
\VALIDATION{Cross-check on tiny arrays where enumeration is feasible.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prefix-Min and Suffix-Max via Heaps}
\WHICHFORMULA{For each split $s \in [n-1,2n-1]$, the left block sum is minimized by taking the $n$ smallest elements from prefix $[0..s]$, and the right block sum is maximized by taking the $n$ largest elements from suffix $[s+1..3n-1]$. Maintain these with two heaps in $O(n \log n)$.}
\ASSUMPTIONS{We can compute:
\begin{bullets}
\item $l\_min[s]$ using a max-heap of size $n$ over the prefix (keep the $n$ smallest).
\item $r\_max[t]$ using a min-heap of size $n$ over the suffix (keep the $n$ largest).
\end{bullets}
}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Left sweep: iterate $i=0..3n-1$, push numbers into a max-heap storing negatives; keep its size at $n$. Track running sum to fill $l\_min[i]$ when heap size is $n$.
\item Right sweep: iterate $i=3n-1..0$, push into a min-heap; keep its size at $n$. Track running sum to fill $r\_max[i]$ when heap size is $n$.
\item Answer is $\min_{s=n-1}^{2n-1} \big( l\_min[s] - r\_max[s+1] \big)$.
\end{algosteps}
\COMPLEXITY{Two linear scans with $O(\log n)$ heap updates per element. Time $O(n \log n)$ and space $O(n)$ for arrays and heaps.}
\[
\begin{aligned}
T(n) &= O(3n \log n) = O(n \log n) \\
\end{aligned}
\]
\CORRECTNESS{For any fixed split, the two sides are independent. The minimal left sum is attained by choosing the $n$ smallest values in the prefix; the maximal right sum by choosing the $n$ largest values in the suffix. Taking the best over all valid splits yields the global minimum difference.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import heapq
import random

class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        N = len(nums)
        n = N // 3

        # lmin[i] = minimal sum of n elements from nums[0..i]
        lmin = [None] * N
        maxheap = []  # store negatives to simulate max-heap of kept (n smallest)
        lsum = 0
        for i, x in enumerate(nums):
            heapq.heappush(maxheap, -x)
            lsum += x
            if len(maxheap) > n:
                lsum += heapq.heappop(maxheap)  # subtract the largest (negative value added)
            if len(maxheap) == n:
                lmin[i] = lsum

        # rmax[i] = maximal sum of n elements from nums[i..N-1]
        rmax = [None] * N
        minheap = []  # keeps the n largest via popping smaller ones
        rsum = 0
        for i in range(N - 1, -1, -1):
            x = nums[i]
            heapq.heappush(minheap, x)
            rsum += x
            if len(minheap) > n:
                rsum -= heapq.heappop(minheap)  # remove smallest to keep n largest
            if len(minheap) == n:
                rmax[i] = rsum

        ans = None
        # split s in [n-1, 2n-1], compare lmin[s] - rmax[s+1]
        for s in range(n - 1, 2 * n):
            diff = lmin[s] - rmax[s + 1]
            if ans is None or diff < ans:
                ans = diff
        return 0 if ans is None else ans

# Checks (deterministic)
assert Solution().minimumDifference([3,1,2]) == -1
assert Solution().minimumDifference([7,9,5,8,1,3]) == 1
# Cross-check vs brute force on a tiny random case
def brute(nums: List[int]) -> int:
    import itertools
    n = len(nums)//3
    N = len(nums)
    best = None
    for rem in itertools.combinations(range(N), n):
        rem = set(rem)
        kept = [nums[i] for i in range(N) if i not in rem]
        val = sum(kept[:n]) - sum(kept[n:])
        if best is None or val < best:
            best = val
    return best
tiny = [2,1,3]
assert Solution().minimumDifference(tiny) == brute(tiny)
\end{minted}
\VALIDATION{Compared against brute force on tiny arrays; verified on given examples.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Prefix-Min and Suffix-Max Scan with Heaps (Provably Optimal)}
\WHICHFORMULA{Compute $l\_min$ via a size-$n$ max-heap on the prefix and $r\_max$ via a size-$n$ min-heap on the suffix; then sweep splits $s \in [n-1,2n-1]$ taking $\min \big(l\_min[s]-r\_max[s+1]\big)$.}
\ASSUMPTIONS{The independence of choices on disjoint ranges makes greedy-by-order selection optimal per side; heaps maintain the $n$ extremal elements in $O(\log n)$ time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Left pass: keep the $n$ smallest seen so far with a max-heap of negatives; record their sum as $l\_min[i]$ when available.
\item Right pass: keep the $n$ largest ahead with a min-heap; record their sum as $r\_max[i]$ when available.
\item Combine by scanning splits and taking the minimum difference.
\end{algosteps}
\OPTIMALITY{For any fixed split, the left choice minimizing sum is to take the $n$ smallest values in the prefix; similarly, the right choice maximizing sum is to take the $n$ largest in the suffix. The global optimum is the minimum over all feasible splits. This matches a lower bound from independently optimal side choices, hence is tight.}
\COMPLEXITY{Two passes plus a linear scan. Time $O(n \log n)$, space $O(n)$.}
\[
\begin{aligned}
T(n) &= O(n \log n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        N = len(nums)
        n = N // 3

        # Left: minimal sum of n from prefix
        lmin = [0] * N
        maxheap = []
        lsum = 0
        for i, x in enumerate(nums):
            heapq.heappush(maxheap, -x)
            lsum += x
            if len(maxheap) > n:
                lsum += heapq.heappop(maxheap)  # pop is negative; adds -largest
            if len(maxheap) == n:
                lmin[i] = lsum
            else:
                lmin[i] = None  # not enough items yet

        # Right: maximal sum of n from suffix
        rmax = [0] * N
        minheap = []
        rsum = 0
        for i in range(N - 1, -1, -1):
            x = nums[i]
            heapq.heappush(minheap, x)
            rsum += x
            if len(minheap) > n:
                rsum -= heapq.heappop(minheap)  # remove smallest
            if len(minheap) == n:
                rmax[i] = rsum
            else:
                rmax[i] = None

        ans = None
        for s in range(n - 1, 2 * n):
            diff = lmin[s] - rmax[s + 1]
            if ans is None or diff < ans:
                ans = diff
        return 0 if ans is None else ans

# Exactly 3 asserts
assert Solution().minimumDifference([3,1,2]) == -1
assert Solution().minimumDifference([7,9,5,8,1,3]) == 1
assert Solution().minimumDifference([1,2,3,4,5,6]) == -7
\end{minted}
\VALIDATION{Three asserts cover the provided examples and a monotone case.}
\RESULT{Returns the minimal achievable $\texttt{sumfirst}-\texttt{sumsecond}$ as an integer.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on given examples; random tiny cases cross-checked against brute force; monotone increasing/decreasing arrays; arrays with duplicates.}
\LINE{CROSS-CHECKS}{Compare Approach B/C results to Approach A on small $n$ to detect logic errors.}
\LINE{EDGE-CASE GENERATOR}{Generate random arrays of length $3n$ with small $n$ (e.g., $n\le 4$) and values in a small range; verify optimized result equals brute force.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random
import itertools
import heapq

def brute(nums: List[int]) -> int:
    n = len(nums)//3
    N = len(nums)
    best = None
    for rem in itertools.combinations(range(N), n):
        rem = set(rem)
        kept = [nums[i] for i in range(N) if i not in rem]
        v = sum(kept[:n]) - sum(kept[n:])
        if best is None or v < best:
            best = v
    return best

class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        N = len(nums)
        n = N // 3
        lmin = [None] * N
        maxheap = []
        lsum = 0
        for i, x in enumerate(nums):
            heapq.heappush(maxheap, -x)
            lsum += x
            if len(maxheap) > n:
                lsum += heapq.heappop(maxheap)
            if len(maxheap) == n:
                lmin[i] = lsum
        rmax = [None] * N
        minheap = []
        rsum = 0
        for i in range(N - 1, -1, -1):
            x = nums[i]
            heapq.heappush(minheap, x)
            rsum += x
            if len(minheap) > n:
                rsum -= heapq.heappop(minheap)
            if len(minheap) == n:
                rmax[i] = rsum
        ans = None
        for s in range(n - 1, 2 * n):
            diff = lmin[s] - rmax[s + 1]
            if ans is None or diff < ans:
                ans = diff
        return ans

def run_cross_checks():
    random.seed(0)
    for n in range(1, 5):
        N = 3 * n
        for _ in range(50):
            nums = [random.randint(1, 9) for _ in range(N)]
            assert Solution().minimumDifference(nums) == brute(nums)
    # boundary patterns
    assert Solution().minimumDifference([3,1,2]) == -1
    assert Solution().minimumDifference([7,9,5,8,1,3]) == 1
    assert Solution().minimumDifference([1,2,3,4,5,6]) == brute([1,2,3,4,5,6])

run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        N = len(nums)
        n = N // 3

        # Minimal left sums
        lmin = [None] * N
        maxheap = []
        lsum = 0
        for i, x in enumerate(nums):
            heapq.heappush(maxheap, -x)
            lsum += x
            if len(maxheap) > n:
                lsum += heapq.heappop(maxheap)  # subtract the largest
            if len(maxheap) == n:
                lmin[i] = lsum

        # Maximal right sums
        rmax = [None] * N
        minheap = []
        rsum = 0
        for i in range(N - 1, -1, -1):
            x = nums[i]
            heapq.heappush(minheap, x)
            rsum += x
            if len(minheap) > n:
                rsum -= heapq.heappop(minheap)  # remove smallest
            if len(minheap) == n:
                rmax[i] = rsum

        # Evaluate splits
        ans = None
        for s in range(n - 1, 2 * n):
            diff = lmin[s] - rmax[s + 1]
            if ans is None or diff < ans:
                ans = diff
        return 0 if ans is None else ans

# Submission-style quick checks
assert Solution().minimumDifference([3,1,2]) == -1
assert Solution().minimumDifference([7,9,5,8,1,3]) == 1
assert Solution().minimumDifference([1,2,3,4,5,6]) == -7
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute minimal left sums and maximal right sums across a valid split, then take the minimum difference.}
\WHY{This pattern appears frequently: constrained selections on disjoint ranges where per-side extremal choices are optimal; heaps yield efficient streaming maintenance.}
\CHECKLIST{
\begin{bullets}
\item Identify split range $s \in [n-1,2n-1]$.
\item Build $l\_min$ with a size-$n$ max-heap of negatives.
\item Build $r\_max$ with a size-$n$ min-heap.
\item Scan and minimize $l\_min[s]-r\_max[s+1]$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ (three elements).
\item All equal elements.
\item Strictly increasing or decreasing arrays.
\item Large values near $10^5$ to ensure no overflow in languages with fixed-size integers.
\item Duplicates and repeated extremes.
\item Arrays where the best split is at the boundary $s=n-1$ or $s=2n-1$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using the wrong extremum per side (left needs $n$ smallest; right needs $n$ largest).
\item Off-by-one when indexing $r\_max[s+1]$.
\item Forgetting to adjust running sums when popping from heaps.
\item Using the wrong heap type (mixing min-heap/max-heap conventions).
\item Not initializing entries when heap size $< n$.
\item Overflow in languages without big integers if sums are not widened.
\end{bullets}
}
\FAILMODES{Greedy that locally deletes large elements may fail because deletions affect both halves simultaneously; only per-side extremal selection tied to a split is valid. The heap-based method avoids this by decoupling sides via the split.}
\ELI{We split the array into two stretches and, for each split, choose the $n$ smallest numbers from the left stretch and the $n$ largest from the right stretch. Checking all valid splits and picking the best gives the smallest possible difference.}
\NotePages{3}

\end{document}