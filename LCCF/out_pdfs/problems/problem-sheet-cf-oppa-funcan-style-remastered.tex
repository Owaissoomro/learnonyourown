% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Oppa Funcan Style Remastered}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/986/F}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{Surely you have seen insane videos by South Korean rapper PSY, such as ``Gangnam Style'', ``Gentleman'' and ``Daddy''. You might also hear that PSY has been recording video ``Oppa Funcan Style'' two years ago (unfortunately we could not find it on the internet). We will remind you what this hit looked like (you can find original description here):

On the ground there are $n$ platforms, which are numbered with integers from $1$ to $n$, on $i$-th platform there is a dancer with number $i$. Further, every second all the dancers standing on the platform with number $i$ jump to the platform with the number $f(i)$. The moving rule $f$ is selected in advance and is not changed throughout the clip.

The duration of the clip was $k$ seconds and the rule $f$ was chosen in such a way that after $k$ seconds all dancers were in their initial positions (i.e. the $i$-th dancer stood on the platform with the number $i$). That allowed to loop the clip and collect even more likes.

PSY knows that enhanced versions of old artworks become more and more popular every day. So he decided to release a remastered-version of his video.

In his case ``enhanced version'' means even more insanity, so the number of platforms can be up to $10^{18}$! But the video director said that if some dancer stays on the same platform all the time, then the viewer will get bored and will turn off the video immediately. Therefore, for all $x$ from $1$ to $n$ $f(x) \ne x$ must hold.

Big part of classic video\textquotesingle s success was in that looping, so in the remastered version all dancers should return to their initial positions in the end of the clip as well.

PSY has not decided on the exact number of platforms and video duration yet, so he asks you to check if there is a good rule $f$ for different options.

Input:
In the first line of input there is one integer $t$ ($1 \le t \le 10^{4}$) — the number of options for $n$ and $k$ to check.

In the next $t$ lines the options are given: each option is described with two integers $n$ and $k$ ($1 \le n \le 10^{18}$, $1 \le k \le 10^{15}$) — the number of dancers and the duration in seconds.

It is guaranteed that the number of different values of $k$ in one test is not greater than $50$.

Output:
Print $t$ lines. If the $i$-th option of the video is feasible, print ``YES'' (without quotes) in $i$-th line, otherwise print ``NO'' (without quotes).}
\BREAKDOWN{A permutation $f$ has $f^k=\mathrm{id}$ iff all cycle lengths divide $k$. No fixed points means no $1$-cycles. So we must decide if $n$ can be written as a sum of divisors of $k$ that are at least $2$. Handle many queries grouped by identical $k$, with $n$ up to $10^{18}$.}
\ELI{You can split the $n$ dancers into loops whose sizes must divide $k$ and all be at least $2$; the question is whether such a split exists.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One integer $t$. Then $t$ lines, each with integers $n$ and $k$:
\begin{BreakableEquation*}
1 \le t \le 10^{4},\quad 1 \le n \le 10^{18},\quad 1 \le k \le 10^{15}.
\end{BreakableEquation*}
At most $50$ distinct values of $k$.}
\OUTPUTS{For each query, print YES if there exists a permutation on $\{1,\ldots,n\}$ with no fixed points whose $k$-th power is identity; otherwise NO.}
\SAMPLES{Examples:
\begin{bullets}
\item Input: 5; queries $(n,k)=(4,2),(3,2),(5,6),(1,30),(10,9)$. Output: YES, NO, YES, NO, YES.
\item Explanation: For $(4,2)$ use two $2$-cycles. For $(3,2)$ odd sum of $2$-cycles is impossible. For $(5,6)$ use a $3$-cycle and a $2$-cycle. For $(1,30)$ no cycle of length $\ge 2$ fits. For $(10,9)$ use five $2$-cycles since $2\mid 9$ is false; instead use $3$-cycles: three $3$-cycles plus one $...$ actually $(10,9)$ is YES because $9=3^2$ and $10$ is not divisible by $3$? No; correct sample: $(9,9)$ is YES, $(10,9)$ is NO.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $D(k)=\{d\in\mathbb{N}: d\mid k,\ d\ge 2\}$. The question is whether there exist nonnegative integers $c_d$ for $d\in D(k)$ such that $\sum_{d\in D(k)} c_d\,d = n$.}
\varmapStart
\var{n}{number of dancers}
\var{k}{clip duration; target exponent with $f^k=\mathrm{id}$}
\var{D(k)}{allowed cycle sizes (divisors of $k$ at least $2$)}
\var{c_d}{count of cycles of length $d$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Find }(c_d)_{d\in D(k)}\text{ with }c_d\in\mathbb{Z}_{\ge 0},\quad \sum_{d\in D(k)} c_d\,d = n.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Permutation cycles are disjoint and cover all $n$ elements; $f^k=\mathrm{id}$ iff each cycle length divides $k$. No fixed points means no $1$-cycles.}
\INVARIANTS{
\begin{bullets}
\item Cycle lengths are integers $\ge 2$ dividing $k$.
\item Sum of cycle lengths equals $n$.
\item Adding a $p$-cycle (where $p$ is a prime dividing $k$) preserves residue modulo $p$ classes of achievable sums.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly test representability of $n$ as a sum of divisors of $k$ (all $\ge 2$).}
\ASSUMPTIONS{For tiny $k$ we could enumerate all divisors and do unbounded subset-sum DP up to some bound; but $n$ is huge, so we only use this idea to derive simpler necessary/sufficient tests by cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k=1$, answer NO (only identity permutation exists, but fixed points are forbidden).
\item Factorize $k$; let its distinct prime factors be $p_1<\cdots<p_m$.
\item If $m=1$ (prime power), answer YES iff $n \equiv 0 \pmod{p_1}$ (pack only $p_1$-cycles).
\item If $m=2$ (two distinct primes $p<q$), answer YES iff $n$ is a nonnegative combination $a p + b q$; compute by modular inverse: let $b \equiv (n \bmod p)\cdot q^{-1}\ (\bmod p)$; check $b q \le n$.
\end{algosteps}
\COMPLEXITY{Dominated by factorization of $k$; we use Miller–Rabin + Pollard–Rho, typically sublinear in $k$. Per query is $O(1)$.}
\[
\begin{aligned}
T(k) &\approx \text{polylog}(k) \text{ for factorization, once per distinct }k,\\
T(\text{per query}) &= O(1),\quad S = O(1).
\end{aligned}
\]
\CORRECTNESS{Cycle decomposition implies each cycle size divides $k$ and no size $1$. For one prime factor, only multiples of that prime are sums. For two distinct primes, any divisor is a multiple of $p$ or $q$, so the semigroup equals $\{ap+bq\}$; the modular inverse test is exact.}
\EDGECASES{Handle $k=1$ as NO; $n=1$ is always NO; parity when $p=2$, odd $n$ impossible with only $2$-cycles.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math, random

# --- number theory utils (64-bit safe for our constraints) ---
def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    small_primes = [2,3,5,7,11,13]
    for p in small_primes:
        if n % p == 0:
            return n == p
    # write n-1 = d * 2^s
    d = n - 1
    s = (d & -d).bit_length() - 1  # count trailing zeros
    d >>= s
    def trial(a: int) -> bool:
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            return True
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                return True
        return False
    for a in small_primes:
        if a % n == 0:
            return True
        if not trial(a):
            return False
    return True

def pollard_rho(n: int) -> int:
    if n % 2 == 0:
        return 2
    while True:
        c = random.randrange(1, n-1)
        f = lambda x: (pow(x, 2, n) + c) % n
        x = random.randrange(2, n-1)
        y = x
        d = 1
        while d == 1:
            x = f(x)
            y = f(f(y))
            d = math.gcd(abs(x - y), n)
        if d != n:
            return d

def factorize(n: int, res: dict):
    if n == 1:
        return
    if is_probable_prime(n):
        res[n] = res.get(n, 0) + 1
    else:
        d = pollard_rho(n)
        factorize(d, res)
        factorize(n // d, res)

def modinv(a: int, m: int) -> int:
    # Extended GCD (works for coprime a, m)
    def egcd(a, b):
        if b == 0:
            return (1, 0, a)
        x, y, g = egcd(b, a % b)
        return (y, x - (a // b) * y, g)
    x, y, g = egcd(a % m, m)
    if g != 1:
        raise ValueError("inverse does not exist")
    return x % m

# --- core per-k precompute (baseline only handles m<=2 fully) ---
def precompute_for_k_baseline(k: int):
    if k == 1:
        return ("none", None)
    fac = {}
    factorize(k, fac)
    primes = sorted(fac.keys())
    m = len(primes)
    if m == 1:
        p = primes[0]
        return ("one", p)
    if m == 2:
        p, q = primes[0], primes[1]
        return ("two", (p, q))
    # Fallback: treat as "two" using smallest two primes (sufficient for correctness of answer),
    # but this baseline will be conservative and may say NO when YES for some rare small n.
    p, q = primes[0], primes[1]
    return ("two", (p, q))

def answer_query_baseline(n: int, kinfo):
    kind, data = kinfo
    if kind == "none":
        return False
    if kind == "one":
        p = data
        return n % p == 0
    if kind == "two":
        p, q = data
        # ensure p < q
        if p > q:
            p, q = q, p
        # solve n = a*p + b*q with a,b >= 0
        b = (n % p) * modinv(q % p, p) % p
        return b * q <= n
    return False

# ---- CF I/O ----
def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    queries = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        queries.append((n, k))
    return t, queries

def solve_all(queries):
    # group by k
    byk = {}
    for idx, (n, k) in enumerate(queries):
        byk.setdefault(k, []).append((idx, n))
    ans = [None] * len(queries)
    cache = {}
    for k, items in byk.items():
        cache[k] = precompute_for_k_baseline(k)
        for idx, n in items:
            ans[idx] = "YES" if answer_query_baseline(n, cache[k]) else "NO"
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # simple tests
        t, queries = 5, [(4,2),(3,2),(5,6),(1,30),(9,9)]
        out = solve_all(queries)
        assert out == ["YES","NO","YES","NO","YES"]
        print("\n".join(out))
        return
    t, queries = read_input(data)
    out = solve_all(queries)
    print("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Sanity checks: $(n,k)=(4,2)\to$ YES; $(3,2)\to$ NO; $(5,6)\to$ YES; $(1,30)\to$ NO; $(9,9)\to$ YES.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Case Analysis}
\WHICHFORMULA{Use exact necessary and sufficient conditions by number of distinct prime factors of $k$: 0, 1, or 2.}
\ASSUMPTIONS{For $k=1$ NO. For $k=p^a$ YES iff $p\mid n$. For $k=p^a q^b$ YES iff $n$ is a nonnegative combination of $p$ and $q$, checked by a modular inverse.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Factorize $k$ once per distinct value.
\item If $k=1$, return NO.
\item If exactly one prime factor $p$, return $n \bmod p = 0$.
\item If exactly two distinct primes $p<q$, compute $b \equiv (n \bmod p) \cdot q^{-1} \pmod p$ and accept iff $bq \le n$.
\end{algosteps}
\COMPLEXITY{Per distinct $k$: near-linear in number of bits for factorization; per query: $O(1)$.}
\[
\begin{aligned}
T_{\text{per }k} &\approx \tilde O(1)\ \text{(Pollard–Rho)},\quad
T_{\text{per query}} = O(1).
\end{aligned}
\]
\CORRECTNESS{Divisors of $k$ are either multiples of $p$ or of $q$ in the two-prime case; using higher powers does not create new residues modulo $p$ nor smaller costs than $q$ itself.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math, random

def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    small_primes = [2,3,5,7,11,13]
    for p in small_primes:
        if n % p == 0:
            return n == p
    d = n - 1
    s = (d & -d).bit_length() - 1
    d >>= s
    def trial(a):
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            return True
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                return True
        return False
    for a in small_primes:
        if a % n == 0:
            return True
        if not trial(a):
            return False
    return True

def pollard_rho(n: int) -> int:
    if n % 2 == 0:
        return 2
    while True:
        c = random.randrange(1, n-1)
        f = lambda x: (pow(x, 2, n) + c) % n
        x = random.randrange(2, n-1)
        y = x
        d = 1
        while d == 1:
            x = f(x); y = f(f(y))
            d = math.gcd(abs(x - y), n)
        if d != n:
            return d

def factorize(n: int, res: dict):
    if n == 1:
        return
    if is_probable_prime(n):
        res[n] = res.get(n, 0) + 1
    else:
        d = pollard_rho(n)
        factorize(d, res)
        factorize(n // d, res)

def egcd(a, b):
    if b == 0:
        return (1, 0, a)
    x, y, g = egcd(b, a % b)
    return (y, x - (a // b) * y, g)

def modinv(a: int, m: int) -> int:
    x, y, g = egcd(a % m, m)
    if g != 1:
        raise ValueError("no inverse")
    return x % m

def precompute_k(k: int):
    if k == 1:
        return ("none", None)
    fac = {}
    factorize(k, fac)
    primes = sorted(fac.keys())
    if len(primes) == 1:
        return ("one", primes[0])
    if len(primes) == 2:
        p, q = primes[0], primes[1]
        return ("two", (p, q))
    return ("two", tuple(sorted(primes)[:2]))

def answer_query(n: int, info):
    kind, data = info
    if kind == "none":
        return False
    if kind == "one":
        p = data
        return n % p == 0
    if kind == "two":
        p, q = data
        if p > q:
            p, q = q, p
        b = (n % p) * modinv(q % p, p) % p
        return b * q <= n
    return False

def read_input(s: str):
    it = iter(s.strip().split())
    t = int(next(it))
    qs = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        qs.append((n, k))
    return t, qs

def solve_all(qs):
    byk = {}
    for i, (n, k) in enumerate(qs):
        byk.setdefault(k, []).append((i, n))
    res = [None] * len(qs)
    cache = {}
    for k, items in byk.items():
        cache[k] = precompute_k(k)
        for i, n in items:
            res[i] = "YES" if answer_query(n, cache[k]) else "NO"
    return res

def main():
    data = sys.stdin.read()
    if not data.strip():
        assert solve_all([(4,2),(3,2),(5,6),(1,30),(9,9)]) == ["YES","NO","YES","NO","YES"]
        assert solve_all([(5,6),(7,6),(1,6)]) == ["YES","YES","NO"]
        print("OK")
        return
    t, qs = read_input(data)
    out = solve_all(qs)
    print("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked two-prime cases like $(n,k)=(7,6)$ and one-prime cases $(n,k)=(8,8)$; also $k=1$ always NO.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Residue Shortest Paths with Full Divisors}
\WHICHFORMULA{For $\ge 3$ distinct primes in $k$, let $p$ be the smallest prime factor. Consider all divisors $d$ of $k$ with $d\ge 2$ and $p\nmid d$. Build a graph on residues $\bmod p$ with edges of weights $d$ adding $d \bmod p$. The shortest distance to residue $r$ equals the minimal representable sum $\equiv r \pmod p$. Then $n$ is feasible iff $\mathrm{dist}[n \bmod p] \le n$.}
\ASSUMPTIONS{Multiples of $p$ (i.e., $p$-cycles) can be added freely to lift any achievable residue by multiples of $p$ without changing residue. It suffices to keep only the minimal-weight divisor per residue increment in the graph.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k=1$, answer NO. Factorize $k$ (Pollard–Rho + Miller–Rabin).
\item If $k$ has $1$ prime factor $p$: answer $n \bmod p = 0$.
\item If $k$ has $2$ distinct primes $p<q$: answer via $n=ap+bq$ check using modular inverse.
\item Else ($\ge 3$ primes): let $p$ be the smallest prime factor. Enumerate all divisors of $k$; for each $d\ge 2$ with $d \bmod p \ne 0$, keep $W[d \bmod p] = \min(W[d \bmod p], d)$.
\item Run Dijkstra on $p$ residues with edges $(u \to u+r \bmod p)$ of cost $W[r]$ for all $r$ with finite $W[r]$; obtain $\mathrm{dist}$.
\item For each query $(n,k)$, answer YES iff $\mathrm{dist}[n \bmod p] \le n$.
\end{algosteps}
\OPTIMALITY{Exact characterization from cycle decomposition. For $\ge 3$ primes, the residue-graph shortest paths give exact minimal achievable sums per residue; comparing to $n$ is necessary and sufficient.}
\COMPLEXITY{Per distinct $k$: factorization is fast in practice; enumerating divisors is $O(\tau(k))$ with $\tau(k)\le 10^4$ for $k\le 10^{15}$. Dijkstra on $p$ nodes and at most $p$ edges costs $O(p \log p)$. Since $p$ is the smallest prime factor and there are $\ge 3$ primes, $p \le \sqrt[3]{k}$, so $p \lesssim 10^{5}$. Per query is $O(1)$.}
\[
\begin{aligned}
T_{\text{per }k} &\approx \tilde O(1) + O(\tau(k) + p \log p),\quad
T_{\text{per query}} = O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, math, random, heapq

# ---------- Miller-Rabin (deterministic for n < 2^64) ----------
def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    small_primes = [2,3,5,7,11,13]
    for p in small_primes:
        if n % p == 0:
            return n == p
    # write n-1 = d * 2^s
    d = n - 1
    s = (d & -d).bit_length() - 1
    d >>= s
    def trial(a: int) -> bool:
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            return True
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                return True
        return False
    for a in small_primes:
        if a % n == 0:
            return True
        if not trial(a):
            return False
    return True

# ---------- Pollard-Rho ----------
def pollard_rho(n: int) -> int:
    if n % 2 == 0:
        return 2
    if n % 3 == 0:
        return 3
    while True:
        c = random.randrange(1, n - 1)
        f = lambda x: (pow(x, 2, n) + c) % n
        x = random.randrange(2, n - 1)
        y = x
        d = 1
        while d == 1:
            x = f(x)
            y = f(f(y))
            d = math.gcd(abs(x - y), n)
        if d != n:
            return d

def factorize(n: int, res: dict):
    if n == 1:
        return
    if is_probable_prime(n):
        res[n] = res.get(n, 0) + 1
    else:
        d = pollard_rho(n)
        factorize(d, res)
        factorize(n // d, res)

def divisors_from_factors(fac: dict) -> list:
    items = list(fac.items())
    divs = [1]
    for p, e in items:
        cur = []
        pe = 1
        for _ in range(e):
            pe *= p
            for v in divs:
                cur.append(v * pe)
        divs += cur
    return divs

def egcd(a, b):
    if b == 0:
        return (1, 0, a)
    x, y, g = egcd(b, a % b)
    return (y, x - (a // b) * y, g)

def modinv(a: int, m: int) -> int:
    x, y, g = egcd(a % m, m)
    if g != 1:
        raise ValueError("no inverse")
    return x % m

# ---------- Precompute per unique k ----------
def precompute_k(k: int):
    # returns a dict with kind and data for answering queries quickly
    info = {"kind": None}
    if k == 1:
        info["kind"] = "none"
        return info
    fac = {}
    factorize(k, fac)
    primes = sorted(fac.keys())
    m = len(primes)
    if m == 1:
        info["kind"] = "one"
        info["p"] = primes[0]
        return info
    if m == 2:
        info["kind"] = "two"
        info["p"], info["q"] = primes[0], primes[1]
        return info
    # m >= 3: Dijkstra on residues modulo smallest prime p
    p = primes[0]
    info["kind"] = "many"
    info["p"] = p
    divs = divisors_from_factors(fac)
    INF = 10**30
    best = [INF] * p  # minimal coin to add residue r (r != 0)
    for d in divs:
        if d >= 2 and d % p != 0:
            r = d % p
            if d < best[r]:
                best[r] = d
    # Build Dijkstra
    dist = [INF] * p
    dist[0] = 0
    pq = [(0, 0)]
    while pq:
        du, u = heapq.heappop(pq)
        if du != dist[u]:
            continue
        for r in range(1, p):
            w = best[r]
            if w >= INF:
                continue
            v = (u + r) % p
            nd = du + w
            if nd < dist[v]:
                dist[v] = nd
                heapq.heappush(pq, (nd, v))
    info["dist"] = dist
    return info

def answer_query(n: int, info: dict) -> bool:
    kind = info["kind"]
    if kind == "none":
        return False
    if kind == "one":
        p = info["p"]
        return n % p == 0
    if kind == "two":
        p, q = info["p"], info["q"]
        if p > q:
            p, q = q, p
        b = (n % p) * modinv(q % p, p) % p
        return b * q <= n
    # many primes
    p = info["p"]
    dist = info["dist"]
    return dist[n % p] <= n

# ---------- CF Plumbing ----------
def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    queries = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        queries.append((n, k))
    return t, queries

def solve_all(queries):
    byk = {}
    for idx, (n, k) in enumerate(queries):
        byk.setdefault(k, []).append((idx, n))
    answers = [None] * len(queries)
    cache = {}
    for k, items in byk.items():
        info = precompute_k(k)
        cache[k] = info
        for idx, n in items:
            answers[idx] = "YES" if answer_query(n, info) else "NO"
    return answers

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Unit asserts (not run on CF)
        assert solve_all([(4,2),(3,2),(5,6),(1,30),(9,9)]) == ["YES","NO","YES","NO","YES"]
        assert solve_all([(5,6),(7,6),(1,6),(2,1)]) == ["YES","YES","NO","NO"]
        assert solve_all([(10,9),(12,9),(3,9)]) == ["NO","YES","YES"]
        print("OK")
        return
    t, queries = read_input(data)
    out = solve_all(queries)
    print("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts included in main(): small mixes covering $k=1$, one-prime, two-prime, and many-prime cases.}
\RESULT{Answer YES iff $n$ can be partitioned into cycle lengths all dividing $k$ and at least $2$; otherwise NO.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for edge cases: $k=1$; single-prime powers with parity constraints; two-prime linear combinations; multi-prime residue shortest-path. Random spot checks on small $k$ comparing to brute-force DP up to small $n$.}
\LINE{CROSS-CHECKS}{Compare Approach B vs C on crafted cases like $k=6,10,30$ with various $n$. Ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate small $k$ by multiplying small primes; for each, enumerate divisors and do BFS/DP up to $n \le 200$ to validate against the optimal solver.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import itertools, math, random

def brute_possible(n, k):
    if k == 1:
        return False
    # compute divisors >= 2
    ds = []
    for d in range(2, k+1):
        if k % d == 0:
            ds.append(d)
    # simple DP up to n
    can = [False] * (n+1)
    can[0] = True
    for s in range(1, n+1):
        ok = False
        for d in ds:
            if d <= s and can[s-d]:
                ok = True
                break
        can[s] = ok
    return can[n]

def quick_test_random():
    from math import prod
    primes = [2,3,5,7,11]
    # small ks as product of up to 3 primes
    ks = set()
    for r in range(1, 4):
        for comb in itertools.combinations(primes, r):
            ks.add(prod(comb))
    # test small n
    import sys
    K = sorted(list(ks))
    # reuse optimal solver from Approach C (inline minimal)
    def check_opt(n, k):
        # minimal inline version
        import math, heapq, random
        def isp(n):
            if n < 2: return False
            for p in [2,3,5,7,11,13]:
                if n % p == 0:
                    return n == p
            d = n-1; s = (d & -d).bit_length()-1; d >>= s
            for a in [2,3,5,7,11,13]:
                if a % n == 0: continue
                x = pow(a, d, n)
                if x == 1 or x == n-1: 
                    continue
                ok = False
                for _ in range(s-1):
                    x = (x*x) % n
                    if x == n-1: ok = True; break
                if not ok: return False
            return True
        def rho(n):
            if n % 2 == 0: return 2
            if n % 3 == 0: return 3
            while True:
                c = random.randrange(1, n-1)
                f = lambda x: (pow(x,2,n)+c) % n
                x = random.randrange(2, n-1); y = x; d = 1
                while d == 1:
                    x = f(x); y = f(f(y)); d = math.gcd(abs(x-y), n)
                if d != n: return d
        def fac(n, res):
            if n == 1: return
            if isp(n): res[n] = res.get(n, 0)+1
            else:
                d = rho(n); fac(d, res); fac(n//d, res)
        if k == 1: return False
        facs = {}; fac(k, facs)
        prs = sorted(facs.keys())
        if len(prs) == 1:
            return n % prs[0] == 0
        if len(prs) == 2:
            p, q = prs[0], prs[1]
            def eg(a,b):
                if b==0: return (1,0,a)
                x,y,g = eg(b, a%b)
                return (y, x-(a//b)*y, g)
            def inv(a,m):
                x,y,g = eg(a%m, m)
                if g!=1: return None
                return x%m
            b = (n % p) * inv(q % p, p) % p
            return b * q <= n
        p = prs[0]
        # divisors
        divs = [1]
        for pr, e in facs.items():
            cur = []
            pe = 1
            for _ in range(e):
                pe *= pr
                for v in divs:
                    cur.append(v*pe)
            divs += cur
        INF = 10**15
        best = [INF]*p
        for d in divs:
            if d >= 2 and d % p != 0:
                r = d % p
                if d < best[r]: best[r] = d
        dist = [INF]*p
        dist[0]=0
        pq=[(0,0)]
        while pq:
            du,u = heapq.heappop(pq)
            if du!=dist[u]: continue
            for r in range(1,p):
                w = best[r]
                if w>=INF: continue
                v=(u+r)%p
                nd=du+w
                if nd<dist[v]:
                    dist[v]=nd
                    heapq.heappush(pq,(nd,v))
        return dist[n%p] <= n
    for k in K:
        for n in range(1, 201):
            assert brute_possible(n, k) == check_opt(n, k)
    print("edge-generator tests OK")

if __name__ == "__main__":
    quick_test_random()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final, single reference solution (same as Approach C) with asserts in __main__
import sys, math, random, heapq

def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    small_primes = [2,3,5,7,11,13]
    for p in small_primes:
        if n % p == 0:
            return n == p
    d = n - 1
    s = (d & -d).bit_length() - 1
    d >>= s
    def trial(a: int) -> bool:
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            return True
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                return True
        return False
    for a in small_primes:
        if a % n == 0:
            return True
        if not trial(a):
            return False
    return True

def pollard_rho(n: int) -> int:
    if n % 2 == 0:
        return 2
    if n % 3 == 0:
        return 3
    while True:
        c = random.randrange(1, n - 1)
        f = lambda x: (pow(x, 2, n) + c) % n
        x = random.randrange(2, n - 1)
        y = x
        d = 1
        while d == 1:
            x = f(x); y = f(f(y))
            d = math.gcd(abs(x - y), n)
        if d != n:
            return d

def factorize(n: int, res: dict):
    if n == 1:
        return
    if is_probable_prime(n):
        res[n] = res.get(n, 0) + 1
    else:
        d = pollard_rho(n)
        factorize(d, res)
        factorize(n // d, res)

def divisors_from_factors(fac: dict) -> list:
    divs = [1]
    for p, e in fac.items():
        cur = []
        pe = 1
        for _ in range(e):
            pe *= p
            for v in divs:
                cur.append(v * pe)
        divs += cur
    return divs

def egcd(a, b):
    if b == 0:
        return (1, 0, a)
    x, y, g = egcd(b, a % b)
    return (y, x - (a // b) * y, g)

def modinv(a: int, m: int) -> int:
    x, y, g = egcd(a % m, m)
    if g != 1:
        raise ValueError("no inverse")
    return x % m

def precompute_k(k: int):
    info = {"kind": None}
    if k == 1:
        info["kind"] = "none"
        return info
    fac = {}
    factorize(k, fac)
    primes = sorted(fac.keys())
    m = len(primes)
    if m == 1:
        info["kind"] = "one"; info["p"] = primes[0]
        return info
    if m == 2:
        info["kind"] = "two"; info["p"], info["q"] = primes[0], primes[1]
        return info
    p = primes[0]
    info["kind"] = "many"; info["p"] = p
    divs = divisors_from_factors(fac)
    INF = 10**30
    best = [INF] * p
    for d in divs:
        if d >= 2 and d % p != 0:
            r = d % p
            if d < best[r]:
                best[r] = d
    dist = [INF] * p
    dist[0] = 0
    pq = [(0, 0)]
    while pq:
        du, u = heapq.heappop(pq)
        if du != dist[u]:
            continue
        for r in range(1, p):
            w = best[r]
            if w >= INF:
                continue
            v = (u + r) % p
            nd = du + w
            if nd < dist[v]:
                dist[v] = nd
                heapq.heappush(pq, (nd, v))
    info["dist"] = dist
    return info

def answer_query(n: int, info: dict) -> str:
    kind = info["kind"]
    if kind == "none":
        return "NO"
    if kind == "one":
        return "YES" if n % info["p"] == 0 else "NO"
    if kind == "two":
        p, q = info["p"], info["q"]
        if p > q:
            p, q = q, p
        b = (n % p) * modinv(q % p, p) % p
        return "YES" if b * q <= n else "NO"
    p = info["p"]
    dist = info["dist"]
    return "YES" if dist[n % p] <= n else "NO"

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    queries = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        queries.append((n, k))
    return t, queries

def solve_all(queries):
    byk = {}
    for idx, (n, k) in enumerate(queries):
        byk.setdefault(k, []).append((idx, n))
    out = [None] * len(queries)
    cache = {}
    for k, items in byk.items():
        info = precompute_k(k)
        cache[k] = info
        for idx, n in items:
            out[idx] = answer_query(n, info)
    return out

def main():
    data = sys.stdin.read()
    if not data.strip():
        assert solve_all([(4,2),(3,2),(5,6),(1,30),(9,9)]) == ["YES","NO","YES","NO","YES"]
        assert solve_all([(7,6),(10,6),(1,6)]) == ["YES","YES","NO"]
        assert solve_all([(1,1),(2,1),(100,1)]) == ["NO","NO","NO"]
        print("OK")
        return
    t, queries = read_input(data)
    out = solve_all(queries)
    print("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Decide if $n$ is a sum of divisors of $k$ each at least $2$.}
\WHY{Classical decomposition of permutations into cycles; testing representability under large bounds needs number theory and a residue shortest-path trick.}
\CHECKLIST{
\begin{bullets}
\item Handle $k=1$ as NO.
\item Factorize $k$ once per distinct value.
\item One prime: check $n \bmod p = 0$.
\item Two primes: solve $n=ap+bq$ via modular inverse.
\item Three or more: residue Dijkstra modulo smallest prime factor with minimal divisor per residue.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ always NO.
\item $k=1$ always NO.
\item $k=2^a$: odd $n$ impossible.
\item $k=p^a$: only multiples of $p$ are possible.
\item Two-prime $k$: small $n<\min(p,q)$ often NO unless $n$ equals one of them.
\item Many-prime $k$: tiny $n$ may still be NO if below the minimal non-multiple-of-$p$ divisor.
\item Very large $n$: residue check suffices; do not DP up to $n$.
\item Ensure divisors $=1$ are excluded.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting that $1$-cycles are forbidden.
\item Using only prime powers as coins in the multi-prime case can give false negatives; must consider all divisors or at least minimal per residue.
\item Incorrect Miller–Rabin bases for 64-bit; use safe small base set for $<10^{15}$.
\item Missing $k=1$ special case.
\item Overflow in languages without big ints; Python is safe.
\item Using modulo inverse when $\gcd(q,p)\ne 1$ (should only be applied for distinct primes).
\item Dijkstra edges should skip divisors divisible by $p$ (they do not change residues).
\item Not grouping queries by $k$ causing repeated expensive factorizations.
\end{bullets}}
\FAILMODES{A naive DP up to $n$ is infeasible for $n$ up to $10^{18}$. A greedy approach on coin denominations fails for two-prime cases. Restricting denominations in the multi-prime case can reject feasible answers. The presented method survives by exact shortest paths per residue class.}
\ELI{We split dancers into loops whose lengths must divide $k$ and be at least $2$. With a couple of primes in $k$, quick math decides; with several primes, compute the cheapest way to hit each remainder modulo the smallest prime and then just see if $n$ is large enough.}
\NotePages{3}

\end{document}