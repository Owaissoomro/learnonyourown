% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Another Sith Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/678/E}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{The rules of Sith Tournament are well known to everyone. $n$ Sith take part in the Tournament. The Tournament starts with the random choice of two Sith who will fight in the first battle. As one of them loses, his place is taken by the next randomly chosen Sith who did not fight before. Does it need to be said that each battle in the Sith Tournament ends with a death of one of opponents? The Tournament ends when the only Sith remains alive.

Jedi Ivan accidentally appeared in the list of the participants in the Sith Tournament. However, his skills in the Light Side of the Force are so strong so he can influence the choice of participants either who start the Tournament or who take the loser's place after each battle. Of course, he will not miss his chance to take advantage of it. Help him to calculate the probability of his victory.

Input:

The first line contains a single integer $n$ ($1 \le n \le 18$) — the number of participants of the Sith Tournament.

Each of the next $n$ lines contains $n$ real numbers, which form a matrix $p_{ij}$ ($0 \le p_{ij} \le 1$). Each its element $p_{ij}$ is the probability that the $i$-th participant defeats the $j$-th in a duel.

The elements on the main diagonal $p_{ii}$ are equal to zero. For all different $i,j$ the equality $p_{ij} + p_{ji} = 1$ holds. All probabilities are given with no more than six decimal places.

Jedi Ivan is the number $1$ in the list of the participants.

Output:

Output a real number — the probability that Jedi Ivan will stay alive after the Tournament. Absolute or relative error of the answer must not exceed $10^{-6}$.}
\BREAKDOWN{Ivan controls the order in which new participants enter the arena: he chooses the initial pair and, after each fight, which not-yet-seen participant joins next. Only the current champion remains from previous fights. Model this as a controlled Markov process and compute the maximum probability that participant $1$ is the final survivor.}
\ELI{Think of a king-of-the-hill fight where Ivan always picks the next challenger to best help player $1$ survive. Use dynamic programming over subsets plus the current champion.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item Integer $n$ ($1 \le n \le 18$).
\item Matrix $p \in [0,1]^{n \times n}$ with $p_{ii}=0$ and $p_{ij}+p_{ji}=1$ for all $i \ne j$.
\end{bullets}}
\OUTPUTS{One real number: the maximum probability that participant $1$ (1-indexed; index $0$ in 0-based code) is the final survivor if Ivan controls the initial pair and every subsequent entrant.}
\SAMPLES{
Example 1:
\begin{verbatim}
Input
1
0.0
Output
1.0
\end{verbatim}
Example 2:
\begin{verbatim}
Input
2
0 0.7
0.3 0
Output
0.7
\end{verbatim}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $U=\{1,\ldots,n\}$ be participants and $p_{ij}$ the probability $i$ defeats $j$. At any time, exactly one current champion $c$ is alive among those who have already appeared. After each fight, Ivan chooses a new not-yet-appeared entrant $j$, who fights the current champion $c$. The winner becomes the new champion; the loser dies; the set of appeared participants grows by one.}
\varmapStart
\var{U}{participant indices}
\var{p_{ij}}{win probability of $i$ over $j$}
\var{S \subseteq U}{set of participants who have already appeared at least once}
\var{c \in S}{current champion alive among $S$}
\var{f(S,c)}{max probability that player $1$ is final champion from state $(S,c)$}
\varmapEnd
\GOVERN{
\[
f(S,c)=
\begin{cases}
1, & \text{if } S=U \text{ and } c=1,\\
0, & \text{if } S=U \text{ and } c\ne 1,\\
\displaystyle \max_{j\in U\setminus S}\bigl( p_{c j}\,f(S\cup\{j\},c) + p_{j c}\,f(S\cup\{j\},j) \bigr), & \text{otherwise.}
\end{cases}
\]
Initial choice (no champion yet): pick distinct $i,j\in U$ to maximize
\begin{BreakableEquation*}
\Phi(i,j)=p_{ij}\,f(\{i,j\},i)+p_{ji}\,f(\{i,j\},j).
\end{BreakableEquation*}
The answer is $\max_{i\ne j}\Phi(i,j)$, with the special case $n=1$ giving $1$.
}
\ASSUMPTIONS{Ivan has perfect control and can adaptively choose the next entrant based on previous outcomes; fights are independent with given pairwise probabilities; each participant can first appear at most once.}
\INVARIANTS{
\begin{bullets}
\item At any nonterminal state, exactly one champion $c$ is alive and $|S|\ge 2$.
\item Transitions only add one new entrant: $S' = S \cup \{j\}$ with $j\notin S$.
\item For any $i\ne j$, $p_{ij}+p_{ji}=1$ implies well-defined two-outcome transitions.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all permutations (orders) in which participants appear. For a fixed order, compute the probability that player $1$ survives the king-of-the-hill chain. Take the maximum over all orders.}
\ASSUMPTIONS{This ignores adaptivity beyond a fixed order; it is correct for $n=2$ and $n=3$ because after the first fight only one new entrant remains. For larger $n$, it becomes intractable and suboptimal if adaptivity can help.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each permutation $\pi$ of $U$, simulate the chain of fights in that order, computing the probability that the final champion is $1$.
\item Keep the maximum probability over all permutations.
\item Return the maximum as the baseline estimate.
\end{algosteps}
\COMPLEXITY{Factorial time; infeasible beyond tiny $n$.}
\[
\begin{aligned}
T(n) &= \Theta(n!) \text{ permutations} \times \Theta(n) \text{ chain eval} \\
     &= \Theta(n\cdot n!) \\
S(n) &= \Theta(n) \text{ for recursion and permutation generation.}
\end{aligned}
\]
\CORRECTNESS{For a fixed order, the chain probability is computed exactly. Taking the max over all orders matches the optimal adaptive strategy when $n\le 3$.}
\EDGECASES{$n=1$ returns $1$; $n=2$ returns $p_{12}$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from itertools import permutations

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    p = [[0.0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            p[i][j] = float(next(it))
    return n, p

def chain_survival_prob(order, p, target=0):
    # order: list of players (0-based) in the order they first appear
    # simulate king-of-the-hill with probabilistic outcomes
    # dp_c is a vector of probabilities for current champion being player x after processing prefix
    a, b = order[0], order[1]
    # After first fight: champion is a with prob p[a][b], else b
    dp = {a: p[a][b], b: p[b][a]}
    # For each next entrant, fight current champion; update distribution
    for k in order[2:]:
        new_dp = {}
        for c, pc in dp.items():
            # c vs k
            win_c = pc * p[c][k]
            win_k = pc * p[k][c]
            new_dp[c] = new_dp.get(c, 0.0) + win_c
            new_dp[k] = new_dp.get(k, 0.0) + win_k
        dp = new_dp
    return dp.get(target, 0.0)

def solve_case_baseline(n, p):
    if n == 1:
        return 1.0
    best = 0.0
    # Try all permutations for very small n (<=8 is already 40320; keep tiny)
    if n <= 8:
        for perm in permutations(range(n)):
            best = max(best, chain_survival_prob(list(perm), p, 0))
        return best
    # Fallback to optimal DP when n is large (baseline cannot handle)
    return solve_case_optimal(n, p)

def solve_case_optimal(n, p):
    # Optimal DP used as fallback here to keep baseline runnable on any input
    if n == 1:
        return 1.0
    N = 1 << n
    # f[mask][c]: probability that player 0 ultimately wins from state (mask, c), mask has appeared players
    # We'll store as a 2D list of floats
    f = [[0.0]*n for _ in range(N)]
    # precompute popcounts
    pc = [0]*N
    for m in range(1, N):
        pc[m] = pc[m >> 1] + (m & 1)
    full = N - 1
    # Base: full mask: champion 0 wins iff c == 0
    for c in range(n):
        f[full][c] = 1.0 if c == 0 else 0.0
    # Iterate masks in decreasing size from n-1 down to 2
    for k in range(n - 1, 1, -1):
        # iterate over all masks with pc == k
        m = full
        while m:
            if pc[m] == k:
                notm = (~m) & full
                # list of outsiders for quick iterate
                j = notm
                while j:
                    j_lowbit = j & -j
                    j_idx = (j_lowbit.bit_length() - 1)
                    j ^= j_lowbit
                    pass
                # For each champion c in m, compute f[m][c]
                # We will compute over all j not in m and take max
                c_bits = m
                while c_bits:
                    cb = c_bits & -c_bits
                    c_idx = (cb.bit_length() - 1)
                    c_bits ^= cb
                    best = 0.0
                    outsiders = notm
                    while outsiders:
                        ob = outsiders & -outsiders
                        j_idx = (ob.bit_length() - 1)
                        outsiders ^= ob
                        mm = m | (1 << j_idx)
                        val = p[c_idx][j_idx] * f[mm][c_idx] + p[j_idx][c_idx] * f[mm][j_idx]
                        if val > best:
                            best = val
                    f[m][c_idx] = best
            m = (m - 1) & full
    # Initial pair choice
    ans = 0.0
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            m = (1 << i) | (1 << j)
            val = p[i][j] * f[m][i] + p[j][i] * f[m][j]
            if val > ans:
                ans = val
    return ans

def main():
    parsed = read_input()
    if parsed is None:
        # No input provided; run self-tests
        run_tests()
        return
    n, p = parsed
    ans = solve_case_baseline(n, p)
    print("{:.10f}".format(ans))

def run_tests():
    # n=1
    n = 1
    p = [[0.0]]
    assert abs(solve_case_baseline(n, p) - 1.0) < 1e-12
    # n=2
    n = 2
    p = [[0.0, 0.7],
         [0.3, 0.0]]
    assert abs(solve_case_baseline(n, p) - 0.7) < 1e-9
    # n=3 simple check: baseline equals max over permutations when n=3
    n = 3
    p = [[0.0, 0.6, 0.4],
         [0.4, 0.0, 0.6],
         [0.6, 0.4, 0.0]]
    # brute force exact
    best_perm = 0.0
    for perm in permutations(range(n)):
        best_perm = max(best_perm, chain_survival_prob(list(perm), p, 0))
    ans = solve_case_baseline(n, p)
    assert abs(ans - best_perm) < 1e-12
    # Random-ish sanity
    print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The asserts cover $n=1$, $n=2$, and $n=3$ where brute force over orders matches the optimal strategy.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Dynamic programming over subsets with a designated current champion: $f(S,c)$ gives the optimal survival probability of player $1$ from state $(S,c)$. Transitions consider each outsider $j\notin S$ joining next; Ivan picks the $j$ yielding the maximum.}
\ASSUMPTIONS{Participants are indexed $0\ldots n-1$ in code, with player $0$ being Ivan. We compute bottom-up in decreasing $|S|$ so that $f(S\cup\{j\},\cdot)$ is already known.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $f(U,c)=\mathbf{1}[c=0]$.
\item For $k=n-1$ down to $2$, for each mask $S$ with $|S|=k$ and for each $c\in S$, set
$f(S,c)=\max\limits_{j\notin S}\bigl(p_{c j} f(S\cup\{j\},c)+p_{j c} f(S\cup\{j\},j)\bigr)$.
\item Compute the best initial pair $(i,j)$ by
$\max\limits_{i\ne j} \bigl(p_{ij} f(\{i,j\},i)+p_{ji} f(\{i,j\},j)\bigr)$, with $n=1$ handled as $1$.
\end{algosteps}
\COMPLEXITY{This visits all states $(S,c)$ with $|S|\ge 2$ and tries all outsiders, which is $O(n^2 2^n)$ time and $O(n 2^n)$ space.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(\sum_{k=2}^{n} \binom{n}{k} \cdot k \cdot (n-k)\right) = \Theta(n^2 2^n),\\
S(n) &= \Theta(n 2^n).
\end{aligned}
\]
\CORRECTNESS{For any state $(S,c)$, the next entrant $j$ is the only decision; the recurrence enumerates all such admissible decisions and uses optimal substructure because after $j$ joins, the process is memoryless except for the new champion and updated $S$. By induction on $|U\setminus S|$, $f$ gives the optimal value.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    p = [[0.0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            p[i][j] = float(next(it))
    return n, p

def solve_case(n, p):
    # Optimal DP over subsets with champion
    if n == 1:
        return 1.0
    N = 1 << n
    full = N - 1
    # Precompute popcount for all masks
    pc = [0] * N
    for m in range(1, N):
        pc[m] = pc[m >> 1] + (m & 1)
    # DP table
    f = [[0.0] * n for _ in range(N)]
    # Base
    for c in range(n):
        f[full][c] = 1.0 if c == 0 else 0.0
    # Iterate decreasing sizes
    for k in range(n - 1, 1, -1):
        m = full
        while m:
            if pc[m] == k:
                notm = (~m) & full
                c_bits = m
                while c_bits:
                    cb = c_bits & -c_bits
                    c = cb.bit_length() - 1
                    c_bits ^= cb
                    best = 0.0
                    outsiders = notm
                    while outsiders:
                        ob = outsiders & -outsiders
                        j = ob.bit_length() - 1
                        outsiders ^= ob
                        mm = m | (1 << j)
                        val = p[c][j] * f[mm][c] + p[j][c] * f[mm][j]
                        if val > best:
                            best = val
                    f[m][c] = best
            m = (m - 1) & full
    # Initial pair
    ans = 0.0
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            m = (1 << i) | (1 << j)
            val = p[i][j] * f[m][i] + p[j][i] * f[m][j]
            if val > ans:
                ans = val
    return ans

def main():
    parsed = read_input()
    if parsed is None:
        run_tests()
        return
    n, p = parsed
    ans = solve_case(n, p)
    print("{:.10f}".format(ans))

def run_tests():
    # Basic sanity tests
    n = 1
    p = [[0.0]]
    assert abs(solve_case(n, p) - 1.0) < 1e-12
    n = 2
    p = [[0.0, 0.7],
         [0.3, 0.0]]
    assert abs(solve_case(n, p) - 0.7) < 1e-12
    n = 3
    p = [[0.0, 0.6, 0.4],
         [0.4, 0.0, 0.6],
         [0.6, 0.4, 0.0]]
    ans = solve_case(n, p)
    assert 0.0 <= ans <= 1.0
    print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Covers $n=1$, $n=2$ exactness and a $n=3$ consistency range check.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Same $f(S,c)$ DP, but with careful bit-iteration and precomputed popcounts to achieve $O(n^2 2^n)$ with low constants. This is the standard solution for CF 678/E.}
\ASSUMPTIONS{0-based indices; player $0$ is Ivan. Double precision suffices for $10^{-6}$ accuracy.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute popcounts for all masks.
\item Initialize base $f(\text{full},c)=\mathbf{1}[c=0]$.
\item For $k=n-1$ down to $2$, for each mask with $|S|=k$ and champion $c\in S$, compute $f(S,c)$ by maximizing over outsiders.
\item Take the best initial pair $(i,j)$ using $f(\{i,j\},i)$ and $f(\{i,j\},j)$.
\end{algosteps}
\OPTIMALITY{At every decision point, Ivan's only control is the choice of the next entrant. The DP considers all such choices and uses exact subproblem values, yielding the Bellman optimality principle and thus the global optimum.}
\COMPLEXITY{The state space is $n\cdot 2^n$; each state tries $O(n)$ outsiders.}
\[
\begin{aligned}
T(n) &= \Theta(n^2 2^n),\quad S(n)=\Theta(n 2^n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    p = [[0.0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            p[i][j] = float(next(it))
    return n, p

def solve_all():
    parsed = read_input()
    if parsed is None:
        run_tests()
        return
    n, p = parsed
    ans = solve_case(n, p)
    print("{:.10f}".format(ans))

def solve_case(n, p):
    if n == 1:
        return 1.0
    N = 1 << n
    full = N - 1
    pc = [0] * N
    for m in range(1, N):
        pc[m] = pc[m >> 1] + (m & 1)
    f = [[0.0] * n for _ in range(N)]
    for c in range(n):
        f[full][c] = 1.0 if c == 0 else 0.0
    for k in range(n - 1, 1, -1):
        m = full
        while m:
            if pc[m] == k:
                notm = (~m) & full
                c_bits = m
                while c_bits:
                    cb = c_bits & -c_bits
                    c = cb.bit_length() - 1
                    c_bits ^= cb
                    best = 0.0
                    outsiders = notm
                    while outsiders:
                        ob = outsiders & -outsiders
                        j = ob.bit_length() - 1
                        outsiders ^= ob
                        mm = m | (1 << j)
                        val = p[c][j] * f[mm][c] + p[j][c] * f[mm][j]
                        if val > best:
                            best = val
                    f[m][c] = best
            m = (m - 1) & full
    ans = 0.0
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            m = (1 << i) | (1 << j)
            val = p[i][j] * f[m][i] + p[j][i] * f[m][j]
            if val > ans:
                ans = val
    return ans

def run_tests():
    # 1) Trivial
    n = 1
    p = [[0.0]]
    assert abs(solve_case(n, p) - 1.0) < 1e-12
    # 2) Two players
    n = 2
    p = [[0.0, 0.7],
         [0.3, 0.0]]
    assert abs(solve_case(n, p) - 0.7) < 1e-12
    # 3) Three players sanity
    n = 3
    p = [[0.0, 0.6, 0.4],
         [0.4, 0.0, 0.6],
         [0.6, 0.4, 0.0]]
    ans = solve_case(n, p)
    assert 0.0 <= ans <= 1.0
    print("OK")

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts: $n=1$ exact, $n=2$ exact, $n=3$ bounded sanity.}
\RESULT{Print the optimal win probability for Ivan (player $1$).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for trivial and small cases; property checks that result lies in $[0,1]$; cross-check against brute force over permutations for $n=3$.}
\LINE{CROSS-CHECKS}{Compare baseline permutation max vs optimal DP for $n=3$ (they must match).}
\LINE{EDGE-CASE GENERATOR}{Generate degenerate matrices: identity-like (certain wins), symmetric coin-flip ($p_{ij}=0.5$), and strongly cyclic preferences.}
\begin{minted}{python}
import random

def gen_matrix(n, mode="coin"):
    p = [[0.0]*n for _ in range(n)]
    if mode == "coin":
        for i in range(n):
            for j in range(n):
                if i == j: p[i][j] = 0.0
                elif i < j:
                    p[i][j] = 0.5
                    p[j][i] = 0.5
    elif mode == "dominant0":
        for i in range(n):
            for j in range(n):
                if i == j: p[i][j] = 0.0
                elif i == 0:
                    p[i][j] = 0.9
                    p[j][i] = 0.1
                elif j == 0:
                    p[i][j] = 0.1
                    p[j][i] = 0.9
                else:
                    if i < j:
                        p[i][j] = 0.5
                        p[j][i] = 0.5
    elif mode == "random":
        for i in range(n):
            for j in range(n):
                if i == j: p[i][j] = 0.0
                elif i < j:
                    x = random.random()
                    p[i][j] = x
                    p[j][i] = 1.0 - x
    return p

def reference_solve(n, p):
    # Reuse the final DP
    return solve_case(n, p)

def quick_tests():
    # coin-flip: result should be symmetric; not necessarily 1/n due to adaptivity, but within [0,1]
    for n in [1, 2, 3, 4]:
        p = gen_matrix(n, "coin")
        ans = reference_solve(n, p)
        assert 0.0 <= ans <= 1.0
    # dominant player 0 should have high probability
    n = 5
    p = gen_matrix(n, "dominant0")
    ans = reference_solve(n, p)
    assert ans > 0.5

if __name__ == "__main__":
    # Bring in solve_case from the Final Submission block if running standalone
    from math import isfinite
    def solve_case(n, p):
        if n == 1:
            return 1.0
        N = 1 << n
        full = N - 1
        pc = [0] * N
        for m in range(1, N):
            pc[m] = pc[m >> 1] + (m & 1)
        f = [[0.0] * n for _ in range(N)]
        for c in range(n):
            f[full][c] = 1.0 if c == 0 else 0.0
        for k in range(n - 1, 1, -1):
            m = full
            while m:
                if pc[m] == k:
                    notm = (~m) & full
                    c_bits = m
                    while c_bits:
                        cb = c_bits & -c_bits
                        c = cb.bit_length() - 1
                        c_bits ^= cb
                        best = 0.0
                        outsiders = notm
                        while outsiders:
                            ob = outsiders & -outsiders
                            j = ob.bit_length() - 1
                            outsiders ^= ob
                            mm = m | (1 << j)
                            val = p[c][j] * f[mm][c] + p[j][c] * f[mm][j]
                            if val > best:
                                best = val
                        f[m][c] = best
                m = (m - 1) & full
        ans = 0.0
        for i in range(n):
            for j in range(n):
                if i == j: continue
                m = (1 << i) | (1 << j)
                val = p[i][j] * f[m][i] + p[j][i] * f[m][j]
                if val > ans:
                    ans = val
        return ans
    quick_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    p = [[0.0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            p[i][j] = float(next(it))
    return n, p

def solve_case(n, p):
    if n == 1:
        return 1.0
    N = 1 << n
    full = N - 1
    pc = [0] * N
    for m in range(1, N):
        pc[m] = pc[m >> 1] + (m & 1)
    f = [[0.0] * n for _ in range(N)]
    for c in range(n):
        f[full][c] = 1.0 if c == 0 else 0.0
    for k in range(n - 1, 1, -1):
        m = full
        while m:
            if pc[m] == k:
                notm = (~m) & full
                c_bits = m
                while c_bits:
                    cb = c_bits & -c_bits
                    c = cb.bit_length() - 1
                    c_bits ^= cb
                    best = 0.0
                    outsiders = notm
                    while outsiders:
                        ob = outsiders & -outsiders
                        j = ob.bit_length() - 1
                        outsiders ^= ob
                        mm = m | (1 << j)
                        val = p[c][j] * f[mm][c] + p[j][c] * f[mm][j]
                        if val > best:
                            best = val
                    f[m][c] = best
            m = (m - 1) & full
    ans = 0.0
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            m = (1 << i) | (1 << j)
            val = p[i][j] * f[m][i] + p[j][i] * f[m][j]
            if val > ans:
                ans = val
    return ans

def main():
    parsed = read_input()
    if parsed is None:
        run_asserts()
        return
    n, p = parsed
    ans = solve_case(n, p)
    print("{:.10f}".format(ans))

def run_asserts():
    # 3 asserts
    n = 1
    p = [[0.0]]
    assert abs(solve_case(n, p) - 1.0) < 1e-12
    n = 2
    p = [[0.0, 0.7],
         [0.3, 0.0]]
    assert abs(solve_case(n, p) - 0.7) < 1e-12
    n = 3
    p = [[0.0, 0.6, 0.4],
         [0.4, 0.0, 0.6],
         [0.6, 0.4, 0.0]]
    ans = solve_case(n, p)
    assert 0.0 <= ans <= 1.0
    print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{DP over subsets with a designated champion yields the optimal controlled survival probability for player $1$.}
\WHY{Appears in interviews and contests as a classic controlled DP with exponential states but feasible for $n\le 18$.}
\CHECKLIST{
\begin{bullets}
\item Define state $(S,c)$ precisely.
\item Use bottom-up in decreasing $|S|$.
\item Base case: full mask returns $\mathbf{1}[c=0]$.
\item Transition: maximize over $j\notin S$ of two-outcome expectation.
\item Compute best initial pair $(i,j)$.
\item Print with sufficient precision.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ should return $1$.
\item $n=2$ equals $p_{12}$.
\item Symmetric $p_{ij}=0.5$ everywhere.
\item Extremely biased rows/columns.
\item Numerical stability for values near $0$ or $1$.
\item Complementarity $p_{ij}+p_{ji}=1$ respected.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to restrict $j$ to outsiders $j\notin S$.
\item Iterating masks in the wrong order so dependencies are uninitialized.
\item Mixing 1-based and 0-based indices (player $1$ is index $0$ in code).
\item Not handling $n=1$.
\item Precision/formatting too few decimals.
\item Inefficient popcount or mask iteration causing timeouts.
\end{bullets}}
\FAILMODES{Brute force over permutations is $n!$ and fails for $n\ge 9$. Greedy choices without DP can be suboptimal because future matchups matter. The presented DP is robust and optimal.}
\ELI{Always think “who fights next?” If Ivan can pick the next challenger, just test them all and keep the best. Store the answer for every set of already-seen players and current champion, and build from the end backwards.}
\NotePages{3}

\end{document}