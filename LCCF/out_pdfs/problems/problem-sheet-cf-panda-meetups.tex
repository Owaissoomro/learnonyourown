% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Panda Meetups}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1852/F}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{The red pandas are in town to meet their relatives, the blue pandas! The town is modeled by a number line.

The pandas have already planned their meetup, but the schedule keeps changing. You are given $q$ updates of the form $x~t~c$.

- If $c < 0$, it means $|c|$ more red pandas enter the number line at position $x$ and time $t$. Then, each unit of time, they can each independently move one unit in either direction across the number line, or not move at all.
- If $c > 0$, it means that $c$ more blue pandas check position $x$ for red pandas at time $t$. If a blue panda does not meet a red panda at that specific location and time, they dejectedly leave the number line right away. If there is a red panda at a position at the same time a blue panda checks it, they form a friendship and leave the number line. Each red panda can form a friendship with at most one blue panda and vice versa.

The updates will be given in order of non-decreasing $x$ values. After each update, please print the maximum number of friendships if the red pandas move in an optimal order based on all the updates given in the input above (and including) this update.

The order in which a red panda moves can change between updates.

Input:
The first line contains $q$ ($1 \le q \le 2 \cdot 10^5$) -- the number of updates.

The $i$-th line of the next $q$ lines consists of $3$ integers $x_i$, $t_i$ and $c_i$ ($0 \le x_i \le 10^9$, $0 \le t_i \le 10^9$, $0 < |c_i| \le 1000$) -- the description of the $i$-th update.

It is guaranteed that the $x_i$ will be given in non-decreasing order.

Output:
After each update, print the maximum number of friendships that can be formed.

Note:
In the first example, the number of friendships after each update can be optimized as follows:

1. $3$ blue pandas now check for red pandas at position $0$ at time $6$. There are no red pandas anywhere, so there are no friendships.
2. $5$ red pandas now appear at position $4$ and time $2$. $4$ of the red pandas can travel to position $0$ at time $6$, where $3$ of them can make friendships with the $3$ existing blue pandas.
3. $6$ red pandas now appear at position $7$ and time $4$. No new blue pandas are added, so the maximum number of friendships is still $3$.
4. $100$ blue pandas now appear at position $10$ and time $5$. No red pandas can reach them at a time of $5$, so no new friendships are created.
5. $7$ blue pandas now appear at position $10$ and time $8$. $6$ of the red pandas at position $7$ and time $4$, along with $1$ red panda at position $4$ and time $2$, can reach $7$ of the blue pandas at position $10$ at time $8$, adding $7$ new friendships. This brings the total to $10$ friendships.}
\BREAKDOWN{Transform to light-cone coordinates $u=x-t$, $v=x+t$. A blue check $(x_b,t_b)$ can match a red source $(x_r,t_r)$ iff $u_b \le u_r$ and $v_r \le v_b$. For any fixed prefix of updates, the maximum friendships equal the maximum bipartite matching under these 2D dominance constraints; this is solved greedily by sweeping increasing $v_b$ and assigning the smallest available $u_r \ge u_b$.}
\ELI{Sort blue times $v_b=x_b+t_b$ from early to late; by then, all reds with $v_r=x_r+t_r$ not later than that are available. Give each blue the closest-enough red in $u=x-t$ to avoid blocking future blues.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test. Integer $q$ followed by $q$ lines, each with integers $x_i$, $t_i$, $c_i$. Ranges: $1 \le q \le 2\cdot 10^5$, $0 \le x_i,t_i \le 10^9$, $0 < |c_i| \le 1000$. Updates are ordered by non-decreasing $x_i$.}
\OUTPUTS{After processing the first $i$ updates (prefix), print on its own line the maximum number of friendships achievable by optimally moving reds, considering only the first $i$ updates.}
\SAMPLES{Example (5 updates):
\[
\begin{aligned}
(0,6,+3) &\Rightarrow 0\\
(4,2,-5) &\Rightarrow 3\\
(7,4,-6) &\Rightarrow 3\\
(10,5,+100) &\Rightarrow 3\\
(10,8,+7) &\Rightarrow 10\\
\end{aligned}
\]
Tiny sanity:
\[
\begin{aligned}
(0,0,-1),(0,0,+1) &\Rightarrow 1\\
(2,1,-1),(0,0,+1) &\Rightarrow 0
\end{aligned}
\]}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $R$ be the multiset of red sources $(x_r,t_r)$ with multiplicities $m_r$; $B$ be the multiset of blue checks $(x_b,t_b)$ with multiplicities $m_b$. Define light-cone coordinates $u=x-t$, $v=x+t$. A red unit at $(u_r,v_r)$ can serve a blue unit at $(u_b,v_b)$ iff
\begin{BreakableEquation*}
v_r \le v_b \quad\text{and}\quad u_b \le u_r.
\end{BreakableEquation*}
Find the maximum cardinality matching with capacity constraints $m_r$, $m_b$ under these dominance relations.}
\varmapStart
\var{u}{coordinate $x-t$ (left-moving characteristic)}
\var{v}{coordinate $x+t$ (right-moving characteristic)}
\var{m_r}{multiplicity of a red source point}
\var{m_b}{multiplicity of a blue check point}
\var{M}{total number of friendships formed (objective)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Matchable pairs}~\mathcal{E} &= \{(r,b) : v_r \le v_b,~u_b \le u_r\},\\
\max M &= \sum_{(r,b)\in\mathcal{E}} f_{rb}\\
\text{s.t.}\quad
&\sum_{b:(r,b)\in\mathcal{E}} f_{rb} \le m_r,\quad \forall r\in R,\\
&\sum_{r:(r,b)\in\mathcal{E}} f_{rb} \le m_b,\quad \forall b\in B,\\
&f_{rb} \in \mathbb{Z}_{\ge 0}.
\end{aligned}
\]
}
\ASSUMPTIONS{Each unit panda is indistinguishable within its color. Movement speed bound is $1$ along the line; meetings occur at exact times/positions. Updates only add units; $x$ are given non-decreasing but that does not constrain $u$ or $v$.}
\INVARIANTS{Greedy by $v$-sweep: processing blue checks in non-decreasing $v_b$ and always assigning the smallest available $u_r \ge u_b$ yields an optimal matching for any fixed instance. Availability invariant: when handling $v_b$, all reds with $v_r \le v_b$ are the only eligible ones.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Recompute from scratch after each update: transform to $(u,v)$, sort blue checks by $v_b$; for each blue unit, scan all eligible red sources with $v_r \le v_b$ to pick the smallest $u_r \ge u_b$.}
\ASSUMPTIONS{Small instances; correctness prioritized over performance. Multiplicities processed one-by-one.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain the list of events up to the current prefix.
\item Build red list $\{(u_r,v_r,\text{cnt})\}$ and blue list $\{(u_b,v_b,\text{cnt})\}$.
\item Sort blues by $v_b$. For each blue unit (repeat by its count), scan all reds with $v_r \le v_b$, $u_r \ge u_b$ and positive remaining count to find the minimum $u_r$; consume one and increment the answer if found.
\end{algosteps}
\COMPLEXITY{For a prefix with $R$ red points and $B$ blue points and total counts $C_B$, scanning per unit yields $O(C_B \cdot R)$ time; building/sorting adds $O((R+B)\log (R+B))$. Space is $O(R+B)$.}
\[
\begin{aligned}
T(\text{prefix}) &= O\big((R+B)\log(R+B) + C_B \cdot R\big),\\
S(\text{prefix}) &= O(R+B).
\end{aligned}
\]
\CORRECTNESS{Choosing the smallest feasible $u_r$ for each blue in non-decreasing $v_b$ order is a known optimal greedy for 2D dominance matching. This baseline implements that choice by explicit scans.}
\EDGECASES{Multiple identical $(x,t)$; many units at one point; no red or no blue; ties in $u$; blues with $t_b < t_r$ or $|x_b-x_r| > t_b-t_r$ are naturally excluded by the $u,v$ constraints.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> List[Tuple[int,int,int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    q = next(it)
    events = []
    for _ in range(q):
        x = next(it); t = next(it); c = next(it)
        events.append((x, t, c))
    return events

def transform_prefix(events: List[Tuple[int,int,int]]) -> Tuple[List[Tuple[int,int,int]], List[Tuple[int,int,int]]]:
    reds = []   # (u_r, v_r, cnt)
    blues = []  # (u_b, v_b, cnt)
    for (x, t, c) in events:
        u = x - t
        v = x + t
        if c < 0:
            reds.append((u, v, -c))
        elif c > 0:
            blues.append((u, v, c))
    return reds, blues

def greedy_match_baseline(reds: List[Tuple[int,int,int]], blues: List[Tuple[int,int,int]]) -> int:
    # Copy mutable counts
    reds = [list(r) for r in reds]  # [u, v, cnt]
    blues = [list(b) for b in blues]  # [u, v, cnt]
    # Sort blues by v ascending (then u ascending optional)
    blues.sort(key=lambda x: (x[1], x[0]))
    # No need to sort reds by v for baseline; we scan all and check v<=v_b
    ans = 0
    for u_b, v_b, cnt_b in blues:
        # Repeat per blue unit
        for _ in range(cnt_b):
            best_idx = -1
            best_u = None
            # Scan all reds
            for i, (u_r, v_r, cnt_r) in enumerate(reds):
                if cnt_r <= 0:
                    continue
                if v_r <= v_b and u_r >= u_b:
                    if best_u is None or u_r < best_u:
                        best_u = u_r
                        best_idx = i
            if best_idx != -1:
                reds[best_idx][2] -= 1
                ans += 1
            # else: no feasible red for this blue unit
    return ans

def solve_all(events: List[Tuple[int,int,int]]) -> List[int]:
    ans_prefix = []
    prefix = []
    for ev in events:
        prefix.append(ev)
        reds, blues = transform_prefix(prefix)
        ans = greedy_match_baseline(reds, blues)
        ans_prefix.append(ans)
    return ans_prefix

def main():
    events = read_input()
    if not events:
        # Self-checks
        # Sample from the note:
        evs = [(0,6,3),(4,2,-5),(7,4,-6),(10,5,100),(10,8,7)]
        out = solve_all(evs)
        assert out == [0,3,3,3,10], f"Got {out}"
        # Tiny checks
        evs2 = [(0,0,-1),(0,0,1)]
        out2 = solve_all(evs2)
        assert out2 == [0,1]
        evs3 = [(2,1,-1),(0,0,1)]
        out3 = solve_all(evs3)
        assert out3 == [0,0]
        print("OK")
    else:
        res = solve_all(events)
        sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Includes asserts: the 5-update example yields outputs $[0,3,3,3,10]$; two tiny edge checks.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Maintain a sweep on $v$: insert all reds with $v_r \le v_b$ into an ordered multiset keyed by $u_r$ with multiplicities. For each blue $(u_b,v_b)$, greedily take the smallest $u_r \ge u_b$ via lower\_bound.}
\ASSUMPTIONS{Ordered multiset supports: insert $(u_r,\text{cnt})$, lower\_bound$(u_b)$, and erase/decrement.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Partition events into reds and blues; compute $(u,v)$ and multiplicities.
\item Sort reds by $v_r$; sort blues by $v_b$.
\item Sweep blues in ascending $v_b$, inserting newly eligible reds into a balanced structure keyed by $u_r$. For each blue count, lower\_bound to the smallest $u_r \ge u_b$ and match as many as possible at that key.
\end{algosteps}
\COMPLEXITY{For a fixed instance, $O((R+B)\log K + M\log K)$ where $K$ is the number of distinct $u_r$ keys and $M$ the total matches; practically $O((R+B)\log (R+B))$. Recomputing per prefix yields $O(i\log i)$ per step on prefix size $i$.}
\[
\begin{aligned}
T(\text{one instance}) &= O((R+B)\log (R+B)),\\
S &= O(R+B).
\end{aligned}
\]
\CORRECTNESS{Classical exchange argument: if a blue at $v_b$ is assigned a red with $u_r$ larger than the minimum feasible, swapping with any later blue that needs a larger $u$ cannot reduce feasibility; thus picking the minimum feasible $u_r$ preserves optimality.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from bisect import bisect_left
from typing import List, Tuple

def read_input() -> List[Tuple[int,int,int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    q = next(it)
    events = []
    for _ in range(q):
        x = next(it); t = next(it); c = next(it)
        events.append((x, t, c))
    return events

class OrderedMultiset:
    def __init__(self):
        self.keys: List[int] = []
        self.cnt: List[int] = []
    def insert(self, key: int, c: int = 1):
        i = bisect_left(self.keys, key)
        if i < len(self.keys) and self.keys[i] == key:
            self.cnt[i] += c
        else:
            self.keys.insert(i, key)
            self.cnt.insert(i, c)
    def lower_bound_index(self, key: int) -> int:
        return bisect_left(self.keys, key)
    def take_from(self, i: int, need: int) -> int:
        if i >= len(self.keys): 
            return 0
        take = min(need, self.cnt[i])
        self.cnt[i] -= take
        if self.cnt[i] == 0:
            del self.cnt[i]; del self.keys[i]
        return take

def transform_prefix(events: List[Tuple[int,int,int]]) -> Tuple[List[Tuple[int,int,int]], List[Tuple[int,int,int]]]:
    reds = []
    blues = []
    for (x, t, c) in events:
        u = x - t
        v = x + t
        if c < 0:
            reds.append((u, v, -c))
        elif c > 0:
            blues.append((u, v, c))
    return reds, blues

def greedy_match_sweep(reds: List[Tuple[int,int,int]], blues: List[Tuple[int,int,int]]) -> int:
    reds = sorted(reds, key=lambda x: (x[1], x[0]))
    blues = sorted(blues, key=lambda x: (x[1], x[0]))
    ms = OrderedMultiset()
    ans = 0
    i = 0
    for u_b, v_b, c_b in blues:
        # Insert all reds with v_r <= v_b
        while i < len(reds) and reds[i][1] <= v_b:
            u_r, v_r, cnt = reds[i]
            ms.insert(u_r, cnt)
            i += 1
        # Match this blue group
        while c_b > 0:
            j = ms.lower_bound_index(u_b)
            if j >= len(ms.keys):
                break
            taken = ms.take_from(j, c_b)
            if taken == 0:
                break
            ans += taken
            c_b -= taken
    return ans

def solve_all(events: List[Tuple[int,int,int]]) -> List[int]:
    ans = []
    pref = []
    for ev in events:
        pref.append(ev)
        reds, blues = transform_prefix(pref)
        ans.append(greedy_match_sweep(reds, blues))
    return ans

def main():
    events = read_input()
    if not events:
        # Self-checks (same as baseline)
        evs = [(0,6,3),(4,2,-5),(7,4,-6),(10,5,100),(10,8,7)]
        out = solve_all(evs)
        assert out == [0,3,3,3,10]
        evs2 = [(0,0,-1),(0,0,1)]
        assert solve_all(evs2) == [0,1]
        evs3 = [(2,1,-1),(0,0,1)]
        assert solve_all(evs3) == [0,0]
        print("OK")
    else:
        res = solve_all(events)
        sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked on the 5-update example and two tiny edge cases; results match expectations.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{For any fixed instance (a given prefix), the $v$-sweep with an ordered multiset keyed by $u$ and greedy lower\_bound matches is optimal. Across prefixes, one can recompute in $O(i\log i)$ per prefix. Fully optimal dynamic maintenance across prefixes requires advanced techniques (e.g., CDQ divide-and-conquer on time with Fenwick trees or offline segment tree divide-and-conquer), but the per-prefix recomputation is already optimal for a given instance and simple to implement.}
\ASSUMPTIONS{Greedy optimality holds because the feasible region is a distributive lattice under $(u,v)$ dominance; processing in non-decreasing $v_b$ and assigning the smallest feasible $u_r$ never harms future options.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Transform events to $(u,v)$.
\item Sort red points by $v_r$ and blue points by $v_b$.
\item Maintain a balanced structure of available $u_r$ from reds with $v_r \le v_b$, and for each blue group, take lower\_bound$(u_b)$ greedily.
\end{algosteps}
\OPTIMALITY{Exchange argument: If a blue at $v_b$ is assigned a red with $u_r$ strictly larger than the smallest feasible, swapping the larger $u_r$ with that smallest feasible cannot decrease the number of future matches, since any later blue that needed the larger $u$ still has it available. This inductively yields maximal matches.}
\COMPLEXITY{For one instance with $N=R+B$ points and total multiplicity $C$, time is $O(N\log N + C\log N)$; if counts are aggregated per key, $C \le N$ in effect. Recomputing after each of $q$ updates is $O\!\left(\sum_{i=1}^q i\log i\right)=O(q^2\log q)$ in the worst case for this naive per-prefix recomputation.}
\[
\begin{aligned}
T_\text{one} &= O((R+B)\log (R+B)),\quad S_\text{one}=O(R+B).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from bisect import bisect_left
from typing import List, Tuple

def read_input() -> List[Tuple[int,int,int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    q = next(it)
    events = []
    for _ in range(q):
        x = next(it); t = next(it); c = next(it)
        events.append((x, t, c))
    return events

class OrderedMultiset:
    __slots__ = ("keys","cnt")
    def __init__(self):
        self.keys: List[int] = []
        self.cnt: List[int] = []
    def insert(self, key: int, c: int = 1):
        i = bisect_left(self.keys, key)
        if i < len(self.keys) and self.keys[i] == key:
            self.cnt[i] += c
        else:
            self.keys.insert(i, key)
            self.cnt.insert(i, c)
    def lower_bound_index(self, key: int) -> int:
        return bisect_left(self.keys, key)
    def take_from(self, i: int, need: int) -> int:
        if i >= len(self.keys):
            return 0
        take = min(need, self.cnt[i])
        self.cnt[i] -= take
        if self.cnt[i] == 0:
            del self.cnt[i]; del self.keys[i]
        return take

def transform_to_uv(events: List[Tuple[int,int,int]]) -> Tuple[List[Tuple[int,int,int]], List[Tuple[int,int,int]]]:
    reds = []
    blues = []
    for (x, t, c) in events:
        u = x - t
        v = x + t
        if c < 0:
            reds.append((u, v, -c))
        elif c > 0:
            blues.append((u, v, c))
    return reds, blues

def max_friendships_for_prefix(events: List[Tuple[int,int,int]]) -> int:
    reds, blues = transform_to_uv(events)
    reds.sort(key=lambda r: (r[1], r[0]))
    blues.sort(key=lambda b: (b[1], b[0]))
    ms = OrderedMultiset()
    ans = 0
    i = 0
    for u_b, v_b, c_b in blues:
        while i < len(reds) and reds[i][1] <= v_b:
            u_r, v_r, cnt = reds[i]
            ms.insert(u_r, cnt)
            i += 1
        while c_b > 0:
            j = ms.lower_bound_index(u_b)
            if j >= len(ms.keys):
                break
            taken = ms.take_from(j, c_b)
            if taken == 0:
                break
            ans += taken
            c_b -= taken
    return ans

def solve_all(events: List[Tuple[int,int,int]]) -> List[int]:
    res = []
    pref = []
    for ev in events:
        pref.append(ev)
        res.append(max_friendships_for_prefix(pref))
    return res

def main():
    events = read_input()
    if not events:
        # Deterministic self-tests
        evs = [(0,6,3),(4,2,-5),(7,4,-6),(10,5,100),(10,8,7)]
        out = solve_all(evs)
        assert out == [0,3,3,3,10], out
        # Edge sanity
        assert solve_all([(0,0,-1),(0,0,1)]) == [0,1]
        assert solve_all([(2,1,-1),(0,0,1)]) == [0,0]
        print("OK")
    else:
        out = solve_all(events)
        sys.stdout.write("\n".join(map(str, out)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts: the $5$-update narrative example and two tiny cases.}
\RESULT{After each update, print the maximum number of friendships achievable up to that point. Ties are irrelevant since we output counts only.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted edge cases: no reds, no blues, simultaneous $(x,t)$ with multiplicities, non-reachable pairs, and reachable with multiple assignments. Property check: greedy per-prefix equals a slow scan implementation.}
\LINE{CROSS-CHECKS}{Compare Approach A (scan) and Approach C (ordered multiset) on random tiny instances to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate small $q\le 8$ with $x,t \in [0,5]$ and counts in $\{1,2\}$; verify equality across methods.}
\begin{minted}{python}
import random
from typing import List, Tuple

def slow_prefix(events: List[Tuple[int,int,int]]) -> List[int]:
    # Approach A baseline
    import sys
    sys.setrecursionlimit(1000000)
    from typing import List, Tuple
    def transform_prefix(evs):
        reds, blues = [], []
        for (x, t, c) in evs:
            u = x - t; v = x + t
            if c < 0: reds.append([u, v, -c])
            elif c > 0: blues.append([u, v, c])
        return reds, blues
    def greedy(reds, blues):
        blues.sort(key=lambda x: (x[1], x[0]))
        ans = 0
        for u_b, v_b, c_b in blues:
            for _ in range(c_b):
                best = None; bi = -1
                for i,(u_r,v_r,c_r) in enumerate(reds):
                    if c_r>0 and v_r<=v_b and u_r>=u_b:
                        if best is None or u_r<best:
                            best = u_r; bi = i
                if bi!=-1:
                    reds[bi][2]-=1; ans+=1
        return ans
    out=[]
    pref=[]
    for e in events:
        pref.append(e)
        r,b = transform_prefix(pref)
        out.append(greedy(r,b))
    return out

def fast_prefix(events: List[Tuple[int,int,int]]) -> List[int]:
    # Approach C final
    from bisect import bisect_left
    class OMS:
        def __init__(self): self.k=[]; self.c=[]
        def ins(self,u,ct):
            i=bisect_left(self.k,u)
            if i<len(self.k) and self.k[i]==u: self.c[i]+=ct
            else: self.k.insert(i,u); self.c.insert(i,ct)
        def lb(self,u): return bisect_left(self.k,u)
        def take(self,i,need):
            if i>=len(self.k): return 0
            t=min(need,self.c[i]); self.c[i]-=t
            if self.c[i]==0: del self.c[i]; del self.k[i]
            return t
    def one(pref):
        reds=[]; blues=[]
        for x,t,c in pref:
            u=x-t; v=x+t
            if c<0: reds.append((u,v,-c))
            elif c>0: blues.append((u,v,c))
        reds.sort(key=lambda x:(x[1],x[0]))
        blues.sort(key=lambda x:(x[1],x[0]))
        i=0; ms=OMS(); ans=0
        for u_b,v_b,c_b in blues:
            while i<len(reds) and reds[i][1]<=v_b:
                u_r,v_r,ct=reds[i]; ms.ins(u_r,ct); i+=1
            while c_b>0:
                j=ms.lb(u_b)
                if j>=len(ms.k): break
                t=ms.take(j,c_b)
                if t==0: break
                ans+=t; c_b-=t
        return ans
    res=[]; pref=[]
    for e in events:
        pref.append(e)
        res.append(one(pref))
    return res

def rnd_events(q: int, seed: int=0) -> List[Tuple[int,int,int]]:
    rng = random.Random(seed)
    xs = sorted(rng.randrange(0,6) for _ in range(q))
    evs=[]
    for i in range(q):
        x = xs[i]
        t = rng.randrange(0,6)
        c = rng.choice([1,2,-1,-2])
        evs.append((x,t,c))
    return evs

def main():
    # Cross-check random small instances
    for seed in range(50):
        evs = rnd_events(8, seed)
        a = slow_prefix(evs)
        b = fast_prefix(evs)
        assert a == b, (seed, evs, a, b)
    # Fixed example
    evs = [(0,6,3),(4,2,-5),(7,4,-6),(10,5,100),(10,8,7)]
    assert fast_prefix(evs) == [0,3,3,3,10]
    print("All tests passed.")

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from bisect import bisect_left
from typing import List, Tuple

def read_input() -> List[Tuple[int,int,int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    q = next(it)
    events = []
    for _ in range(q):
        x = next(it); t = next(it); c = next(it)
        events.append((x, t, c))
    return events

class OrderedMultiset:
    __slots__ = ("keys","cnt")
    def __init__(self):
        self.keys: List[int] = []
        self.cnt: List[int] = []
    def insert(self, key: int, c: int = 1):
        i = bisect_left(self.keys, key)
        if i < len(self.keys) and self.keys[i] == key:
            self.cnt[i] += c
        else:
            self.keys.insert(i, key)
            self.cnt.insert(i, c)
    def lower_bound_index(self, key: int) -> int:
        return bisect_left(self.keys, key)
    def take_from(self, i: int, need: int) -> int:
        if i >= len(self.keys):
            return 0
        take = min(need, self.cnt[i])
        self.cnt[i] -= take
        if self.cnt[i] == 0:
            del self.cnt[i]; del self.keys[i]
        return take

def transform_to_uv(events: List[Tuple[int,int,int]]) -> Tuple[List[Tuple[int,int,int]], List[Tuple[int,int,int]]]:
    reds = []
    blues = []
    for (x, t, c) in events:
        u = x - t
        v = x + t
        if c < 0:
            reds.append((u, v, -c))
        elif c > 0:
            blues.append((u, v, c))
    return reds, blues

def max_friendships_for_prefix(events: List[Tuple[int,int,int]]) -> int:
    reds, blues = transform_to_uv(events)
    reds.sort(key=lambda r: (r[1], r[0]))
    blues.sort(key=lambda b: (b[1], b[0]))
    ms = OrderedMultiset()
    ans = 0
    i = 0
    for u_b, v_b, c_b in blues:
        while i < len(reds) and reds[i][1] <= v_b:
            u_r, v_r, cnt = reds[i]
            ms.insert(u_r, cnt)
            i += 1
        while c_b > 0:
            j = ms.lower_bound_index(u_b)
            if j >= len(ms.keys):
                break
            taken = ms.take_from(j, c_b)
            if taken == 0:
                break
            ans += taken
            c_b -= taken
    return ans

def solve_all(events: List[Tuple[int,int,int]]) -> List[int]:
    res = []
    pref = []
    for ev in events:
        pref.append(ev)
        res.append(max_friendships_for_prefix(pref))
    return res

def main():
    events = read_input()
    if not events:
        # Asserts for sanity
        evs = [(0,6,3),(4,2,-5),(7,4,-6),(10,5,100),(10,8,7)]
        out = solve_all(evs)
        assert out == [0,3,3,3,10], out
        assert solve_all([(0,0,-1),(0,0,1)]) == [0,1]
        assert solve_all([(2,1,-1),(0,0,1)]) == [0,0]
        print("OK")
    else:
        out = solve_all(events)
        sys.stdout.write("\n".join(map(str, out)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Transform $(x,t)$ to $(u=x-t, v=x+t)$ and greedily match by sweeping $v$ while picking the smallest feasible $u$.}
\WHY{This 2D dominance matching pattern appears in scheduling with speed constraints, lattice path assignments, and geometry-to-flow reductions.}
\CHECKLIST{
- Convert each update to $(u,v)$ with multiplicity.
- For a fixed prefix, sort reds by $v_r$ and blues by $v_b$.
- Sweep $v_b$; insert eligible reds into an ordered multiset on $u_r$.
- For each blue group, lower\_bound on $u_b$ and match greedily.
- Output cumulative matches for the prefix.
}
\EDGECASES{
- No reds yet: answer $0$.
- No blues yet: answer $0$.
- Identical $(x,t)$ with large multiplicities.
- Blues with $t_b < t_r$: filtered by $v_r \le v_b$.
- Far-away $x$ violating speed: filtered by $u_b \le u_r$ and $v_r \le v_b$.
- Multiple blues at the same $(u_b,v_b)$.
- Multiple reds at the same $(u_r,v_r)$.
- Very large counts at one point (batch consume).
- All $x$ equal (trivial $x$ ordering does not matter).
}
\PITFALLS{
- Forgetting to process multiplicities atomically (batching at a key is faster).
- Using $|x_b-x_r| \le t_b-t_r$ directly without the $(u,v)$ transform can lead to incorrect greedy ordering.
- Inserting reds strictly before $v_r < v_b$ and omitting equality case $v_r = v_b$.
- Using the largest feasible $u_r$ instead of the smallest; this can block future matches.
- Not removing $u_r$ when its count drops to $0$ from the multiset.
- Mishandling integer overflow in other languages when computing $u,v$ (use 64-bit).
}
\FAILMODES{Naive pairwise greedy in arbitrary blue order fails; must process blues by non-decreasing $v_b$. Greedy by nearest in $x$ without $u$ threshold can be suboptimal. The provided sweep with ordered multiset avoids these.}
\ELI{Think of time flowing forward ($v$ increases). By a given time, some red sources are available. Each blue needs a red whose $u=x-t$ is not too small. Give each blue the smallest $u$ that works so as not to take away scarce larger-$u$ reds from future blues.}
\NotePages{3}

\end{document}