% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Rudolf and CodeVid-23}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1846/G}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{A new virus called ``CodeVid-23'' has spread among programmers. Rudolf, being a programmer, was not able to avoid it.

There are $n$ symptoms numbered from $1$ to $n$ that can appear when infected. Initially, Rudolf has some of them. He went to the pharmacy and bought $m$ medicines.

For each medicine, the number of days it needs to be taken is known, and the set of symptoms it removes. Unfortunately, medicines often have side effects. Therefore, for each medicine, the set of symptoms that appear when taking it is also known.

After reading the instructions, Rudolf realized that taking more than one medicine at a time is very unhealthy.

Rudolph wants to be healed as soon as possible. Therefore, he asks you to calculate the minimum number of days to remove all symptoms, or to say that it is impossible.

Input:
The first line contains a single integer $t$ $(1 \le t \le 100)$ — the number of test cases.

Then follow the descriptions of the test cases.

The first line of each test case contains two integers $n, m$ $(1 \le n \le 10, 1 \le m \le 10^3)$ — the number of symptoms and medicines, respectively.

The second line of each test case contains a string of length $n$ consisting of the characters $0$ and $1$ — the description of Rudolf's symptoms. If the $i$-th character of the string is $1$, Rudolf has the $i$-th symptom, otherwise he does not.

Then follow $3 \cdot m$ lines — the description of the medicines.

The first line of each medicine description contains an integer $d$ $(1 \le d \le 10^3)$ — the number of days the medicine needs to be taken.

The next two lines of the medicine description contain two strings of length $n$, consisting of the characters $0$ and $1$ — the description of the symptoms it removes and the description of the side effects.

In the first of the two lines, $1$ at position $i$ means that the medicine removes the $i$-th symptom, and $0$ otherwise.

In the second of the two lines, $1$ at position $i$ means that the $i$-th symptom appears after taking the medicine, and $0$ otherwise.

Different medicines can have the same sets of symptoms and side effects. If a medicine relieves a certain symptom, it will not be among the side effects.

The sum of $m$ over all test cases does not exceed $10^3$.

Output:
For each test case, output a single integer on a separate line — the minimum number of days it will take Rudolf to remove all symptoms. If this never happens, output $-1$.

Note:
In the first example, we can first apply medicine number $4$, after which the symptoms will look like ``00101''. After that, medicine number $2$, then all symptoms will disappear, and the number of days will be $5 + 3 = 8$. Another option is to apply the medicines in the order $1, 3, 2$. In this case, all symptoms will also disappear, but the number of days will be $3 + 3 + 3 = 9$.

In the second example, there are no symptoms initially, so the treatment will take $0$ days.

In the third example, there are no options to remove all symptoms.}
\BREAKDOWN{Model each symptom set as a bitmask state ($n \le 10$), each medicine as a weighted transition that clears some bits and sets others. Find the minimum total days to reach the zero mask using a shortest path over $2^n$ states.}
\ELI{Think of symptoms as up to $10$ light switches; each pill toggles some off and turns some on with a time cost. Choose a pill sequence that gets all lights off in the least total time.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: integers $n, m$; a binary string $s$ of length $n$ for initial symptoms; for each medicine: integer $d$, a binary string $rem$ of length $n$ (symptoms removed), and a binary string $add$ of length $n$ (side effects).}
\OUTPUTS{For each test case, a single integer: the minimum total days to reach the all-zero symptom state, or $-1$ if impossible.}
\SAMPLES{Example 1 (simple):
\[
\begin{aligned}
t&=1\\
n,m&=1,1\\
s&=\text{"1"}\\
d&=3,\ rem=\text{"1"},\ add=\text{"0"}\\
\text{Output:}&\ 3
\end{aligned}
\]
Example 2 (already healthy):
\[
\begin{aligned}
t&=1\\
n,m&=2,0\\
s&=\text{"00"}\\
\text{Output:}&\ 0
\end{aligned}
\]}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let states be bitmasks $S \in \{0,1\}^n$ encoding current symptoms. Each medicine $k$ is a pair of masks $(R_k, A_k)$ and cost $d_k$, transitioning
\begin{BreakableEquation*}
S \mapsto \bigl(S \,\&\, \neg R_k\bigr)\ \mid\ A_k.
\end{BreakableEquation*}
We seek $\min$ total cost from initial $S_0$ to target $0$.}
\varmapStart
\var{n}{number of symptoms, $1 \le n \le 10$}
\var{m}{number of medicines, $1 \le m \le 10^3$}
\var{S}{current symptom mask}
\var{S_0}{initial mask derived from input string}
\var{R_k}{mask of symptoms removed by medicine $k$}
\var{A_k}{mask of side effects added by medicine $k$}
\var{d_k}{days (cost) for medicine $k$, $1 \le d_k \le 10^3$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Transition:}\quad & T_k(S) \coloneqq \bigl(S \ \&\ (\text{all\_ones} \oplus R_k)\bigr) \ \mid\ A_k,\\
\text{Shortest path:}\quad & \text{dist}[0] \ =\ \min_{\text{paths } S_0 \to 0} \ \sum d_{k_i} \\
& \text{subject to } S_{i+1} = T_{k_i}(S_i).
\end{aligned}
\]
}
\ASSUMPTIONS{Bits are indexed $0..n-1$ from left to right of input strings. Sets $R_k$ and $A_k$ are disjoint per statement. Medicines may be reused any number of times; only the cost and transitions matter.}
\INVARIANTS{Transition is deterministic and depends only on current state and chosen medicine. Costs are nonnegative; Dijkstra's algorithm is applicable. State space size is $2^n \le 1024$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Model the problem as a weighted directed graph on $2^n$ states with edges $S \to T_k(S)$ of weight $d_k$. Use SPFA (queue-based Bellman-Ford) over this tiny state space to compute shortest paths from $S_0$.}
\ASSUMPTIONS{Nonnegative weights ensure convergence; the tiny graph size makes SPFA acceptable here.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse input and build bitmasks $S_0$, $(R_k,A_k,d_k)$ for all medicines; precompute mask\_all $=(1\ll n)-1$.
\item Initialize $\text{dist}[S]=+\infty$ for all $S$; set $\text{dist}[S_0]=0$; push $S_0$ into a queue.
\item While queue nonempty, pop $S$ and relax all $m$ transitions to $S' = ((S \& \sim R_k) \mid A_k)$ with candidate cost $\text{dist}[S]+d_k$. If improved, update and push $S'$.
\item Output $\text{dist}[0]$ if finite; otherwise $-1$.
\end{algosteps}
\COMPLEXITY{Let $N=2^n \le 1024$ and $M=m \le 10^3$. Worst-case SPFA relaxes $O(N\cdot M)$ edges with practical performance acceptable due to small $N$.}
\[
\begin{aligned}
T(n) &\approx O(N\cdot M)\ \text{relaxations} \\
     &\le O(1024 \cdot 1000) \approx 10^6\ \text{edge scans},\\
S(n) &= O(N).
\end{aligned}
\]
\CORRECTNESS{SPFA computes the same distances as Bellman-Ford on graphs with nonnegative weights, hence returns shortest path distances. The constructed graph exactly captures all medicine applications as edges with their day costs.}
\EDGECASES{Already healthy: $S_0=0$ returns $0$. Medicines that do not change a state are safely ignored upon relaxation. Disjointness of $R_k$ and $A_k$ is respected but not required by the algorithm.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
from typing import List, Tuple

INF = 10**18

def parse_mask(s: str) -> int:
    """Convert '01..' to bitmask with bit i for s[i]=='1'."""
    mask = 0
    for i, ch in enumerate(s.strip()):
        if ch == '1':
            mask |= (1 << i)
    return mask

def read_input() -> Tuple[int, List[Tuple[int, int, str, List[Tuple[int, int, int]]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        s0_str = next(it)
        meds = []
        for __ in range(m):
            d = int(next(it))
            rem = next(it)
            add = next(it)
            R = parse_mask(rem)
            A = parse_mask(add)
            meds.append((d, R, A))
        tests.append((n, parse_mask(s0_str), s0_str, meds))
    return t, tests

def solve_case_spfa(n: int, s0_mask: int, meds: List[Tuple[int, int, int]]) -> int:
    N = 1 << n
    allmask = N - 1
    dist = [INF] * N
    inq = [False] * N
    q = deque()
    dist[s0_mask] = 0
    q.append(s0_mask)
    inq[s0_mask] = True
    while q:
        s = q.popleft()
        inq[s] = False
        ds = dist[s]
        for d, R, A in meds:
            ns = ((s & (~R & allmask)) | A)
            nd = ds + d
            if nd < dist[ns]:
                dist[ns] = nd
                if not inq[ns]:
                    q.append(ns)
                    inq[ns] = True
    return -1 if dist[0] >= INF // 2 else dist[0]

def solve_all_spfa() -> None:
    import sys
    t, tests = read_input()
    out_lines = []
    for (n, s0_mask, _s0_str, meds) in tests:
        ans = solve_case_spfa(n, s0_mask, meds)
        out_lines.append(str(ans))
    sys.stdout.write("\n".join(out_lines))

def main():
    solve_all_spfa()

# --- Tests ---
def _unit_tests_spfa():
    # 1) Simple removal in one step
    n = 1
    s0 = parse_mask("1")
    meds = [(3, parse_mask("1"), parse_mask("0"))]
    assert solve_case_spfa(n, s0, meds) == 3

    # 2) Already healthy
    n = 2
    s0 = parse_mask("00")
    meds = []
    assert solve_case_spfa(n, s0, meds) == 0

    # 3) Two-step sequence: 111 -> (rem 100, add 010) -> 011 -> (rem 011, add 000) -> 000
    n = 3
    s0 = parse_mask("111")
    meds = [
        (5, parse_mask("011"), parse_mask("000")),
        (3, parse_mask("100"), parse_mask("010")),
    ]
    assert solve_case_spfa(n, s0, meds) == 8

    # 4) Impossible: only adds symptoms
    n = 1
    s0 = parse_mask("1")
    meds = [(2, parse_mask("0"), parse_mask("1"))]
    assert solve_case_spfa(n, s0, meds) == -1

    # 5) I/O style mini-test for 2 cases
    import io, sys
    sample_in = """2
1 1
1
3
1
0
2 0
00
"""
    expected_out = "3\n0\n"
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(sample_in)
        sys.stdout = io.StringIO()
        solve_all_spfa()
        out = sys.stdout.getvalue()
        assert out == expected_out
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

if __name__ == "__main__":
    _unit_tests_spfa()
\end{minted}
\VALIDATION{Covers trivial, already-healthy, two-step optimal path, and impossible cases; also verifies I/O path for two cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use Dijkstra's algorithm with a binary heap. All edge weights are positive, so Dijkstra yields optimal distances with fewer relaxations and guaranteed $O(N \log N + E \log N)$ complexity.}
\ASSUMPTIONS{Positive costs; state graph is implicit but cheap to generate; $N=2^n \le 1024$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $\text{dist}[S]=+\infty$ and $\text{dist}[S_0]=0$. Push $(0,S_0)$ to a min-heap.
\item Repeatedly pop $(d,S)$. If $d \ne \text{dist}[S]$, continue. If $S=0$, return $d$ (early exit).
\item For each medicine $k$, compute $S' = T_k(S)$. If $d+d_k < \text{dist}[S']$, relax and push to heap.
\item If the heap empties without reaching $0$, return $-1$.
\end{algosteps}
\COMPLEXITY{With $N=2^n$ and $M=m$, each state is popped once; each pop scans $M$ transitions.}
\[
\begin{aligned}
T(n) &\in O\big((N + N\cdot M)\log N\big) \le O( N M \log N) \\
     &\le O(1024 \cdot 1000 \cdot \log 1024) \approx 10^7\ \text{ops},\\
S(n) &= O(N).
\end{aligned}
\]
\CORRECTNESS{By standard Dijkstra correctness for nonnegative weights. The early exit upon popping state $0$ is safe because then $d=\text{dist}[0]$ is final.}
\textbf{Code (Improved)}
\begin{minted}{python}
import heapq
from typing import List, Tuple

INF = 10**18

def parse_mask(s: str) -> int:
    mask = 0
    for i, ch in enumerate(s.strip()):
        if ch == '1':
            mask |= (1 << i)
    return mask

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        s0_str = next(it)
        meds = []
        for __ in range(m):
            d = int(next(it))
            rem = next(it)
            add = next(it)
            meds.append((d, parse_mask(rem), parse_mask(add)))
        tests.append((n, parse_mask(s0_str), s0_str, meds))
    return t, tests

def solve_case_dijkstra(n: int, s0_mask: int, meds: List[Tuple[int, int, int]]) -> int:
    N = 1 << n
    allmask = N - 1
    dist = [INF] * N
    dist[s0_mask] = 0
    pq = [(0, s0_mask)]
    while pq:
        d, s = heapq.heappop(pq)
        if d != dist[s]:
            continue
        if s == 0:
            return d
        for cost, R, A in meds:
            ns = ((s & (~R & allmask)) | A)
            nd = d + cost
            if nd < dist[ns]:
                dist[ns] = nd
                heapq.heappush(pq, (nd, ns))
    return -1

def solve_all_dijkstra() -> None:
    import sys
    t, tests = read_input()
    out = []
    for (n, s0_mask, _s0_str, meds) in tests:
        out.append(str(solve_case_dijkstra(n, s0_mask, meds)))
    sys.stdout.write("\n".join(out))

def main():
    solve_all_dijkstra()

# --- Tests ---
def _unit_tests_dijkstra():
    # Basic: one medicine removes the only symptom
    assert solve_case_dijkstra(1, parse_mask("1"), [(7, parse_mask("1"), parse_mask("0"))]) == 7
    # Already zero
    assert solve_case_dijkstra(2, parse_mask("00"), []) == 0
    # Two-step optimal path equals SPFA result
    meds = [
        (5, parse_mask("011"), parse_mask("000")),
        (3, parse_mask("100"), parse_mask("010")),
    ]
    assert solve_case_dijkstra(3, parse_mask("111"), meds) == 8
    # Impossible
    meds = [(2, parse_mask("0"), parse_mask("1"))]
    assert solve_case_dijkstra(1, parse_mask("1"), meds) == -1
    # I/O quick check
    import io, sys
    sample_in = """3
1 1
1
3
1
0
2 0
00
3 2
111
3
100
010
5
011
000
"""
    expected_out = "3\n0\n8\n"
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(sample_in)
        sys.stdout = io.StringIO()
        solve_all_dijkstra()
        assert sys.stdout.getvalue() == expected_out
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

if __name__ == "__main__":
    _unit_tests_dijkstra()
\end{minted}
\VALIDATION{Checks equivalence to SPFA on crafted tests and exercises the early-exit path.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Run Dijkstra with pruning: from a state $S$, skip medicines that would not change the state, i.e., where $T_k(S)=S$. This reduces unnecessary relaxations without changing correctness.}
\ASSUMPTIONS{Edge weights are positive; $R_k$ and $A_k$ are disjoint; transitions are deterministic.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize distances and heap as in Approach B.
\item When expanding $S$, compute $S' = T_k(S)$. If $S'=S$, continue; else try to relax.
\item Early exit upon popping $S=0$ with finalized minimal distance.
\item Return $-1$ if unreachable.
\end{algosteps}
\OPTIMALITY{Dijkstra is optimal for nonnegative weights. Pruning only removes self-loop edges of nonnegative cost, which can never improve a shortest path.}
\COMPLEXITY{Same big-O as Approach B but fewer constant-factor relaxations due to pruning.}
\[
\begin{aligned}
T(n) &\in O(N M \log N)\ \text{in worst case}, \text{ but prunes all no-op transitions.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, heapq
from typing import List, Tuple

INF = 10**18

def parse_mask(s: str) -> int:
    mask = 0
    for i, ch in enumerate(s.strip()):
        if ch == '1':
            mask |= (1 << i)
    return mask

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        s0_str = next(it)
        meds = []
        for __ in range(m):
            d = int(next(it))
            rem = next(it)
            add = next(it)
            meds.append((d, parse_mask(rem), parse_mask(add)))
        tests.append((n, parse_mask(s0_str), s0_str, meds))
    return t, tests

def solve_case(n: int, s0_mask: int, meds: List[Tuple[int, int, int]]) -> int:
    N = 1 << n
    allmask = N - 1
    dist = [INF] * N
    dist[s0_mask] = 0
    pq: List[Tuple[int, int]] = [(0, s0_mask)]
    while pq:
        d, s = heapq.heappop(pq)
        if d != dist[s]:
            continue
        if s == 0:
            return d
        for cost, R, A in meds:
            ns = ((s & (~R & allmask)) | A)
            if ns == s:  # no change, skip
                continue
            nd = d + cost
            if nd < dist[ns]:
                dist[ns] = nd
                heapq.heappush(pq, (nd, ns))
    return -1

def solve_all() -> None:
    t, tests = read_input()
    out_lines = []
    for (n, s0_mask, _s0_str, meds) in tests:
        out_lines.append(str(solve_case(n, s0_mask, meds)))
    sys.stdout.write("\n".join(out_lines))

def main():
    solve_all()

# --- Minimal asserts and I/O mini-tests ---
def _tests_final():
    # Basic sanity tests
    assert solve_case(1, parse_mask("1"), [(4, parse_mask("1"), parse_mask("0"))]) == 4
    assert solve_case(2, parse_mask("00"), []) == 0
    # Two-step crafted example
    meds = [
        (5, parse_mask("011"), parse_mask("000")),
        (3, parse_mask("100"), parse_mask("010")),
    ]
    assert solve_case(3, parse_mask("111"), meds) == 8

    # I/O test: three cases
    import io
    sample_in = """3
1 1
1
3
1
0
2 0
00
3 2
111
3
100
010
5
011
000
"""
    expected_out = "3\n0\n8\n"
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(sample_in)
        sys.stdout = io.StringIO()
        solve_all()
        assert sys.stdout.getvalue() == expected_out
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

if __name__ == "__main__":
    _tests_final()
\end{minted}
\VALIDATION{Exactly 3 asserts plus one I/O mini-test validate core transitions, zero-case, two-step path, and aggregated I/O.}
\RESULT{Print the minimal total days to reach the zero symptom mask for each test, or $-1$ if unreachable; one line per test case.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on single-step, already-healthy, multi-step composed transitions, and impossible scenarios. Cross-validate SPFA vs Dijkstra on random tiny instances. Exercise I/O pipeline.}
\LINE{CROSS-CHECKS}{For small $n \le 4$, randomly generate medicines and confirm Approach A (SPFA) and Approach C (Dijkstra+prune) produce identical answers.}
\LINE{EDGE-CASE GENERATOR}{Generate cases with $S_0=0$, with medicines that are no-ops, and with only side-effect-adding medicines to ensure $-1$ is returned.}
\begin{minted}{python}
import random
from typing import List, Tuple

def rand_case(n: int, m: int, seed: int = 0) -> Tuple[int, int, int, List[Tuple[int,int,int]]]:
    random.seed(seed)
    s0 = 0
    for i in range(n):
        if random.randrange(2):
            s0 |= (1 << i)
    meds = []
    for _ in range(m):
        d = random.randint(1, 7)
        R = 0; A = 0
        for i in range(n):
            r = random.randrange(2)
            a = random.randrange(2)
            if r and a:
                # enforce disjointness by clearing add if remove is set
                a = 0
            if r: R |= (1 << i)
            if a: A |= (1 << i)
        meds.append((d, R, A))
    return n, s0, s0, meds

# Cross-check solver implementations deterministically
def spfa(n: int, s0: int, meds):
    from collections import deque
    INF = 10**15
    N = 1 << n
    allmask = N - 1
    dist = [INF] * N
    inq = [False] * N
    q = deque([s0])
    dist[s0] = 0
    inq[s0] = True
    while q:
        s = q.popleft()
        inq[s] = False
        ds = dist[s]
        for d, R, A in meds:
            ns = ((s & (~R & allmask)) | A)
            nd = ds + d
            if nd < dist[ns]:
                dist[ns] = nd
                if not inq[ns]:
                    q.append(ns); inq[ns] = True
    return -1 if dist[0] >= INF//2 else dist[0]

def dijk(n: int, s0: int, meds):
    import heapq
    INF = 10**15
    N = 1 << n
    allmask = N - 1
    dist = [INF] * N
    dist[s0] = 0
    pq = [(0, s0)]
    while pq:
        d, s = heapq.heappop(pq)
        if d != dist[s]: continue
        if s == 0: return d
        for c, R, A in meds:
            ns = ((s & (~R & allmask)) | A)
            if ns == s: continue
            nd = d + c
            if nd < dist[ns]:
                dist[ns] = nd
                heapq.heappush(pq, (nd, ns))
    return -1

def _cross_check():
    for seed in range(50):
        n = random.randint(1, 5)
        m = random.randint(0, 10)
        n, s0, _s0str, meds = rand_case(n, m, seed)
        a = spfa(n, s0, meds)
        b = dijk(n, s0, meds)
        assert a == b, (seed, n, m, a, b)
    # Boundary: S0=0
    assert dijk(4, 0, []) == 0

if __name__ == "__main__":
    _cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Codeforces 1846G — Rudolf and CodeVid-23
# Final reference solution: Dijkstra over bitmask states with pruning.

import sys, heapq
from typing import List, Tuple

INF = 10**18

def parse_mask(s: str) -> int:
    mask = 0
    for i, ch in enumerate(s.strip()):
        if ch == '1':
            mask |= (1 << i)
    return mask

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        s0_str = next(it)
        meds = []
        for __ in range(m):
            d = int(next(it))
            rem = next(it)
            add = next(it)
            meds.append((d, parse_mask(rem), parse_mask(add)))
        tests.append((n, parse_mask(s0_str), s0_str, meds))
    return t, tests

def solve_case(n: int, s0_mask: int, meds: List[Tuple[int, int, int]]) -> int:
    N = 1 << n
    allmask = N - 1
    dist = [INF] * N
    dist[s0_mask] = 0
    pq: List[Tuple[int, int]] = [(0, s0_mask)]
    while pq:
        d, s = heapq.heappop(pq)
        if d != dist[s]:
            continue
        if s == 0:
            return d
        for cost, R, A in meds:
            ns = ((s & (~R & allmask)) | A)
            if ns == s:  # skip no-op transitions
                continue
            nd = d + cost
            if nd < dist[ns]:
                dist[ns] = nd
                heapq.heappush(pq, (nd, ns))
    return -1

def solve_all() -> None:
    t, tests = read_input()
    out_lines = []
    for (n, s0_mask, _s0_str, meds) in tests:
        out_lines.append(str(solve_case(n, s0_mask, meds)))
    sys.stdout.write("\n".join(out_lines))

def main():
    solve_all()

# --- Asserts / mini-tests ---
def _tests_reference():
    assert solve_case(1, parse_mask("1"), [(1, parse_mask("1"), parse_mask("0"))]) == 1
    assert solve_case(2, parse_mask("00"), []) == 0
    # 111 -> (rem 100, add 010) -> 011 -> (rem 011, add 000) -> 000
    meds = [
        (5, parse_mask("011"), parse_mask("000")),
        (3, parse_mask("100"), parse_mask("010")),
    ]
    assert solve_case(3, parse_mask("111"), meds) == 8

    # I/O test
    import io
    sample_in = """2
1 1
1
3
1
0
2 0
00
"""
    expected_out = "3\n0\n"
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(sample_in)
        sys.stdout = io.StringIO()
        solve_all()
        assert sys.stdout.getvalue() == expected_out
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

if __name__ == "__main__":
    _tests_reference()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Shortest path on bitmask states where each medicine clears some bits, sets others, with positive edge weights.}
\WHY{Bitmask DPs and state-graph shortest paths are common in contests; recognizing tiny state spaces enables polynomial-time solutions regardless of $m$.}
\CHECKLIST{%
\begin{bullets}
\item Convert strings to bitmasks consistently (bit $i$ for character at index $i$).
\item Transition: $S'=(S \& \neg R)\mid A$ with mask limiting to $n$ bits.
\item Use Dijkstra (positive costs); early exit on state $0$.
\item Skip no-op transitions to reduce work.
\item Handle $S_0=0$ returning $0$.
\item Print $-1$ if unreachable.
\end{bullets}}
\EDGECASES{%
\begin{bullets}
\item $S_0=0$.
\item Medicines list empty.
\item Medicines that do nothing on a given state.
\item Multiple medicines with identical $(R,A,d)$.
\item Large $m$ but small $n$.
\item Side effects only (no removal) — may lead to $-1$.
\item Chains requiring several steps where greedy by removal size fails.
\item States near $2^n-1$ and $0$.
\end{bullets}}
\PITFALLS{%
\begin{bullets}
\item Forgetting to mask with $(1\ll n)-1$ when using bitwise NOT.
\item Misindexing bits vs. string order.
\item Using BFS (unweighted) despite varying $d_k$.
\item Not skipping outdated heap entries in Dijkstra.
\item Overflow not an issue in Python, but be careful with sentinels for $\infty$.
\item Treating $R$ and $A$ as toggles; they are clear-then-set, not XOR.
\item Assuming medicines must remove a present symptom; not required by statement.
\end{bullets}}
\FAILMODES{Greedy strategies (e.g., pick medicine removing most symptoms) can loop or be suboptimal. Pure BFS ignores weights and yields incorrect totals. The Dijkstra approach survives because it explores by nondecreasing total days.}
\ELI{We try different pills in different orders. Each choice changes which symptoms we have and takes some time. Using a best-first search by total days, we stop as soon as we first reach the completely healthy state; that time is minimal.}
\NotePages{3}

\end{document}