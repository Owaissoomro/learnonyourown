% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Permutation Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/818/B}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{%
You are given $n$ children standing in a circle. Their numbers in clockwise order form a permutation $a_1, a_2, \ldots, a_n$ of length $n$; that is, each integer from $1$ to $n$ appears exactly once.

The game consists of $m$ steps. On each step, the current leader with index $i$ counts out $a_i$ people in clockwise order, starting from the next person. The last one to be pointed at by the leader becomes the new leader.

You are given numbers $l_1, l_2, \ldots, l_m$ — the indices of leaders at the beginning of each step. The child with number $l_1$ is the first leader in the game.

Restore any permutation $a_1, a_2, \ldots, a_n$ consistent with the process. If there are multiple solutions, print any of them. If there is no solution, print $-1$.

Input:
The first line contains two integers $n, m$ ($1 \le n, m \le 100$).

The second line contains $m$ integers $l_1, l_2, \ldots, l_m$ ($1 \le l_i \le n$) — the indices of leaders at the beginning of each step.

Output:
Print a permutation of $n$ numbers $a_1, a_2, \ldots, a_n$ such that the leaders in the game are exactly $l_1, l_2, \ldots, l_m$ if all the rules are followed. If there are multiple solutions, print any of them.

If there is no permutation that satisfies the conditions, print $-1$.

Note (illustration of leadership in a sample):
\begin{bullets}
\item Child $2$ starts.
\item Leadership goes from $2$ to $2 + a_2 = 3$.
\item Leadership goes from $3$ to $3 + a_3 = 5$. As it is greater than $4$, it goes in a circle to $1$.
\item Leadership goes from $1$ to $1 + a_1 = 4$.
\item Leadership goes from $4$ to $4 + a_4 = 8$. Thus in the circle it remains at $4$.
\end{bullets}
}
\BREAKDOWN{%
From consecutive leaders $l_k \to l_{k+1}$ we can deduce the exact value of $a_{l_k}$ modulo $n$, which uniquely maps to a value in $\{1,\ldots,n\}$ by interpreting $0$ as $n$. Enforce consistency across repeated leaders and ensure the assigned values form a permutation; fill the rest arbitrarily with unused values.
}
\ELI{%
The difference (clockwise steps) from each leader to the next tells you that leader's $a_i$. If any leader is forced to two different values or two leaders need the same value, it is impossible; otherwise use the remaining unused numbers anywhere.
}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{%
$n, m \in \mathbb{Z}$ with $1 \le n, m \le 100$ (works for larger up to typical CF bounds).
Sequence $l_1,\ldots,l_m$ with $1 \le l_i \le n$.
}
\OUTPUTS{%
Either one line with $n$ integers forming a permutation $a_1,\ldots,a_n$ satisfying the leadership sequence rules, or $-1$ if impossible.
}
\SAMPLES{%
Example 1:
Input
\[
\begin{aligned}
n,m &= 4,5 \\
\mathbf{l} &= [2,3,1,4,4]
\end{aligned}
\]
One valid output is $[3,1,2,4]$.

Example 2:
Input
\[
\begin{aligned}
n,m &= 3,3 \\
\mathbf{l} &= [1,2,3]
\end{aligned}
\]
Output is $-1$ because both $a_1$ and $a_2$ would need to be $1$.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{%
Indices $[n]=\{1,\ldots,n\}$ around a circle. A permutation $\mathbf{a}\in\{1,\ldots,n\}^n$ with all values distinct. Given leaders $\mathbf{l}=(l_1,\ldots,l_m)$ with $l_k\in[n]$. Transition rule:
\begin{BreakableEquation*}
l_{k+1} = \bigl((l_k - 1) + a_{l_k}\bigr) \bmod n + 1,\quad k=1,\ldots,m-1.
\end{BreakableEquation*}
Find $\mathbf{a}$ or decide infeasibility.
}
\varmapStart
\var{n}{number of children}
\var{m}{number of steps (leaders given)}
\var{l_k}{leader index at step $k$}
\var{a_i}{count from leader $i$; forms a permutation of $[n]$}
\var{d_k}{required clockwise distance from $l_k$ to $l_{k+1}$ in $[0,n-1]$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
d_k &\equiv (l_{k+1}-l_k) \bmod n,\quad d_k\in\{0,1,\ldots,n-1\},\\
a_{l_k} &= \begin{cases}
n, & d_k=0,\\
d_k, & d_k\in\{1,\ldots,n-1\},
\end{cases}
\quad k=1,\ldots,m-1,\\
\{a_1,\ldots,a_n\} &= [n]\ \text{(all distinct)}.
\end{aligned}
\]
}
\ASSUMPTIONS{%
Indices are $1$-based around the circle. If a leader $i$ appears multiple times among $\{l_k\}$ as the current leader, all induced values for $a_i$ must be equal. Assigned values must be unique across positions.
}
\INVARIANTS{%
\begin{bullets}
\item Each constraint fixes exactly one position's value: only $a_{l_k}$ is constrained by the pair $(l_k,l_{k+1})$.
\item Mapping $d_k=0\mapsto a_{l_k}=n$ and $d_k\in[1,n-1]\mapsto a_{l_k}=d_k$ is bijective within $\{1,\ldots,n\}$.
\item Unassigned positions can be filled with remaining unused values without violating transitions.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{%
Use the direct constraint extraction $a_{l_k} = \bigl((l_{k+1}-l_k)\bmod n\bigr)$ with $0\mapsto n$. Check consistency across repeats and uniqueness of values; then arbitrarily assign remaining unused values to remaining positions.
}
\ASSUMPTIONS{%
We assume standard $1$-based modular arithmetic on a circle of size $n$. If contradictions arise, no permutation exists.
}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $a_i=0$ for all $i$ and an empty set of used values.
\item For each $k=1$ to $m-1$, compute $d=(l_{k+1}-l_k)\bmod n$; if $d=0$ set $v=n$ else $v=d$. Enforce $a_{l_k}\in\{0,v\}$ and that $v$ is unused unless already assigned to $l_k$.
\item After processing constraints, assign the remaining unused values to the zero positions in any order.
\end{algosteps}
\COMPLEXITY{%
$T(n)=\mathcal{O}(n+m)$, $S(n)=\mathcal{O}(n)$.
\[
\begin{aligned}
T(n) &= \mathcal{O}(m)\ \text{for constraints} + \mathcal{O}(n)\ \text{to fill remaining} \\
     &= \mathcal{O}(n+m).
\end{aligned}
\]
}
\CORRECTNESS{%
Each pair $(l_k,l_{k+1})$ uniquely determines $a_{l_k}$ in $\{1,\ldots,n\}$. If two constraints demand different values for the same position or the same value for two positions, no permutation can satisfy both uniqueness and transitions. Otherwise, assigning remaining values freely preserves all transitions since they do not affect already-determined leaders.
}
\EDGECASES{%
$m=1$ implies no constraints; any permutation is valid. Repeated same leader implies $a_{l_k}=n$. Leaders that wrap around are handled by modulo with $0\mapsto n$.
}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

def read_input(data: str) -> Optional[Tuple[int, int, List[int]]]:
    toks = data.strip().split()
    if not toks:
        return None
    it = iter(map(int, toks))
    try:
        n = next(it)
        m = next(it)
        l = [next(it) for _ in range(m)]
        return n, m, l
    except StopIteration:
        return None

def solve_case(n: int, m: int, l: List[int]) -> Optional[List[int]]:
    a = [0] * (n + 1)  # 1-indexed
    used = [False] * (n + 1)
    for k in range(m - 1):
        i = l[k]
        j = l[k + 1]
        d = (j - i) % n
        v = n if d == 0 else d
        if a[i] != 0 and a[i] != v:
            return None
        if a[i] == 0:
            if used[v]:
                return None
            a[i] = v
            used[v] = True
        else:
            # a[i] == v already; ok
            pass
    # fill remaining
    free_vals = [v for v in range(1, n + 1) if not used[v]]
    idx = 0
    for i in range(1, n + 1):
        if a[i] == 0:
            a[i] = free_vals[idx]
            idx += 1
    return a[1:]

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, m, l = parsed
    res = solve_case(n, m, l)
    if res is None:
        return "-1\n"
    return " ".join(map(str, res)) + "\n"

def check_perm(n: int, leaders: List[int], a: List[int]) -> bool:
    # simulate transitions
    for k in range(len(leaders) - 1):
        cur = leaders[k]
        nxt = leaders[k + 1]
        step = a[cur - 1]
        calc = ((cur - 1) + step) % n + 1
        if calc != nxt:
            return False
    return True

def main():
    data = sys.stdin.read()
    if not data.strip():
        # self-tests
        # Test 1: sample-like from note
        n, m, l = 4, 5, [2, 3, 1, 4, 4]
        ans = solve_case(n, m, l)
        assert ans is not None and ans == [3, 1, 2, 4]
        assert check_perm(n, l, ans)
        # Test 2: impossible case
        n, m, l = 3, 3, [1, 2, 3]
        ans = solve_case(n, m, l)
        assert ans is None
        # Test 3: repeated leader implies n
        n, m, l = 3, 3, [1, 1, 1]
        ans = solve_case(n, m, l)
        assert ans is not None and ans[0] == 3 and len(set(ans)) == 3
        assert check_perm(n, l, ans)
        print("OK")
    else:
        sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{%
Tiny checks: the code asserts the sample-like case $[2,3,1,4,4]\mapsto[3,1,2,4]$, an impossible case $[1,2,3]$, and a repeated-leader case $[1,1,1]$ with $a_1=n$.
}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{%
Same direct constraints, but we maintain the pool of unused values with a queue to fill remaining positions in a single pass. Early exit on the first contradiction.
}
\ASSUMPTIONS{%
The set of remaining values is independent of positions not appearing in constraints; any order works. We choose increasing order for determinism.
}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Process constraints left-to-right; if an already-used value is needed by a new position, abort as impossible.
\item Track unused values in a list and fill zeros in increasing order.
\item Output the completed permutation.
\end{algosteps}
\COMPLEXITY{%
Same as baseline: $\mathcal{O}(n+m)$ time and $\mathcal{O}(n)$ space, but with fewer dynamic checks and early pruning.
\[
\begin{aligned}
T(n) &= \mathcal{O}(m) + \mathcal{O}(n).
\end{aligned}
\]
}
\CORRECTNESS{%
Identical to baseline: constraints uniquely determine some positions; uniqueness and consistency checks ensure feasibility; filling remaining values preserves all constraints.
}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

def read_input(data: str) -> Optional[Tuple[int, int, List[int]]]:
    s = data.strip().split()
    if not s:
        return None
    it = iter(map(int, s))
    try:
        n = next(it)
        m = next(it)
        l = [next(it) for _ in range(m)]
        return n, m, l
    except StopIteration:
        return None

def solve_case(n: int, m: int, l: List[int]) -> Optional[List[int]]:
    a = [0] * (n + 1)
    used = [False] * (n + 1)
    for k in range(m - 1):
        i = l[k]
        j = l[k + 1]
        d = (j - i) % n
        v = n if d == 0 else d
        if a[i] == 0:
            if used[v]:
                return None
            a[i] = v
            used[v] = True
        elif a[i] != v:
            return None
    free_vals = [v for v in range(1, n + 1) if not used[v]]
    t = 0
    for i in range(1, n + 1):
        if a[i] == 0:
            a[i] = free_vals[t]
            t += 1
    return a[1:]

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, m, l = parsed
    ans = solve_case(n, m, l)
    if ans is None:
        return "-1\n"
    return " ".join(map(str, ans)) + "\n"

def simulate_ok(n: int, leaders: List[int], a: List[int]) -> bool:
    for k in range(len(leaders) - 1):
        cur = leaders[k]
        nxt = leaders[k + 1]
        if ((cur - 1) + a[cur - 1]) % n + 1 != nxt:
            return False
    return True

def main():
    data = sys.stdin.read()
    if not data.strip():
        # quick validations
        assert solve_case(3, 3, [1, 2, 3]) is None
        out = solve_case(4, 5, [2, 3, 1, 4, 4])
        assert out == [3, 1, 2, 4]
        assert simulate_ok(4, [2, 3, 1, 4, 4], out)
        # no constraints => any permutation (deterministic fill)
        out = solve_case(5, 1, [3])
        assert sorted(out) == [1, 2, 3, 4, 5]
        print("OK")
    else:
        sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{%
Checks include feasibility, infeasibility, and the no-constraint case; all are deterministic and simulate to verify correctness.
}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{%
Constraint propagation on a permutation with uniqueness: map each transition $l_k\to l_{k+1}$ to $a_{l_k}=\bigl((l_{k+1}-l_k)\bmod n\bigr)$ with $0\mapsto n$, enforce consistency and injectivity, then fill remaining entries with unused values.
}
\ASSUMPTIONS{%
The leaders are valid indices and the circle arithmetic uses $1$-based wraparound.
}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize arrays for assignment and usage markers.
\item For each adjacent leader pair, deduce the required value for $a_{l_k}$ and enforce constraints; on contradiction, return $-1$.
\item Fill remaining unassigned positions with the remaining unused values (in increasing order for determinism) and output the permutation.
\end{algosteps}
\OPTIMALITY{%
Any algorithm must at least read the $m$ transitions and produce $n$ outputs, so $\Omega(n+m)$ is a lower bound. This method achieves $\Theta(n+m)$ time and $\Theta(n)$ space, which is optimal up to constants.
}
\COMPLEXITY{%
\[
\begin{aligned}
T(n) &= \mathcal{O}(m) + \mathcal{O}(n) = \mathcal{O}(n+m),\\
S(n) &= \mathcal{O}(n).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

def read_input(data: str) -> Optional[Tuple[int, int, List[int]]]:
    parts = data.strip().split()
    if not parts:
        return None
    it = iter(map(int, parts))
    try:
        n = next(it)
        m = next(it)
        l = [next(it) for _ in range(m)]
        return n, m, l
    except StopIteration:
        return None

def solve_case(n: int, m: int, l: List[int]) -> Optional[List[int]]:
    a = [0] * (n + 1)      # 1-indexed
    used = [False] * (n + 1)
    # Enforce constraints from consecutive leaders
    for k in range(m - 1):
        i = l[k]
        j = l[k + 1]
        d = (j - i) % n
        v = n if d == 0 else d
        if a[i] == 0:
            if used[v]:
                return None
            a[i] = v
            used[v] = True
        elif a[i] != v:
            return None
    # Fill remaining with unused values
    rem = [v for v in range(1, n + 1) if not used[v]]
    p = 0
    for i in range(1, n + 1):
        if a[i] == 0:
            a[i] = rem[p]
            p += 1
    return a[1:]

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, m, l = parsed
    ans = solve_case(n, m, l)
    if ans is None:
        return "-1\n"
    return " ".join(map(str, ans)) + "\n"

def simulate_ok(n: int, leaders: List[int], a: List[int]) -> bool:
    for k in range(len(leaders) - 1):
        cur = leaders[k]
        nxt = leaders[k + 1]
        if ((cur - 1) + a[cur - 1]) % n + 1 != nxt:
            return False
    return True

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Exactly 3 asserts / I/O mini-tests
        out = solve_case(4, 5, [2, 3, 1, 4, 4])
        assert out == [3, 1, 2, 4] and simulate_ok(4, [2, 3, 1, 4, 4], out)
        assert solve_case(3, 3, [1, 2, 3]) is None
        anyp = solve_case(5, 1, [4])
        assert anyp is not None and sorted(anyp) == [1, 2, 3, 4, 5]
        print("OK")
    else:
        sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{%
Three asserts: a feasible case simulation, an impossible case, and the no-constraint case confirming permutation validity.
}
\RESULT{%
If multiple permutations satisfy the constraints, any one is printed. On contradiction (value reuse or conflicting assignments), print $-1$.
}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{%
Unit tests verify: constraint deduction and wraparound; conflict detection (same value demanded by different positions or conflicting assignments for the same position); and unconstrained positions filled with remaining values. Property: the output is a permutation and simulates to the given leaders.
}
\LINE{CROSS-CHECKS}{%
Compare outputs across Approach A, B, and C on small random instances; all should agree on feasibility and on some valid permutation (not necessarily identical due to arbitrary fill order).
}
\LINE{EDGE-CASE GENERATOR}{%
Generate random $n$ and a random permutation $a$, simulate leaders, then feed leaders back to the solver to ensure recovery of a consistent permutation. Also generate adversarial leaders causing conflicts.
}
\begin{minted}{python}
import random

def gen_random_instance(n: int, m: int):
    a = list(range(1, n + 1))
    random.shuffle(a)
    # simulate leaders from a random start
    l1 = random.randint(1, n)
    leaders = [l1]
    cur = l1
    for _ in range(m - 1):
        cur = ((cur - 1) + a[cur - 1]) % n + 1
        leaders.append(cur)
    return n, m, leaders, a

def cross_check(trials: int = 50):
    from collections import Counter
    ok = 0
    for _ in range(trials):
        n = random.randint(2, 10)
        m = random.randint(1, 10)
        n, m, leaders, a_truth = gen_random_instance(n, m)
        from io import StringIO
        data = f"{n} {m}\n" + " ".join(map(str, leaders)) + "\n"
        # Use final reference solve_all
        out = solve_all(data)
        if out.strip() == "-1":
            # could happen if leaders are too short to constrain, but since
            # generated from a valid permutation, it should be solvable
            return False
        a_sol = list(map(int, out.strip().split()))
        # Check permutation property and simulation
        if sorted(a_sol) != list(range(1, n + 1)):
            return False
        if not simulate_ok(n, leaders, a_sol):
            return False
        ok += 1
    return ok == trials

if __name__ == "__main__":
    # Deterministic sanity runs
    random.seed(0)
    assert cross_check(10)
    print("Generator cross-checks passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Optional, Tuple

def read_input(data: str) -> Optional[Tuple[int, int, List[int]]]:
    parts = data.strip().split()
    if not parts:
        return None
    it = iter(map(int, parts))
    try:
        n = next(it)
        m = next(it)
        l = [next(it) for _ in range(m)]
        return n, m, l
    except StopIteration:
        return None

def solve_case(n: int, m: int, l: List[int]) -> Optional[List[int]]:
    a = [0] * (n + 1)
    used = [False] * (n + 1)
    for k in range(m - 1):
        i = l[k]
        j = l[k + 1]
        d = (j - i) % n
        v = n if d == 0 else d
        if a[i] == 0:
            if used[v]:
                return None
            a[i] = v
            used[v] = True
        elif a[i] != v:
            return None
    # fill any remaining positions with remaining values
    rem = [v for v in range(1, n + 1) if not used[v]]
    p = 0
    for i in range(1, n + 1):
        if a[i] == 0:
            a[i] = rem[p]
            p += 1
    return a[1:]

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, m, l = parsed
    ans = solve_case(n, m, l)
    if ans is None:
        return "-1\n"
    return " ".join(map(str, ans)) + "\n"

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks (won't run on CF since input is provided)
        out = solve_case(4, 5, [2, 3, 1, 4, 4])
        assert out == [3, 1, 2, 4]
        assert solve_case(3, 3, [1, 2, 3]) is None
        anyp = solve_case(5, 1, [2])
        assert anyp is not None and sorted(anyp) == [1, 2, 3, 4, 5]
        print("OK")
    else:
        sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{%
Deduce $a_{l_k}$ from each consecutive leader pair using circle differences; check consistency and uniqueness; fill the rest with unused numbers.
}
\WHY{%
Common CF pattern: reconstructing permutations from modular differences with uniqueness constraints; tests careful handling of $0\mapsto n$ and repeated constraints.
}
\CHECKLIST{%
\begin{bullets}
\item Compute $d=(l_{k+1}-l_k)\bmod n$; map $0\mapsto n$.
\item If $a_{l_k}=0$, set it to $d'$ if unused; else fail.
\item If $a_{l_k}\ne 0$ and $a_{l_k}\ne d'$, fail.
\item After constraints, assign remaining unused values to remaining positions.
\item Output permutation or $-1$.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $m=1$ (no constraints): any permutation works.
\item Repeated same leader consecutively: forces $a_i=n$.
\item Wraparound transitions: ensure modulo arithmetic is correct.
\item Conflicts where two different leaders demand the same value.
\item Same leader appearing multiple times with conflicting demands.
\item All positions constrained except one: ensure the last unused value is valid.
\item $n=1$: only $a_1=1$ is valid; any leaders sequence is consistent.
\item Large $m$ with many repeats: performance still linear.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to map $d=0$ to $n$.
\item Allowing a used value to be reassigned to a different index.
\item Off-by-one in $1$-based modulo: use $((i-1)+a_i)\bmod n + 1$.
\item Not checking consistency when a leader index repeats.
\item Filling remaining positions with non-deterministic or duplicate values.
\item Misreading input when $m=0$ (not allowed here, but be cautious).
\item Printing trailing spaces or wrong formatting.
\item Using $0$-based arrays unintentionally for $a$ while leaders are $1$-based.
\end{bullets}
}
\FAILMODES{%
Weaker approaches that try to simulate or guess without enforcing uniqueness can assign the same value to multiple positions, violating permutation property. The presented method prevents this by tracking used values and immediate contradiction detection.
}
\ELI{%
Every jump from a leader to the next tells you how many steps were counted. Put that number into that leader's spot. If two spots fight for the same number, it is impossible. Otherwise, fill the empty spots with the remaining numbers.
}
\NotePages{3}

\end{document}