% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Balanced Removals (Harder)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1237/C2}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{This is a harder version of the problem. In this version, $n \le 50\,000$.

There are $n$ distinct points in three-dimensional space numbered from $1$ to $n$. The $i$-th point has coordinates $(x_i, y_i, z_i)$. The number of points $n$ is even.

You would like to remove all $n$ points using a sequence of $\tfrac{n}{2}$ snaps. In one snap, you can remove any two points $a$ and $b$ that have not been removed yet and form a perfectly balanced pair. A pair of points $a$ and $b$ is perfectly balanced if no other point $c$ (that has not been removed yet) lies within the axis-aligned minimum bounding box of points $a$ and $b$.

Formally, point $c$ lies within the axis-aligned minimum bounding box of points $a$ and $b$ if and only if $\min(x_a, x_b) \le x_c \le \max(x_a, x_b)$, $\min(y_a, y_b) \le y_c \le \max(y_a, y_b)$, and $\min(z_a, z_b) \le z_c \le \max(z_a, z_b)$. Note that the bounding box might be degenerate.

Find a way to remove all points in $\tfrac{n}{2}$ snaps.

Input: The first line contains a single integer $n$ ($2 \le n \le 50\,000$; $n$ is even), denoting the number of points.

Each of the next $n$ lines contains three integers $x_i$, $y_i$, $z_i$ ($-10^8 \le x_i, y_i, z_i \le 10^8$), denoting the coordinates of the $i$-th point.

No two points coincide.

Output: Output $\tfrac{n}{2}$ pairs of integers $a_i, b_i$ ($1 \le a_i, b_i \le n$), denoting the indices of points removed on snap $i$. Every integer between $1$ and $n$, inclusive, must appear in your output exactly once.

We can show that it is always possible to remove all points. If there are many solutions, output any of them.

Note: In the first example, here is what points and their corresponding bounding boxes look like (drawn in two dimensions for simplicity, as all points lie on $z = 0$ plane). Note that order of removing matters: for example, points $5$ and $1$ do not form a perfectly balanced pair initially, but they do after point $3$ is removed.}
\BREAKDOWN{Pair points so that at each pairing step the axis-aligned box of the chosen two contains no other remaining point. Use sorting and grouping by coordinates to greedily create safe pairs and carry forward leftovers.}
\ELI{Pair within identical $(x,y)$ first by $z$, then within identical $x$ by $y$, finally across $x$ by $x$; each stage preserves the ``empty box'' property.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integer $n$ ($2 \le n \le 50\,000$, even).
- Then $n$ lines: integers $x_i,y_i,z_i$ with $-10^8 \le x_i,y_i,z_i \le 10^8$. All points are distinct.}
\OUTPUTS{Exactly $\tfrac{n}{2}$ lines, each with two integers $a~b$ ($1 \le a,b \le n$), such that each index in $[1..n]$ appears exactly once. Any valid sequence of perfectly balanced pairs is accepted.}
\SAMPLES{Example 1:
Input
4
0 0 0
0 0 1
0 1 0
1 0 0

One valid output
1 2
3 4

Example 2:
Input
6
0 0 0
0 0 2
0 1 1
0 1 3
2 5 7
9 9 9

One valid output
1 2
3 4
5 6}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a finite set $P=\{p_i=(x_i,y_i,z_i)\}_{i=1}^n$ with distinct points, partition $P$ into $n/2$ unordered pairs $\{(i,j)\}$ and an order over these pairs so that, at the time of selecting any pair $(i,j)$, the axis-aligned box $B(i,j)$ contains no other point still present.}
\varmapStart
\var{P}{set of input points}
\var{B(i,j)}{axis-aligned bounding box spanning $p_i$ and $p_j$}
\var{\pi}{sequence of pairs forming a perfect matching consistent with the box-emptiness condition}
\varmapEnd
\GOVERN{
\[
\forall (i,j)\in \pi:\quad \nexists\, k\ne i,j \text{ remaining at this step s.t. } x_k\in[\min(x_i,x_j),\max(x_i,x_j)],\\
y_k\in[\min(y_i,y_j),\max(y_i,y_j)],\ z_k\in[\min(z_i,z_j),\max(z_i,z_j)].
\]
}
\ASSUMPTIONS{Coordinates are integers; no two points coincide. The parity constraint ensures $n$ is even, so a full pairing exists.}
\INVARIANTS{Greedy grouping invariant:
- Within a fixed $(x,y)$, pairing consecutive points by $z$ leaves no unpaired point between the two in $z$, so the box is empty.
- Within fixed $x$, pairing leftovers by increasing $y$ ensures boxes are empty inside that $x$-slice after previous step.
- Finally, pairing across increasing $x$ keeps boxes empty after prior eliminations.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the process: repeatedly find any pair whose bounding box is empty with respect to the current remaining set; remove it; continue.}
\ASSUMPTIONS{Small $n$ only; correctness over performance.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a set of remaining indices $S$.
\item Scan all unordered pairs $\{i,j\}\subseteq S$; for each, test whether no $k\in S\setminus\{i,j\}$ lies inside $B(i,j)$.
\item Take the first valid pair, output it, and remove it from $S$; repeat until $S=\varnothing$.
\end{algosteps}
\COMPLEXITY{Cubic in the worst case.}
\[
\begin{aligned}
T(n) &\le \sum_{t=1}^{n/2} O(|S_t|^2 \cdot |S_t|) = \sum_{t=1}^{n/2} O(|S_t|^3) \\
     &= O\!\left(\sum_{m=2,\,\text{even}}^{n} m^3\right) = O(n^4),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Always removes some pair if a full solution exists; since a solution is guaranteed, the greedy finds a valid pair at each step.}
\EDGECASES{Points sharing coordinates; degenerate boxes (same coordinate values); minimal $n=2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple
import io

def read_input(data: str = None) -> Tuple[int, List[Tuple[int,int,int,int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    n = int(next(it))
    pts = []
    for i in range(1, n+1):
        x = int(next(it)); y = int(next(it)); z = int(next(it))
        pts.append((x, y, z, i))
    return n, pts

def empty_box(i, j, Sset, coords):
    xi, yi, zi = coords[i]
    xj, yj, zj = coords[j]
    xmin, xmax = (xi, xj) if xi <= xj else (xj, xi)
    ymin, ymax = (yi, yj) if yi <= yj else (yj, yi)
    zmin, zmax = (zi, zj) if zi <= zj else (zj, zi)
    for k in Sset:
        if k == i or k == j:
            continue
        xk, yk, zk = coords[k]
        if xmin <= xk <= xmax and ymin <= yk <= ymax and zmin <= zk <= zmax:
            return False
    return True

def solve_case_bruteforce(n: int, pts: List[Tuple[int,int,int,int]]) -> List[Tuple[int,int]]:
    # coords by index 1..n
    coords = {idx:(x,y,z) for (x,y,z,idx) in pts}
    S = set(idx for (_,_,_,idx) in pts)
    ans = []
    while S:
        found = False
        L = sorted(S)
        for a_i in range(len(L)):
            for b_i in range(a_i+1, len(L)):
                a = L[a_i]; b = L[b_i]
                if empty_box(a, b, S, coords):
                    ans.append((a, b))
                    S.remove(a); S.remove(b)
                    found = True
                    break
            if found:
                break
        if not found:
            # Should not happen for valid inputs, but guard to avoid infinite loop
            # Pair arbitrary two to proceed (keeps determinism for tests).
            L = sorted(S)
            a, b = L[0], L[1]
            ans.append((a, b))
            S.remove(a); S.remove(b)
    return ans

def solve_all() -> None:
    n, pts = read_input()
    pairs = solve_case_bruteforce(n, pts)
    out = sys.stdout
    for a, b in pairs:
        out.write(f"{a} {b}\n")

def _test_baseline():
    data = "2\n0 0 0\n1 1 1\n"
    n, pts = read_input(data)
    pairs = solve_case_bruteforce(n, pts)
    assert len(pairs) == 1 and sorted(pairs[0]) == [1,2]
    data2 = "4\n0 0 0\n0 0 1\n1 1 1\n2 2 2\n"
    n2, pts2 = read_input(data2)
    pairs2 = solve_case_bruteforce(n2, pts2)
    used = sorted([i for p in pairs2 for i in p])
    assert used == [1,2,3,4]
    # Degenerate boxes along axes
    data3 = "4\n0 0 0\n0 0 2\n0 0 4\n0 0 6\n"
    n3, pts3 = read_input(data3)
    pairs3 = solve_case_bruteforce(n3, pts3)
    assert len(pairs3) == 2 and sorted([i for p in pairs3 for i in p]) == [1,2,3,4]

if __name__ == "__main__":
    if sys.stdin.isatty():
        _test_baseline()
    else:
        solve_all()
\end{minted}
\VALIDATION{Tiny sanity tests assert coverage of minimal and degenerate inputs.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Hierarchical Grouping by Coordinates}
\WHICHFORMULA{Exploit axis alignment: empty boxes arise naturally if we pair points progressively fixing more coordinates. First pair within identical $(x,y)$ by $z$, then pair leftovers within identical $x$ by $y$, and finally pair global leftovers by $x$.}
\ASSUMPTIONS{Sorting stability; no coincident points.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group points by $(x,y)$; within each group, sort by $z$ and pair consecutive points. Keep at most one leftover from each $(x,y)$.
\item For each fixed $x$, collect leftovers from different $y$; sort by $y$ (and $z$ to break ties) and pair consecutively. Keep at most one leftover per $x$.
\item Collect global leftovers (at most one per $x$), sort by $x$ (and $y,z$ for determinism), and pair consecutively.
\end{algosteps}
\COMPLEXITY{Dominated by sorting.}
\[
\begin{aligned}
T(n) &= O(n\log n)\ \text{(sorting + linear scans)},\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Each pairing step ensures the segment in the last varying coordinate contains no remaining point between the paired two, while earlier coordinates are equal within the current stage; previously paired points are removed, so boxes are empty.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Dict, DefaultDict
from collections import defaultdict

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    n = int(next(it))
    pts = []
    for i in range(1, n+1):
        x = int(next(it)); y = int(next(it)); z = int(next(it))
        pts.append((x, y, z, i))
    return n, pts

def solve_case_grouped(n: int, pts: List[Tuple[int,int,int,int]]) -> List[Tuple[int,int]]:
    # Step 1: group by (x,y)
    by_xy: DefaultDict[Tuple[int,int], List[Tuple[int,int,int,int]]] = defaultdict(list)
    for x, y, z, idx in pts:
        by_xy[(x, y)].append((x, y, z, idx))
    pairs: List[Tuple[int,int]] = []
    leftovers_by_x: DefaultDict[int, List[Tuple[int,int,int,int]]] = defaultdict(list)

    for (x, y), arr in by_xy.items():
        arr.sort(key=lambda t: t[2])  # by z
        # pair consecutive
        i = 0
        while i + 1 < len(arr):
            a = arr[i][3]; b = arr[i+1][3]
            pairs.append((a, b))
            i += 2
        if i < len(arr):  # one leftover
            leftovers_by_x[x].append(arr[i])

    # Step 2: within each x, pair leftovers by y
    global_leftovers: List[Tuple[int,int,int,int]] = []
    for x, arr in leftovers_by_x.items():
        arr.sort(key=lambda t: (t[1], t[2], t[3]))  # by y, then z, then idx
        i = 0
        while i + 1 < len(arr):
            a = arr[i][3]; b = arr[i+1][3]
            pairs.append((a, b))
            i += 2
        if i < len(arr):
            global_leftovers.append(arr[i])

    # Step 3: pair across x by increasing x (then y,z)
    global_leftovers.sort(key=lambda t: (t[0], t[1], t[2], t[3]))
    i = 0
    while i + 1 < len(global_leftovers):
        a = global_leftovers[i][3]; b = global_leftovers[i+1][3]
        pairs.append((a, b))
        i += 2

    # Sanity: must cover all points exactly once
    used = []
    for a, b in pairs:
        used.append(a); used.append(b)
    used.sort()
    assert used == list(range(1, n+1)), "Not a perfect pairing"
    return pairs

def solve_all():
    n, pts = read_input()
    res = solve_case_grouped(n, pts)
    out = sys.stdout
    for a, b in res:
        out.write(f"{a} {b}\n")

def _test_improved():
    data = "6\n0 0 0\n0 0 2\n0 1 1\n0 1 3\n2 5 7\n9 9 9\n"
    n, pts = read_input(data)
    pairs = solve_case_grouped(n, pts)
    assert len(pairs) == 3
    used = sorted([i for p in pairs for i in p])
    assert used == [1,2,3,4,5,6]
    # Random-ish order robustness
    data2 = "4\n1 2 3\n1 2 5\n1 3 4\n2 3 4\n"
    n2, pts2 = read_input(data2)
    pairs2 = solve_case_grouped(n2, pts2)
    assert sorted([i for p in pairs2 for i in p]) == [1,2,3,4]

if __name__ == "__main__":
    if sys.stdin.isatty():
        _test_improved()
    else:
        solve_all()
\end{minted}
\VALIDATION{Checked that all indices appear exactly once; asserts on two crafted cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Three-Level Greedy on $(x,y,z)$}
\WHICHFORMULA{Standard CF solution:
- Pair within identical $(x,y)$ by $z$.
- Pair leftovers within identical $x$ by $y$.
- Pair remaining leftovers across increasing $x$.
The correctness stems from axis-aligned independence of coordinates and staged removals.}
\ASSUMPTIONS{Deterministic stable sorts; integer coordinates; uniqueness of points.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build buckets by $(x,y)$; within each, sort by $z$ and pair neighbors, promoting a single leftover (if any) upwards.
\item For each $x$, sort its promoted leftovers by $(y,z)$ and pair neighbors, promoting a single leftover (if any) further upwards.
\item Sort global leftovers by $(x,y,z)$ and pair neighbors; no leftovers remain as $n$ is even.
\end{algosteps}
\OPTIMALITY{Time-optimal up to comparison lower bounds: $O(n\log n)$ from sorting is necessary in the comparison model. Memory is linear.}
\COMPLEXITY{Sorting dominates; linear passes elsewhere.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple
from collections import defaultdict

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    n = int(next(it))
    pts = []
    for i in range(1, n+1):
        x = int(next(it)); y = int(next(it)); z = int(next(it))
        pts.append((x, y, z, i))
    return n, pts

def solve_case(n: int, pts: List[Tuple[int,int,int,int]]) -> List[Tuple[int,int]]:
    by_xy = defaultdict(list)
    for x, y, z, idx in pts:
        by_xy[(x, y)].append((x, y, z, idx))
    pairs: List[Tuple[int,int]] = []
    leftovers_by_x = defaultdict(list)

    # Stage 1: within (x,y)
    for (x, y), arr in by_xy.items():
        arr.sort(key=lambda t: t[2])  # z
        i = 0
        while i + 1 < len(arr):
            pairs.append((arr[i][3], arr[i+1][3]))
            i += 2
        if i < len(arr):
            leftovers_by_x[x].append(arr[i])

    # Stage 2: within x
    global_leftovers = []
    for x, arr in leftovers_by_x.items():
        arr.sort(key=lambda t: (t[1], t[2], t[3]))  # y, z, idx
        i = 0
        while i + 1 < len(arr):
            pairs.append((arr[i][3], arr[i+1][3]))
            i += 2
        if i < len(arr):
            global_leftovers.append(arr[i])

    # Stage 3: across x
    global_leftovers.sort(key=lambda t: (t[0], t[1], t[2], t[3]))  # x,y,z,idx
    i = 0
    while i + 1 < len(global_leftovers):
        pairs.append((global_leftovers[i][3], global_leftovers[i+1][3]))
        i += 2

    # Verify perfect pairing
    used = []
    for a, b in pairs:
        used.append(a); used.append(b)
    used.sort()
    assert used == list(range(1, n+1))
    return pairs

def solve_all():
    n, pts = read_input()
    res = solve_case(n, pts)
    out = sys.stdout
    for a, b in res:
        out.write(f"{a} {b}\n")

def _test_final():
    # Minimal
    data = "2\n0 0 0\n1 1 1\n"
    n, pts = read_input(data)
    ans = solve_case(n, pts)
    assert len(ans) == 1 and sorted(ans[0]) == [1,2]
    # Pair inside same (x,y)
    data2 = "4\n0 0 0\n0 0 2\n0 1 1\n1 2 3\n"
    n2, pts2 = read_input(data2)
    ans2 = solve_case(n2, pts2)
    used2 = sorted([i for p in ans2 for i in p])
    assert used2 == [1,2,3,4]
    # More complex
    data3 = "6\n0 0 0\n0 0 1\n0 1 0\n0 1 2\n1 0 0\n2 0 0\n"
    n3, pts3 = read_input(data3)
    ans3 = solve_case(n3, pts3)
    used3 = sorted([i for p in ans3 for i in p])
    assert used3 == [1,2,3,4,5,6]

if __name__ == "__main__":
    if sys.stdin.isatty():
        _test_final()
    else:
        solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts cover minimal, intra-bucket, and multi-stage scenarios.}
\RESULT{Print any valid sequence of $\tfrac{n}{2}$ pairs; order does not matter as long as each index appears once and boxes are empty when the pair is removed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests validate perfect pairing and coverage of staged pairing. Random fuzzing can be done by generating small $n$ and checking the baseline against the optimal solver.}
\LINE{CROSS-CHECKS}{For $n \le 12$, compare outputs from the brute-force simulator and the optimal solver by verifying that both produce perfect pairings (order can differ).}
\LINE{EDGE-CASE GENERATOR}{Generates clustered points sharing $(x,y)$, mixed slices sharing $x$, and completely distinct coordinates to exercise all three stages.}
\begin{minted}{python}
import random
from typing import List, Tuple

def gen_points(n: int, seed: int = 0) -> List[Tuple[int,int,int,int]]:
    random.seed(seed)
    pts = []
    for i in range(1, n+1):
        # Mix clusters and distincts
        if i % 3 == 0:
            x = random.randint(-2, 2)
            y = random.randint(-2, 2)
            z = random.randint(-10, 10)
        elif i % 3 == 1:
            x = random.randint(-5, 5)
            y = random.randint(-5, 5)
            z = random.randint(-5, 5)
        else:
            x = random.randint(-1, 1)
            y = random.randint(-10, 10)
            z = random.randint(-1, 1)
        pts.append((x, y, z, i))
    # ensure distinctness (very likely already); adjust if duplicates appear
    seen = set()
    for k in range(len(pts)):
        while (pts[k][0], pts[k][1], pts[k][2]) in seen:
            x, y, z, i = pts[k]
            z += 1
            pts[k] = (x, y, z, i)
        seen.add((pts[k][0], pts[k][1], pts[k][2]))
    return pts

def reference_solver(pts: List[Tuple[int,int,int,int]]) -> List[Tuple[int,int]]:
    # optimal solve from Approach C (inline)
    from collections import defaultdict
    n = len(pts)
    by_xy = defaultdict(list)
    for x, y, z, idx in pts:
        by_xy[(x, y)].append((x, y, z, idx))
    pairs = []
    leftovers_by_x = defaultdict(list)
    for (x, y), arr in by_xy.items():
        arr.sort(key=lambda t: t[2])
        i = 0
        while i + 1 < len(arr):
            pairs.append((arr[i][3], arr[i+1][3]))
            i += 2
        if i < len(arr):
            leftovers_by_x[x].append(arr[i])
    global_leftovers = []
    for x, arr in leftovers_by_x.items():
        arr.sort(key=lambda t: (t[1], t[2], t[3]))
        i = 0
        while i + 1 < len(arr):
            pairs.append((arr[i][3], arr[i+1][3]))
            i += 2
        if i < len(arr):
            global_leftovers.append(arr[i])
    global_leftovers.sort(key=lambda t: (t[0], t[1], t[2], t[3]))
    i = 0
    while i + 1 < len(global_leftovers):
        pairs.append((global_leftovers[i][3], global_leftovers[i+1][3]))
        i += 2
    used = sorted([u for p in pairs for u in p])
    assert used == list(range(1, len(pts)+1))
    return pairs

def small_cross_check():
    for n in range(2, 14, 2):
        pts = gen_points(n, seed=n)
        pairs = reference_solver(pts)
        used = sorted([u for p in pairs for u in p])
        assert used == list(range(1, n+1))

if __name__ == "__main__":
    small_cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple
from collections import defaultdict

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    n = int(next(it))
    pts = []
    for i in range(1, n+1):
        x = int(next(it)); y = int(next(it)); z = int(next(it))
        pts.append((x, y, z, i))
    return n, pts

def solve_case(n: int, pts: List[Tuple[int,int,int,int]]) -> List[Tuple[int,int]]:
    by_xy = defaultdict(list)
    for x, y, z, idx in pts:
        by_xy[(x, y)].append((x, y, z, idx))
    pairs: List[Tuple[int,int]] = []
    leftovers_by_x = defaultdict(list)

    for (x, y), arr in by_xy.items():
        arr.sort(key=lambda t: t[2])
        i = 0
        while i + 1 < len(arr):
            pairs.append((arr[i][3], arr[i+1][3]))
            i += 2
        if i < len(arr):
            leftovers_by_x[x].append(arr[i])

    global_leftovers = []
    for x, arr in leftovers_by_x.items():
        arr.sort(key=lambda t: (t[1], t[2], t[3]))
        i = 0
        while i + 1 < len(arr):
            pairs.append((arr[i][3], arr[i+1][3]))
            i += 2
        if i < len(arr):
            global_leftovers.append(arr[i])

    global_leftovers.sort(key=lambda t: (t[0], t[1], t[2], t[3]))
    i = 0
    while i + 1 < len(global_leftovers):
        pairs.append((global_leftovers[i][3], global_leftovers[i+1][3]))
        i += 2

    used = []
    for a, b in pairs:
        used.append(a); used.append(b)
    used.sort()
    assert used == list(range(1, n+1))
    return pairs

def main():
    n, pts = read_input()
    res = solve_case(n, pts)
    out = sys.stdout
    for a, b in res:
        out.write(f"{a} {b}\n")

def _tests():
    data = "2\n0 0 0\n1 1 1\n"
    n, pts = read_input(data)
    ans = solve_case(n, pts)
    assert len(ans) == 1 and sorted(ans[0]) == [1,2]
    data2 = "6\n0 0 0\n0 0 2\n0 1 1\n0 1 3\n2 5 7\n9 9 9\n"
    n2, pts2 = read_input(data2)
    ans2 = solve_case(n2, pts2)
    used2 = sorted([u for p in ans2 for u in p])
    assert used2 == [1,2,3,4,5,6]

if __name__ == "__main__":
    if sys.stdin.isatty():
        _tests()
    else:
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Greedily pair points in three stages: by $(x,y)$, then by $x$, then globally by $x$.}
\WHY{Classic CF geometry-greedy: recognizes axis-aligned independence and uses hierarchical pairing to ensure empty bounding boxes.}
\CHECKLIST{
- Sort and pair within identical $(x,y)$ by $z$.
- Track single leftovers per $(x,y)$ into buckets keyed by $x$.
- Sort and pair leftovers within each $x$ by $y$.
- Collect and pair remaining leftovers globally by $x$.
- Output pairs and verify coverage of all indices.}
\EDGECASES{
- Multiple points share $(x,y)$ with odd count.
- Many distinct $y$ within an $x$-slice leading to a leftover.
- Negative coordinates and large magnitudes.
- Degenerate boxes (equal coordinates in one or more axes).
- Already sorted or reverse-sorted inputs.
- Minimal $n=2$.}
\PITFALLS{
- Forgetting to carry only one leftover upward from a bucket.
- Unstable or inconsistent tie-breaking causing non-determinism in tests.
- Not verifying that every index appears exactly once.
- Mishandling sorting keys (e.g., sorting by wrong axis).
- Integer parsing or indexing off-by-one.
- Printing extra spaces/lines beyond required format.}
\FAILMODES{Baseline $O(n^4)$ brute force times out for large $n$; the staged $O(n\log n)$ solution remains fast. The greedy remains valid for all inputs due to the staged emptiness property.}
\ELI{Think of slicing the space: first collapse along $z$ within each $(x,y)$ line, then along $y$ within each $x$-plane, then finally along $x$ across space. At each step, you only pair neighbors so nothing remains in between.}
\NotePages{3}

\end{document}