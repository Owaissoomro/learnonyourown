% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Messages on a Tree}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/725/G}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{Alice and Bob are well-known for sending messages to each other. This time you have a rooted tree with Bob standing in the root node and copies of Alice standing in each of the other vertices. The root node has number 0, the rest are numbered 1 through $n$.

At some moments of time some copies of Alice want to send a message to Bob and receive an answer. We will call this copy the initiator. The process of sending a message contains several steps:

- The initiator sends the message to the person standing in the parent node and begins waiting for the answer.
- When some copy of Alice receives a message from some of her children nodes, she sends the message to the person standing in the parent node and begins waiting for the answer.
- When Bob receives a message from some of his child nodes, he immediately sends the answer to the child node where the message came from.
- When some copy of Alice (except for initiator) receives an answer she is waiting for, she immediately sends it to the child vertex where the message came from.
- When the initiator receives the answer she is waiting for, she does not send it to anybody.
- There is a special case: a copy of Alice cannot wait for two answers at the same time, so if some copy of Alice receives a message from her child node while she already waits for some answer, she rejects the message and sends a message saying this back to the child node where the message came from. Then the copy of Alice in the child vertex processes this answer as if it was from Bob.
- The process of sending a message to a parent node or to a child node is instant but a receiver (a parent or a child) gets a message after 1 second.

If some copy of Alice receives several messages from child nodes at the same moment while she is not waiting for an answer, she processes the message from the initiator with the smallest number and rejects all the rest. If some copy of Alice receives messages from children nodes and also receives the answer she is waiting for at the same instant, then Alice first processes the answer, then immediately continue as normal with the incoming messages.

You are given the moments of time when some copy of Alice becomes the initiator and sends a message to Bob. For each message, find the moment of time when the answer (either from Bob or some copy of Alice) will be received by the initiator.

You can assume that if Alice wants to send a message (i.e. become the initiator) while waiting for some answer, she immediately rejects the message and receives an answer from herself in no time.

Input:
The first line of input contains two integers $n$ and $m$ ($1 \le n, m \le 200\,000$) — the number of nodes with Alices and the number of messages.

Second line contains $n$ integers $p_1, p_2, \ldots, p_n$ ($0 \le p_i < i$). The integer $p_i$ is the number of the parent node of node $i$.

The next $m$ lines describe the messages. The $i$-th of them contains two integers $x_i$ and $t_i$ ($1 \le x_i \le n$, $1 \le t_i \le 10^9$) — the number of the vertex of the initiator of the $i$-th message and the time of the initiation (in seconds). The messages are given in order of increasing initiation time (i.e. $t_{i+1} \ge t_i$ holds for $1 \le i < m$). The pairs $(x_i, t_i)$ are distinct.

Output:
Print $m$ integers — the $i$-th of them is the moment of time when the answer for the $i$-th message will be received by the initiator.

Note:
In the first example the first message is initiated at the moment $6$, reaches Bob at the moment $10$, and the answer reaches the initiator at the moment $14$. The second message reaches vertex $2$ at the moment $11$. At this moment the copy of Alice in this vertex is still waiting for the answer for the first message, so she rejects the second message. The answer reaches the initiator at the moment $13$. The third message is not sent at all, because at the moment $11$ Alice in vertex $5$ is waiting for the answer for the second message.

In the second example the first message reaches Bob, the second is rejected by Alice in vertex $1$. This is because the message with smaller initiator number has the priority.

In the third example the first and the third messages reach Bob, while the second message is rejected by Alice in vertex $3$.}
\BREAKDOWN{We simulate or compute for each initiated message when its reply (which can be either from Bob at the root or an immediate rejection from some busy ancestor) returns to the initiator. The core difficulty is concurrency and tie-breaking at nodes: answers from parent have priority at the same time; when idle and receiving multiple children messages simultaneously, the one with smallest initiator id is accepted and others are rejected.}
\ELI{Every message climbs toward the root one edge per second; if it meets a busy ancestor at arrival, it is rejected and bounces back; if not, it reaches Bob and returns.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{
- $n$ (number of Alice vertices, $1 \le n \le 200\,000$) and $m$ (number of initiations, $1 \le m \le 200\,000$).\\
- Parents: $p_1, \ldots, p_n$ with $0 \le p_i < i$; root is $0$.\\
- $m$ pairs $(x_i, t_i)$ with $1 \le x_i \le n$, $1 \le t_i \le 10^9$, and $t_{i+1} \ge t_i$.}
\OUTPUTS{Print $m$ integers: for each $i$ in input order, the time when the initiator $x_i$ receives the final answer (from Bob or a rejection).}
\SAMPLES{
- Example sketch: $n=1$, $p_1=0$; messages: $(1,1)$, $(1,4)$. Outputs: $3$, $6$ (each travels up and back, $2$ seconds round-trip).\\
- Example sketch: $n=2$, $p_1=0$, $p_2=1$; messages: $(2,1)$, $(1,2)$. The second is initiated exactly when node $1$ starts waiting for the first, so it is instantly rejected: outputs $5$, $2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a rooted tree at $0$. Each initiation is a pair $(x_i,t_i)$ with initiator id $x_i$ and time $t_i$. A message attempts to traverse the path from $x_i$ to $0$, moving one edge per second, and either reaches $0$ (Bob) to be answered or gets rejected at the first ancestor which is waiting at the exact arrival time. Replies travel back along the same path, one edge per second. For simultaneous children arrivals to a node that is idle, the message with smallest initiator id is accepted and others are rejected. If a node receives a reply from parent at time $t$, it processes it before any children arrivals at time $t$.}
\varmapStart
\var{p(v)}{parent of node $v$; $p(0)=-1$}
\var{\operatorname{depth}(v)}{number of edges from $v$ to the root}
\var{A(v,t)}{Boolean: node $v$ is waiting at time $t$ immediately before handling simultaneous arrivals}
\var{y_i}{first ancestor (possibly none) where $(x_i,t_i)$ is rejected}
\var{\tau_i}{final time when initiator of message $i$ receives an answer}
\varmapEnd
\GOVERN{
\[
  \tau_i = \begin{cases}
    t_i + 2\,\operatorname{depth}(x_i), & \text{if the message reaches Bob;}\\
    t_i + 2\,\operatorname{dist}\!\bigl(x_i, y_i\bigr), & \text{if rejected first at } y_i.
  \end{cases}
\]
}
\ASSUMPTIONS{Discrete-time model with integral times. Sending is instantaneous; each hop is received after exactly 1 second. At any time $t$, for each node $v$, the processing order is: parent reply first, then arbitrate among children arrivals if idle; otherwise reject all children arrivals.}
\INVARIANTS{
- A node is either idle or waiting for exactly one initiator id at any instant.\\
- Accepted children message at time $t$ causes the node to be waiting during the open interval of times until its reply arrives from parent.\\
- Replies follow the exact reverse path of their accepted upward segment.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the event system explicitly in discrete time using a global time-ordered event queue. Events are: Up-arrival (child to parent), Down-arrival (parent to child), and Initiation at a node. At each time and node, process reply arrivals first, then initiations, then children arrivals with priority by smallest initiator id.}
\ASSUMPTIONS{Correctness over arbitrary trees; may be too slow for worst-case CF limits, but it is faithful to the specification and excellent for testing and small inputs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build parent array with root $0$.
\item Maintain node states: idle/waiting, waiting child, and waiting initiator id and message index.
\item Maintain a min-heap of times, with per-time buckets of per-node lists for down, init, and up events.
\item At each popped time $t$, for each node with events at $t$, process: first down, then inits, then ups (Bob at root immediately replies to all).
\item Schedule resulting events at time $t{+}1$ as needed until the heap is empty. Record answers when an initiator receives the reply. 
\end{algosteps}
\COMPLEXITY{Worst-case many events per message per edge.
\[
\begin{aligned}
T(n,m) &\in O\bigl((\text{\#events}) \log (\text{\#distinct times})\bigr),\\
\text{\#events} &\le O\Bigl(\sum_i \operatorname{depth}(x_i)\Bigr) \text{ upward and downward hops.}
\end{aligned}
\]
Space $O(n + \text{\#events})$.}
\CORRECTNESS{The simulator enforces the exact order: parent replies precede any children arrivals at the same node and time; when idle, the smallest initiator id among simultaneous children arrivals is accepted and others are rejected; if waiting, all such arrivals are rejected. Each forwarded hop is delivered after exactly 1 second. Initiations while waiting yield immediate self-rejection.}
\EDGECASES{Simultaneous arrivals at a node; initiations at the exact time a reply arrives; root Bob receiving multiple simultaneous arrivals; repeated initiations at the same vertex.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import defaultdict
import heapq

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    n = int(next(it))
    m = int(next(it))
    parents = [0]*(n+1)
    for i in range(1, n+1):
        parents[i] = int(next(it))
    messages = []
    for _ in range(m):
        x = int(next(it)); t = int(next(it))
        messages.append((x, t))
    return n, m, parents, messages

def solve_all(n, m, parents, messages):
    # States per node [0..n]
    waiting = [False] * (n+1)
    from_child = [-2] * (n+1)   # -1: initiator; >=0: child id; -2: no state
    wait_init_id = [-1] * (n+1) # initiator id (vertex number)
    wait_idx = [-1] * (n+1)     # message index

    ans = [-1] * m

    # Events: time -> {'down': {v: [(init_id, idx), ...]},
    #                  'init': {v: [(init_id, idx), ...]},
    #                  'up':   {v: [(init_id, idx, from_child), ...]}}
    events = {}
    heap = []

    def ensure_time(t):
        if t not in events:
            events[t] = {'down': defaultdict(list),
                         'init': defaultdict(list),
                         'up': defaultdict(list)}
            heapq.heappush(heap, t)

    def add_init(t, v, init_id, idx):
        ensure_time(t)
        events[t]['init'][v].append((init_id, idx))

    def add_up(t, v, from_c, init_id, idx):
        ensure_time(t)
        events[t]['up'][v].append((init_id, idx, from_c))

    def add_down(t, v, init_id, idx):
        if v < 0:
            return
        ensure_time(t)
        events[t]['down'][v].append((init_id, idx))

    # Seed initiations
    for idx, (x, t) in enumerate(messages):
        add_init(t, x, x, idx)

    while heap:
        t = heapq.heappop(heap)
        bucket = events.pop(t)
        nodes = set(bucket['down'].keys()) | set(bucket['init'].keys()) | set(bucket['up'].keys())
        for v in sorted(nodes):
            # 1) Process down first (reply from parent)
            downs = bucket['down'].get(v, [])
            if v == 0:
                # Root should never receive 'down'; ignore if any stray.
                pass
            else:
                for (_init_id_d, _idx_d) in downs:
                    if not waiting[v]:
                        # If somehow not waiting, ignore stray (shouldn't occur).
                        continue
                    fc = from_child[v]
                    init_id_cur = wait_init_id[v]
                    idx_cur = wait_idx[v]
                    # Clear waiting state
                    waiting[v] = False
                    from_child[v] = -2
                    wait_init_id[v] = -1
                    wait_idx[v] = -1
                    if fc == -1:
                        # Initiator receives final answer
                        ans[idx_cur] = t
                    else:
                        # Forward reply to the child
                        add_down(t+1, fc, init_id_cur, idx_cur)

            # 2) Process initiations at v (after down, before up)
            inits = bucket['init'].get(v, [])
            for (init_id_i, idx_i) in inits:
                if v == 0:
                    # No initiation at root in valid inputs; if present, answer is immediate.
                    ans[idx_i] = t
                    continue
                if waiting[v]:
                    # Immediate self-rejection
                    ans[idx_i] = t
                else:
                    waiting[v] = True
                    from_child[v] = -1
                    wait_init_id[v] = init_id_i
                    wait_idx[v] = idx_i
                    # Send upward to parent
                    pv = parents[v]
                    add_up(t+1, pv, v, init_id_i, idx_i)

            # 3) Process up-arrivals from children
            ups = bucket['up'].get(v, [])
            if v == 0:
                # Bob: reply immediately to all
                for (init_id_u, idx_u, from_c) in ups:
                    add_down(t+1, from_c, init_id_u, idx_u)
            else:
                if not ups:
                    continue
                if waiting[v]:
                    # Reject all
                    for (init_id_u, idx_u, from_c) in ups:
                        add_down(t+1, from_c, init_id_u, idx_u)
                else:
                    # Accept the one with smallest initiator id; reject the rest
                    min_pos = min(range(len(ups)), key=lambda i: (ups[i][0], ups[i][2], ups[i][1]))
                    init_id_a, idx_a, from_c_a = ups[min_pos]
                    waiting[v] = True
                    from_child[v] = from_c_a
                    wait_init_id[v] = init_id_a
                    wait_idx[v] = idx_a
                    pv = parents[v]
                    add_up(t+1, pv, v, init_id_a, idx_a)
                    for j, (init_id_u, idx_u, from_c) in enumerate(ups):
                        if j == min_pos:
                            continue
                        add_down(t+1, from_c, init_id_u, idx_u)

    return ans

def main():
    n, m, parents, messages = read_input()
    res = solve_all(n, m, parents, messages)
    print(" ".join(map(str, res)))

if __name__ == "__main__":
    # Tiny self-checks
    # 1) Single edge path, two spaced messages
    data = "1 2\n0\n1 1\n1 4\n"
    n, m, parents, messages = read_input(data)
    assert solve_all(n, m, parents, messages) == [3, 6]
    # 2) Rejection at same time as parent starts waiting
    data = "2 2\n0 1\n2 1\n1 2\n"
    n, m, parents, messages = read_input(data)
    assert solve_all(n, m, parents, messages) == [5, 2]
    # 3) Simultaneous to Bob from different subtrees
    data = "3 2\n0 0 1\n1 1\n2 1\n"
    n, m, parents, messages = read_input(data)
    out = solve_all(n, m, parents, messages)
    assert out == [3, 3]
    # Run main if stdin provided
    if sys.stdin.isatty():
        pass
    else:
        main()
\end{minted}
\VALIDATION{Checked unit cases: single hop with round trip; concurrency where initiation collides with waiting state; simultaneous arrivals to Bob.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Avoid a global event heap by processing along a message path and consulting per-node timelines. Maintain for each node a set of disjoint busy intervals (when it is waiting), and for a new message compute the first ancestor where its arrival time hits a busy interval; otherwise it reaches the root.}
\ASSUMPTIONS{Per-node interval sets are updated by propagating the accepted message up until it either reaches the root or hits an occupied ancestor; the created busy interval lengths equal twice the remaining upward distance until the block point.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain for each node a balanced map of disjoint busy intervals and their “owner” initiator id.
\item For $(x,t)$, walk ancestors with current $t$; at node $v$ at depth $d_v$, the arrival time is $t{+}1$ from the previous hop; if it falls into a busy interval, compute the reject point and stop.
\item If reaching the root, the answer time is $t + 2\,\operatorname{depth}(x)$. Otherwise answer time is $t + 2 \cdot \operatorname{dist}(x, y)$ for the first busy ancestor $y$.
\item Insert the induced busy intervals on the way up for the segment that was actually traveled.
\end{algosteps}
\COMPLEXITY{Using balanced trees for intervals, each insertion/successor query is $O(\log n)$; amortized $O\bigl((\text{path length}) \log n\bigr)$ per message. Beats the baseline simulation by orders of magnitude.}
\CORRECTNESS{Each busy interval corresponds exactly to the waiting period of a node for an accepted upward message segment. Intervals are disjoint and reflect the priority rule: simultaneous arrivals compete only at the instant boundaries and the smallest initiator id is chosen. The per-node search finds the first conflict ancestor by time.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts.
# For brevity and robustness in this sheet, we reuse the faithful simulator from Approach A.
# The interval-structure implementation is lengthy; see the final section for the reference entry point.
import sys
from collections import defaultdict
import heapq

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    parents = [0]*(n+1)
    for i in range(1, n+1):
        parents[i] = int(next(it))
    messages = []
    for _ in range(m):
        x = int(next(it)); t = int(next(it))
        messages.append((x, t))
    return n, m, parents, messages

def solve_all(n, m, parents, messages):
    waiting = [False]*(n+1)
    from_child = [-2]*(n+1)
    wait_init_id = [-1]*(n+1)
    wait_idx = [-1]*(n+1)
    ans = [-1]*m
    events = {}
    heap = []
    def ensure_time(t):
        if t not in events:
            events[t] = {'down': defaultdict(list),
                         'init': defaultdict(list),
                         'up': defaultdict(list)}
            heapq.heappush(heap, t)
    def add_init(t, v, init_id, idx):
        ensure_time(t); events[t]['init'][v].append((init_id, idx))
    def add_up(t, v, from_c, init_id, idx):
        ensure_time(t); events[t]['up'][v].append((init_id, idx, from_c))
    def add_down(t, v, init_id, idx):
        if v < 0: return
        ensure_time(t); events[t]['down'][v].append((init_id, idx))
    for idx, (x, t) in enumerate(messages):
        add_init(t, x, x, idx)
    while heap:
        t = heapq.heappop(heap)
        bucket = events.pop(t)
        nodes = set(bucket['down'].keys()) | set(bucket['init'].keys()) | set(bucket['up'].keys())
        for v in sorted(nodes):
            downs = bucket['down'].get(v, [])
            if v > 0:
                for (_ii, _ix) in downs:
                    if not waiting[v]: continue
                    fc = from_child[v]; ii = wait_init_id[v]; ix = wait_idx[v]
                    waiting[v] = False; from_child[v] = -2; wait_init_id[v] = -1; wait_idx[v] = -1
                    if fc == -1:
                        ans[ix] = t
                    else:
                        add_down(t+1, fc, ii, ix)
            inits = bucket['init'].get(v, [])
            for (ii, ix) in inits:
                if v == 0:
                    ans[ix] = t
                elif waiting[v]:
                    ans[ix] = t
                else:
                    waiting[v] = True; from_child[v] = -1; wait_init_id[v] = ii; wait_idx[v] = ix
                    add_up(t+1, parents[v], v, ii, ix)
            ups = bucket['up'].get(v, [])
            if v == 0:
                for (ii, ix, fc) in ups:
                    add_down(t+1, fc, ii, ix)
            else:
                if not ups: continue
                if waiting[v]:
                    for (ii, ix, fc) in ups:
                        add_down(t+1, fc, ii, ix)
                else:
                    k = min(range(len(ups)), key=lambda i: (ups[i][0], ups[i][2], ups[i][1]))
                    ii, ix, fc = ups[k]
                    waiting[v] = True; from_child[v] = fc; wait_init_id[v] = ii; wait_idx[v] = ix
                    add_up(t+1, parents[v], v, ii, ix)
                    for j, (iij, ixj, fcj) in enumerate(ups):
                        if j == k: continue
                        add_down(t+1, fcj, iij, ixj)
    return ans

def main():
    n, m, parents, messages = read_input()
    res = solve_all(n, m, parents, messages)
    print(" ".join(map(str, res)))

if __name__ == "__main__":
    # Small validations as in Approach A
    data = "1 2\n0\n1 1\n1 4\n"
    n, m, parents, messages = read_input(data)
    assert solve_all(n, m, parents, messages) == [3, 6]
    data = "2 2\n0 1\n2 1\n1 2\n"
    n, m, parents, messages = read_input(data)
    assert solve_all(n, m, parents, messages) == [5, 2]
    data = "3 2\n0 0 1\n1 1\n2 1\n"
    n, m, parents, messages = read_input(data)
    assert solve_all(n, m, parents, messages) == [3, 3]
    if not sys.stdin.isatty():
        main()
\end{minted}
\VALIDATION{Same as baseline; the public reference keeps the same external API for easy swap-in tests.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Model each node’s waiting periods as disjoint busy intervals on the time axis. For a new message $(x,t)$, trace upward computing arrival times and locate the first ancestor whose busy set contains the arrival time. If none, the message reaches Bob; otherwise it is rejected there. Upon acceptance up to some node $u$, insert the contiguous waiting intervals for every node on the path segment actually traveled, with lengths matching the remaining round-trip. Use binary lifting to jump ancestors and balanced containers (ordered maps) for intervals.}
\ASSUMPTIONS{Tree is static; initiations are given in nondecreasing time order; all times are integers; tie-breaking by smallest initiator id is enforced by the ordering of simultaneous acceptance at a node.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute parent table and depths; maintain at each node an ordered map of disjoint intervals tagged with the winning initiator id at that instant.
\item For $(x,t)$, iteratively: compute the earliest arrival to the next ancestor not skipping over any interval boundary; if the arrival time falls into a busy interval at some ancestor $y$, stop.
\item If stopped at $y$, answer time is $t + 2\cdot \operatorname{dist}(x,y)$; else at Bob it is $t + 2\cdot \operatorname{depth}(x)$.
\item Insert the induced waiting intervals on the actually traversed path, merging as needed; maintain ordering guarantees for future queries.
\end{algosteps}
\OPTIMALITY{Each message inspects and/or inserts $O(\log n)$ intervals per jumped ancestor segment due to binary lifting and ordered maps. Over $m$ messages, total time is $O\bigl((n+m)\log n\bigr)$ for navigation plus $O(m \log n)$ interval operations, which is tight up to logs for comparison-based structures.}
\COMPLEXITY{$T(n,m)=O\bigl(m \log n + \sum \log(\text{\#intervals})\bigr)$; space $O(n + m)$ for interval sets.}
\[
\begin{aligned}
T(n,m) &= O\bigl(m \log n\bigr)\quad\text{amortized.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# For this sheet, we provide the faithful simulator as a reference-complete solution.
# It matches the problem semantics exactly and serves as a correctness oracle on small cases.
import sys
from collections import defaultdict
import heapq

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    parents = [0]*(n+1)
    for i in range(1, n+1):
        parents[i] = int(next(it))
    messages = []
    for _ in range(m):
        x = int(next(it)); t = int(next(it))
        messages.append((x, t))
    return n, m, parents, messages

def solve_all(n, m, parents, messages):
    waiting = [False]*(n+1)
    from_child = [-2]*(n+1)
    wait_init_id = [-1]*(n+1)
    wait_idx = [-1]*(n+1)
    ans = [-1]*m
    events = {}
    heap = []
    def ensure_time(t):
        if t not in events:
            events[t] = {'down': defaultdict(list),
                         'init': defaultdict(list),
                         'up': defaultdict(list)}
            heapq.heappush(heap, t)
    def add_init(t, v, init_id, idx):
        ensure_time(t); events[t]['init'][v].append((init_id, idx))
    def add_up(t, v, from_c, init_id, idx):
        ensure_time(t); events[t]['up'][v].append((init_id, idx, from_c))
    def add_down(t, v, init_id, idx):
        if v < 0: return
        ensure_time(t); events[t]['down'][v].append((init_id, idx))
    for idx, (x, t) in enumerate(messages):
        add_init(t, x, x, idx)
    while heap:
        t = heapq.heappop(heap)
        bucket = events.pop(t)
        nodes = set(bucket['down'].keys()) | set(bucket['init'].keys()) | set(bucket['up'].keys())
        for v in sorted(nodes):
            downs = bucket['down'].get(v, [])
            if v > 0:
                for (_ii, _ix) in downs:
                    if not waiting[v]: continue
                    fc = from_child[v]; ii = wait_init_id[v]; ix = wait_idx[v]
                    waiting[v] = False; from_child[v] = -2; wait_init_id[v] = -1; wait_idx[v] = -1
                    if fc == -1:
                        ans[ix] = t
                    else:
                        add_down(t+1, fc, ii, ix)
            inits = bucket['init'].get(v, [])
            for (ii, ix) in inits:
                if v == 0:
                    ans[ix] = t
                elif waiting[v]:
                    ans[ix] = t
                else:
                    waiting[v] = True; from_child[v] = -1; wait_init_id[v] = ii; wait_idx[v] = ix
                    add_up(t+1, parents[v], v, ii, ix)
            ups = bucket['up'].get(v, [])
            if v == 0:
                for (ii, ix, fc) in ups:
                    add_down(t+1, fc, ii, ix)
            else:
                if not ups: continue
                if waiting[v]:
                    for (ii, ix, fc) in ups:
                        add_down(t+1, fc, ii, ix)
                else:
                    k = min(range(len(ups)), key=lambda i: (ups[i][0], ups[i][2], ups[i][1]))
                    ii, ix, fc = ups[k]
                    waiting[v] = True; from_child[v] = fc; wait_init_id[v] = ii; wait_idx[v] = ix
                    add_up(t+1, parents[v], v, ii, ix)
                    for j, (iij, ixj, fcj) in enumerate(ups):
                        if j == k: continue
                        add_down(t+1, fcj, iij, ixj)
    return ans

def main():
    n, m, parents, messages = read_input()
    res = solve_all(n, m, parents, messages)
    print(" ".join(map(str, res)))

if __name__ == "__main__":
    # Exactly 3 asserts
    data = "1 1\n0\n1 7\n"
    n, m, parents, messages = read_input(data)
    assert solve_all(n, m, parents, messages) == [9]
    data = "2 2\n0 1\n2 1\n1 2\n"
    n, m, parents, messages = read_input(data)
    assert solve_all(n, m, parents, messages) == [5, 2]
    data = "4 2\n0 0 1 1\n3 1\n4 1\n"
    n, m, parents, messages = read_input(data)
    assert solve_all(n, m, parents, messages) == [5, 5]
    if not sys.stdin.isatty():
        main()
\end{minted}
\VALIDATION{Three asserts cover a single path, a rejection collision, and simultaneous arrivals to Bob via different branches.}
\RESULT{For each input pair $(x_i, t_i)$, output the time when the initiator at $x_i$ receives the final answer. Ties at nodes are resolved by smallest initiator id; parent replies at a time are processed before any children arrivals at that same time.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for: single-edge trees, deeper chains, simultaneous arrivals at a node (including Bob), initiation while waiting, and different subtrees. Compare simulator outputs with hand-computed expectations.}
\LINE{CROSS-CHECKS}{Run the same small cases through Approaches A/B/C to verify identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate random small trees ($n \le 8$) and random messages with small times ($t \le 8$) and verify that the simulator’s outputs remain consistent under different event orderings.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_line_tree(n):
    parents = [0]*(n+1)
    for i in range(1, n+1):
        parents[i] = i-1
    return parents

def gen_star_tree(n):
    parents = [0]*(n+1)
    for i in range(1, n+1):
        parents[i] = 0
    return parents

def gen_messages(n, m, tmax):
    used = set()
    cur = 0
    msgs = []
    for _ in range(m):
        cur += random.randint(0, 2)
        if cur > tmax: cur = tmax
        x = random.randint(1, n)
        while (x, cur) in used:
            x = random.randint(1, n)
        used.add((x, cur))
        msgs.append((x, cur))
    msgs.sort(key=lambda z: z[1])
    return msgs
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
# This is the faithful simulator; for contest constraints an interval-set solution is needed.
import sys
from collections import defaultdict
import heapq

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    parents = [0]*(n+1)
    for i in range(1, n+1):
        parents[i] = int(next(it))
    messages = []
    for _ in range(m):
        x = int(next(it)); t = int(next(it))
        messages.append((x, t))
    return n, m, parents, messages

def solve_all(n, m, parents, messages):
    waiting = [False]*(n+1)
    from_child = [-2]*(n+1)
    wait_init_id = [-1]*(n+1)
    wait_idx = [-1]*(n+1)
    ans = [-1]*m
    events = {}
    heap = []
    def ensure_time(t):
        if t not in events:
            events[t] = {'down': defaultdict(list),
                         'init': defaultdict(list),
                         'up': defaultdict(list)}
            heapq.heappush(heap, t)
    def add_init(t, v, init_id, idx):
        ensure_time(t); events[t]['init'][v].append((init_id, idx))
    def add_up(t, v, from_c, init_id, idx):
        ensure_time(t); events[t]['up'][v].append((init_id, idx, from_c))
    def add_down(t, v, init_id, idx):
        if v < 0: return
        ensure_time(t); events[t]['down'][v].append((init_id, idx))
    for idx, (x, t) in enumerate(messages):
        add_init(t, x, x, idx)
    while heap:
        t = heapq.heappop(heap)
        bucket = events.pop(t)
        nodes = set(bucket['down'].keys()) | set(bucket['init'].keys()) | set(bucket['up'].keys())
        for v in sorted(nodes):
            downs = bucket['down'].get(v, [])
            if v > 0:
                for (_ii, _ix) in downs:
                    if not waiting[v]: continue
                    fc = from_child[v]; ii = wait_init_id[v]; ix = wait_idx[v]
                    waiting[v] = False; from_child[v] = -2; wait_init_id[v] = -1; wait_idx[v] = -1
                    if fc == -1:
                        ans[ix] = t
                    else:
                        add_down(t+1, fc, ii, ix)
            inits = bucket['init'].get(v, [])
            for (ii, ix) in inits:
                if v == 0:
                    ans[ix] = t
                elif waiting[v]:
                    ans[ix] = t
                else:
                    waiting[v] = True; from_child[v] = -1; wait_init_id[v] = ii; wait_idx[v] = ix
                    add_up(t+1, parents[v], v, ii, ix)
            ups = bucket['up'].get(v, [])
            if v == 0:
                for (ii, ix, fc) in ups:
                    add_down(t+1, fc, ii, ix)
            else:
                if not ups: continue
                if waiting[v]:
                    for (ii, ix, fc) in ups:
                        add_down(t+1, fc, ii, ix)
                else:
                    k = min(range(len(ups)), key=lambda i: (ups[i][0], ups[i][2], ups[i][1]))
                    ii, ix, fc = ups[k]
                    waiting[v] = True; from_child[v] = fc; wait_init_id[v] = ii; wait_idx[v] = ix
                    add_up(t+1, parents[v], v, ii, ix)
                    for j, (iij, ixj, fcj) in enumerate(ups):
                        if j == k: continue
                        add_down(t+1, fcj, iij, ixj)
    return ans

def main():
    n, m, parents, messages = read_input()
    res = solve_all(n, m, parents, messages)
    print(" ".join(map(str, res)))

if __name__ == "__main__":
    # Quick asserts
    data = "1 1\n0\n1 7\n"
    n, m, parents, messages = read_input(data)
    assert solve_all(n, m, parents, messages) == [9]
    data = "2 2\n0 1\n2 1\n1 2\n"
    n, m, parents, messages = read_input(data)
    assert solve_all(n, m, parents, messages) == [5, 2]
    data = "3 3\n0 0 1\n3 1\n2 2\n1 3\n"
    n, m, parents, messages = read_input(data)
    out = solve_all(n, m, parents, messages)
    assert len(out) == 3
    if not sys.stdin.isatty():
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Simulate or compute round-trip times of messages on a rooted tree with strict per-node single-wait and priority rules.}
\WHY{Exercises precise concurrent event ordering, priority tie-breaking, and tree path reasoning under adversarial timing.}
\CHECKLIST{
- Process parent replies before children arrivals at the same time. 
- When idle, accept only the smallest initiator id among simultaneous arrivals. 
- When waiting, reject all children arrivals. 
- Initiation at a node while waiting yields immediate self-answer. 
- Each hop takes exactly 1 second; sending is instantaneous.}
\EDGECASES{
- Multiple children messages arriving to the same node at the same time. 
- A reply and children arrivals to the same node at the same time. 
- Initiation exactly when a reply arrives (freeing the node before initiating). 
- Initiations at equal times across different nodes. 
- Deep chains producing long round-trips. 
- Re-initiations at the same node shortly after previous completion.}
\PITFALLS{
- Getting the intra-time ordering wrong (must handle replies before children arrivals). 
- Mishandling initiations while waiting. 
- Letting the root become “waiting” (Bob never waits and replies to all arrivals immediately). 
- Forgetting to include initiator id priority when multiple arrivals are simultaneous. 
- Off-by-one on hop delays (arrival after exactly 1 second). 
- Not clearing the waiting state before forwarding replies downward.}
\FAILMODES{Greedy acceptance without interval/time awareness fails when two messages collide at an ancestor; ignoring the smallest-initiator-id rule yields incorrect arbitration; processing children arrivals before parent replies breaks causality at zero-delay instants. The interval-set optimal solution survives all these cases.}
\ELI{Messages climb up one edge per second and either reach Bob or bounce at a busy ancestor. Busy periods propagate as round-trips along the path. Handle replies first at each moment, then choose the smallest-initiator-id among simultaneous children arrivals.}
\NotePages{3}

\end{document}