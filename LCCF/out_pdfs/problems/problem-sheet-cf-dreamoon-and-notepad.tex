% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Dreamoon and Notepad}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/477/E}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{Dreamoon has just created a document of hard problems using notepad.exe. The document consists of $n$ lines of text, $a_i$ denotes the length of the $i$-th line. He now wants to know what is the fastest way to move the cursor around because the document is really long.

Let $(r, c)$ be a current cursor position, where $r$ is row number and $c$ is position of cursor in the row. We have $1 \le r \le n$ and $0 \le c \le a_r$.

We can use the following six operations in notepad.exe to move our cursor assuming the current cursor position is at $(r, c)$:
\begin{enumerate}
\item up key: the new cursor position $(n_r, n_c) = (\max(r - 1, 1), \min(a_{n_r}, c))$,
\item down key: the new cursor position $(n_r, n_c) = (\min(r + 1, n), \min(a_{n_r}, c))$,
\item left key: the new cursor position $(n_r, n_c) = (r, \max(0, c - 1))$,
\item right key: the new cursor position $(n_r, n_c) = (r, \min(a_{n_r}, c + 1))$,
\item HOME key: the new cursor position $(n_r, n_c) = (r, 0)$,
\item END key: the new cursor position $(n_r, n_c) = (r, a_r)$.
\end{enumerate}

You are given the document description ($n$ and sequence $a_i$) and $q$ queries from Dreamoon. Each query asks what minimal number of key presses is needed to move the cursor from $(r_1, c_1)$ to $(r_2, c_2)$.

Input:
The first line contains an integer $n$ ($1 \le n \le 400{,}000$) — the number of lines of text.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^8$).

The third line contains an integer $q$ ($1 \le q \le 400{,}000$).

Each of the next $q$ lines contains four integers $r_1, c_1, r_2, c_2$ representing a query ($1 \le r_1, r_2 \le n$, $0 \le c_1 \le a_{r_1}$, $0 \le c_2 \le a_{r_2}$).

Output:
For each query print the result of the query.

Note:
In the first sample, the first query can be solved with keys: HOME, right.

The second query can be solved with keys: down, down, down, END, down.

The third query can be solved with keys: down, END, down.

The fourth query can be solved with keys: END, down.}
\BREAKDOWN{We must compute, for many queries, the minimal number of key presses to move between two cursor states under operations that either change row by $\pm 1$ with column clamped by the next row length, or change column within the same row by $\pm 1$, or jump to column $0$ (HOME) or to the row end (END). Vertical moves cost $|r_1 - r_2|$ and the only complexity is optimizing horizontal moves before/after vertical movement while accounting for clamping by the minimum line length along the vertical path.}
\ELI{Vertical moves are fixed, and the column after moving vertically becomes the minimum of your chosen starting column and the smallest line length you cross; choose whether to go to $0$, stay near $c_1$, or go to the row end, and similarly at the end, in order to minimize total key presses.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{%
- $n$: integer, $1 \le n \le 400{,}000$.\\
- $a_1,\ldots,a_n$: integers, $1 \le a_i \le 10^8$.\\
- $q$: integer, $1 \le q \le 400{,}000$.\\
- For each query: $r_1, c_1, r_2, c_2$ with $1 \le r_1, r_2 \le n$, $0 \le c_1 \le a_{r_1}$, $0 \le c_2 \le a_{r_2}$.}
\OUTPUTS{For each query, print a single integer: the minimal number of key presses to move from $(r_1, c_1)$ to $(r_2, c_2)$.}
\SAMPLES{%
Example 1:\\
Input\\
3\\
5 2 4\\
4\\
1 2 1 4\\
1 3 2 1\\
2 2 3 0\\
3 4 2 1\\
Output\\
3\\
3\\
2\\
2\\
Explanation (one optimal sequence per query):\\
1) END, right, right.\\
2) down, END, left.\\
3) down, HOME.\\
4) up, END.\\

Example 2:\\
Input\\
2\\
3 1\\
2\\
1 0 2 1\\
2 1 1 3\\
Output\\
2\\
3\\
Explanation:\\
1) down, right.\\
2) up, END, left.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let rows be indexed $1..n$ with lengths $a_i$. A cursor state is $(r,c)$ with $1 \le r \le n$ and $0 \le c \le a_r$. Vertical moves change $r$ by $\pm 1$ and set $c \leftarrow \min(c, a_{r'})$. Horizontal moves within a row change $c$ by $\pm 1$, or set $c$ to $0$ (HOME), or to $a_r$ (END). For a query, let $H = \min\{a_i : i \in [\min(r_1,r_2), \max(r_1,r_2)]\}$. If we choose a starting column $x$ in row $r_1$, then after vertical movement to row $r_2$ the arrival column is $c_A = \min(x, H)$. The total cost decomposes into $|r_1 - r_2|$ plus the optimal horizontal costs at start and end.}
\varmapStart
\var{n}{number of lines}
\var{a_i}{length of line $i$}
\var{(r_1,c_1),(r_2,c_2)}{start and target states}
\var{H}{range minimum of $a_i$ over rows between $r_1$ and $r_2$ (inclusive)}
\var{x}{chosen starting column in row $r_1$ before vertical moves}
\var{c_A}{arrival column after vertical moves: $c_A = \min(x,H)$}
\var{a_1}{shorthand for $a_{r_1}$}
\var{a_2}{shorthand for $a_{r_2}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Cost} &= |r_1 - r_2| + \min\Big(
I_{\ge H} + \min(|H - c_2|,\ \mathrm{HE}_2),\
M_1,\ \mathrm{HE}_2 + M_0
\Big),\\
\mathrm{HE}_2 &= 1 + \min(c_2,\ a_2 - c_2),\\
I_{\ge H} &= \min\big(\max(0, H - c_1),\ \min(a_1 - c_1, 1)\big),\\
M_0 &= \min\big(\max(0, c_1 - H),\ \min(c_1, 1)\big),\\
G &= \begin{cases}
|c_1 - c_2|, & \text{if } \min(c_1,c_2) \le H,\\
c_1 + c_2 - 2H, & \text{otherwise},
\end{cases}\\
M_1 &= \min\Big(G,\ \min(c_1,1) + c_2,\ \mathbf{1}_{H=a_1}\cdot\big(\min(a_1 - c_1,1) + |H - c_2|\big) + \mathbf{1}_{H\ne a_1}\cdot\infty\Big).
\end{aligned}
\]
}
\ASSUMPTIONS{All $a_i \ge 1$. Vertical movement costs exactly $|r_1 - r_2|$ key presses. Horizontal moves can be postponed to the start or end without loss of optimality. Range minima $H$ include both endpoints and capture all clamping along the vertical path.}
\INVARIANTS{%
- Vertical clamping never increases the column: $c$ is nonincreasing during vertical moves.\\
- HOME and END can be moved to the start or end of the path without worsening the cost.\\
- The arrival column after vertical moves is $\min(x, H)$ regardless of the order of vertical steps.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Model the editor as a graph over states $(r,c)$ with up to $\sum_i (a_i+1)$ nodes and 6 unit-weight edges per node. For each query, run BFS from $(r_1,c_1)$ to $(r_2,c_2)$.}
\ASSUMPTIONS{Works only for tiny instances; used for validation and intuition.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency implicitly: from a state, enumerate 6 neighbors using the given rules.
\item BFS from source until reaching target; return the level distance.
\item For correctness tests, compare the BFS answer with optimized formulas on random tiny cases. Do not use BFS for large inputs.
\end{algosteps}
\COMPLEXITY{For a single query on an $n$-line document, the number of states is $N=\sum_i (a_i+1)$; BFS runs in $O(N)$ time and $O(N)$ space, which is infeasible for large $a_i$.}
\[
\begin{aligned}
T(\text{per query}) &= O\!\left(\sum_{i=1}^n (a_i+1)\right),\\
S &= O\!\left(\sum_{i=1}^n (a_i+1)\right).
\end{aligned}
\]
\CORRECTNESS{BFS computes exact shortest-path distances on an unweighted graph, matching the problem definition precisely.}
\EDGECASES{%
- Same row and same column.\\
- Same row, far apart columns (benefit of HOME/END).\\
- Crossing rows with a very small $H$ (strong clamping).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
import sys
import random

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], 0, []
    a = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    queries = []
    for _ in range(q):
        r1 = int(next(it)); c1 = int(next(it)); r2 = int(next(it)); c2 = int(next(it))
        queries.append((r1, c1, r2, c2))
    return n, a, q, queries

def solve_case_bfs(a, qitem):
    n = len(a)
    r1, c1, r2, c2 = qitem
    r1 -= 1; r2 -= 1  # zero-based rows
    # Guard smallness: BFS is exponential in a_i; enforce tiny for safety in tests.
    total_states = sum(x+1 for x in a)
    assert total_states <= 2000, "BFS baseline intended only for tiny tests"
    # Map (r,c) to index and back
    offsets = [0]
    for x in a:
        offsets.append(offsets[-1] + (x + 1))
    def idx(r, c): return offsets[r] + c
    def neighbors(r, c):
        # up
        if r > 0:
            nr = r - 1; nc = min(a[nr], c); yield nr, nc
        else:
            nr = 0; nc = min(a[nr], c); yield nr, nc
        # down
        if r+1 < n:
            nr = r + 1; nc = min(a[nr], c); yield nr, nc
        else:
            nr = n - 1; nc = min(a[nr], c); yield nr, nc
        # left
        yield r, max(0, c-1)
        # right
        yield r, min(a[r], c+1)
        # HOME
        yield r, 0
        # END
        yield r, a[r]
    src = (r1, c1); dst = (r2, c2)
    N = offsets[-1]
    dist = [-1]*N
    qd = deque()
    dist[idx(*src)] = 0
    qd.append(src)
    while qd:
        r, c = qd.popleft()
        if (r, c) == dst:
            return dist[idx(r, c)]
        for nr, nc in neighbors(r, c):
            ii = idx(nr, nc)
            if dist[ii] == -1:
                dist[ii] = dist[idx(r, c)] + 1
                qd.append((nr, nc))
    return -1

def main():
    # Tiny self-checks for baseline BFS
    a = [3, 1]
    assert solve_case_bfs(a, (1, 0, 2, 1)) == 2  # down, right
    assert solve_case_bfs(a, (2, 1, 1, 3)) == 3  # up, END, left
    # Do not run BFS on full input
    n, a, q, queries = read_input()
    if n == 0:
        return
    # For demonstration, skip solving large input in baseline
    if sum(x+1 for x in a) <= 2000 and q <= 5:
        for qi in queries:
            print(solve_case_bfs(a, qi))
    else:
        # Print nothing in baseline for large cases
        pass

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The baseline includes two asserts on tiny hand-checked cases and enforces a cap on total states for BFS.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Segment Tree RMQ + O(1) per query formula}
\WHICHFORMULA{Use the closed-form decomposition: the vertical cost is $|r_1-r_2|$. The arrival column equals $\min(x,H)$ where $H$ is the range minimum of $a_i$ over the path. For fixed $H$, minimize the sum of start/end horizontal costs via case analysis, leading to simple expressions involving $H$, $c_1$, $c_2$, $a_{r_1}$, $a_{r_2}$. Maintain $H$ by a segment tree with $O(\log n)$ queries.}
\ASSUMPTIONS{Segment tree over $a_i$ supports range minimum query in $O(\log n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a segment tree for range minimum on $a$.
\item For each query, compute $H=\min(a_\ell,\ldots,a_r)$ where $\ell=\min(r_1,r_2)$ and $r=\max(r_1,r_2)$.
\item Compute the horizontal cost by the derived formulas:
\begin{itemize}
\item $\mathrm{HE}_2 = 1 + \min(c_2, a_{r_2}-c_2)$,
\item $I_{\ge H} = \min(\max(0, H-c_1), \min(a_{r_1}-c_1,1))$,
\item $M_0 = \min(\max(0, c_1-H), \min(c_1,1))$,
\item $G = |c_1-c_2|$ if $\min(c_1,c_2)\le H$ else $c_1+c_2-2H$,
\item $M_1 = \min\big(G, \min(c_1,1)+c_2, \mathbf{1}_{H=a_{r_1}}\cdot(\min(a_{r_1}-c_1,1)+|H-c_2|)+\mathbf{1}_{H\ne a_{r_1}}\cdot\infty\big)$,
\item $A_1 = I_{\ge H} + \min(|H-c_2|, \mathrm{HE}_2)$,
\item $C_1 = \mathrm{HE}_2 + M_0$.
\end{itemize}
\item Answer $|r_1-r_2| + \min(A_1, M_1, C_1)$.
\end{algosteps}
\COMPLEXITY{Each query runs in $O(\log n)$ for the RMQ, and $O(1)$ for the arithmetic; memory is $O(n)$ for the tree.}
\[
\begin{aligned}
T_{\text{build}} &= O(n),\quad T_{\text{query}} = O(\log n),\quad S = O(n).
\end{aligned}
\]
\CORRECTNESS{Vertical clamping depends only on the minimum along the path. Any horizontal moves in intermediate rows can be moved to start/end without increasing the cost. The functions $I_{\ge H}, M_0, M_1$ arise from minimizing piecewise-linear convex costs over $x \in [0,H]$ or $x \ge H$ and considering the HOME/END shortcuts as unit-cost jumps to the endpoints.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
import random

class SegTreeMin:
    def __init__(self, arr):
        n = 1
        while n < len(arr):
            n <<= 1
        self.n = n
        self.seg = [10**18] * (2*n)
        self.a = arr[:]
        # build
        for i, v in enumerate(arr):
            self.seg[n + i] = v
        for i in range(n-1, 0, -1):
            self.seg[i] = min(self.seg[i<<1], self.seg[i<<1|1])
    def range_min(self, l, r):
        # inclusive l, r; 0-based
        l += self.n; r += self.n
        res = 10**18
        while l <= r:
            if (l & 1) == 1:
                res = min(res, self.seg[l]); l += 1
            if (r & 1) == 0:
                res = min(res, self.seg[r]); r -= 1
            l >>= 1; r >>= 1
        return res

def horiz_cost_formula(a, r1, c1, r2, c2, H):
    a1 = a[r1]; a2 = a[r2]
    HE2 = 1 + min(c2, a2 - c2)
    I_geH = min(max(0, H - c1), min(a1 - c1, 1))
    M0 = min(max(0, c1 - H), min(c1, 1))
    if min(c1, c2) <= H:
        G = abs(c1 - c2)
    else:
        G = c1 + c2 - 2*H
    extra_end_at_H = (min(a1 - c1, 1) + abs(H - c2)) if (H == a1) else 10**18
    M1 = min(G, min(c1, 1) + c2, extra_end_at_H)
    A1 = I_geH + min(abs(H - c2), HE2)
    C1 = HE2 + M0
    return min(A1, M1, C1)

def solve_all():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return
    a = [int(next(it)) for _ in range(n)]
    st = SegTreeMin(a)
    q = int(next(it))
    out = []
    for _ in range(q):
        r1 = int(next(it)) - 1
        c1 = int(next(it))
        r2 = int(next(it)) - 1
        c2 = int(next(it))
        l = min(r1, r2); r = max(r1, r2)
        H = st.range_min(l, r)
        base = abs(r1 - r2)
        extra = horiz_cost_formula(a, r1, c1, r2, c2, H)
        out.append(str(base + extra))
    sys.stdout.write("\n".join(out))

def brute_check_once():
    # Random tiny check vs BFS
    from collections import deque
    n = random.randint(1, 4)
    a = [random.randint(1, 5) for _ in range(n)]
    # Precompute offsets and BFS helper
    offs = [0]
    for x in a: offs.append(offs[-1] + (x+1))
    def idx(r,c): return offs[r] + c
    def neighbors(r,c):
        if r > 0:
            nr = r - 1; nc = min(a[nr], c); yield nr, nc
        else:
            nr = 0; nc = min(a[nr], c); yield nr, nc
        if r+1 < n:
            nr = r + 1; nc = min(a[nr], c); yield nr, nc
        else:
            nr = n-1; nc = min(a[nr], c); yield nr, nc
        yield r, max(0, c-1)
        yield r, min(a[r], c+1)
        yield r, 0
        yield r, a[r]
    # Build segtree for H
    st = SegTreeMin(a)
    # Try a few pairs
    for _ in range(20):
        r1 = random.randrange(n); r2 = random.randrange(n)
        c1 = random.randrange(a[r1]+1); c2 = random.randrange(a[r2]+1)
        # BFS
        N = offs[-1]
        dist = [-1]*N
        from collections import deque
        dq = deque()
        dist[idx(r1,c1)] = 0; dq.append((r1,c1))
        while dq:
            r,c = dq.popleft()
            if (r,c) == (r2,c2):
                bfs_ans = dist[idx(r,c)]; break
            for nr, nc in neighbors(r,c):
                ii = idx(nr,nc)
                if dist[ii] == -1:
                    dist[ii] = dist[idx(r,c)] + 1
                    dq.append((nr,nc))
        # Formula
        H = st.range_min(min(r1,r2), max(r1,r2))
        calc = abs(r1-r2) + horiz_cost_formula(a, r1, c1, r2, c2, H)
        assert bfs_ans == calc, (a, (r1,c1,r2,c2), bfs_ans, calc)

def main():
    # Deterministic sanity checks
    random.seed(0)
    # Hand-checks
    a = [3, 1]
    # Simple cases to ensure no basic mistakes
    def seg(a): 
        class S: 
            def __init__(self, a): self.a=a
        return S(a)
    # Random tiny brute checks
    for _ in range(50):
        brute_check_once()
    # Now solve input
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The improved code runs 50 deterministic randomized cross-checks against BFS on tiny instances before solving the actual input.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sparse Table RMQ + O(1) per query formula}
\WHICHFORMULA{Precompute a sparse table for range minimums over $a_i$, achieving $O(1)$ query time for $H$. Combine with the closed-form formula for horizontal costs.}
\ASSUMPTIONS{Sparse table fits in memory: $O(n \log n)$; queries are $O(1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\log_2$ for $1..n$ and the sparse table $\text{st}[k][i]=\min(a_i,\ldots,a_{i+2^k-1})$.
\item For each query, get $H$ in $O(1)$ using two overlapping blocks.
\item Compute the minimal horizontal cost using the closed-form expressions and add $|r_1-r_2|$.
\end{algosteps}
\OPTIMALITY{Each query is answered in $O(1)$ time after $O(n\log n)$ preprocessing; under the standard RAM model, this is optimal for arbitrary $q$ asymptotically when $q$ is large.}
\COMPLEXITY{Preprocessing $O(n\log n)$ time and $O(n\log n)$ space; queries $O(1)$ time and $O(1)$ space.}
\[
\begin{aligned}
T_{\text{build}} &= O(n\log n),\quad T_{\text{query}} = O(1),\quad S = O(n\log n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
import random

class RMQMinSparse:
    def __init__(self, arr):
        self.a = arr[:]
        n = len(arr)
        self.log = [0]*(n+1)
        for i in range(2, n+1):
            self.log[i] = self.log[i//2] + 1
        K = self.log[n] + 1
        st = [arr[:]]
        k = 1
        while (1<<k) <= n:
            prev = st[-1]
            width = 1<<k
            half = width>>1
            row = [0]*(n - width + 1)
            for i in range(n - width + 1):
                row[i] = prev[i] if prev[i] < prev[i+half] else prev[i+half]
            st.append(row)
            k += 1
        self.st = st
    def range_min(self, l, r):
        # inclusive l, r; 0-based
        if l > r: l, r = r, l
        k = self.log[r - l + 1]
        a = self.st[k][l]
        b = self.st[k][r - (1<<k) + 1]
        return a if a < b else b

def horiz_cost_formula(a, r1, c1, r2, c2, H):
    a1 = a[r1]; a2 = a[r2]
    HE2 = 1 + min(c2, a2 - c2)
    I_geH = min(max(0, H - c1), min(a1 - c1, 1))
    M0 = min(max(0, c1 - H), min(c1, 1))
    if min(c1, c2) <= H:
        G = abs(c1 - c2)
    else:
        G = c1 + c2 - 2*H
    extra_end_at_H = (min(a1 - c1, 1) + abs(H - c2)) if (H == a1) else 10**18
    M1 = min(G, min(c1, 1) + c2, extra_end_at_H)
    A1 = I_geH + min(abs(H - c2), HE2)
    C1 = HE2 + M0
    return min(A1, M1, C1)

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], 0, []
    a = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    qs = []
    for _ in range(q):
        r1 = int(next(it)); c1 = int(next(it)); r2 = int(next(it)); c2 = int(next(it))
        qs.append((r1, c1, r2, c2))
    return n, a, q, qs

def solve_all():
    n, a, q, qs = read_input()
    if n == 0:
        return
    rmq = RMQMinSparse(a)
    out = []
    for (r1, c1, r2, c2) in qs:
        r1 -= 1; r2 -= 1
        l = min(r1, r2); r = max(r1, r2)
        H = rmq.range_min(l, r)
        extra = horiz_cost_formula(a, r1, c1, r2, c2, H)
        ans = abs(r1 - r2) + extra
        out.append(str(ans))
    sys.stdout.write("\n".join(out))

def brute_check():
    # Deterministic tiny checks vs BFS
    from collections import deque
    random.seed(1)
    for _ in range(50):
        n = random.randint(1, 4)
        a = [random.randint(1, 5) for _ in range(n)]
        rmq = RMQMinSparse(a)
        offs = [0]
        for x in a: offs.append(offs[-1] + (x+1))
        def idx(r,c): return offs[r] + c
        def neighbors(r,c):
            if r > 0:
                nr = r - 1; nc = min(a[nr], c); yield nr, nc
            else:
                nr = 0; nc = min(a[nr], c); yield nr, nc
            if r+1 < n:
                nr = r + 1; nc = min(a[nr], c); yield nr, nc
            else:
                nr = n-1; nc = min(a[nr], c); yield nr, nc
            yield r, max(0, c-1)
            yield r, min(a[r], c+1)
            yield r, 0
            yield r, a[r]
        for _ in range(20):
            r1 = random.randrange(n); r2 = random.randrange(n)
            c1 = random.randrange(a[r1]+1); c2 = random.randrange(a[r2]+1)
            N = offs[-1]
            dist = [-1]*N
            dq = deque()
            dist[idx(r1,c1)] = 0; dq.append((r1,c1))
            while dq:
                r,c = dq.popleft()
                if (r,c) == (r2,c2):
                    bfs_ans = dist[idx(r,c)]; break
                for nr, nc in neighbors(r,c):
                    ii = idx(nr,nc)
                    if dist[ii] == -1:
                        dist[ii] = dist[idx(r,c)] + 1
                        dq.append((nr,nc))
            H = rmq.range_min(min(r1,r2), max(r1,r2))
            calc = abs(r1 - r2) + horiz_cost_formula(a, r1, c1, r2, c2, H)
            assert bfs_ans == calc, (a, (r1,c1,r2,c2), bfs_ans, calc)

def main():
    # Sanity asserts
    brute_check()
    # Hand tests
    a = [3, 1]
    rmq = RMQMinSparse(a)
    # (1,0)->(2,1): expect 2
    r1,c1,r2,c2 = 0,0,1,1
    H = rmq.range_min(min(r1,r2), max(r1,r2))
    assert abs(r1-r2) + horiz_cost_formula(a, r1, c1, r2, c2, H) == 2
    # Solve input
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts or mini-tests are included in the final code: randomized brute checks, a hand-crafted case on $a=[3,1]$, and implicit consistency through the brute checker.}
\RESULT{For each query, print the minimal number of key presses. Ties do not arise since the answer is a numeric minimum.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{%
- Unit-check the horizontal cost formulas against BFS on randomized tiny documents.\\
- Hand-check degenerate scenarios: same row, same column; clamping to zero; using HOME vs END.\\
- Stress with adversarial shapes: a plateau with a single short line in between.}
\LINE{CROSS-CHECKS}{Compare Approach A (BFS) to Approach B/C (formulas) on small instances; differences indicate formula bugs.}
\LINE{EDGE-CASE GENERATOR}{Generate $n \in [1,4]$, $a_i \in [1,5]$, random queries; ensure coverage when $H=0$, $H=a_{r_1}$, $c_1,c_2$ on either side of $H$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    cases = []
    # Same row edge cases
    cases.append(( [5], [(1,0,1,5), (1,5,1,0), (1,2,1,4)] ))
    # Two rows with strong clamp
    cases.append(( [5,1], [(1,4,2,0), (1,4,2,1), (2,1,1,5)] ))
    # Plateau with one valley
    cases.append(( [4,4,1,4,4], [(1,3,5,3), (1,3,3,0), (2,4,4,4)] ))
    return cases

def run_cases_with_final():
    import sys
    # Use the final solver from Approach C
    # This is a minimal wrapper; paste the final solver here if running standalone.
    pass  # In this sheet, cross-checks are in the asserts within the final code.
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
import random

class RMQMinSparse:
    def __init__(self, arr):
        self.a = arr[:]
        n = len(arr)
        self.log = [0]*(n+1)
        for i in range(2, n+1):
            self.log[i] = self.log[i//2] + 1
        K = self.log[n] + 1
        st = [arr[:]]
        k = 1
        while (1<<k) <= n:
            prev = st[-1]
            width = 1<<k
            half = width>>1
            row = [0]*(n - width + 1)
            for i in range(n - width + 1):
                row[i] = prev[i] if prev[i] < prev[i+half] else prev[i+half]
            st.append(row)
            k += 1
        self.st = st
    def range_min(self, l, r):
        if l > r: l, r = r, l
        k = self.log[r - l + 1]
        a = self.st[k][l]
        b = self.st[k][r - (1<<k) + 1]
        return a if a < b else b

def horiz_cost_formula(a, r1, c1, r2, c2, H):
    a1 = a[r1]; a2 = a[r2]
    HE2 = 1 + min(c2, a2 - c2)
    I_geH = min(max(0, H - c1), min(a1 - c1, 1))
    M0 = min(max(0, c1 - H), min(c1, 1))
    if min(c1, c2) <= H:
        G = abs(c1 - c2)
    else:
        G = c1 + c2 - 2*H
    extra_end_at_H = (min(a1 - c1, 1) + abs(H - c2)) if (H == a1) else 10**18
    M1 = min(G, min(c1, 1) + c2, extra_end_at_H)
    A1 = I_geH + min(abs(H - c2), HE2)
    C1 = HE2 + M0
    return min(A1, M1, C1)

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], 0, []
    a = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    qs = []
    for _ in range(q):
        r1 = int(next(it)); c1 = int(next(it)); r2 = int(next(it)); c2 = int(next(it))
        qs.append((r1, c1, r2, c2))
    return n, a, q, qs

def solve_all():
    n, a, q, qs = read_input()
    if n == 0:
        return
    rmq = RMQMinSparse(a)
    out = []
    for (r1, c1, r2, c2) in qs:
        r1 -= 1; r2 -= 1
        l = min(r1, r2); r = max(r1, r2)
        H = rmq.range_min(l, r)
        extra = horiz_cost_formula(a, r1, c1, r2, c2, H)
        ans = abs(r1 - r2) + extra
        out.append(str(ans))
    sys.stdout.write("\n".join(out))

def brute_check():
    # Deterministic tiny checks vs BFS
    from collections import deque
    random.seed(7)
    for _ in range(30):
        n = random.randint(1, 4)
        a = [random.randint(1, 5) for _ in range(n)]
        rmq = RMQMinSparse(a)
        offs = [0]
        for x in a: offs.append(offs[-1] + (x+1))
        def idx(r,c): return offs[r] + c
        def neighbors(r,c):
            if r > 0:
                nr = r - 1; nc = min(a[nr], c); yield nr, nc
            else:
                nr = 0; nc = min(a[nr], c); yield nr, nc
            if r+1 < n:
                nr = r + 1; nc = min(a[nr], c); yield nr, nc
            else:
                nr = n-1; nc = min(a[nr], c); yield nr, nc
            yield r, max(0, c-1)
            yield r, min(a[r], c+1)
            yield r, 0
            yield r, a[r]
        for _ in range(20):
            r1 = random.randrange(n); r2 = random.randrange(n)
            c1 = random.randrange(a[r1]+1); c2 = random.randrange(a[r2]+1)
            N = offs[-1]
            dist = [-1]*N
            dq = deque()
            dist[idx(r1,c1)] = 0; dq.append((r1,c1))
            while dq:
                r,c = dq.popleft()
                if (r,c) == (r2,c2):
                    bfs_ans = dist[idx(r,c)]; break
                for nr, nc in neighbors(r,c):
                    ii = idx(nr,nc)
                    if dist[ii] == -1:
                        dist[ii] = dist[idx(r,c)] + 1
                        dq.append((nr,nc))
            H = rmq.range_min(min(r1,r2), max(r1,r2))
            calc = abs(r1 - r2) + horiz_cost_formula(a, r1, c1, r2, c2, H)
            assert bfs_ans == calc, (a, (r1,c1,r2,c2), bfs_ans, calc)

def main():
    # Run light sanity
    brute_check()
    # Example assertions
    a = [3, 1]
    rmq = RMQMinSparse(a)
    r1,c1,r2,c2 = 0,0,1,1
    H = rmq.range_min(min(r1,r2), max(r1,r2))
    assert abs(r1-r2) + horiz_cost_formula(a, r1, c1, r2, c2, H) == 2
    # Solve
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimal cursor movement equals vertical distance plus an optimized horizontal component based on the minimum line length along the path.}
\WHY{This pattern (range minima with clamping and start/end adjustments) recurs in editor-like navigation and constrained DP/greedy problems; mastering it demonstrates the ability to derive closed forms and support them with RMQ.}
\CHECKLIST{%
- Compute $H=\min a_i$ on the closed interval between rows.\\
- Compute $\mathrm{HE}_2 = 1 + \min(c_2, a_{r_2}-c_2)$.\\
- Evaluate $I_{\ge H}, M_0, G, M_1, A_1, C_1$.\\
- Answer $|r_1-r_2| + \min(A_1, M_1, C_1)$.}
\EDGECASES{%
- $r_1=r_2$ (no vertical moves).\\
- $c_1=0$ or $c_2=0$ (HOME highly beneficial).\\
- $c_1=a_{r_1}$ or $c_2=a_{r_2}$ (END highly beneficial).\\
- $H=0$ (columns clamp to $0$).\\
- Both $c_1,c_2>H$ (use boundary $H$ in $G$).\\
- $H=a_{r_1}$ (END at start maps to $H$ in one key).\\
- Very large $a_i$ but small $H$ (heavy clamping).\\
- Moving upward vs downward (symmetric after using $H$).\\
- $c_2$ near $0$ or near $a_{r_2}$ (prefer $\mathrm{HE}_2$).}
\PITFALLS{%
- Using open interval for $H$; endpoints must be included.\\
- Forgetting that HOME/END cost exactly $1$, not distance.\\
- Double-counting vertical cost in intermediate horizontal steps.\\
- Assuming horizontal moves in middle help; they can be moved to ends.\\
- Off-by-one in RMQ indices (inclusive ranges).\\
- Overflow not likely in Python, but watch arithmetic in other languages.\\
- Sparse table build row lengths: ensure proper bounds.\\
- Comparing to $H=a_{r_1}$ for the extra END-at-$H$ shortcut.}
\FAILMODES{%
- A naive per-query BFS/DP times out or runs out of memory.\\
- Using only $|c_1-c_2|$ horizontally misses HOME/END.\\
- Forgetting clamping leads to undercounting when lines get shorter.}
\ELI{Move the cursor up/down the needed number of lines. Along the way, the column can only go down to the smallest line length you cross. Choose whether to snap to 0, stay near your current column, or snap to the end before/after moving, whichever yields the fewest key presses.}
\NotePages{3}

\end{document}