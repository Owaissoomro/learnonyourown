% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Insert Interval}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/insert-interval/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given an array of non-overlapping intervals \texttt{intervals} where \texttt{intervals[i] = [starti, endi]} represent the start and the end of the \texttt{ith} interval and \texttt{intervals} is sorted in ascending order by \texttt{starti}. You are also given an interval \texttt{newInterval = [start, end]} that represents the start and end of another interval.

Insert \texttt{newInterval} into \texttt{intervals} such that \texttt{intervals} is still sorted in ascending order by \texttt{starti} and \texttt{intervals} still does not have any overlapping intervals (merge overlapping intervals if necessary). Return \texttt{intervals} \emph{after the insertion}.

\textbf{Note} that you do not need to modify \texttt{intervals} in-place. You can make a new array and return it.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{intervals = [[1,3],[6,9]], newInterval = [2,5]}

\quad \textbf{Output:} \texttt{[[1,5],[6,9]]}

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]}

\quad \textbf{Output:} \texttt{[[1,2],[3,10],[12,16]]}

\quad \textbf{Explanation:} Because the new interval \texttt{[4,8]} overlaps with \texttt{[3,5]}, \texttt{[6,7]}, \texttt{[8,10]}.

\textbf{Constraints:}
\begin{itemize}
\item $0 \le \texttt{intervals.length} \le 10^4$
\item $\texttt{intervals[i].length} = 2$
\item $0 \le \texttt{starti} \le \texttt{endi} \le 10^5$
\item \texttt{intervals} is sorted by \texttt{starti} in ascending order.
\item $\texttt{newInterval.length} = 2$
\item $0 \le \texttt{start} \le \texttt{end} \le 10^5$
\end{itemize}}
\BREAKDOWN{We must insert one interval into a sorted list of pairwise disjoint intervals and merge any overlaps to keep the list sorted and non-overlapping. The challenge is to do this in optimal linear time by exploiting the input order.}
\ELI{Slide the new interval across the timeline: copy all intervals that end before it, merge all that overlap with it, then append the rest.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Given:
\begin{itemize}
\item \texttt{intervals}: list of $n$ closed intervals \texttt{[l, r]} with $0 \le n \le 10^4$, sorted by \texttt{l} strictly increasing, and pairwise non-overlapping.
\item \texttt{newInterval}: a single closed interval \texttt{[l, r]} with $0 \le l \le r \le 10^5$.
\end{itemize}}
\OUTPUTS{Return a new list of closed intervals, sorted by start, pairwise disjoint, whose union equals the union of \texttt{intervals} and \texttt{newInterval}.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{intervals = [[1,3],[6,9]]}, \texttt{newInterval = [2,5]} $\to$ Output: \texttt{[[1,5],[6,9]]}
\item Input: \texttt{intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]]}, \texttt{newInterval = [4,8]} $\to$ Output: \texttt{[[1,2],[3,10],[12,16]]}
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let intervals be closed sets on $\mathbb{Z}$ or $\mathbb{R}$, represented as $[a_i,b_i]$ with $a_i \le b_i$, sorted by $a_i$, and pairwise disjoint. Given a new interval $[c,d]$, compute the unique family of pairwise disjoint intervals, sorted by start, whose union equals $\bigl(\bigcup_i [a_i,b_i]\bigr) \cup [c,d]$.}
\varmapStart
\var{(a_i,b_i)}{endpoints of the $i$-th existing interval}
\var{(c,d)}{endpoints of the new interval}
\var{U}{the union set $\bigcup_i [a_i,b_i]$}
\var{R}{the resulting family after insertion and merging}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
R &= \operatorname{Normalize}\!\left(\,\{[a_i,b_i]\}_i \cup \{[c,d]\}\,\right), \\
\operatorname{Normalize}(S) &:= \text{the minimal-size ordered family of disjoint intervals whose union is } \bigcup_{I \in S} I.
\end{aligned}
\]
}
\ASSUMPTIONS{Input \texttt{intervals} is sorted by start and pairwise non-overlapping; endpoints are integers within bounds.}
\INVARIANTS{
\begin{itemize}
\item Prefix-copy invariant: all output intervals emitted before the merged \texttt{newInterval} end strictly before its current start.
\item Merge invariant: while overlapping, we maintain the current merged interval as $[\min, \max]$ of all overlaps encountered so far.
\item Postfix-copy invariant: once we emit the merged interval, remaining inputs start strictly after its end, so they can be appended unchanged.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Append the new interval, sort by start, then perform a standard full merge of overlapping intervals. This ignores the given sorted, disjoint structure for simplicity.}
\ASSUMPTIONS{Sorting is available; integer arithmetic; endpoints fit in standard integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Create array $A = \texttt{intervals} \cup \{\texttt{newInterval}\}$.
\item Sort $A$ by start coordinate.
\item Scan left-to-right, merging consecutive intervals that overlap; emit non-overlapping merged intervals into the answer.
\end{algosteps}
\COMPLEXITY{Sorting dominates: $T(n) = O(n \log n)$, $S(n) = O(1)$ extra besides output (or $O(n)$ if counting output buffer).}
\[
\begin{aligned}
T(n) &= O(n \log n) + O(n) \\
     &= O(n \log n).
\end{aligned}
\]
\CORRECTNESS{Sorting ensures intervals are in non-decreasing start order. The standard merge sweep computes the normalization of the set union, yielding the minimal disjoint cover.}
\EDGECASES{Empty input; \texttt{newInterval} before all; after all; contained inside an existing interval; overlapping multiple consecutive intervals; equal endpoints.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        # Baseline: append, sort, and merge all.
        arr = intervals + [newInterval]
        if not arr:
            return []
        arr.sort(key=lambda x: x[0])
        merged: List[List[int]] = []
        cur_s, cur_e = arr[0][0], arr[0][1]
        for s, e in arr[1:]:
            if s <= cur_e:
                if e > cur_e:
                    cur_e = e
            else:
                merged.append([cur_s, cur_e])
                cur_s, cur_e = s, e
        merged.append([cur_s, cur_e])
        return merged

# Tests (LC-style quick checks)
s = Solution()
assert s.insert([[1,3],[6,9]],[2,5]) == [[1,5],[6,9]]
assert s.insert([[1,2],[3,5],[6,7],[8,10],[12,16]],[4,8]) == [[1,2],[3,10],[12,16]]
assert s.insert([], [2,3]) == [[2,3]]
assert s.insert([[1,5]],[2,3]) == [[1,5]]
assert s.insert([[1,5]],[6,8]) == [[1,5],[6,8]]
\end{minted}
\VALIDATION{Manual spot-checks confirm: merging is stable; edge cases like empty input, full containment, and no-overlap append/prepend behave correctly.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Linear Scan Using Sorted Structure}
\WHICHFORMULA{Exploit that \texttt{intervals} is already sorted and disjoint. We only need to:
(1) copy all intervals strictly before \texttt{newInterval},
(2) merge all overlaps with \texttt{newInterval} into one interval,
(3) append the remaining intervals.}
\ASSUMPTIONS{Closed intervals; overlap test is $[a,b]$ and $[c,d]$ overlap iff $a \le d$ and $c \le b$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize result list \texttt{ans = []}, set \texttt{cur = newInterval}.
\item While next interval ends before \texttt{cur} starts, append it to \texttt{ans}.
\item While next interval overlaps \texttt{cur}, expand \texttt{cur} to cover the union.
\item Append \texttt{cur} to \texttt{ans}, then append all remaining intervals.
\end{algosteps}
\COMPLEXITY{Single pass over $n$ intervals; beats sorting-based baseline.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n) = O(1) \text{ extra besides output.}
\end{aligned}
\]
\CORRECTNESS{By invariants: copied prefix is disjoint and ordered; merged block condenses exactly the overlapping run into one interval; suffix starts after the merged end so remains disjoint and ordered.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        ans: List[List[int]] = []
        i, n = 0, len(intervals)
        s, e = newInterval[0], newInterval[1]

        # 1) Add all intervals ending before newInterval starts.
        while i < n and intervals[i][1] < s:
            ans.append(intervals[i])
            i += 1

        # 2) Merge all that overlap with [s, e].
        while i < n and intervals[i][0] <= e and intervals[i][1] >= s:
            s = min(s, intervals[i][0])
            e = max(e, intervals[i][1])
            i += 1

        # 3) Add the merged interval.
        ans.append([s, e])

        # 4) Append the rest.
        while i < n:
            ans.append(intervals[i])
            i += 1

        return ans

# Tests
s = Solution()
assert s.insert([[1,3],[6,9]],[2,5]) == [[1,5],[6,9]]
assert s.insert([[1,2],[3,5],[6,7],[8,10],[12,16]],[4,8]) == [[1,2],[3,10],[12,16]]
assert s.insert([], [2,3]) == [[2,3]]
assert s.insert([[1,5]],[2,3]) == [[1,5]]
assert s.insert([[1,5]],[6,8]) == [[1,5],[6,8]]
\end{minted}
\VALIDATION{Covers prepend/append, full containment, spanning multiple intervals, and empty input.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-Pass Linear Insert-and-Merge}
\WHICHFORMULA{Same linear scan as Approach B with a slightly cleaner overlap predicate and no redundant checks.}
\ASSUMPTIONS{Input sorted and disjoint; closed intervals; stable copy/append order.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Copy all intervals with end $< \texttt{new.start}$.
\item Merge all intervals with start $\le \texttt{new.end}$ into \texttt{new} by updating its start to the minimum and end to the maximum encountered.
\item Emit the merged \texttt{new}, then append the remaining intervals.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect each interval to decide overlap with the new interval in the worst case, giving a lower bound of $\Omega(n)$. This algorithm achieves $O(n)$ time with $O(1)$ extra space.}
\COMPLEXITY{Linear time, constant extra space beyond output buffer.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n) = O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        ans: List[List[int]] = []
        i, n = 0, len(intervals)
        ns, ne = newInterval

        # Copy all intervals strictly before the new interval.
        while i < n and intervals[i][1] < ns:
            ans.append(intervals[i])
            i += 1

        # Merge overlaps with the new interval.
        while i < n and intervals[i][0] <= ne:
            ns = min(ns, intervals[i][0])
            ne = max(ne, intervals[i][1])
            i += 1

        ans.append([ns, ne])

        # Append remaining intervals.
        while i < n:
            ans.append(intervals[i])
            i += 1

        return ans

# Exactly 3 asserts
_s = Solution()
assert _s.insert([[1,3],[6,9]],[2,5]) == [[1,5],[6,9]]
assert _s.insert([[1,2],[3,5],[6,7],[8,10],[12,16]],[4,8]) == [[1,2],[3,10],[12,16]]
assert _s.insert([], [2,3]) == [[2,3]]
\end{minted}
\VALIDATION{Matches sample outputs and handles degenerate/empty inputs.}
\RESULT{Returns the normalized, sorted, pairwise disjoint family of intervals representing the union of the original intervals with the inserted one; tie-breaking is inherent in normalization and uniqueness of the merged cover.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests: sample cases; boundary endpoints equal; insertion at front/back; full containment; spanning multiple intervals; empty input. Property test: compare optimized vs baseline on random crafted instances.}
\LINE{CROSS-CHECKS}{Run baseline $O(n \log n)$ vs optimal $O(n)$ on the same inputs; outputs must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Covers empty, single interval, touching endpoints, large ranges, and random positions for \texttt{newInterval}.}
\begin{minted}{python}
from typing import List, Tuple
import random

def baseline_insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
    arr = intervals + [newInterval]
    if not arr:
        return []
    arr.sort(key=lambda x: x[0])
    out: List[List[int]] = []
    cs, ce = arr[0]
    for s, e in arr[1:]:
        if s <= ce:
            if e > ce:
                ce = e
        else:
            out.append([cs, ce])
            cs, ce = s, e
    out.append([cs, ce])
    return out

def optimal_insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
    ans: List[List[int]] = []
    i, n = 0, len(intervals)
    ns, ne = newInterval
    while i < n and intervals[i][1] < ns:
        ans.append(intervals[i]); i += 1
    while i < n and intervals[i][0] <= ne:
        ns = min(ns, intervals[i][0])
        ne = max(ne, intervals[i][1])
        i += 1
    ans.append([ns, ne])
    while i < n:
        ans.append(intervals[i]); i += 1
    return ans

def gen_intervals(n: int, lo: int = 0, hi: int = 50, gap: int = 0) -> List[List[int]]:
    # Deterministic generator
    rnd = random.Random(123456789 + n + lo + hi + gap)
    points = sorted({rnd.randint(lo, hi) for _ in range(2 * n)})
    res: List[List[int]] = []
    i = 0
    while i + 1 < len(points) and len(res) < n:
        a = points[i]
        b = max(a, points[i + 1])
        if not res or a > res[-1][1] + gap:
            res.append([a, b])
        i += 2
    return res

def gen_new(lo: int = 0, hi: int = 50) -> List[int]:
    a, b = sorted((lo + 1, hi - 1))
    return [a, b]

# Cross-checks
for n in range(0, 15):
    ivs = gen_intervals(n)
    # Try several new intervals around the range
    for new in ([[-10, -5], [0, 0], [5, 15], [40, 60], [100, 120], [0, 100]]):
        bl = baseline_insert(ivs, new)
        op = optimal_insert(ivs, new)
        assert bl == op

# Sample checks
assert optimal_insert([[1,3],[6,9]],[2,5]) == [[1,5],[6,9]]
assert optimal_insert([], [2,3]) == [[2,3]]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        ans: List[List[int]] = []
        i, n = 0, len(intervals)
        ns, ne = newInterval

        # Copy intervals strictly before newInterval.
        while i < n and intervals[i][1] < ns:
            ans.append(intervals[i])
            i += 1

        # Merge overlaps with newInterval.
        while i < n and intervals[i][0] <= ne:
            ns = min(ns, intervals[i][0])
            ne = max(ne, intervals[i][1])
            i += 1

        # Emit merged and append remainder.
        ans.append([ns, ne])
        while i < n:
            ans.append(intervals[i])
            i += 1

        return ans

# Self-checks
_s = Solution()
assert _s.insert([[1,3],[6,9]],[2,5]) == [[1,5],[6,9]]
assert _s.insert([[1,5]],[2,3]) == [[1,5]]
assert _s.insert([[1,5]],[6,8]) == [[1,5],[6,8]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Insert one interval into a sorted, disjoint list by copying the left, merging overlaps into one, then appending the right.}
\WHY{Common interval-manipulation pattern in scheduling, calendar apps, range maintenance, and sweep-line foundations.}
\CHECKLIST{
\begin{itemize}
\item Identify and copy all intervals with end $< \texttt{new.start}$.
\item Merge all intervals with start $\le \texttt{new.end}$ into the new interval.
\item Append merged interval, then the remaining suffix.
\item Preserve sort order and disjointness.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item Empty \texttt{intervals}.
\item \texttt{newInterval} before all or after all.
\item Full containment inside an existing interval.
\item Touching endpoints (e.g., $[1,2]$ and $[2,3]$): still overlap for closed intervals.
\item Multiple consecutive overlaps.
\item Large identical endpoints (equal start and end).
\item Single interval input.
\item Very large $n$ (performance).
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Using strict overlap test and missing endpoint-touching cases.
\item Forgetting to append the merged interval before suffix.
\item Off-by-one when advancing the index through overlaps.
\item Accidentally re-sorting and paying $O(n \log n)$.
\item Mutating input arrays unexpectedly (avoid if platform expects immutability).
\item Not handling empty input correctly.
\item Incorrectly initializing the merged bounds.
\item Duplicating intervals in output when new interval is fully contained.
\end{itemize}}
\FAILMODES{A naive in-place insertion without merging will break on overlapping runs; sorting-based approaches are correct but slower. The linear scan survives adversarial placements because it classifies intervals into prefix/overlap/suffix deterministically.}
\ELI{Think of placing one sticky note on a timeline of non-overlapping notes. Move right, glue together any notes that touch your new sticky note into one larger note, then stick it down and keep the rest as they are.}
\NotePages{3}

\end{document}