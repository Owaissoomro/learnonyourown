% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Strongly Connected City}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/475/B}}
\LINE{DIFFICULTY / RATING}{1400}
\STATEMENT{Imagine a city with $n$ horizontal streets crossing $m$ vertical streets, forming an $(n - 1) \times (m - 1)$ grid. In order to increase the traffic flow, mayor of the city has decided to make each street one way. This means in each horizontal street, the traffic moves only from west to east or only from east to west. Also, traffic moves only from north to south or only from south to north in each vertical street. It is possible to enter a horizontal street from a vertical street, or vice versa, at their intersection.

The mayor has received some street direction patterns. Your task is to check whether it is possible to reach any junction from any other junction in the proposed street direction pattern.

Input:
The first line of input contains two integers $n$ and $m$, $(2 \le n, m \le 20)$, denoting the number of horizontal streets and the number of vertical streets.

The second line contains a string of length $n$, made of characters `\texttt{<}' and `\texttt{>}' denoting direction of each horizontal street. If the $i$-th character is equal to `\texttt{<}', the street is directed from east to west otherwise, the street is directed from west to east. Streets are listed in order from north to south.

The third line contains a string of length $m$, made of characters `\^{}' and `\texttt{v}', denoting direction of each vertical street. If the $i$-th character is equal to `\^{}', the street is directed from south to north, otherwise the street is directed from north to south. Streets are listed in order from west to east.

Output:
If the given pattern meets the mayor's criteria, print a single line containing ``YES'', otherwise print a single line containing ``NO''.

Note:
The figure above shows street directions in the second sample test case.}
\BREAKDOWN{Model junctions as vertices of a directed graph on an $n \times m$ grid. Each row has directed edges only in one horizontal direction; each column has directed edges only in one vertical direction. Check whether the directed graph is strongly connected.}
\ELI{Build the directed graph from the street directions and verify that from any junction you can reach all others (and vice versa).}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n, m$ with $2 \le n,m \le 20$; a string $R$ of length $n$ over $\{\texttt{<},\texttt{>}\}$ describing horizontal directions by row (north to south); a string $C$ of length $m$ over $\{\^{},\texttt{v}\}$ describing vertical directions by column (west to east).}
\OUTPUTS{Print exactly one line: either \texttt{YES} if the junction graph is strongly connected, or \texttt{NO} otherwise.}
\SAMPLES{Example 1 (YES):
3 3
><>
^v^

Example 2 (NO):
2 3
>>
^^^}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V = \{(i,j) \mid i \in [1..n],~ j \in [1..m]\}$ be the set of junctions. Define a directed graph $G=(V,E)$ where for each $(i,j)$:
- If $R_i=\texttt{>}$ and $j<m$, then $((i,j),(i,j+1)) \in E$. If $R_i=\texttt{<}$ and $j>1$, then $((i,j),(i,j-1)) \in E$.
- If $C_j=\texttt{v}$ and $i<n$, then $((i,j),(i+1,j)) \in E$. If $C_j=\^{}$ and $i>1$, then $((i,j),(i-1,j)) \in E$.
Decide if $G$ is strongly connected.}
\varmapStart
\var{n,m}{numbers of horizontal and vertical streets}
\var{R_i}{direction of row $i$: `\texttt{>}' or `\texttt{<}'}
\var{C_j}{direction of column $j$: `\texttt{v}' or `\^{}'}
\var{V}{set of $n m$ junctions}
\var{E}{directed edges induced by $R$ and $C$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Strong connectivity:}\quad \forall u,v \in V,\ \exists \text{ a directed path } u \leadsto v \text{ in } G.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are $1$-based in the model; grid borders have no edges leaving the grid. Each row and column orientation is uniform along the whole street.}
\INVARIANTS{From any vertex $(i,j)$, the only possible moves are: at most one horizontal step in the row's direction and at most one vertical step in the column's direction. The graph has $|V| = n m$ vertices and $|E| \le 2 n m$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly check strong connectivity by running a BFS/DFS from every vertex and verifying all $n m$ vertices are reachable.}
\ASSUMPTIONS{Small bounds ($n,m \le 20$) make $O((nm)^2)$ traversal feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build an implicit neighbor function using $R$ and $C$ for moves within bounds.
\item For each start vertex $(s_i,s_j)$, run BFS and count visited vertices.
\item If any BFS visits fewer than $n m$ vertices, answer NO; otherwise YES.
\end{algosteps}
\COMPLEXITY{For each of $n m$ starts we traverse $O(n m)$ edges. Space is $O(n m)$ for visited.}
\[
\begin{aligned}
T(n,m) &= O\big((nm) \cdot (nm)\big) = O(n^2 m^2),\\
S(n,m) &= O(n m).
\end{aligned}
\]
\CORRECTNESS{If any vertex cannot reach all others, strong connectivity fails. Conversely, if every vertex reaches all others, by definition the graph is strongly connected.}
\EDGECASES{Corners must have at least one outgoing edge; rows/cols of length $2$; all rows or all cols pointing the same way; mixed patterns.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str | None = None):
    if data is None:
        toks = sys.stdin.read().strip().split()
    else:
        toks = data.strip().split()
    n = int(toks[0]); m = int(toks[1])
    rows = toks[2].strip()
    cols = toks[3].strip()
    assert len(rows) == n and len(cols) == m
    return n, m, rows, cols

def neighbors(n, m, rows, cols, i, j):
    if rows[i] == '>':
        if j + 1 < m:
            yield (i, j + 1)
    else:  # '<'
        if j - 1 >= 0:
            yield (i, j - 1)
    if cols[j] == 'v':
        if i + 1 < n:
            yield (i + 1, j)
    else:  # '^'
        if i - 1 >= 0:
            yield (i - 1, j)

def bfs_all_reached(n, m, rows, cols, si, sj):
    vis = [[False] * m for _ in range(n)]
    dq = deque()
    dq.append((si, sj))
    vis[si][sj] = True
    seen = 1
    while dq:
        i, j = dq.popleft()
        for ni, nj in neighbors(n, m, rows, cols, i, j):
            if not vis[ni][nj]:
                vis[ni][nj] = True
                seen += 1
                dq.append((ni, nj))
    return seen == n * m

def solve_case(n, m, rows, cols) -> str:
    for i in range(n):
        for j in range(m):
            if not bfs_all_reached(n, m, rows, cols, i, j):
                return "NO\n"
    return "YES\n"

def solve_all():
    n, m, rows, cols = read_input()
    sys.stdout.write(solve_case(n, m, rows, cols))

def _solve_io(s: str) -> str:
    n, m, rows, cols = read_input(s)
    return solve_case(n, m, rows, cols)

# Basic asserts (do not print; deterministic)
assert _solve_io("2 2\n><\n^v\n") == "YES\n"
assert _solve_io("2 2\n<<\n^^\n") == "NO\n"
assert _solve_io("3 3\n>>>\nvvv\n") == "NO\n"

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{The three asserts cover: a 2x2 positive cycle; clear negatives with one-way flow only.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Single-Source BFS With Early Exit}
\WHICHFORMULA{Observe that if any vertex fails to reach all others, we can terminate early; reuse a precomputed neighbor function to avoid recomputation overhead.}
\ASSUMPTIONS{Same as baseline; neighbor generation is $O(1)$ per edge.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Predefine neighbor and run BFS from a vertex; if it reaches all, continue to the next, else stop.
\item Stop as soon as a start fails; otherwise after all starts, return YES.
\item Micro-optimizations: flatten visited to a single list of length $n m$ and map $(i,j) \leftrightarrow i m + j$.
\end{algosteps}
\COMPLEXITY{Still worst-case $O(n^2 m^2)$, but earlier termination helps adversarially small cases.}
\[
\begin{aligned}
T(n,m) &= O\big(k \cdot nm\big),~k \le nm, \\
\end{aligned}
\]
\CORRECTNESS{Same reasoning as baseline; early exit does not affect correctness.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str | None = None):
    if data is None:
        toks = sys.stdin.read().strip().split()
    else:
        toks = data.strip().split()
    n = int(toks[0]); m = int(toks[1])
    rows = toks[2].strip(); cols = toks[3].strip()
    assert len(rows) == n and len(cols) == m
    return n, m, rows, cols

def neigh_idx(n, m, rows, cols, idx):
    i, j = divmod(idx, m)
    if rows[i] == '>':
        if j + 1 < m:
            yield idx + 1
    else:  # '<'
        if j - 1 >= 0:
            yield idx - 1
    if cols[j] == 'v':
        if i + 1 < n:
            yield idx + m
    else:  # '^'
        if i - 1 >= 0:
            yield idx - m

def bfs_ok(n, m, rows, cols, start_idx):
    N = n * m
    vis = [False] * N
    dq = deque([start_idx])
    vis[start_idx] = True
    seen = 1
    while dq:
        u = dq.popleft()
        for v in neigh_idx(n, m, rows, cols, u):
            if not vis[v]:
                vis[v] = True
                seen += 1
                dq.append(v)
    return seen == N

def solve_case(n, m, rows, cols) -> str:
    N = n * m
    for s in range(N):
        if not bfs_ok(n, m, rows, cols, s):
            return "NO\n"
    return "YES\n"

def solve_all():
    n, m, rows, cols = read_input()
    sys.stdout.write(solve_case(n, m, rows, cols))

def _solve_io(s: str) -> str:
    n, m, rows, cols = read_input(s)
    return solve_case(n, m, rows, cols)

# Checks
assert _solve_io("2 2\n><\n^v\n") == "YES\n"
assert _solve_io("2 2\n>>\nvv\n") == "NO\n"
assert _solve_io("3 2\n<>\n^^\n") == "NO\n"

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Positive 2x2 cycle; negatives where all rows/cols point one way or corners become sinks.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{SCC Check via Two Traversals (Kosaraju Idea)}
\WHICHFORMULA{A directed graph is strongly connected iff (i) all vertices are reachable from a fixed source $s$ and (ii) all vertices can reach $s$ (equivalently, all vertices are reachable from $s$ in the transpose graph). Perform two graph traversals with implicit neighbors and reverse-neighbors.}
\ASSUMPTIONS{The implicit graph provides $O(1)$-time neighbor generation; we do not materialize adjacency lists.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pick $s=(0,0)$. DFS/BFS using forward neighbors; if not all $n m$ visited, print NO.
\item DFS/BFS using reverse neighbors (transpose); if not all visited, print NO.
\item Otherwise, print YES.
\end{algosteps}
\OPTIMALITY{This uses exactly two traversals over $V$ and $E$ with $O(n m)$ memory, which is asymptotically optimal for connectivity on this graph.}
\COMPLEXITY{$T=O(|V|+|E|)=O(n m)$; $S=O(n m)$.}
\[
\begin{aligned}
T(n,m) &= O(n m), \quad S(n,m) = O(n m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str | None = None):
    if data is None:
        toks = sys.stdin.read().strip().split()
    else:
        toks = data.strip().split()
    n = int(toks[0]); m = int(toks[1])
    rows = toks[2].strip(); cols = toks[3].strip()
    assert len(rows) == n and len(cols) == m
    return n, m, rows, cols

def fwd_neighbors_idx(n, m, rows, cols, idx):
    i, j = divmod(idx, m)
    if rows[i] == '>':
        if j + 1 < m:
            yield idx + 1
    else:  # '<'
        if j - 1 >= 0:
            yield idx - 1
    if cols[j] == 'v':
        if i + 1 < n:
            yield idx + m
    else:  # '^'
        if i - 1 >= 0:
            yield idx - m

def rev_neighbors_idx(n, m, rows, cols, idx):
    i, j = divmod(idx, m)
    # reverse horizontal
    if rows[i] == '>':
        if j - 1 >= 0:
            yield idx - 1
    else:  # '<'
        if j + 1 < m:
            yield idx + 1
    # reverse vertical
    if cols[j] == 'v':
        if i - 1 >= 0:
            yield idx - m
    else:  # '^'
        if i + 1 < n:
            yield idx + m

def bfs_count(n, m, rows, cols, start_idx, use_reverse=False):
    N = n * m
    vis = [False] * N
    dq = deque([start_idx])
    vis[start_idx] = True
    seen = 1
    step = rev_neighbors_idx if use_reverse else fwd_neighbors_idx
    while dq:
        u = dq.popleft()
        for v in step(n, m, rows, cols, u):
            if not vis[v]:
                vis[v] = True
                seen += 1
                dq.append(v)
    return seen

def solve_case(n, m, rows, cols) -> str:
    N = n * m
    start = 0  # (0,0)
    if bfs_count(n, m, rows, cols, start, use_reverse=False) != N:
        return "NO\n"
    if bfs_count(n, m, rows, cols, start, use_reverse=True) != N:
        return "NO\n"
    return "YES\n"

def solve_all():
    n, m, rows, cols = read_input()
    sys.stdout.write(solve_case(n, m, rows, cols))

def _solve_io(s: str) -> str:
    n, m, rows, cols = read_input(s)
    return solve_case(n, m, rows, cols)

# Exactly 3 asserts
assert _solve_io("2 2\n><\n^v\n") == "YES\n"
assert _solve_io("2 2\n>>\nvv\n") == "NO\n"
assert _solve_io("3 3\n><>\n^v^\n") in ("YES\n", "NO\n")  # sanity: valid input, deterministic

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Three asserts: a positive 2x2 cycle; a negative all-one-way flow; a sanity deterministic check on a valid 3x3 input.}
\RESULT{Print \texttt{YES} iff the grid-induced directed graph is strongly connected; otherwise \texttt{NO}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test small grids exhaustively for $n,m \in \{2,3\}$; include corner-outdegree checks; cross-check BFS-everywhere vs. two-traversal SCC.}
\LINE{CROSS-CHECKS}{For each small instance, compare outputs of Approach A and Approach C; they must match.}
\LINE{EDGE-CASE GENERATOR}{Enumerate all direction strings for small $n,m$ to exercise corners, border-only moves, and alternating patterns.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from itertools import product

def all_patterns(n, m):
    for rows in product('<>', repeat=n):
        for cols in product('^v', repeat=m):
            yield ''.join(rows), ''.join(cols)

def brute_A(n, m, rows, cols):
    # reuse baseline logic (inline)
    from collections import deque
    def neigh(i, j):
        if rows[i] == '>':
            if j + 1 < m: yield (i, j + 1)
        else:
            if j - 1 >= 0: yield (i, j - 1)
        if cols[j] == 'v':
            if i + 1 < n: yield (i + 1, j)
        else:
            if i - 1 >= 0: yield (i - 1, j)
    def reach(si, sj):
        vis = [[False]*m for _ in range(n)]
        dq = deque([(si, sj)]); vis[si][sj] = True; seen = 1
        while dq:
            i, j = dq.popleft()
            for ni, nj in neigh(i, j):
                if not vis[ni][nj]:
                    vis[ni][nj] = True; seen += 1; dq.append((ni, nj))
        return seen == n * m
    for i in range(n):
        for j in range(m):
            if not reach(i, j):
                return False
    return True

def kosaraju_C(n, m, rows, cols):
    # reuse final logic (inline)
    from collections import deque
    N = n * m
    def fwd(u):
        i, j = divmod(u, m)
        if rows[i] == '>':
            if j + 1 < m: yield u + 1
        else:
            if j - 1 >= 0: yield u - 1
        if cols[j] == 'v':
            if i + 1 < n: yield u + m
        else:
            if i - 1 >= 0: yield u - m
    def rev(u):
        i, j = divmod(u, m)
        if rows[i] == '>':
            if j - 1 >= 0: yield u - 1
        else:
            if j + 1 < m: yield u + 1
        if cols[j] == 'v':
            if i - 1 >= 0: yield u - m
        else:
            if i + 1 < n: yield u + m
    def count(start, step):
        vis = [False]*N
        dq = deque([start]); vis[start] = True; seen = 1
        while dq:
            u = dq.popleft()
            for v in step(u):
                if not vis[v]:
                    vis[v] = True; seen += 1; dq.append(v)
        return seen
    return (count(0, fwd) == N) and (count(0, rev) == N)

def cross_check():
    for n in (2, 3):
        for m in (2, 3):
            for rows, cols in all_patterns(n, m):
                a = brute_A(n, m, rows, cols)
                c = kosaraju_C(n, m, rows, cols)
                assert a == c
    # Spot checks
    assert kosaraju_C(2, 2, '><', '^v') is True
    assert kosaraju_C(2, 2, '<<', '^^') is False

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Codeforces 475B — Strongly Connected City
# Final solution: SCC check via two traversals (implicit neighbors)
import sys
from collections import deque

def read_input(data: str | None = None):
    if data is None:
        toks = sys.stdin.read().strip().split()
    else:
        toks = data.strip().split()
    n = int(toks[0]); m = int(toks[1])
    rows = toks[2].strip(); cols = toks[3].strip()
    assert len(rows) == n and len(cols) == m
    return n, m, rows, cols

def fwd_neighbors_idx(n, m, rows, cols, idx):
    i, j = divmod(idx, m)
    if rows[i] == '>':
        if j + 1 < m:
            yield idx + 1
    else:
        if j - 1 >= 0:
            yield idx - 1
    if cols[j] == 'v':
        if i + 1 < n:
            yield idx + m
    else:
        if i - 1 >= 0:
            yield idx - m

def rev_neighbors_idx(n, m, rows, cols, idx):
    i, j = divmod(idx, m)
    if rows[i] == '>':
        if j - 1 >= 0:
            yield idx - 1
    else:
        if j + 1 < m:
            yield idx + 1
    if cols[j] == 'v':
        if i - 1 >= 0:
            yield idx - m
    else:
        if i + 1 < n:
            yield idx + m

def bfs_count(n, m, rows, cols, start_idx, use_reverse=False):
    N = n * m
    vis = [False] * N
    dq = deque([start_idx])
    vis[start_idx] = True
    seen = 1
    step = rev_neighbors_idx if use_reverse else fwd_neighbors_idx
    while dq:
        u = dq.popleft()
        for v in step(n, m, rows, cols, u):
            if not vis[v]:
                vis[v] = True
                seen += 1
                dq.append(v)
    return seen

def solve_case(n, m, rows, cols) -> str:
    N = n * m
    start = 0
    if bfs_count(n, m, rows, cols, start, use_reverse=False) != N:
        return "NO\n"
    if bfs_count(n, m, rows, cols, start, use_reverse=True) != N:
        return "NO\n"
    return "YES\n"

def solve_all():
    n, m, rows, cols = read_input()
    sys.stdout.write(solve_case(n, m, rows, cols))

def _solve_io(s: str) -> str:
    n, m, rows, cols = read_input(s)
    return solve_case(n, m, rows, cols)

# Asserts (deterministic)
assert _solve_io("2 2\n><\n^v\n") == "YES\n"
assert _solve_io("2 2\n>>\nvv\n") == "NO\n"
assert _solve_io("3 3\n>>>\n^^^\n") == "NO\n"

if __name__ == "__main__":
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Check if a directed grid, where each row and column is uniformly oriented, is strongly connected.}
\WHY{Tests modeling, graph construction, and SCC reasoning under tight time constraints.}
\CHECKLIST{
- Parse $n,m$, strings $R$ and $C$ of correct lengths.
- Define forward and reverse neighbor functions correctly at boundaries.
- Run one traversal on $G$ and one on $G^\top$ from the same source.
- Compare visited counts to $n m$.
- Print exactly \texttt{YES}/\texttt{NO} with newline.
}
\EDGECASES{
- Corners with zero out-degree if $R_1=\texttt{<}$ and $C_1=\^{}$ (top-left), etc.
- All rows pointing same way or all columns pointing same way.
- $n=2$ or $m=2$ minimal sizes.
- Alternating patterns that create cycles vs. sinks.
- Leading/trailing whitespace in input.
- Strings not matching lengths $n$ or $m$.
}
\PITFALLS{
- Mixing up reverse edges: reverse of `\texttt{>}' along row is move left; reverse of `\texttt{v}' along column is move up.
- Off-by-one at borders (ensure indices stay within $[0..n-1]$, $[0..m-1]$).
- Forgetting to include both traversals (forward only is insufficient).
- Using recursion depth for DFS in Python (prefer BFS or iterative DFS).
- Not flushing newline at the end or extra spaces in output.
- Misreading order of input lines.
}
\FAILMODES{Heuristics like ``both directions appear'' are insufficient; small counterexamples exist. The two-traversal SCC test correctly handles all cases.}
\ELI{Turn the city into a directed graph: each junction points along its row and its column according to arrows. If from the top-left we can reach all nodes and, in the reversed directions, also reach all nodes, then everyone can reach everyone.}
\NotePages{3}

\end{document}