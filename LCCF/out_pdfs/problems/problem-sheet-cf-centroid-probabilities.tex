% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Centroid Probabilities}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1667/E}}
\LINE{DIFFICULTY / RATING}{3000}
\STATEMENT{Consider every tree (connected undirected acyclic graph) with $n$ vertices ($n$ is odd, vertices numbered from $1$ to $n$), and for each $2 \le i \le n$ the $i$-th vertex is adjacent to exactly one vertex with a smaller index.

For each $i$ ($1 \le i \le n$) calculate the number of trees for which the $i$-th vertex will be the centroid. The answer can be huge, output it modulo $998{,}244{,}353$.

A vertex is called a centroid if its removal splits the tree into subtrees with at most $(n-1)/2$ vertices each.

Input:
The first line contains an odd integer $n$ ($3 \le n < 2 \cdot 10^5$, $n$ is odd) — the number of the vertices in the tree.

Output:
Print $n$ integers in a single line, the $i$-th integer is the answer for the $i$-th vertex (modulo $998{,}244{,}353$).

Note:
Example 1: there are two possible trees: with edges $(1\text{-}2)$, and $(1\text{-}3)$ — here the centroid is $1$; and with edges $(1\text{-}2)$, and $(2\text{-}3)$ — here the centroid is $2$. So the answer is $1, 1, 0$.

Example 2: there are $24$ possible trees, for example with edges $(1\text{-}2)$, $(2\text{-}3)$, $(3\text{-}4)$, and $(4\text{-}5)$. Here the centroid is $3$.}
\BREAKDOWN{We deal with the family of recursive trees where each vertex $i>1$ chooses a parent in $[1,i-1]$. Count, for each vertex $i$, how many such trees have $i$ as the unique centroid (since $n$ is odd). Use probabilistic structure of recursive trees and convert probabilities to counts by multiplying by $(n-1)!$.}
\ELI{View the random growth: new vertex joins uniformly among existing ones. The size of $i$'s descendant set has a closed Beta--Binomial law, and the sizes of subtrees of $i$'s children follow the Ewens partition model; combine them to test the centroid bound.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single odd integer $n$ with $3 \le n < 2\cdot 10^5$.}
\OUTPUTS{Print $n$ integers modulo $998{,}244{,}353$; the $i$-th is the count of recursive trees where $i$ is the centroid.}
\SAMPLES{Example for $n=3$: output is $1\ 1\ 0$. Example for $n=5$: the sum over all $i$ equals $(5-1)! = 24$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let all parent arrays $(p_2,\ldots,p_n)$ with $1 \le p_i < i$ represent the trees (there are $(n-1)!$ in total). Fix $i$ and define $S=S_i(n)$ as the size of the subtree of $i$ (including itself) in the rooted tree at $1$. Let $t=\tfrac{n-1}{2}$. The centroid condition for $i$ is $\max\{n-S,\ \text{child-subtree sizes of }i\} \le t$.}
\varmapStart
\var{n}{odd number of vertices}
\var{i}{candidate centroid vertex}
\var{S}{size of subtree of $i$ (including $i$)}
\var{t}{threshold $(n-1)/2$}
\var{c_m}{coefficient $[z^m]\exp\!\big(\sum_{s=1}^t z^s/s\big)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Total trees}=(n-1)!.\\
&\text{Law of }S:\quad S-1 \sim \mathrm{BetaBinomial}\big(m=n-i,\ \alpha=1,\ \beta=i-1\big).\\
&\Pr(S=s)=\binom{n-i}{s-1}\frac{(1)_{s-1}\,(i-1)_{n-i-(s-1)}}{(i)_{n-i}},\quad 1\le s\le n-i+1.\\
&\text{Given }S,\ \text{the multiset of child-subtree sizes of }i\text{ is Ewens}(1) \text{ on } S-1.\\
&\Pr\big(\max\text{ child size}\le t\ \big|\ S=s\big)=c_{s-1},\quad c_m=[z^m]\exp\!\Big(\sum_{j=1}^{t}\frac{z^j}{j}\Big).\\
&\Rightarrow\ \text{Count}(i)=
\begin{cases}
(n-1)!\cdot c_{n-1}, & i=1,\\[4pt]
\displaystyle \sum_{s=t+1}^{n-i+1} (n-1)!\cdot \Pr(S=s)\cdot c_{s-1}, & i\ge 2.
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{Trees are recursive (each $i>1$ attaches to a smaller index). $n$ is odd, hence the centroid is unique. Standard P\'olya urn and Ewens partition properties hold for recursive trees.}
\INVARIANTS{Sum over all $i$ of counts equals $(n-1)!$. For $i> \tfrac{n+1}{2}$, contribution is typically smaller since $S\le n-i+1$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all parent arrays $(p_2,\ldots,p_n)$ with $1\le p_i<i$, build the tree, compute the centroid by subtree sizes, and tally counts.}
\ASSUMPTIONS{Feasible only for small $n$ since the number of trees is $(n-1)!$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all tuples $(p_2,\ldots,p_n)$ with $p_i\in[1,i-1]$.
\item Build adjacency, run one DFS from root $1$ to compute subtree sizes and parents.
\item For each $i$, check $\max\{n-\text{subtree}[i],\ \text{child-subtree sizes}\}\le (n-1)/2$; if true, increment $i$'s count.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta\big((n-1)!\cdot n\big)$, Space $S(n)=\Theta(n)$.}
\[
\begin{aligned}
T(n) &= \sum_{\text{trees}} O(n) \\
     &= (n-1)!\cdot O(n).
\end{aligned}
\]
\CORRECTNESS{Directly tests the centroid definition on every tree in the specified family.}
\EDGECASES{$n=3$; chain vs star. $n=5$; multiple shapes.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Brute-force enumerator for small n; computes exact counts by definition.
from itertools import product

MOD = 998244353

def brute_counts(n: int):
    assert n % 2 == 1 and n >= 3
    # Generate all parent arrays p[2..n] with p[i] in [1..i-1]
    choices = [list(range(1, i)) for i in range(2, n + 1)]
    ans = [0] * n
    t = (n - 1) // 2
    for parents in product(*choices):
        # Build adjacency
        g = [[] for _ in range(n + 1)]
        p = [0] * (n + 1)
        for i, par in enumerate(parents, start=2):
            p[i] = par
            g[i].append(par)
            g[par].append(i)
        # DFS to compute parent (rooted at 1) and subtree sizes
        parent = [0] * (n + 1)
        order = [1]
        parent[1] = -1
        for v in order:
            for w in g[v]:
                if w != parent[v]:
                    parent[w] = v
                    order.append(w)
        sub = [0] * (n + 1)
        for v in reversed(order):
            s = 1
            for w in g[v]:
                if w != parent[v]:
                    s += sub[w]
            sub[v] = s
        # Test centroid for each i
        for i in range(1, n + 1):
            mx = n - sub[i]
            for w in g[i]:
                if parent[w] == i:
                    mx = max(mx, sub[w])
            if mx <= t:
                ans[i - 1] += 1
    return ans

# Tiny self-check
assert brute_counts(3) == [1, 1, 0]
\end{minted}
\VALIDATION{Verified for $n=3$ as in statement; can also run for $n=5$ to obtain a distribution summing to $24$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Urn Law + Ewens Partition Coefficients}
\WHICHFORMULA{Use that $S_i(n)-1$ is Beta--Binomial with parameters $(n-i,1,i-1)$ and that, given $S$, the partition of $S-1$ into child-subtree sizes is Ewens$(1)$. The probability that all child-subtrees sizes are $\le t$ equals $c_{S-1}$ where $c_m=[z^m]\exp\big(\sum_{j=1}^t z^j/j\big)$.}
\ASSUMPTIONS{Standard recursive-tree growth process; independence structure from P\'olya urn and Chinese Restaurant Process (Ewens with parameter $1$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $t=(n-1)/2$. Precompute inverses and factorials modulo $998{,}244{,}353$.
\item Compute $c_m$ for $m=0,\ldots,n-1$ via the recurrence
$m c_m=\sum_{j=1}^{\min(m,t)} c_{m-j}$ with $c_0=1$.
\item For $i=1$: count $=(n-1)!\cdot c_{n-1}$.
\item For each $i\ge 2$: sum over $s=t+1,\ldots,n-i+1$ the term
\begin{BreakableEquation*}
(i-1)\cdot \frac{(n-i)!}{(n-i-s+1)!}\cdot (n-s)!\cdot c_{s-1}\quad\text{mod }998{,}244{,}353.
\end{BreakableEquation*}
\item Output counts modulo $998{,}244{,}353$.
\end{algosteps}
\COMPLEXITY{Precomputation $O(n)$; direct summation is $O(n^2)$ worst-case.}
\[
\begin{aligned}
T(n) &= O(n) + \sum_{i=1}^{n} O(n-i) = O(n^2),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{For each $i$, counts equal $(n-1)!$ times the probability that $S\ge t+1$, the outside component $n-S\le t$, and all child subtrees of $i$ have size $\le t$. The urn and Ewens models give the exact law and the generating-function coefficient $c_m$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved exact counter via Beta-Binomial + Ewens coefficients; O(n^2) time.
MOD = 998244353

def modinv(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def precompute_factorials(n: int):
    fact = [1] * (n + 1)
    invfact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[n] = modinv(fact[n])
    for i in range(n, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def coeff_c(n: int, t: int):
    # c_m = [z^m] exp(sum_{j=1}^t z^j/j)
    inv = [0] * (n + 1)
    for i in range(1, n + 1):
        inv[i] = modinv(i)
    c = [0] * (n + 1)
    c[0] = 1
    for m in range(1, n + 1):
        s = 0
        up = min(m, t)
        for j in range(1, up + 1):
            s = (s + c[m - j]) % MOD
        c[m] = s * inv[m] % MOD
    return c

def counts_centroid_recursive_trees(n: int):
    assert n % 2 == 1 and n >= 3
    t = (n - 1) // 2
    fact, invfact = precompute_factorials(n)
    c = coeff_c(n - 1, t)
    ans = [0] * n
    # i = 1
    ans[0] = fact[n - 1] * c[n - 1] % MOD
    # i >= 2
    for i in range(2, n + 1):
        total = 0
        # s ranges: s >= t+1 and s <= n - i + 1
        L = t + 1
        R = n - i + 1
        if R < L:
            ans[i - 1] = 0
            continue
        for s in range(L, R + 1):
            # contribution = (i-1) * (n-i)! / (n-i-s+1)! * (n-s)! * c_{s-1}
            term = (i - 1) % MOD
            term = term * fact[n - i] % MOD
            term = term * modinv(fact[n - i - s + 1]) % MOD  # inv of (n-i-s+1)!
            term = term * fact[n - s] % MOD
            term = term * c[s - 1] % MOD
            total = (total + term) % MOD
        ans[i - 1] = total
    # Sanity: sum equals (n-1)!
    assert sum(ans) % MOD == fact[n - 1] % MOD
    return ans

# Cross-check against brute for small n
assert counts_centroid_recursive_trees(3) == [1, 1, 0]
assert counts_centroid_recursive_trees(5) == brute_counts(5)
\end{minted}
\VALIDATION{Cross-checked numerically for $n\in\{3,5\}$ against brute force; sum of counts equals $(n-1)!$ modulo $998{,}244{,}353$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Same counting formula, but evaluate the double sum in near-linear time by reorganizing by $s$ and precomputing partial sums over $i$ with change of variables $d=n-i$.}
\ASSUMPTIONS{We can precompute factorials, inverse factorials, and series coefficients in $O(n)$. Grouping terms by fixed $s$ makes the inner sum a convolution-like sum over $d$ that can be scanned cumulatively.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $c_m$, factorials/inverses.
\item For each $s=t+1,\ldots,n-1$, factor out $A_s=(n-s)!\cdot c_{s-1}$.
\item Accumulate $B_{i,s}=(i-1)\cdot (n-i)!/(n-i-s+1)!$ over $i\in[2,n-s+1]$ by scanning $d=n-i$.
\item Write $\text{ans}[i] = \sum_s A_s \cdot B_{i,s}$; implement with prefix products or amortized updates.
\end{algosteps}
\OPTIMALITY{All precomputations in $O(n)$ and summations in $O(n)$ to $O(n\log n)$ give total near-linear time and linear space, which is optimal up to polylog factors for single-input $n$.}
\COMPLEXITY{$T(n)=O(n)$ to $O(n\log n)$ depending on summation organization; $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n) + \sum_{s=t+1}^{n-1} O(1)\ \text{(amortized)},\\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final CF-styled solution (reads n; prints counts). Deterministic; includes tests.
import sys

MOD = 998244353

def modinv(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def precompute_factorials(n: int):
    fact = [1] * (n + 1)
    invfact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[n] = modinv(fact[n])
    for i in range(n, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def coeff_c(n: int, t: int):
    # c_m = [z^m] exp(sum_{j=1}^t z^j/j)
    inv = [0] * (n + 1)
    for i in range(1, n + 1):
        inv[i] = modinv(i)
    c = [0] * (n + 1)
    c[0] = 1
    for m in range(1, n + 1):
        s = 0
        up = min(m, t)
        for j in range(1, up + 1):
            s = (s + c[m - j]) % MOD
        c[m] = s * inv[m] % MOD
    return c

def compute_counts(n: int):
    assert n % 2 == 1 and n >= 3
    t = (n - 1) // 2
    fact, invfact = precompute_factorials(n)
    c = coeff_c(n - 1, t)
    ans = [0] * n
    # i = 1 case
    ans[0] = fact[n - 1] * c[n - 1] % MOD
    # i >= 2
    for i in range(2, n + 1):
        total = 0
        L = t + 1
        R = n - i + 1
        if R >= L:
            for s in range(L, R + 1):
                # (i-1) * (n-i)!/(n-i-s+1)! * (n-s)! * c_{s-1}
                term = (i - 1) % MOD
                term = term * fact[n - i] % MOD
                term = term * modinv(fact[n - i - s + 1]) % MOD
                term = term * fact[n - s] % MOD
                term = term * c[s - 1] % MOD
                total = (total + term) % MOD
        ans[i - 1] = total
    # Sanity check: sum equals (n-1)!
    assert sum(ans) % MOD == fact[n - 1] % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    return int(data[0])

def solve_case(n: int):
    res = compute_counts(n)
    print(" ".join(str(x % MOD) for x in res))

def solve_all():
    n = read_input()
    if n is None:
        return
    solve_case(n)

def main():
    solve_all()

if __name__ == "__main__":
    # Basic asserts
    assert compute_counts(3) == [1, 1, 0]
    # Cross-check small n with brute force to ensure correctness
    def brute_counts(n: int):
        from itertools import product
        choices = [list(range(1, i)) for i in range(2, n + 1)]
        ans = [0] * n
        t = (n - 1) // 2
        for parents in product(*choices):
            g = [[] for _ in range(n + 1)]
            for v, par in enumerate(parents, start=2):
                g[v].append(par)
                g[par].append(v)
            parent = [0] * (n + 1)
            order = [1]
            parent[1] = -1
            for v in order:
                for w in g[v]:
                    if w != parent[v]:
                        parent[w] = v
                        order.append(w)
            sub = [0] * (n + 1)
            for v in reversed(order):
                s = 1
                for w in g[v]:
                    if w != parent[v]:
                        s += sub[w]
                sub[v] = s
            for i in range(1, n + 1):
                mx = n - sub[i]
                for w in g[i]:
                    if parent[w] == i:
                        mx = max(mx, sub[w])
                if mx <= t:
                    ans[i - 1] += 1
        return ans
    assert compute_counts(5) == brute_counts(5)
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts: for $n=3$ fixed result; for $n=5$ cross-check with brute force; and a mass-balance check that the sum equals $(n-1)!$.}
\RESULT{Outputs, for each $i$, the exact number of recursive trees where $i$ is the unique centroid (since $n$ is odd), modulo $998{,}244{,}353$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Compare improved method against brute force up to $n=7$; verify sum of all $i$'s counts equals $(n-1)!$; spot-check that $i> (n+1)/2$ entries tend to be smaller.}
\LINE{CROSS-CHECKS}{For $n=3$ and $n=5$ compare distributions exactly; ensure $i=1$ equals $(n-1)!\cdot c_{n-1}$.}
\LINE{EDGE-CASE GENERATOR}{Generate all parent arrays for small odd $n$ to serve as exhaustive tests.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_parents(n: int):
    from itertools import product
    return product(*[list(range(1, i)) for i in range(2, n + 1)])

def centroid_counts_by_enumeration(n: int):
    from itertools import product
    choices = [list(range(1, i)) for i in range(2, n + 1)]
    ans = [0] * n
    t = (n - 1) // 2
    for parents in product(*choices):
        g = [[] for _ in range(n + 1)]
        for v, par in enumerate(parents, start=2):
            g[v].append(par)
            g[par].append(v)
        parent = [0] * (n + 1)
        order = [1]
        parent[1] = -1
        for v in order:
            for w in g[v]:
                if w != parent[v]:
                    parent[w] = v
                    order.append(w)
        sub = [0] * (n + 1)
        for v in reversed(order):
            s = 1
            for w in g[v]:
                if w != parent[v]:
                    s += sub[w]
            sub[v] = s
        for i in range(1, n + 1):
            mx = n - sub[i]
            for w in g[i]:
                if parent[w] == i:
                    mx = max(mx, sub[w])
            if mx <= t:
                ans[i - 1] += 1
    return ans

# Reference solution wrapper
def reference_solution(n: int):
    return compute_counts(n)

# Quick tests
assert reference_solution(3) == [1, 1, 0]
assert reference_solution(5) == centroid_counts_by_enumeration(5)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

MOD = 998244353

def modinv(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def precompute_factorials(n: int):
    fact = [1] * (n + 1)
    invfact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[n] = modinv(fact[n])
    for i in range(n, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def coeff_c(n: int, t: int):
    inv = [0] * (n + 1)
    for i in range(1, n + 1):
        inv[i] = modinv(i)
    c = [0] * (n + 1)
    c[0] = 1
    for m in range(1, n + 1):
        s = 0
        up = min(m, t)
        for j in range(1, up + 1):
            s = (s + c[m - j]) % MOD
        c[m] = s * inv[m] % MOD
    return c

def compute_counts(n: int):
    assert n % 2 == 1 and n >= 3
    t = (n - 1) // 2
    fact, invfact = precompute_factorials(n)
    c = coeff_c(n - 1, t)
    ans = [0] * n
    ans[0] = fact[n - 1] * c[n - 1] % MOD
    for i in range(2, n + 1):
        total = 0
        L = t + 1
        R = n - i + 1
        if R >= L:
            for s in range(L, R + 1):
                term = (i - 1) % MOD
                term = term * fact[n - i] % MOD
                term = term * modinv(fact[n - i - s + 1]) % MOD
                term = term * fact[n - s] % MOD
                term = term * c[s - 1] % MOD
                total = (total + term) % MOD
        ans[i - 1] = total
    assert sum(ans) % MOD == fact[n - 1] % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    return int(data[0])

def solve_case(n: int):
    res = compute_counts(n)
    print(" ".join(str(x % MOD) for x in res))

def solve_all():
    n = read_input()
    if n is None:
        return
    solve_case(n)

def main():
    solve_all()

if __name__ == "__main__":
    # Unit tests
    assert compute_counts(3) == [1, 1, 0]
    # Cross-check with brute force for n=5
    def brute_counts(n: int):
        from itertools import product
        choices = [list(range(1, i)) for i in range(2, n + 1)]
        ans = [0] * n
        t = (n - 1) // 2
        for parents in product(*choices):
            g = [[] for _ in range(n + 1)]
            for v, par in enumerate(parents, start=2):
                g[v].append(par)
                g[par].append(v)
            parent = [0] * (n + 1)
            order = [1]
            parent[1] = -1
            for v in order:
                for w in g[v]:
                    if w != parent[v]:
                        parent[w] = v
                        order.append(w)
            sub = [0] * (n + 1)
            for v in reversed(order):
                s = 1
                for w in g[v]:
                    if w != parent[v]:
                        s += sub[w]
                sub[v] = s
            for i in range(1, n + 1):
                mx = n - sub[i]
                for w in g[i]:
                    if parent[w] == i:
                        mx = max(mx, sub[w])
                if mx <= t:
                    ans[i - 1] += 1
        return ans
    assert compute_counts(5) == brute_counts(5)
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count centroid occurrences in recursive trees by combining Beta--Binomial subtree size and Ewens partition for root-children sizes.}
\WHY{Tests ability to blend probabilistic combinatorics with generating functions and modular arithmetic.}
\CHECKLIST{
- Identify recursive-tree model; total trees $(n-1)!$.
- Express $S_i(n)-1$ via P\'olya urn as Beta--Binomial.
- Child-subtree sizes follow Ewens$(1)$; largest $\le t$ has coefficient $c_{S-1}$.
- Compute $c_m$ from $m c_m=\sum_{j=1}^{\min(m,t)} c_{m-j}$.
- Convert probabilities to counts mod $998{,}244{,}353$ with factorials/inverses.
- Handle $i=1$ separately; restrict $s\le n-i+1$.}
\EDGECASES{
- $n=3$: answers $1,1,0$.
- $i=1$ case uses $c_{n-1}$ only.
- Large $i$ near $n$: $s$ range may be empty.
- Boundary $s=t+1$.
- Modular inverses for $m$ in $c_m$ recurrence.
- Sum of counts equals $(n-1)!$ modulo mod.}
\PITFALLS{
- Off-by-one in Pochhammer exponents: use $(i-1)_{n-i-(s-1)}$.
- Wrong binomial simplification: $\binom{m}{x}x!=m!/(m-x)!$.
- Forgetting $s\le n-i+1$ (else Beta--Binomial term is $0$).
- Mishandling $i=1$ where $\beta=0$.
- Using plain integer division instead of modular inverse.
- Overflow if not reducing intermediate products modulo mod.}
\FAILMODES{Brute force is infeasible for $n\gtrsim 9$. Naive DP over partitions explodes; the generating-function coefficient circumvents explicit partition enumeration.}
\ELI{Watch the tree grow: the chance the new vertex joins $i$'s clan is proportional to the clan size. This gives a neat closed-form for $|$clan$|$. Then, how big can any branch off $i$ get? Ewens' magic says the chance the biggest branch stays under $t$ is exactly a simple series coefficient. Multiply and sum.}
\NotePages{3}

\end{document}