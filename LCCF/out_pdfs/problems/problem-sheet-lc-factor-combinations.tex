% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Factor Combinations}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/factor-combinations/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given an integer $n$. Return all possible combinations of its factors (excluding $1$ and $n$ itself) such that the product of the factors in each combination equals $n$. Each combination must be in non-decreasing order. Return the list of combinations in any order. If $n$ is prime or $n \le 3$, return an empty list.}
\BREAKDOWN{Generate all multiplicative partitions of $n$ using factors strictly between $2$ and $n-1$ while avoiding duplicates. Enforce non-decreasing order to ensure uniqueness and use recursion to build combinations.}
\ELI{Try to split $n$ into smaller factors step by step, always picking a factor at least as big as the previous one, and record each full split.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $n$ (typically $1 \le n \le 10^9$ on coding platforms).}
\OUTPUTS{A list of integer lists. Each inner list is a non-decreasing sequence of integers $\ge 2$ whose product equals $n$, with both $1$ and $n$ excluded as individual factors.}
\SAMPLES{
Example 1: $n=12 \to [[2,6],[3,4],[2,2,3]]$.\\
Example 2: $n=37 \to []$ (since $37$ is prime).
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathcal{F}(n)$ be the set of finite sequences $(f_1,\ldots,f_k)$ with $k \ge 2$, $2 \le f_1 \le \cdots \le f_k \le n-1$, and $\prod_{i=1}^k f_i = n$. The task is to enumerate all elements of $\mathcal{F}(n)$.}
\varmapStart
\var{n}{the given integer}
\var{f_i}{the $i$-th factor in a combination}
\var{r}{current remaining product to factor}
\var{s}{the smallest factor allowed next (to enforce non-decreasing order)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\mathcal{F}(n) &= \bigcup_{f \in [2,\lfloor \sqrt{n} \rfloor],\, f \mid n} \Big( \{(f,\tfrac{n}{f})\} \cup \big\{(f)\mathbin{\Vert}\mathbf{p} \,:\, \mathbf{p} \in \mathcal{F}_{\ge f}\big(\tfrac{n}{f}\big) \big\} \Big), \\
\mathcal{F}_{\ge s}(r) &= \bigcup_{f \in [s,\lfloor \sqrt{r} \rfloor],\, f \mid r} \Big( \{(f,\tfrac{r}{f})\} \cup \{(f)\mathbin{\Vert}\mathbf{p} : \mathbf{p} \in \mathcal{F}_{\ge f}(\tfrac{r}{f})\} \Big),
\end{aligned}
\]
where $\mathbf{p}$ denotes concatenation of sequences and non-decreasing order is preserved by requiring the next factor $\ge s$.}
\ASSUMPTIONS{We exclude $1$ and $n$ as singleton factors. Non-decreasing sequences uniquely represent combinations. We only need to try divisors up to $\lfloor\sqrt{r}\rfloor$ at each step; the paired cofactor is $\tfrac{r}{f} \ge f$.}
\INVARIANTS{
- Path non-decreasing: the partial sequence remains sorted, preventing duplicates.\\
- Product invariant: the product of the path times the current remainder equals $n$.\\
- Validity: every reported combination multiplies to $n$ and has length at least $2$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct recursive search that tries every candidate factor from $s$ up to $r-1$ when factoring remainder $r$, appending valid splits and recursing on the quotient.}
\ASSUMPTIONS{We still enforce non-decreasing order via the $s$ parameter to avoid duplicate permutations, but otherwise do not prune the search space aggressively.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n \le 3$, return empty.
\item Define DFS$(r, s, \text{path})$: for each integer $f$ from $s$ to $r-1$, if $f \mid r$, set $q=r/f$.
\item If $q \ge f$, record $\text{path}+[f,q]$; then recurse DFS$(q, f, \text{path}+[f])$.
\end{algosteps}
\COMPLEXITY{In the worst case, the loop up to $r-1$ makes the search superlinear and often near $O(n \log n)$ or worse, though output size dominates for composite $n$. Space is $O(\log n)$ recursion depth.}
\[
\begin{aligned}
T(n) &\approx \sum_{\text{nodes}} (r - s) \quad \text{with } r \text{ varying per node, often } \Theta(n) \text{ at the root},\\
S(n) &= O(\log n) \text{ (recursion) } + O(\text{output}).
\end{aligned}
\]
\CORRECTNESS{Non-decreasing order ensures each unique combination appears exactly once. Every time $f \mid r$, both the pair $[f,q]$ and deeper splits of $q$ are explored, so all factorizations are covered.}
\EDGECASES{Prime $n$ returns empty; $n \le 3$ returns empty; powers like $n=2^k$ produce chains $[2,2,\ldots,2]$ and their grouped variants; avoid using $1$ or $n$ as standalone factors.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def getFactors(self, n: int) -> List[List[int]]:
        res: List[List[int]] = []
        if n <= 3:
            return res

        def dfs(rem: int, start: int, path: List[int]) -> None:
            # Try every possible factor from 'start' to 'rem-1' (very slow).
            for f in range(start, rem):
                if rem % f == 0:
                    q = rem // f
                    if q >= f:
                        res.append(path + [f, q])
                        # Continue factoring the quotient, keeping non-decreasing order.
                        dfs(q, f, path + [f])

        dfs(n, 2, [])
        return res


if __name__ == "__main__":
    s = Solution()

    def norm(ans: List[List[int]]) -> List[Tuple[int, ...]]:
        # Normalize for comparison: sort each combo, then sort the list.
        return sorted(tuple(sorted(x)) for x in ans)

    # Tiny checks
    assert norm(s.getFactors(1)) == []
    assert norm(s.getFactors(12)) == sorted([tuple(x) for x in [[2, 6], [3, 4], [2, 2, 3]]])
    assert norm(s.getFactors(37)) == []
\end{minted}
\VALIDATION{The asserts check empty for $1$ and primes; verify canonical cases like $12$. This baseline is correct but slow for large $n$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Search Using Square-Root Pruning}
\WHICHFORMULA{At remainder $r$, try factors only up to $\lfloor\sqrt{r}\rfloor$, since any factor above that would pair with a below-$\sqrt{r}$ cofactor already considered. Immediately add the pair $[f, r/f]$ and recurse on the quotient.}
\ASSUMPTIONS{Maintain non-decreasing order with a start boundary $s$; use integer arithmetic and the $f \cdot f \le r$ loop to avoid computing square roots and to prune aggressively.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n \le 3$, return empty.
\item DFS$(r, s, \text{path})$: for $f$ from $s$ while $f \cdot f \le r$:
\item If $f \mid r$, set $q=r/f$, push $\text{path}+[f,q]$, then recurse DFS$(q, f, \text{path}+[f])$.
\end{algosteps}
\COMPLEXITY{This explores only valid splitting points. The loop at each node is bounded by $\lfloor\sqrt{r}\rfloor$, so time is near output-sensitive. Space remains $O(\log n)$ for recursion plus output.}
\[
\begin{aligned}
T(n) &\approx \sum_{\text{nodes}} O(\sqrt{r}) = O(\sqrt{n} + \text{output overhead}),\\
S(n) &= O(\log n) + O(\text{output}).
\end{aligned}
\]
\CORRECTNESS{Same invariants as the baseline; pruning does not skip any valid factor since every factor $> \sqrt{r}$ is paired with a factor $\le \sqrt{r}$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def getFactors(self, n: int) -> List[List[int]]:
        res: List[List[int]] = []
        if n <= 3:
            return res

        def dfs(rem: int, start: int, path: List[int]) -> None:
            f = start
            while f * f <= rem:
                if rem % f == 0:
                    q = rem // f
                    res.append(path + [f, q])
                    dfs(q, f, path + [f])
                f += 1

        dfs(n, 2, [])
        return res


if __name__ == "__main__":
    s = Solution()

    def norm(ans: List[List[int]]):
        return sorted(tuple(sorted(x)) for x in ans)

    assert norm(s.getFactors(12)) == sorted([tuple(x) for x in [[2, 6], [3, 4], [2, 2, 3]]])
    assert norm(s.getFactors(32)) == sorted([tuple(x) for x in [[2, 16], [4, 8], [2, 2, 8], [2, 4, 4], [2, 2, 2, 4], [2, 2, 2, 2, 2]]])
    assert norm(s.getFactors(37)) == []
\end{minted}
\VALIDATION{Checks common cases and a power ($32$) to confirm deeper recursion and multiple groupings are handled.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Square-Root DFS with Monotone Paths (Submission-Ready)}
\WHICHFORMULA{Use the DFS with divisor enumeration up to $\lfloor\sqrt{r}\rfloor$, record pairs immediately, and recurse on quotients with non-decreasing constraint. This is the standard optimal approach for enumerating multiplicative partitions in coding interviews.}
\ASSUMPTIONS{Single-query setting; trial division is sufficient. We rely on output-sensitivity and avoid generating permutations.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n \le 3$, return empty.
\item Start DFS with remainder $n$, minimum factor $2$, and empty path.
\item For each $f$ from $s$ while $f \cdot f \le r$: if $f \mid r$, add path $\cup [f, r/f]$, then DFS on $(r/f, f, \text{path}\cup[f])$.
\end{algosteps}
\OPTIMALITY{Any method must enumerate all valid combinations, so time $\Omega(\text{output})$. The square-root bound per node and non-decreasing order make the algorithm tight up to small polynomial factors.}
\COMPLEXITY{Time is output-sensitive with a per-level scanning cost $O(\sqrt{r})$, typically very fast for interview-sized inputs. Stack depth is bounded by the number of prime factors, $O(\log_2 n)$.}
\[
\begin{aligned}
T(n) &\in \Theta\!\big(\text{output} + \sum_{\text{nodes}} \sqrt{r}\big), \\
S(n) &= O(\log n) + O(\text{output}).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def getFactors(self, n: int) -> List[List[int]]:
        res: List[List[int]] = []
        if n <= 3:
            return res

        def dfs(rem: int, start: int, path: List[int]) -> None:
            f = start
            while f * f <= rem:
                if rem % f == 0:
                    q = rem // f
                    res.append(path + [f, q])
                    dfs(q, f, path + [f])
                f += 1

        dfs(n, 2, [])
        return res


if __name__ == "__main__":
    s = Solution()

    def as_set(ans: List[List[int]]) -> set:
        return set(tuple(x) for x in (sorted(c) for c in ans))

    # Exactly 3 asserts
    assert as_set(s.getFactors(12)) == as_set([[2, 6], [3, 4], [2, 2, 3]])
    assert as_set(s.getFactors(37)) == set()
    assert as_set(s.getFactors(32)) == as_set([[2, 16], [4, 8], [2, 2, 8], [2, 4, 4], [2, 2, 2, 4], [2, 2, 2, 2, 2]])
\end{minted}
\VALIDATION{The three asserts cover a composite with multiple shapes ($12$), a prime ($37$), and a prime power ($32$).}
\RESULT{Return all non-decreasing factor sequences (length $\ge 2$) whose product equals $n$, in any order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-check that every returned combination multiplies to $n$, is non-decreasing, excludes $1$ and $n$, and that primes yield empty lists. Compare against small handcrafted truths for $n \in \{12,16,18,24,32\}$.}
\LINE{CROSS-CHECKS}{On small $n$ (e.g., $n \le 100$), compare outputs of Baseline vs Improved vs Final for equality up to permutation.}
\LINE{EDGE-CASE GENERATOR}{Deterministically iterate $n$ from $1$ to $100$ and verify constraints on each generated combination.}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def getFactors(self, n: int) -> List[List[int]]:
        res: List[List[int]] = []
        if n <= 3:
            return res

        def dfs(rem: int, start: int, path: List[int]) -> None:
            f = start
            while f * f <= rem:
                if rem % f == 0:
                    q = rem // f
                    res.append(path + [f, q])
                    dfs(q, f, path + [f])
                f += 1

        dfs(n, 2, [])
        return res


if __name__ == "__main__":
    s = Solution()

    def is_non_decreasing(a: List[int]) -> bool:
        return all(a[i] <= a[i+1] for i in range(len(a) - 1))

    # Property checks on n in [1..100]
    for n in range(1, 101):
        ans = s.getFactors(n)
        if n <= 3:
            assert ans == []
        # Every combination valid
        for comb in ans:
            assert len(comb) >= 2
            assert is_non_decreasing(comb)
            assert 1 not in comb and n not in comb
            prod = 1
            for x in comb:
                prod *= x
            assert prod == n

    # Handcrafted cross-checks
    def as_set(ans: List[List[int]]) -> set:
        return set(tuple(x) for x in (sorted(c) for c in ans))

    assert as_set(s.getFactors(12)) == as_set([[2, 6], [3, 4], [2, 2, 3]])
    assert as_set(s.getFactors(16)) == as_set([[2, 8], [4, 4], [2, 2, 4], [2, 2, 2, 2]])
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def getFactors(self, n: int) -> List[List[int]]:
        # Output all non-decreasing sequences (len >= 2) of factors (>= 2, <= n-1) multiplying to n.
        res: List[List[int]] = []
        if n <= 3:
            return res

        def dfs(rem: int, start: int, path: List[int]) -> None:
            f = start
            while f * f <= rem:
                if rem % f == 0:
                    q = rem // f
                    res.append(path + [f, q])
                    dfs(q, f, path + [f])
                f += 1

        dfs(n, 2, [])
        return res


if __name__ == "__main__":
    s = Solution()
    # Spot checks
    def as_set(ans: List[List[int]]) -> set:
        return set(tuple(sorted(x)) for x in ans)

    assert as_set(s.getFactors(12)) == as_set([[2, 6], [3, 4], [2, 2, 3]])
    assert as_set(s.getFactors(37)) == set()
    assert as_set(s.getFactors(32)) == as_set([[2, 16], [4, 8], [2, 2, 8], [2, 4, 4], [2, 2, 2, 4], [2, 2, 2, 2, 2]])
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Enumerate all non-decreasing factor sequences (excluding $1$ and $n$) whose product equals $n$ via square-root-pruned DFS.}
\WHY{This tests multiplicative reasoning, recursion with constraints, and output-sensitive enumeration, common in medium-difficulty interviews.}
\CHECKLIST{
- Enforce non-decreasing order with a start bound. 
- Loop only while $f \cdot f \le r$.
- When $f \mid r$, record the pair $[f, r/f]$ and recurse on $r/f$.
- Stop early on $n \le 3$ or primes (naturally yields empty).
- No use of $1$ or $n$ as standalone factors.
}
\EDGECASES{
- $n \le 3 \Rightarrow []$. 
- Prime $n \Rightarrow []$. 
- Perfect squares (e.g., $16$) with repeated factors.
- Large prime power (e.g., $2^k$) producing long chains.
- $n$ with many small factors (e.g., $2 \cdot 3 \cdot 5 \cdot 7$).
- Ensure pair $[f, r/f]$ is captured before deeper recursion.}
\PITFALLS{
- Forgetting non-decreasing constraint leads to duplicate permutations.
- Iterating factors up to $r$ instead of $\sqrt{r}$ causes TLE.
- Not appending the immediate pair misses valid combinations.
- Allowing $1$ or $n$ into combinations violates the spec.
- Off-by-one in loop bounds ($f$ must start at $2$ or current $s$).
- Using floating-point $\sqrt{}$ with precision issues; prefer $f \cdot f \le r$.
}
\FAILMODES{Naive enumeration over $[2, r-1]$ is too slow for larger $n$. The square-root-pruned DFS avoids scanning factors that cannot exist and remains output-sensitive.}
\ELI{Keep chopping $n$ by small factors. Each time you cut $n$ by $f$, you also record the pair $[f, n/f]$ and keep cutting the quotient, never letting the next cut be smaller than the last. This finds each factorization once, efficiently.}
\NotePages{3}

\end{document}