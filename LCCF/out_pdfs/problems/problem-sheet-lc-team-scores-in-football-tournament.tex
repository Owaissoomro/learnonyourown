% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Team Scores in Football Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/team-scores-in-football-tournament/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Team Scores in Football Tournament — LeetCode.

You are given a football tournament with $n$ teams labeled from $1$ to $n$. A match is represented as a quadruple $[h, a, g_h, g_a]$ where $h$ is the home team id, $a$ is the away team id, $g_h$ is the number of goals scored by the home team, and $g_a$ is the number of goals scored by the away team. For each match:
\begin{bullets}
\item the winner (the team with more goals) earns $3$ points;
\item if the match is a draw ($g_h = g_a$), each team earns $1$ point;
\item the loser earns $0$ points.
\end{bullets}
Compute each team\textquotesingle s total points across all matches and return an array $ans$ of length $n$ where $ans[i-1]$ is the total points of team $i$.

Input is given as:
\begin{bullets}
\item an integer $n$ ($1 \le n \le 10^5$), the number of teams;
\item a list \texttt{matches} of length $m$ ($0 \le m \le 2\cdot 10^5$) with entries $[h, a, g_h, g_a]$ such that $1 \le h, a \le n$, $h \ne a$, and $0 \le g_h, g_a \le 100$.
\end{bullets}
Return the array of team scores as described.}
\BREAKDOWN{Accumulate points per team by scanning all matches once. For each match, determine the outcome and update the two involved teams\textquotesingle{} scores according to the rules. Ensure teams with no matches end with $0$ points.}
\ELI{Walk through matches and add $3$ for a win or $1$ each for a draw; everyone else gets $0$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer $n$; a list \texttt{matches} of length $m$ with entries $[h, a, g_h, g_a]$ where team ids are $1$-indexed and distinct per match.}
\OUTPUTS{Return a list $ans$ of length $n$ where $ans[i-1]$ is the points of team $i$ computed with win $=3$, draw $=1$, loss $=0$.}
\SAMPLES{
Example 1:

$n=3$, \texttt{matches} $=[[1,2,2,1],[2,3,0,0],[1,3,1,4]]$.

Explanation: Match 1: team $1$ beats team $2$ $\Rightarrow$ $+3$ for team $1$. Match 2: draw $\Rightarrow$ $+1$ for teams $2$ and $3$. Match 3: team $3$ beats team $1$ $\Rightarrow$ $+3$ for team $3$. Output: $[3,1,4]$.

Example 2:

$n=2$, \texttt{matches} $=[[1,2,0,0]]$. Both teams draw, so output $[1,1]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let teams be the set $V=\{1,\ldots,n\}$. Let matches be a multiset $E$ of ordered pairs with scores: each $e\in E$ is $(h,a,g_h,g_a)$. The score of team $t$ is the sum over its matches of outcome points: $3$ for win, $1$ for draw, $0$ for loss.}
\varmapStart
\var{n}{number of teams}
\var{E}{multiset of matches; each $e=(h,a,g_h,g_a)$}
\var{S_t}{total tournament points of team $t$}
\var{\mathbf{ans}}{array of scores, $\mathbf{ans}[t-1]=S_t$}
\varmapEnd
\GOVERN{
\[
  S_t \;=\; \sum_{(h,a,g_h,g_a)\in E}
  \Big( \mathbf{1}[t=h]\cdot\big(3\cdot \mathbf{1}[g_h>g_a] + \mathbf{1}[g_h=g_a]\big)
      + \mathbf{1}[t=a]\cdot\big(3\cdot \mathbf{1}[g_a>g_h] + \mathbf{1}[g_h=g_a]\big)\Big).
\]
}
\ASSUMPTIONS{Teams are labeled $1..n$. Each match has exactly two distinct teams. Goals are nonnegative integers. There is no effect from home vs away beyond being listed as $h$ or $a$.}
\INVARIANTS{
\begin{bullets}
\item Nonnegativity: $S_t \ge 0$ for all $t$.
\item Conservation per match: each match contributes exactly $3$ total points to the tournament (either $3+0$ or $1+1$).
\item Upper bound: $S_t \le 3\cdot d_t$ where $d_t$ is team $t$'s number of played matches.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Translate the governing sum into a single pass over matches, branching on $g_h$ vs $g_a$ and updating two entries in an array of length $n$.}
\ASSUMPTIONS{Teams are $1$-indexed in input; store scores in a $0$-indexed array.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an array \texttt{scores} of length $n$ with zeros.
\item For each match $[h,a,g_h,g_a]$:
  \begin{bullets}
  \item If $g_h>g_a$: add $3$ to \texttt{scores[$h-1$]}.
  \item Else if $g_h<g_a$: add $3$ to \texttt{scores[$a-1$]}.
  \item Else: add $1$ to both \texttt{scores[$h-1$]} and \texttt{scores[$a-1$]}.
  \end{bullets}
\item Return \texttt{scores}.
\end{algosteps}
\COMPLEXITY{Linear in number of matches; memory linear in number of teams.}
\[
\begin{aligned}
T(n,m) &= \Theta(m) \quad\text{(one pass, O(1) work per match)},\\
S(n,m) &= \Theta(n) \quad\text{(score array)}.
\end{aligned}
\]
\CORRECTNESS{Each match updates exactly the involved teams per the rules. The conservation invariant ensures no double counting; teams not appearing in any match remain $0$.}
\EDGECASES{No matches; all draws; large team ids with sparse participation; repeated pairs; goals equal to $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def teamScores(self, n: int, matches: List[List[int]]) -> List[int]:
        scores = [0] * n
        for h, a, gh, ga in matches:
            if gh > ga:
                scores[h - 1] += 3
            elif gh < ga:
                scores[a - 1] += 3
            else:
                scores[h - 1] += 1
                scores[a - 1] += 1
        return scores

# baseline sanity checks
s = Solution()
assert s.teamScores(3, [[1, 2, 2, 1], [2, 3, 0, 0], [1, 3, 1, 4]]) == [3, 1, 4]
assert s.teamScores(2, [[1, 2, 0, 0]]) == [1, 1]
assert s.teamScores(4, []) == [0, 0, 0, 0]
\end{minted}
\VALIDATION{Checked correctness on two nontrivial examples and the empty-matches case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same fundamental formula, but reduce branches and repeated indexing by using local references and a tiny outcome map.}
\ASSUMPTIONS{Leverage Python booleans as integers to compute points succinctly while keeping clarity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{scores} as before.
\item For each match, compute two integers \texttt{hp}, \texttt{ap} as the points for home and away using booleans-as-ints and add to the corresponding entries.
\item Return \texttt{scores}.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline, but with fewer conditional branches and repeated index lookups.}
\[
\begin{aligned}
T(n,m) &= \Theta(m), \quad S(n,m)=\Theta(n).
\end{aligned}
\]
\CORRECTNESS{For any $(g_h,g_a)$, exactly one of $g_h>g_a$, $g_h=g_a$, $g_h<g_a$ holds; the boolean arithmetic maps to the correct $(3,0)$, $(1,1)$, or $(0,3)$ distribution.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def teamScores(self, n: int, matches: List[List[int]]) -> List[int]:
        scores = [0] * n
        for h, a, gh, ga in matches:
            hp = (gh > ga) * 3 + (gh == ga) * 1
            ap = (ga > gh) * 3 + (gh == ga) * 1
            scores[h - 1] += hp
            scores[a - 1] += ap
        return scores

# improved checks
s = Solution()
assert s.teamScores(1, []) == [0]
assert s.teamScores(3, [[1, 2, 3, 0], [2, 3, 2, 5], [1, 3, 1, 1]]) == [4, 3, 4]
assert s.teamScores(2, [[2, 1, 2, 0], [1, 2, 1, 4]]) == [0, 6]
\end{minted}
\VALIDATION{Covers empty, mixed outcomes, and order of home vs away with different winners.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Single linear sweep with branchless point computation using indicator functions implemented via boolean arithmetic.}
\ASSUMPTIONS{Input sizes fit in memory; integer arithmetic does not overflow in Python.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Allocate an array \texttt{scores} of length $n$ filled with $0$.
\item For each match $[h,a,g_h,g_a]$: compute
\[
\begin{aligned}
p_h &= 3\cdot \mathbf{1}[g_h>g_a] + 1\cdot \mathbf{1}[g_h=g_a],\\
p_a &= 3\cdot \mathbf{1}[g_a>g_h] + 1\cdot \mathbf{1}[g_h=g_a],
\end{aligned}
\]
and add to the respective teams.
\item Return \texttt{scores}.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must inspect each match at least once, giving a lower bound $\Omega(m)$. This method achieves $O(m)$ time and $O(n)$ space, which is tight.}
\COMPLEXITY{Linear in matches; linear auxiliary storage for scores.}
\[
\begin{aligned}
T(n,m) &= \Theta(m), \\
S(n,m) &= \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def teamScores(self, n: int, matches: List[List[int]]) -> List[int]:
        scores = [0] * n
        add = scores.__setitem__  # local alias for micro-optimizing repeated writes
        for h, a, gh, ga in matches:
            hp = (gh > ga) * 3 + (gh == ga)
            ap = (ga > gh) * 3 + (gh == ga)
            # update using reads then writes to avoid extra indexing work
            sh = scores[h - 1] + hp
            sa = scores[a - 1] + ap
            add(h - 1, sh)
            add(a - 1, sa)
        return scores

# Exactly 3 asserts
_s = Solution()
assert _s.teamScores(3, [[1, 2, 2, 1], [2, 3, 0, 0], [1, 3, 1, 4]]) == [3, 1, 4]
assert _s.teamScores(2, [[1, 2, 0, 0]]) == [1, 1]
assert _s.teamScores(5, [[1, 2, 0, 3], [3, 4, 2, 2], [5, 1, 1, 0], [2, 5, 7, 7]]) == [3, 3, 1, 1, 4]
\end{minted}
\VALIDATION{Three asserts covering win, draw, and multiple matches per team.}
\RESULT{Returns an array of length $n$; index $i-1$ contains team $i$'s total points.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests include: empty matches; all draws; all decisive matches; mixed outcomes; teams with no matches; randomized small tournaments with cross-checks.}
\LINE{CROSS-CHECKS}{Verify equivalence between baseline and final implementations on randomized inputs; ensure total tournament points equal $3m$.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial cases: maximum goals, repeated fixtures, star topology where one team plays many matches, and completely disjoint participation.}
\begin{minted}{python}
from typing import List, Tuple
import random

def gen_case(n: int, m: int, seed: int = 0) -> Tuple[int, List[List[int]]]:
    random.seed(seed)
    matches: List[List[int]] = []
    for _ in range(m):
        h = random.randint(1, n)
        a = random.randint(1, n-1)
        if a >= h:
            a += 1
        gh = random.randint(0, 5)
        ga = random.randint(0, 5)
        matches.append([h, a, gh, ga])
    return n, matches

class Baseline:
    def teamScores(self, n: int, matches: List[List[int]]) -> List[int]:
        scores = [0] * n
        for h, a, gh, ga in matches:
            if gh > ga:
                scores[h - 1] += 3
            elif gh < ga:
                scores[a - 1] += 3
            else:
                scores[h - 1] += 1
                scores[a - 1] += 1
        return scores

class Final:
    def teamScores(self, n: int, matches: List[List[int]]) -> List[int]:
        scores = [0] * n
        for h, a, gh, ga in matches:
            hp = (gh > ga) * 3 + (gh == ga)
            ap = (ga > gh) * 3 + (gh == ga)
            scores[h - 1] += hp
            scores[a - 1] += ap
        return scores

def check_total_points(matches: List[List[int]]) -> int:
    # each match yields total of exactly 3 points
    return sum(((gh > ga) * 3 + (gh == ga) + (ga > gh) * 3 + (gh == ga)) for _, _, gh, ga in matches)

# Deterministic cross-checks
for seed in range(10):
    n, matches = gen_case(n=8, m=30, seed=seed)
    b = Baseline().teamScores(n, matches)
    f = Final().teamScores(n, matches)
    assert b == f
    assert check_total_points(matches) == 3 * len(matches)

# Smoke reference test
n, matches = 3, [[1, 2, 2, 1], [2, 3, 0, 0], [1, 3, 1, 4]]
assert Final().teamScores(n, matches) == [3, 1, 4]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def teamScores(self, n: int, matches: List[List[int]]) -> List[int]:
        scores = [0] * n
        for h, a, gh, ga in matches:
            hp = (gh > ga) * 3 + (gh == ga)
            ap = (ga > gh) * 3 + (gh == ga)
            scores[h - 1] += hp
            scores[a - 1] += ap
        return scores

# reference asserts
_s = Solution()
assert _s.teamScores(4, []) == [0, 0, 0, 0]
assert _s.teamScores(2, [[2, 1, 1, 0]]) == [0, 3]
assert _s.teamScores(3, [[1, 2, 3, 3], [3, 1, 0, 1]]) == [2, 1, 3]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sum per-team points over matches: $3$ for win, $1$ each for draw, $0$ for loss.}
\WHY{Common aggregation pattern; shows ability to translate rules to indicator-based arithmetic and handle indexing cleanly.}
\CHECKLIST{
\begin{bullets}
\item Confirm teams are $1$-indexed and convert to $0$-indexed array.
\item Initialize scores of length $n$ with zeros.
\item For each match, compute and add points for both teams.
\item Return the scores array; no extra formatting.
\item Consider teams with no matches.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $m=0$ (no matches) $\Rightarrow$ all zeros.
\item All draws.
\item One team plays many matches; others play none.
\item Maximum goals but equal scores.
\item Repeated fixtures between the same pair of teams.
\item Home and away reversed across matches.
\item Minimal $n=1$.
\item Maximal $n$ with sparse matches.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one from $1$-indexed team ids.
\item Forgetting to update both teams on a draw.
\item Using nested loops leading to $O(nm)$ time unnecessarily.
\item Accidental negative indexing if using $0$-based ids incorrectly.
\item Mutating the input list instead of accumulating in a separate array.
\item Overflow concerns in fixed-width languages; ensure adequate type sizes.
\item Assuming home advantage affects points; it does not here.
\item Misreading that draws give $1$ point to each team, not $0.5$.
\end{bullets}}
\FAILMODES{A double-counting approach or missing one team\textquotesingle s update on draws yields totals not summing to $3m$; the indicator-based update preserves the per-match $3$-point conservation.}
\ELI{Just keep a running tally for each team. Each game hands out $3$ points total: either one team gets all $3$ or they split $1$ and $1$. Add these up for every team.}
\NotePages{3}

\end{document}