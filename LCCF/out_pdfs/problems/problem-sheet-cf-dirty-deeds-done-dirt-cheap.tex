% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Dirty Deeds Done Dirt Cheap}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1148/D}}
\LINE{DIFFICULTY / RATING}{1800}
\STATEMENT{You are given $n$ pairs of integers $(a_1, b_1), (a_2, b_2), \ldots, (a_n, b_n)$. All of the integers in the pairs are distinct and are in the range from $1$ to $2 \cdot n$ inclusive.

Let's call a sequence of integers $x_1, x_2, \ldots, x_{2k}$ good if either
\begin{bullets}
\item $x_1 < x_2 > x_3 < \ldots < x_{2k-2} > x_{2k-1} < x_{2k}$, or
\item $x_1 > x_2 < x_3 > \ldots > x_{2k-2} < x_{2k-1} > x_{2k}$.
\end{bullets}

You need to choose a subset of distinct indices $i_1, i_2, \ldots, i_t$ and their order in a way that if you write down all numbers from the pairs in a single sequence (the sequence would be $a_{i_1}, b_{i_1}, a_{i_2}, b_{i_2}, \ldots, a_{i_t}, b_{i_t}$), this sequence is good.

What is the largest subset of indices you can choose? You also need to construct the corresponding index sequence $i_1, i_2, \ldots, i_t$.

Input:
The first line contains single integer $n$ ($2 \le n \le 3 \cdot 10^5$) — the number of pairs.

Each of the next $n$ lines contain two numbers — $a_i$ and $b_i$ ($1 \le a_i, b_i \le 2 \cdot n$) — the elements of the pairs.

It is guaranteed that all integers in the pairs are distinct, that is, every integer from $1$ to $2 \cdot n$ is mentioned exactly once.

Output:
In the first line print a single integer $t$ — the number of pairs in the answer.

Then print $t$ distinct integers $i_1, i_2, \ldots, i_t$ — the indexes of pairs in the corresponding order.

Note:
The final sequence in the first example is $1 < 7 > 3 < 5 > 2 < 10$.

The final sequence in the second example is $6 > 1 < 3 > 2 < 5 > 4$.}
\BREAKDOWN{Partition pairs by whether $a_i<b_i$ or $a_i>b_i$. Choose the larger partition and sort it appropriately so that concatenating $(a_i,b_i)$ yields an alternating zigzag. Construct and output the indices.}
\ELI{Pick all pairs of one type (either $a<b$ or $a>b$), whichever are more numerous, and sort them so highs strictly go down (or lows strictly go up); then the zigzag works automatically.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item Integer $n$ with $2 \le n \le 3 \cdot 10^5$.
\item Then $n$ lines: integers $a_i,b_i$ with $1 \le a_i,b_i \le 2n$.
\item All $2n$ integers are distinct and form a permutation of $\{1,\ldots,2n\}$.
\end{bullets}}
\OUTPUTS{
\begin{bullets}
\item First line: integer $t$ — size of the selected subset.
\item Second line: $t$ distinct indices $i_1,\ldots,i_t$ in the chosen order.
\end{bullets}}
\SAMPLES{
Example A:
\begin{verbatim}
Input
3
1 6
3 5
2 4

Output
3
1 2 3
\end{verbatim}
Example B:
\begin{verbatim}
Input
3
6 1
3 2
5 4

Output
3
1 2 3
\end{verbatim}
Both outputs are acceptable because $1<6>3<5>2<4$ and $6>1<3>2<5>4$ are good.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n$ disjoint pairs $(a_i,b_i)$ covering $\{1,\ldots,2n\}$, choose a maximum-cardinality subsequence of indices and an order such that the concatenation of their pairs forms an alternating inequality sequence (zigzag) of even length.}
\varmapStart
\var{(a_i,b_i)}{the $i$-th pair with distinct entries}
\var{L}{indices with $a_i<b_i$}
\var{R}{indices with $a_i>b_i$}
\var{t}{number of selected indices}
\var{i_1,\ldots,i_t}{ordering of selected indices}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let }L=\{i: a_i<b_i\},\quad R=\{i: a_i>b_i\}.\\
&\text{If we output }i_1,\ldots,i_t\in L\text{ sorted by decreasing }b_{i},\\
&\text{then }a_{i_1}<b_{i_1}>a_{i_2}<b_{i_2}>\cdots>a_{i_t}<b_{i_t}.\\
&\text{If we output }i_1,\ldots,i_t\in R\text{ sorted by increasing }b_{i},\\
&\text{then }a_{i_1}>b_{i_1}<a_{i_2}>b_{i_2}<\cdots>a_{i_t}>b_{i_t}.
\end{aligned}
\]
}
\ASSUMPTIONS{All $2n$ values are distinct. We may choose any subset. Sorting by the described key yields strict inequalities because all numbers are distinct.}
\INVARIANTS{
\begin{bullets}
\item For $i\in L$: $a_i<b_i$. For $i\in R$: $a_i>b_i$.
\item If $b$-values strictly decrease across consecutive $L$-pairs, then $a$-values are strictly below the previous $b$, preserving the $<,>$ alternation.
\item If $b$-values strictly increase across consecutive $R$-pairs, then $a$-values are strictly above the previous $b$, preserving the $>,<$ alternation.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try both patterns by using simple partitions:
\begin{bullets}
\item Use all pairs with $a_i<b_i$; sort by decreasing $b_i$.
\item Use all pairs with $a_i>b_i$; sort by increasing $b_i$.
\end{bullets}
Pick the longer one.}
\ASSUMPTIONS{Because all numbers are distinct, strict sorting by $b_i$ is well-defined.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read the pairs and build sets $L$ and $R$.
\item If $|L|\ge |R|$, sort $L$ by $b$ decreasing; else, sort $R$ by $b$ increasing.
\item Output the ordered indices.
\end{algosteps}
\COMPLEXITY{Linear-time partition and $O(n \log n)$ sort dominate.}
\[
\begin{aligned}
T(n) &= O(n) + O(n \log n) = O(n \log n),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Within $L$, arranging by strictly decreasing $b$ ensures each transition $b_{i_j} > a_{i_{j+1}}$ (as $a_{i_{j+1}}<b_{i_{j+1}}<b_{i_j}$), preserving $<,>$ alternation. Symmetrically, within $R$, arranging by strictly increasing $b$ ensures $a_{i_j} > b_{i_j} < a_{i_{j+1}}$ since $a_{i_{j+1}}>b_{i_{j+1}}>b_{i_j}$. Choosing the larger of $L$ or $R$ maximizes $t$.}
\EDGECASES{
\begin{bullets}
\item All pairs in $L$ or all in $R$: trivially output all.
\item Ties $|L|=|R|$: either is optimal; choose $L$ by convention.
\item Minimal $n=2$: just sort two pairs per rule.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int, int]]]:
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, []
    pairs = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it))
        pairs.append((a, b))
    return n, pairs

def solve_case(n: int, pairs: List[Tuple[int, int]]) -> List[int]:
    L, R = [], []
    for idx, (a, b) in enumerate(pairs, 1):
        if a < b:
            L.append((idx, a, b))
        else:
            R.append((idx, a, b))
    if len(L) >= len(R):
        L.sort(key=lambda x: x[2], reverse=True)  # sort by b desc
        return [i for i, a, b in L]
    else:
        R.sort(key=lambda x: x[2])  # sort by b asc
        return [i for i, a, b in R]

def solve_all(n: int, pairs: List[Tuple[int, int]]) -> str:
    ans = solve_case(n, pairs)
    out = [str(len(ans)), "\n", " ".join(map(str, ans))]
    return "".join(out)

def is_good_sequence(seq: List[int]) -> bool:
    """Check if seq alternates either <,>,<,>... or >,<,>,<,..."""
    m = len(seq)
    if m < 2:
        return True
    # pattern 1: < > < > ...
    ok1 = True
    for i in range(m - 1):
        if i % 2 == 0:
            if not (seq[i] < seq[i + 1]):
                ok1 = False
                break
        else:
            if not (seq[i] > seq[i + 1]):
                ok1 = False
                break
    # pattern 2: > < > < ...
    ok2 = True
    for i in range(m - 1):
        if i % 2 == 0:
            if not (seq[i] > seq[i + 1]):
                ok2 = False
                break
        else:
            if not (seq[i] < seq[i + 1]):
                ok2 = False
                break
    return ok1 or ok2

def build_sequence(pairs: List[Tuple[int, int]], indices: List[int]) -> List[int]:
    out = []
    for i in indices:
        a, b = pairs[i - 1]
        out.extend([a, b])
    return out

def main():
    n, pairs = read_input()
    if n == 0:
        return
    sys.stdout.write(solve_all(n, pairs))

if __name__ == "__main__":
    # Self-checks
    n1, p1 = 3, [(1, 6), (3, 5), (2, 4)]
    ans1 = solve_case(n1, p1)
    seq1 = build_sequence(p1, ans1)
    assert len(ans1) == 3 and is_good_sequence(seq1)

    n2, p2 = 3, [(6, 1), (3, 2), (5, 4)]
    ans2 = solve_case(n2, p2)
    seq2 = build_sequence(p2, ans2)
    assert len(ans2) == 3 and is_good_sequence(seq2)

    n3, p3 = 4, [(8, 1), (2, 7), (3, 6), (5, 4)]
    ans3 = solve_case(n3, p3)
    seq3 = build_sequence(p3, ans3)
    assert len(ans3) == max(sum(a < b for a, b in p3), sum(a > b for a, b in p3))
    assert is_good_sequence(seq3)

    main()
\end{minted}
\VALIDATION{Three asserts:
\begin{bullets}
\item All-in-$L$ case yields full length and a good sequence.
\item All-in-$R$ case yields full length and a good sequence.
\item Mixed case matches $\max(|L|,|R|)$ and the produced sequence is good.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same partition idea but emphasize that only $b$-ordering matters. We avoid any checks or DP by leveraging strict monotonicity of $b$ in the chosen group.}
\ASSUMPTIONS{Distinctness guarantees strict ordering; no ties. Sorting is stable and deterministic.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Partition into $L$ and $R$ by sign of $a_i-b_i$.
\item Compare sizes; keep the larger set.
\item Sort kept set by $b$ descending if in $L$, ascending if in $R$; output indices.
\end{algosteps}
\COMPLEXITY{Identical to baseline but with a reduced conceptual surface; proof directly uses $b$-monotonicity.}
\[
\begin{aligned}
T(n) &= O(n \log n) \text{ from one sort},\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{For $L$ sorted by decreasing $b$: $a_{i_j}<b_{i_j}$ and $b_{i_j}>b_{i_{j+1}}>a_{i_{j+1}}$ ensure $a_{i_j}<b_{i_j}>a_{i_{j+1}}<b_{i_{j+1}}$. The $R$ case is symmetric with $b$ increasing and $a_{i_{j+1}}>b_{i_{j+1}}>b_{i_j}$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int, int]]]:
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, []
    pairs = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, pairs

def solve_case(n: int, pairs: List[Tuple[int, int]]) -> List[int]:
    L, R = [], []
    for i, (a, b) in enumerate(pairs, 1):
        (L if a < b else R).append((i, a, b))
    if len(L) >= len(R):
        L.sort(key=lambda x: x[2], reverse=True)
        return [i for i, a, b in L]
    else:
        R.sort(key=lambda x: x[2])
        return [i for i, a, b in R]

def solve_all(n: int, pairs: List[Tuple[int, int]]) -> str:
    ans = solve_case(n, pairs)
    return f"{len(ans)}\n{' '.join(map(str, ans))}"

def is_good(seq: List[int]) -> bool:
    if len(seq) < 2:
        return True
    # pattern <
    ok = True
    for i in range(len(seq)-1):
        if (i % 2 == 0 and not (seq[i] < seq[i+1])) or (i % 2 == 1 and not (seq[i] > seq[i+1])):
            ok = False
            break
    if ok:
        return True
    # pattern >
    for i in range(len(seq)-1):
        if (i % 2 == 0 and not (seq[i] > seq[i+1])) or (i % 2 == 1 and not (seq[i] < seq[i+1])):
            return False
    return True

def main():
    n, pairs = read_input()
    if n == 0:
        return
    print(solve_all(n, pairs))

if __name__ == "__main__":
    # Quick checks
    n1, p1 = 3, [(1,6),(3,5),(2,4)]
    idx1 = solve_case(n1, p1)
    seq1 = [x for i in idx1 for x in p1[i-1]]
    assert len(idx1) == 3 and is_good(seq1)

    n2, p2 = 3, [(6,1),(3,2),(5,4)]
    idx2 = solve_case(n2, p2)
    seq2 = [x for i in idx2 for x in p2[i-1]]
    assert len(idx2) == 3 and is_good(seq2)

    n3, p3 = 4, [(8,1),(2,7),(3,6),(5,4)]
    idx3 = solve_case(n3, p3)
    seq3 = [x for i in idx3 for x in p3[i-1]]
    assert len(idx3) == max(sum(a<b for a,b in p3), sum(a>b for a,b in p3)) and is_good(seq3)

    main()
\end{minted}
\VALIDATION{Asserts mirror baseline and confirm maximality equals $\max(|L|,|R|)$ and the concatenation alternates.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Choose the larger of $\{i:a_i<b_i\}$ and $\{i:a_i>b_i\}$; sort by $b$ descending for $L$ or ascending for $R$.}
\ASSUMPTIONS{All values are distinct; hence strict inequality propagation under $b$-monotone ordering.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Split indices into $L$ and $R$ by comparing $a_i$ and $b_i$.
\item If $|L|\ge |R|$, sort $L$ by $b_i$ decreasing; else sort $R$ by $b_i$ increasing.
\item Output the ordered indices from the chosen set.
\end{algosteps}
\OPTIMALITY{Any good sequence consists entirely of pairs from $L$ or entirely from $R$. Proof sketch: If two consecutive pairs have opposite types, say $(a<b)$ followed by $(a'>b')$, then the needed alternation would violate either $b>a'$ or $b<a'$, contradicting definitions when combined with distinctness and pair-local order. Therefore an optimal solution must pick from a single type, and picking the larger type maximizes $t$.}
\COMPLEXITY{$O(n \log n)$ time and $O(n)$ space, optimal up to sorting.}
\[
\begin{aligned}
T(n) &= O(n \log n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int, int]]]:
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, []
    pairs = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, pairs

def solve_case(n: int, pairs: List[Tuple[int, int]]) -> List[int]:
    L, R = [], []
    for i, (a, b) in enumerate(pairs, 1):
        if a < b:
            L.append((i, b))
        else:
            R.append((i, b))
    if len(L) >= len(R):
        L.sort(key=lambda t: t[1], reverse=True)  # b desc
        return [i for i, _ in L]
    else:
        R.sort(key=lambda t: t[1])  # b asc
        return [i for i, _ in R]

def solve_all(n: int, pairs: List[Tuple[int, int]]) -> str:
    idx = solve_case(n, pairs)
    return f"{len(idx)}\n{' '.join(map(str, idx))}"

# --- Tests and validators ---
def is_good(seq: List[int]) -> bool:
    if len(seq) < 2:
        return True
    ok = True
    for i in range(len(seq)-1):
        if (i % 2 == 0 and not (seq[i] < seq[i+1])) or (i % 2 == 1 and not (seq[i] > seq[i+1])):
            ok = False
            break
    if ok:
        return True
    for i in range(len(seq)-1):
        if (i % 2 == 0 and not (seq[i] > seq[i+1])) or (i % 2 == 1 and not (seq[i] < seq[i+1])):
            return False
    return True

def build_seq(pairs: List[Tuple[int, int]], idx: List[int]) -> List[int]:
    out = []
    for i in idx:
        a, b = pairs[i - 1]
        out.extend([a, b])
    return out

def main():
    n, pairs = read_input()
    if n == 0:
        return
    print(solve_all(n, pairs))

if __name__ == "__main__":
    # Exactly 3 asserts
    n1, p1 = 3, [(1,6),(3,5),(2,4)]
    s1 = solve_case(n1, p1); q1 = build_seq(p1, s1)
    assert len(s1) == 3 and is_good(q1)

    n2, p2 = 3, [(6,1),(3,2),(5,4)]
    s2 = solve_case(n2, p2); q2 = build_seq(p2, s2)
    assert len(s2) == 3 and is_good(q2)

    n3, p3 = 4, [(8,1),(2,7),(3,6),(5,4)]
    s3 = solve_case(n3, p3); q3 = build_seq(p3, s3)
    assert len(s3) == max(sum(a<b for a,b in p3), sum(a>b for a,b in p3)) and is_good(q3)

    main()
\end{minted}
\VALIDATION{Three asserts cover: all-in-$L$, all-in-$R$, and mixed.}
\RESULT{Output the maximal number of pairs and an order of their indices such that concatenating $(a_i,b_i)$ forms a good sequence. When $|L|=|R|$, either is acceptable; this solution prefers $L$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-validate the zigzag property, maximality against $\max(|L|,|R|)$, and both homogeneous and mixed cases.}
\LINE{CROSS-CHECKS}{Compare sequences built from indices against the validator for both partitions. Ensure stability against permutations of input order.}
\LINE{EDGE-CASE GENERATOR}{Deterministically craft instances: all in $L$, all in $R$, alternating $b$ magnitudes, and boundary values $\{1,\ldots,2n\}$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_L(n: int):
    # pairs (1,2),(3,4),...,(2n-1,2n)
    return [(2*i-1, 2*i) for i in range(1, n+1)]

def gen_all_R(n: int):
    # pairs (2,1),(4,3),...,(2n,2n-1)
    return [(2*i, 2*i-1) for i in range(1, n+1)]

def gen_mixed(n: int):
    # interleave to force tie sizes for even n
    out = []
    for i in range(1, n+1):
        if i % 2 == 1:
            out.append((i, 2*n+1-i))       # a<b
        else:
            out.append((2*n+1-i, i))       # a>b
    return out

def test_suite():
    from typing import List, Tuple
    def is_good(seq: List[int]) -> bool:
        if len(seq) < 2: return True
        ok = True
        for i in range(len(seq)-1):
            if (i%2==0 and not (seq[i]<seq[i+1])) or (i%2==1 and not (seq[i]>seq[i+1])):
                ok = False; break
        if ok: return True
        for i in range(len(seq)-1):
            if (i%2==0 and not (seq[i]>seq[i+1])) or (i%2==1 and not (seq[i]<seq[i+1])):
                return False
        return True

    def build_seq(pairs: List[Tuple[int,int]], idx: List[int]) -> List[int]:
        out = []
        for i in idx: out += list(pairs[i-1])
        return out

    # all L
    p = gen_all_L(5)
    from collections import Counter
    idx = solve_case(len(p), p)
    seq = build_seq(p, idx)
    assert len(idx) == 5 and is_good(seq) and Counter(idx) == Counter(range(1,6))

    # all R
    p = gen_all_R(5)
    idx = solve_case(len(p), p)
    seq = build_seq(p, idx)
    assert len(idx) == 5 and is_good(seq)

    # mixed
    p = gen_mixed(6)
    idx = solve_case(len(p), p)
    seq = build_seq(p, idx)
    L = sum(a<b for a,b in p); R = sum(a>b for a,b in p)
    assert len(idx) == max(L, R) and is_good(seq)

# Reference solution reproducing the final approach
import sys
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int, int]]]:
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, []
    pairs = [(int(next(it)), int(next(it))) for _ in range(n)]
    return n, pairs

def solve_case(n: int, pairs: List[Tuple[int, int]]) -> List[int]:
    L, R = [], []
    for i, (a, b) in enumerate(pairs, 1):
        if a < b:
            L.append((i, b))
        else:
            R.append((i, b))
    if len(L) >= len(R):
        L.sort(key=lambda t: t[1], reverse=True)
        return [i for i, _ in L]
    else:
        R.sort(key=lambda t: t[1])
        return [i for i, _ in R]

def main():
    n, pairs = read_input()
    if n == 0:
        return
    idx = solve_case(n, pairs)
    print(len(idx))
    print(" ".join(map(str, idx)))

if __name__ == "__main__":
    test_suite()
    # Note: main() not invoked here to avoid consuming stdin during tests.
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Pick the larger side of pairs with $a<b$ or $a>b$; sort by $b$ descending (for $L$) or ascending (for $R$) to get a maximal-length zigzag.}
\WHY{Classic CF trick: transform an alternation constraint into a monotone key on a partition. Appears in greedy/ordering tasks.}
\CHECKLIST{
\begin{bullets}
\item Partition into $L$ and $R$.
\item Choose the larger set.
\item Sort by $b$ (desc for $L$, asc for $R$).
\item Output indices.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All pairs on one side.
\item Tie sizes $|L|=|R|$.
\item Minimal $n=2$.
\item Pairs with consecutive integers near $1$ or $2n$.
\item Input order adversarially shuffled.
\item Very large $n$ near $3\cdot 10^5$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Sorting the wrong key (sorting by $a$ can fail).
\item Mixing $L$ and $R$ in one sequence breaks alternation.
\item Forgetting strictness; must be strict $<$ and $>$.
\item 1-indexed indices in output; do not switch to 0-based.
\item Printing wrong count $t$ mismatch with indices length.
\item Not handling tie case deterministically.
\end{bullets}}
\FAILMODES{Approaches that interleave $L$ and $R$ may fail to maintain the zigzag or be non-maximal. The $b$-monotone greedy survives all due to strict inequality propagation.}
\ELI{We split pairs into those that go up and those that go down. Pick the bigger pile. If we line them up so the highs keep getting smaller (or lows keep getting bigger), the whole chain naturally zigzags the right way.}
\NotePages{3}

\end{document}