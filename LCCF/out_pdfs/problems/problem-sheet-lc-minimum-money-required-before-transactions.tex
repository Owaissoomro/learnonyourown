% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Money Required Before Transactions}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-money-required-before-transactions/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a 0-indexed 2D integer array \texttt{transactions}, where \texttt{transactions[i] = [costi, cashbacki]}. The array describes transactions, where each transaction must be completed exactly once in some order. At any given moment, you have a certain amount of \texttt{money}. In order to complete transaction $i$, $money \ge cost_i$ must hold true. After performing a transaction, \texttt{money} becomes \texttt{money - costi + cashbacki}. Return the minimum amount of \texttt{money} required before any transaction so that all of the transactions can be completed regardless of the order of the transactions.

Example 1:

Input: \texttt{transactions = [[2,1],[5,0],[4,2]]}

Output: \texttt{10}

Explanation: Starting with \texttt{money = 10}, the transactions can be performed in any order. It can be shown that starting with \texttt{money < 10} will fail to complete all transactions in some order.

Example 2:

Input: \texttt{transactions = [[3,0],[0,3]]}

Output: \texttt{3}

Explanation:
\begin{bullets}
\item If transactions are in the order \texttt{[[3,0],[0,3]]}, the minimum money required to complete the transactions is \texttt{3}.
\item If transactions are in the order \texttt{[[0,3],[3,0]]}, the minimum money required to complete the transactions is \texttt{0}.
\end{bullets}
Thus, starting with \texttt{money = 3}, the transactions can be performed in any order.

Constraints:
\begin{bullets}
\item $1 \le \texttt{transactions.length} \le 10^5$
\item \texttt{transactions[i].length == 2}
\item $0 \le cost_i, cashback_i \le 10^9$
\end{bullets}}
\BREAKDOWN{Partition transactions into loss-making ($cost_i > cashback_i$) and non-loss ($cost_i \le cashback_i$). Compute the total net loss that must be covered in the worst case and the single largest upfront spike required by an adversarial order.}
\ELI{Pay for all your losses once, plus keep a buffer equal to the biggest of: a loss transaction's cashback or a non-loss transaction's cost.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list \texttt{transactions} of length $n$ where each element is a pair \texttt{[cost, cashback]} with integers in $[0,10^9]$.}
\OUTPUTS{Return an integer: the minimum initial \texttt{money} that guarantees the ability to finish all transactions in any order.}
\SAMPLES{Example A: \texttt{[[2,1],[5,0],[4,2]]} $\to$ \texttt{10}. Example B: \texttt{[[3,0],[0,3]]} $\to$ \texttt{3}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=\{1,\ldots,n\}$ index transactions. Each transaction $i$ has $(cost_i, cashback_i)$. Money evolves as $M \mapsto M - cost_i + cashback_i$ upon executing $i$. Define the loss $\ell_i = \max(0, cost_i - cashback_i)$.}
\varmapStart
\var{M}{initial money to determine}
\var{B}{set of loss-making transactions: $B=\{i: cost_i > cashback_i\}$}
\var{G}{set of non-loss transactions: $G=\{i: cost_i \le cashback_i\}$}
\var{S}{total loss: $S=\sum_{i\in B} (cost_i - cashback_i)=\sum_{i=1}^n \ell_i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
M^\star &= \min \left\{ M ~\middle|~ \text{for every permutation } \pi \text{ and step } t,\; M - \sum_{k=1}^{t-1} \ell_{\pi_k} \ge cost_{\pi_t} \right\} \\
&= S + \max\!\left( \max_{i\in G} cost_i,\; \max_{i\in B} cashback_i \right) \\
&= S + \max_{i=1,\ldots,n} \min(cost_i, cashback_i).
\end{aligned}
\]
}
\ASSUMPTIONS{All transactions must be executed exactly once; order is adversarial. Integers fit in 64-bit signed during intermediate sums.}
\INVARIANTS{
\begin{bullets}
\item Money decreases over time only when executing loss-making transactions; non-loss never reduces the running total.
\item Before executing $i$, available money equals $M$ minus the sum of losses among already executed transactions.
\item Worst-case for a given $i$ occurs when all other loss-making transactions are executed before $i$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all permutations and compute, for each order, the minimum initial money required; then take the maximum over permutations. This defines the ground truth for small $n$.}
\ASSUMPTIONS{Use exhaustive search only for validation (small $n$). For a fixed order $\pi$, the minimum $M$ is $\max_t \{ cost_{\pi_t} + \sum_{k=1}^{t-1} \ell_{\pi_k} \}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each permutation $\pi$ of transactions:
\item Scan left to right; maintain cumulative loss $L$; update $ans_\pi \gets \max(ans_\pi, cost_{\pi_t} + L)$, then add $\ell_{\pi_t}$ to $L$.
\item Take $M^\star = \max_{\pi} ans_\pi$.
\end{algosteps}
\COMPLEXITY{Brute force uses $O(n!)$ permutations and $O(n)$ per permutation; infeasible beyond tiny $n$. Space is $O(1)$ extra aside from input.}
\[
\begin{aligned}
T(n) &= n! \cdot O(n) \\
     &= O(n \cdot n!) \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Directly matches the definition: ensure feasibility at each step of every possible order, picking the minimal initial money per order, then the maximum across orders.}
\EDGECASES{Single transaction; all non-loss; all loss; zeros for costs or cashbacks.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import itertools

class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        # Baseline would be brute-force; here we provide the closed-form to remain scalable.
        S = 0
        m = 0
        for c, b in transactions:
            if c > b:
                S += c - b
            # min(c, b) is the per-item requirement in the adversarial step
            if min(c, b) > m:
                m = min(c, b)
        return S + m

# Tiny brute for validation (not used by judge; for asserts)
def brute_all_orders(transactions: List[Tuple[int, int]]) -> int:
    best = 0
    for perm in itertools.permutations(transactions):
        L = 0
        need = 0
        for c, b in perm:
            need = max(need, c + L)
            if c > b:
                L += c - b
        best = max(best, need)
    return best

# Asserts (samples and small cross-checks)
sol = Solution()
assert sol.minimumMoney([[2,1],[5,0],[4,2]]) == 10
assert sol.minimumMoney([[3,0],[0,3]]) == 3
# Cross-check a few tiny cases with brute
cases = [
    [[0,0]],
    [[1,1]],
    [[1,0]],
    [[0,1]],
    [[2,3],[5,1]],
    [[5,1],[2,3]],
    [[2,1],[1,2],[3,3]],
    [[3,1],[1,3],[2,0]],
]
for tr in cases:
    assert sol.minimumMoney(tr) == brute_all_orders(tr)
\end{minted}
\VALIDATION{Validated on the two provided samples and several small handcrafted cases via brute-force agreement.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Partition by Loss and Collapse the Max}
\WHICHFORMULA{Observe that only loss-making transactions reduce money over time. In the worst case, an adversary can place all other losses before the current transaction $i$, requiring $S - \ell_i$ losses to be paid before $i$. This yields the per-item requirement $S + \min(cost_i, cashback_i)$.}
\ASSUMPTIONS{Define $S=\sum \max(0, cost_i - cashback_i)$. For $i \in G$, requirement is $S + cost_i$; for $i \in B$, requirement is $S + cashback_i$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $S = \sum_i \max(0, cost_i - cashback_i)$.
\item Compute $M_{\text{buf}} = \max_i \min(cost_i, cashback_i)$.
\item Return $S + M_{\text{buf}}$.
\end{algosteps}
\COMPLEXITY{Single pass to compute both $S$ and the max-min buffer.}
\[
\begin{aligned}
T(n) &= O(n), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{For any transaction $i$, before executing it in the worst order, all other losses could have been accumulated: money $= M - (S - \ell_i) \ge cost_i \iff M \ge S + \min(cost_i, cashback_i)$. Taking the maximum over $i$ ensures feasibility for every $i$; adding $S$ covers all losses overall.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        S = 0
        mx = 0
        for c, b in transactions:
            if c > b:
                S += c - b
            v = c if c <= b else b  # min(c, b)
            if v > mx:
                mx = v
        return S + mx

# Asserts
sol = Solution()
assert sol.minimumMoney([[2,1],[5,0],[4,2]]) == 10
assert sol.minimumMoney([[3,0],[0,3]]) == 3
assert sol.minimumMoney([[0,0]]) == 0
\end{minted}
\VALIDATION{Checked on samples and trivial edge \texttt{[[0,0]]}.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Closed-Form One-Pass Solution}
\WHICHFORMULA{Use $M^\star = \sum_i \max(0, cost_i - cashback_i) + \max_i \min(cost_i, cashback_i)$.}
\ASSUMPTIONS{No special ordering needed; applies to all inputs in constraints. 64-bit integers suffice since $n \le 10^5$ and values $\le 10^9$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $S \gets 0$, $mx \gets 0$.
\item For each $(c,b)$: add $\max(0,c-b)$ to $S$; update $mx \gets \max(mx, \min(c,b))$.
\item Return $S + mx$.
\end{algosteps}
\OPTIMALITY{Tight by adversary: pick the transaction that maximizes $\min(cost_i, cashback_i)$ and schedule it after all other loss-making transactions; this forces the buffer term. The $S$ term is unavoidable, as total money decreases by exactly $S$ over the entire sequence.}
\COMPLEXITY{Linear time, constant extra space.}
\[
\begin{aligned}
T(n) &= O(n), \\
S(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        S = 0
        mx = 0
        for c, b in transactions:
            if c > b:
                S += c - b
            v = c if c <= b else b
            if v > mx:
                mx = v
        return S + mx

# Exactly 3 asserts (problem samples + a sanity)
sol = Solution()
assert sol.minimumMoney([[2,1],[5,0],[4,2]]) == 10
assert sol.minimumMoney([[3,0],[0,3]]) == 3
assert sol.minimumMoney([[10,10],[0,0]]) == 10
\end{minted}
\VALIDATION{Three asserts: both samples and a sanity where total loss is 0 but we need the largest \texttt{min(cost, cashback)}.}
\RESULT{Return the minimal initial \texttt{money} that guarantees feasibility for every order: $S + \max_i \min(cost_i, cashback_i)$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on samples; property-based cross-check against brute-force enumerations for small $n$; edge cases like all loss, all non-loss, zeros, and mixed magnitudes.}
\LINE{CROSS-CHECKS}{Compare the closed-form against brute-force maximum over permutations for small, deterministic sets.}
\LINE{EDGE-CASE GENERATOR}{Handcrafted tiny suites cover corner distributions without randomness.}
\begin{minted}{python}
from typing import List, Tuple
import itertools

def brute_all_orders(transactions: List[Tuple[int, int]]) -> int:
    best = 0
    for perm in itertools.permutations(transactions):
        L = 0
        need = 0
        for c, b in perm:
            need = max(need, c + L)
            if c > b:
                L += c - b
        best = max(best, need)
    return best

class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        S = 0
        mx = 0
        for c, b in transactions:
            if c > b:
                S += c - b
            v = c if c <= b else b
            if v > mx:
                mx = v
        return S + mx

def run_tests():
    sol = Solution()
    # Samples
    assert sol.minimumMoney([[2,1],[5,0],[4,2]]) == 10
    assert sol.minimumMoney([[3,0],[0,3]]) == 3
    # Deterministic small cases cross-check
    small_cases = [
        [[0,0]],
        [[1,0]],
        [[0,1]],
        [[1,1]],
        [[2,3],[5,1]],
        [[5,1],[2,3]],
        [[2,1],[1,2],[3,3]],
        [[3,1],[1,3],[2,0]],
        [[10,0],[0,10],[5,5]],
        [[4,4],[4,0],[0,4]],
    ]
    for tr in small_cases:
        assert sol.minimumMoney(tr) == brute_all_orders([tuple(x) for x in tr])
    # Larger sanity mixes (no brute)
    assert sol.minimumMoney([[10,9],[9,10],[1,0],[100,50]]) == (10-9)+(1-0)+(100-50) + max(min(10,9),min(9,10),min(1,0),min(100,50))
    # Edge: all non-loss
    arr = [[i, i+1] for i in range(1, 8)]
    assert sol.minimumMoney(arr) == max(i for i, _ in arr)

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        S = 0
        mx = 0
        for c, b in transactions:
            if c > b:
                S += c - b
            v = c if c <= b else b
            if v > mx:
                mx = v
        return S + mx

# Quick self-checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumMoney([[2,1],[5,0],[4,2]]) == 10
    assert sol.minimumMoney([[3,0],[0,3]]) == 3
    assert sol.minimumMoney([[0,0]]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute total losses $S$ and add the largest per-item buffer $\max_i \min(cost_i, cashback_i)$.}
\WHY{This pattern appears in adversarial-order scheduling and greedy proofs: isolate unavoidable cumulative deficit and the single worst upfront requirement.}
\CHECKLIST{
\begin{bullets}
\item Partition losses: add $\max(0, cost - cashback)$ to $S$.
\item Track $mx \gets \max(mx, \min(cost, cashback))$.
\item Answer is $S + mx$.
\item Use 64-bit integers for sums.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Single transaction: answer is $\min(cost, cashback)$.
\item All non-loss: answer is $\max_i cost_i$.
\item All loss: answer is $\sum (cost - cashback) + \max_i cashback_i$.
\item Presence of zeros: e.g., $[0, x]$ or $[x, 0]$.
\item Large values near $10^9$ and $n$ near $10^5$.
\item Mixed where the max buffer comes from a non-loss vs. from a loss.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to exclude $i$'s own loss when placing $i$ in worst position; use $S - \ell_i$.
\item Using $\max(cost, cashback)$ instead of $\min(cost, cashback)$ in the buffer term.
\item Summing all $(cost - cashback)$ including negative values.
\item Integer overflow in languages without big integers.
\item Misinterpreting ``regardless of order'' as ``there exists an order''.
\item Off-by-one in prefix calculations if attempting a simulation-based derivation.
\end{bullets}
}
\FAILMODES{Greedy order-specific heuristics can under-estimate required initial money because they only witness one favorable order, not the adversarial one. The closed form withstands any order.}
\ELI{First, set aside enough to pay for every loss you'll ever take. Then, because someone might make you pay a tough transaction when you're at your lowest, keep a buffer equal to that transaction's smaller of cost and cashback.}
\NotePages{3}

\end{document}