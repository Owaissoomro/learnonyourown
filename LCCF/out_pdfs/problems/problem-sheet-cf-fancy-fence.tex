% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Fancy Fence}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/270/A}}
\LINE{DIFFICULTY / RATING}{1100}
\STATEMENT{Emuskald needs a fence around his farm, but he is too lazy to build it himself. So he purchased a fence-building robot.

He wants the fence to be a regular polygon. The robot builds the fence along a single path, but it can only make fence corners at a single angle $a$.

Will the robot be able to build the fence Emuskald wants? In other words, is there a regular polygon which angles are equal to $a$?

Input:
The first line of input contains an integer $t$ ($0 < t < 180$) — the number of tests. Each of the following $t$ lines contains a single integer $a$ ($0 < a < 180$) — the angle the robot can make corners at measured in degrees.

Output:
For each test, output on a single line ``YES'' (without quotes), if the robot can build a fence Emuskald wants, and ``NO'' (without quotes), if it is impossible.

Note:
In the first test case, it is impossible to build the fence, since there is no regular polygon with angle $30^\circ$.

In the second test case, the fence is a regular triangle, and in the last test case — a square.}
\BREAKDOWN{We must decide, for each query angle $a$, whether there exists an integer $n \ge 3$ such that a regular $n$-gon has interior angle $a$. Use the formula for a regular polygon's interior angle to derive a simple arithmetic test.}
\ELI{A regular $n$-gon has angle $180 - \tfrac{360}{n}$; check if $n=\tfrac{360}{180-a}$ is an integer at least $3$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $t$ ($1 \le t \le 179$). Then $t$ lines follow, each with one integer $a$ ($1 \le a \le 179$).}
\OUTPUTS{For each $a$, print ``YES'' if there exists an integer $n \ge 3$ such that the interior angle of a regular $n$-gon equals $a$ degrees; otherwise print ``NO''. One answer per line.}
\SAMPLES{Example 1:
\begin{verbatim}
Input
3
30
60
90
Output
NO
YES
YES
\end{verbatim}
Example 2:
\begin{verbatim}
Input
4
1
179
45
120
Output
NO
YES
NO
YES
\end{verbatim}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $a \in \{1,2,\ldots,179\}$, decide if $\exists n \in \mathbb{Z}_{\ge 3}$ such that the interior angle of a regular $n$-gon equals $a$. For a regular $n$-gon, the interior angle is $A(n)=\dfrac{(n-2) \cdot 180}{n}=180-\dfrac{360}{n}$.}
\varmapStart
\var{a}{desired interior angle in degrees}
\var{n}{number of sides of the regular polygon, integer $\ge 3$}
\varmapEnd
\GOVERN{
\[
\exists n \in \mathbb{Z}_{\ge 3} \text{ such that } A(n)=a
\quad\Longleftrightarrow\quad
a = 180 - \frac{360}{n}
\quad\Longleftrightarrow\quad
n = \frac{360}{180-a} \in \mathbb{Z}_{\ge 3}.
\]
}
\ASSUMPTIONS{Angles are integer degrees; $a \in (0,180)$. Regular polygon interior angles are uniform.}
\INVARIANTS{
\begin{bullets}
\item $A(n)$ is strictly increasing in $n$ and approaches $180^\circ$ as $n \to \infty$.
\item The set $\{A(n): n \ge 3\}$ equals $\{180 - \tfrac{360}{n}: n \ge 3\}$; thus valid $a$ correspond exactly to divisors of $360$ in the form $180-a$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use $A(n)=\dfrac{(n-2) \cdot 180}{n}$. Linearly scan $n=3,4,\ldots,360$ and check $a n = (n-2)\cdot 180$. Upper bound $360$ suffices since $A(n)$ changes only when $n$ changes and $180 - \tfrac{360}{n}$ converges to $180^\circ$.}
\ASSUMPTIONS{Search up to $n=360$; if no match by then, none exists.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a given $a$, loop $n$ from $3$ to $360$.
\item If $a \cdot n = (n-2)\cdot 180$, return ``YES''.
\item If no $n$ matches, return ``NO''.
\end{algosteps}
\COMPLEXITY{Constant-time per query: $T(n)=\mathcal{O}(360)=\mathcal{O}(1)$, $S(n)=\mathcal{O}(1)$.}
\[
\begin{aligned}
T_{\text{per query}} &\le 358 \text{ iterations of integer arithmetic.}
\end{aligned}
\]
\CORRECTNESS{Directly checks the defining equality for the interior angle across all feasible $n$ up to $360$, which covers all possible regular polygon angles in degrees.}
\EDGECASES{$a=179$ yields ``YES'' ($n=360$). Very small $a$ like $a=1$ yield ``NO''.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Codeforces 270A - Fancy Fence (Baseline: brute-force n from 3..360)
from typing import List, Optional

def read_input(data: Optional[str] = None) -> List[int]:
    import sys
    s = data if data is not None else sys.stdin.read()
    tok = s.strip().split()
    if not tok:
        return []
    it = iter(tok)
    try:
        t = int(next(it))
    except StopIteration:
        return []
    angles = []
    for _ in range(t):
        try:
            angles.append(int(next(it)))
        except StopIteration:
            break
    return angles

def solve_case(a: int) -> str:
    # Check if there exists n in [3..360] with a*n == (n-2)*180
    for n in range(3, 361):
        if a * n == (n - 2) * 180:
            return "YES"
    return "NO"

def solve_all(angles: List[int]) -> List[str]:
    return [solve_case(a) for a in angles]

def main() -> None:
    angles = read_input()
    ans = solve_all(angles)
    if ans:
        print("\n".join(ans))

# Basic asserts
assert solve_case(60) == "YES"     # triangle
assert solve_case(90) == "YES"     # square
assert solve_case(30) == "NO"      # no n
assert solve_case(179) == "YES"    # n = 360
assert solve_case(1) == "NO"
assert solve_all([60, 30, 90]) == ["YES", "NO", "YES"]

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked typical cases: triangle, square, invalid small angle, near-$180^\circ$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Divisibility Characterization}
\WHICHFORMULA{From $a=180-\tfrac{360}{n}$ we get $n=\tfrac{360}{180-a}$. Therefore, $a$ is valid iff $b=180-a$ divides $360$ and $b>0$.}
\ASSUMPTIONS{Only integer arithmetic; handle $b \le 0$ as impossible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $b=180-a$.
\item If $b \le 0$, return ``NO''.
\item If $360 \bmod b = 0$, return ``YES''; else ``NO''.
\end{algosteps}
\COMPLEXITY{Constant-time per query; strictly less work than scanning $n$.}
\[
\begin{aligned}
T_{\text{per query}} &= \mathcal{O}(1), \quad S_{\text{per query}} = \mathcal{O}(1).
\end{aligned}
\]
\CORRECTNESS{Equivalence follows from algebraic rearrangement. The divisibility ensures an integer $n \ge 3$ since $b \in \{1,\ldots,179\}$ yields $n=\tfrac{360}{b}\ge 2$, and $b\le 120$ for $n\ge 3$ which holds when the divisibility gives $n \ge 3$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Codeforces 270A - Fancy Fence (Improved: divisibility)
from typing import List, Optional

def read_input(data: Optional[str] = None) -> List[int]:
    import sys
    s = data if data is not None else sys.stdin.read()
    tok = s.strip().split()
    if not tok:
        return []
    it = iter(tok)
    try:
        t = int(next(it))
    except StopIteration:
        return []
    angles = []
    for _ in range(t):
        try:
            angles.append(int(next(it)))
        except StopIteration:
            break
    return angles

def solve_case(a: int) -> str:
    b = 180 - a
    if b <= 0:
        return "NO"
    return "YES" if 360 % b == 0 else "NO"

def solve_all(angles: List[int]) -> List[str]:
    return [solve_case(a) for a in angles]

def main() -> None:
    angles = read_input()
    out = solve_all(angles)
    if out:
        print("\n".join(out))

# Asserts
assert solve_case(60) == "YES"     # n=3
assert solve_case(90) == "YES"     # n=4
assert solve_case(30) == "NO"
assert solve_case(179) == "YES"    # n=360
assert solve_case(1) == "NO"
assert solve_all([60, 30, 90, 120]) == ["YES", "NO", "YES", "YES"]

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Cross-check a batch $a=1\ldots 179$ against the brute-force baseline; all outcomes match.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Closed-Form Check with Simple Arithmetic}
\WHICHFORMULA{Use $n=\tfrac{360}{180-a}$ being an integer and $\ge 3$. This is the minimal-time decision procedure.}
\ASSUMPTIONS{Applies for integer $a$ in degrees; $0 < a < 180$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $a$, compute $b=180-a$.
\item If $b \le 0$, answer ``NO''.
\item Else answer ``YES'' iff $360 \bmod b = 0$.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must distinguish residue classes of $a$ modulo divisors of $360$, which requires at least constant-time arithmetic; this method achieves $O(1)$ time and $O(1)$ space per query.}
\COMPLEXITY{Per test case $T=\mathcal{O}(1)$, $S=\mathcal{O}(1)$.}
\[
\begin{aligned}
T_{\text{per query}} &= c_1 \text{ ops (one sub, one compare, one mod, one branch).}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Codeforces 270A - Fancy Fence (Final)
from typing import List, Optional

def read_input(data: Optional[str] = None) -> List[int]:
    import sys
    s = data if data is not None else sys.stdin.read()
    tok = s.strip().split()
    if not tok:
        return []
    it = iter(tok)
    try:
        t = int(next(it))
    except StopIteration:
        return []
    angles = []
    for _ in range(t):
        try:
            angles.append(int(next(it)))
        except StopIteration:
            break
    return angles

def solve_case(a: int) -> str:
    b = 180 - a
    if b <= 0:
        return "NO"
    return "YES" if 360 % b == 0 else "NO"

def solve_all(angles: List[int]) -> List[str]:
    return [solve_case(a) for a in angles]

def main() -> None:
    angles = read_input()
    res = solve_all(angles)
    if res:
        print("\n".join(res))

# Exactly 3 asserts / mini-tests
assert solve_case(60) == "YES"     # triangle
assert solve_case(30) == "NO"
assert solve_case(90) == "YES"     # square

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Sanity tests: $a\in\{60,30,90\}$ produce expected results.}
\RESULT{For each input $a$, print ``YES'' iff $(180-a)$ divides $360$; else print ``NO''.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the decision on representative angles: small invalid (1), boundary high (179), typical valid (60, 90, 120), typical invalid (45). Fuzz-check all $a \in [1,179]$ via cross-approach comparison.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (scan) and Approach B/C (divisibility) for all $a \in [1,179]$; expect identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate the full range $1\ldots 179$ deterministically to cover all cases.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List

def gen_all_angles() -> List[int]:
    return list(range(1, 180))

def brute(a: int) -> str:
    for n in range(3, 361):
        if a * n == (n - 2) * 180:
            return "YES"
    return "NO"

def fast(a: int) -> str:
    b = 180 - a
    if b <= 0:
        return "NO"
    return "YES" if 360 % b == 0 else "NO"

def cross_check() -> None:
    for a in gen_all_angles():
        assert brute(a) == fast(a)

def reference_io(data: str) -> str:
    def read_input(s: str):
        tok = s.strip().split()
        if not tok:
            return []
        it = iter(tok)
        _t = int(next(it))
        res = []
        for _ in range(_t):
            try:
                res.append(int(next(it)))
            except StopIteration:
                break
        return res
    angles = read_input(data)
    out = [fast(a) for a in angles]
    return "\n".join(out)

# Run cross-check on import
cross_check()

# I/O mini-test
inp = "4\n30\n60\n90\n179\n"
exp = "NO\nYES\nYES\nYES"
assert reference_io(inp) == exp
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Codeforces 270A - Fancy Fence (Reference Solution)
from typing import List, Optional

def read_input(data: Optional[str] = None) -> List[int]:
    import sys
    s = data if data is not None else sys.stdin.read()
    tok = s.strip().split()
    if not tok:
        return []
    it = iter(tok)
    try:
        t = int(next(it))
    except StopIteration:
        return []
    res: List[int] = []
    for _ in range(t):
        try:
            res.append(int(next(it)))
        except StopIteration:
            break
    return res

def solve_case(a: int) -> str:
    b = 180 - a
    if b <= 0:
        return "NO"
    return "YES" if 360 % b == 0 else "NO"

def solve_all(angles: List[int]) -> List[str]:
    return [solve_case(a) for a in angles]

def main() -> None:
    angles = read_input()
    ans = solve_all(angles)
    if ans:
        print("\n".join(ans))

# Asserts for quick verification
assert solve_case(60) == "YES"
assert solve_case(30) == "NO"
assert solve_case(90) == "YES"

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Check if $(180-a)$ divides $360$; if yes, print ``YES'', else ``NO''.}
\WHY{This tests quick algebraic reasoning under pressure: relating polygon angles to divisibility, a common CF A-level trick.}
\CHECKLIST{
\begin{bullets}
\item Compute $b=180-a$.
\item If $b \le 0$: output ``NO''.
\item Else if $360 \bmod b = 0$: output ``YES''; else ``NO''.
\item Ensure $n=\tfrac{360}{b} \ge 3$ holds automatically when divisible and $a<180$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $a=179 \Rightarrow b=1 \Rightarrow n=360 \Rightarrow$ YES.
\item $a=1 \Rightarrow b=179$ not dividing $360 \Rightarrow$ NO.
\item $a=60 \Rightarrow b=120 \Rightarrow n=3 \Rightarrow$ YES.
\item $a=90 \Rightarrow b=90 \Rightarrow n=4 \Rightarrow$ YES.
\item $a=30 \Rightarrow b=150$ not dividing $360 \Rightarrow$ NO.
\item $a=120 \Rightarrow b=60 \Rightarrow n=6 \Rightarrow$ YES.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to handle $b \le 0$ (though inputs ensure $a<180$).
\item Using floating-point equality; prefer integer arithmetic.
\item Off-by-one when brute-forcing $n$; ensure $n$ starts at $3$ and includes $360$.
\item Printing extra spaces or missing newlines between answers.
\item Misreading $a$ as an exterior angle instead of interior.
\item Assuming $t$ equals the count of remaining tokens exactly; guard against short input gracefully.
\end{bullets}
}
\FAILMODES{Floating-point comparisons may fail on equality; the integer divisibility approach is robust. Brute-force beyond $360$ is unnecessary and wastes time.}
\ELI{Regular polygons have angles $180 - \tfrac{360}{n}$. So if we can divide $360$ by $(180-a)$ exactly, we have some $n$-gon with that angle; otherwise it is impossible.}
\NotePages{3}

\end{document}