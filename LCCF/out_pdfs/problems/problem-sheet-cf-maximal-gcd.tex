% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximal GCD}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/803/C}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{You are given positive integer number $n$. You should create such strictly increasing sequence of $k$ positive numbers $a_1, a_2, \ldots, a_k$, that their sum is equal to $n$ and greatest common divisor is maximal.

Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them.

If there is no possible sequence then output $-1$.

Input:
The first line consists of two numbers $n$ and $k$ ($1 \le n, k \le 10^{10}$).

Output:
If the answer exists then output $k$ numbers — resulting sequence. Otherwise output $-1$. If there are multiple answers, print any of them.}
\BREAKDOWN{Maximize a common factor $g$ such that $n$ can be written as $g$ times a strictly increasing sequence of $k$ positive integers. Check feasibility via the minimal sum constraint, then construct a canonical increasing sequence once $g$ is chosen.}
\ELI{Scale the smallest strictly increasing sequence by the largest possible divisor of $n$ that still fits under the sum budget.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n$ and $k$ with $1 \le n,k \le 10^{10}$.}
\OUTPUTS{If possible, print $k$ strictly increasing positive integers summing to $n$ whose greatest common divisor is maximized; otherwise print $-1$. Any valid maximal-GCD sequence is acceptable.}
\SAMPLES{Example 1: $n=18, k=3$. Output could be $3~6~9$.

Example 2: $n=8, k=3$. Output could be $1~2~5$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $g=\gcd(a_1,\ldots,a_k)$. Write $a_i=g x_i$ where $x_1<\cdots<x_k$ are positive integers and $\sum_{i=1}^k a_i=n$. Then $\sum_{i=1}^k x_i = n/g$. We seek to maximize $g$ subject to feasibility of strictly increasing $x_i$.}
\varmapStart
\var{n}{target sum}
\var{k}{sequence length}
\var{g}{greatest common divisor of the sequence}
\var{x_i}{scaled strictly increasing positive integers with $\gcd(x_1,\ldots,x_k)=1$}
\var{S_{\min}}{minimal sum of strictly increasing $k$-tuple, $S_{\min}=\tfrac{k(k+1)}{2}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Feasibility: } \frac{n}{g} \ge S_{\min} \quad\text{and}\quad g \mid n.\\
&\text{Objective: maximize } g \text{ subject to the above.}\\
&\text{Canonical construction for feasible } g:\ a_i = g\cdot i \ \ (1\le i\le k-1),\quad
a_k = n - g\cdot \frac{(k-1)k}{2}.
\end{aligned}
\]
}
\ASSUMPTIONS{A single-element sequence is strictly increasing by convention. For $k\ge 2$, using $x_i=i$ for $i=1,\ldots,k-1$ and placing the remainder in the last term maintains strict increase when $\tfrac{n}{g}\ge \tfrac{k(k+1)}{2}$.}
\INVARIANTS{Sum invariant: $\sum a_i=n$. Order invariant: $a_1<\cdots<a_k$ as long as $\tfrac{n}{g}\ge \tfrac{k(k+1)}{2}$. Divisibility invariant: every $a_i$ is a multiple of $g$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Let $S_{\min}=\tfrac{k(k+1)}{2}$. Any feasible $g$ must satisfy $g \mid n$ and $g \le \left\lfloor \dfrac{n}{S_{\min}}\right\rfloor$. Brute-force scan $g$ downward from $\left\lfloor \dfrac{n}{S_{\min}}\right\rfloor$ to $1$ to find the first divisor of $n$.}
\ASSUMPTIONS{Works for small $\left\lfloor \dfrac{n}{S_{\min}}\right\rfloor$; too slow in worst cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k=1$, output $[n]$.
\item Compute $S_{\min}=k(k+1)/2$. If $S_{\min}>n$, print $-1$.
\item For $g$ from $\left\lfloor \dfrac{n}{S_{\min}}\right\rfloor$ down to $1$, if $n \bmod g=0$ then construct $a_i$ as $g,2g,\ldots,(k-1)g$ and $a_k=n-g\cdot \tfrac{(k-1)k}{2}$; output and stop.
\end{algosteps}
\COMPLEXITY{Let $M=\left\lfloor \dfrac{n}{S_{\min}}\right\rfloor$. Time $O(M)$ in the worst case, space $O(1)$ aside from output.}
\[
\begin{aligned}
T(n) &= O\!\left(\left\lfloor \frac{n}{k(k+1)/2}\right\rfloor\right).
\end{aligned}
\]
\CORRECTNESS{The first found $g$ in descending order is maximal by construction; the sequence is strictly increasing and sums to $n$ with all terms divisible by $g$.}
\EDGECASES{$k=1$; $S_{\min}>n$; $S_{\min}=n$ (then $g=1$ and sequence $1,2,\ldots,k$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from math import isqrt

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0]); k = int(data[1])
    return n, k

def construct_sequence(n, k, g):
    # First k-1 terms: g,2g,...,(k-1)g; last is the remainder
    res = [g * i for i in range(1, k)]
    last = n - g * (k - 1) * k // 2
    res.append(last)
    return res

def solve_case(n, k):
    if k == 1:
        return [n]
    need = k * (k + 1) // 2
    if need > n:
        return None
    maxg = n // need
    for g in range(maxg, 0, -1):
        if n % g == 0:
            return construct_sequence(n, k, g)
    return None

def solve_all():
    nk = read_input()
    if nk is None:
        return
    n, k = nk
    ans = solve_case(n, k)
    out = "-1" if ans is None else " ".join(str(x) for x in ans)
    print(out)

def _run_tests():
    # Small sanity tests for the core solver
    assert solve_case(18, 3) == [3, 6, 9]
    assert solve_case(8, 3) == [1, 2, 5]
    assert solve_case(3, 3) is None
    # k=1
    assert solve_case(10, 1) == [10]

if __name__ == "__main__":
    if sys.stdin.isatty():
        _run_tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Checked that sums equal $n$, terms strictly increase, and impossibility is detected when $S_{\min}>n$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized via Divisor Enumeration}
\WHICHFORMULA{Instead of linear scanning, enumerate divisors of $n$ in $O(\sqrt{n})$ and pick the largest divisor $g$ with $g \le \left\lfloor \dfrac{n}{S_{\min}} \right\rfloor$.}
\ASSUMPTIONS{Trial division up to $\lfloor \sqrt{n} \rfloor$ is feasible for $n \le 10^{10}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Handle $k=1$ and the feasibility check $S_{\min}\le n$ as before.
\item Let $m=\left\lfloor \dfrac{n}{S_{\min}} \right\rfloor$.
\item For each $d$ up to $\lfloor \sqrt{n} \rfloor$ with $d \mid n$, consider both $d$ and $n/d$; keep the largest divisor $\le m$.
\item If none, print $-1$; else build the sequence with that $g$.
\end{algosteps}
\COMPLEXITY{Divisor enumeration is $O(\sqrt{n})$ time and $O(1)$ extra space.}
\[
\begin{aligned}
T(n) &= O(\sqrt{n}),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Any feasible $g$ must divide $n$ and be $\le m$. Taking the maximum such divisor achieves the maximal GCD. The canonical construction preserves strict increase and correct sum.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from math import isqrt

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0]); k = int(data[1])
    return n, k

def construct_sequence(n, k, g):
    res = [g * i for i in range(1, k)]
    last = n - g * (k - 1) * k // 2
    res.append(last)
    return res

def best_gcd(n, k):
    need = k * (k + 1) // 2
    if need > n:
        return 0
    m = n // need
    best = 0
    r = isqrt(n)
    for d in range(1, r + 1):
        if n % d == 0:
            if d <= m and d > best:
                best = d
            other = n // d
            if other <= m and other > best:
                best = other
    return best

def solve_case(n, k):
    if k == 1:
        return [n]
    g = best_gcd(n, k)
    if g == 0:
        return None
    return construct_sequence(n, k, g)

def solve_all():
    nk = read_input()
    if nk is None:
        return
    n, k = nk
    ans = solve_case(n, k)
    print("-1" if ans is None else " ".join(map(str, ans)))

def _run_tests():
    assert solve_case(18, 3) == [3, 6, 9]
    assert solve_case(8, 3) == [1, 2, 5]
    assert solve_case(3, 3) is None
    # A case where large divisor is chosen
    ans = solve_case(100, 2)
    assert ans is not None and sum(ans) == 100 and ans[0] < ans[1] and (ans[0] if ans[0] == ans[1] else ans[0])  # trivial check structure
    # More explicit checks
    ans = solve_case(100, 2); g = min(ans)
    from math import gcd
    assert gcd(ans[0], ans[1]) == g

if __name__ == "__main__":
    if sys.stdin.isatty():
        _run_tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Edge cases $k=1$, $S_{\min}>n$, and random small pairs $(n,k)$ cross-checked against brute force for small $n$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divisor Sieve with Canonical Construction}
\WHICHFORMULA{Compute $S_{\min}=\tfrac{k(k+1)}{2}$, set $m=\left\lfloor \dfrac{n}{S_{\min}} \right\rfloor$, and pick the largest divisor of $n$ not exceeding $m$ via $\sqrt{n}$ enumeration. Construct $g,2g,\ldots,(k-1)g$ and the last term as the remainder.}
\ASSUMPTIONS{Integer arithmetic fits in Python integers; $\sqrt{n}\le 10^5$ ensures fast divisor scan.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k=1$, output $[n]$.
\item Compute $S_{\min}=\tfrac{k(k+1)}{2}$. If $S_{\min}>n$, output $-1$.
\item Let $m=\left\lfloor \dfrac{n}{S_{\min}} \right\rfloor$. Enumerate divisors of $n$ and take the maximum $g\le m$.
\item Output $g,2g,\ldots,(k-1)g$ and $n-g\cdot \tfrac{(k-1)k}{2}$.
\end{algosteps}
\OPTIMALITY{No algorithm can avoid considering divisors of $n$ to decide feasibility of a particular $g \mid n$; enumerating all divisors in $O(\sqrt{n})$ is asymptotically optimal for arbitrary $n$ given no prior factorization.}
\COMPLEXITY{Time $O(\sqrt{n})$; space $O(1)$ plus output.}
\[
\begin{aligned}
T(n) &= O(\sqrt{n}),\quad S(n)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from math import isqrt, gcd

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0]); k = int(data[1])
    return n, k

def construct_sequence(n, k, g):
    # Build k-1 consecutive multiples of g, then the final remainder term.
    res = [g * i for i in range(1, k)]
    last = n - g * (k - 1) * k // 2
    res.append(last)
    return res

def largest_divisor_leq(n, limit):
    best = 0
    r = isqrt(n)
    for d in range(1, r + 1):
        if n % d == 0:
            if d <= limit and d > best:
                best = d
            other = n // d
            if other <= limit and other > best:
                best = other
    return best

def solve_case(n, k):
    if k == 1:
        return [n]
    need = k * (k + 1) // 2
    if need > n:
        return None
    m = n // need
    g = largest_divisor_leq(n, m)
    if g == 0:
        return None
    return construct_sequence(n, k, g)

def solve_all():
    nk = read_input()
    if nk is None:
        return
    n, k = nk
    ans = solve_case(n, k)
    if ans is None:
        print("-1")
    else:
        print(" ".join(map(str, ans)))

def _run_tests():
    # Exactly 3 asserts or mini-tests
    assert solve_case(18, 3) == [3, 6, 9]
    assert solve_case(8, 3) == [1, 2, 5]
    assert solve_case(3, 3) is None

if __name__ == "__main__":
    if sys.stdin.isatty():
        _run_tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Three asserts cover a typical feasible case with $g>1$, a feasible case with $g=1$, and an infeasible case.}
\RESULT{Print any valid maximal-GCD sequence if it exists; otherwise print $-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the solver on hand-crafted cases: infeasible when $k(k+1)/2>n$; $k=1$; random small $n$ cross-checked with brute force; and edge cases where the best $g$ is the larger co-divisor near $\sqrt{n}$.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A vs B vs C on small $n$ to ensure consistent sums, strict increase, and equal GCDs.}
\LINE{EDGE-CASE GENERATOR}{Generate pairs $(n,k)$ with $k\in[1,20]$, $n\in[1,2000]$; for each, brute-force scan $g$ and verify Approach C matches.}
\begin{minted}{python}
import random
from math import gcd, isqrt

def brute_max_g(n, k):
    if k == 1:
        return n
    need = k * (k + 1) // 2
    if need > n:
        return 0
    m = n // need
    # largest divisor of n not exceeding m
    best = 0
    for g in range(1, m + 1):
        if n % g == 0:
            best = g
    return best

def reference_solve(n, k):
    if k == 1:
        return [n]
    need = k * (k + 1) // 2
    if need > n:
        return None
    m = n // need
    # O(sqrt(n)) pick
    best = 0
    r = isqrt(n)
    for d in range(1, r + 1):
        if n % d == 0:
            if d <= m and d > best:
                best = d
            other = n // d
            if other <= m and other > best:
                best = other
    if best == 0:
        return None
    res = [best * i for i in range(1, k)]
    res.append(n - best * (k - 1) * k // 2)
    return res

def quick_self_check():
    # Deterministic small sweep
    for n in range(1, 501):
        for k in range(1, 21):
            g = brute_max_g(n, k)
            ans = reference_solve(n, k)
            if g == 0:
                assert ans is None
            else:
                assert ans is not None
                assert sum(ans) == n
                assert all(ans[i] < ans[i+1] for i in range(len(ans)-1))
                gg = 0
                for v in ans:
                    gg = v if gg == 0 else gcd(gg, v)
                assert gg == g

if __name__ == "__main__":
    quick_self_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from math import isqrt

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0]); k = int(data[1])
    return n, k

def largest_divisor_leq(n, limit):
    best = 0
    r = isqrt(n)
    for d in range(1, r + 1):
        if n % d == 0:
            if d <= limit and d > best:
                best = d
            other = n // d
            if other <= limit and other > best:
                best = other
    return best

def solve_case(n, k):
    if k == 1:
        return [n]
    need = k * (k + 1) // 2
    if need > n:
        return None
    m = n // need
    g = largest_divisor_leq(n, m)
    if g == 0:
        return None
    res = [g * i for i in range(1, k)]
    last = n - g * (k - 1) * k // 2
    res.append(last)
    return res

def solve_all():
    nk = read_input()
    if nk is None:
        return
    n, k = nk
    ans = solve_case(n, k)
    if ans is None:
        print("-1")
    else:
        print(" ".join(map(str, ans)))

def _run_tests():
    # Basic regression asserts
    assert solve_case(18, 3) == [3, 6, 9]
    assert solve_case(8, 3) == [1, 2, 5]
    assert solve_case(3, 3) is None

if __name__ == "__main__":
    if sys.stdin.isatty():
        _run_tests()
    else:
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize $g \mid n$ such that $n/g \ge \tfrac{k(k+1)}{2}$, then output a nearly consecutive scaled sequence.}
\WHY{Combines number theory (divisors, GCD) with constructive reasoning; common in mid-to-hard CF interview problems.}
\CHECKLIST{Compute $S_{\min}=\tfrac{k(k+1)}{2}$. If $S_{\min}>n$ then $-1$. Let $m=\left\lfloor \dfrac{n}{S_{\min}} \right\rfloor$. Pick the largest divisor of $n$ not exceeding $m$. Build sequence $g,2g,\ldots,(k-1)g$, remainder as last term.}
\EDGECASES{$k=1$; $S_{\min}=n$; $n$ prime; $k$ very large where $S_{\min}$ quickly exceeds $n$; $n$ a perfect square; cases where the best divisor is $n$ itself.}
\PITFALLS{Overflow in $k(k+1)/2$ if using fixed-width types; forgetting strict increase; not ensuring the last term is at least $kg$; scanning all $g$ linearly; missing the paired divisor $n/d$.}
\FAILMODES{Brute force over $g$ is too slow when $m$ is large; skipping feasibility check leads to negative or non-increasing last term; not handling $k=1$ separately. The divisor enumeration survives all by construction.}
\ELI{Find how big a step size $g$ you can use so that $k$ steps $g,2g,\ldots$ still fit within $n$. Use the biggest $g$ dividing $n$ that fits, and pour the leftover into the last step.}
\NotePages{3}

\end{document}