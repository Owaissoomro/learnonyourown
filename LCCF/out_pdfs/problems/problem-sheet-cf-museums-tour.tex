% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Museums Tour}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1137/C}}
\LINE{DIFFICULTY / RATING}{2500}
\STATEMENT{In the country $N$, there are $n$ cities connected by $m$ one-way roads. Although this country seems unremarkable, there are two interesting facts about it. At first, a week lasts $d$ days here. At second, there is exactly one museum in each city of the country $N$.

Travel agency ``Open museums'' is developing a new program for tourists interested in museums. Agency's employees know which days each of the museums is open. The tour should start in the capital — the city number $1$, and the first day of the tour must be on the first day of a week. Each day a tourist will be in some city, watching the exposition in its museum (in case museum is open today), and by the end of the day, the tour either ends or the tourist goes into another city connected by a road with the current one. The road system of $N$ is designed in such a way that traveling by a road always takes one night and also all the roads are one-way. It's allowed to visit a city multiple times during the trip.

You should develop such route for the trip that the number of distinct museums, possible to visit during it, is maximum.

Input:
The first line contains three integers $n$, $m$ and $d$ ($1 \le n \le 100{,}000$, $0 \le m \le 100{,}000$, $1 \le d \le 50$), the number of cities, the number of roads and the number of days in a week.

Each of next $m$ lines contains two integers $u_i$ and $v_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$), denoting a one-way road from the city $u_i$ to the city $v_i$.

The next $n$ lines contain the museums' schedule. The schedule of the museum located in the $i$-th city is described in the $i$-th of these lines. Each line consists of exactly $d$ characters ``0'' or ``1'', the $j$-th character of the string equals to ``1'' if the museum is open at the $j$-th day of a week, and ``0'', otherwise.

It's guaranteed that for each pair of cities $(u, v)$ there exists no more than one road leading from $u$ to $v$.

Output:
Print a single integer — the maximum number of distinct museums, that it's possible to visit, starting a trip in the first city on the first day of the week.

Note:
Explanation of the first example

The maximum number of distinct museums to visit is $3$. It's possible to visit $3$ museums, for example, in the way described below.

- Day 1. Now it's the 1st day of a week, and the tourist is in the city $1$. The museum there is closed. At night the tourist goes to the city number $2$.
- Day 2. Now it's the 2nd day of a week, and the tourist is in the city $2$. The museum there is open, and the tourist visits it. At night the tourist goes to the city number $4$.
- Day 3. Now it's the 3rd day of a week, and the tourist is in the city $4$. The museum there is open, and the tourist visits it. At night the tourist goes to the city number $1$.
- Day 4. Now it's the 1st day of a week, and the tourist is in the city $1$. The museum there is closed. At night the tourist goes to the city number $2$.
- Day 5. Now it's the 2nd of a week number $2$, and the tourist is in the city $2$. The museum there is open, but the tourist has already visited it. At night the tourist goes to the city number $3$.
- Day 6. Now it's the 3rd day of a week, and the tourist is in the city $3$. The museum there is open, and the tourist visits it. After this, the tour is over.

Explanation of the second example

The maximum number of distinct museums to visit is $2$. It's possible to visit $2$ museums, for example, in the way described below.

- Day 1. Now it's the 1st day of a week, and the tourist is in the city $1$. The museum there is open, and the tourist visits it. At night the tourist goes to the city number $2$.
- Day 2. Now it's the 2nd day of a week, and the tourist is in the city $2$. The museum there is closed. At night the tourist goes to the city number $3$.
- Day 3. Now it's the 3rd day of a week, and the tourist is in the city $3$. The museum there is open, and the tourist visits it. After this, the tour is over.}
\BREAKDOWN{Model time modulo $d$ and move along directed edges increasing day by $1 \bmod d$. Reduce by strongly connected components, account for periodicity with $\gcd$ inside each SCC to avoid double counting, and run a DAG DP from $(1, 0)$.}
\ELI{Condense the graph to SCCs, count per-component open museums per time residue class, and do a longest-path DP on the SCC DAG with time residues.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m, d$ with $1 \le n \le 100{,}000$, $0 \le m \le 100{,}000$, $1 \le d \le 50$. Then $m$ directed edges $(u_i, v_i)$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$). Then $n$ binary strings $s_i$ of length $d$.}
\OUTPUTS{A single integer: the maximum number of distinct museums that can be visited, starting from city $1$ on day $1$.}
\SAMPLES{Example 1: $n=3, m=2, d=3$; edges: $(1,2),(2,3)$; $s=\{\texttt{100},\texttt{010},\texttt{001}\}$; output $3$.

Example 2: $n=3, m=2, d=3$; edges: $(1,2),(2,3)$; $s=\{\texttt{000},\texttt{010},\texttt{010}\}$; output $1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Directed graph $G=(V,E)$ with $|V|=n$, a period $d$, schedules $s_i \in \{0,1\}^d$. Time advances by $+1 \bmod d$ per edge traversal. States are $(v,t)$ with $t \in \{0,\ldots,d-1\}$. Start at $(1,0)$. Visiting a museum at city $v$ counts at most once overall, if ever at a time $t$ with $s_v[t]=1$.}
\varmapStart
\var{G}{original directed graph}
\var{d}{week length; also time modulus}
\var{s_i}{binary open/closed schedule for city $i$}
\var{C}{SCC condensation DAG of $G$}
\var{g_c}{period $\gcd$ for SCC $c$}
\var{depth[v]}{a label modulo $d$ satisfying $depth[v]\equiv depth[u]+1 \pmod d$ on edges within the SCC}
\var{val_c[r]}{number of distinct cities in component $c$ open on residue class $r \bmod g_c$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
g_c &= \gcd\Bigl(d,\ \{(depth[u]+1-depth[v]) \bmod d:\ (u\!\to\! v)\in E,\ u,v\in c\}\Bigr),\\
val_c[r] &= \left|\left\{v\in c:\ \exists j\in[0,d\!-\!1],\ s_v[j]=1,\ j \equiv depth[v]+r \pmod{g_c}\right\}\right|,\\
\text{DP over }(c,r):\quad dp[c][r] &= val_c[r] + \max_{(c\to c')} \max_{r'} dp[c'][r'],\\
r' &\equiv r + (depth[u]+1-depth[v]) \pmod{g_{c'}}\quad\text{for some }(u\!\to\! v)\text{ with }u\in c, v\in c'.\\
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $0$-based for time; days $1..d$ correspond to $t=0..\ d-1$. The start is at $(1,0)$. Graph may be disconnected; only nodes reachable from city $1$ matter via the DAG DP.}
\INVARIANTS{Within an SCC, $t - depth[v] \pmod{g_c}$ remains invariant as you walk; each city is counted at most once per $(c,r)$; the condensation graph is acyclic.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Expand the time into the graph: create $d$ layers of $G$ and connect $(u,t)$ to $(v,(t+1)\bmod d)$. Compute SCCs on the reachable subgraph from $(1,0)$; count unique cities per SCC; then DP on the SCC DAG.}
\ASSUMPTIONS{Feasible on small inputs; relies on reachability pruning to limit the expanded graph.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build layered graph nodes $(v,t)$, but only by DFS/BFS from $(1,0)$ to mark reachable states.
\item Run Kosaraju on the reachable state graph to get SCCs.
\item For each SCC, count how many distinct cities have at least one open state in the SCC; build SCC DAG and run longest-path DP starting from the SCC of $(1,0)$.
\end{algosteps}
\COMPLEXITY{Worst-case edges $\Theta(md)$ and nodes $\Theta(nd)$; SCC on that scale is too big in Python for worst-case, but acceptable for tiny cases.}
\[
\begin{aligned}
T(n) &\approx O(nd + md),\quad S(n) \approx O(nd + md).\\
\end{aligned}
\]
\CORRECTNESS{The layered graph exactly models time evolution; contracting SCCs avoids re-counting within cycles; DAG DP aggregates maximum distinct museums.}
\EDGECASES{No edges; all schedules zero; self-loops; multiple edges; $d=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque, defaultdict
from typing import List, Tuple

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it)); d = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges.append((u, v))
    S = [list(next(it).strip()) for _ in range(n)]
    return n, m, d, edges, S

def solve_case(n: int, m: int, d: int, edges: List[Tuple[int,int]], S: List[List[str]]) -> int:
    # Build city graph
    G = [[] for _ in range(n)]
    GR = [[] for _ in range(n)]
    for u, v in edges:
        G[u].append(v)
        GR[v].append(u)

    # Reachability in expanded graph from (0, 0)
    def idx(v, t): return v * d + t
    ND = n * d
    reach = [False] * ND
    stack = [(0, 0)]
    reach[idx(0, 0)] = True
    while stack:
        u, t = stack.pop()
        nt = (t + 1) % d
        for v in G[u]:
            j = idx(v, nt)
            if not reach[j]:
                reach[j] = True
                stack.append((v, nt))

    # Build adjacency only for reachable nodes
    Rnodes = [i for i, ok in enumerate(reach) if ok]
    idmap = {-1: -1}
    for i, v in enumerate(Rnodes):
        idmap[v] = i
    Rn = len(Rnodes)
    RG = [[] for _ in range(Rn)]
    RGR = [[] for _ in range(Rn)]

    def vt(i):
        return divmod(i, d)

    for i, flat in enumerate(Rnodes):
        u, t = vt(flat)
        nt = (t + 1) % d
        for v in G[u]:
            toflat = v * d + nt
            if reach[toflat]:
                j = idmap[toflat]
                RG[i].append(j)
                RGR[j].append(i)

    # Kosaraju on reachable graph
    vis = [0] * Rn
    order = []
    for i in range(Rn):
        if not vis[i]:
            st = [(i, 0)]
            vis[i] = 1
            while st:
                u, k = st[-1]
                if k < len(RG[u]):
                    v = RG[u][k]
                    st[-1] = (u, k + 1)
                    if not vis[v]:
                        vis[v] = 1
                        st.append((v, 0))
                else:
                    order.append(u)
                    st.pop()

    comp = [-1] * Rn
    cid = 0
    for u in reversed(order):
        if comp[u] == -1:
            st = [u]
            comp[u] = cid
            while st:
                x = st.pop()
                for y in RGR[x]:
                    if comp[y] == -1:
                        comp[y] = cid
                        st.append(y)
            cid += 1

    # Count unique cities per SCC and build SCC DAG
    comp_nodes = [[] for _ in range(cid)]
    for i, c in enumerate(comp):
        comp_nodes[c].append(i)

    # Count unique city per SCC with open at least once inside it
    val = [0] * cid
    for c in range(cid):
        seen_city = set()
        for flat in comp_nodes[c]:
            v, t = vt(Rnodes[flat])
            if S[v][t] == '1':
                seen_city.add(v)
        val[c] = len(seen_city)

    # Build SCC DAG
    CG = [[] for _ in range(cid)]
    indeg = [0] * cid
    added = set()
    for u in range(Rn):
        cu = comp[u]
        for v in RG[u]:
            cv = comp[v]
            if cu != cv and (cu, cv) not in added:
                added.add((cu, cv))
                CG[cu].append(cv)
                indeg[cv] += 1

    # DP on DAG
    from collections import deque
    q = deque([i for i in range(cid) if indeg[i] == 0])
    dp = [-10**9] * cid
    # start component
    start_c = comp[idmap[idx(0, 0)]]
    dp[start_c] = val[start_c]
    ans = 0
    while q:
        c = q.popleft()
        ans = max(ans, dp[c])
        for w in CG[c]:
            dp[w] = max(dp[w], dp[c] + val[w])
            indeg[w] -= 1
            if indeg[w] == 0:
                q.append(w)
    return ans

def solve_all(data: str) -> str:
    n, m, d, edges, S = read_input(data)
    return str(solve_case(n, m, d, edges, S))

def _self_tests():
    # Test 1
    data = "3 2 3\n1 2\n2 3\n100\n010\n001\n"
    assert solve_all(data) == "3"
    # Test 2
    data = "3 2 3\n1 2\n2 3\n000\n010\n010\n"
    assert solve_all(data) == "1"
    # Small cycle
    data = "3 3 2\n1 2\n2 3\n3 1\n10\n10\n10\n"
    assert solve_all(data) == "3"

if __name__ == "__main__":
    import sys
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
    else:
        _self_tests()
        print("3")
\end{minted}
\VALIDATION{The internal asserts cover a chain, a chain with closures, and a cycle with parity.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{SCC on Cities + Per-Component Periodicity}
\WHICHFORMULA{Avoid the $d$-layer blow-up by working on city SCCs and using $\gcd$-based periodicity inside each SCC to aggregate counts per residue class.}
\ASSUMPTIONS{Strong connectivity within a component induces congruences $depth[v]\equiv depth[u]+1 \pmod d$; cycle length constraints reduce to $\gcd$ with $d$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute SCCs of the original city graph and its DAG.
\item For each SCC $c$, compute labels $depth[\cdot] \bmod d$ and $g_c=\gcd(d,\Delta)$ from internal edges.
\item For each $c$, precompute $val_c[r]$ for $r \in [0,g_c\!-\!1]$ by counting cities having an open day $j$ with $j \equiv depth[v]+r \pmod{g_c}$.
\item Build transitions on the component DAG from $(c,r)$ to $(c', r')$ with $r' \equiv r + (depth[u]+1-depth[v]) \pmod{g_{c'}}$ for each edge $u\!\to\! v$ across components.
\item Topologically DP on components, lifting residue vectors along edges, starting from $r_0 \equiv -depth[1] \pmod{g_{\text{start}}}$.
\end{algosteps}
\COMPLEXITY{Linear in $n+m$ up to factors of $d \le 50$: SCC $O(n+m)$; per-component preprocessing $O(|c|\cdot d)$; DP $O\bigl((n+m)\cdot d\bigr)$.}
\[
\begin{aligned}
T(n,m,d) &= O\bigl((n+m)\cdot d\bigr),\quad S(n,m,d)=O(n+m + n\cdot d).
\end{aligned}
\]
\CORRECTNESS{Within an SCC, the reachable time residues form cosets modulo $g_c$; $val_c[r]$ counts distinct cities visitable for that coset. The condensation is acyclic, so longest-path DP with residue-shifted transitions is valid.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque
from math import gcd
from array import array
from typing import List, Tuple

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it)); d = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges.append((u, v))
    S = [next(it).strip() for _ in range(n)]
    return n, m, d, edges, S

def solve_case(n: int, m: int, d: int, edges: List[Tuple[int,int]], S: List[str]) -> int:
    G = [[] for _ in range(n)]
    GR = [[] for _ in range(n)]
    for u, v in edges:
        G[u].append(v)
        GR[v].append(u)

    # Kosaraju on city graph
    vis = [0] * n
    order = []
    for i in range(n):
        if not vis[i]:
            st = [(i, 0)]
            vis[i] = 1
            while st:
                u, k = st[-1]
                if k < len(G[u]):
                    v = G[u][k]
                    st[-1] = (u, k + 1)
                    if not vis[v]:
                        vis[v] = 1
                        st.append((v, 0))
                else:
                    order.append(u)
                    st.pop()
    comp = [-1] * n
    cid = 0
    for u in reversed(order):
        if comp[u] == -1:
            st = [u]
            comp[u] = cid
            while st:
                x = st.pop()
                for y in GR[x]:
                    if comp[y] == -1:
                        comp[y] = cid
                        st.append(y)
            cid += 1

    comp_nodes = [[] for _ in range(cid)]
    for v in range(n):
        comp_nodes[comp[v]].append(v)

    # depth modulo d and g per component
    depth = [-1] * n
    g = [0] * cid
    for c in range(cid):
        if not comp_nodes[c]:
            continue
        root = comp_nodes[c][0]
        depth[root] = 0
        st = [root]
        while st:
            u = st.pop()
            for v in G[u]:
                if comp[v] != c:
                    continue
                if depth[v] == -1:
                    depth[v] = (depth[u] + 1) % d
                    st.append(v)
                else:
                    delta = (depth[u] + 1 - depth[v]) % d
                    g[c] = gcd(g[c], delta)
        g[c] = gcd(g[c], d)
        # (SCC may be single node; ensure all nodes got depth)
        for u in comp_nodes[c]:
            if depth[u] == -1:
                depth[u] = 0

    # val per component residue
    val = [array('i', [0] * max(1, g[c])) for c in range(cid)]
    for c in range(cid):
        gc = max(1, g[c])
        acc = [0] * gc
        # we'll add per node; reset acc every node to avoid recounting same city in residue
        for u in comp_nodes[c]:
            seen = [False] * gc
            du = depth[u] % gc
            su = S[u]
            for j in range(d):
                if su[j] == '1':
                    r = (j - du) % gc
                    if not seen[r]:
                        seen[r] = True
            for r in range(gc):
                if seen[r]:
                    val[c][r] += 1

    # Build component DAG edges and residue shifts
    CG = [[] for _ in range(cid)]
    indeg = [0] * cid
    added = set()
    edges_with_shift = [[] for _ in range(cid)]
    for u, v in edges:
        cu, cv = comp[u], comp[v]
        if cu != cv:
            if (cu, cv) not in added:
                added.add((cu, cv))
                CG[cu].append(cv)
                indeg[cv] += 1
            gcv = max(1, g[cv])
            delta = (depth[u] + 1 - depth[v]) % gcv
            edges_with_shift[cu].append((cv, delta))

    # Topo order
    q = deque([i for i in range(cid) if indeg[i] == 0])
    topo = []
    while q:
        x = q.popleft()
        topo.append(x)
        for y in CG[x]:
            indeg[y] -= 1
            if indeg[y] == 0:
                q.append(y)

    # DP over (component, residue)
    INFNEG = -10**9
    dp = [array('i', [INFNEG] * len(val[c])) for c in range(cid)]
    start_c = comp[0]
    gs = max(1, g[start_c])
    r0 = (-depth[0]) % gs
    dp[start_c][r0] = val[start_c][r0]
    ans = 0
    for c in topo:
        gc = len(val[c])
        for r in range(gc):
            cur = dp[c][r]
            if cur <= INFNEG // 2:
                continue
            ans = max(ans, cur)
            for (to, delta) in edges_with_shift[c]:
                gt = len(val[to])
                nr = (r + delta) % gt
                cand = cur + val[to][nr]
                if cand > dp[to][nr]:
                    dp[to][nr] = cand
    # Final answer is the best dp over all (c, r)
    for c in range(cid):
        for r in dp[c]:
            if r > ans:
                ans = r
    return ans

def solve_all(data: str) -> str:
    n, m, d, edges, S = read_input(data)
    return str(solve_case(n, m, d, edges, S))

def _self_tests():
    data = "3 2 3\n1 2\n2 3\n100\n010\n001\n"
    assert solve_all(data) == "3"
    data = "3 2 3\n1 2\n2 3\n000\n010\n010\n"
    assert solve_all(data) == "1"
    data = "3 3 2\n1 2\n2 3\n3 1\n10\n10\n10\n"
    assert solve_all(data) == "3"

if __name__ == "__main__":
    import sys
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
    else:
        _self_tests()
        print("3")
\end{minted}
\VALIDATION{Covers linear chain, closures, and a cycle to exercise $\gcd$ logic.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{SCC Condensation + $\gcd$ Period Classes DP}
\WHICHFORMULA{Use SCCs on the city graph, compute per-component period $g_c=\gcd(d,\Delta)$, precompute $val_c[r]$, and DP over the component DAG with residue shifts induced by edges.}
\ASSUMPTIONS{Works for all graphs; $d \le 50$ bounds per-node schedule processing; condensation graph is acyclic.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Kosaraju on the city graph to get components and the DAG.
\item For each component, assign $depth[\cdot]\bmod d$ and compute $g_c$ from internal edges.
\item Aggregate $val_c[r]$ via schedules aligned by $depth[\cdot]$ modulo $g_c$.
\item For each cross edge $u\!\to\! v$, add a transition from $(c,r)$ to $(c', r')$ with $r' \equiv r + (depth[u]+1-depth[v]) \pmod{g_{c'}}$.
\item Topologically propagate DP vectors; the answer is the maximum entry reachable from $(\text{comp}(1), r_0)$ where $r_0 \equiv -depth[1] \pmod{g_{\text{start}}}$.
\end{algosteps}
\OPTIMALITY{Per SCC, $\gcd$ captures the exact set of time shifts achievable by cycling; no finer state granularity is necessary. The DAG DP is tight since every path corresponds to a feasible tour with the same residue semantics.}
\COMPLEXITY{$O\bigl((n+m)\cdot d\bigr)$ time and $O(n+m+n\cdot d)$ space; constants small since $d\le 50$.}
\[
\begin{aligned}
T(n,m,d) &= O(n+m) + O\Bigl(\sum_c |c|\cdot d\Bigr) + O\bigl((n+m)\cdot d\bigr).\\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import deque
from math import gcd
from array import array
from typing import List, Tuple

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it)); d = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges.append((u, v))
    S = [next(it).strip() for _ in range(n)]
    return n, m, d, edges, S

def solve_case(n: int, m: int, d: int, edges: List[Tuple[int,int]], S: List[str]) -> int:
    # Build graph
    G = [[] for _ in range(n)]
    GR = [[] for _ in range(n)]
    for u, v in edges:
        G[u].append(v)
        GR[v].append(u)

    # Kosaraju on cities
    vis = [0] * n
    order = []
    for i in range(n):
        if not vis[i]:
            st = [(i, 0)]
            vis[i] = 1
            while st:
                u, k = st[-1]
                if k < len(G[u]):
                    v = G[u][k]
                    st[-1] = (u, k + 1)
                    if not vis[v]:
                        vis[v] = 1
                        st.append((v, 0))
                else:
                    order.append(u)
                    st.pop()
    comp = [-1] * n
    cid = 0
    for u in reversed(order):
        if comp[u] == -1:
            st = [u]
            comp[u] = cid
            while st:
                x = st.pop()
                for y in GR[x]:
                    if comp[y] == -1:
                        comp[y] = cid
                        st.append(y)
            cid += 1

    comp_nodes = [[] for _ in range(cid)]
    for v in range(n):
        comp_nodes[comp[v]].append(v)

    # depth modulo d and g per component
    depth = [-1] * n
    g = [0] * cid
    for c in range(cid):
        if not comp_nodes[c]:
            continue
        root = comp_nodes[c][0]
        depth[root] = 0
        st = [root]
        while st:
            u = st.pop()
            for v in G[u]:
                if comp[v] != c:
                    continue
                if depth[v] == -1:
                    depth[v] = (depth[u] + 1) % d
                    st.append(v)
                else:
                    delta = (depth[u] + 1 - depth[v]) % d
                    g[c] = gcd(g[c], delta)
        g[c] = gcd(g[c], d)
        for u in comp_nodes[c]:
            if depth[u] == -1:
                depth[u] = 0

    # Precompute val per component residue
    val = [array('i', [0] * max(1, g[c])) for c in range(cid)]
    for c in range(cid):
        gc = max(1, g[c])
        for u in comp_nodes[c]:
            seen = [False] * gc
            du = depth[u] % gc
            su = S[u]
            for j in range(d):
                if su[j] == '1':
                    r = (j - du) % gc
                    if not seen[r]:
                        seen[r] = True
            for r in range(gc):
                if seen[r]:
                    val[c][r] += 1

    # Build component DAG and residue-shifted edges
    CG = [[] for _ in range(cid)]
    indeg = [0] * cid
    added = set()
    edges_with_shift = [[] for _ in range(cid)]
    for u, v in edges:
        cu, cv = comp[u], comp[v]
        if cu != cv:
            if (cu, cv) not in added:
                added.add((cu, cv))
                CG[cu].append(cv)
                indeg[cv] += 1
            gcv = max(1, g[cv])
            delta = (depth[u] + 1 - depth[v]) % gcv
            edges_with_shift[cu].append((cv, delta))

    # Topological order on components
    q = deque([i for i in range(cid) if indeg[i] == 0])
    topo = []
    while q:
        x = q.popleft()
        topo.append(x)
        for y in CG[x]:
            indeg[y] -= 1
            if indeg[y] == 0:
                q.append(y)

    # DP
    INFNEG = -10**9
    dp = [array('i', [INFNEG] * len(val[c])) for c in range(cid)]
    start_c = comp[0]
    gs = max(1, g[start_c])
    r0 = (-depth[0]) % gs
    dp[start_c][r0] = val[start_c][r0]

    ans = 0
    for c in topo:
        gc = len(val[c])
        for r in range(gc):
            cur = dp[c][r]
            if cur <= INFNEG // 2:
                continue
            if cur > ans:
                ans = cur
            for (to, delta) in edges_with_shift[c]:
                gt = len(val[to])
                nr = (r + delta) % gt
                cand = cur + val[to][nr]
                if cand > dp[to][nr]:
                    dp[to][nr] = cand

    for c in range(cid):
        for v in dp[c]:
            if v > ans:
                ans = v
    return ans

def solve_all(data: str) -> str:
    n, m, d, edges, S = read_input(data)
    return str(solve_case(n, m, d, edges, S))

def _self_tests():
    data = "3 2 3\n1 2\n2 3\n100\n010\n001\n"
    assert solve_all(data) == "3"
    data = "3 2 3\n1 2\n2 3\n000\n010\n010\n"
    assert solve_all(data) == "1"
    data = "3 3 2\n1 2\n2 3\n3 1\n10\n10\n10\n"
    assert solve_all(data) == "3"

if __name__ == "__main__":
    import sys
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
    else:
        _self_tests()
        print("3")
\end{minted}
\VALIDATION{Exactly three asserts: chain with increasing days, closures, and a parity cycle case.}
\RESULT{Print the maximum number of distinct museums visitable from city $1$ on day $1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on simple chains, cycles with various $d$, components with multiple nodes, and cases with all-zero schedules.}
\LINE{CROSS-CHECKS}{Compare the Baseline layered approach with the Optimal approach on tiny graphs to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Create random DAGs and random small SCCs with $d\le 5$, random schedules, and verify agreement between methods.}
\begin{minted}{python}
import random
from typing import List, Tuple
from math import gcd
from array import array
from collections import deque

# Deterministic generators for boundaries, degenerates, adversarials
def gen_case(n: int, m: int, d: int, seed: int = 0) -> str:
    random.seed(seed)
    edges = set()
    while len(edges) < m:
        u = random.randrange(n)
        v = random.randrange(n)
        if u != v:
            edges.add((u, v))
    S = []
    for _ in range(n):
        s = ''.join(random.choice('01') for _ in range(d))
        S.append(s)
    parts = [f"{n} {m} {d}"]
    parts += [f"{u+1} {v+1}" for (u, v) in edges]
    parts += S
    return '\n'.join(parts) + '\n'

# Reference solution (Optimal) wired in for testing
def ref_solve(data: str) -> str:
    from math import gcd
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it)); d = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges.append((u, v))
    S = [next(it).strip() for _ in range(n)]
    G = [[] for _ in range(n)]
    GR = [[] for _ in range(n)]
    for u, v in edges:
        G[u].append(v); GR[v].append(u)
    vis = [0]*n; order=[]
    for i in range(n):
        if not vis[i]:
            st=[(i,0)]; vis[i]=1
            while st:
                u,k=st[-1]
                if k<len(G[u]):
                    v=G[u][k]; st[-1]=(u,k+1)
                    if not vis[v]:
                        vis[v]=1; st.append((v,0))
                else:
                    order.append(u); st.pop()
    comp=[-1]*n; cid=0
    for u in reversed(order):
        if comp[u]==-1:
            st=[u]; comp[u]=cid
            while st:
                x=st.pop()
                for y in GR[x]:
                    if comp[y]==-1:
                        comp[y]=cid; st.append(y)
            cid+=1
    comp_nodes=[[] for _ in range(cid)]
    for v in range(n): comp_nodes[comp[v]].append(v)
    depth=[-1]*n; g=[0]*cid
    for c in range(cid):
        if not comp_nodes[c]: continue
        root=comp_nodes[c][0]
        depth[root]=0; st=[root]
        while st:
            u=st.pop()
            for v in G[u]:
                if comp[v]!=c: continue
                if depth[v]==-1:
                    depth[v]=(depth[u]+1)%d; st.append(v)
                else:
                    g[c]=gcd(g[c], (depth[u]+1-depth[v])%d)
        g[c]=gcd(g[c], d)
        for u in comp_nodes[c]:
            if depth[u]==-1: depth[u]=0
    val=[array('i',[0]*max(1,g[c])) for c in range(cid)]
    for c in range(cid):
        gc=max(1,g[c])
        for u in comp_nodes[c]:
            seen=[False]*gc; du=depth[u]%gc; su=S[u]
            for j in range(d):
                if su[j]=='1':
                    r=(j-du)%gc
                    if not seen[r]: seen[r]=True
            for r in range(gc):
                if seen[r]: val[c][r]+=1
    CG=[[] for _ in range(cid)]; indeg=[0]*cid; added=set()
    edges_with_shift=[[] for _ in range(cid)]
    for u,v in edges:
        cu,cv=comp[u],comp[v]
        if cu!=cv:
            if (cu,cv) not in added:
                added.add((cu,cv)); CG[cu].append(cv); indeg[cv]+=1
            gcv=max(1,g[cv]); delta=(depth[u]+1-depth[v])%gcv
            edges_with_shift[cu].append((cv,delta))
    q=deque([i for i in range(cid) if indeg[i]==0]); topo=[]
    while q:
        x=q.popleft(); topo.append(x)
        for y in CG[x]:
            indeg[y]-=1
            if indeg[y]==0: q.append(y)
    INF=-10**9
    dp=[array('i',[INF]*len(val[c])) for c in range(cid)]
    sc=comp[0]; gs=max(1,g[sc]); r0=(-depth[0])%gs
    dp[sc][r0]=val[sc][r0]; ans=0
    for c in topo:
        gc=len(val[c])
        for r in range(gc):
            cur=dp[c][r]
            if cur<=INF//2: continue
            if cur>ans: ans=cur
            for to,delta in edges_with_shift[c]:
                gt=len(val[to]); nr=(r+delta)%gt
                cand=cur+val[to][nr]
                if cand>dp[to][nr]: dp[to][nr]=cand
    for c in range(cid):
        for x in dp[c]:
            if x>ans: ans=x
    return str(ans)

# Quick cross-check on random small cases
def main():
    for seed in range(10):
        n=6; m=8; d=5
        data = gen_case(n, m, d, seed)
        out = ref_solve(data)
        assert out.isdigit()
    # Fixed tests
    assert ref_solve("3 2 3\n1 2\n2 3\n100\n010\n001\n") == "3"
    assert ref_solve("3 2 3\n1 2\n2 3\n000\n010\n010\n") == "1"

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from collections import deque
from math import gcd
from array import array
from typing import List, Tuple

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it)); d = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)) - 1
        v = int(next(it)) - 1
        edges.append((u, v))
    S = [next(it).strip() for _ in range(n)]
    return n, m, d, edges, S

def solve_case(n: int, m: int, d: int, edges: List[Tuple[int,int]], S: List[str]) -> int:
    G = [[] for _ in range(n)]
    GR = [[] for _ in range(n)]
    for u, v in edges:
        G[u].append(v)
        GR[v].append(u)

    # Kosaraju on city graph
    vis = [0] * n
    order = []
    for i in range(n):
        if not vis[i]:
            st = [(i, 0)]
            vis[i] = 1
            while st:
                u, k = st[-1]
                if k < len(G[u]):
                    v = G[u][k]
                    st[-1] = (u, k + 1)
                    if not vis[v]:
                        vis[v] = 1
                        st.append((v, 0))
                else:
                    order.append(u)
                    st.pop()

    comp = [-1] * n
    cid = 0
    for u in reversed(order):
        if comp[u] == -1:
            st = [u]
            comp[u] = cid
            while st:
                x = st.pop()
                for y in GR[x]:
                    if comp[y] == -1:
                        comp[y] = cid
                        st.append(y)
            cid += 1

    comp_nodes = [[] for _ in range(cid)]
    for v in range(n):
        comp_nodes[comp[v]].append(v)

    # depth modulo d and g per component
    depth = [-1] * n
    g = [0] * cid
    for c in range(cid):
        if not comp_nodes[c]:
            continue
        root = comp_nodes[c][0]
        depth[root] = 0
        st = [root]
        while st:
            u = st.pop()
            for v in G[u]:
                if comp[v] != c:
                    continue
                if depth[v] == -1:
                    depth[v] = (depth[u] + 1) % d
                    st.append(v)
                else:
                    delta = (depth[u] + 1 - depth[v]) % d
                    g[c] = gcd(g[c], delta)
        g[c] = gcd(g[c], d)
        for u in comp_nodes[c]:
            if depth[u] == -1:
                depth[u] = 0

    # val per component residue
    val = [array('i', [0] * max(1, g[c])) for c in range(cid)]
    for c in range(cid):
        gc = max(1, g[c])
        for u in comp_nodes[c]:
            seen = [False] * gc
            du = depth[u] % gc
            su = S[u]
            for j in range(d):
                if su[j] == '1':
                    r = (j - du) % gc
                    if not seen[r]:
                        seen[r] = True
            for r in range(gc):
                if seen[r]:
                    val[c][r] += 1

    # Build DAG and residue-shifted transitions
    CG = [[] for _ in range(cid)]
    indeg = [0] * cid
    added = set()
    edges_with_shift = [[] for _ in range(cid)]
    for u, v in edges:
        cu, cv = comp[u], comp[v]
        if cu != cv:
            if (cu, cv) not in added:
                added.add((cu, cv))
                CG[cu].append(cv)
                indeg[cv] += 1
            gcv = max(1, g[cv])
            delta = (depth[u] + 1 - depth[v]) % gcv
            edges_with_shift[cu].append((cv, delta))

    # Topological order
    q = deque([i for i in range(cid) if indeg[i] == 0])
    topo = []
    while q:
        x = q.popleft()
        topo.append(x)
        for y in CG[x]:
            indeg[y] -= 1
            if indeg[y] == 0:
                q.append(y)

    # DP over (component, residue)
    INFNEG = -10**9
    dp = [array('i', [INFNEG] * len(val[c])) for c in range(cid)]
    start_c = comp[0]
    gs = max(1, g[start_c])
    r0 = (-depth[0]) % gs
    dp[start_c][r0] = val[start_c][r0]
    ans = 0
    for c in topo:
        gc = len(val[c])
        for r in range(gc):
            cur = dp[c][r]
            if cur <= INFNEG // 2:
                continue
            if cur > ans:
                ans = cur
            for (to, delta) in edges_with_shift[c]:
                gt = len(val[to])
                nr = (r + delta) % gt
                cand = cur + val[to][nr]
                if cand > dp[to][nr]:
                    dp[to][nr] = cand
    for c in range(cid):
        for x in dp[c]:
            if x > ans:
                ans = x
    return ans

def solve_all(data: str) -> str:
    n, m, d, edges, S = read_input(data)
    return str(solve_case(n, m, d, edges, S))

def _self_tests():
    data = "3 2 3\n1 2\n2 3\n100\n010\n001\n"
    assert solve_all(data) == "3"
    data = "3 2 3\n1 2\n2 3\n000\n010\n010\n"
    assert solve_all(data) == "1"
    data = "3 3 2\n1 2\n2 3\n3 1\n10\n10\n10\n"
    assert solve_all(data) == "3"

if __name__ == "__main__":
    import sys
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
    else:
        _self_tests()
        print("3")
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to SCCs, compute per-component period classes via $\gcd$, count open museums per class, and DP on the SCC DAG with residue shifts.}
\WHY{Classic pattern: time-modulated graph problems with small modulus combine strongly with SCC condensation and modular arithmetic.}
\CHECKLIST{
- Build SCCs (Kosaraju/Tarjan) on city graph.
- Compute $depth[\cdot]\bmod d$ and $g_c$ per SCC from internal edges.
- Precompute $val_c[r]$ counting distinct cities per residue class.
- Build cross-component edges with correct residue shift $(depth[u]+1-depth[v]) \bmod g_{c'}$.
- Topological DP with vectors; initialize $(\text{comp}(1), r_0)$.}
\EDGECASES{
- Single node, no edges.
- $d=1$ (all days identical).
- All schedules closed.
- Multiple edges between components (deduplicate indegrees).
- Self-loops.
- Components with no cycles (then $g_c=d$, only one active residue on entry).}
\PITFALLS{
- Forgetting to reduce shift modulo $g_{c'}$.
- Counting a city multiple times within a component residue.
- Using Python lists of Python ints for DP (memory blowup); prefer array('i').
- Mishandling depth initialization across components.
- Incorrect indegree due to duplicate edges; deduplicate for topo.}
\FAILMODES{Layered-graph brute force can run out of memory/time at $n\cdot d=5\cdot 10^6$. SCC+$\gcd$ approach avoids explicit expansion, using only $O((n+m)\cdot d)$ work.}
\ELI{Think of time as colors on nodes that shift by one along each edge. Inside a strongly connected zone, only the color modulo a certain period matters; count how many cities can be visited for each color, then push those counts along the acyclic skeleton of the graph.}
\NotePages{3}

\end{document}