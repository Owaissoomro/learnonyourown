% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Sorted GCD Pair Queries}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/sorted-gcd-pair-queries/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an integer array \texttt{nums} of length \texttt{n} and an integer array \texttt{queries}. Let \texttt{gcdPairs} denote an array obtained by calculating the GCD of all possible pairs \texttt{(nums[i], nums[j])}, where \texttt{0 <= i < j < n}, and then sorting these values in \textbf{ascending} order. For each query \texttt{queries[i]}, you need to find the element at index \texttt{queries[i]} in \texttt{gcdPairs}. Return an integer array \texttt{answer}, where \texttt{answer[i]} is the value at \texttt{gcdPairs[queries[i]]} for each query. The term \texttt{gcd(a, b)} denotes the \textbf{greatest common divisor} of \texttt{a} and \texttt{b}.

\textbf{Example 1:}
\textbf{Input:} nums = [2,3,4], queries = [0,2,2]
\textbf{Output:} [1,2,2]
\textbf{Explanation:}
\texttt{gcdPairs = [gcd(nums[0], nums[1]), gcd(nums[0], nums[2]), gcd(nums[1], nums[2])] = [1, 2, 1]}. After sorting in ascending order, \texttt{gcdPairs = [1, 1, 2]}. So, the answer is \texttt{[gcdPairs[queries[0]], gcdPairs[queries[1]], gcdPairs[queries[2]]] = [1, 2, 2]}.

\textbf{Example 2:}
\textbf{Input:} nums = [4,4,2,1], queries = [5,3,1,0]
\textbf{Output:} [4,2,1,1]
\textbf{Explanation:}
\texttt{gcdPairs} sorted in ascending order is \texttt{[1, 1, 1, 2, 2, 4]}.

\textbf{Example 3:}
\textbf{Input:} nums = [2,2], queries = [0,0]
\textbf{Output:} [2,2]
\textbf{Explanation:}
\texttt{gcdPairs = [2]}.

\textbf{Constraints:}
\begin{itemize}
\item \texttt{2 <= n == nums.length <= 10\^{}5}
\item \texttt{1 <= nums[i] <= 5 * 10\^{}4}
\item \texttt{1 <= queries.length <= 10\^{}5}
\item \texttt{0 <= queries[i] < n * (n - 1) / 2}
\end{itemize}}
\BREAKDOWN{Count how many pairs yield each possible gcd value $d$. Construct the cumulative distribution of gcd values across pairs. For each query $k$, find the smallest $d$ with cumulative count strictly greater than $k$.}
\ELI{Count how many pairs have gcd $1$, gcd $2$, etc.; then the $k$-th element in the sorted list is the smallest $d$ whose cumulative count exceeds $k$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two arrays: \texttt{nums} with $2 \le n \le 10^5$ and values in $[1, 5\cdot 10^4]$; \texttt{queries} with $1 \le |\texttt{queries}| \le 10^5$ and each $0 \le \texttt{queries[i]} < \tfrac{n(n-1)}{2}$.}
\OUTPUTS{Array \texttt{answer} of same length as \texttt{queries}, where \texttt{answer[i]} equals the value at index \texttt{queries[i]} in the sorted array of all pairwise gcds.}
\SAMPLES{Example 1: \texttt{nums=[2,3,4]}, \texttt{queries=[0,2,2]} $\to$ \texttt{[1,2,2]}. Example 2: \texttt{nums=[4,4,2,1]}, \texttt{queries=[5,3,1,0]} $\to$ \texttt{[4,2,1,1]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $f[x]$ be the frequency of value $x$ in \texttt{nums}. For each divisor $d \in \{1,\ldots,M\}$ with $M=\max(\texttt{nums})$, define $S_d=\sum_{k\ge 1} f[kd]$ (count of elements divisible by $d$). Let $E_d$ denote the number of index pairs $(i,j)$, $i<j$, with $\gcd(\texttt{nums}[i],\texttt{nums}[j])=d$. The sorted multiset of pairwise gcd values is exactly $\{d$ repeated $E_d$ times, for $d=1,\ldots,M\}$. Queries ask for the $k$-th (0-indexed) element of this multiset in ascending order.}
\varmapStart
\var{f[x]}{frequency of value $x$ in \texttt{nums}}
\var{S_d}{count of elements divisible by $d$}
\var{E_d}{number of pairs with gcd exactly $d$}
\var{F(d)}{cumulative pairs with gcd $\le d$, i.e., $F(d)=\sum_{t=1}^{d} E_t$}
\var{k}{a query index into the sorted gcd-pair multiset (0-indexed)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
S_d &= \sum_{m=1}^{\left\lfloor M/d \right\rfloor} f[md], \\
\binom{S_d}{2} &= \sum_{m=1}^{\left\lfloor M/d \right\rfloor} E_{md}, \\
E_d &= \binom{S_d}{2} - \sum_{m=2}^{\left\lfloor M/d \right\rfloor} E_{md}, \\
F(d) &= \sum_{t=1}^{d} E_t, \quad \text{and for query } k:\ \text{answer}(k)=\min\{d: F(d) \ge k+1\}.
\end{aligned}
\]
}
\ASSUMPTIONS{All values are positive integers. Pairs are unordered index pairs $(i,j)$ with $i<j$.}
\INVARIANTS{(1) $\sum_{d=1}^{M} E_d = \binom{n}{2}$. (2) $F$ is nondecreasing in $d$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute all $\binom{n}{2}$ gcds, sort, and index into the sorted list for each query.}
\ASSUMPTIONS{Feasible only for small $n$ due to $O(n^2 \log n)$ behavior.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all pairs $(i,j)$ with $i<j$; compute $\gcd(\texttt{nums}[i], \texttt{nums}[j])$ and collect.
\item Sort the list in ascending order.
\item For each query $k$, output the element at index $k$.
\end{algosteps}
\COMPLEXITY{Let $n=|\texttt{nums}|$. Time $T(n)=\Theta(n^2 \log n)$ due to sorting $\Theta(n^2)$ elements; space $S(n)=\Theta(n^2)$.}
\[
\begin{aligned}
\text{pair count} &= \binom{n}{2} = \Theta(n^2), \\
T(n) &= \Theta(n^2) \text{ gcds} + \Theta(n^2 \log n^2) = \Theta(n^2 \log n).
\end{aligned}
\]
\CORRECTNESS{Sorting the explicit multiset of pairwise gcds and indexing directly implements the problem definition.}
\EDGECASES{All equal numbers; presence of many ones; minimal $n=2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
import math
import random

class Solution:
    # Baseline brute force
    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:
        n = len(nums)
        pairs = []
        for i in range(n):
            xi = nums[i]
            for j in range(i + 1, n):
                pairs.append(math.gcd(xi, nums[j]))
        pairs.sort()
        return [pairs[k] for k in queries]

# Tiny sanity tests (baseline only suitable for small inputs)
sol = Solution()
assert sol.gcdValues([2,3,4], [0,2,2]) == [1,2,2]
assert sol.gcdValues([4,4,2,1], [5,3,1,0]) == [4,2,1,1]
assert sol.gcdValues([2,2], [0,0]) == [2,2]
# Random tiny cross-check against itself
arr = [random.randint(1,8) for _ in range(6)]
brute = Solution().gcdValues(arr, list(range(0, len(arr)*(len(arr)-1)//2)))
assert brute == sorted([math.gcd(arr[i], arr[j]) for i in range(len(arr)) for j in range(i+1, len(arr))])
\end{minted}
\VALIDATION{Checked sample cases; verified a random tiny case equals the explicitly sorted gcd list.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Divisor Sieve + Inclusion–Exclusion; Query Sweep}
\WHICHFORMULA{Count pairs by exact gcd using $E_d = \binom{S_d}{2} - \sum_{m\ge 2} E_{md}$, then answer all queries in ascending order by a single sweep across $d=1\ldots M$.}
\ASSUMPTIONS{Values are bounded by $M=\max(\texttt{nums}) \le 5\cdot 10^4$, enabling harmonic-sum loops over multiples.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build frequency array $f$ on $[1..M]$.
\item For each $d$, compute $S_d=\sum_{m} f[md]$ by adding frequencies over multiples.
\item Compute $E_d$ for $d=M\ldots 1$ via inclusion–exclusion over multiples.
\item Sort queries with original indices; sweep $d=1\ldots M$ maintaining running sum $F(d)$ and answer each query when $F(d)\ge k+1$.
\end{algosteps}
\COMPLEXITY{Computing $S_d$ and $E_d$ costs $O(M \log M)$; answering queries by sweep costs $O(M + Q \log Q)$. This beats the $O(n^2)$ baseline.}
\[
\begin{aligned}
T &\in O\!\left(M \sum_{d=1}^{M}\frac{1}{d}\right) + O(Q\log Q) = O(M\log M + Q\log Q).
\end{aligned}
\]
\CORRECTNESS{By construction, all pairs divisible by $d$ are counted in $\binom{S_d}{2}$; subtracting contributions of strict multiples isolates pairs with exact gcd $d$. Sweeping $d$ in ascending order enumerates the sorted multiset.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    # Improved: multiplicity counting + sweep across gcd values for sorted queries
    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:
        if not nums:
            return []
        max_v = max(nums)
        f = [0] * (max_v + 1)
        for x in nums:
            f[x] += 1
        Sdiv = [0] * (max_v + 1)
        for d in range(1, max_v + 1):
            s = 0
            for m in range(d, max_v + 1, d):
                s += f[m]
            Sdiv[d] = s
        exact = [0] * (max_v + 1)
        for d in range(max_v, 0, -1):
            cnt = Sdiv[d]
            pairs = cnt * (cnt - 1) // 2
            subs = 0
            step = d + d
            for m in range(step, max_v + 1, d):
                subs += exact[m]
            exact[d] = pairs - subs
        # Sweep queries in ascending order
        q_with_idx: List[Tuple[int,int]] = sorted((k, i) for i, k in enumerate(queries))
        ans = [0] * len(queries)
        run = 0
        qi = 0
        for d in range(1, max_v + 1):
            if exact[d] == 0 and qi >= len(q_with_idx):
                continue
            run += exact[d]
            # Answer all queries whose k < run
            while qi < len(q_with_idx) and run >= q_with_idx[qi][0] + 1:
                _, idx = q_with_idx[qi]
                ans[idx] = d
                qi += 1
            if qi == len(q_with_idx):
                break
        return ans

# Tests
sol = Solution()
assert sol.gcdValues([2,3,4], [0,2,2]) == [1,2,2]
assert sol.gcdValues([4,4,2,1], [5,3,1,0]) == [4,2,1,1]
assert sol.gcdValues([2,2], [0,0]) == [2,2]
\end{minted}
\VALIDATION{Validated on the given examples. The sweep ensures strictly increasing cumulative coverage, handling repeated queries naturally.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divisor Sieve + Inclusion–Exclusion; Prefix and Binary Search}
\WHICHFORMULA{Compute $E_d$ as before; build prefix $F(d)=\sum_{t\le d} E_t$; for each query $k$, binary search the smallest $d$ with $F(d)\ge k+1$.}
\ASSUMPTIONS{Applicable whenever values are bounded so that harmonic loops over multiples are efficient.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $f$, compute $S_d$, then $E_d$ via inclusion–exclusion on multiples.
\item Build nondecreasing prefix array $F[1..M]$.
\item For each query $k$, binary search for the first index with $F[d]\ge k+1$ and output $d$.
\end{algosteps}
\OPTIMALITY{The counting phase is near-linear in $M\log M$ and independent of $n$ beyond frequencies. Answering $Q$ queries each in $O(\log M)$ is optimal up to logarithmic factors unless queries are pre-sorted and swept.}
\COMPLEXITY{Time $O(M\log M + Q\log M)$; space $O(M)$.}
\[
\begin{aligned}
T &= O(M\log M) + O(Q\log M), \quad S = O(M).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import bisect

class Solution:
    # Final: multiplicity counting + prefix + per-query binary search
    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:
        max_v = max(nums)
        f = [0] * (max_v + 1)
        for x in nums:
            f[x] += 1
        # Sdiv[d] = count of elements divisible by d
        Sdiv = [0] * (max_v + 1)
        for d in range(1, max_v + 1):
            s = 0
            for m in range(d, max_v + 1, d):
                s += f[m]
            Sdiv[d] = s
        # exact[d] = number of pairs with gcd exactly d
        exact = [0] * (max_v + 1)
        for d in range(max_v, 0, -1):
            cnt = Sdiv[d]
            pairs = cnt * (cnt - 1) // 2
            subs = 0
            for m in range(d + d, max_v + 1, d):
                subs += exact[m]
            exact[d] = pairs - subs
        # Build cumulative counts F(d) over d=1..max_v
        cum = []
        run = 0
        for d in range(1, max_v + 1):
            run += exact[d]
            cum.append(run)
        # Sanity: total pairs
        total_pairs = len(nums) * (len(nums) - 1) // 2
        assert run == total_pairs
        # Answer queries via binary search on cum
        ans = []
        for k in queries:
            d_idx = bisect.bisect_left(cum, k + 1)  # first d with cum[d] >= k+1
            ans.append(d_idx + 1)  # d runs from 1..max_v
        return ans

# Exactly 3 asserts (samples)
sol = Solution()
assert sol.gcdValues([2,3,4], [0,2,2]) == [1,2,2]
assert sol.gcdValues([4,4,2,1], [5,3,1,0]) == [4,2,1,1]
assert sol.gcdValues([2,2], [0,0]) == [2,2]
\end{minted}
\VALIDATION{Three sample asserts pass. The invariant $\sum_d E_d = \binom{n}{2}$ is asserted at runtime.}
\RESULT{For each query index $k$, the returned integer is the gcd value occupying position $k$ in the globally sorted multiset of all pairwise gcds.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on samples; randomized small arrays to cross-check against brute force; property that total cumulative equals $\binom{n}{2}$.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Optimal on small random inputs; ensure identical outputs for all query indices.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of all ones, all equal large value, primes, and mixed composites to stress divisor counting.}
\begin{minted}{python}
from typing import List
import math
import random
import bisect

def brute(nums: List[int], queries: List[int]) -> List[int]:
    arr = []
    n = len(nums)
    for i in range(n):
        for j in range(i+1, n):
            arr.append(math.gcd(nums[i], nums[j]))
    arr.sort()
    return [arr[k] for k in queries]

class Solution:
    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:
        max_v = max(nums)
        f = [0] * (max_v + 1)
        for x in nums:
            f[x] += 1
        Sdiv = [0] * (max_v + 1)
        for d in range(1, max_v + 1):
            s = 0
            for m in range(d, max_v + 1, d):
                s += f[m]
            Sdiv[d] = s
        exact = [0] * (max_v + 1)
        for d in range(max_v, 0, -1):
            cnt = Sdiv[d]
            pairs = cnt * (cnt - 1) // 2
            subs = 0
            for m in range(d + d, max_v + 1, d):
                subs += exact[m]
            exact[d] = pairs - subs
        cum = []
        run = 0
        for d in range(1, max_v + 1):
            run += exact[d]
            cum.append(run)
        total_pairs = len(nums) * (len(nums) - 1) // 2
        assert run == total_pairs
        ans = []
        for k in queries:
            idx = bisect.bisect_left(cum, k + 1)
            ans.append(idx + 1)
        return ans

# Cross-checks
for _ in range(50):
    n = random.randint(2, 10)
    nums = [random.randint(1, 20) for _ in range(n)]
    total = n*(n-1)//2
    # query all positions to compare exact multiset
    queries = list(range(total))
    sol = Solution()
    assert sol.gcdValues(nums, queries) == brute(nums, queries)

# Edge-focused tests
sol = Solution()
assert sol.gcdValues([1,1,1,1], [0,5]) == [1,1]
assert sol.gcdValues([6,10,15], [0,1,2]) == sorted([math.gcd(6,10), math.gcd(6,15), math.gcd(10,15)])
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import bisect

class Solution:
    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:
        max_v = max(nums)
        f = [0] * (max_v + 1)
        for x in nums:
            f[x] += 1
        Sdiv = [0] * (max_v + 1)
        for d in range(1, max_v + 1):
            s = 0
            for m in range(d, max_v + 1, d):
                s += f[m]
            Sdiv[d] = s
        exact = [0] * (max_v + 1)
        for d in range(max_v, 0, -1):
            cnt = Sdiv[d]
            pairs = cnt * (cnt - 1) // 2
            subs = 0
            for m in range(d + d, max_v + 1, d):
                subs += exact[m]
            exact[d] = pairs - subs
        cum = []
        run = 0
        for d in range(1, max_v + 1):
            run += exact[d]
            cum.append(run)
        total_pairs = len(nums) * (len(nums) - 1) // 2
        assert run == total_pairs
        ans = []
        for k in queries:
            idx = bisect.bisect_left(cum, k + 1)
            ans.append(idx + 1)
        return ans

# Samples
sol = Solution()
assert sol.gcdValues([2,3,4], [0,2,2]) == [1,2,2]
assert sol.gcdValues([4,4,2,1], [5,3,1,0]) == [4,2,1,1]
assert sol.gcdValues([2,2], [0,0]) == [2,2]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count pairs by exact gcd via divisor sums and inclusion–exclusion; answer queries by cumulative counts.}
\WHY{This technique—counting by divisors/multiples and Möbius-style subtraction—appears in problems aggregating by gcd/lcm/frequency over bounded integer domains.}
\CHECKLIST{%
\begin{bullets}
\item Build frequency array up to $M=\max(\texttt{nums})$.
\item Compute $S_d$ over multiples.
\item Compute $E_d$ from $M$ down to $1$ subtracting multiples.
\item Prefix $F(d)$ and binary search each query $k$.
\item Sanity-check $\sum_d E_d = \binom{n}{2}$.
\end{bullets}}
\EDGECASES{%
\begin{bullets}
\item All ones $\to$ all gcds are 1.
\item All equal $x$ $\to$ all gcds are $x$.
\item Mix of primes and composites.
\item Large $n$, small $M$.
\item Queries at boundaries $k=0$ and $k=\binom{n}{2}-1$.
\item Repeated queries.
\item Values absent for some $d$ (zero $E_d$).
\item Minimal $n=2$.
\end{bullets}}
\PITFALLS{%
\begin{bullets}
\item Forgetting to subtract strict multiples when computing $E_d$.
\item Off-by-one in binary search ($k$ is 0-indexed; need $F(d)\ge k+1$).
\item Not asserting total pairs equals $\binom{n}{2}$ as a sanity check.
\item Using 1-based vs 0-based indexing inconsistently for $d$.
\item Overflow in other languages when computing $\binom{S_d}{2}$.
\item Building arrays sized larger than necessary (use $M=\max(\texttt{nums})$).
\item Inefficient per-query linear scans instead of binary search or sweep.
\end{bullets}}
\FAILMODES{Brute force fails for $n\approx 10^5$ due to $\Theta(n^2)$ memory/time; frequency-sieve method remains efficient since $M\le 5\cdot 10^4$.}
\ELI{We bucket numbers by their divisors. For each divisor $d$, count how many numbers are multiples of $d$, how many pairs they form, and subtract the pairs already attributed to larger multiples. This gives how many pairs have gcd exactly $d$. Then queries become simple index lookups via a prefix and binary search.}
\NotePages{3}

\end{document}