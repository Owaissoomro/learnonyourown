% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Count of Matches in Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/count-of-matches-in-tournament/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given an integer $n$, the number of teams in a tournament that has strange rules:
\begin{bullets}
\item If the current number of teams is \textbf{even}, each team gets paired with another team. A total of $n / 2$ matches are played, and $n / 2$ teams advance to the next round.
\item If the current number of teams is \textbf{odd}, one team randomly advances in the tournament, and the rest gets paired. A total of $(n - 1) / 2$ matches are played, and $(n - 1) / 2 + 1$ teams advance to the next round.
\end{bullets}
Return the number of matches played in the tournament until a winner is decided.
\par\textbf{Example 1:}
\par Input: $n = 7$
\par Output: $6$
\par Explanation: Details of the tournament:
\begin{bullets}
\item 1st Round: Teams $= 7$, Matches $= 3$, and $4$ teams advance.
\item 2nd Round: Teams $= 4$, Matches $= 2$, and $2$ teams advance.
\item 3rd Round: Teams $= 2$, Matches $= 1$, and $1$ team is declared the winner.
\end{bullets}
Total number of matches $= 3 + 2 + 1 = 6$.
\par\textbf{Example 2:}
\par Input: $n = 14$
\par Output: $13$
\par Explanation: Details of the tournament:
\begin{bullets}
\item 1st Round: Teams $= 14$, Matches $= 7$, and $7$ teams advance.
\item 2nd Round: Teams $= 7$, Matches $= 3$, and $4$ teams advance.
\item 3rd Round: Teams $= 4$, Matches $= 2$, and $2$ teams advance.
\item 4th Round: Teams $= 2$, Matches $= 1$, and $1$ team is declared the winner.
\end{bullets}
Total number of matches $= 7 + 3 + 2 + 1 = 13$.
\par\textbf{Constraints:} $1 \le n \le 200$.}
\BREAKDOWN{Track per-round matches until a single team remains. Observe that each match eliminates exactly one team, suggesting a telescoping count.}
\ELI{Every match knocks out exactly one team; to go from $n$ teams to $1$, you need $n - 1$ knockouts.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $n$ with $1 \le n \le 200$.}
\OUTPUTS{Single integer: total number of matches played until one winner remains.}
\SAMPLES{
\begin{bullets}
\item Input: $n=7$; Output: $6$.
\item Input: $n=1$; Output: $0$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n_0=n$. For round $t \ge 0$, define
\begin{BreakableEquation*}
m_t = \left\lfloor \frac{n_t}{2} \right\rfloor,\quad n_{t+1} = \left\lceil \frac{n_t}{2} \right\rceil.
\end{BreakableEquation*}
Stop when $n_T = 1$. The objective is $M = \sum_{t=0}^{T-1} m_t$.}
\varmapStart
\var{n}{initial number of teams}
\var{n_t}{teams at start of round $t$}
\var{m_t}{matches played in round $t$}
\var{M}{total number of matches until a winner}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
m_t \;=\; n_t - n_{t+1}\quad\text{for all }t,\qquad M \;=\; \sum_{t=0}^{T-1} (n_t - n_{t+1}) \;=\; n_0 - n_T \;=\; n - 1.
\end{BreakableEquation*}
}
\ASSUMPTIONS{A match always eliminates exactly one team; byes advance exactly one team without adding matches. The process terminates with exactly one team.}
\INVARIANTS{
\begin{bullets}
\item Conservation: $n_{t+1} + m_t = n_t$. Each match reduces team count by $1$.
\item Monotonicity: $(n_t)$ is strictly decreasing until $1$; termination occurs in $O(\log n)$ rounds.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the tournament round by round using the given rules and sum matches.}
\ASSUMPTIONS{Straightforward arithmetic; loop while $n>1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize matches $M \leftarrow 0$.
\item While $n>1$: add $\lfloor n/2 \rfloor$ to $M$; update $n \leftarrow \lceil n/2 \rceil$.
\item Return $M$.
\end{algosteps}
\COMPLEXITY{Let $R$ be the number of rounds; $R \le \lceil \log_2 n \rceil$. Time $O(R)=O(\log n)$, space $O(1)$.}
\[
\begin{aligned}
T(n) &= \sum_{t=0}^{R-1} O(1) \\
     &= O(R) = O(\log n).
\end{aligned}
\]
\CORRECTNESS{Matches per round follow the statement; updating $n$ with $\lceil n/2 \rceil$ maintains the tournament size. Sum equals total matches.}
\EDGECASES{$n=1$ returns $0$; even and odd transitions both covered.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def numberOfMatches(self, n: int) -> int:
        matches = 0
        while n > 1:
            matches += n // 2
            n = (n + 1) // 2
            # Equivalent to:
            # if n % 2 == 0: n //= 2 else: n = (n - 1) // 2 + 1
        return matches

# Basic asserts
s = Solution()
assert s.numberOfMatches(7) == 6
assert s.numberOfMatches(14) == 13
assert s.numberOfMatches(1) == 0
\end{minted}
\VALIDATION{Checked odd, even, and minimal input.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use the invariant that each match eliminates exactly one team; accumulate eliminations per round in $O(\log n)$ with minimal branching.}
\ASSUMPTIONS{Same loop, but use $n \gets (n+1)//2$ and $M \gets M + n//2$ directly.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $M \leftarrow 0$.
\item While $n>1$: $M \leftarrow M + \lfloor n/2 \rfloor$; $n \leftarrow \lceil n/2 \rceil$.
\item Return $M$.
\end{algosteps}
\COMPLEXITY{Same as baseline: $O(\log n)$ time, $O(1)$ space, but simpler branchless loop.}
\[
\begin{aligned}
T(n) &= O(\log n).
\end{aligned}
\]
\CORRECTNESS{Directly mirrors rules; invariant $n_{t+1} + m_t = n_t$ holds each step, so total matches is the sum of $m_t$.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def numberOfMatches(self, n: int) -> int:
        ans = 0
        while n > 1:
            ans += n // 2
            n = (n + 1) // 2
        return ans

# Checks on edge inputs
s = Solution()
assert s.numberOfMatches(2) == 1
assert s.numberOfMatches(3) == 2
assert s.numberOfMatches(200) == 199
\end{minted}
\VALIDATION{Validated small even, small odd, and the upper bound.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Return $n - 1$ using the invariant that each match eliminates exactly one team and the tournament ends with one team.}
\ASSUMPTIONS{Valid for all $n \ge 1$ under the given rules.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n=1$, return $0$.
\item Otherwise, return $n-1$.
\item No loops or recursion needed.
\end{algosteps}
\OPTIMALITY{Any tournament that reduces from $n$ to $1$ by eliminating one team per match must have exactly $n-1$ eliminations. This is a tight lower bound and achieved here.}
\COMPLEXITY{Time $O(1)$, space $O(1)$.}
\[
\begin{aligned}
T(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def numberOfMatches(self, n: int) -> int:
        # Each match removes exactly one team; from n teams to 1 needs n-1 eliminations.
        return 0 if n <= 1 else n - 1

# Exactly 3 asserts
s = Solution()
assert s.numberOfMatches(7) == 6
assert s.numberOfMatches(14) == 13
assert s.numberOfMatches(1) == 0
\end{minted}
\VALIDATION{Covers odd case, even case, and minimal case.}
\RESULT{Return the total number of matches, which is exactly $n-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for representative odd/even values and boundary $n=1$ and $n=200$. Property check: result equals $n-1$.}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A, B, and C on random $n$ in $[1,200]$; they must match.}
\LINE{EDGE-CASE GENERATOR}{Generate $n \in \{1,2,3,4,5,199,200\}$ to cover minimal, small odd/even, and upper bound.}
\begin{minted}{python}
import random

def brute(n: int) -> int:
    m = 0
    while n > 1:
        m += n // 2
        n = (n + 1) // 2
    return m

def formula(n: int) -> int:
    return 0 if n <= 1 else n - 1

# Cross-check on a deterministic sample
for n in [1,2,3,4,5,7,14,199,200]:
    assert brute(n) == formula(n)

# Extra randomized sanity (deterministic seed)
random.seed(0)
for _ in range(50):
    n = random.randint(1, 200)
    assert brute(n) == formula(n)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def numberOfMatches(self, n: int) -> int:
        # From n teams to 1 winner, each match eliminates exactly one team.
        # Therefore, exactly n - 1 matches are played.
        return 0 if n <= 1 else n - 1

# Reference asserts
s = Solution()
assert s.numberOfMatches(7) == 6
assert s.numberOfMatches(14) == 13
assert s.numberOfMatches(200) == 199
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Total matches in this tournament are always $n-1$.}
\WHY{Common interview pattern: identify an invariant and telescope instead of simulating.}
\CHECKLIST{
\begin{bullets}
\item What changes per match? Exactly one team is eliminated.
\item Where does the process end? At one team.
\item Telescoping sum: initial minus final count.
\item Validate edge case $n=1$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1 \Rightarrow 0$ matches.
\item $n=2 \Rightarrow 1$ match.
\item Small odd ($n=3$) and small even ($n=4$).
\item Upper bound $n=200$.
\item Prime $n$ values behave the same.
\item Large powers of two: still $n-1$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Over-simulating when $O(1)$ solution suffices.
\item Off-by-one when updating $n$ with ceil vs. floor.
\item Miscounting a bye as a match.
\item Returning number of rounds instead of matches.
\item Using integer division incorrectly for odd $n$.
\item Forgetting $n=1$ should return $0$.
\end{bullets}
}
\FAILMODES{Approaches that count rounds or pairings without the invariant can err for odd $n$ due to byes. The invariant-based solution is robust.}
\ELI{Every match knocks out exactly one team. To go from $n$ teams to a single winner, we must eliminate $n-1$ teams, so there are $n-1$ matches.}
\NotePages{3}

\end{document}