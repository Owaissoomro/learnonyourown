% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Balanced K-Factor Decomposition}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/balanced-k-factor-decomposition/}}
\LINE{DIFFICULTY / RATING}{Medium}
\STATEMENT{Given two integers \texttt{n} and \texttt{k}, split the number \texttt{n} into exactly \texttt{k} positive integers such that the \textbf{product} of these integers is equal to \texttt{n}. Return any one split in which the \textbf{maximum} difference between any two numbers is minimized. You may return the result in any order.

Example 1: Input: \texttt{n = 100, k = 2}. Output: \texttt{[10, 10]}. Explanation: The split \texttt{[10, 10]} yields \texttt{10 * 10 = 100} and a max-min difference of 0, which is minimal.

Example 2: Input: \texttt{n = 44, k = 3}. Output: \texttt{[2, 2, 11]}. Explanation:
\begin{itemize}
\item Split \texttt{[1, 1, 44]} yields a difference of 43
\item Split \texttt{[1, 2, 22]} yields a difference of 21
\item Split \texttt{[1, 4, 11]} yields a difference of 10
\item Split \texttt{[2, 2, 11]} yields a difference of 9
\end{itemize}
Therefore, \texttt{[2, 2, 11]} is the optimal split with the smallest difference 9.

Constraints:
\begin{itemize}
\item \texttt{4 <= n <= 10^{5}}
\item \texttt{2 <= k <= 5}
\item \texttt{k} is strictly less than the total number of positive divisors of \texttt{n}.
\end{itemize}}
\BREAKDOWN{We must produce exactly \texttt{k} positive integers whose product is \texttt{n} while minimizing the range, i.e., $\max a_i - \min a_i$. Key idea: factor \texttt{n} and distribute prime factors across \texttt{k} buckets to equalize the products.}
\ELI{Break \texttt{n} into \texttt{k} multiplicative pieces that are as equal as possible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers \texttt{n}, \texttt{k} with $4 \le n \le 10^{5}$ and $2 \le k \le 5$.}
\OUTPUTS{An array \texttt{res} of length \texttt{k} of positive integers with $\prod res_i = n$ and with minimized $\max(res) - \min(res)$. Any order is acceptable.}
\SAMPLES{
Example A:
\begin{itemize}
\item Input: \texttt{n = 100, k = 2}
\item Output: \texttt{[10, 10]}
\end{itemize}
Example B:
\begin{itemize}
\item Input: \texttt{n = 44, k = 3}
\item Output: \texttt{[2, 2, 11]}
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n \in \mathbb{Z}_{\ge 1}$ and $k \in \mathbb{Z}_{\ge 1}$, choose $a_1,\ldots,a_k \in \mathbb{Z}_{\ge 1}$ such that $\prod_{i=1}^{k} a_i = n$ minimizing the range $R(a) = \max_i a_i - \min_i a_i$.}
\varmapStart
\var{n}{target product}
\var{k}{number of factors required}
\var{a_i}{the $i$-th factor in the split}
\var{p_j^{e_j}}{prime factorization of $n$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Find } a_1,\dots,a_k \in \mathbb{Z}_{\ge 1} \\
&\text{s.t. } \prod_{i=1}^{k} a_i = n, \quad \text{and } R(a) = \max_i a_i - \min_i a_i \text{ is minimized.}
\end{aligned}
\]
}
\ASSUMPTIONS{We may include the number $1$ as a factor. Order of factors is irrelevant. The constraint $k$ is less than the number of positive divisors ensures feasibility of nontrivial splits.}
\INVARIANTS{
\begin{itemize}
\item Product invariant: multiplying any factor by $p$ and dividing another by $p$ preserves the product $n$.
\item Balancing principle: distributing each prime's exponent as evenly as possible across buckets reduces spread in log-space and thus range in value-space.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate nondecreasing $k$-tuples of positive integers whose product is $n$ using divisor recursion; pick the tuple with minimal range.}
\ASSUMPTIONS{Since $n \le 10^{5}$ and $k \le 5$, multiplicative partitions are few enough for backtracking with pruning.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute all divisors of the current remainder during recursion.
\item Recursively select the next factor $d$ dividing the remainder, constrained by nondecreasing order ($d \ge$ previous factor).
\item When depth $k-1$ is reached, set the last factor to the remaining product and evaluate the range.
\end{algosteps}
\COMPLEXITY{Let $D(x)$ be number of divisors of $x$. The worst-case branching is bounded by $D(\cdot)$ and depth $k-1$. Empirically small for $n \le 10^{5}$ and $k \le 5$.}
\[
\begin{aligned}
T(n) &\approx O\!\left(\sum_{\text{nodes}} D(\text{remainder})\right) \\
S(n) &= O(k + D(n))
\end{aligned}
\]
\CORRECTNESS{By exhaustive enumeration of all nondecreasing $k$-factor factorizations, the best range found is optimal. Nondecreasing order avoids duplicates without missing any feasible split.}
\EDGECASES{Many $1$'s; prime $n$; $k$ close to its maximum; repeated prime powers.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def balancedKFactorDecomposition(self, n: int, k: int) -> List[int]:
        # Enumerate nondecreasing k-tuples of positive integers with product n.
        # Return one with minimal max-min difference.
        def divisors(x: int) -> List[int]:
            small, large = [], []
            i = 1
            while i * i <= x:
                if x % i == 0:
                    small.append(i)
                    if i * i != x:
                        large.append(x // i)
                i += 1
            return small + large[::-1]

        best_range = None
        best_tuple: List[int] = []

        # DFS with nondecreasing sequence constraint
        def dfs(pos: int, prev: int, rem: int, cur: List[int]) -> None:
            nonlocal best_range, best_tuple
            if pos == k - 1:
                # Last factor is forced to rem; must respect nondecreasing order
                last = rem
                if last < prev:
                    return
                arr = cur + [last]
                r = max(arr) - min(arr)
                if best_range is None or r < best_range:
                    best_range = r
                    best_tuple = arr[:]
                return

            for d in divisors(rem):
                if d < prev:
                    continue
                # pruning: if d == 0 it won't happen; if d > rem, divisors() prevents
                if rem % d != 0:
                    continue
                dfs(pos + 1, d, rem // d, cur + [d])

        dfs(0, 1, n, [])
        # Fallback if no assignment found (shouldn't happen given constraints)
        if not best_tuple:
            return [1] * (k - 1) + [n]
        return best_tuple

# Baseline quick checks
sol = Solution()
assert sorted(sol.balancedKFactorDecomposition(100, 2)) == [10, 10]
ans = sol.balancedKFactorDecomposition(44, 3)
assert sorted(ans) == [2, 2, 11]
# Additional small checks
assert sorted(sol.balancedKFactorDecomposition(36, 3)) == [3, 3, 4]
\end{minted}
\VALIDATION{Checked examples; verified a small extra case \texttt{n=36, k=3} yields \texttt{[3,3,4]} which has product 36 and minimal range 1.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy Heap on Prime Factors}
\WHICHFORMULA{Factor $n = \prod p_i^{e_i}$. Start with $k$ buckets of value $1$. For each prime copy (repeat $e_i$ times), multiply the currently smallest bucket by $p_i$. This equalizes products and minimizes the range.}
\ASSUMPTIONS{Minimizing range in value-space corresponds to balancing sums in log-space; greedily boosting the smallest bucket is optimal for such load balancing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Factorize $n$ into its multiset of prime factors with multiplicity.
\item Initialize a min-heap of $k$ pairs $(\text{value}, \text{index})$ with value $1$.
\item For each prime factor $p$ (with multiplicity), pop the smallest bucket, multiply it by $p$, and push it back.
\item Return the final bucket values.
\end{algosteps}
\COMPLEXITY{Let $\omega(n)$ be the number of prime factors counting multiplicity.}
\[
\begin{aligned}
T(n) &= O(\sqrt{n} + \omega(n)\log k) \\
S(n) &= O(k)
\end{aligned}
\]
\CORRECTNESS{Each multiplication assigns growth to the currently minimal factor, minimizing both the current maximum and the eventual spread by convexity in log-space. Distributing each prime's copies this way is equivalent to evenly splitting prime exponents and interleaving across primes to keep products balanced.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import heapq
import math

class Solution:
    def balancedKFactorDecomposition(self, n: int, k: int) -> List[int]:
        # Factorize n into prime factors with multiplicity.
        def prime_factors_multiset(x: int) -> List[int]:
            facs: List[int] = []
            d = 2
            while d * d <= x:
                while x % d == 0:
                    facs.append(d)
                    x //= d
                d += 1 if d == 2 else 2  # small speedup: after 2, test odds
            if x > 1:
                facs.append(x)
            return facs

        factors = [1] * k
        heap = [(1, i) for i in range(k)]
        heapq.heapify(heap)
        for p in prime_factors_multiset(n):
            val, idx = heapq.heappop(heap)
            val *= p
            factors[idx] = val
            heapq.heappush(heap, (val, idx))
        return factors

# Improved quick checks
sol = Solution()
assert sorted(sol.balancedKFactorDecomposition(100, 2)) == [10, 10]
assert sorted(sol.balancedKFactorDecomposition(44, 3)) == [2, 2, 11]
# Another check
assert sorted(sol.balancedKFactorDecomposition(72, 4)) == [2, 3, 3, 4]
\end{minted}
\VALIDATION{Verified on samples and a composite case \texttt{n=72, k=4} giving a near-equal split \texttt{[2,3,3,4]}.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Exponent Balancing with Per-Prime Bulk Assignment}
\WHICHFORMULA{For each prime $p$ with exponent $e$, compute $q=\lfloor e/k \rfloor$ and $r=e \bmod k$. Multiply every bucket by $p^q$; then multiply the $r$ currently smallest buckets by one more factor $p$. This reduces heap operations from $e$ to $r \le k-1$ per prime.}
\ASSUMPTIONS{Equalizing exponents of each prime across buckets minimizes spread in log-space. Interleaving the extra $r$ copies to the currently smallest buckets across all primes keeps total products balanced.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Factorize $n$ into its distinct primes with exponents $e$.
\item Initialize factors $f_i \gets 1$ and a min-heap over the current values $f_i$.
\item For each $(p,e)$:
  \begin{itemize}
  \item Compute $q=\lfloor e/k \rfloor$ and $r=e \bmod k$; $mul = p^q$.
  \item Multiply every factor by $mul$ (no heap needed for this step).
  \item Rebuild/update the heap; then do $r$ times: pop-min, multiply by $p$, push back.
  \end{itemize}
\item Return the factors.
\end{algosteps}
\OPTIMALITY{This is the same greedy as Approach B but batches the uniform part $p^q$ for all buckets. It achieves the same final multiset as repeatedly multiplying the minimum by $p$ for each copy, hence inherits optimality.}
\COMPLEXITY{With $\pi(n)$ distinct primes:}
\[
\begin{aligned}
T(n) &= O(\sqrt{n} + k\,\pi(n) + \pi(n)\log k + k\log k) \\
S(n) &= O(k)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def balancedKFactorDecomposition(self, n: int, k: int) -> List[int]:
        # Factorize n into (prime, exponent)
        def factorize(n: int) -> List[Tuple[int, int]]:
            res: List[Tuple[int, int]] = []
            d = 2
            x = n
            while d * d <= x:
                if x % d == 0:
                    e = 0
                    while x % d == 0:
                        x //= d
                        e += 1
                    res.append((d, e))
                d += 1 if d == 2 else 2  # after 2, only odd candidates
            if x > 1:
                res.append((x, 1))
            return res

        if k == 0:
            return []
        # Initialize factors
        factors = [1] * k
        # Batch per prime
        for p, e in factorize(n):
            q, r = divmod(e, k)
            base = pow(p, q)
            # Multiply all by base
            for i in range(k):
                factors[i] *= base
            if r == 0:
                continue
            # Heap for distributing the extra r copies
            heap = [(factors[i], i) for i in range(k)]
            heapq.heapify(heap)
            for _ in range(r):
                val, idx = heapq.heappop(heap)
                val *= p
                factors[idx] = val
                heapq.heappush(heap, (val, idx))
        return factors

# Exactly 3 asserts
sol = Solution()
assert sorted(sol.balancedKFactorDecomposition(100, 2)) == [10, 10]
assert sorted(sol.balancedKFactorDecomposition(44, 3)) == [2, 2, 11]
assert sorted(sol.balancedKFactorDecomposition(36, 3)) == [3, 3, 4]
\end{minted}
\VALIDATION{Three asserts covering two samples and a balanced composite $36 = 2^2 \cdot 3^2$ with $k=3$.}
\RESULT{Returns any one balanced $k$-factor split of $n$ minimizing the maximum difference. No special tie-breaking is required; any order is acceptable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test product correctness, length, and range minimality by cross-checking Approach B vs. Approach A on small random cases. Include edge cases with many $1$'s and prime powers.}
\LINE{CROSS-CHECKS}{On random $(n,k)$ with $n \le 5000$, compare the range from brute force (A) with greedy (B/C). They should match; also verify products equal $n$.}
\LINE{EDGE-CASE GENERATOR}{Generate $n$ from $\{4,\ldots,2000\}$ and $k \in \{2,\ldots,5\}$; emphasize primes, prime powers, and highly composite numbers.}
\begin{minted}{python}
from typing import List, Tuple
import random
import math
import heapq

# Deterministic generators for boundaries, degenerates, adversarials

def brute_split(n: int, k: int) -> List[int]:
    def divisors(x: int) -> List[int]:
        small, large = [], []
        i = 1
        while i * i <= x:
            if x % i == 0:
                small.append(i)
                if i * i != x:
                    large.append(x // i)
            i += 1
        return small + large[::-1]

    best, best_arr = None, []
    def dfs(pos: int, prev: int, rem: int, cur: List[int]):
        nonlocal best, best_arr
        if pos == k - 1:
            last = rem
            if last < prev:
                return
            arr = cur + [last]
            rng = max(arr) - min(arr)
            if best is None or rng < best:
                best, best_arr = rng, arr[:]
            return
        for d in divisors(rem):
            if d < prev or rem % d != 0:
                continue
            dfs(pos + 1, d, rem // d, cur + [d])
    dfs(0, 1, n, [])
    return best_arr if best_arr else [1] * (k - 1) + [n]

def greedy_heap(n: int, k: int) -> List[int]:
    def prime_multiset(x: int) -> List[int]:
        facs = []
        d = 2
        while d * d <= x:
            while x % d == 0:
                facs.append(d)
                x //= d
            d += 1 if d == 2 else 2
        if x > 1:
            facs.append(x)
        return facs
    factors = [1] * k
    heap = [(1, i) for i in range(k)]
    heapq.heapify(heap)
    for p in prime_multiset(n):
        v, idx = heapq.heappop(heap)
        v *= p
        factors[idx] = v
        heapq.heappush(heap, (v, idx))
    return factors

def range_of(arr: List[int]) -> int:
    return max(arr) - min(arr)

random.seed(7)
for n in list(range(4, 201)) + [360, 420, 840, 1024, 99991]:
    for k in range(2, 6):
        a = brute_split(n, k)
        b = greedy_heap(n, k)
        assert math.prod(a) == n and len(a) == k
        assert math.prod(b) == n and len(b) == k
        assert range_of(b) == range_of(a)
# Spot-print a few cases (deterministic)
cases = [(44,3), (100,2), (72,4), (96,5)]
for n, k in cases:
    print(n, k, sorted(greedy_heap(n, k)))
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def balancedKFactorDecomposition(self, n: int, k: int) -> List[int]:
        # Final: per-prime exponent balancing with minimal heap touches.
        def factorize(n: int) -> List[Tuple[int, int]]:
            res: List[Tuple[int, int]] = []
            d = 2
            x = n
            while d * d <= x:
                if x % d == 0:
                    e = 0
                    while x % d == 0:
                        x //= d
                        e += 1
                    res.append((d, e))
                d += 1 if d == 2 else 2
            if x > 1:
                res.append((x, 1))
            return res

        factors = [1] * k
        for p, e in factorize(n):
            q, r = divmod(e, k)
            base = pow(p, q)
            for i in range(k):
                factors[i] *= base
            if r:
                heap = [(factors[i], i) for i in range(k)]
                heapq.heapify(heap)
                for _ in range(r):
                    v, idx = heapq.heappop(heap)
                    v *= p
                    factors[idx] = v
                    heapq.heappush(heap, (v, idx))
        return factors

# Sanity asserts
sol = Solution()
assert sorted(sol.balancedKFactorDecomposition(44, 3)) == [2, 2, 11]
assert sorted(sol.balancedKFactorDecomposition(100, 2)) == [10, 10]
assert sorted(sol.balancedKFactorDecomposition(36, 3)) == [3, 3, 4]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Distribute the prime factors of $n$ across $k$ buckets to keep their products as equal as possible.}
\WHY{Common in interviews to test factorization, greedy balancing, and reasoning in multiplicative vs. additive domains (via logs).}
\CHECKLIST{
\begin{itemize}
\item Factorize $n$ correctly.
\item Initialize $k$ buckets with $1$.
\item Distribute exponents evenly; give leftovers to current smallest buckets.
\item Return any order; ensure length $k$ and product $n$.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item $n$ prime, $k>2$: output has many $1$'s and one $n$.
\item Large prime power $p^e$ with $k \le e$: near-equal powers per bucket.
\item Highly composite $n$ like $360, 840$: many balancing opportunities.
\item $k=5$ at upper bound: ensure performance and heap logic are correct.
\item $n$ just over a square, e.g., $n=10^{5}$; factorization still fast.
\item When $r=0$ for some prime: skip heap step cleanly.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Forgetting to allow factor $1$ leads to infeasible recursion.
\item Using integer division mistakes in exponent splitting ($q,r$).
\item Not rebuilding/updating heap after bulk multiply step.
\item Overflow not a concern in Python, but be cautious in other languages.
\item Incorrect prime factorization loop increments.
\item Returning unsorted results and comparing to sorted expectations in tests.
\end{itemize}
}
\FAILMODES{Naive random assignment of prime factors can yield large spreads. Even splitting per-prime without interleaving across primes can imbalance products; always add extras to the current smallest buckets.}
\ELI{Turn $n$ into its prime Lego bricks. Build $k$ towers by always snapping the next brick onto the shortest tower. This keeps all towers nearly the same height, so the tallest and shortest differ as little as possible.}
\NotePages{3}

\end{document}