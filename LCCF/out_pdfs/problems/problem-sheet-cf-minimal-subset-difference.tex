% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimal Subset Difference}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/924/F}}
\LINE{DIFFICULTY / RATING}{CF: 924/F \quad Rating: 3200}
\STATEMENT{We call a positive integer $x$ a $k$-beautiful integer if and only if it is possible to split the multiset of its digits in the decimal representation into two subsets such that the difference between the sum of digits in one subset and the sum of digits in the other subset is less than or equal to $k$. Each digit should belong to exactly one subset after the split.

There are $n$ queries for you. Each query is described with three integers $l$, $r$ and $k$, which mean that you are asked how many integers $x$ between $l$ and $r$ (inclusive) are $k$-beautiful.

Input:
The first line contains a single integer $n$ ($1 \le n \le 5\cdot 10^4$), indicating the number of queries.

Each of the next $n$ lines describes a query, containing three integers $l$, $r$ and $k$ ($1 \le l \le r \le 10^{18}$, $0 \le k \le 9$).

Output:
For each query print a single number — the answer to the query.

Note:
If $1 \le x \le 9$, integer $x$ is $k$-beautiful if and only if $x \le k$.

If $10 \le x \le 99$, integer $x = 10a + b$ is $k$-beautiful if and only if $\lvert a - b \rvert \le k$, where $a$ and $b$ are integers between $0$ and $9$, inclusive.

$100$ is $k$-beautiful if and only if $k \ge 1$.}
\BREAKDOWN{Reduce the partition of digits into two subsets to the standard partition problem on small weights $\{0,1,\ldots,9\}$. For a number $x$ with digit multiset, the minimal achievable difference equals the minimum of $\lvert S-2s\rvert$ over subset-sums $s$ from the multiset, where $S$ is the sum of digits. Then count the numbers in $[l,r]$ with minimal difference $\le k$ using digit DP.}
\ELI{We try to split the digits into two piles with sums as close as possible; we only need to know if we can get within $k$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $n$; then $n$ lines, each with integers $l$, $r$, $k$ where $1 \le l \le r \le 10^{18}$ and $0 \le k \le 9$.}
\OUTPUTS{For each query, output the count of integers $x \in [l,r]$ that are $k$-beautiful, one per line.}
\SAMPLES{Example 1 (tiny):
\[
\begin{aligned}
n&=3\\
(1,9,k{=}0)&\to 0\\
(1,9,k{=}5)&\to 5\\
(10,99,k{=}1)&\to \#\{(a,b)\in[0,9]^2\setminus\{(0,0)\}:\lvert a-b\rvert\le 1\}
\end{aligned}
\]
Example 2:
\begin{BreakableEquation*}
(100,100,k{=}0)\to 0,\quad (100,100,k{=}1)\to 1.
\end{BreakableEquation*}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a digit multiset $D=\{d_1,\ldots,d_m\}$ with each $d_i\in\{0,1,\ldots,9\}$ and total sum $S=\sum d_i$, we consider partitions $A\subseteq\{1,\ldots,m\}$ with sum $s=\sum_{i\in A} d_i$. The partition difference is $\Delta=|S-2s|$. The minimal difference for $x$ is $\Delta^\star(x)=\min_{A}\lvert S-2s\rvert$. Call $x$ $k$-beautiful if $\Delta^\star(x)\le k$.}
\varmapStart
\var{S}{sum of digits of $x$}
\var{m}{number of digits of $x$}
\var{D}{multiset of digits of $x$}
\var{\Delta^\star}{minimal achievable partition difference for $D$}
\var{k}{tolerance threshold}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\Delta^\star(x) \;=\; \min_{s \in \mathcal{S}(D)} \bigl|S-2s\bigr|,\quad \mathcal{S}(D):=\left\{\sum_{i\in A} d_i: A\subseteq\{1,\ldots,m\}\right\}.
\end{BreakableEquation*}
Equivalently, letting $E_0=\{0\}$ and $E_{t+1}=\bigl\{|e\pm d_{t+1}|:e\in E_t\bigr\}$, we have $\Delta^\star(x)=\min E_m$.
}
\ASSUMPTIONS{Decimal representation has no leading zeros; zeros as digits do not affect achievable differences but count as elements assignable to either subset.}
\INVARIANTS{At step $t$, $E_t\subseteq\{0,1,\ldots,\sum_{i\le t} d_i\}$; transitions preserve integrality and parity mod $1$ trivially.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute $\Delta^\star(x)$ by evolving the set of achievable absolute differences $E$ via $E\leftarrow\{|e\pm d|\}$ for each digit $d$ of $x$, then test $\min E\le k$.}
\ASSUMPTIONS{Only feasible for tiny ranges; per $x$ time is $O(m\cdot S)$ with $m\le 19$, $S\le 171$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $x\in[l,r]$, extract its digits into list $D$.
\item Initialize $E=\{0\}$; for each $d\in D$, update $E=\{|e+d|,|e-d|:e\in E\}$.
\item If $\min E\le k$, increment the answer.
\end{algosteps}
\COMPLEXITY{For a single $x$: $T(x)=O(m\cdot |E|)$ with $|E|\le S+1\le 172$, so $T(x)=O(mS)\le O(19\cdot 171)$. Over the interval, $T([l,r])=O((r-l+1) \cdot mS)$; space $O(S)$.}
\[
\begin{aligned}
T([l,r]) &\le (r-l+1)\cdot 19\cdot 171,\\
S([l,r]) &\in O(171).
\end{aligned}
\]
\CORRECTNESS{The recurrence $E\leftarrow\{|e\pm d|\}$ exactly enumerates all possible absolute differences after assigning the new digit $d$ to either subset. Starting from $E=\{0\}$, after all digits, $\min E$ is the minimal achievable difference.}
\EDGECASES{Single-digit numbers; zeros among digits; $k=0$; endpoints $l=r$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline brute-force enumerator (tiny ranges).
from typing import List, Tuple

def digits_of(x: int) -> List[int]:
    return list(map(int, str(x)))

def min_partition_diff_from_digits(digs: List[int]) -> int:
    E = {0}
    for d in digs:
        nxt = set()
        for e in E:
            a = e + d
            b = abs(e - d)
            nxt.add(a)
            nxt.add(b)
        E = nxt
    return min(E)

def is_k_beautiful(x: int, k: int) -> bool:
    return min_partition_diff_from_digits(digits_of(x)) <= k

def read_input() -> List[Tuple[int, int, int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    qs = []
    for _ in range(n):
        l = int(next(it)); r = int(next(it)); k = int(next(it))
        qs.append((l, r, k))
    return qs

def solve_case(l: int, r: int, k: int) -> int:
    ans = 0
    for x in range(l, r + 1):
        if is_k_beautiful(x, k):
            ans += 1
    return ans

def solve_all():
    qs = read_input()
    out_lines = []
    for (l, r, k) in qs:
        out_lines.append(str(solve_case(l, r, k)))
    print("\n".join(out_lines))

if __name__ == "__main__":
    # Tiny sanity asserts (baseline)
    assert is_k_beautiful(1, 0) is False
    assert is_k_beautiful(5, 5) is True
    # For 2-digit x=10a+b, min diff equals |a-b|
    for a in range(10):
        for b in range(10):
            if a == 0 and b == 0:
                continue
            x = 10*a + b
            md = min_partition_diff_from_digits([a, b])
            assert md == abs(a - b)
    # Do not run solve_all() in baseline by default
    pass
\end{minted}
\VALIDATION{Checked single-digit behavior, and verified the 2-digit characterization exhaustively.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Caching Over Digit Multisets}
\WHICHFORMULA{Memoize $\Delta^\star$ by the sorted tuple of digits of $x$; adjacent numbers often share many digits in small ranges.}
\ASSUMPTIONS{Effective when the union of queried ranges is small or has repeated digit patterns.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a dictionary cache from a digit multiset key (sorted tuple of digits) to $\Delta^\star$.
\item For each $x$, form the key; if cached, reuse; else compute via the $E$-set update and store.
\item Count those with $\Delta^\star\le k$.
\end{algosteps}
\COMPLEXITY{Worst-case still linear in range size, but the constant improves when many repeats occur. Memory stores up to the number of distinct digit multisets encountered.}
\[
\begin{aligned}
T([l,r]) &\le (r-l+1)\cdot C_{\text{hit/miss}},\quad C_{\text{hit}}\ll C_{\text{miss}},\\
\end{aligned}
\]
\CORRECTNESS{Caching does not change results; it only avoids recomputation for identical digit multisets.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved: cache by digit multiset key
from typing import Dict, Tuple

def min_partition_diff_cached_key(key: Tuple[int, ...], memo: Dict[Tuple[int, ...], int]) -> int:
    if key in memo:
        return memo[key]
    E = {0}
    for d in key:
        nxt = set()
        for e in E:
            a = e + d
            b = abs(e - d)
            nxt.add(a)
            nxt.add(b)
        E = nxt
    md = min(E)
    memo[key] = md
    return md

def solve_case_cached(l: int, r: int, k: int) -> int:
    memo: Dict[Tuple[int, ...], int] = {}
    ans = 0
    for x in range(l, r + 1):
        digs = tuple(sorted(map(int, str(x))))
        md = min_partition_diff_cached_key(digs, memo)
        if md <= k:
            ans += 1
    return ans

if __name__ == "__main__":
    # Tiny asserts for improved version on small ranges
    assert solve_case_cached(1, 9, 0) == 0
    assert solve_case_cached(1, 9, 3) == 3
    assert solve_case_cached(100, 100, 1) == 1
\end{minted}
\VALIDATION{Validated tiny ranges: single digits with $k=0,3$; the special case $100$ with $k=1$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Digit DP on Difference-Set Bitmasks}
\WHICHFORMULA{Count $k$-beautiful numbers $\le N$ via digit DP. State tracks position, tight/start flags, and a bitmask of achievable absolute differences $E$ (bounded by $W=9\cdot \text{max\_digits}$). Transition for digit $d$ updates the bitmask by mapping each set bit $i$ to positions $i{+}d$ and $\lvert i{-}d\rvert$. At the end, accept if the least set bit is $\le k$. Answer for $[l,r]$ is $\text{cnt}(\le r)-\text{cnt}(\le l-1)$.}
\ASSUMPTIONS{Works for any $N$; state-space is exponential in worst-case but practical for small/moderate $N$. For very large $N$ this is a conceptual reference and may require further pruning/optimizations in a contest-grade implementation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute maximum width $W=9\cdot \text{len}(N)$. Represent $E$ as an integer bitmask over $[0..W]$, with bit $j$ set iff difference $j$ is achievable.
\item Initialize mask $M=1\ll 0$.
\item Recurse over digits with memoization on $(\text{pos},\text{tight},\text{started},M)$; for each next digit $d$, if still not started and $d=0$, keep $M$; else update $M$ by the absolute-difference transition.
\item At leaf (pos==len), accept if started and $\operatorname{tz}(M)\le k$ where $\operatorname{tz}$ gives the index of the least significant set bit.
\end{algosteps}
\OPTIMALITY{Among exact methods, digit DP achieves optimal asymptotic in the numeric length (not the value) by avoiding per-number iteration. The bitmask captures all necessary combinatorial states for the partition difference.}
\COMPLEXITY{Let $L$ be the digit length and $W=9L$. Per transition, updating the mask costs $O(\#\text{bits set})\le O(W)$. The number of DP states depends on how many distinct masks arise; in worst case it is large, but memoization significantly reduces recomputation.}
\[
\begin{aligned}
T(N) &\approx O\bigl(\#\text{states}\cdot 10 \cdot W\bigr),\quad W\le 171,\\
S(N) &\approx O(\#\text{states}).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF-style solution: digit DP on difference bitmasks (conceptual; optimized for small/moderate N).
from functools import lru_cache
from typing import List, Tuple

def update_mask_absdiff(mask: int, d: int, W: int) -> int:
    """Given a bitset mask over [0..W], return new mask for E' = {|e ± d|, e ∈ E}."""
    if d == 0:
        return mask  # adding zero changes nothing
    m = mask
    res = 0
    # iterate set bits
    while m:
        lsb = m & -m
        i = (lsb.bit_length() - 1)
        m -= lsb
        a = i + d
        if a <= W:
            res |= (1 << a)
        b = abs(i - d)
        res |= (1 << b)
    return res

def least_set_bit_index(mask: int) -> int:
    # Assumes mask != 0
    lsb = mask & -mask
    return lsb.bit_length() - 1

def count_k_beautiful_upto(N: int, k: int) -> int:
    if N <= 0:
        return 0
    digs = list(map(int, str(N)))
    L = len(digs)
    W = 9 * L  # safe bound for differences
    @lru_cache(maxsize=None)
    def dfs(pos: int, tight: int, started: int, mask: int) -> int:
        if pos == L:
            if started == 0:
                return 0  # exclude zero
            return 1 if least_set_bit_index(mask) <= k else 0
        limit = digs[pos] if tight else 9
        total = 0
        for d in range(0, limit + 1):
            ntight = tight and (d == limit)
            if started == 0 and d == 0:
                total += dfs(pos + 1, ntight, 0, mask)
            else:
                nmask = update_mask_absdiff(mask, d, W)
                total += dfs(pos + 1, ntight, 1, nmask)
        return total
    init_mask = 1 << 0
    return dfs(0, 1, 0, init_mask)

def solve_case(l: int, r: int, k: int) -> int:
    return count_k_beautiful_upto(r, k) - count_k_beautiful_upto(l - 1, k)

def read_input() -> List[Tuple[int, int, int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    qs = []
    for _ in range(n):
        l = int(next(it)); r = int(next(it)); k = int(next(it))
        qs.append((l, r, k))
    return qs

def solve_all():
    qs = read_input()
    out_lines = []
    for (l, r, k) in qs:
        out_lines.append(str(solve_case(l, r, k)))
    print("\n".join(out_lines))

if __name__ == "__main__":
    # Exactly 3 asserts (mini-tests)
    # 1) Single-digit characterization
    assert count_k_beautiful_upto(9, 0) == 0 and count_k_beautiful_upto(9, 5) == 5
    # 2) Special case: 100 is k-beautiful iff k >= 1
    a100 = solve_case(100, 100, 0); b100 = solve_case(100, 100, 1)
    assert a100 == 0 and b100 == 1
    # 3) Cross-check brute for two-digit numbers with k=1 on a tiny window
    def brute(l: int, r: int, k: int) -> int:
        def md(digs: List[int]) -> int:
            E = {0}
            for d in digs:
                nxt = set()
                for e in E:
                    nxt.add(e + d); nxt.add(abs(e - d))
                E = nxt
            return min(E)
        ans = 0
        for x in range(l, r + 1):
            d = list(map(int, str(x)))
            if x >= 10 and x <= 99:
                if md(d) <= k:
                    ans += 1
        return ans
    assert solve_case(10, 99, 1) == brute(10, 99, 1)
    # To run on input, uncomment the next line
    # solve_all()
\end{minted}
\VALIDATION{Three asserts: single-digit counts; the $100$ special case; and a two-digit window cross-check against brute force.}
\RESULT{For each query $(l,r,k)$, output $\#\{x\in[l,r]: \Delta^\star(x)\le k\}$. No tie-breaking is needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: single-digit characterization; special hand-crafted numbers (like $100$); cross-checks for two-digit ranges; random tiny intervals against brute force.}
\LINE{CROSS-CHECKS}{Compare digit-DP counts vs. brute force on small intervals (e.g., up to $10^4$).}
\LINE{EDGE-CASE GENERATOR}{Generate ranges with extremes: $l=r$, $k=0$, $k=9$, numbers with all same digits, numbers with alternating digits, and those containing many zeros.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import Iterator, Tuple
def gen_ranges() -> Iterator[Tuple[int,int,int]]:
    # Singletons with various k
    for k in (0,1,5,9):
        for x in (1,5,9,10,11,19,99,100,101,999,1000):
            yield (x, x, k)
    # Small intervals
    for k in (0,1,2,3):
        yield (1, 50, k)
        yield (10, 99, k)
    # Patterns: same digits and many zeros
    for k in (0,1,9):
        for t in (1,2,3,4):
            x = int("9"*t)
            yield (x, x, k)
            y = int("10"*t)  # e.g., 1010...
            yield (y, y, k)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference: digit DP as above (same API), with input/output handling.
from functools import lru_cache
from typing import List, Tuple

def update_mask_absdiff(mask: int, d: int, W: int) -> int:
    if d == 0:
        return mask
    m = mask
    res = 0
    while m:
        lsb = m & -m
        i = (lsb.bit_length() - 1)
        m -= lsb
        a = i + d
        if a <= W:
            res |= (1 << a)
        b = abs(i - d)
        res |= (1 << b)
    return res

def least_set_bit_index(mask: int) -> int:
    lsb = mask & -mask
    return lsb.bit_length() - 1

def count_k_beautiful_upto(N: int, k: int) -> int:
    if N <= 0:
        return 0
    digs = list(map(int, str(N)))
    L = len(digs)
    W = 9 * L
    @lru_cache(maxsize=None)
    def dfs(pos: int, tight: int, started: int, mask: int) -> int:
        if pos == L:
            if started == 0:
                return 0
            return 1 if least_set_bit_index(mask) <= k else 0
        limit = digs[pos] if tight else 9
        total = 0
        for d in range(0, limit + 1):
            ntight = tight and (d == limit)
            if started == 0 and d == 0:
                total += dfs(pos + 1, ntight, 0, mask)
            else:
                nmask = update_mask_absdiff(mask, d, W)
                total += dfs(pos + 1, ntight, 1, nmask)
        return total
    init_mask = 1 << 0
    return dfs(0, 1, 0, init_mask)

def solve_case(l: int, r: int, k: int) -> int:
    return count_k_beautiful_upto(r, k) - count_k_beautiful_upto(l - 1, k)

def read_input() -> List[Tuple[int, int, int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    qs = []
    for _ in range(n):
        l = int(next(it)); r = int(next(it)); k = int(next(it))
        qs.append((l, r, k))
    return qs

def solve_all():
    qs = read_input()
    out_lines = []
    for (l, r, k) in qs:
        out_lines.append(str(solve_case(l, r, k)))
    print("\n".join(out_lines))

if __name__ == "__main__":
    # Light sanity asserts
    assert count_k_beautiful_upto(9, 0) == 0
    assert solve_case(100, 100, 1) == 1
    assert solve_case(10, 99, 1) == (count_k_beautiful_upto(99, 1) - count_k_beautiful_upto(9, 1))
    # Uncomment to run the solver:
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count numbers whose digit multiset can be partitioned into two piles with sum difference at most $k$.}
\WHY{This mixes subset-sum style combinatorics with digit DP, a classic pattern in advanced counting problems.}
\CHECKLIST{
\begin{bullets}
\item Model minimal difference via subset-sum or difference evolution.
\item Design DP state to capture necessary info; here, a difference bitmask.
\item Implement digit DP for $\le N$ and use inclusion-exclusion for $[l,r]$.
\item Validate on small cases and special notes.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $k=0$ forces exact balance; parity and digit availability matter.
\item Single-digit numbers: only $x\le k$ qualify.
\item Two-digit numbers: condition reduces to $\lvert a-b\rvert \le k$.
\item Numbers with all same digits (e.g., $99\ldots 9$): differences are multiples of that digit.
\item Presence of many zeros: they do not change differences but increase digit count.
\item Very long numbers (up to $10^{18}$): ensure $W=9L$ bounds transitions.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Mishandling leading zeros in digit DP (must not count $x=0$).
\item Forgetting to cap difference bitmask width to $W=9L$.
\item Incorrect absolute-difference transition for the bitmask.
\item Assuming monotonicity when $\min E \le k$ mid-DP (it is not monotone).
\item Off-by-one in inclusion-exclusion: use $\text{cnt}(\le r)-\text{cnt}(\le l-1)$.
\item Conflating digit $0$ transitions with ``not started'' state.
\end{bullets}
}
\FAILMODES{Brute force over $[l,r]$ is infeasible for large ranges. A DP that only tracks the current minimal difference (a scalar) is insufficient; different paths with larger interim differences can later yield a smaller final difference. The bitmask-based DP survives these by retaining all reachable differences.}
\ELI{We track what differences are possible as we place digits, then ask if we can get within $k$ by the end. Counting all such numbers up to $N$ and subtracting gives the answer for any interval.}
\NotePages{3}

\end{document}