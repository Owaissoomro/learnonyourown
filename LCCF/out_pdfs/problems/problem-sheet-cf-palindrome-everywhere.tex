% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Palindrome Everywhere}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2029/F}}
\LINE{DIFFICULTY / RATING}{2500}
\STATEMENT{You are given a cycle with $n$ vertices numbered from $0$ to $n-1$. For each $0\le i\le n-1$, there is an undirected edge between vertex $i$ and vertex $((i+1)\bmod n)$ with the color $c_i$ ($c_i=\texttt{R}$ or $\texttt{B}$).

Determine whether the following condition holds for every pair of vertices $(i,j)$ ($0\le i<j\le n-1$):

- There exists a palindrome route between vertex $i$ and vertex $j$. Note that the route may not be simple. Formally, there must exist a sequence $p=[p_0,p_1,p_2,\ldots,p_m]$ such that: $p_0=i$, $p_m=j$; For each $0\leq x\le m-1$, either $p_{x+1}=(p_x+1)\bmod n$ or $p_{x+1}=(p_x-1)\bmod n$; For each $0\le x\le y\le m-1$ satisfying $x+y=m-1$, the edge between $p_x$ and $p_{x+1}$ has the same color as the edge between $p_y$ and $p_{y+1}$.

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^5$) — the number of test cases. The description of the test cases follows.

The first line of each test case contains an integer $n$ ($3\leq n\leq10^6$) — the number of vertices in the cycle.

The second line contains a string $c$ of length $n$ ($c_i=\texttt{R}$ or $\texttt{B}$) — the color of each edge.

It is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.

Output:
For each test case, print ``YES'' (without quotes) if there is a palindrome route between any pair of nodes, and ``NO'' (without quotes) otherwise.

You can output the answer in any case (upper or lower). For example, the strings ``yEs'', ``yes'', ``Yes'', and ``YES'' will be recognized as positive responses.

Note:
In the first test case, it is easy to show that there is a palindrome route between any two vertices.

In the second test case, for any two vertices, there exists a palindrome route with only red edges.

In the third test case, the cycle is as follows: $0\color{red}{\overset{\texttt{R}}{\longleftrightarrow}}1\color{blue}{\overset{\texttt{B}}{\longleftrightarrow}}2\color{blue}{\overset{\texttt{B}}{\longleftrightarrow}}3\color{red}{\overset{\texttt{R}}{\longleftrightarrow}}4\color{blue}{\overset{\texttt{B}}{\longleftrightarrow}}0$. Take $(i,j)=(0,3)$ as an example, then $0\color{red}{\overset{\texttt{R}}{\longrightarrow}}1\color{blue}{\overset{\texttt{B}}{\longrightarrow}}2\color{blue}{\overset{\texttt{B}}{\longrightarrow}}3\color{red}{\overset{\texttt{R}}{\longrightarrow}}4\color{blue}{\overset{\texttt{B}}{\longrightarrow}}0\color{blue}{\overset{\texttt{B}}{\longrightarrow}}4\color{red}{\overset{\texttt{R}}{\longrightarrow}}3$ is a palindrome route. Thus, the condition holds for $(i,j)=(0,3)$.

In the fourth test case, when $(i,j)=(0,2)$, there does not exist a palindrome route.}
\BREAKDOWN{Recognize when every pair of vertices admits a palindromic color sequence along some walk on the cycle. Reduce the condition to a simple structural property of the edge-color string on the cycle. Design an $O(n)$ checker per test case.}
\ELI{The answer is YES unless the cycle colors alternate strictly R, B, R, B, \ldots\ around the whole cycle; in that perfectly alternating case, some pairs cannot be connected by a palindromic-colored walk.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: an integer $n$ with $3\le n\le 10^6$, and a string $c$ of length $n$ over $\{\texttt{R},\texttt{B}\}$. The total $\sum n \le 10^6$.}
\OUTPUTS{For each test case, print YES if every ordered pair $(i,j)$ with $i<j$ admits some walk from $i$ to $j$ whose sequence of edge colors is a palindrome; otherwise NO. Any letter case is accepted.}
\SAMPLES{Example 1: $n=5$, $c=\texttt{RBBRB}$ $\to$ YES. Example 2: $n=4$, $c=\texttt{RBRB}$ $\to$ NO.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let vertices be $\mathbb{Z}_n$. For each $k\in\mathbb{Z}_n$, the undirected edge $\{k,k+1\}$ has color $c_k\in\{\texttt{R},\texttt{B}\}$. A walk is a sequence $(p_x)_{x=0}^m$ with $p_{x+1}\equiv p_x\pm 1\pmod n$. Its color sequence is $(c_{\min\{p_x,p_{x+1}\}\bmod n})_{x=0}^{m-1}$. We require that for all $i\ne j$, there exists some walk $i\leadsto j$ with a palindromic color sequence.}
\varmapStart
\var{n}{number of vertices/edges in the cycle}
\var{c_k}{color of edge $\{k,k+1\}$ for $k\in\mathbb{Z}_n$}
\var{i,j}{start and end vertices}
\var{m}{length (in edges) of a walk}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer}=\text{YES}\ \Longleftrightarrow\ \exists k\in\mathbb{Z}_n:\ c_k=c_{k+1}.
\end{BreakableEquation*}
Equivalently, the color string $c$ around the cycle is not strictly alternating. For odd $n$ this always holds. For even $n$, this fails exactly when $c$ is periodic with period $2$ and both colors appear.
}
\ASSUMPTIONS{Edges are unit steps on the cycle; colors are attached to edges, not to vertices. Walks may repeat edges/vertices.}
\INVARIANTS{On a strictly alternating coloring, any palindromic color sequence must have odd length; any odd-length walk changes vertex parity, so only pairs of opposite parity can be connected by such palindromes. If any adjacent equal colors exist, one can pad both halves with that color to achieve palindromes of any needed parity and displacement.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly characterize the ``bad'' structure: the only obstruction is a perfectly alternating cycle.}
\ASSUMPTIONS{If every adjacent pair differs ($c_k\ne c_{k+1}$ for all $k$), then $n$ must be even and the colors alternate globally. In that case, pairs of same parity cannot be connected by a palindromic-colored walk.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan the cycle; if any $k$ has $c_k=c_{k+1}$ (indices mod $n$), return YES.
\item Otherwise, the cycle is strictly alternating; return NO.
\end{algosteps}
\COMPLEXITY{Single pass per test case.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1).
\end{aligned}
\]
\CORRECTNESS{If some $c_k=c_{k+1}$, we can always create palindromic walks by mirroring around that equal-color edge, adjusting length parity to match any $(i,j)$. If all adjacent pairs differ, the coloring alternates; any palindrome then has odd length, so pairs of equal parity cannot be connected, violating the requirement.}
\EDGECASES{All edges same color; $n$ odd (always YES); $n$ even with perfect alternation (NO).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        s = list(next(it).strip())
        assert len(s) == n
        cases.append((n, ''.join(s)))
    return t, cases

def solve_case_baseline(n: int, s: str) -> str:
    # YES iff there exists k with s[k] == s[(k+1)%n]
    for k in range(n):
        if s[k] == s[(k + 1) % n]:
            return "YES"
    return "NO"

def solve_all_baseline(cases):
    out = []
    for n, s in cases:
        out.append(solve_case_baseline(n, s))
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-test
        t, cases = 6, [
            (5, "RBBRB"),  # YES (has BB)
            (4, "RBRB"),   # NO (perfect alternation)
            (3, "RRR"),    # YES (all same)
            (6, "RBRBRR"), # YES (has RR)
            (7, "RBRBRBR"),# YES (n odd => cannot alternate globally)
            (8, "BBBBBBBB")# YES
        ]
        got = solve_all_baseline(cases)
        exp = "\n".join(["YES","NO","YES","YES","YES","YES"])
        assert got == exp, (got, exp)
        print(got)
        return
    t, cases = read_input(data)
    print(solve_all_baseline(cases))

if __name__ == "__main__":
    # Additional tiny asserts
    assert solve_case_baseline(4, "RBRB") == "NO"
    assert solve_case_baseline(5, "RBBRB") == "YES"
    assert solve_case_baseline(3, "BRB") == "YES"
    main()
\end{minted}
\VALIDATION{Checked alternating vs non-alternating; odd $n$ cases; all-same color string.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Parity Insight and Early Exit}
\WHICHFORMULA{Use the parity constraint on palindromic walks in alternating cycles: palindromic color sequences on alternating edges must be of odd length, hence cannot connect same-parity vertices.}
\ASSUMPTIONS{Strict alternation implies $n$ is even and both colors appear. Presence of any equal adjacent colors immediately certifies YES.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Linear scan to detect any equal adjacent pair; if found, return YES.
\item Otherwise, deduce strict alternation and return NO without further checks.
\end{algosteps}
\COMPLEXITY{Same $\Theta(n)$ time and $\Theta(1)$ space, but with a clear logical certificate and immediate early return on detection.}
\[
\begin{aligned}
T(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{In alternation, every palindrome is odd-length; an odd-length walk changes parity, so pairs of same parity fail. If not alternating, mirror around any equal-color edge to build palindromes for arbitrary endpoints.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        s = next(it).strip()
        assert len(s) == n
        cases.append((n, s))
    return t, cases

def alternating_cycle(n: int, s: str) -> bool:
    # True iff every adjacent pair differs (modulo n)
    for i in range(n):
        if s[i] == s[(i + 1) % n]:
            return False
    return True

def solve_case(n: int, s: str) -> str:
    return "NO" if alternating_cycle(n, s) else "YES"

def solve_all(cases):
    return "\n".join(solve_case(n, s) for n, s in cases)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-test
        tests = [
            (4, "RBRB", "NO"),
            (6, "BRBRBR", "NO"),
            (6, "BRBRBB", "YES"),
            (5, "RBRBR", "YES"),  # odd n => non-alternating
        ]
        for n, s, expected in tests:
            assert solve_case(n, s) == expected
        print("\n".join(expected for _, _, expected in tests))
        return
    t, cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    # Tiny parity sanity: alternating -> NO
    assert solve_case(4, "RBRB") == "NO"
    # Any equal adjacency -> YES
    assert solve_case(4, "RRRB") == "YES"
    main()
\end{minted}
\VALIDATION{Edge tests confirm NO on perfect alternation (even $n$), YES if any equal adjacency, and YES for all odd $n$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single Scan with Structural Certificate}
\WHICHFORMULA{Final method: return YES iff $\exists k:\ c_k=c_{k+1}$ (indices mod $n$).}
\ASSUMPTIONS{The reduction is exact: strict alternation is the only obstruction.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate $k=0,\ldots,n-1$; if $c_k=c_{k+1\bmod n}$, print YES.
\item If loop completes without a match, print NO.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect $\Omega(n)$ characters in the worst case to distinguish an alternating string from one with a single equal pair; thus the single scan is time-optimal up to constants.}
\COMPLEXITY{Linear time, constant space.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        s = next(it).strip()
        assert len(s) == n
        cases.append((n, s))
    return t, cases

def solve_case(n: int, s: str) -> str:
    # YES iff not perfectly alternating
    for i in range(n):
        if s[i] == s[(i + 1) % n]:
            return "YES"
    return "NO"

def solve_all(cases):
    return "\n".join(solve_case(n, s) for n, s in cases)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Internal mini-tests
        small = [
            (3, "RRR", "YES"),
            (4, "RBRB", "NO"),
            (5, "RBBRB", "YES"),
        ]
        for n, s, ans in small:
            assert solve_case(n, s) == ans
        print("\n".join(ans for _, _, ans in small))
        return
    t, cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    # Deterministic asserts
    assert solve_case(6, "RBRBRB") == "NO"
    assert solve_case(6, "RBRBRR") == "YES"
    assert solve_case(7, "RBRBRBR") == "YES"
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts included: perfectly alternating even $n$ returns NO; a single equal pair returns YES; odd $n$ returns YES.}
\RESULT{Print YES if the cycle is not strictly alternating; otherwise NO.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for: all-same colors; single equal pair; odd $n$; even $n$ with alternation; random small cycles cross-checked between different implementations.}
\LINE{CROSS-CHECKS}{Compare baseline and final functions on a sweep of small $n\le 8$ over all $2^n$ colorings, verifying identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate all binary strings up to small $n$ and detect alternation property to assert expected outputs.}
\begin{minted}{python}
import sys
from itertools import product

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        s = next(it).strip()
        cases.append((n, s))
    return t, cases

def is_alternating(n: int, s: str) -> bool:
    for i in range(n):
        if s[i] == s[(i + 1) % n]:
            return False
    return True

def solve_case_ref(n: int, s: str) -> str:
    return "NO" if is_alternating(n, s) else "YES"

def solve_all_ref(cases):
    return "\n".join(solve_case_ref(n, s) for n, s in cases)

def cross_check_small():
    # Exhaustive for n up to 7
    for n in range(3, 8):
        for bits in product("RB", repeat=n):
            s = "".join(bits)
            ans = solve_case_ref(n, s)
            # Independent oracle: check exists equal adjacency
            oracle = "YES" if any(s[i] == s[(i+1)%n] for i in range(n)) else "NO"
            assert ans == oracle, (n, s, ans, oracle)
    return True

def main():
    # Run cross-checks if no stdin
    data = sys.stdin.read()
    if not data.strip():
        assert cross_check_small()
        # Also run a few fixed tests
        tests = [
            (4, "RBRB"), (5, "RBBRB"), (6, "BBBBBB"), (6, "RBRBRB"), (7, "RBRBRBR")
        ]
        print("\n".join(solve_case_ref(n, s) for n, s in tests))
        return
    t, cases = read_input(data)
    print(solve_all_ref(cases))

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        s = next(it).strip()
        assert len(s) == n
        cases.append((n, s))
    return t, cases

def solve_case(n: int, s: str) -> str:
    # YES iff there exists k with s[k] == s[(k+1)%n]
    for i in range(n):
        if s[i] == s[(i + 1) % n]:
            return "YES"
    return "NO"

def solve_all(cases):
    return "\n".join(solve_case(n, s) for n, s in cases)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks
        assert solve_case(4, "RBRB") == "NO"
        assert solve_case(5, "RBBRB") == "YES"
        assert solve_case(3, "BRB") == "YES"
        print("\n".join([
            solve_case(4, "RBRB"),
            solve_case(5, "RBBRB"),
            solve_case(3, "BRB"),
        ]))
        return
    t, cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Answer YES iff the cycle is not perfectly alternating in color.}
\WHY{This captures a common trick: translating a global walk constraint (palindromic colors) into a local structural certificate (adjacent equal colors).}
\CHECKLIST{%
\begin{bullets}
\item Scan once around the cycle.
\item If any adjacent equal colors exist, print YES.
\item Otherwise, print NO.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item All edges the same color (YES).
\item Exactly one adjacent equal pair (YES).
\item Even $n$ with strict alternation (NO).
\item Odd $n$ (always YES).
\item Minimal $n=3$.
\item Large $n$ near $10^6$ with no equal pairs until the end.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting cyclic adjacency between $c_{n-1}$ and $c_0$.
\item Misinterpreting palindromic constraint as directions instead of colors.
\item Assuming alternation possible for odd $n$ (it is not).
\item Off-by-one in indexing modulo $n$.
\item Allocating $O(n)$ per test case unnecessarily in Python loops; keep constant extra space.
\item Not accounting for multiple test cases and the total $\sum n$ bound.
\end{bullets}
}
\FAILMODES{%
\begin{bullets}
\item Algorithms that attempt to search paths explicitly will time out; the structural test avoids this.
\item If one checks only linear adjacency but forgets the wrap-around, false positives can occur.
\end{bullets}
}
\ELI{A palindrome-colored walk needs symmetry in colors. If you ever have two neighboring edges of the same color, you can reflect a walk around them to get symmetry for any endpoints. If colors strictly alternate all the way, some pairs cannot be symmetrically connected, so the answer is NO.}
\NotePages{3}

\end{document}