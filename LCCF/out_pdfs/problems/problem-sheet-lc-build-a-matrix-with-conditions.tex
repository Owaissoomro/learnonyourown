% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Build a Matrix With Conditions}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/build-a-matrix-with-conditions/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a positive integer $k$. You are also given:
\begin{itemize}
\item a 2D integer array \texttt{rowConditions} of size $n$ where $\texttt{rowConditions}[i] = [\textit{above}_i,\ \textit{below}_i]$, and
\item a 2D integer array \texttt{colConditions} of size $m$ where $\texttt{colConditions}[i] = [\textit{left}_i,\ \textit{right}_i]$.
\end{itemize}
The two arrays contain integers from $1$ to $k$. You have to build a $k \times k$ matrix that contains each of the numbers from $1$ to $k$ exactly once. The remaining cells should have the value $0$. The matrix should also satisfy the following conditions:
\begin{itemize}
\item The number $\textit{above}_i$ should appear in a row that is strictly above the row at which the number $\textit{below}_i$ appears for all $i$ from $0$ to $n-1$.
\item The number $\textit{left}_i$ should appear in a column that is strictly left of the column at which the number $\textit{right}_i$ appears for all $i$ from $0$ to $m-1$.
\end{itemize}
Return any matrix that satisfies the conditions. If no answer exists, return an empty matrix.
\par
Example 1:
\begin{itemize}
\item Input: $k = 3$, \texttt{rowConditions} $= [[1,2],[3,2]]$, \texttt{colConditions} $= [[2,1],[3,2]]$
\item Output: \texttt{[[3,0,0],[0,0,1],[0,2,0]]}
\item Explanation: A valid matrix exists. Row conditions: $1$ is above $2$; $3$ is above $2$. Column conditions: $2$ is left of $1$; $3$ is left of $2$. There may be multiple correct answers.
\end{itemize}
Example 2:
\begin{itemize}
\item Input: $k = 3$, \texttt{rowConditions} $= [[1,2],[2,3],[3,1],[2,3]]$, \texttt{colConditions} $= [[2,1]]$
\item Output: \texttt{[]}
\item Explanation: From the first two conditions, $3$ has to be below $1$, but the third condition requires $3$ to be above $1$. No matrix can satisfy all the conditions, so return the empty matrix.
\end{itemize}
Constraints:
\begin{itemize}
\item $2 \le k \le 400$
\item $1 \le \texttt{rowConditions.length},\ \texttt{colConditions.length} \le 10^{4}$
\item $\texttt{rowConditions}[i].\texttt{length} = \texttt{colConditions}[i].\texttt{length} = 2$
\item $1 \le \textit{above}_i,\ \textit{below}_i,\ \textit{left}_i,\ \textit{right}_i \le k$
\item $\textit{above}_i \ne \textit{below}_i$
\item $\textit{left}_i \ne \textit{right}_i$
\end{itemize}}
\BREAKDOWN{Build a permutation of rows and a permutation of columns for the labels $1..k$ that satisfy the respective partial orders. If either partial order has a cycle, no solution exists. Otherwise, place each number $v$ at the intersection of its topological row and column indices; fill remaining cells with $0$.}
\ELI{Topologically sort the row constraints and the column constraints separately, then put each number at the intersection of its row rank and column rank. If a sort fails (cycle), return an empty matrix.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers and arrays:
\begin{itemize}
\item $k$ (int): size of the square matrix and the label range $\{1,\ldots,k\}$.
\item \texttt{rowConditions} (list of pairs): each pair $[a,b]$ requires label $a$ to be placed in a strictly higher row than $b$.
\item \texttt{colConditions} (list of pairs): each pair $[l,r]$ requires label $l$ to be placed in a strictly left column of $r$.
\end{itemize}
Valid ranges: $2 \le k \le 400$; arrays have length between $1$ and $10^{4}$; all entries are in $[1,k]$ with distinct elements per pair.}
\OUTPUTS{A $k \times k$ integer matrix represented as a list of $k$ lists of length $k$:
\begin{itemize}
\item If feasible: each label $v \in \{1,\ldots,k\}$ appears exactly once; all other cells are $0$; all given row and column precedence constraints are satisfied.
\item If infeasible: return \texttt{[]}.
\end{itemize}}
\SAMPLES{Example A:
\begin{itemize}
\item Input: $k=3$, \texttt{rowConditions} $=[[1,2],[3,2]]$, \texttt{colConditions} $=[[2,1],[3,2]]$
\item Output: one valid matrix, e.g., \texttt{[[3,0,0],[0,0,1],[0,2,0]]}
\end{itemize}
Example B:
\begin{itemize}
\item Input: $k=3$, \texttt{rowConditions} $=[[1,2],[2,3],[3,1],[2,3]]$, \texttt{colConditions} $=[[2,1]]$
\item Output: \texttt{[]}
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{1,2,\ldots,k\}$. Define two directed relations:
\begin{itemize}
\item Row precedence $R \subseteq V \times V$ where $(a,b)\in R$ iff $a$ must be above $b$.
\item Column precedence $C \subseteq V \times V$ where $(\ell,r)\in C$ iff $\ell$ must be left of $r$.
\end{itemize}
We seek injective row and column placement functions $r:V\to\{0,\ldots,k-1\}$ and $c:V\to\{0,\ldots,k-1\}$ such that
$r(a)<r(b)$ for all $(a,b)\in R$ and $c(\ell)<c(r)$ for all $(\ell,r)\in C$. Let $M\in\{0,\ldots,k\}^{k\times k}$ with $M_{r(v),c(v)}=v$ and $0$ elsewhere.}
\varmapStart
\var{V}{label set $\{1,\ldots,k\}$}
\var{R}{row precedence pairs $(a,b)$}
\var{C}{column precedence pairs $(\ell,r)$}
\var{r(\cdot)}{row index function (injective)}
\var{c(\cdot)}{column index function (injective)}
\var{M}{final matrix with unique placement of each $v\in V$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Find permutations } \pi_r,\pi_c \text{ of } V \text{ such that}\\
&\forall(a,b)\in R:\ \operatorname{pos}_{\pi_r}(a) < \operatorname{pos}_{\pi_r}(b),\qquad
\forall(\ell,r)\in C:\ \operatorname{pos}_{\pi_c}(\ell) < \operatorname{pos}_{\pi_c}(r),\\
&\text{Then set } r(v)=\operatorname{pos}_{\pi_r}(v),\ c(v)=\operatorname{pos}_{\pi_c}(v),\ M_{r(v),c(v)}=v,\ \text{others } 0.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $0$-based for matrix positions. Inputs only use labels in $\{1,\ldots,k\}$ and do not contain self-constraints.}
\INVARIANTS{
\begin{itemize}
\item If $R$ (or $C$) has a directed cycle, no permutation $\pi_r$ (or $\pi_c$) exists; conversely, acyclicity admits a topological order.
\item Each label $v$ is placed exactly once since $r$ and $c$ are permutations (injective and total on $V$).
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute a topological ordering of $1..k$ under the row constraints and separately under the column constraints using Kahn's algorithm. Place label $v$ at $(\text{rowPos}[v],\ \text{colPos}[v])$.}
\ASSUMPTIONS{Use a straightforward adjacency list and indegree counts; allow duplicate edges as they appear (treated as parallel edges).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build directed graph $G_r$ over $1..k$ from \texttt{rowConditions}, increment indegrees (allow duplicates).
\item Run Kahn's algorithm to get order $\pi_r$; if not all $k$ appear, return \texttt{[]}.
\item Repeat for columns to get $\pi_c$; if it fails, return \texttt{[]}.
\item Map each label $v$ to row index $\operatorname{pos}_{\pi_r}(v)$ and column index $\operatorname{pos}_{\pi_c}(v)$; set matrix cell to $v$, others to $0$.
\end{algosteps}
\COMPLEXITY{Let $E_r=\lvert \texttt{rowConditions}\rvert$, $E_c=\lvert \texttt{colConditions}\rvert$.
\[
\begin{aligned}
T(k,E_r,E_c) &= \mathcal{O}\big(k + E_r + k + E_c + k^2\big) = \mathcal{O}(k^2 + E_r + E_c),\\
S(k,E_r,E_c) &= \mathcal{O}(k + E_r + E_c + k^2) \text{ including the output matrix.}
\end{aligned}
\]
}
\CORRECTNESS{Kahn's algorithm returns a topological order iff the graph is acyclic. The two orders independently satisfy the row and column partial orders. Placing each label at the intersection of its row and column positions yields unique placement and honors both precedence constraints.}
\EDGECASES{Cycles in either constraint set; labels not appearing in any constraint; duplicate edges; $k=2$ minimal case.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Dict
import collections

class Solution:
    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
        def topo_no_dedup(k: int, edges: List[List[int]]):
            adj = [[] for _ in range(k + 1)]
            indeg = [0] * (k + 1)
            for u, v in edges:
                if 1 <= u <= k and 1 <= v <= k and u != v:
                    adj[u].append(v)
                    indeg[v] += 1
            dq = collections.deque([i for i in range(1, k + 1) if indeg[i] == 0])
            order = []
            while dq:
                u = dq.popleft()
                order.append(u)
                for w in adj[u]:
                    indeg[w] -= 1
                    if indeg[w] == 0:
                        dq.append(w)
            if len(order) != k:
                return []
            pos = {node: i for i, node in enumerate(order)}
            return order, pos

        r = topo_no_dedup(k, rowConditions)
        if not r:
            return []
        c = topo_no_dedup(k, colConditions)
        if not c:
            return []
        _, rpos = r
        _, cpos = c
        mat = [[0] * k for _ in range(k)]
        for v in range(1, k + 1):
            mat[rpos[v]][cpos[v]] = v
        return mat

# --- Tiny validation helpers and asserts ---
def check_matrix(mat: List[List[int]], k: int,
                 rowConditions: List[List[int]], colConditions: List[List[int]]) -> bool:
    if not mat or len(mat) != k or any(len(row) != k for row in mat):
        return False
    seen = set()
    loc = {}
    for i in range(k):
        for j in range(k):
            v = mat[i][j]
            if v == 0:
                continue
            if not (1 <= v <= k) or v in seen:
                return False
            seen.add(v)
            loc[v] = (i, j)
    if len(seen) != k:
        return False
    for a, b in rowConditions:
        if a in loc and b in loc:
            if not (loc[a][0] < loc[b][0]):
                return False
    for l, r in colConditions:
        if l in loc and r in loc:
            if not (loc[l][1] < loc[r][1]):
                return False
    return True

# Example 1: should produce a valid matrix
sol = Solution()
k = 3
rows = [[1,2],[3,2]]
cols = [[2,1],[3,2]]
ans = sol.buildMatrix(k, rows, cols)
assert check_matrix(ans, k, rows, cols)

# Example 2: infeasible => empty
k2 = 3
rows2 = [[1,2],[2,3],[3,1],[2,3]]
cols2 = [[2,1]]
assert Solution().buildMatrix(k2, rows2, cols2) == []
\end{minted}
\VALIDATION{Checked the first sample via a validator (not exact shape) and the second sample for emptiness.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Deduplicate parallel edges to avoid inflated indegrees and unnecessary decrements. This reduces memory and can speed up in the presence of many duplicates.}
\ASSUMPTIONS{Use sets for adjacency to ensure unique edges; otherwise, same Kahn's algorithm.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each constraint list, build adjacency as a set per node and indegree from unique edges only.
\item Run Kahn's algorithm to obtain $\pi_r$ and $\pi_c$; abort if either fails.
\item Place labels at intersections of positions as before.
\end{algosteps}
\COMPLEXITY{With $E'_r$ and $E'_c$ the number of unique edges:
\[
\begin{aligned}
T &= \mathcal{O}(k + E'_r + k + E'_c + k^2) = \mathcal{O}(k^2 + E'_r + E'_c),\\
S &= \mathcal{O}(k + E'_r + E'_c + k^2).
\end{aligned}
\]
It is never worse than the baseline and is better when there are many duplicates.}
\CORRECTNESS{Removing duplicate edges preserves the partial order relation. Kahn's algorithm correctness is unchanged; the final placement logic is identical.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import collections

class Solution:
    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
        def topo_dedup(k: int, edges: List[List[int]]):
            adj = [set() for _ in range(k + 1)]
            indeg = [0] * (k + 1)
            for u, v in edges:
                if 1 <= u <= k and 1 <= v <= k and u != v and v not in adj[u]:
                    adj[u].add(v)
                    indeg[v] += 1
            dq = collections.deque([i for i in range(1, k + 1) if indeg[i] == 0])
            order = []
            while dq:
                u = dq.popleft()
                order.append(u)
                for w in adj[u]:
                    indeg[w] -= 1
                    if indeg[w] == 0:
                        dq.append(w)
            if len(order) != k:
                return []
            pos = {node: i for i, node in enumerate(order)}
            return order, pos

        r = topo_dedup(k, rowConditions)
        if not r:
            return []
        c = topo_dedup(k, colConditions)
        if not c:
            return []
        _, rpos = r
        _, cpos = c
        mat = [[0] * k for _ in range(k)]
        for v in range(1, k + 1):
            mat[rpos[v]][cpos[v]] = v
        return mat

# Checks
def ok(mat: List[List[int]], k: int, rows: List[List[int]], cols: List[List[int]]) -> bool:
    if mat == []:
        return False
    pos = {}
    for i in range(k):
        for j in range(k):
            v = mat[i][j]
            if v != 0:
                pos[v] = (i, j)
    if set(pos.keys()) != set(range(1, k + 1)):
        return False
    for a, b in rows:
        if not (pos[a][0] < pos[b][0]):
            return False
    for l, r in cols:
        if not (pos[l][1] < pos[r][1]):
            return False
    return True

# Tiny tests
sol = Solution()
ans1 = sol.buildMatrix(3, [[1,2],[3,2]], [[2,1],[3,2]])
assert ok(ans1, 3, [[1,2],[3,2]], [[2,1],[3,2]])
assert Solution().buildMatrix(3, [[1,2],[2,3],[3,1],[2,3]], [[2,1]]) == []
\end{minted}
\VALIDATION{Validated both a feasible and an infeasible case; ensured each label appears exactly once with constraints met.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Two independent topological sorts on the row and column constraint DAGs (with deduped edges), then place labels at rank intersections.}
\ASSUMPTIONS{Applies when both constraint graphs are acyclic. Works for any $k$ within constraints; duplicates and irrelevant labels are handled.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build unique-edge DAGs for rows and columns; compute indegrees.
\item Run Kahn's algorithm on each to obtain permutations $\pi_r$ and $\pi_c$; if either fails, return \texttt{[]}.
\item Compute index maps $rpos[v]$ and $cpos[v]$; allocate matrix and place $v$ at $(rpos[v],cpos[v])$ for all $v$.
\item Return the matrix; by construction it satisfies all constraints and uses each label once.
\end{algosteps}
\OPTIMALITY{Any solution must determine a feasible linear extension of each partial order, which takes at least linear time in the size of the graph. The algorithm runs in $\Theta(k + E)$ time per graph plus output construction, which is optimal up to constant factors.}
\COMPLEXITY{Let $E = E'_r + E'_c$ be the total number of unique constraints:
\[
\begin{aligned}
T(k,E) &= \mathcal{O}(k + E + k^2),\quad S(k,E) = \mathcal{O}(k + E + k^2).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import collections

class Solution:
    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
        def topo_unique(k: int, edges: List[List[int]]):
            adj = [set() for _ in range(k + 1)]
            indeg = [0] * (k + 1)
            for u, v in edges:
                if 1 <= u <= k and 1 <= v <= k and u != v and v not in adj[u]:
                    adj[u].add(v)
                    indeg[v] += 1
            dq = collections.deque([i for i in range(1, k + 1) if indeg[i] == 0])
            order = []
            while dq:
                u = dq.popleft()
                order.append(u)
                for w in adj[u]:
                    indeg[w] -= 1
                    if indeg[w] == 0:
                        dq.append(w)
            if len(order) != k:
                return []
            pos = {node: i for i, node in enumerate(order)}
            return order, pos

        r = topo_unique(k, rowConditions)
        if not r:
            return []
        c = topo_unique(k, colConditions)
        if not c:
            return []
        _, rpos = r
        _, cpos = c

        mat = [[0] * k for _ in range(k)]
        for v in range(1, k + 1):
            mat[rpos[v]][cpos[v]] = v
        return mat

# --- Exactly 3 asserts ---
# 1) Feasible sample must validate constraints and uniqueness
def validate(mat: List[List[int]], k: int, rows: List[List[int]], cols: List[List[int]]) -> bool:
    if len(mat) != k or any(len(row) != k for row in mat):
        return False
    pos = {}
    for i in range(k):
        for j in range(k):
            v = mat[i][j]
            if v != 0:
                if v in pos or not (1 <= v <= k):
                    return False
                pos[v] = (i, j)
    if set(pos.keys()) != set(range(1, k + 1)):
        return False
    for a, b in rows:
        if not (pos[a][0] < pos[b][0]):
            return False
    for l, r in cols:
        if not (pos[l][1] < pos[r][1]):
            return False
    return True

sol = Solution()
ans = sol.buildMatrix(3, [[1,2],[3,2]], [[2,1],[3,2]])
assert validate(ans, 3, [[1,2],[3,2]], [[2,1],[3,2]])

# 2) Infeasible sample
assert Solution().buildMatrix(3, [[1,2],[2,3],[3,1],[2,3]], [[2,1]]) == []

# 3) No constraints: should be a permutation placement using all labels exactly once
k3 = 4
ans3 = Solution().buildMatrix(k3, [], [])
flat = [v for row in ans3 for v in row if v != 0]
assert sorted(flat) == list(range(1, k3 + 1))
\end{minted}
\VALIDATION{Three asserts: validates a feasible sample structurally, checks infeasibility returns empty, and confirms coverage of all labels when there are no constraints.}
\RESULT{Returns a $k \times k$ matrix meeting all precedence constraints with each $1..k$ appearing once; returns \texttt{[]} if either constraint graph is cyclic.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: feasible small DAGs; infeasible cycles; cases with duplicates; cases with isolated labels; extreme $k$ with empty constraints. Property checks: output uses each label exactly once and satisfies given partial orders.}
\LINE{CROSS-CHECKS}{Compare baseline vs improved vs final on crafted instances; ensure all produce valid results on DAGs and all return empty on cyclic inputs.}
\LINE{EDGE-CASE GENERATOR}{Generate deterministic patterns: chains, stars, parallel chains, and a simple 3-cycle.}
\begin{minted}{python}
from typing import List, Tuple

def gen_chain(k: int) -> List[List[int]]:
    return [[i, i+1] for i in range(1, k)]

def gen_star_above(k: int, center: int = 1) -> List[List[int]]:
    return [[center, i] for i in range(1, k+1) if i != center]

def gen_two_chains(k: int) -> Tuple[List[List[int]], List[List[int]]]:
    a = [[i, i+1] for i in range(1, k) if i % 2 == 1]
    b = [[i, i+1] for i in range(1, k) if i % 2 == 0]
    return a, b

def gen_cycle_3() -> List[List[int]]:
    return [[1,2],[2,3],[3,1]]

# Cross-check runner (deterministic)
def check_solution(SolCls, k: int, rows: List[List[int]], cols: List[List[int]]) -> bool:
    sol = SolCls()
    mat = sol.buildMatrix(k, rows, cols)
    if mat == []:
        # accept only if either rows or cols have an obvious cycle (we test such cases explicitly)
        return False
    pos = {}
    for i in range(k):
        for j in range(k):
            v = mat[i][j]
            if v != 0:
                if v in pos: return False
                pos[v] = (i, j)
    if set(pos.keys()) != set(range(1, k+1)):
        return False
    for a, b in rows:
        if pos[a][0] >= pos[b][0]:
            return False
    for l, r in cols:
        if pos[l][1] >= pos[r][1]:
            return False
    return True
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import collections

class Solution:
    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
        def topo_unique(k: int, edges: List[List[int]]):
            adj = [set() for _ in range(k + 1)]
            indeg = [0] * (k + 1)
            for u, v in edges:
                if 1 <= u <= k and 1 <= v <= k and u != v and v not in adj[u]:
                    adj[u].add(v)
                    indeg[v] += 1
            dq = collections.deque([i for i in range(1, k + 1) if indeg[i] == 0])
            order = []
            while dq:
                u = dq.popleft()
                order.append(u)
                for w in adj[u]:
                    indeg[w] -= 1
                    if indeg[w] == 0:
                        dq.append(w)
            if len(order) != k:
                return []
            pos = {node: i for i, node in enumerate(order)}
            return order, pos

        row = topo_unique(k, rowConditions)
        if not row:
            return []
        col = topo_unique(k, colConditions)
        if not col:
            return []
        _, rpos = row
        _, cpos = col
        mat = [[0] * k for _ in range(k)]
        for v in range(1, k + 1):
            mat[rpos[v]][cpos[v]] = v
        return mat

# Asserts for quick sanity
def validate(mat: List[List[int]], k: int, rows: List[List[int]], cols: List[List[int]]) -> bool:
    if mat == []:
        return False
    if len(mat) != k or any(len(r) != k for r in mat):
        return False
    pos = {}
    for i in range(k):
        for j in range(k):
            v = mat[i][j]
            if v != 0:
                if v in pos or not (1 <= v <= k):
                    return False
                pos[v] = (i, j)
    if set(pos.keys()) != set(range(1, k + 1)):
        return False
    for a, b in rows:
        if pos[a][0] >= pos[b][0]:
            return False
    for l, r in cols:
        if pos[l][1] >= pos[r][1]:
            return False
    return True

# Feasible sample
sol = Solution()
ans = sol.buildMatrix(3, [[1,2],[3,2]], [[2,1],[3,2]])
assert validate(ans, 3, [[1,2],[3,2]], [[2,1],[3,2]])

# Infeasible sample
assert Solution().buildMatrix(3, [[1,2],[2,3],[3,1],[2,3]], [[2,1]]) == []

# No constraints
k = 5
ans2 = Solution().buildMatrix(k, [], [])
flat = [v for row in ans2 for v in row if v != 0]
assert sorted(flat) == list(range(1, k + 1))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Topologically sort rows and columns separately; place each label at the intersection of its row rank and column rank.}
\WHY{This pattern appears in ordering with multiple independent precedence constraints (e.g., scheduling by two criteria). Recognizing independent DAG topological sorts is key.}
\CHECKLIST{
\begin{bullets}
\item Build DAGs for rows and columns.
\item Deduplicate edges; compute indegrees.
\item Kahn's algorithm on each; verify length $k$.
\item Map label to $(\text{row},\text{col})$ indices.
\item Fill matrix; others are $0$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Cycles in row constraints.
\item Cycles in column constraints.
\item Many duplicate constraints.
\item Labels absent from constraints.
\item Minimal $k=2$.
\item Maximal sizes with sparse constraints.
\item Conflicting single pair vs long chain.
\item Disconnected components.
\item Self-edges in input (should be ignored).
\item Out-of-range values (robust code guards them).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to include labels not present in constraints in the topological order.
\item Counting duplicate edges twice, inflating indegrees unnecessarily.
\item Not checking that the topological order includes all $k$ nodes.
\item Off-by-one between $1..k$ labels and $0$-based indices.
\item Overwriting cells instead of mapping by positions.
\item Assuming the example output shape is unique.
\item Misinterpreting row vs column precedence directions.
\item Using recursion depth (DFS) and hitting recursion limits.
\end{bullets}}
\FAILMODES{Approaches that try to greedily place numbers without respecting both partial orders simultaneously fail on intersecting constraints. Cycle-unaware methods return invalid matrices; the topological-sort approach detects cycles and returns \texttt{[]}.}
\ELI{Make two rankings: one for how high each number should be, and one for how far left. If both rankings are possible, put each number where its row rank and column rank meet. If you cannot make either ranking because of a cycle, there is no valid matrix.}
\NotePages{3}

\end{document}