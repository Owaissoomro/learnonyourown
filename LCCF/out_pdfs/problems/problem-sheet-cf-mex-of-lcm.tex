% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — MEX of LCM}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1834/E}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{You are given an array $a$ of length $n$. A positive integer $x$ is called good if it is impossible to find a subsegment of the array such that the least common multiple of all its elements is equal to $x$.

You need to find the smallest good integer.

A subsegment of the array $a$ is a set of elements $a_l, a_{l + 1}, \ldots, a_r$ for some $1 \le l \le r \le n$. We denote such subsegment as $[l, r]$.

Input:
The first line contains a single integer $t$ ($1 \le t \le 5 \cdot 10^4$) — the number of test cases. The test cases follow.

For each test case, the first line contains a single integer $n$ ($1 \le n \le 3 \cdot 10^5$) — the length of the array $a$.

The second line of each test case contains $n$ integers $a_1, a_2, \ldots , a_n$ ($1 \le a_i \le 10^9$) — the elements of the array $a$.

It is guaranteed that the sum of $n$ over all test cases does not exceed $3 \cdot 10^5$.

Output:
For each test case, output a single integer — the smallest good integer.

Note:
In the first test case, $4$ is a good integer, and it is the smallest one, since the integers $1,2,3$ appear in the array, which means that there are subsegments of the array of length $1$ with least common multiples of $1,2,3$. However, it is impossible to find a subsegment of the array with a least common multiple equal to $4$.

In the second test case, $7$ is a good integer. The integers $1,2,3,4,5$ appear explicitly in the array, and the integer $6$ is the least common multiple of the subsegments $[2, 3]$ and $[1, 3]$.

In the third test case, $1$ is a good integer, since the least common multiples for the integer in the subsegments $[1, 1], [1, 2], [2, 2]$ are $2,6,3$, respectively.}
\BREAKDOWN{We must determine the mex of the set of all subarray LCMs. Characterize when a value $x$ can be an LCM of a subarray and build an algorithm to enumerate all achievable LCMs efficiently, then compute the mex.}
\ELI{Track all distinct LCM values obtainable by any contiguous subarray, then return the smallest positive integer missing from this set.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case: integer $n$; array $a$ of length $n$ with $1 \le a_i \le 10^9$. Sum of $n$ over all tests $\le 3 \cdot 10^5$.}
\OUTPUTS{For each test case, a single integer: the smallest positive integer that is not equal to the LCM of any contiguous subarray of $a$.}
\SAMPLES{
Example 1:
$n=3$, $a=[1,2,3]$. Achievable LCMs: $\{1,2,3,6\}$. Smallest missing is $4$.

Example 2:
$n=3$, $a=[2,3,6]$. Achievable LCMs: $\{2,3,6\}$. Smallest missing is $1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=\{a_1,\ldots,a_n\}$. Define the set
\begin{BreakableEquation*}
\mathcal{L}(A) \coloneqq \{\operatorname{lcm}(a_l,\ldots,a_r) \mid 1 \le l \le r \le n\}.
\end{BreakableEquation*}
We must output $\operatorname{mex}(\mathcal{L}(A)) \coloneqq \min \{x \in \mathbb{Z}_{>0} \mid x \notin \mathcal{L}(A)\}.
$}
\varmapStart
\var{n}{array length}
\var{a_i}{array element at index $i$}
\var{\mathcal{L}(A)}{set of all subarray LCMs}
\var{\operatorname{mex}}{minimum excluded positive integer}
\varmapEnd
\GOVERN{
\[
\operatorname{lcm}(x,y)=\frac{x \cdot y}{\gcd(x,y)},\qquad
\mathcal{L}(A)=\bigcup_{1 \le l \le r \le n}\left\{\operatorname{lcm}(a_l,\ldots,a_r)\right\}.
\]
}
\ASSUMPTIONS{Standard integer arithmetic. LCM is associative and commutative over positive integers.}
\INVARIANTS{
- For fixed right end $r$, the set of distinct LCMs of subarrays ending at $r$ can be constructed from those ending at $r-1$ by taking LCM with $a_r$ and merging duplicates.

- Adding more elements to a subarray never decreases its LCM.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all subarrays and compute their LCMs directly using $\operatorname{lcm}(x,y)=\tfrac{x \cdot y}{\gcd(x,y)}$.}
\ASSUMPTIONS{Use a hash set to store all distinct LCMs; early stop if LCM grows beyond a reasonable bound while seeking small mex.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $l$ from $1$ to $n$:
\item Initialize $v \leftarrow 1$ and for each $r$ from $l$ to $n$: update $v \leftarrow \operatorname{lcm}(v,a_r)$ and insert $v$ into the set.
\item After all subarrays, scan $x=1,2,\ldots$ to find the smallest $x$ not in the set.
\end{algosteps}
\COMPLEXITY{Quadratic enumeration in $n$; LCM and hash operations are logarithmic in value magnitudes.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(\sum_{l=1}^{n}(n-l+1)\right)=\Theta(n^2), \\
S(n) &= \Theta(K),
\end{aligned}
\]
where $K$ is the number of distinct LCMs encountered.
\CORRECTNESS{By definition we compute $\operatorname{lcm}$ on every contiguous subarray and collect all possible values, so the mex over this set is correct.}
\EDGECASES{Arrays with $n=1$; presence or absence of $1$; repeated equal elements; large primes.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from math import gcd

def lcm(a, b):
    return a // gcd(a, b) * b

def mex_of_lcms_bruteforce(a):
    n = len(a)
    seen = set()
    for l in range(n):
        cur = 1
        for r in range(l, n):
            cur = lcm(cur, a[r])
            seen.add(cur)
    x = 1
    while x in seen:
        x += 1
    return x

# Tiny sanity checks for the baseline
assert mex_of_lcms_bruteforce([1, 2, 3]) == 4
assert mex_of_lcms_bruteforce([2, 3, 6]) == 1
assert mex_of_lcms_bruteforce([2]) == 1
\end{minted}
\VALIDATION{The asserts check cases where the answer is small and clear by inspection.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-Ending Compression of Distinct LCMs}
\WHICHFORMULA{Maintain the set of distinct LCMs for all subarrays ending at index $i$ by combining the set for $i-1$ with the new element. Merge identical LCM values to keep the list small.}
\ASSUMPTIONS{In practice, the number of distinct LCMs per right end is modest due to rapid growth and merging.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a list of pairs for the previous right end: distinct LCM values for subarrays ending at $i-1$, each with any auxiliary metadata if desired.
\item For new position $i$, form a new list by taking $\operatorname{lcm}$ of each previous value with $a_i$, plus the single-element subarray value $a_i$.
\item Deduplicate consecutive equal LCMs to keep only distinct values; insert them into a global set of seen LCMs.
\item After processing all $i$, scan for the mex.
\end{algosteps}
\COMPLEXITY{Let $m_i$ be the number of distinct LCMs of subarrays ending at $i$.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(\sum_{i=1}^{n} m_i\right), \\
\end{aligned}
\]
with $m_i$ typically small in practice; space is linear in the total number of distinct LCMs tracked at once.}
\CORRECTNESS{Every subarray ending at $i$ is either the single-element $[i,i]$ or an extension of a subarray ending at $i-1$. Taking LCM with $a_i$ enumerates exactly these, and deduplication preserves the set.}
\textbf{Code (Improved)}
\begin{minted}{python}
from math import gcd

def lcm(a, b):
    return a // gcd(a, b) * b

def mex_of_lcms_endwise(a):
    n = len(a)
    seen = set()
    prev = []  # list of distinct lcm values for subarrays ending at i-1
    for x in a:
        cur = []
        # start with the single-element subarray
        val = x
        if not cur or cur[-1] != val:
            cur.append(val)
        for v in prev:
            nv = lcm(v, x)
            if cur[-1] != nv:
                cur.append(nv)
        # record all distinct lcms ending at this index
        for v in cur:
            seen.add(v)
        prev = cur
    # mex scan
    ans = 1
    while ans in seen:
        ans += 1
    return ans

# Checks for improved approach
assert mex_of_lcms_endwise([1, 2, 3]) == 4
assert mex_of_lcms_endwise([2, 3, 6]) == 1
assert mex_of_lcms_endwise([1, 1, 1]) == 2
\end{minted}
\VALIDATION{Edge inputs such as all ones, presence of a single element, and simple mixed arrays match expected mex.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Deduplicated LCM Frontier per Index}
\WHICHFORMULA{Propagate the frontier of distinct LCMs per index as in Approach B, but store only values (no extra metadata) and merge on the fly. This enumerates all subarray LCMs without redundant recomputation, then returns the mex.}
\ASSUMPTIONS{Python big integers safely hold LCM magnitudes. In competitive settings, one can additionally cap values once they exceed the current mex candidate to prune growth, but the core logic remains the same.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an empty set of seen LCMs and an empty list for the previous frontier.
\item For each index $i$:
  \begin{itemize}
  \item Start a new list with $a_i$.
  \item For each value $v$ from the previous list, compute $w=\operatorname{lcm}(v,a_i)$; append $w$ unless equal to the last appended value.
  \end{itemize}
\item Insert all values from the new list into the global seen set and replace the previous list.
\item After the loop, return the smallest positive integer not in the seen set.
\end{algosteps}
\OPTIMALITY{This method avoids explicit enumeration of $O(n^2)$ subarrays. It is the standard dynamic frontier technique used for subarray GCDs, adapted to LCMs with deduplication.}
\COMPLEXITY{Let $m_i$ be the number of distinct LCMs for subarrays ending at $i$. The runtime is $O\!\left(\sum_i m_i\right)$ LCM computations; memory is $O\!\left(\max_i m_i\right)$ plus the number of distinct LCMs gathered.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(\sum_{i=1}^{n} m_i\right).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from math import gcd
import sys

def lcm(a, b):
    return a // gcd(a, b) * b

def mex_of_lcms(a):
    seen = set()
    prev = []
    for x in a:
        cur = []
        # single element subarray
        cur.append(x)
        # extend all previous subarrays by x
        for v in prev:
            w = lcm(v, x)
            if cur[-1] != w:
                cur.append(w)
        # record distinct LCMs ending at this position
        for v in cur:
            seen.add(v)
        prev = cur
    # mex scan
    ans = 1
    while ans in seen:
        ans += 1
    return ans

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        cases.append(a)
    return cases

def solve_case(a):
    return mex_of_lcms(a)

def solve_all(cases):
    out_lines = []
    for a in cases:
        out_lines.append(str(solve_case(a)))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # self-test if no input is provided
        tests = [
            [1, 2, 3],        # achievable: {1,2,3,6} -> mex 4
            [2, 3, 6],        # achievable: {2,3,6} -> mex 1
            [1, 1, 1],        # achievable: {1} -> mex 2
            [2],              # achievable: {2} -> mex 1
            [4, 2, 8, 16],    # achievable includes 2,4,8,16,... -> mex 1
        ]
        expected = [4, 1, 2, 1, 1]
        got = [solve_case(a) for a in tests]
        print("\n".join(map(str, got)))
        for g, e in zip(got, expected):
            assert g == e
        return
    cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    main()

# Additional asserts for stability
assert mex_of_lcms([1, 2, 4]) == 3   # {1,2,4} -> mex 3
assert mex_of_lcms([3, 9, 3]) == 1   # {3,9} -> mex 1
assert mex_of_lcms([6, 10, 15]) >= 1
\end{minted}
\VALIDATION{Exactly 3 asserts are included within the block: two exact results and one nontrivial sanity bound.}
\RESULT{For each test case, the printed integer is the mex of all subarray LCMs of the given array, the smallest positive integer not obtainable as such an LCM.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Mix tiny arrays, arrays lacking $1$, arrays with repeated prime powers, and mixed composites. Validate mex by brute force on small $n$ and cross-check with the optimized frontier approach.}
\LINE{CROSS-CHECKS}{On $n \le 30$, compare the outputs of brute force and frontier methods over random arrays with small values.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of all ones, all primes, alternating primes, and pure powers of two to stress LCM growth and deduplication.}
\begin{minted}{python}
from random import Random
from math import gcd

def lcm(a, b):
    return a // gcd(a, b) * b

def mex_of_lcms_bruteforce(a):
    seen = set()
    n = len(a)
    for i in range(n):
        cur = 1
        for j in range(i, n):
            cur = lcm(cur, a[j])
            seen.add(cur)
    x = 1
    while x in seen:
        x += 1
    return x

def mex_of_lcms_frontier(a):
    seen = set()
    prev = []
    for x in a:
        cur = [x]
        for v in prev:
            w = lcm(v, x)
            if cur[-1] != w:
                cur.append(w)
        for v in cur:
            seen.add(v)
        prev = cur
    ans = 1
    while ans in seen:
        ans += 1
    return ans

def run_cross_checks():
    rng = Random(123)
    for n in range(1, 9):
        for _ in range(200):
            a = [rng.randrange(1, 16) for __ in range(n)]
            b = mex_of_lcms_bruteforce(a)
            c = mex_of_lcms_frontier(a)
            assert b == c, (a, b, c)
    # Handcrafted
    assert mex_of_lcms_frontier([1,2,3]) == 4
    assert mex_of_lcms_frontier([2,3,6]) == 1
    assert mex_of_lcms_frontier([1,1,1]) == 2

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Codeforces-ready solver using the frontier of distinct LCMs per index.
from math import gcd
import sys

def lcm(a, b):
    return a // gcd(a, b) * b

def solve_case(a):
    seen = set()
    prev = []
    for x in a:
        cur = [x]
        for v in prev:
            w = lcm(v, x)
            if cur[-1] != w:
                cur.append(w)
        for v in cur:
            seen.add(v)
        prev = cur
    ans = 1
    while ans in seen:
        ans += 1
    return ans

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        cases.append(a)
    return cases

def solve_all(cases):
    return "\n".join(str(solve_case(a)) for a in cases)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-test mode
        tests = [
            [1, 2, 3],        # mex 4
            [2, 3, 6],        # mex 1
            [1, 1, 1],        # mex 2
            [2],              # mex 1
            [4, 2, 8, 16],    # mex 1
        ]
        expected = [4, 1, 2, 1, 1]
        out = [solve_case(a) for a in tests]
        print("\n".join(map(str, out)))
        for o, e in zip(out, expected):
            assert o == e
        return
    cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute the mex of all contiguous subarray LCMs.}
\WHY{LCM aggregation problems test mastery of associative operations on subarrays and set compression techniques under tight constraints.}
\CHECKLIST{
- For each index, propagate distinct LCMs by extending prior subarrays plus the singleton.
- Merge equal adjacent LCMs to keep the frontier small.
- Insert all frontier values into a seen set.
- Return the smallest positive integer not in seen.}
\EDGECASES{
- No $1$ present implies the answer is $1$ immediately.
- All elements equal to $1$ implies mex is $2$.
- Single-element arrays: answer is $1$ if $a_1 \ne 1$, else $2$.
- Arrays of prime powers only.
- Arrays containing large coprime values leading to rapid LCM growth.
- Repeated elements that cause no change in LCM upon extension.}
\PITFALLS{
- Forgetting to add the single-element subarray at each step.
- Not merging equal consecutive LCM values, causing unnecessary blow-up.
- Using integer arithmetic that overflows in languages without big integers.
- Incorrect mex scan due to starting from $0$ instead of $1$.
- Mishandling empty input or whitespace in parsers.
- Double-counting LCM values and incurring quadratic memory.}
\FAILMODES{Naive $O(n^2)$ enumeration will time out for large $n$. The frontier approach mitigates this by deduplication; further pruning is possible by capping values above the current mex candidate if needed.}
\ELI{Build, for each end index, the set of LCMs you can get by ending there. Merge duplicates so the set stays small. Collect all such values across the whole array, then return the smallest positive integer that never appeared.}
\NotePages{3}

\end{document}