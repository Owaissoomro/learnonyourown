% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Shady Lady}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1045/F}}
\LINE{DIFFICULTY / RATING}{3400}
\STATEMENT{Ani and Borna are playing a short game on a two-variable polynomial. It is a special kind of a polynomial: the monomials are fixed, but all of its coefficients are fill-in-the-blanks dashes, e.g. $~\_~ xy + ~\_~ x^4 y^7 + ~\_~ x^8 y^3 + \ldots$

Borna will fill in the blanks with positive integers. He wants the polynomial to be bounded from below, i.e. his goal is to make sure there exists a real number $M$ such that the value of the polynomial at any point is greater than $M$.

Ani is mischievous, and wants the polynomial to be unbounded. Along with stealing Borna's heart, she can also steal parts of polynomials. Ani is only a petty kind of thief, though: she can only steal at most one monomial from the polynomial before Borna fills in the blanks.

If Ani and Borna play their only moves optimally, who wins?

Input:
The first line contains a positive integer $N$ $(2 \le N \le 200{,}000)$, denoting the number of the terms in the starting special polynomial.

Each of the following $N$ lines contains a description of a monomial: the $k$-th line contains two space-separated integers $a_k$ and $b_k$ $(0 \le a_k, b_k \le 10^9)$ which mean the starting polynomial has the term $~\_~ x^{a_k} y^{b_k}$. It is guaranteed that for $k \ne l$, either $a_k \ne a_l$ or $b_k \ne b_l$.

Output:
If Borna can always choose the coefficients such that the resulting polynomial is bounded from below, regardless of what monomial Ani steals, output ``Borna''. Else, output ``Ani''.

You should not output the quotation marks.

Note:
In the first sample, the initial polynomial is $~\_~xy+ ~\_~x^2 + ~\_~y^2$. If Ani steals the $~\_~y^2$ term, Borna is left with $~\_~xy+~\_~x^2$. Whatever positive integers are written on the blanks, $y \to -\infty$ and $x := 1$ makes the whole expression go to negative infinity.

In the second sample, the initial polynomial is $~\_~1 + ~\_~x + ~\_~x^2 + ~\_~x^8$. One can check that no matter what term Ani steals, Borna can always win.}
\BREAKDOWN{Reduce to geometry of exponent pairs $(a,b)$. Only the coordinate-wise maximal ``upper chain'' matters for growth in directions $(u,v)\in \mathbb{R}_{\ge 0}^2$. Signs depend on parity of $a$, $b$, and $a{+}b$ in three nontrivial quadrants. Robustness to deleting one monomial imposes redundancy constraints on each supporting face and on the two extreme exponents in $a$ and $b$.}
\ELI{Think of each term as a point. Along any direction to infinity, the ``top'' points on a certain edge dominate. To never go to $-\infty$, every such edge must contain at least two ``good'' (even-parity) points, and the two biggest $a$'s and two biggest $b$'s must be even as well.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integer $N$ with $2 \le N \le 200{,}000$.
- Then $N$ lines of integers $(a_k,b_k)$ with $0 \le a_k,b_k \le 10^9$, and all pairs distinct.}
\OUTPUTS{A single word: Borna if bounded from below is guaranteed regardless of deleting at most one monomial, else Ani.}
\SAMPLES{Example 1:
- Input: $N=3$; $(1,1)$, $(2,0)$, $(0,2)$. Output: Ani.

Example 2:
- Input: $N=4$; $(0,0)$, $(1,0)$, $(2,0)$, $(8,0)$. Output: Borna.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a finite set $S \subset \mathbb{Z}_{\ge 0}^2$ of exponent pairs $(a,b)$, consider polynomials $P(x,y)=\sum_{(a,b)\in S} c_{a,b} x^{a} y^{b}$ with all $c_{a,b}\in \mathbb{Z}_{>0}$. Ani removes at most one $(a,b)$ to obtain $S'$. Borna chooses $c_{a,b}>0$. Decide if for all single deletions $S'$ there exist $c_{a,b}>0$ such that $P$ is bounded from below on $\mathbb{R}^2$.}
\varmapStart
\var{(a,b)}{exponent pair}
\var{H}{upper coordinate-wise skyline (Pareto maxima) of $S$ sorted by $a$ increasing, $b$ decreasing}
\var{\text{runs}}{maximal collinear consecutive blocks along $H$ (supporting faces for normals in $\mathbb{R}_{\ge 0}^2$)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{For any }(u,v)\in\mathbb{R}_{\ge 0}^2,\ \max_{(a,b)\in S'}(au+bv)\text{ is attained on a face }F\subseteq H'.
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Sign in quadrant }(p,q)\in\{(1,0),(0,1),(1,1)\}\text{ is }(-1)^{ap+bq}.
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Bounded below}\iff \forall\text{ faces }F \text{ and }(p,q)\in\{(1,0),(0,1),(1,1)\},\ \exists (a,b)\in F:\ ap+bq\equiv 0\ (\mathrm{mod}\ 2).
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Robust to one deletion}\iff \text{if }|F|\ge 2:\ \#\{(a,b)\in F: ap{+}bq\equiv 0\}\ge 2,\ \text{and for extreme directions }u{=}0,v{=}0,\ \text{top two }b,a\text{ are even.}
\end{BreakableEquation*}
}
\ASSUMPTIONS{Only sign-quadrants with $(p,q)\in\{(1,0),(0,1),(1,1)\}$ are nontrivial (the $(0,0)$ quadrant is always nonnegative). Only the skyline $H$ matters for maxima with $(u,v)\ge 0$.}
\INVARIANTS{On $H$ the sequence has strictly increasing $a$ and strictly decreasing $b$. For any direction with $(u,v)\ge 0$, the maximizers lie on a consecutive block (a face) of $H$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all deletions and all quadrant directions by sampling many $(u,v)$ and checking sign-dominance.}
\ASSUMPTIONS{Finite sampling might approximate support faces.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each removal $p\in S\cup\{\varnothing\}$, form $S'$.
\item For a dense set of $(u,v)$, find maximizers $F$ of $au+bv$ in $S'$; for each $(p,q)$, require at least one even $ap+bq$.
\item If any $S'$ fails, output Ani; else Borna.
\end{algosteps}
\COMPLEXITY{Infeasible: combinatorial set of directions; exponential or pseudo-polynomial if discretized.}
\[
\begin{aligned}
T(N) &\approx O\!\left(N \cdot M \cdot \log N\right)\ \text{with huge }M\text{ (direction samples)}\\
\end{aligned}
\]
\CORRECTNESS{If sampling captured all normal cones exactly, it would be correct; but it cannot in finite time.}
\EDGECASES{Collinear blocks and extreme axes $(u=0)$, $(v=0)$ are easy to miss by sampling.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline placeholder demonstrating API; not used for final due to infeasibility.

import sys
from typing import List, Tuple

def read_input(data: str = None) -> List[Tuple[int, int]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return []
    pts = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it))
        pts.append((a, b))
    return pts

def solve_case(points: List[Tuple[int, int]]) -> str:
    # Always return "Ani" (unknown), since baseline is infeasible; keeps API.
    return "Ani"

def main():
    data = sys.stdin.read()
    if data.strip():
        pts = read_input(data)
        print(solve_case(pts))
    else:
        # Tiny sanity demo
        assert solve_case([(1,1),(2,0),(0,2)]) in ("Ani","Borna")
        print("Ani")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Only a stub; real validation deferred to improved/optimal solutions.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Skyline Reduction}
\WHICHFORMULA{Only coordinate-wise Pareto maxima (skyline) can be maximizers for $(u,v)\ge 0$. Reduce $S$ to the skyline $H$.}
\ASSUMPTIONS{Dominated points never maximize $au+bv$ for $(u,v)\ge 0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort by $a$ increasing; for equal $a$ keep the maximum $b$. Scan from right to left, keeping strictly increasing $b$ to form $H$.
\item Partition $H$ into maximal collinear consecutive runs (faces).
\item Naively test redundancy: require all points of $H$ to have even $a$ and even $b$; if any odd, output Ani.
\end{algosteps}
\COMPLEXITY{Sorting $O(N\log N)$; scan $O(N)$.}
\[
\begin{aligned}
T(N) &= O(N\log N),\quad S(N)=O(N).
\end{aligned}
\]
\CORRECTNESS{Necessary but not sufficient: misses the finer ``at least two even per face'' and axis top-2 constraints.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> List[Tuple[int, int]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return []
    pts = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it))
        pts.append((a, b))
    return pts

def skyline(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    # Dedup by a keeping max b
    best_by_a = {}
    for a, b in points:
        if a not in best_by_a or b > best_by_a[a]:
            best_by_a[a] = b
    arr = sorted(((a, b) for a, b in best_by_a.items()))
    # Keep Pareto maxima scanning from right: strictly increasing b
    H_rev = []
    maxb = -1
    for a, b in reversed(arr):
        if b > maxb:
            H_rev.append((a, b))
            maxb = b
    return list(reversed(H_rev))

def solve_case(points: List[Tuple[int, int]]) -> str:
    H = skyline(points)
    # Necessary but not sufficient: every convex-hull vertex must have even a and b.
    # Here we (over)require all H points to be even-even.
    for a, b in H:
        if (a & 1) or (b & 1):
            return "Ani"
    return "Borna"

def main():
    data = sys.stdin.read()
    if data.strip():
        pts = read_input(data)
        print(solve_case(pts))
    else:
        # Tests: xy + x^2 + y^2 -> Ani (since middle is odd, our overstrict rule flags Ani)
        assert solve_case([(1,1),(2,0),(0,2)]) == "Ani"
        # 1 + x + x^2 + x^8 -> Borna
        assert solve_case([(0,0),(1,0),(2,0),(8,0)]) == "Borna"
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Catches some failures but rejects many Borna cases; we need exact face and axis redundancy.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Upper Chain Faces + Parity Redundancy}
\WHICHFORMULA{Use the skyline $H$ (Pareto maxima). The only relevant faces are maximal collinear consecutive runs in $H$. Robustness to one deletion requires:
- For each face $F$ and each parity type $f\in\{a\bmod 2,\ b\bmod 2,\ (a{+}b)\bmod 2\}$, at least two $f$-even points in $F$.
- For axis directions $u{=}0$ and $v{=}0$: among all points, the largest two distinct $b$ (resp. $a$) must be even.}
\ASSUMPTIONS{After removing at most one monomial, new maximizers still lie on the original skyline or, on axes, may reveal a hidden tie at the same $a$ or $b$; we handle that by the top-two-by-$a$/$b$ check across all points.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $H$ (skyline) as in Approach B.
\item Partition $H$ into maximal collinear runs using cross products of consecutive edge vectors.
\item Vertex safety: endpoints of each run (the convex-hull vertices) must have even $a$ and even $b$ (else already unbounded).
\item Face redundancy: for every run of length $\ge 2$, count how many points have even $a$, even $b$, and even $a{+}b$; each count must be at least $2$ (else deletion can leave an all-odd-max face).
\item Axis redundancy: among all input points, let $A_{\max}$ be the maximum $a$; it must be even. If only one point has $a=A_{\max}$, then the second largest $a$ (if it exists) must be even too. Do the analogous check for $b$.
\item If all checks pass, answer Borna; otherwise Ani.
\end{algosteps}
\OPTIMALITY{This characterizes exactly when Ani can remove one monomial to expose a direction and quadrant whose maximizers all have negative sign. Faces cover all oblique directions; the axis top-two covers $u{=}0$ and $v{=}0$ where ties by $a$ or $b$ can be revealed after deletion.}
\COMPLEXITY{$O(N\log N)$ from sorting; linear passes otherwise.}
\[
\begin{aligned}
T(N) &= O(N\log N),\quad S(N)=O(N).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> List[Tuple[int, int]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return []
    pts = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it))
        pts.append((a, b))
    return pts

def skyline(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    # Dedup by a keeping max b
    best_by_a = {}
    for a, b in points:
        if a not in best_by_a or b > best_by_a[a]:
            best_by_a[a] = b
    arr = sorted(((a, b) for a, b in best_by_a.items()))
    # Keep Pareto maxima scanning from right: strictly increasing b
    H_rev = []
    maxb = -1
    for a, b in reversed(arr):
        if b > maxb:
            H_rev.append((a, b))
            maxb = b
    return list(reversed(H_rev))

def collinear_runs(H: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    m = len(H)
    if m <= 1:
        return []
    runs = []
    i = 0
    while i < m - 1:
        l = i
        dx1 = H[i+1][0] - H[i][0]
        dy1 = H[i+1][1] - H[i][1]
        i += 1
        while i < m - 1:
            dx2 = H[i+1][0] - H[i][0]
            dy2 = H[i+1][1] - H[i][1]
            # Cross with previous edge
            if dx1 * dy2 - dy1 * dx2 != 0:
                break
            i += 1
        r = i
        runs.append((l, r))
    return runs

def solve_case(points: List[Tuple[int, int]]) -> str:
    n = len(points)
    # Axis top-two checks across ALL points (not just skyline), using distinct a and b values logic.
    # For a:
    if n == 0:
        return "Borna"
    max_a = max(a for a, _ in points)
    if max_a & 1:
        return "Ani"
    cnt_max_a = sum(1 for a, _ in points if a == max_a)
    if cnt_max_a == 1:
        # Need next distinct a (if any) to be even
        second_a = -1
        for a, _ in points:
            if a < max_a and a > second_a:
                second_a = a
        if second_a >= 0 and (second_a & 1):
            return "Ani"
    # For b:
    max_b = max(b for _, b in points)
    if max_b & 1:
        return "Ani"
    cnt_max_b = sum(1 for _, b in points if b == max_b)
    if cnt_max_b == 1:
        second_b = -1
        for _, b in points:
            if b < max_b and b > second_b:
                second_b = b
        if second_b >= 0 and (second_b & 1):
            return "Ani"

    # Build skyline H
    H = skyline(points)
    m = len(H)
    # Single point case: that one must be even-even (after removal polynomial can be zero).
    if m == 1:
        a, b = H[0]
        return "Borna" if ((a & 1) == 0 and (b & 1) == 0) else "Ani"

    # Collinear runs (faces)
    runs = collinear_runs(H)

    # Collect convex-hull vertices: endpoints of runs.
    vertices = set()
    for l, r in runs:
        vertices.add(l); vertices.add(r)
    # Safety at vertices: even a and even b
    for idx in vertices:
        a, b = H[idx]
        if (a & 1) or (b & 1):
            return "Ani"

    # Face redundancy: for each run, at least two even for each parity type
    for l, r in runs:
        cnt_a_even = 0
        cnt_b_even = 0
        cnt_s_even = 0
        for i in range(l, r + 1):
            a, b = H[i]
            if (a & 1) == 0:
                cnt_a_even += 1
            if (b & 1) == 0:
                cnt_b_even += 1
            if ((a + b) & 1) == 0:
                cnt_s_even += 1
        if cnt_a_even < 2 or cnt_b_even < 2 or cnt_s_even < 2:
            return "Ani"

    return "Borna"

def main():
    data = sys.stdin.read()
    if data.strip():
        pts = read_input(data)
        print(solve_case(pts))
    else:
        # Exactly 3 asserts
        # 1) From note: xy + x^2 + y^2 -> Ani
        assert solve_case([(1,1),(2,0),(0,2)]) == "Ani"
        # 2) Univariate even-heavy: 1 + x + x^2 + x^8 -> Borna
        assert solve_case([(0,0),(1,0),(2,0),(8,0)]) == "Borna"
        # 3) Single monomial even-even -> Borna; odd-any -> Ani
        assert solve_case([(4,6)]) == "Borna"
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts:
- $(1,1),(2,0),(0,2) \to$ Ani.
- $(0,0),(1,0),(2,0),(8,0) \to$ Borna.
- Single $(4,6) \to$ Borna.}
\RESULT{Output Borna if and only if every maximal face on the skyline has at least two even-parity points for each of $a$, $b$, and $a{+}b$, and the two largest distinct $a$ and $b$ (over all points) are even. Otherwise Ani.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test skyline construction; face detection; parity counts; axis top-two logic. Use crafted sets: fully collinear, mixed slopes, duplicates in $a$/$b$, extremes with unique/max duplicate.}
\LINE{CROSS-CHECKS}{Compare decisions between the Improved vs Optimal solvers on random small sets; the Improved should be a subset of Borna cases marked by Optimal.}
\LINE{EDGE-CASE GENERATOR}{Generate random $S$ with small $a,b\in[0,6]$, add duplicates of $a$ or $b$, and verify consistency.}
\begin{minted}{python}
import random

def gen_cases(K=200, A=6, B=6):
    cases = []
    for _ in range(K):
        n = random.randint(1, min(10, (A+1)*(B+1)))
        pts = set()
        while len(pts) < n:
            pts.add((random.randint(0,A), random.randint(0,B)))
        cases.append(list(pts))
    return cases

def reference(points):
    # Use the final solve_case as reference here.
    return solve_case(points)

def quick_check():
    for pts in gen_cases():
        _ = reference(pts)
    return True

if __name__ == "__main__":
    assert quick_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str = None) -> List[Tuple[int, int]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return []
    pts = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it))
        pts.append((a, b))
    return pts

def skyline(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    best_by_a = {}
    for a, b in points:
        if a not in best_by_a or b > best_by_a[a]:
            best_by_a[a] = b
    arr = sorted(((a, b) for a, b in best_by_a.items()))
    H_rev = []
    maxb = -1
    for a, b in reversed(arr):
        if b > maxb:
            H_rev.append((a, b))
            maxb = b
    return list(reversed(H_rev))

def collinear_runs(H: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    m = len(H)
    if m <= 1:
        return []
    runs = []
    i = 0
    while i < m - 1:
        l = i
        dx1 = H[i+1][0] - H[i][0]
        dy1 = H[i+1][1] - H[i][1]
        i += 1
        while i < m - 1:
            dx2 = H[i+1][0] - H[i][0]
            dy2 = H[i+1][1] - H[i][1]
            if dx1 * dy2 - dy1 * dx2 != 0:
                break
            i += 1
        r = i
        runs.append((l, r))
    return runs

def solve_case(points: List[Tuple[int, int]]) -> str:
    n = len(points)
    if n == 0:
        return "Borna"
    # Axis top-two by a
    max_a = max(a for a, _ in points)
    if max_a & 1:
        return "Ani"
    cnt_max_a = sum(1 for a, _ in points if a == max_a)
    if cnt_max_a == 1:
        second_a = -1
        for a, _ in points:
            if a < max_a and a > second_a:
                second_a = a
        if second_a >= 0 and (second_a & 1):
            return "Ani"
    # Axis top-two by b
    max_b = max(b for _, b in points)
    if max_b & 1:
        return "Ani"
    cnt_max_b = sum(1 for _, b in points if b == max_b)
    if cnt_max_b == 1:
        second_b = -1
        for _, b in points:
            if b < max_b and b > second_b:
                second_b = b
        if second_b >= 0 and (second_b & 1):
            return "Ani"

    H = skyline(points)
    m = len(H)
    if m == 1:
        a, b = H[0]
        return "Borna" if ((a & 1) == 0 and (b & 1) == 0) else "Ani"

    runs = collinear_runs(H)

    vertices = set()
    for l, r in runs:
        vertices.add(l); vertices.add(r)

    for idx in vertices:
        a, b = H[idx]
        if (a & 1) or (b & 1):
            return "Ani"

    for l, r in runs:
        cnt_a_even = cnt_b_even = cnt_s_even = 0
        for i in range(l, r + 1):
            a, b = H[i]
            if (a & 1) == 0:
                cnt_a_even += 1
            if (b & 1) == 0:
                cnt_b_even += 1
            if ((a + b) & 1) == 0:
                cnt_s_even += 1
        if cnt_a_even < 2 or cnt_b_even < 2 or cnt_s_even < 2:
            return "Ani"

    return "Borna"

def main():
    data = sys.stdin.read()
    if data.strip():
        pts = read_input(data)
        print(solve_case(pts))
    else:
        # Self-checks
        assert solve_case([(1,1),(2,0),(0,2)]) == "Ani"
        assert solve_case([(0,0),(1,0),(2,0),(8,0)]) == "Borna"
        assert solve_case([(4,6)]) == "Borna"
        print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to the skyline of exponent pairs and enforce parity redundancy on each supporting face plus axis top-two evenness.}
\WHY{This captures all directions $(u,v)\ge 0$ (faces) and deletions that can expose new axis leaders (duplicates by $a$ or $b$).}
\CHECKLIST{
- Build skyline $H$ (unique max $b$ per $a$, then Pareto scan).
- Partition $H$ into maximal collinear runs (faces).
- Endpoints of runs: $a$ even and $b$ even.
- Each run: at least two even for $a$, for $b$, and for $a{+}b$.
- Axis: largest $a$ even; if unique, second-largest $a$ even. Same for $b$.}
\EDGECASES{
- Many points with same $a$ or same $b$.
- Entire skyline collinear (one big face).
- Only one skyline point.
- Very large coordinates; use 64-bit cross products.
- Input size up to $200{,}000$; $O(N\log N)$ only.}
\PITFALLS{
- Forgetting to keep only max $b$ per equal $a$ for skyline build.
- Missing axis second-largest parity when top is unique.
- Treating interior collinear points as convex vertices (they are not).
- Cross product overflow if using 32-bit.
- Off-by-one when forming runs; ensure maximality.}
\FAILMODES{Sampling directions or using full convex hull (not skyline) is overkill and can miss axis exposures. The presented method is robust to any single deletion.}
\ELI{Only the ``top edge'' of exponent points matters when going to infinity. In each relevant direction, you need at least two even-signed leaders so that deleting one cannot flip the sign. On the pure $x$- or $y$-axes, the top two exponents in that variable must be even as well.}
\NotePages{3}

\end{document}