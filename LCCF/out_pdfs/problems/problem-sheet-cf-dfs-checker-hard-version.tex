% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — DFS Checker (Hard Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2002/D2}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{This is the hard version of the problem. In this version, you are given a generic tree and the constraints on $n$ and $q$ are higher. You can make hacks only if both versions of the problem are solved.

You are given a rooted tree consisting of $n$ vertices. The vertices are numbered from $1$ to $n$, and the root is the vertex $1$. You are also given a permutation $p_1, p_2, \ldots, p_n$ of $[1,2,\ldots,n]$.

You need to answer $q$ queries. For each query, you are given two integers $x$, $y$; you need to swap $p_x$ and $p_y$ and determine if $p_1, p_2, \ldots, p_n$ is a valid DFS order$^\dagger$ of the given tree.

Please note that the swaps are persistent through queries.

$^\dagger$ A DFS order is found by calling the following $\texttt{dfs}$ function on the given tree.

Note that the DFS order is not unique.

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1\le t\le 10^4$). The description of the test cases follows.

The first line of each test case contains two integers $n$, $q$ ($2\le n\le 3\cdot 10^5$, $2\le q\le 10^5$) — the number of vertices in the tree and the number of queries.

The next line contains $n-1$ integers $a_2,a_3,\ldots,a_n$ ($1\le a_i<i$) — the parent of each vertex in the given tree.

The next line contains $n$ integers $p_1,p_2,\ldots,p_n$ ($1\le p_i\le n$, all $p_i$ are distinct) — the initial permutation $p$.

The next $q$ lines each contain two integers $x$, $y$ ($1\le x,y\le n, x\ne y$) — the positions of the elements to swap in the permutation.

It is guaranteed that the sum of all $n$ does not exceed $3\cdot 10^5$, and the sum of all $q$ does not exceed $10^5$.

Output:
For each test case, print $q$ lines corresponding to the $q$ queries. For each query, output $\texttt{YES}$ if there is a DFS order that exactly equals the current permutation, and output $\texttt{NO}$ otherwise.

You can output $\texttt{Yes}$ and $\texttt{No}$ in any case (for example, strings $\texttt{yEs}$, $\texttt{yes}$, $\texttt{Yes}$, and $\texttt{YES}$ will be recognized as a positive response).

Note:
In the first test case, the permutation $p_1, p_2, \ldots, p_n$ after each modification is $[1,3,2],[1,2,3],[3,2,1]$, respectively. The first two permutations are valid DFS orders; the third is not a DFS order.

In the second test case, the permutation $p_1, p_2, \ldots, p_n$ after each modification is $[1,2,5,4,3,6,7],[1,3,5,4,2,6,7],[1,3,7,4,2,6,5],[1,3,7,6,2,4,5]$, respectively.}
\BREAKDOWN{We must dynamically maintain whether a permutation equals some preorder DFS traversal of a fixed rooted tree under arbitrary child-order choices, after swapping two positions per query. Characterize valid preorders and update only local constraints affected by a swap.}
\ELI{A sequence is a valid DFS preorder iff first is the root and every consecutive pair $(u,v)$ satisfies $\mathrm{lca}(u,v)=\mathrm{parent}(v)$; swapping two positions only affects a constant number of such adjacent checks.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test:
- Integers $n,q$ with $2\le n\le 3\cdot 10^5$, $2\le q\le 10^5$.
- Parent list $a_2,\ldots,a_n$ with $1\le a_i<i$, defining edges $(a_i,i)$; root is $1$.
- Permutation $p_1,\ldots,p_n$ of $[1..n]$.
- Then $q$ lines: pairs $x,y$ with $1\le x,y\le n$, $x\ne y$. Swaps are persistent. Sums: $\sum n\le 3\cdot 10^5$, $\sum q\le 10^5$.}
\OUTPUTS{For each query, print a single line: $\texttt{YES}$ if the current $p$ is a DFS preorder of the tree, otherwise $\texttt{NO}$.}
\SAMPLES{Example 1, consistent with notes:
- $n=3$, edges $1\to 2$, $1\to 3$. Start $p=[1,2,3]$. Queries: swap $(2,3)$, then $(2,3)$, then $(1,3)$.
- Outputs: YES, YES, NO.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a rooted tree at $1$. Let $p=(p_1,\ldots,p_n)$ be a permutation. Define $\mathrm{par}(v)$ for $v\ne 1$ and $\mathrm{depth}(v)$. Let $\mathrm{lca}(u,v)$ be the lowest common ancestor under root $1$. Predicate: $p$ is a valid DFS preorder iff $p_1=1$ and for all $i\in[1,n-1]$, $\mathrm{lca}(p_i,p_{i+1})=\mathrm{par}(p_{i+1})$.}
\varmapStart
\var{n}{number of vertices}
\var{q}{number of queries}
\var{p_i}{value at position $i$ in current permutation}
\var{\mathrm{par}(v)}{parent of vertex $v$ in $T$ (with $\mathrm{par}(1)=0$)}
\var{\mathrm{lca}(u,v)}{lowest common ancestor of $u$ and $v$}
\var{b_i}{indicator that pair $(p_i,p_{i+1})$ violates the condition}
\var{B}{total violations: $B=\mathbf{1}[p_1\ne 1]+\sum_{i=1}^{n-1} b_i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{$p$ is DFS preorder} \iff \left(p_1=1\right)\ \land\ \bigwedge_{i=1}^{n-1}\left(\mathrm{lca}(p_i,p_{i+1})=\mathrm{par}(p_{i+1})\right).
\end{aligned}
\]
}
\ASSUMPTIONS{Tree is connected, rooted at $1$. $\mathrm{lca}$ is computed via binary lifting with $O(\log n)$ per query. Swaps are persistent and only affect local adjacency checks at indices $x-1,x,y-1,y$.}
\INVARIANTS{ 
- The parent array $\mathrm{par}(\cdot)$ and binary lifting table remain fixed across queries.
- $B=0$ iff current permutation is a valid DFS preorder.
- Only $b_{x-1},b_x,b_{y-1},b_y$ and the root check can change after swapping positions $x$ and $y$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the direct DFS-preorder characterization: $p_1=1$ and $\forall i$ $\mathrm{lca}(p_i,p_{i+1})=\mathrm{par}(p_{i+1})$. After each swap, rescan all adjacent pairs.}
\ASSUMPTIONS{Efficient $\mathrm{lca}$ queries via binary lifting; rescanning $n-1$ pairs per query is acceptable only for very small $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\mathrm{par}$, $\mathrm{depth}$, and binary lifting table $\text{up}[k][v]$.
\item For each query $(x,y)$: swap $p_x$ and $p_y$.
\item Check $p_1=1$ and for all $i=1..n-1$ verify $\mathrm{lca}(p_i,p_{i+1})=\mathrm{par}(p_{i+1})$. Print YES iff all pass.
\end{algosteps}
\COMPLEXITY{Per test: preprocess $O(n\log n)$. Per query: $O(n\log n)$ with binary lifting LCA.}
\[
\begin{aligned}
T_{\text{pre}}(n) &= O(n\log n),\\
T_{\text{query}}(n) &= O(n\log n),\quad S(n)=O(n\log n).
\end{aligned}
\]
\CORRECTNESS{The check is exactly the necessary and sufficient condition for preorder DFS sequences under arbitrary child orders.}
\EDGECASES{Ensure $p_1=1$; handle adjacent swaps; handle indices at boundaries so that only valid adjacent pairs are inspected.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        par = [0]*(n+1)
        for v in range(2, n+1):
            par[v] = int(next(it))
        p = [0]*(n+1)
        for i in range(1, n+1):
            p[i] = int(next(it))
        qs = []
        for _ in range(q):
            x = int(next(it)); y = int(next(it))
            qs.append((x, y))
        tests.append((n, q, par, p, qs))
    return tests

def build_lca(n: int, parents: List[int], adj: List[List[int]]):
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    par = [0]*(n+1)
    # root is 1
    par[1] = 0
    depth[1] = 0
    stack = [1]
    order = [1]
    seen = [False]*(n+1)
    seen[1] = True
    while stack:
        u = stack.pop()
        for v in adj[u]:
            if not seen[v]:
                seen[v] = True
                par[v] = u
                depth[v] = depth[u] + 1
                stack.append(v)
                order.append(v)
    for v in range(1, n+1):
        up[0][v] = par[v]
    for k in range(1, LOG):
        for v in range(1, n+1):
            up[k][v] = up[k-1][ up[k-1][v] ] if up[k-1][v] != 0 else 0
    def lca(a: int, b: int) -> int:
        if a == 0 or b == 0:
            return a ^ b
        if depth[a] < depth[b]:
            a, b = b, a
        da = depth[a]; db = depth[b]
        diff = da - db
        k = 0
        while diff:
            if diff & 1:
                a = up[k][a]
            diff >>= 1; k += 1
        if a == b:
            return a
        for k in range(LOG-1, -1, -1):
            if up[k][a] != up[k][b]:
                a = up[k][a]; b = up[k][b]
        return up[0][a]
    return par, depth, up, lca

def is_dfs_preorder(p: List[int], par: List[int], lca_func) -> bool:
    n = len(p)-1
    if p[1] != 1:
        return False
    for i in range(1, n):
        u = p[i]; v = p[i+1]
        if lca_func(u, v) != par[v]:
            return False
    return True

def solve_all():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    it = iter(data)
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        parents = [0]*(n+1)
        adj = [[] for _ in range(n+1)]
        for v in range(2, n+1):
            parents[v] = int(next(it))
            adj[parents[v]].append(v)
            adj[v].append(parents[v])
        p = [0]*(n+1)
        for i in range(1, n+1):
            p[i] = int(next(it))
        queries = [(int(next(it)), int(next(it))) for __ in range(q)]
        par, depth, up, lca = build_lca(n, parents, adj)
        for (x, y) in queries:
            p[x], p[y] = p[y], p[x]
            out_lines.append("YES" if is_dfs_preorder(p, par, lca) else "NO")
    sys.stdout.write("\n".join(out_lines))

def _small_unit():
    # Simple tree: 1-2, 1-3
    n = 3
    adj = [[] for _ in range(n+1)]
    parents = [0,0,1,1]
    adj[1] = [2,3]; adj[2] = [1]; adj[3] = [1]
    par, depth, up, lca = build_lca(n, parents, adj)
    p = [0,1,2,3]
    assert is_dfs_preorder(p, par, lca)
    p = [0,1,3,2]
    assert is_dfs_preorder(p, par, lca)
    p = [0,3,2,1]
    assert not is_dfs_preorder(p, par, lca)

if __name__ == "__main__":
    _small_unit()
    # Do not run solve_all() during unit test; it will run on judge.
    # But to ensure API, we leave it callable.
    # Uncomment next line to run locally:
    # solve_all()
\end{minted}
\VALIDATION{Tiny asserts in code verify the characterization on a 3-node tree.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Maintain only local adjacency violations $b_i$ and a root check. Swapping positions $x,y$ can only change $b_{x-1},b_x,b_{y-1},b_y$ and whether $p_1=1$. Maintain a running sum of violations $B$.}
\ASSUMPTIONS{Binary lifting supports $\mathrm{lca}$ in $O(\log n)$. Each update touches $O(1)$ adjacent pairs for $O(\log n)$ total time per query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\mathrm{par}$, depths, and $\mathrm{lca}$.
\item Initialize $b_i=\mathbf{1}[\mathrm{lca}(p_i,p_{i+1})\ne \mathrm{par}(p_{i+1})]$ for $i=1..n-1$ and $b_{\text{root}}=\mathbf{1}[p_1\ne 1]$; set $B=b_{\text{root}}+\sum b_i$.
\item For each swap $(x,y)$:
\begin{bullets}
\item Let $S=\{i\in\{x-1,x,y-1,y\}\mid 1\le i\le n-1\}$.
\item Subtract old $b_i$ for $i\in S$ from $B$; swap $p_x,p_y$; recompute $b_i$ for $i\in S$; add to $B$.
\item Update $b_{\text{root}}$ similarly using $p_1$ and adjust $B$.
\end{bullets}
\item Answer YES iff $B=0$.
\end{algosteps}
\COMPLEXITY{Initialization $O(n\log n)$; each query $O(\log n)$ for a constant number of $\mathrm{lca}$ calls.}
\[
\begin{aligned}
T_{\text{pre}}(n) &= O(n\log n),\\
T_{\text{query}}(n) &=
O(\log n)\ \text{(constant many LCA calls)},\quad S(n)=O(n\log n).
\end{aligned}
\]
\CORRECTNESS{By the DFS characterization, $B=0$ iff the permutation is a valid DFS preorder. Swapping only changes adjacency relationships at boundaries touching $x$ and $y$, so maintaining the sum of violations is sufficient and necessary.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List

def read_input():
    return sys.stdin.read()

def build_adj(n: int, parents: List[int]) -> List[List[int]]:
    adj = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        p = parents[v]
        adj[p].append(v)
        adj[v].append(p)
    return adj

def build_lca(n: int, parents: List[int], adj: List[List[int]]):
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    par = [0]*(n+1)
    # Iterative DFS to avoid recursion limit
    par[1] = 0
    depth[1] = 0
    stack = [1]
    seen = [False]*(n+1)
    seen[1] = True
    order = [1]
    while stack:
        u = stack.pop()
        for v in adj[u]:
            if not seen[v]:
                seen[v] = True
                par[v] = u
                depth[v] = depth[u] + 1
                stack.append(v)
                order.append(v)
    for v in range(1, n+1):
        up[0][v] = par[v]
    for k in range(1, LOG):
        rowk = up[k]
        rowkm1 = up[k-1]
        for v in range(1, n+1):
            mid = rowkm1[v]
            rowk[v] = rowkm1[mid] if mid != 0 else 0
    def lca(a: int, b: int) -> int:
        if a == b:
            return a
        if depth[a] < depth[b]:
            a, b = b, a
        diff = depth[a] - depth[b]
        k = 0
        while diff:
            if diff & 1:
                a = up[k][a]
            diff >>= 1; k += 1
        if a == b:
            return a
        for k in range(LOG-1, -1, -1):
            if up[k][a] != up[k][b]:
                a = up[k][a]
                b = up[k][b]
        return up[0][a]
    return par, depth, up, lca

def solve_all():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    it = iter(data)
    t = int(next(it))
    out = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        parents = [0]*(n+1)
        for v in range(2, n+1):
            parents[v] = int(next(it))
        adj = build_adj(n, parents)
        par, depth, up, lca = build_lca(n, parents, adj)
        p = [0]*(n+1)
        for i in range(1, n+1):
            p[i] = int(next(it))
        # Initialize bad array
        n_pairs = n-1
        bad = [0]*(n)  # use indices 1..n-1
        def pair_bad(i: int) -> int:
            u = p[i]; v = p[i+1]
            return 0 if lca(u, v) == par[v] else 1
        total_bad = 0
        for i in range(1, n):
            bad[i] = pair_bad(i)
            total_bad += bad[i]
        bad_root = 1 if p[1] != 1 else 0
        total_bad += bad_root
        for __ in range(q):
            x = int(next(it)); y = int(next(it))
            # collect affected indices
            idx = set()
            for k in (x-1, x, y-1, y):
                if 1 <= k <= n-1:
                    idx.add(k)
            # subtract old contributions
            for k in idx:
                total_bad -= bad[k]
            total_bad -= bad_root
            # perform swap
            p[x], p[y] = p[y], p[x]
            # recompute affected
            for k in idx:
                bad[k] = pair_bad(k)
                total_bad += bad[k]
            bad_root = 1 if p[1] != 1 else 0
            total_bad += bad_root
            out.append("YES" if total_bad == 0 else "NO")
    sys.stdout.write("\n".join(out))

def _asserts():
    # Basic characterization equivalence check on small trees
    def check_seq(adj, par, p):
        # naive O(n log n) verify: we'll embed small lca here
        n = len(p)-1
        # build lca
        parents = par
        from collections import deque
        depth = [0]* (n+1)
        LOG = (n+1).bit_length()
        up = [[0]*(n+1) for _ in range(LOG)]
        order = []
        seen = [False]*(n+1)
        dq = deque([1])
        seen[1] = True
        while dq:
            u = dq.popleft()
            order.append(u)
            for v in adj[u]:
                if not seen[v]:
                    seen[v] = True
                    depth[v] = depth[u]+1
                    up[0][v] = u
                    dq.append(v)
        for k in range(1, LOG):
            for v in range(1, n+1):
                mid = up[k-1][v]
                up[k][v] = up[k-1][mid] if mid != 0 else 0
        def lca(a,b):
            if depth[a] < depth[b]:
                a,b = b,a
            diff = depth[a]-depth[b]
            k=0
            while diff:
                if diff&1: a = up[k][a]
                diff >>= 1; k+=1
            if a==b: return a
            for k in range(LOG-1,-1,-1):
                if up[k][a] != up[k][b]:
                    a = up[k][a]; b = up[k][b]
            return up[0][a]
        if p[1] != 1: return False
        for i in range(1, n):
            if lca(p[i], p[i+1]) != parents[p[i+1]]:
                return False
        return True
    # Tree: 1-2,1-3, 2-4
    n = 4
    adj = [[] for _ in range(n+1)]
    par = [0,0,1,1,2]
    for v in range(2, n+1):
        u = par[v]
        adj[u].append(v); adj[v].append(u)
    assert check_seq(adj, par, [0,1,2,4,3])  # preorder 1,2,4,3
    assert check_seq(adj, par, [0,1,3,2,4])  # preorder 1,3,2,4
    assert not check_seq(adj, par, [0,1,4,2,3])  # 4 cannot come before its parent

if __name__ == "__main__":
    _asserts()
    # Ready for judge:
    # solve_all()
\end{minted}
\VALIDATION{Checks ensure sequences violating parent-before-child or adjacency LCA constraints are rejected.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Maintain the sum of local violations and the root check; answer YES iff the sum is $0$. Use binary lifting for $\mathrm{lca}$ to keep updates $O(\log n)$, which is optimal here given input sizes and Python constraints.}
\ASSUMPTIONS{Root is fixed at $1$. The DFS-preorder characterization via adjacent pairs and LCA is necessary and sufficient.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $\mathrm{par}$ and $\mathrm{lca}$ with binary lifting.
\item Initialize $b_i$ and $B$ as in Approach B.
\item For each swap $(x,y)$, recompute only indices in $\{x-1,x,y-1,y\}\cap[1,n-1]$ and the root check; update $B$.
\item Output YES iff $B=0$.
\end{algosteps}
\OPTIMALITY{Any solution must at least observe the elements involved in the swap and their adjacent boundaries. Only a constant number of LCA computations per query are necessary; precomputation is linearithmic.}
\COMPLEXITY{Same as Approach B.}
\[
\begin{aligned}
T_{\text{pre}}(n) &= O(n\log n),\quad T_{\text{per-swap}} = O(\log n),\quad S(n)=O(n\log n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List

def read_input():
    return sys.stdin.read()

def build_adj(n: int, parents: List[int]) -> List[List[int]]:
    adj = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        p = parents[v]
        adj[p].append(v)
        adj[v].append(p)
    return adj

def build_lca(n: int, parents: List[int], adj: List[List[int]]):
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    par = [0]*(n+1)
    # Iterative DFS stack
    stack = [1]
    seen = [False]*(n+1)
    seen[1] = True
    par[1] = 0
    depth[1] = 0
    while stack:
        u = stack.pop()
        for v in adj[u]:
            if not seen[v]:
                seen[v] = True
                par[v] = u
                depth[v] = depth[u] + 1
                stack.append(v)
    for v in range(1, n+1):
        up[0][v] = par[v]
    for k in range(1, LOG):
        rowk = up[k]; rowkm1 = up[k-1]
        for v in range(1, n+1):
            mid = rowkm1[v]
            rowk[v] = rowkm1[mid] if mid != 0 else 0
    def lca(a: int, b: int) -> int:
        if a == b:
            return a
        if depth[a] < depth[b]:
            a, b = b, a
        diff = depth[a] - depth[b]
        k = 0
        while diff:
            if diff & 1:
                a = up[k][a]
            diff >>= 1; k += 1
        if a == b:
            return a
        for k in range(LOG-1, -1, -1):
            if up[k][a] != up[k][b]:
                a = up[k][a]
                b = up[k][b]
        return up[0][a]
    return par, depth, up, lca

def solve_all():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    it = iter(data)
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        parents = [0]*(n+1)
        for v in range(2, n+1):
            parents[v] = int(next(it))
        adj = build_adj(n, parents)
        par, depth, up, lca = build_lca(n, parents, adj)
        p = [0]*(n+1)
        for i in range(1, n+1):
            p[i] = int(next(it))
        bad = [0]* (n)  # indices 1..n-1
        def pair_bad(i: int) -> int:
            u = p[i]; v = p[i+1]
            return 0 if lca(u, v) == par[v] else 1
        total_bad = 0
        for i in range(1, n):
            bad[i] = pair_bad(i)
            total_bad += bad[i]
        bad_root = 1 if p[1] != 1 else 0
        total_bad += bad_root
        for __ in range(q):
            x = int(next(it)); y = int(next(it))
            idx = set()
            for k in (x-1, x, y-1, y):
                if 1 <= k <= n-1:
                    idx.add(k)
            for k in idx:
                total_bad -= bad[k]
            total_bad -= bad_root
            p[x], p[y] = p[y], p[x]
            for k in idx:
                bad[k] = pair_bad(k)
                total_bad += bad[k]
            bad_root = 1 if p[1] != 1 else 0
            total_bad += bad_root
            out_lines.append("YES" if total_bad == 0 else "NO")
    sys.stdout.write("\n".join(out_lines))

def _tests():
    # Basic deterministic mini-tests
    # Test 1: Star centered at 1
    n = 5
    parents = [0,0,1,1,1,1]
    adj = build_adj(n, parents)
    par, depth, up, lca = build_lca(n, parents, adj)
    def is_ok(p):
        if p[1] != 1: return False
        for i in range(1, n):
            if lca(p[i], p[i+1]) != par[p[i+1]]:
                return False
        return True
    assert is_ok([0,1,2,3,4,5])
    assert is_ok([0,1,5,4,3,2])
    assert not is_ok([0,2,1,3,4,5])  # root must be first
    # Test 2: Chain 1-2-3-4
    n2 = 4
    parents2 = [0,0,1,2,3]
    adj2 = build_adj(n2, parents2)
    par2, depth2, up2, lca2 = build_lca(n2, parents2, adj2)
    def is_ok2(p):
        if p[1] != 1: return False
        for i in range(1, n2):
            if lca2(p[i], p[i+1]) != par2[p[i+1]]:
                return False
        return True
    assert is_ok2([0,1,2,3,4])
    assert not is_ok2([0,1,3,2,4])

if __name__ == "__main__":
    _tests()
    # Ready for judge
    # solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts or I/O mini-tests are embedded in the helper tests to check root-first, star, and chain cases.}
\RESULT{For each query, output YES iff the current permutation is a DFS preorder (root first and adjacent LCA condition holds); otherwise NO. Ties or multiple valid DFS orders are irrelevant because we check equality with the given permutation.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small trees: stars, chains, and small binaries. Randomized small cases comparing baseline vs. improved methods.}
\LINE{CROSS-CHECKS}{For small $n$ generate random trees and random permutations; verify the characterization against a simulated DFS with all child-order permutations for tiny sizes, and ensure Approach B/C outputs match Approach A.}
\LINE{EDGE-CASE GENERATOR}{Produce trees of size $n\in\{2,3,4,5,6,7\}$ including stars and chains; generate swap queries that hit boundaries (positions $1$ and $n$) and adjacent pairs ($x=y\pm 1$ disallowed but adjacent cases tested).}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_tree_star(n: int) -> List[int]:
    return [0] + [0] + [1]*(n-1)

def gen_tree_chain(n: int) -> List[int]:
    par = [0]*(n+1)
    for v in range(2, n+1):
        par[v] = v-1
    return par

def gen_random_tree(n: int, seed: int = 42) -> List[int]:
    random.seed(seed)
    par = [0]*(n+1)
    for v in range(2, n+1):
        par[v] = random.randint(1, v-1)
    return par

def run_cross_check():
    # Compare baseline vs improved on small instances
    import sys

    def build_adj(n, parents):
        adj = [[] for _ in range(n+1)]
        for v in range(2, n+1):
            p = parents[v]
            adj[p].append(v)
            adj[v].append(p)
        return adj

    def build_lca(n, parents, adj):
        LOG = (n+1).bit_length()
        up = [[0]*(n+1) for _ in range(LOG)]
        depth = [0]*(n+1)
        par = [0]*(n+1)
        stack = [1]
        seen = [False]*(n+1)
        seen[1] = True
        while stack:
            u = stack.pop()
            for v in adj[u]:
                if not seen[v]:
                    seen[v] = True
                    par[v] = u
                    depth[v] = depth[u] + 1
                    stack.append(v)
        for v in range(1, n+1):
            up[0][v] = par[v]
        for k in range(1, LOG):
            for v in range(1, n+1):
                mid = up[k-1][v]
                up[k][v] = up[k-1][mid] if mid != 0 else 0
        def lca(a, b):
            if a == b: return a
            if depth[a] < depth[b]:
                a, b = b, a
            diff = depth[a] - depth[b]
            k = 0
            while diff:
                if diff & 1:
                    a = up[k][a]
                diff >>= 1; k += 1
            if a == b:
                return a
            for k in range(LOG-1, -1, -1):
                if up[k][a] != up[k][b]:
                    a = up[k][a]; b = up[k][b]
            return up[0][a]
        return par, depth, up, lca

    def is_dfs_preorder(p, par, lca):
        n = len(p)-1
        if p[1] != 1: return False
        for i in range(1, n):
            if lca(p[i], p[i+1]) != par[p[i+1]]:
                return False
        return True

    for n in range(2, 8):
        for seed in range(3):
            parents = gen_random_tree(n, seed=seed)
            adj = build_adj(n, parents)
            par, depth, up, lca = build_lca(n, parents, adj)
            # start with identity perm
            p = [0] + list(range(1, n+1))
            # perform swaps and compare baseline vs incremental updates
            bad = [0]*(n)
            def pair_bad(i):
                return 0 if lca(p[i], p[i+1]) == par[p[i+1]] else 1
            total_bad = 0
            for i in range(1, n):
                bad[i] = pair_bad(i)
                total_bad += bad[i]
            bad_root = 1 if p[1] != 1 else 0
            total_bad += bad_root
            def inc_answer():
                return total_bad == 0
            for x in range(1, n+1):
                for y in range(1, n+1):
                    if x == y: continue
                    idx = set()
                    for k in (x-1, x, y-1, y):
                        if 1 <= k <= n-1: idx.add(k)
                    # remove
                    sTB = total_bad
                    for k in idx: sTB -= bad[k]
                    sTB -= bad_root
                    p[x], p[y] = p[y], p[x]
                    for k in idx:
                        bad[k] = pair_bad(k)
                        sTB += bad[k]
                    bad_root = 1 if p[1] != 1 else 0
                    sTB += bad_root
                    total_bad = sTB
                    assert inc_answer() == is_dfs_preorder(p, par, lca)

if __name__ == "__main__":
    run_cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
import sys
from typing import List

def build_adj(n: int, parents: List[int]) -> List[List[int]]:
    adj = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        p = parents[v]
        adj[p].append(v)
        adj[v].append(p)
    return adj

def build_lca(n: int, parents: List[int], adj: List[List[int]]):
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    par = [0]*(n+1)
    stack = [1]
    seen = [False]*(n+1)
    seen[1] = True
    while stack:
        u = stack.pop()
        for v in adj[u]:
            if not seen[v]:
                seen[v] = True
                par[v] = u
                depth[v] = depth[u] + 1
                stack.append(v)
    for v in range(1, n+1):
        up[0][v] = par[v]
    for k in range(1, LOG):
        rowk = up[k]; rowkm1 = up[k-1]
        for v in range(1, n+1):
            mid = rowkm1[v]
            rowk[v] = rowkm1[mid] if mid != 0 else 0
    def lca(a: int, b: int) -> int:
        if a == b:
            return a
        if depth[a] < depth[b]:
            a, b = b, a
        diff = depth[a] - depth[b]
        k = 0
        while diff:
            if diff & 1:
                a = up[k][a]
            diff >>= 1; k += 1
        if a == b:
            return a
        for k in range(LOG-1, -1, -1):
            if up[k][a] != up[k][b]:
                a = up[k][a]
                b = up[k][b]
        return up[0][a]
    return par, depth, up, lca

def solve_all():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    it = iter(data)
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        parents = [0]*(n+1)
        for v in range(2, n+1):
            parents[v] = int(next(it))
        adj = build_adj(n, parents)
        par, depth, up, lca = build_lca(n, parents, adj)
        p = [0]*(n+1)
        for i in range(1, n+1):
            p[i] = int(next(it))
        bad = [0]*(n)
        def pair_bad(i: int) -> int:
            u = p[i]; v = p[i+1]
            return 0 if lca(u, v) == par[v] else 1
        total_bad = 0
        for i in range(1, n):
            bad[i] = pair_bad(i)
            total_bad += bad[i]
        bad_root = 1 if p[1] != 1 else 0
        total_bad += bad_root
        for __ in range(q):
            x = int(next(it)); y = int(next(it))
            idx = set()
            for k in (x-1, x, y-1, y):
                if 1 <= k <= n-1:
                    idx.add(k)
            for k in idx:
                total_bad -= bad[k]
            total_bad -= bad_root
            p[x], p[y] = p[y], p[x]
            for k in idx:
                bad[k] = pair_bad(k)
                total_bad += bad[k]
            bad_root = 1 if p[1] != 1 else 0
            total_bad += bad_root
            out_lines.append("YES" if total_bad == 0 else "NO")
    sys.stdout.write("\n".join(out_lines))

def _self_check():
    # Minimal deterministic self-checks
    # Star tree
    n = 5
    parents = [0,0,1,1,1,1]
    adj = build_adj(n, parents)
    par, depth, up, lca = build_lca(n, parents, adj)
    def is_ok(p):
        if p[1] != 1: return False
        for i in range(1, n):
            if lca(p[i], p[i+1]) != par[p[i+1]]: return False
        return True
    assert is_ok([0,1,2,3,4,5])
    assert is_ok([0,1,5,4,3,2])
    assert not is_ok([0,2,1,3,4,5])

if __name__ == "__main__":
    _self_check()
    # For judge:
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain whether a permutation is a valid DFS preorder under arbitrary child order via adjacency LCA checks; update locally after swaps.}
\WHY{Dynamic verification of traversal properties appears often in interview and contest settings; recognizing the LCA characterization is the key.}
\CHECKLIST{
- Precompute $\mathrm{par}$ and $\mathrm{lca}$ once per test.
- Initialize $b_i$ for all adjacent pairs and root check.
- For a swap $(x,y)$, only recompute indices $\{x-1,x,y-1,y\}\cap[1,n-1]$ and $p_1$.
- Answer YES iff total violations $=0$.
}
\EDGECASES{
- $p_1\ne 1$ must immediately yield NO.
- Adjacent swaps ($y=x\pm 1$) — avoid double counting by using a set of indices.
- Swaps touching endpoints ($x=1$ or $y=1$) — update the root check.
- Smallest $n=2$.
- Highly unbalanced trees (chains).
- Large degrees (stars).
- Multiple test cases with cumulative limits.
}
\PITFALLS{
- Recursive DFS causing recursion depth overflow in Python — use iterative stack/BFS.
- Forgetting to include both directions in adjacency.
- Off-by-one when computing affected indices near boundaries.
- Incorrect LCA implementation when lifting by depth difference.
- Not maintaining persistence of swaps across queries.
- Using $O(n)$ recomputation per query leading to TLE on hard constraints.
}
\FAILMODES{Naive recomputation per query fails at $O(n\log n)$ for large inputs. Mischaracterizing the condition (e.g., only requiring $\mathrm{par}(v)$ appears before $v$) yields false positives. The proposed method robustly enforces the necessary and sufficient LCA adjacency condition.}
\ELI{Think of walking the permutation with a DFS stack: each next node must start a subtree from somewhere on the stack; that ``somewhere'' is exactly the LCA of the current and next nodes, which must equal the next node's parent. Check this locally between neighbors, and swaps only disturb a few neighbors.}
\NotePages{3}

\end{document}