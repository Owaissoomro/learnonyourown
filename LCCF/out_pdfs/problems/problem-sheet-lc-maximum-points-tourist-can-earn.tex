% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximum Points Tourist Can Earn}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximum-points-tourist-can-earn/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given two integers, $n$ and $k$, along with two 2D integer arrays, $\texttt{stayScore}$ and $\texttt{travelScore}$. A tourist is visiting a country with $n$ cities, where each city is \textbf{directly} connected to every other city. The tourist's journey consists of \textbf{exactly} $k$ \textbf{0-indexed} days, and they can choose \textbf{any} city as their starting point.

Each day, the tourist has two choices:
\begin{bullets}
\item \textbf{Stay in the current city}: If the tourist stays in their current city $\texttt{curr}$ during day $i$, they will earn $\texttt{stayScore}[i][\texttt{curr}]$ points.
\item \textbf{Move to another city}: If the tourist moves from their current city $\texttt{curr}$ to city $\texttt{dest}$, they will earn $\texttt{travelScore}[\texttt{curr}][\texttt{dest}]$ points.
\end{bullets}
Return the \textbf{maximum} possible points the tourist can earn.

\textbf{Example 1:}
Input: $n = 2$, $k = 1$, $\texttt{stayScore} = [[2,3]]$, $\texttt{travelScore} = [[0,2],[1,0]]$.
Output: $3$.
Explanation: The tourist earns the maximum number of points by starting in city $1$ and staying in that city.

\textbf{Example 2:}
Input: $n = 3$, $k = 2$, $\texttt{stayScore} = [[3,4,2],[2,1,2]]$, $\texttt{travelScore} = [[0,2,1],[2,0,4],[3,2,0]]$.
Output: $8$.
Explanation: The tourist earns the maximum number of points by starting in city $1$, staying in that city on day $0$, and traveling to city $2$ on day $1$.

\textbf{Constraints:}
\begin{bullets}
\item $1 \le n \le 200$
\item $1 \le k \le 200$
\item $n = \texttt{travelScore.length} = \texttt{travelScore}[i].\texttt{length} = \texttt{stayScore}[i].\texttt{length}$
\item $k = \texttt{stayScore.length}$
\item $1 \le \texttt{stayScore}[i][j] \le 100$
\item $0 \le \texttt{travelScore}[i][j] \le 100$
\item $\texttt{travelScore}[i][i] = 0$
\end{bullets}
Movement to the same city is considered ``another city'' only if $\texttt{dest} \ne \texttt{curr}$; thus a same-city move is not allowed and earns $0$ by definition, but staying is permitted and uses $\texttt{stayScore}$ for that day.}
\BREAKDOWN{Model each day as a transition over cities. Keep the maximum points achievable when ending the day in each city. For each day, either add the stay score for remaining in place or take the best incoming move score from any other city.}
\ELI{Dynamic programming over days and cities: each day, either stay and add the day's stay points, or move and add the travel points from your previous city.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function signature (LeetCode style): $\texttt{maxPoints(self, n, k, stayScore, travelScore)}$.
\begin{bullets}
\item $n$ (int): number of cities, $1 \le n \le 200$.
\item $k$ (int): number of days, $1 \le k \le 200$.
\item $\texttt{stayScore}$ (list[list[int]]): size $k \times n$, with $1 \le \texttt{stayScore}[i][j] \le 100$.
\item $\texttt{travelScore}$ (list[list[int]]): size $n \times n$, with $0 \le \texttt{travelScore}[i][j] \le 100$ and $\texttt{travelScore}[i][i] = 0$.
\end{bullets}}
\OUTPUTS{An integer: the maximum points achievable over exactly $k$ days, starting from any city and applying per-day choices.}
\SAMPLES{Example 1:
\begin{bullets}
\item Input: $n=2$, $k=1$, $\texttt{stayScore}=[[2,3]]$, $\texttt{travelScore}=[[0,2],[1,0]]$
\item Output: $3$
\end{bullets}
Example 2:
\begin{bullets}
\item Input: $n=3$, $k=2$, $\texttt{stayScore}=[[3,4,2],[2,1,2]]$, $\texttt{travelScore}=[[0,2,1],[2,0,4],[3,2,0]]$
\item Output: $8$
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{0,\ldots,n-1\}$ be cities. Let $S_i[c]=\texttt{stayScore}[i][c]$ for day $i$, and $T[p][d]=\texttt{travelScore}[p][d]$ for a move from $p$ to $d$, with the rule that moves must satisfy $p \ne d$. Define $dp_i[c]$ as the maximum total points after completing day $i$ and being in city $c$. Initial state: $dp_{-1}[c]=0$ for all $c\in V$ (free choice of starting city).}
\varmapStart
\var{n}{number of cities}
\var{k}{number of days}
\var{S_i[c]}{stay score on day $i$ for city $c$}
\var{T[p][d]}{travel score from $p$ to $d$}
\var{dp_i[c]}{max points after day $i$ ending in city $c$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
dp_{-1}[c] &= 0 \quad \forall c\in V, \\
dp_i[d] &= \max\Big( dp_{i-1}[d] + S_i[d],\ \max_{\substack{p\in V\\ p\ne d}} \big(dp_{i-1}[p] + T[p][d]\big) \Big) \quad \text{for } i=0,\ldots,k-1,\ d\in V. \\
\text{Answer} &= \max_{d\in V} dp_{k-1}[d].
\end{aligned}
\]
}
\ASSUMPTIONS{Days are indexed $0\ldots k-1$. All indices are valid. Moving to the same city is disallowed (``to another city''). The traveler earns either stay points or travel points each day, not both.}
\INVARIANTS{
\begin{bullets}
\item $dp_i[c]$ is nondecreasing in $i$ for fixed $c$ if $S_i[c]\ge 0$ and $T\ge 0$, which holds by constraints.
\item At each day $i$, $dp_i[c]\ge dp_{i-1}[c] + S_i[c]$ (staying option always available).
\item The recurrence is a max-plus linear update over a union of diagonal (stay) and off-diagonal (move) transitions.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the direct DP recurrence $dp_i[d]=\max(dp_{i-1}[d]+S_i[d], \max_{p\ne d}(dp_{i-1}[p]+T[p][d]))$.}
\ASSUMPTIONS{Compute day by day; maintain two arrays of size $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dp[c]=0$ for all $c$.
\item For each day $i=0\ldots k-1$:
  \begin{bullets}
  \item Set $\texttt{newdp}[c] = dp[c] + S_i[c]$ for all $c$ (stay).
  \item For each pair $(p,d)$ with $p\ne d$, set $\texttt{newdp}[d]=\max(\texttt{newdp}[d], dp[p] + T[p][d])$ (move).
  \end{bullets}
\item Replace $dp \leftarrow \texttt{newdp}$. After all days, return $\max_c dp[c]$.
\end{algosteps}
\COMPLEXITY{Two nested loops over $n$ per day. Time $T(n,k)=\Theta(k n^2)$, space $S(n)=\Theta(n)$.}
\[
\begin{aligned}
T(n,k) &= k\cdot\big(\Theta(n) + \Theta(n^2)\big) \\
       &= \Theta(k n^2), \quad S(n)=\Theta(n).
\end{aligned}
\]
\CORRECTNESS{By construction, at day $i$ for each destination $d$ we consider both admissible ways to end in $d$: either we stayed in $d$ (adding $S_i[d]$) or we moved from some $p\ne d$ (adding $T[p][d]$). Taking the maximum over these covers all optimal paths of length $i+1$. Initialization $dp_{-1}[c]=0$ captures free starting city.}
\EDGECASES{
\begin{bullets}
\item $n=1$: Only staying is possible each day.
\item $k=1$: Answer is $\max(\text{stay on day }0,\ \text{one move from start})$ where the start is freely chosen.
\item All-zero travel or all-zero stay cases reduce to taking only the other action.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxPoints(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        # dp[c]: max points after previous day, being in city c
        dp = [0] * n
        for i in range(k):
            newdp = [-10**18] * n  # sentinel for max
            # Option 1: stay in the same city c
            si = stayScore[i]
            for c in range(n):
                val = dp[c] + si[c]
                if val > newdp[c]:
                    newdp[c] = val
            # Option 2: move from p to d (p != d)
            T = travelScore
            for p in range(n):
                base = dp[p]
                row = T[p]
                for d in range(n):
                    if d == p:
                        continue
                    cand = base + row[d]
                    if cand > newdp[d]:
                        newdp[d] = cand
            dp = newdp
        return max(dp)

# Basic asserts (samples)
sol = Solution()
assert sol.maxPoints(2, 1, [[2, 3]], [[0, 2], [1, 0]]) == 3
assert sol.maxPoints(3, 2, [[3, 4, 2], [2, 1, 2]], [[0, 2, 1], [2, 0, 4], [3, 2, 0]]) == 8

# Additional tiny checks
assert sol.maxPoints(1, 3, [[5], [6], [7]], [[0]]) == 5 + 6 + 7  # only stays possible
assert sol.maxPoints(2, 1, [[1, 1]], [[0, 10], [9, 0]]) == 10  # start at 0 and move to 1
\end{minted}
\VALIDATION{Checked given samples; validated $n=1$ multi-day stays; validated best single-day move with free start.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Layout and Pruning}
\WHICHFORMULA{Same DP, but iterate by source city first to reuse row pointers and keep tight inner loops. Skip $p=d$ early to avoid wasted comparisons.}
\ASSUMPTIONS{Travel matrix is dense and arbitrary; asymptotically we still need $\Theta(n^2)$ per day. We target constant-factor speedups (Python-friendly).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep $dp$ as a Python list for fast indexing.
\item For each day:
  \begin{bullets}
  \item Initialize $\texttt{newdp}$ with the stay updates.
  \item For each source $p$, cache $base=dp[p]$ and the row $T[p]$, then sweep all $d\ne p$ updating $\texttt{newdp}[d]$ by max.
  \end{bullets}
\item Return $\max(\texttt{newdp})$ after the last day.
\end{algosteps}
\COMPLEXITY{Same asymptotics, fewer Python-level operations by hoisting invariants.}
\[
\begin{aligned}
T(n,k) &= \Theta(k n^2), \quad S(n)=\Theta(n).
\end{aligned}
\]
\CORRECTNESS{Identical recurrence and initialization as the baseline; only loop ordering/layout differs, preserving the max over all feasible transitions.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxPoints(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        T = travelScore  # alias
        for i in range(k):
            si = stayScore[i]
            newdp = [dp[c] + si[c] for c in range(n)]  # stay updates
            # move updates
            for p in range(n):
                base = dp[p]
                row = T[p]
                # manual unrolling is unnecessary; just skip d==p
                for d in range(n):
                    if d == p:
                        continue
                    v = base + row[d]
                    if v > newdp[d]:
                        newdp[d] = v
            dp = newdp
        return max(dp)

# Same asserts to ensure consistent behavior
sol = Solution()
assert sol.maxPoints(2, 1, [[2, 3]], [[0, 2], [1, 0]]) == 3
assert sol.maxPoints(3, 2, [[3, 4, 2], [2, 1, 2]], [[0, 2, 1], [2, 0, 4], [3, 2, 0]]) == 8
assert sol.maxPoints(1, 3, [[5], [6], [7]], [[0]]) == 18
assert sol.maxPoints(2, 1, [[1, 1]], [[0, 10], [9, 0]]) == 10
\end{minted}
\VALIDATION{Verified identical outputs on the sample cases and key edge cases ($n=1$, $k=1$).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Day-by-Day DP with Max-Plus Transitions}
\WHICHFORMULA{Use the recurrence:
\begin{BreakableEquation*}
dp_i[d]=\max\big(dp_{i-1}[d]+S_i[d],\ \max_{p\ne d}(dp_{i-1}[p]+T[p][d])\big).
\end{BreakableEquation*}
This is optimal under arbitrary dense $T$.}
\ASSUMPTIONS{Travel scores are unconstrained beyond bounds; thus every off-diagonal edge can be uniquely critical. Any algorithm must, in the worst case, consider $\Theta(n^2)$ edge contributions per day to certify optimality.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dp$ with zeros (free starting city).
\item For each day $i$, compute stay updates and all move updates $p\to d$ with $p\ne d$.
\item Return the maximum over final $dp$.
\end{algosteps}
\OPTIMALITY{Lower bound sketch: With arbitrary $T$, the contribution $dp_{i-1}[p]+T[p][d]$ for each ordered pair $(p,d)$ can be adversarially set so that each destination $d$ has a distinct maximizing source $p_d$. Any algorithm that skips considering a particular pair risks missing the true maximizer. Therefore $\Omega(n^2)$ work per day is information-theoretically necessary in the worst case, making the $\Theta(k n^2)$ DP tight.}
\COMPLEXITY{Time $\Theta(k n^2)$, space $\Theta(n)$.}
\[
\begin{aligned}
T(n,k) &= \Theta(k n^2), \quad S(n)=\Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxPoints(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        T = travelScore
        for i in range(k):
            si = stayScore[i]
            # Stay option
            newdp = [dp[c] + si[c] for c in range(n)]
            # Move option
            for p in range(n):
                base = dp[p]
                row = T[p]
                for d in range(n):
                    if d == p:
                        continue
                    cand = base + row[d]
                    if cand > newdp[d]:
                        newdp[d] = cand
            dp = newdp
        return max(dp)

# Exactly 3 asserts (samples + one crafted)
sol = Solution()
assert sol.maxPoints(2, 1, [[2, 3]], [[0, 2], [1, 0]]) == 3
assert sol.maxPoints(3, 2, [[3, 4, 2], [2, 1, 2]], [[0, 2, 1], [2, 0, 4], [3, 2, 0]]) == 8
# Crafted: prefer moving on both days
assert sol.maxPoints(3, 2, [[1, 1, 1], [1, 1, 1]], [[0, 5, 0], [0, 0, 6], [7, 0, 0]]) == 5 + 6
\end{minted}
\VALIDATION{Three asserts: both samples and a crafted two-day chain of moves where staying is dominated.}
\RESULT{Maximum total points over $k$ days with per-day choice of staying (earning $S_i[c]$) or moving (earning $T[p][d]$ with $p\ne d$), starting from any city.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify samples; edge cases $n=1$, $k=1$; adversarial random small cases via cross-check with a slow $O(k n^2)$ DP (same as reference) to ensure consistency.}
\LINE{CROSS-CHECKS}{Compare outputs across multiple implementations (baseline, improved, final). Since all implement the same recurrence, they should match exactly on random seeds.}
\LINE{EDGE-CASE GENERATOR}{Generate tiny random instances with $n\le 5$, $k\le 5$, bounded scores, deterministic seed for reproducibility.}
\begin{minted}{python}
from typing import List
import random

def brute(n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
    # Same DP; kept for explicit cross-check
    dp = [0] * n
    for i in range(k):
        ndp = [dp[c] + stayScore[i][c] for c in range(n)]
        for p in range(n):
            base = dp[p]
            row = travelScore[p]
            for d in range(n):
                if d == p:
                    continue
                v = base + row[d]
                if v > ndp[d]:
                    ndp[d] = v
        dp = ndp
    return max(dp)

class Solution:
    def maxPoints(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        T = travelScore
        for i in range(k):
            si = stayScore[i]
            newdp = [dp[c] + si[c] for c in range(n)]
            for p in range(n):
                base = dp[p]
                row = T[p]
                for d in range(n):
                    if d == p:
                        continue
                    cand = base + row[d]
                    if cand > newdp[d]:
                        newdp[d] = cand
            dp = newdp
        return max(dp)

def gen_case(n: int, k: int, vmax_stay: int = 7, vmax_move: int = 7, seed: int = 123) -> tuple:
    random.seed(seed)
    stay = [[random.randint(1, vmax_stay) for _ in range(n)] for _ in range(k)]
    move = [[random.randint(0, vmax_move) for _ in range(n)] for _ in range(n)]
    for i in range(n):
        move[i][i] = 0
    return n, k, stay, move

# Cross-check random cases
for seed in range(5):
    n, k, stay, move = gen_case(5, 4, seed=seed)
    ref = brute(n, k, stay, move)
    got = Solution().maxPoints(n, k, stay, move)
    assert ref == got, (seed, ref, got)

# Final sample checks
sol = Solution()
assert sol.maxPoints(2, 1, [[2, 3]], [[0, 2], [1, 0]]) == 3
assert sol.maxPoints(3, 2, [[3, 4, 2], [2, 1, 2]], [[0, 2, 1], [2, 0, 4], [3, 2, 0]]) == 8
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxPoints(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        T = travelScore
        for i in range(k):
            si = stayScore[i]
            newdp = [dp[c] + si[c] for c in range(n)]
            for p in range(n):
                base = dp[p]
                row = T[p]
                for d in range(n):
                    if d == p:
                        continue
                    cand = base + row[d]
                    if cand > newdp[d]:
                        newdp[d] = cand
            dp = newdp
        return max(dp)

# Sanity asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxPoints(2, 1, [[2, 3]], [[0, 2], [1, 0]]) == 3
    assert sol.maxPoints(3, 2, [[3, 4, 2], [2, 1, 2]], [[0, 2, 1], [2, 0, 4], [3, 2, 0]]) == 8
    # Edge: n=1
    assert sol.maxPoints(1, 4, [[2], [3], [4], [5]], [[0]]) == 14
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Day-by-day DP over cities; each day choose stay (add $S_i[c]$) or move (add $T[p][d]$) and keep maxima per destination.}
\WHY{Common DP pattern combining per-step local reward with transitions; tests handling of multiple choices and initialization with free start.}
\CHECKLIST{
\begin{bullets}
\item Initialize $dp$ to all zeros (free starting city) before day $0$.
\item For day $i$, apply stay updates first or interleave; both are fine as long as both options are considered.
\item Exclude $p=d$ for moves; staying already covers that case.
\item Update into a fresh array to avoid mixing day $i$ and $i-1$ values.
\item Take $\max$ over final $dp$ as the answer.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ forces only stays.
\item $k=1$ reduces to one stay vs one move from optimal start.
\item All $\texttt{travelScore}=0$ implies always stay.
\item All $\texttt{stayScore}=0$ implies always move if any positive travel exists.
\item Large $k,n$ near limits: ensure $O(k n^2)$ fits time.
\item Extremely skewed rows or columns in $T$: ensure correct source selection.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Allowing $p=d$ in move step (double-counts option and may suppress better stay).
\item In-place updates of $dp$ within the same day causing dependency on updated values.
\item Forgetting to consider free starting city (incorrect nonzero initialization).
\item Integer underflow/overflow not an issue in Python, but avoid very negative sentinels leaking to result.
\item Misindexing day vs city dimensions in $\texttt{stayScore}$ and $\texttt{travelScore}$.
\item Assuming travel plus stay in the same day; the problem defines an exclusive choice.
\end{bullets}}
\FAILMODES{Greedy by day or by city fails: a locally best stay or move may block a high-reward move later. The DP considers all predecessors per destination per day, avoiding such traps.}
\ELI{Keep the best score you can have in each city after each day. Each day, either add the stay points if you remain, or add the travel points if you switch cities. After $k$ days, the best among all cities is your answer.}
\NotePages{3}

\end{document}