% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Farm Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1942/E}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Farmer Nhoj has brought his cows over to Farmer John\'s farm to play a game! FJ\'s farm can be modeled by a number line with walls at points $0$ and $l + 1$. On the farm, there are $2n$ cows, with $n$ of the cows belonging to FJ and the other $n$ belonging to FN. They place each of their cows at a distinct point, and no two FJ\'s cows nor FN\'s cows are adjacent. Two cows are adjacent if there are no other cows between them.

Formally, if $a_1, a_2, \ldots, a_n$ represents the positions of FJ\'s cows and $b_1, b_2, \ldots, b_n$ represents the positions of FN\'s cows, then either $0 < a_1 < b_1 < a_2 < b_2 < \ldots < a_n < b_n < l + 1$ or $0 < b_1 < a_1 < b_2 < a_2 < \ldots < b_n < a_n < l + 1$.

In one move, a farmer chooses a number $k$ $(1 \le k \le n)$ and a direction (left or right). Then, that farmer chooses $k$ of his cows and moves them one position towards the chosen direction. A farmer cannot move any of his cows onto the walls or onto another farmer\'s cow. If a farmer cannot move any cows, then that farmer loses. FJ starts the game, making the first turn.

Given $l$ and $n$, find the number of possible game configurations for Farmer John to win if both farmers play optimally. It may be the case that the game will continue indefinitely, in which no farmer wins. A configuration is different from another if there is any $i$ such that $a_i$ or $b_i$ is different. Output the answer modulo $998{,}244{,}353$.

Input:
The first line contains $t$ ($1 \le t \le 10^4$)~--- the number of test cases.

Each test case contains two integers $l$ and $n$ ($2 \le l \le 10^6, 1 \le n \le \lfloor \tfrac{l}{2} \rfloor$)~--- the length of the number line and the number of cows each farmer will place.

It is guaranteed the sum of $l$ over all test cases does not exceed $10^6$.

Output:
For each test case output an integer: the number of game configurations where Farmer John wins if both farmers play optimally, modulo $998{,}244{,}353$.

Note:
Let J denote FJ\'s cow, N denote FN\'s cow, and \_ denote an empty space.

For the first test case, the two possible configurations are JN or NJ. In both cases, since FJ makes the first turn and cannot make any moves, he cannot win.

For the second case there are two possible configurations for FJ to win: N\_J and J\_N.}
\BREAKDOWN{Rephrase the game as a stars-and-bars composition of empty gaps between cows and walls. Characterize exactly when the starting player can force a win. Count such gap tuples over both alternation patterns and sum, modulo $998{,}244{,}353$.}
\ELI{All empty spaces sit in $2n{+}1$ gaps; FJ can win only if, in his very first move, he can clear every gap adjacent to FN\'s cows. This happens exactly when all empties on FN-adjacent gaps lie on a single side across all FN cows and the boundary gap he cannot touch is already zero. Count these compositions.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.
\begin{bullets}
\item $t$ integer, number of test cases.
\item For each test: integers $l, n$ with $2 \le l \le 10^6$ and $1 \le n \le \lfloor \tfrac{l}{2} \rfloor$.
\end{bullets}}
\OUTPUTS{For each test case, one integer: the number of initial configurations (placement of $n$ FJ cows and $n$ FN cows at distinct positions in $\{1,\ldots,l\}$ alternating) for which FJ wins under optimal play, modulo $998{,}244{,}353$.}
\SAMPLES{Examples consistent with notes:
\begin{bullets}
\item $l=2, n=1 \Rightarrow 0$ (both cows fill the line; no moves).
\item $l=3, n=1 \Rightarrow 2$ (configurations N\_J and J\_N).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the $2n$ cows occupy positions $1 \le x_1 < x_2 < \cdots < x_{2n} \le l$. Define gap vector $g \in \mathbb{Z}_{\ge 0}^{2n+1}$ by
$g_0 = x_1-1$, $g_i = x_{i+1}-x_i-1$ for $1 \le i \le 2n-1$, and $g_{2n} = l - x_{2n}$. Then $\sum_{i=0}^{2n} g_i = S := l - 2n$. Alternation has two patterns:
\begin{bullets}
\item Pattern P1: FJ at odd $x_i$ (indices $1,3,\ldots,2n-1$), FN at even $x_i$.
\item Pattern P2: FN at odd $x_i$, FJ at even $x_i$.
\end{bullets}
On FJ\'s move, he chooses a global direction. In P1, each FJ cow sits between gaps $(g_{2j}, g_{2j+1})$; moving left decrements $g_{2j}$ and increments $g_{2j+1}$; moving right decrements $g_{2j+1}$ and increments $g_{2j}$. In P2, each FJ cow sits between gaps $(g_{2j-1}, g_{2j})$ with analogous effect. FN acts similarly on the complementary adjacent pairs.}
\varmapStart
\var{l}{number of cells}
\var{n}{cows per farmer}
\var{S}{total empty cells, $S=l-2n$}
\var{g_i}{empty cells in gap $i$ between walls/cows}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\sum_{i=0}^{2n} g_i = S,\quad g_i \in \mathbb{Z}_{\ge 0}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Cows alternate strictly; no two cows share a position; walls at $0$ and $l{+}1$ are excluded from positions.}
\INVARIANTS{
\begin{bullets}
\item Total empties $\sum g_i = S$ is invariant.
\item In P1 (resp.\ P2), FJ only moves mass within pairs $(g_{2j},g_{2j+1})$ (resp.\ $(g_{2j-1},g_{2j})$).
\item A player is stuck iff for each of his cows, both adjacent gaps are $0$ (equivalently, all gaps belonging to his pairs are $0$).
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Recast placements as stars-and-bars on gap-vector $g$. Characterize first-move wins: FJ can win only if, in his first move, all gaps adjacent to every FN cow become $0$.}
\ASSUMPTIONS{Any attempt to force a later win requires FN to cooperate by picking the same global direction twice in a row; optimal FN will avoid this. Hence only immediate eliminations matter.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each alternation pattern (P1, P2), identify the set of FN-pair gaps.
\item FJ can zero all FN-pair gaps in one move iff:
\begin{bullets}
\item the boundary FN-only gap (unaffected by FJ this move) is already $0$ (P1: $g_{2n}=0$; P2: $g_0=0$), and
\item among FN-pair gaps, all positive entries lie on the same side across all FN cows (either all ``left'' members or all ``right'' members of those pairs), and at least one such entry is positive so $k \ge 1$.
\end{bullets}
\item Count such $g$ by stars-and-bars with the above zero constraints; sum P1 and P2 counts.
\end{algosteps}
\COMPLEXITY{Using closed forms, per test $O(1)$ after factorial precomputation. Precompute up to $O(\max l)$.
\[
\begin{aligned}
T(t,l_{\max}) &= O(l_{\max} + t),\quad S(l_{\max}) = O(l_{\max}).
\end{aligned}
\]
}
\CORRECTNESS{If FN-pair positives occupy both sides among different FN cows, no single FJ direction can clear them all; FN will then have a legal reply, preventing immediate loss. Conversely, if all positives lie on one side and the untouchable boundary FN gap is $0$, FJ chooses the clearing direction and selects all eligible cows, making every FN-pair gap $0$; FN has no move and loses.}
\EDGECASES{When $S=0$ no moves exist; the starter loses, yielding zero winning configurations. If all FN-pair gaps are already $0$ but FJ has a move elsewhere, then any move creates a positive FN-pair gap; thus not a winning initial state.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

MOD = 998244353

def precompute_factorials(limit: int, mod: int = MOD):
    fac = [1] * (limit + 1)
    ifac = [1] * (limit + 1)
    for i in range(1, limit + 1):
        fac[i] = fac[i - 1] * i % mod
    if limit >= 1:
        ifac[limit] = pow(fac[limit], mod - 2, mod)
        for i in range(limit, 0, -1):
            ifac[i - 1] = ifac[i] * i % mod
    return fac, ifac

def nCk(n: int, k: int, fac, ifac, mod: int = MOD) -> int:
    if k < 0 or k > n or n < 0:
        return 0
    return fac[n] * ifac[k] % mod * ifac[n - k] % mod

def count_fj_wins_closed(l: int, n: int, fac, ifac) -> int:
    S = l - 2 * n
    # Per-pattern count:
    # cp = C(S+n, n) + C(S+n-1, n-1) - 2
    term1 = nCk(S + n, n, fac, ifac)
    term2 = nCk(S + n - 1, n - 1, fac, ifac)
    cp = (term1 + term2 - 2) % MOD
    return (2 * cp) % MOD

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        l = int(next(it)); n = int(next(it))
        tests.append((l, n))
    return t, tests

def solve_all():
    t, tests = read_input()
    if t == 0:
        return
    max_l = max(l for (l, _) in tests)
    # Upper bound for n in combos: need up to S+n <= l - n <= max_l - 1
    fac, ifac = precompute_factorials(max_l, MOD)
    out = []
    for (l, n) in tests:
        out.append(str(count_fj_wins_closed(l, n, fac, ifac)))
    sys.stdout.write("\n".join(out))

def _self_test():
    fac, ifac = precompute_factorials(10)
    # Tiny checks from statement and simple reasoning
    assert count_fj_wins_closed(2, 1, fac, ifac) == 0  # S=0
    assert count_fj_wins_closed(3, 1, fac, ifac) == 2  # S=1 => 2
    # A couple more tiny checks
    assert count_fj_wins_closed(4, 1, fac, ifac) == (2 * ((3 + 1 - 2) % MOD)) % MOD  # S=2: C(3,1)=3, C(2,0)=1 -> per-pattern 2 -> total 4
    assert count_fj_wins_closed(4, 2, fac, ifac) == 0  # S=0 again
    # Random spot-check consistency: non-negativity
    for l in range(2, 8):
        for n in range(1, l // 2 + 1):
            ans = count_fj_wins_closed(l, n, fac, ifac)
            assert 0 <= ans < MOD

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Asserts cover $S=0$ edge, the $l=3,n=1$ sample, and a couple of tiny cross-checks.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same closed form; improve verification by enumerating gap-compositions for tiny inputs to cross-check the formula and avoid search over placements.}
\ASSUMPTIONS{Use stars-and-bars enumeration of $g$ only for tiny $S, n$ within asserts; production path uses the $O(1)$ formula.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute factorials and inverse factorials up to $\max l$.
\item For testing only, enumerate all $g \in \mathbb{Z}_{\ge 0}^{2n+1}$ with $\sum g_i = S$ for tiny $l$.
\item Implement the first-move-win predicate on $g$ for P1 and P2 and compare counts to the closed form.
\item For production, output the formula $2\cdot\big(\binom{S+n}{n} + \binom{S+n-1}{n-1} - 2\big)\bmod M$.
\end{algosteps}
\COMPLEXITY{Production remains $O(1)$ per test; tiny enumeration only in asserts. 
\begin{BreakableEquation*}
T = O(l_{\max}) + O(t),\quad S = O(l_{\max}).
\end{BreakableEquation*}
}
\CORRECTNESS{The enumeration-based checker independently counts configurations satisfying the precise one-move-win criterion derived from the pair-structure; equality with the formula on many tiny cases supports correctness.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from itertools import product

MOD = 998244353

def precompute_factorials(limit: int, mod: int = MOD):
    fac = [1] * (limit + 1)
    ifac = [1] * (limit + 1)
    for i in range(1, limit + 1):
        fac[i] = fac[i - 1] * i % mod
    if limit >= 1:
        ifac[limit] = pow(fac[limit], mod - 2, mod)
        for i in range(limit, 0, -1):
            ifac[i - 1] = ifac[i] * i % mod
    return fac, ifac

def nCk(n: int, k: int, fac, ifac, mod: int = MOD) -> int:
    if k < 0 or k > n or n < 0:
        return 0
    return fac[n] * ifac[k] % mod * ifac[n - k] % mod

def count_fj_wins_closed(l: int, n: int, fac, ifac) -> int:
    S = l - 2 * n
    term1 = nCk(S + n, n, fac, ifac)
    term2 = nCk(S + n - 1, n - 1, fac, ifac)
    cp = (term1 + term2 - 2) % MOD
    return (2 * cp) % MOD

def _can_win_first_move_P1(g):
    # P1: FJ at odd indices; FN pairs are (1,2), ... , (2n-1,2n)
    m = len(g) - 1  # m = 2n
    n = m // 2
    if g[m] != 0:
        return False
    # Check sides among FN pairs
    odd_pos = any(g[2*j - 1] > 0 for j in range(1, n + 1))  # indices 1,3,...,2n-1
    even_pos = any(g[2*j] > 0 for j in range(1, n + 1))      # indices 2,4,...,2n
    if not odd_pos and not even_pos:
        return False  # no k>=1 move to clear (all FN-pair gaps already zero)
    if odd_pos and even_pos:
        return False  # cannot clear both sides with one global direction
    # If only even_pos, we already ensured g[2n]==0 above
    return True

def _can_win_first_move_P2(g):
    # P2: FJ at even indices; FN pairs are (0,1),(2,3),..., (2n-2,2n-1)
    m = len(g) - 1
    n = m // 2
    if g[0] != 0:
        return False
    odd_pos = any(g[2*j - 1] > 0 for j in range(1, n + 1))   # 1,3,...,2n-1
    even_pos = any(g[2*j] > 0 for j in range(1, n))          # 2,4,...,2n-2
    if not odd_pos and not even_pos:
        return False
    if odd_pos and even_pos:
        return False
    return True

def _enumerate_gap_counts(l, n):
    S = l - 2 * n
    # Generate all compositions of S into 2n+1 nonnegative parts
    # Simple recursive generator
    res = []
    g = [0] * (2 * n + 1)
    def dfs(i, rem):
        if i == 2 * n:
            g[i] = rem
            res.append(tuple(g))
            return
        for v in range(rem + 1):
            g[i] = v
            dfs(i + 1, rem - v)
    dfs(0, S)
    return res

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        l = int(next(it)); n = int(next(it))
        tests.append((l, n))
    return t, tests

def solve_all():
    t, tests = read_input()
    if t == 0:
        return
    max_l = max(l for (l, _) in tests)
    fac, ifac = precompute_factorials(max_l, MOD)
    out = []
    for (l, n) in tests:
        out.append(str(count_fj_wins_closed(l, n, fac, ifac)))
    sys.stdout.write("\n".join(out))

def _self_test():
    fac, ifac = precompute_factorials(20)
    # Known small cases
    assert count_fj_wins_closed(2, 1, fac, ifac) == 0
    assert count_fj_wins_closed(3, 1, fac, ifac) == 2
    # Cross-check by enumerating gaps for small l
    for l in range(2, 7):
        for n in range(1, l // 2 + 1):
            gs = _enumerate_gap_counts(l, n)
            count_enum = 0
            for g in gs:
                if _can_win_first_move_P1(g):
                    count_enum += 1
                if _can_win_first_move_P2(g):
                    count_enum += 1
            assert count_enum % MOD == count_fj_wins_closed(l, n, fac, ifac)

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{The internal checker enumerates all gap-compositions for $l \le 6$ and validates the formula exactly for all feasible $n$ in that range.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Closed-form counting via stars-and-bars with one-move-win characterization. Final formula:
\begin{BreakableEquation*}
W(l,n) = 2\cdot\Bigg(\binom{S+n}{n} + \binom{S+n-1}{n-1} - 2\Bigg)\bmod 998{,}244{,}353,\quad S=l-2n.
\end{BreakableEquation*}}
\ASSUMPTIONS{Optimal FN never cooperates to allow a two-turn funnel of empties into a losing boundary; hence only immediate eliminations are forceable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute factorials and inverse factorials up to $\max l$ across tests.
\item For a test $(l,n)$, set $S=l-2n$.
\item Compute $A=\binom{S+n}{n}$ and $B=\binom{S+n-1}{n-1}$.
\item Answer $= 2\cdot(A+B-2)\bmod M$, where $M=998{,}244{,}353$.
\end{algosteps}
\OPTIMALITY{The decision and count are $O(1)$ per test after precomputation. This is information-theoretically optimal for outputs per test in constant time.}
\COMPLEXITY{Precompute $O(\max l)$; per test $O(1)$.
\begin{BreakableEquation*}
T = O(l_{\max}) + O(t),\quad S = O(l_{\max}).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

MOD = 998244353

def precompute_factorials(limit: int, mod: int = MOD):
    fac = [1] * (limit + 1)
    ifac = [1] * (limit + 1)
    for i in range(1, limit + 1):
        fac[i] = fac[i - 1] * i % mod
    if limit >= 1:
        ifac[limit] = pow(fac[limit], mod - 2, mod)
        for i in range(limit, 0, -1):
            ifac[i - 1] = ifac[i] * i % mod
    return fac, ifac

def nCk(n: int, k: int, fac, ifac, mod: int = MOD) -> int:
    if k < 0 or k > n or n < 0:
        return 0
    return fac[n] * ifac[k] % mod * ifac[n - k] % mod

def answer_for_case(l: int, n: int, fac, ifac) -> int:
    S = l - 2 * n
    A = nCk(S + n, n, fac, ifac)
    B = nCk(S + n - 1, n - 1, fac, ifac)
    ans = (2 * ((A + B - 2) % MOD)) % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        l = int(next(it)); n = int(next(it))
        tests.append((l, n))
    return t, tests

def solve_all():
    t, tests = read_input()
    if t == 0:
        return
    max_l = max(l for (l, _) in tests)
    fac, ifac = precompute_factorials(max_l, MOD)
    out = []
    for (l, n) in tests:
        out.append(str(answer_for_case(l, n, fac, ifac)))
    sys.stdout.write("\n".join(out))

def _self_test():
    fac, ifac = precompute_factorials(10)
    # Statement-aligned checks
    assert answer_for_case(2, 1, fac, ifac) == 0
    assert answer_for_case(3, 1, fac, ifac) == 2
    # A couple more
    assert answer_for_case(4, 1, fac, ifac) == 4
    assert answer_for_case(4, 2, fac, ifac) == 0

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts exercise $S=0$, the sample $S=1$, and a few tiny cases.}
\RESULT{Counts configurations where FJ wins under optimal play: exactly those where in his first move he can clear all FN-adjacent gaps, across either alternation pattern.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate combinatorial formula against exhaustive gap-enumeration for small $l$ and all feasible $n$. Check edge $S=0$. Random tiny smoke checks for non-negativity and bounds.}
\LINE{CROSS-CHECKS}{Compare closed-form answers against enumeration-based predicate on $g$ for both patterns (P1, P2) on $l \le 6$.}
\LINE{EDGE-CASE GENERATOR}{Generate all $g$ with $\sum g_i=S$ for tiny $S$ by recursive compositions, ensuring coverage of boundary conditions ($g_0=0$ or $g_{2n}=0$) and one-sided support across FN pairs.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def enumerate_gaps(S, parts):
    g = [0] * parts
    res = []
    def dfs(i, rem):
        if i == parts - 1:
            g[i] = rem
            res.append(tuple(g))
            return
        for v in range(rem + 1):
            g[i] = v
            dfs(i + 1, rem - v)
    dfs(0, S)
    return res

def adversarial_cases(max_l=6):
    cases = []
    for l in range(2, max_l + 1):
        for n in range(1, l // 2 + 1):
            cases.append((l, n))
    return cases

def reference_closed(l, n, fac, ifac, MOD=998244353):
    S = l - 2 * n
    from math import comb  # only for tiny checks if desired
    # Using provided fac/ifac for consistency
    def C(N, K):
        if K < 0 or K > N or N < 0:
            return 0
        return fac[N] * ifac[K] % MOD * ifac[N - K] % MOD
    return (2 * ((C(S + n, n) + C(S + n - 1, n - 1) - 2) % MOD)) % MOD
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

MOD = 998244353

def precompute_factorials(limit: int, mod: int = MOD):
    fac = [1] * (limit + 1)
    ifac = [1] * (limit + 1)
    for i in range(1, limit + 1):
        fac[i] = fac[i - 1] * i % mod
    if limit >= 1:
        ifac[limit] = pow(fac[limit], mod - 2, mod)
        for i in range(limit, 0, -1):
            ifac[i - 1] = ifac[i] * i % mod
    return fac, ifac

def nCk(n: int, k: int, fac, ifac, mod: int = MOD) -> int:
    if k < 0 or k > n or n < 0:
        return 0
    return fac[n] * ifac[k] % mod * ifac[n - k] % mod

def solve_case(l: int, n: int, fac, ifac) -> int:
    S = l - 2 * n
    t1 = nCk(S + n, n, fac, ifac)
    t2 = nCk(S + n - 1, n - 1, fac, ifac)
    ans = (2 * ((t1 + t2 - 2) % MOD)) % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        l = int(next(it)); n = int(next(it))
        tests.append((l, n))
    return t, tests

def main():
    t, tests = read_input()
    if t == 0:
        return
    max_l = max(l for (l, _) in tests)
    fac, ifac = precompute_factorials(max_l)
    out = []
    for (l, n) in tests:
        out.append(str(solve_case(l, n, fac, ifac)))
    print("\n".join(out))

def _tests():
    fac, ifac = precompute_factorials(10)
    assert solve_case(2, 1, fac, ifac) == 0
    assert solve_case(3, 1, fac, ifac) == 2
    assert solve_case(4, 1, fac, ifac) == 4

if __name__ == "__main__":
    _tests()
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count gap-compositions where FN-adjacent gaps can all be cleared by FJ in a single global-direction move.}
\WHY{Alternating-pair move constraints mean only immediate eliminations are forceable under optimal play; otherwise the opponent can always maintain a reply, leading to an endless game.}
\CHECKLIST{
\begin{bullets}
\item Compute $S=l-2n$.
\item Precompute factorials up to $\max l$.
\item Evaluate $A=\binom{S+n}{n}$, $B=\binom{S+n-1}{n-1}$ modulo $998{,}244{,}353$.
\item Answer $=2\cdot(A+B-2)\bmod M$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $S=0$ (no moves): answer $0$.
\item $n=1$ sanity: yields $0,2,4,\ldots$ consistent with direct enumeration.
\item Extremely large $l$ with sum of $l$ bounded: precompute once.
\item Ensure boundary FN-only gap is zero (P1: $g_{2n}$; P2: $g_0$) in the characterization.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in which boundary gap is untouchable per pattern.
\item Forgetting to exclude the all-mass-in-$g_0$ or all-mass-in-$g_{2n}$ cases (no $k\ge 1$ move).
\item Misapplying direction effects between P1 vs P2.
\item Modular subtraction: add $M$ before $\bmod$ to avoid negatives.
\end{bullets}}
\FAILMODES{Enumerating placements directly is infeasible; search over game trees explodes and is unnecessary. The derived closed form bypasses exponential blow-up.}
\ELI{Think of empty spaces as tokens in $2n{+}1$ bins. FJ can only slide tokens across his cows, all in one chosen direction. He wins right away only if all tokens near FN cows are on one consistent side, so a single sweep clears them out. Count those cases with stars-and-bars.}
\NotePages{3}

\end{document}