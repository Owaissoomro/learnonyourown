% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Poisoned Dagger}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1613/C}}
\LINE{DIFFICULTY / RATING}{1200 (CF: 1613/C)}
\STATEMENT{Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts $100^{500}$ seconds, during which Monocarp attacks the dragon with a poisoned dagger. The $i$-th attack is performed at the beginning of the $a_i$-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals $1$ damage during each of the next $k$ seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).

For example, suppose $k = 4$, and Monocarp stabs the dragon during the seconds $2$, $4$ and $10$. Then the poison effect is applied at the start of the $2$-nd second and deals $1$ damage during the $2$-nd and $3$-rd seconds; then, at the beginning of the $4$-th second, the poison effect is reapplied, so it deals exactly $1$ damage during the seconds $4$, $5$, $6$ and $7$; then, during the $10$-th second, the poison effect is applied again, and it deals $1$ damage during the seconds $10$, $11$, $12$ and $13$. In total, the dragon receives $10$ damage.

Monocarp knows that the dragon has $h$ hit points, and if he deals at least $h$ damage to the dragon during the battle — he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of $k$ (the number of seconds the poison effect lasts) that is enough to deal at least $h$ damage to the dragon.

Input:
The first line contains a single integer $t$ ($1 \le t \le 1000$) — the number of test cases.

The first line of the test case contains two integers $n$ and $h$ ($1 \le n \le 100; 1 \le h \le 10^{18}$) — the number of Monocarp's attacks and the amount of damage that needs to be dealt.

The second line contains $n$ integers $a_1$, $a_2$, \ldots, $a_n$ ($1 \le a_i \le 10^9; a_i < a_{i + 1}$), where $a_i$ is the second when the $i$-th attack is performed.

Output:
For each test case, print a single integer — the minimum value of the parameter $k$, such that Monocarp will cause at least $h$ damage to the dragon.

Note:
In the first example, for $k=3$, damage is dealt in seconds $[1, 2, 3, 5, 6, 7]$.

In the second example, for $k=4$, damage is dealt in seconds $[2, 3, 4, 5, 6, 7, 10, 11, 12, 13]$.

In the third example, for $k=1$, damage is dealt in seconds $[1, 2, 4, 5, 7]$.}
\BREAKDOWN{Compute total poison damage for a given $k$ efficiently as a sum of capped gaps and the last segment, then search the minimal $k$ that reaches at least $h$. Use monotonicity to binary search on $k$.}
\ELI{Each stab starts a $k$-long timer of damage, but re-stabbing resets it; the total damage grows with $k$, so find the smallest $k$ by binary search.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case:
\begin{bullets}
\item $n$ (int), $h$ (int): $1 \le n \le 100$, $1 \le h \le 10^{18}$.
\item Strictly increasing sequence $a_1,\ldots,a_n$ (ints), $1 \le a_i \le 10^9$.
\end{bullets}}
\OUTPUTS{For each test case, print one integer on its own line: the minimal $k$ such that the total poison damage is at least $h$.}
\SAMPLES{Example:
\begin{tcolorbox}
Input
\begin{verbatim}
3
3 10
2 4 10
1 7
5
5 12
1 3 6 7 9
\end{verbatim}
Output
\begin{verbatim}
4
7
4
\end{verbatim}
\end{tcolorbox}
Explanation (third case): damage$(k)=\min(k,2)+\min(k,3)+\min(k,1)+\min(k,2)+k$, so the least $k$ with damage $\ge 12$ is $k=4$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given strictly increasing timestamps $a_1<\cdots<a_n$ and a duration $k\in\mathbb{Z}_{\ge 1}$, the poison contributes damage in continuous seconds. Because a re-application truncates the previous effect, the total damage equals the sum of truncated segments between attacks plus the terminal segment of length $k$. Find the least $k$ so that this sum reaches $h$.}
\varmapStart
\var{n}{number of attacks}
\var{h}{required total damage}
\var{\mathbf{a}=(a_1,\ldots,a_n)}{attack times, strictly increasing}
\var{k}{poison duration to choose}
\var{D(k)}{total damage dealt as a function of $k$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
D(k)=\sum_{i=1}^{n-1}\min\bigl(k,\ a_{i+1}-a_i\bigr)+k,\qquad\text{find }\min\{k\in\mathbb{Z}_{\ge 1}: D(k)\ge h\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Attacks are at integer seconds; re-poison resets the effect immediately; $a_i$ are strictly increasing; $k$ is a positive integer.}
\INVARIANTS{
\begin{bullets}
\item $D(k)$ is nondecreasing and piecewise-linear in $k$ with slope in $[1,n]$.
\item $D(k)\le (n-1)\cdot k + k = n\cdot k$, hence $k\le h$ always suffices since $D(h)\ge h$.
\item For each gap $\Delta_i=a_{i+1}-a_i$, its contribution saturates at $\Delta_i$ once $k\ge \Delta_i$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use $D(k)=\sum_{i=1}^{n-1}\min(k,a_{i+1}-a_i)+k$. Increment $k$ from $1$ upward until $D(k)\ge h$.}
\ASSUMPTIONS{Feasible only for small $h$; correctness relies on monotonicity of $D(k)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute adjacent gaps $\Delta_i=a_{i+1}-a_i$.
\item For $k=1,2,\ldots$ compute $D(k)=\sum_{i=1}^{n-1}\min(k,\Delta_i)+k$.
\item Stop at the first $k$ with $D(k)\ge h$ and output it.
\end{algosteps}
\COMPLEXITY{Let $n$ be the number of attacks and $K^\star$ the answer. This scans $k$ up to $K^\star$, each in $O(n)$ time.}
\[
\begin{aligned}
T(n) &= O\bigl(n\cdot K^\star\bigr) \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Since $D(k)$ is nondecreasing in $k$, the first $k$ reaching $h$ is minimal. Each $D(k)$ is computed exactly per the governing formula.}
\EDGECASES{$n=1$ yields $D(k)=k$ hence answer $k=h$. Large gaps do not overcount due to the $\min$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def compute_damage(a, k):
    """Total damage for duration k."""
    total = 0
    n = len(a)
    for i in range(n - 1):
        total += min(k, a[i + 1] - a[i])
    total += k
    return total

def minimal_k_naive(a, h):
    """Brute-force k upwards until reaching h."""
    k = 1
    while True:
        if compute_damage(a, k) >= h:
            return k
        k += 1

def read_input(data: str):
    it = iter(map(int, data.strip().split()))
    try:
        t = next(it)
    except StopIteration:
        return 0, []
    cases = []
    for _ in range(t):
        n = next(it); h = next(it)
        arr = [next(it) for _ in range(n)]
        cases.append((n, h, arr))
    return t, cases

def solve_case(n, h, arr):
    return minimal_k_naive(arr, h)

def solve_all(cases):
    out_lines = []
    for n, h, arr in cases:
        out_lines.append(str(solve_case(n, h, arr)))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    t, cases = read_input(data)
    ans = solve_all(cases)
    if ans:
        print(ans)

if __name__ == "__main__":
    # Self-checks on tiny inputs
    assert compute_damage([2, 4, 10], 3) == 8
    assert compute_damage([2, 4, 10], 4) == 10
    assert minimal_k_naive([2, 4, 10], 10) == 4
    # n=1: need k=h
    assert minimal_k_naive([5], 7) == 7
    main()
\end{minted}
\VALIDATION{Checked core damage arithmetic; validated example scenario $[2,4,10], h=10 \Rightarrow k=4$; trivial single-attack case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search on Monotone Answer}
\WHICHFORMULA{$D(k)$ is nondecreasing in $k$, so the predicate $D(k)\ge h$ is monotone. Binary search $k$ in $[1,h]$.}
\ASSUMPTIONS{Upper bound $h$ is sufficient because $D(h)\ge h$. Each $D(k)$ is computed in $O(n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define predicate $P(k)\equiv\bigl(D(k)\ge h\bigr)$.
\item Initialize $lo=1$, $hi=h$.
\item While $lo<hi$: set $mid=\lfloor(lo+hi)/2\rfloor$; if $P(mid)$ then $hi=mid$ else $lo=mid+1$.
\item Return $lo$.
\end{algosteps}
\COMPLEXITY{Binary search performs $O(\log h)$ iterations; each iteration computes $D(k)$ in $O(n)$ time.}
\[
\begin{aligned}
T(n) &= O\bigl(n\log h\bigr), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Invariants: $P(lo)$ is false and $P(hi)$ is true initially if we conceptually set $lo=0$; the loop maintains the smallest feasible $hi$. Termination yields the minimal $k$ with $P(k)$ true.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def compute_damage(a, k):
    total = 0
    for i in range(len(a) - 1):
        total += min(k, a[i + 1] - a[i])
    total += k
    return total

def minimal_k_binary(a, h):
    lo, hi = 1, h  # hi is sufficient since D(h) >= h
    while lo < hi:
        mid = (lo + hi) // 2
        if compute_damage(a, mid) >= h:
            hi = mid
        else:
            lo = mid + 1
    return lo

def read_input(data: str):
    it = iter(map(int, data.strip().split()))
    try:
        t = next(it)
    except StopIteration:
        return 0, []
    cases = []
    for _ in range(t):
        n = next(it); h = next(it)
        arr = [next(it) for _ in range(n)]
        cases.append((n, h, arr))
    return t, cases

def solve_case(n, h, arr):
    return minimal_k_binary(arr, h)

def solve_all(cases):
    return "\n".join(str(solve_case(n, h, arr)) for n, h, arr in cases)

def main():
    data = sys.stdin.read()
    t, cases = read_input(data)
    if t:
        print(solve_all(cases))

if __name__ == "__main__":
    # Checks against known scenarios
    assert minimal_k_binary([2, 4, 10], 10) == 4
    assert minimal_k_binary([5], 7) == 7
    # Another crafted case
    assert minimal_k_binary([1, 3, 6, 7, 9], 12) == 4
    main()
\end{minted}
\VALIDATION{Verified on three small cases, including the illustrative example and boundary $n=1$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Binary Search with Tight Bounds and Linear Damage Evaluation}
\WHICHFORMULA{Same as Approach B: binary search on $k$ with $D(k)$ from the governing formula; this is optimal under comparison model due to monotonicity and the need to evaluate $D$.}
\ASSUMPTIONS{Integers fit 64-bit; Python big integers handle $h\le 10^{18}$. Attack times strictly increasing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $D(k)$ in one pass as $\sum_{i=1}^{n-1}\min(k,a_{i+1}-a_i)+k$.
\item Binary search $k\in[1,h]$ to find the smallest $k$ with $D(k)\ge h$.
\item Output $k$ for each test case.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must distinguish among $O(h)$ possible $k$ values in the worst case if only via comparisons on $D(k)$; binary search is optimal up to constant factors. Each $D(k)$ must consider all $n-1$ gaps, yielding the $O(n\log h)$ time bound.}
\COMPLEXITY{$O(n\log h)$ time and $O(1)$ extra space per test case.}
\[
\begin{aligned}
T(n) &= O\bigl(n\log h\bigr). 
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def compute_damage(a, k):
    """Compute total damage for duration k."""
    total = 0
    for i in range(len(a) - 1):
        total += min(k, a[i + 1] - a[i])
    total += k
    return total

def minimal_k(a, h):
    """Binary search minimal k such that compute_damage(a, k) >= h."""
    lo, hi = 1, h  # hi is always sufficient since damage at least k each last segment
    while lo < hi:
        mid = (lo + hi) // 2
        if compute_damage(a, mid) >= h:
            hi = mid
        else:
            lo = mid + 1
    return lo

def read_input(data: str):
    it = iter(map(int, data.split()))
    try:
        t = next(it)
    except StopIteration:
        return 0, []
    cases = []
    for _ in range(t):
        n = next(it); h = next(it)
        arr = [next(it) for _ in range(n)]
        cases.append((n, h, arr))
    return t, cases

def solve_case(n, h, arr):
    return minimal_k(arr, h)

def solve_all(cases):
    out = []
    for n, h, arr in cases:
        out.append(str(solve_case(n, h, arr)))
    return "\n".join(out)

def main():
    data = sys.stdin.read().strip()
    if not data:
        return
    t, cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    # Exactly 3 asserts as mini-tests
    assert compute_damage([2, 4, 10], 4) == 10
    assert minimal_k([2, 4, 10], 10) == 4
    assert minimal_k([1, 3, 6, 7, 9], 12) == 4
    main()
\end{minted}
\VALIDATION{Assertions cover damage computation and two answer queries, including an $n=5$ crafted case.}
\RESULT{For each test case, the printed integer is the minimal $k$ such that total poison damage is at least $h$; ties are irrelevant since we choose the minimal feasible $k$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the damage function against hand-computed sums; test boundary $n=1$; test mixed gaps; test large $h$ upper bound logic by ensuring $k\le h$ is always sufficient.}
\LINE{CROSS-CHECKS}{Compare outputs of baseline (linear scan) and optimal (binary search) on small random-like fixed cases to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate deterministic edge cases: $n=1$; equal gaps; very large last gap; $h=1$; $h$ just below/above saturation $\sum \Delta_i$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    cases = []
    # Single attack
    cases.append((1, 7, [5], 7))
    # Example-like
    cases.append((3, 10, [2, 4, 10], 4))
    # Mixed gaps
    cases.append((5, 12, [1, 3, 6, 7, 9], 4))
    # h=1 minimal
    cases.append((4, 1, [1, 10, 20, 30], 1))
    # Saturation around sum of gaps + k
    # Here sum of gaps with k large is (9 + 1 + 5) + k; choose h to force a specific k
    cases.append((4, 15, [1, 10, 11, 16], 5))
    return cases

def reference_minimal_k(a, h):
    # binary search reference
    def damage(k):
        tot = 0
        for i in range(len(a) - 1):
            tot += min(k, a[i + 1] - a[i])
        return tot + k
    lo, hi = 1, h
    while lo < hi:
        mid = (lo + hi) // 2
        if damage(mid) >= h:
            hi = mid
        else:
            lo = mid + 1
    return lo

def baseline_minimal_k(a, h):
    # linear scan (safe for tiny tests)
    k = 1
    while True:
        tot = 0
        for i in range(len(a) - 1):
            tot += min(k, a[i + 1] - a[i])
        tot += k
        if tot >= h:
            return k
        k += 1

def run_tests():
    for n, h, arr, exp in gen_cases():
        got_ref = reference_minimal_k(arr, h)
        got_base = baseline_minimal_k(arr, h)
        assert got_ref == exp, (arr, h, got_ref, exp)
        assert got_base == exp, (arr, h, got_base, exp)

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def compute_damage(a, k):
    total = 0
    for i in range(len(a) - 1):
        total += min(k, a[i + 1] - a[i])
    total += k
    return total

def minimal_k(a, h):
    lo, hi = 1, h
    while lo < hi:
        mid = (lo + hi) // 2
        if compute_damage(a, mid) >= h:
            hi = mid
        else:
            lo = mid + 1
    return lo

def read_input(data: str):
    it = iter(map(int, data.split()))
    try:
        t = next(it)
    except StopIteration:
        return 0, []
    cases = []
    for _ in range(t):
        n = next(it); h = next(it)
        arr = [next(it) for _ in range(n)]
        cases.append((n, h, arr))
    return t, cases

def solve_case(n, h, arr):
    return minimal_k(arr, h)

def solve_all(cases):
    return "\n".join(str(solve_case(n, h, arr)) for n, h, arr in cases)

def main():
    data = sys.stdin.read().strip()
    if not data:
        return
    t, cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    # Sanity asserts
    assert compute_damage([2, 4, 10], 4) == 10
    assert minimal_k([2, 4, 10], 10) == 4
    assert minimal_k([1, 3, 6, 7, 9], 12) == 4
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sum truncated gaps plus the final $k$, then binary search the smallest $k$ with total damage at least $h$.}
\WHY{Classic monotone predicate with large search space; tests reasoning about overlaps and resetting effects.}
\CHECKLIST{
\begin{bullets}
\item Write $D(k)=\sum_{i=1}^{n-1}\min(k,\Delta_i)+k$.
\item Prove monotonicity of $D(k)$.
\item Set search bounds $[1,h]$.
\item Implement damage in $O(n)$ without overflow issues.
\item Binary search for minimal feasible $k$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ $\Rightarrow$ answer $h$.
\item Very large $h$ near $10^{18}$.
\item Large gaps vs. tiny gaps.
\item Consecutive attacks with $\Delta_i=1$.
\item Minimal $h=1$.
\item Attacks starting at $a_1=1$ vs. larger $a_1$ (irrelevant to formula).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting the final $+k$ term.
\item Using $>$ instead of $\ge$ in predicate.
\item Off-by-one in binary search updates.
\item Overflow in languages without big ints (use 128-bit or checks).
\item Misreading that effects overlap — they do not stack; they reset.
\item Wrong upper bound (use $h$ safely).
\end{bullets}}
\FAILMODES{Brute force on $k$ times $n$ can time out when $k$ is large; incorrect overlap handling double-counts damage; improper upper bound causes infinite loops in search. The proposed method avoids all by correct modeling and tight bounds.}
\ELI{Every stab starts a damage timer of length $k$, but a new stab restarts that timer so you only keep $k$ seconds from the latest stab. Add up the kept parts and binary search to find the smallest $k$ that reaches the required total damage.}
\NotePages{3}

\end{document}