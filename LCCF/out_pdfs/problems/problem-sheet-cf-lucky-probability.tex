% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lucky Probability}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/109/B}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya and his friend Vasya play an interesting game. Petya randomly chooses an integer $p$ from the interval $[p_l, p_r]$ and Vasya chooses an integer $v$ from the interval $[v_l, v_r]$ (also randomly). Both players choose their integers equiprobably. Find the probability that the interval $[\min(v, p), \max(v, p)]$ contains exactly $k$ lucky numbers.

Input:
The single line contains five integers $p_l$, $p_r$, $v_l$, $v_r$ and $k$ ($1 \le p_l \le p_r \le 10^9$, $1 \le v_l \le v_r \le 10^9$, $1 \le k \le 1000$).

Output:
On the single line print the result with an absolute error of no more than $10^{-9}$.

Note:
Consider that $[a, b]$ denotes an interval of integers; this interval includes the boundaries. That is, $[a,b] \stackrel{\mathrm{def}}{=} \{x \in \mathbb{R} : a \le x \le b\}$.

In first case there are 32 suitable pairs: $(1, 7)$, $(1, 8)$, $(1, 9)$, $(1, 10)$, $(2, 7)$, $(2, 8)$, $(2, 9)$, $(2, 10)$, $(3, 7)$, $(3, 8)$, $(3, 9)$, $(3, 10)$, $(4, 7)$, $(4, 8)$, $(4, 9)$, $(4, 10)$, $(7, 1)$, $(7, 2)$, $(7, 3)$, $(7, 4)$, $(8, 1)$, $(8, 2)$, $(8, 3)$, $(8, 4)$, $(9, 1)$, $(9, 2)$, $(9, 3)$, $(9, 4)$, $(10, 1)$, $(10, 2)$, $(10, 3)$, $(10, 4)$. Total number of possible pairs is $10 \cdot 10 = 100$, so answer is $32 / 100$.

In second case Petya always get number less than Vasya and the only lucky 7 is between these numbers, so there will be always 1 lucky number.}
\BREAKDOWN{Generate all lucky numbers, then count the number of ordered pairs $(p,v)$ such that $[\min(p,v),\max(p,v)]$ contains exactly $k$ of them. Use inclusion ranges around consecutive lucky numbers to count pairs in $O(L)$ where $L$ is the count of lucky numbers.}
\ELI{Exactly $k$ lucky numbers appear between the two chosen points iff the smaller one lands just before the first of a block of $k$ lucky numbers and the larger one lands just after the last, while not crossing into the neighboring lucky numbers.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Five integers $p_l, p_r, v_l, v_r, k$ with $1 \le p_l \le p_r \le 10^9$, $1 \le v_l \le v_r \le 10^9$, $1 \le k \le 1000$.}
\OUTPUTS{A single real number: the desired probability, with absolute error at most $10^{-9}$.}
\SAMPLES{Example 1: $p_l=1, p_r=10, v_l=1, v_r=10, k=2 \Rightarrow 0.32$. Example 2: $p_l=1, p_r=3, v_l=8, v_r=10, k=1 \Rightarrow 1.0$ since the only lucky $7$ lies between any such pair.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathcal{L}=\{ \ell_1 < \ell_2 < \cdots < \ell_m\}$ be all lucky numbers in $[1,10^9]$. Two integers $p \sim \mathrm{Unif}[p_l,p_r]$ and $v \sim \mathrm{Unif}[v_l,v_r]$ are chosen independently and uniformly over integers. We want $\mathbb{P}\big(\#\{\ell \in \mathcal{L} : \min(p,v) \le \ell \le \max(p,v)\}=k\big)$.}
\varmapStart
\var{p_l,p_r}{Petya's interval endpoints}
\var{v_l,v_r}{Vasya's interval endpoints}
\var{k}{Target count of lucky numbers inside the closed segment}
\var{\mathcal{L}}{Sorted list of lucky numbers}
\var{N_P}{Number of integers in $[p_l,p_r]$}
\var{N_V}{Number of integers in $[v_l,v_r]$}
\var{W_i}{Window of $k$ consecutive luckies $(\ell_i,\ldots,\ell_{i+k-1})$}
\varmapEnd
\GOVERN{
\[
\text{Let }N = N_P \cdot N_V.
\quad
\text{For each }i,\ 1 \le i \le m-k+1:
\]
\[
\begin{aligned}
L^-_i &= \ell_{i-1}+1\ \ (\text{or }-\infty\text{ if }i=1), & L^+_i &= \ell_i,\\
R^-_i &= \ell_{i+k-1}, & R^+_i &= \ell_{i+k}-1\ \ (\text{or }+\infty\text{ if }i+k>m).
\end{aligned}
\]
\begin{BreakableEquation*}
\text{Valid pairs are those with } \min(p,v) \in [L^-_i,L^+_i],\ \max(p,v) \in [R^-_i,R^+_i],
\end{BreakableEquation*}
\[
\text{counted as}\
\#P([L^-_i,L^+_i])\cdot \#V([R^-_i,R^+_i])\ +\ \#V([L^-_i,L^+_i])\cdot \#P([R^-_i,R^+_i]),
\]
\begin{BreakableEquation*}
\text{and for }k=1\text{ subtract }1\text{ if }\ell_i\in [p_l,p_r]\cap [v_l,v_r]\text{ (to avoid double counting the pair }(p,v)=(\ell_i,\ell_i)).
\end{BreakableEquation*}
}
\ASSUMPTIONS{All intervals are closed on integers. If a bound is $\pm\infty$, intersections with $[p_l,p_r]$ and $[v_l,v_r]$ clip it to finite ranges.}
\INVARIANTS{
- The $k$ lucky numbers inside the segment must be a contiguous block in $\mathcal{L}$.
- Excluding neighbors $\ell_{i-1}$ and $\ell_{i+k}$ ensures the count is exactly $k$ (not more).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all ordered pairs $(p,v)$; for each, count luckies in the segment via precomputed sorted $\mathcal{L}$ using binary search.}
\ASSUMPTIONS{This is only feasible when the intervals are tiny (for validation).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate all lucky numbers $\mathcal{L}$ up to $10^{10}$ to safely cover $10^9$.
\item For each $p \in [p_l,p_r]$ and $v \in [v_l,v_r]$: compute $a=\min(p,v)$ and $b=\max(p,v)$, then $c=\#\{\ell\in\mathcal{L}: a \le \ell \le b\}$ by binary searches.
\item Count how many ordered pairs yield $c=k$; divide by $(p_r-p_l+1)(v_r-v_l+1)$.
\end{algosteps}
\COMPLEXITY{Brute force over all pairs.}
\[
\begin{aligned}
T(n) &= (p_r-p_l+1)\cdot(v_r-v_l+1)\cdot O(\log L) \\
     &= O(N_P N_V \log L),\quad S(n)=O(L).
\end{aligned}
\]
\CORRECTNESS{Directly checks the definition per pair; uses binary search counts for correctness.}
\EDGECASES{No lucky in range; $k$ larger than available; overlapping endpoints; identical picks $p=v$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from bisect import bisect_left, bisect_right

def generate_lucky(limit=10**10):
    res = []
    def dfs(x):
        if x > limit:
            return
        if x > 0:
            res.append(x)
        dfs(x*10 + 4)
        dfs(x*10 + 7)
    dfs(0)
    res.sort()
    return res

LUCKY = generate_lucky(10**10)

def count_lucky_between(a, b, LUCKY=LUCKY):
    if a > b:
        a, b = b, a
    i = bisect_left(LUCKY, a)
    j = bisect_right(LUCKY, b)
    return j - i

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    if not data:
        return None
    pl, pr, vl, vr, k = map(int, data[:5])
    return pl, pr, vl, vr, k

def solve_case(pl, pr, vl, vr, k):
    total = (pr - pl + 1) * (vr - vl + 1)
    good = 0
    for p in range(pl, pr + 1):
        for v in range(vl, vr + 1):
            c = count_lucky_between(min(p, v), max(p, v))
            if c == k:
                good += 1
    return good / total if total else 0.0

def main():
    args = read_input()
    if args is None:
        # Self-test on tiny ranges
        assert abs(solve_case(1, 3, 1, 3, 0) - 1.0) < 1e-12
        # Lucky numbers up to 10 are 4 and 7; exactly 2 in between requires one on [1,4] and the other on [7,10]
        ans = solve_case(1, 10, 1, 10, 2)
        assert abs(ans - 0.32) < 1e-12
        print("OK")
    else:
        pl, pr, vl, vr, k = args
        print("{:.12f}".format(solve_case(pl, pr, vl, vr, k)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Two asserts on tiny domains, including a case with no lucky numbers and the canonical $0.32$ result for $k=2$ over $[1,10] \times [1,10]$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prefix Counts for Intervals}
\WHICHFORMULA{Use binary search on $\mathcal{L}$ to get $F(a,b)=\#\{\ell\in\mathcal{L}: a\le \ell\le b\}$ quickly, and for a fixed endpoint, find admissible ranges of the other endpoint that yield exactly $k$.}
\ASSUMPTIONS{Still too slow in the worst case if we sweep every integer endpoint, but much faster than naive when ranges are modest.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\mathcal{L}$.
\item For each $p \in [p_l,p_r]$, via binary searches on $\mathcal{L}$, determine disjoint ranges of $v$ such that $F(\min(p,v),\max(p,v))=k$.
\item Sum lengths of these ranges for all $p$; divide by the total number of pairs.
\end{algosteps}
\COMPLEXITY{Let $N_P=p_r-p_l+1$, $N_V=v_r-v_l+1$, and $L=\lvert \mathcal{L}\rvert$.}
\[
\begin{aligned}
T(n) &= O\big(N_P \log L + \text{(# of ranges)}\big), \\
\end{aligned}
\]
\CORRECTNESS{By monotonicity of $F$ in each endpoint, each $p$ induces at most $O(L)$ breakpoints where the count changes.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from bisect import bisect_left, bisect_right

def generate_lucky(limit=10**10):
    res = []
    def dfs(x):
        if x > limit:
            return
        if x > 0:
            res.append(x)
        dfs(x*10 + 4)
        dfs(x*10 + 7)
    dfs(0)
    res.sort()
    return res

LUCKY = generate_lucky(10**10)

def count_lucky_between(a, b, LUCKY=LUCKY):
    if a > b:
        a, b = b, a
    i = bisect_left(LUCKY, a)
    j = bisect_right(LUCKY, b)
    return j - i

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    if not data:
        return None
    pl, pr, vl, vr, k = map(int, data[:5])
    return pl, pr, vl, vr, k

def solve_case(pl, pr, vl, vr, k):
    # Semi-optimized: if ranges are large, fall back to optimal window method; else do per-p sweep.
    NP = pr - pl + 1
    NV = vr - vl + 1
    if NP * NV > 200000:  # safety for speed
        return solve_optimal(pl, pr, vl, vr, k)
    good = 0
    for p in range(pl, pr + 1):
        # For v on the left of p
        lo, hi = vl, min(vr, p)
        # Sweep contiguous segments where count changes only at lucky boundaries
        # We step over candidate breakpoints derived from LUCKY and p
        bps = set([lo, hi + 1])
        for x in LUCKY:
            bps.add(max(lo, min(hi + 1, x)))
            bps.add(max(lo, min(hi + 1, x + 1)))
        segs = sorted(bps)
        for a, b in zip(segs, segs[1:]):
            if a > hi or a >= b:
                continue
            mid = a
            c = count_lucky_between(mid, p)
            if c == k:
                good += (min(b - 1, hi) - a + 1)
        # For v on the right of p
        lo, hi = max(vl, p), vr
        bps = set([lo, hi + 1])
        for x in LUCKY:
            bps.add(max(lo, min(hi + 1, x)))
            bps.add(max(lo, min(hi + 1, x + 1)))
        segs = sorted(bps)
        for a, b in zip(segs, segs[1:]):
            if a > hi or a >= b:
                continue
            mid = a
            c = count_lucky_between(p, mid)
            if c == k:
                good += (min(b - 1, hi) - a + 1)
    total = NP * NV
    return good / total if total else 0.0

def solve_optimal(pl, pr, vl, vr, k):
    # Delegate to optimal method below (reused in Approach C)
    return solve_window(pl, pr, vl, vr, k)

def solve_window(pl, pr, vl, vr, k):
    INF = 10**18
    L = LUCKY
    m = len(L)
    total_pairs = (pr - pl + 1) * (vr - vl + 1)
    if total_pairs == 0:
        return 0.0
    if k > m:
        return 0.0

    def cnt_in(a, b, lo, hi):
        lo2 = max(a, lo)
        hi2 = min(b, hi)
        if lo2 > hi2:
            return 0
        return hi2 - lo2 + 1

    good = 0
    for i in range(0, m - k + 1):
        left_lo = L[i - 1] + 1 if i > 0 else -INF
        left_hi = L[i]
        right_lo = L[i + k - 1]
        right_hi = L[i + k] - 1 if (i + k) < m else INF

        a = cnt_in(pl, pr, left_lo, left_hi) * cnt_in(vl, vr, right_lo, right_hi)
        b = cnt_in(vl, vr, left_lo, left_hi) * cnt_in(pl, pr, right_lo, right_hi)
        good += a + b

        if k == 1:
            x = L[i]
            if pl <= x <= pr and vl <= x <= vr:
                good -= 1  # remove double-count of (x,x)

    return good / total_pairs

def main():
    args = read_input()
    if args is None:
        # Cross-check with brute on tiny cases
        for pl in range(1, 6):
            for pr in range(pl, min(6, pl + 2)):
                for vl in range(1, 6):
                    for vr in range(vl, min(6, vl + 2)):
                        for k in range(0, 4):
                            brute = 0.0
                            # small brute to confirm
                            total = (pr - pl + 1) * (vr - vl + 1)
                            g = 0
                            for p in range(pl, pr + 1):
                                for v in range(vl, vr + 1):
                                    if count_lucky_between(min(p, v), max(p, v)) == k:
                                        g += 1
                            brute = g / total if total else 0.0
                            fast = solve_optimal(pl, pr, vl, vr, k)
                            assert abs(brute - fast) < 1e-12
        print("OK")
    else:
        pl, pr, vl, vr, k = args
        print("{:.12f}".format(solve_optimal(pl, pr, vl, vr, k)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Cross-checks against brute force on many tiny intervals; asserts ensure exact agreement.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sliding Window over Consecutive Lucky Numbers}
\WHICHFORMULA{For each consecutive block of $k$ lucky numbers $(\ell_i,\ldots,\ell_{i+k-1})$, the valid endpoints are:
- the smaller endpoint in $[\ell_{i-1}+1,\ \ell_i]$,
- the larger endpoint in $[\ell_{i+k-1},\ \ell_{i+k}-1]$,
clipped to $[p_l,p_r]$ and $[v_l,v_r]$; sum ordered pairs for both orientations and adjust the $k=1$ diagonal.}
\ASSUMPTIONS{Applies since lucky numbers are totally ordered and the count inside a segment changes only when passing a lucky.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate and sort all lucky numbers up to $10^{10}$.
\item For each $i=1$ to $m-k+1$, compute left range $[L^-_i,L^+_i]$ and right range $[R^-_i,R^+_i]$ using neighbors $\ell_{i-1}$ and $\ell_{i+k}$ (treat missing neighbors as $\pm\infty$).
\item Add counts of ordered pairs with $p$ left \& $v$ right plus $v$ left \& $p$ right, then if $k=1$, subtract the diagonal pair $(\ell_i,\ell_i)$ if both intervals contain $\ell_i$.
\end{algosteps}
\OPTIMALITY{We examine $O(m)$ windows where $m \le 1023$. Each window contributes in $O(1)$ time, so total is $O(m)$ independent of interval lengths; this is information-theoretically optimal up to the size of $\mathcal{L}$.}
\COMPLEXITY{Let $m=\lvert\mathcal{L}\rvert \le 1023$.}
\[
\begin{aligned}
T(n) &= O(m), \quad S(n) = O(m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def generate_lucky(limit=10**10):
    res = []
    def dfs(x):
        if x > limit:
            return
        if x > 0:
            res.append(x)
        dfs(x*10 + 4)
        dfs(x*10 + 7)
    dfs(0)
    res.sort()
    return res

LUCKY = generate_lucky(10**10)

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    if not data:
        return None
    pl, pr, vl, vr, k = map(int, data[:5])
    return pl, pr, vl, vr, k

def count_in_range(a, b, lo, hi):
    lo2 = max(a, lo)
    hi2 = min(b, hi)
    if lo2 > hi2:
        return 0
    return hi2 - lo2 + 1

def solve_all(pl, pr, vl, vr, k):
    INF = 10**18
    L = LUCKY
    m = len(L)
    total_pairs = (pr - pl + 1) * (vr - vl + 1)
    if total_pairs == 0 or k > m:
        return 0.0

    good = 0
    for i in range(0, m - k + 1):
        left_lo = L[i - 1] + 1 if i > 0 else -INF
        left_hi = L[i]
        right_lo = L[i + k - 1]
        right_hi = L[i + k] - 1 if (i + k) < m else INF

        a = count_in_range(pl, pr, left_lo, left_hi) * count_in_range(vl, vr, right_lo, right_hi)
        b = count_in_range(vl, vr, left_lo, left_hi) * count_in_range(pl, pr, right_lo, right_hi)
        good += a + b

        if k == 1:
            x = L[i]
            if pl <= x <= pr and vl <= x <= vr:
                good -= 1  # remove double counting of (x, x)

    return good / total_pairs

def main():
    args = read_input()
    if args is None:
        # Exactly 3 asserts / mini-tests
        assert abs(solve_all(1, 10, 1, 10, 2) - 0.32) < 1e-12
        assert abs(solve_all(1, 3, 1, 3, 0) - 1.0) < 1e-12
        # If k is larger than possible, probability is 0
        assert abs(solve_all(1, 5, 6, 10, 5) - 0.0) < 1e-12
        print("OK")
    else:
        pl, pr, vl, vr, k = args
        ans = solve_all(pl, pr, vl, vr, k)
        print("{:.12f}".format(ans))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts: canonical $0.32$ case; zero-lucky everywhere case; and an impossible $k$ case.}
\RESULT{Print the probability that the closed integer segment between the two picks contains exactly $k$ lucky numbers; ties and orientations are handled as ordered pairs.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit asserts on canonical cases; property tests comparing optimal vs brute on tiny intervals; edge tests where $k=0$ or $k$ exceeds the number of luckies.}
\LINE{CROSS-CHECKS}{Compare brute force (Approach A) with optimal (Approach C) on many tiny ranges; ensure exact equality.}
\LINE{EDGE-CASE GENERATOR}{Deterministically enumerates short intervals to stress boundaries at lucky numbers and immediate neighbors.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from itertools import product

def tiny_cases():
    vals = [1, 2, 3, 4, 7, 8, 9, 10]
    for pl in vals:
        for pr in vals:
            if pl > pr: continue
            for vl in vals:
                for vr in vals:
                    if vl > vr: continue
                    for k in range(0, 4):
                        yield pl, pr, vl, vr, k

def brute_prob(pl, pr, vl, vr, k, LUCKY):
    from bisect import bisect_left, bisect_right
    def cnt(a, b):
        i = bisect_left(LUCKY, a)
        j = bisect_right(LUCKY, b)
        return j - i
    total = (pr - pl + 1) * (vr - vl + 1)
    good = 0
    for p in range(pl, pr + 1):
        for v in range(vl, vr + 1):
            a, b = (p, v) if p <= v else (v, p)
            if cnt(a, b) == k:
                good += 1
    return good / total if total else 0.0

def optimal_prob(pl, pr, vl, vr, k):
    return solve_all(pl, pr, vl, vr, k)

# Cross-check on tiny set
for case in list(tiny_cases())[:200]:
    pl, pr, vl, vr, k = case
    b = brute_prob(pl, pr, vl, vr, k, LUCKY)
    f = optimal_prob(pl, pr, vl, vr, k)
    assert abs(b - f) < 1e-12
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def generate_lucky(limit=10**10):
    res = []
    def dfs(x):
        if x > limit:
            return
        if x > 0:
            res.append(x)
        dfs(x*10 + 4)
        dfs(x*10 + 7)
    dfs(0)
    res.sort()
    return res

LUCKY = generate_lucky(10**10)

def count_in_range(a, b, lo, hi):
    lo2 = max(a, lo)
    hi2 = min(b, hi)
    if lo2 > hi2:
        return 0
    return hi2 - lo2 + 1

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    if not data:
        return None
    pl, pr, vl, vr, k = map(int, data[:5])
    return pl, pr, vl, vr, k

def solve_all(pl, pr, vl, vr, k):
    INF = 10**18
    L = LUCKY
    m = len(L)
    total_pairs = (pr - pl + 1) * (vr - vl + 1)
    if total_pairs == 0 or k > m:
        return 0.0

    good = 0
    for i in range(0, m - k + 1):
        left_lo = L[i - 1] + 1 if i > 0 else -INF
        left_hi = L[i]
        right_lo = L[i + k - 1]
        right_hi = L[i + k] - 1 if (i + k) < m else INF

        a = count_in_range(pl, pr, left_lo, left_hi) * count_in_range(vl, vr, right_lo, right_hi)
        b = count_in_range(vl, vr, left_lo, left_hi) * count_in_range(pl, pr, right_lo, right_hi)
        good += a + b

        if k == 1:
            x = L[i]
            if pl <= x <= pr and vl <= x <= vr:
                good -= 1

    return good / total_pairs

def main():
    args = read_input()
    if args is None:
        # Minimal smoke tests
        assert abs(solve_all(1, 10, 1, 10, 2) - 0.32) < 1e-12
        assert abs(solve_all(1, 3, 1, 3, 0) - 1.0) < 1e-12
        print("OK")
    else:
        pl, pr, vl, vr, k = args
        print("{:.12f}".format(solve_all(pl, pr, vl, vr, k)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count ordered pairs by sliding over contiguous blocks of $k$ lucky numbers and composing endpoint ranges.}
\WHY{This pattern (counting segments by critical landmarks) appears in probability, combinatorics on intervals, and number-theory flavored CF problems.}
\CHECKLIST{
- Generate all luckies up to a safe limit.
- Iterate windows of $k$ consecutive luckies.
- Build left/right endpoint ranges using neighbors.
- Intersect with $[p_l,p_r]$ and $[v_l,v_r]$.
- Sum both orientations; adjust the $k=1$ diagonal.
- Divide by total ordered pairs; print with enough precision.}
\EDGECASES{
- $k=0$: not required here by constraints but useful for testing.
- $k=1$: ensure subtracting the $(\ell_i,\ell_i)$ double count.
- No lucky numbers in any relevant span.
- Intervals degenerate to a point.
- One interval wholly to the left/right of all luckies.
- Very large intervals hitting sentinels ($\pm\infty$ handling via clipping).}
\PITFALLS{
- Forgetting the $k=1$ double-count fix when both choose the same lucky.
- Using open instead of closed integer intervals (off-by-one at ends).
- Overflow in languages with fixed-width integers (use 128-bit or Python int).
- Generating insufficient luckies (must cover up to the next neighbor).
- Mishandling empty intersections when clipping ranges.
- Printing with insufficient precision.}
\FAILMODES{Pairwise enumeration times out for large intervals; mid-level sweeps per endpoint also fail at worst case. The window method is robust to interval sizes.}
\ELI{Lucky counts only change at lucky numbers. So we anchor on the first and last lucky that must be inside, prevent neighbors from sneaking in, and just count how many ways the two players can land on the allowed sides.}
\NotePages{3}

\end{document}