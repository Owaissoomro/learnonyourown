% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Sales by Day of the Week}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/sales-by-day-of-the-week/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a finite multiset of sales records. Each record consists of a calendar date in the ISO format \texttt{YYYY-MM-DD} and a nonnegative integer sale amount. Aggregate the total sales for each day of the week and return seven totals ordered from Monday to Sunday. If no sale occurs on a given weekday, its total is 0. Dates are valid Gregorian dates.}
\BREAKDOWN{We must compute the weekday for each date, bucket sale amounts into 7 bins (Monday index 0 through Sunday index 6), and output the sums in that fixed order.}
\ELI{Turn a list of dated sale amounts into seven sums: one per weekday, Monday first, filling missing days with zeros.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list \texttt{transactions} of length $n$ where each element is a pair \texttt{(date\_str, amount)}: \texttt{date\_str} is a string in \texttt{YYYY-MM-DD}; \texttt{amount} is an integer with $0 \le \texttt{amount} \le 10^9$. $0 \le n \le 2\cdot 10^5$.}
\OUTPUTS{A list of seven integers \texttt{totals} where \texttt{totals[0]} is the sum for Monday, \texttt{totals[1]} for Tuesday, \ldots, \texttt{totals[6]} for Sunday.}
\SAMPLES{
Example 1: \texttt{[("2023-01-02", 10), ("2023-01-08", 5)]} $\to$ \texttt{[10,0,0,0,0,0,5]} since 2023-01-02 is Monday and 2023-01-08 is Sunday.

Example 2: \texttt{[("2024-02-28", 7), ("2024-02-29", 3), ("2024-03-01", 4)]} $\to$ \texttt{[0,0,0,10,4,0,0]} because Wed+Thu totals 10 and Fri is 4.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the input be $\{(d_i,a_i)\}_{i=1}^n$ where $d_i$ is a Gregorian date and $a_i \in \mathbb{Z}_{\ge 0}$. Let $w:\text{Date}\to\{0,\ldots,6\}$ map a date to its weekday index with Monday $=0$ and Sunday $=6$. We seek $S\in\mathbb{Z}_{\ge 0}^7$ such that for each $k\in\{0,\ldots,6\}$,
\begin{BreakableEquation*}
S_k=\sum_{i=1}^n a_i\cdot \mathbf{1}\{w(d_i)=k\}.
\end{BreakableEquation*}
Return $(S_0,S_1,\ldots,S_6)$.
}
\varmapStart
\var{n}{number of sales records}
\var{d_i}{the $i$-th date}
\var{a_i}{the $i$-th nonnegative sale amount}
\var{w(d)}{weekday index of $d$ with Monday $=0$, \ldots, Sunday $=6$}
\var{S_k}{total sales on weekday $k$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall k\in\{0,\ldots,6\}:\quad S_k=\sum_{i=1}^n a_i\,\mathbf{1}\{w(d_i)=k\},\qquad \text{output } (S_0,\ldots,S_6).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Dates are valid Gregorian dates; amounts are integers $\ge 0$; the output must enumerate all weekdays in fixed Monday$\to$Sunday order.}
\INVARIANTS{The sum of all $S_k$ equals $\sum_{i=1}^n a_i$. Each record contributes exactly once to exactly one weekday bucket.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use a standard library weekday function to compute $w(d)$ for each date, then add the amount into an array of length 7.}
\ASSUMPTIONS{The standard library correctly handles leap years and Gregorian calendar transitions.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{totals} as a list of seven zeros.
\item For each \texttt{(date\_str, amount)}:
  \begin{itemize}
  \item Parse the date string into year, month, day.
  \item Use \texttt{datetime.date(year, month, day).weekday()} to get Monday $=0$ through Sunday $=6$.
  \item Add \texttt{amount} to \texttt{totals[weekday]}.
  \end{itemize}
\item Return \texttt{totals}.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(n)$ for iterating and parsing; space $S(n)=\Theta(1)$ auxiliary besides the fixed-size 7-array.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^n O(1) = O(n), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Each record is mapped to exactly one weekday via the library function; accumulation is associative and commutative; zero-initialized bins ensure missing weekdays remain 0.}
\EDGECASES{Empty input; all sales on the same weekday; leap day such as 2024-02-29; month and year boundaries.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
from datetime import date

class Solution:
    def salesByDayOfWeek(self, transactions: List[Tuple[str, int]]) -> List[int]:
        totals = [0] * 7  # Monday=0 ... Sunday=6
        for ds, amount in transactions:
            y = int(ds[0:4]); m = int(ds[5:7]); d = int(ds[8:10])
            w = date(y, m, d).weekday()  # Monday=0 ... Sunday=6
            totals[w] += amount
        return totals

# Basic asserts
if __name__ == "__main__":
    s = Solution()
    assert s.salesByDayOfWeek([]) == [0,0,0,0,0,0,0]
    assert s.salesByDayOfWeek([("2023-01-02", 10), ("2023-01-08", 5)]) == [10,0,0,0,0,0,5]
    assert s.salesByDayOfWeek([("2024-02-28", 7), ("2024-02-29", 3), ("2024-03-01", 4)]) == [0,0,0,10,4,0,0]
\end{minted}
\VALIDATION{Validated on empty input; distinct weekdays; a leap-year span to ensure weekday mapping and leap day handling are correct.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Replace library calls with a branch-free arithmetic weekday function (Sakamoto's algorithm), reducing overhead in tight loops and avoiding per-record object allocations.}
\ASSUMPTIONS{Dates are Gregorian; we use a well-known integer formula for weekday with Sunday $=0$ then remap to Monday $=0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Implement \texttt{weekday\_ymd(y,m,d)} using Sakamoto's algorithm that returns Sunday $=0$ to Saturday $=6$.
\item Remap to Monday $=0$ by computing $(w+6)\bmod 7$.
\item Accumulate into a fixed-size array of 7 integers.
\end{algosteps}
\COMPLEXITY{Same asymptotic bounds as baseline, but with lower constant factors by avoiding library date construction.}
\[
\begin{aligned}
T(n) &= O(n), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Sakamoto's algorithm is equivalent to Gregorian weekday computation. The remapping preserves the Monday-first convention.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def _weekday_ymd_monday0(self, y: int, m: int, d: int) -> int:
        # Sakamoto's algorithm: w (Sunday=0 .. Saturday=6)
        t = [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]
        y2 = y - 1 if m < 3 else y
        w_sun0 = (y2 + y2 // 4 - y2 // 100 + y2 // 400 + t[m - 1] + d) % 7
        # Convert Sunday=0..Saturday=6 to Monday=0..Sunday=6
        return (w_sun0 + 6) % 7

    def salesByDayOfWeek(self, transactions: List[Tuple[str, int]]) -> List[int]:
        totals = [0] * 7
        for ds, amount in transactions:
            y = int(ds[0:4]); m = int(ds[5:7]); d = int(ds[8:10])
            w = self._weekday_ymd_monday0(y, m, d)
            totals[w] += amount
        return totals

# Asserts
if __name__ == "__main__":
    s = Solution()
    # Known dates: 2023-01-02 is Monday (index 0), 2023-01-08 is Sunday (index 6)
    assert s.salesByDayOfWeek([("2023-01-02", 1), ("2023-01-08", 2)]) == [1,0,0,0,0,0,2]
    # Leap year 2000-02-29 (Tuesday) and 1900-01-01 (Monday, but 1900 not leap)
    assert s.salesByDayOfWeek([("2000-02-29", 3), ("1900-01-01", 4)]) == [4,3,0,0,0,0,0]
    # Empty
    assert s.salesByDayOfWeek([]) == [0,0,0,0,0,0,0]
\end{minted}
\VALIDATION{Checked Gregorian century rules (1900 non-leap, 2000 leap) and mapping to Monday-first indexing.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{The output inherently requires aggregating all $n$ records, so $O(n)$ time and $O(1)$ extra space beyond seven bins is optimal. Use a branch-free integer weekday and a tight loop.}
\ASSUMPTIONS{Dates are valid and in \texttt{YYYY-MM-DD}. Integer arithmetic in Python is exact for the required ranges.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a 7-length list of zeros.
\item For each transaction, parse integers for year, month, day.
\item Compute weekday via integer arithmetic and remap to Monday-first.
\item Add the amount to the corresponding bin.
\item Return the seven-bin list.
\end{algosteps}
\OPTIMALITY{Any correct method must inspect each input record at least once, implying a lower bound of $\Omega(n)$ time. The seven-bin accumulator is asymptotically minimal extra space.}
\COMPLEXITY{Linear-time single pass with constant extra space.}
\[
\begin{aligned}
T(n) &= \Theta(n), \\
S(n) &= \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    @staticmethod
    def _weekday_monday0(y: int, m: int, d: int) -> int:
        # Sakamoto's algorithm, then remap to Monday=0..Sunday=6
        t = (0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4)
        y2 = y - 1 if m < 3 else y
        w_sun0 = (y2 + y2 // 4 - y2 // 100 + y2 // 400 + t[m - 1] + d) % 7
        return (w_sun0 + 6) % 7

    def salesByDayOfWeek(self, transactions: List[Tuple[str, int]]) -> List[int]:
        totals = [0, 0, 0, 0, 0, 0, 0]
        for ds, amount in transactions:
            # Parse 'YYYY-MM-DD' quickly with slicing (assumes valid input)
            y = (ord(ds[0]) - 48) * 1000 + (ord(ds[1]) - 48) * 100 + (ord(ds[2]) - 48) * 10 + (ord(ds[3]) - 48)
            m = (ord(ds[5]) - 48) * 10 + (ord(ds[6]) - 48)
            d = (ord(ds[8]) - 48) * 10 + (ord(ds[9]) - 48)
            w = self._weekday_monday0(y, m, d)
            totals[w] += amount
        return totals

# Exactly 3 asserts
if __name__ == "__main__":
    s = Solution()
    assert s.salesByDayOfWeek([("2023-01-02", 10), ("2023-01-08", 5)]) == [10,0,0,0,0,0,5]
    assert s.salesByDayOfWeek([("2024-02-28", 7), ("2024-02-29", 3), ("2024-03-01", 4)]) == [0,0,0,10,4,0,0]
    assert s.salesByDayOfWeek([]) == [0,0,0,0,0,0,0]
\end{minted}
\VALIDATION{The three asserts cover basic mapping, leap-day handling across month boundary, and empty input.}
\RESULT{Return the seven totals as a Python list \texttt{[Mon,Tue,Wed,Thu,Fri,Sat,Sun]}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: empty list; all records on one weekday; uniform distribution; leap years (including century rules); month/year boundaries. Property: sum of output equals sum of inputs.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach A (library weekday) vs Approach B/C (integer weekday) on randomly generated valid dates; they must match.}
\LINE{EDGE-CASE GENERATOR}{Generate dates near leap days (e.g., 1999-02-28, 2000-02-29, 2000-03-01), end-of-month, and end-of-year to stress weekday computations.}
\begin{minted}{python}
from typing import List, Tuple
import random

def gen_transactions(seed: int = 0, n: int = 200) -> List[Tuple[str, int]]:
    random.seed(seed)
    def is_leap(y: int) -> bool:
        return (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0)
    res = []
    for _ in range(n):
        y = random.randint(1990, 2030)
        m = random.randint(1, 12)
        if m in (1,3,5,7,8,10,12):
            mdays = 31
        elif m in (4,6,9,11):
            mdays = 30
        else:
            mdays = 29 if is_leap(y) else 28
        d = random.randint(1, mdays)
        ds = f"{y:04d}-{m:02d}-{d:02d}"
        amt = random.randint(0, 1000)
        res.append((ds, amt))
    return res

# Reference using datetime for cross-check
from datetime import date
def ref_group(transactions: List[Tuple[str, int]]) -> List[int]:
    totals = [0] * 7
    for ds, a in transactions:
        y = int(ds[0:4]); m = int(ds[5:7]); d = int(ds[8:10])
        w = date(y, m, d).weekday()
        totals[w] += a
    return totals

class Solution:
    @staticmethod
    def _weekday_monday0(y: int, m: int, d: int) -> int:
        t = (0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4)
        y2 = y - 1 if m < 3 else y
        w_sun0 = (y2 + y2 // 4 - y2 // 100 + y2 // 400 + t[m - 1] + d) % 7
        return (w_sun0 + 6) % 7

    def salesByDayOfWeek(self, transactions: List[Tuple[str, int]]) -> List[int]:
        totals = [0] * 7
        for ds, amount in transactions:
            y = int(ds[0:4]); m = int(ds[5:7]); d = int(ds[8:10])
            w = self._weekday_monday0(y, m, d)
            totals[w] += amount
        return totals

# Cross-check small random batches
if __name__ == "__main__":
    for seed in range(5):
        tx = gen_transactions(seed, n=500)
        s = Solution()
        assert s.salesByDayOfWeek(tx) == ref_group(tx)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    @staticmethod
    def _weekday_monday0(y: int, m: int, d: int) -> int:
        # Sakamoto's algorithm with Monday-first remap
        t = (0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4)
        y2 = y - 1 if m < 3 else y
        w_sun0 = (y2 + y2 // 4 - y2 // 100 + y2 // 400 + t[m - 1] + d) % 7
        return (w_sun0 + 6) % 7

    def salesByDayOfWeek(self, transactions: List[Tuple[str, int]]) -> List[int]:
        totals = [0, 0, 0, 0, 0, 0, 0]
        for ds, amount in transactions:
            y = (ord(ds[0]) - 48) * 1000 + (ord(ds[1]) - 48) * 100 + (ord(ds[2]) - 48) * 10 + (ord(ds[3]) - 48)
            m = (ord(ds[5]) - 48) * 10 + (ord(ds[6]) - 48)
            d = (ord(ds[8]) - 48) * 10 + (ord(ds[9]) - 48)
            w = self._weekday_monday0(y, m, d)
            totals[w] += amount
        return totals

# Sanity checks
if __name__ == "__main__":
    s = Solution()
    assert s.salesByDayOfWeek([]) == [0,0,0,0,0,0,0]
    assert s.salesByDayOfWeek([("2023-01-02", 1)]) == [1,0,0,0,0,0,0]
    assert s.salesByDayOfWeek([("2023-01-08", 5)]) == [0,0,0,0,0,0,5]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Map each dated sale to its weekday and sum into seven bins ordered Monday through Sunday.}
\WHY{Common in analytics: weekly cohorts, dashboards, and report pivots; tests weekday math and careful indexing.}
\CHECKLIST{
\begin{bullets}
\item Parse date safely and efficiently.
\item Compute weekday with correct calendar rules.
\item Use Monday $=0$ ordering consistently.
\item Initialize seven bins; include zeros for missing days.
\item Verify $\sum \text{output} = \sum \text{inputs}$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Empty input.
\item All transactions on one weekday.
\item Leap day (e.g., 2024-02-29).
\item Century rules (1900 non-leap, 2000 leap).
\item Month boundary (e.g., 2023-01-31 to 2023-02-01).
\item Year boundary (e.g., 2022-12-31 to 2023-01-01).
\item Very large amounts but within 64-bit range.
\item Repeated dates.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Mixing weekday conventions (Sunday-first vs Monday-first).
\item Off-by-one in remapping Sunday $=0$ to Monday $=0$.
\item Relying on locale-dependent APIs instead of calendar math.
\item Creating per-record datetime objects causing slowdowns.
\item Misparsing date strings or accepting malformed input.
\item Forgetting zeros for weekdays with no sales.
\item Integer overflow in other languages without big ints.
\item Assuming every month has 30 or 31 days in custom parsers.
\end{bullets}
}
\FAILMODES{Implementations that assume Sunday-first indices will return a rotated vector. Naive leap-year checks that treat 1900 as leap will miscompute weekdays.}
\ELI{We are bucketing numbers by the day of the week. The only tricky bit is getting the weekday right and keeping the Monday-first order. Everything else is simple addition.}
\NotePages{3}

\end{document}