% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Monocarp and a Strategic Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1841/F}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{Monocarp plays a strategic computer game in which he develops a city. The city is inhabited by creatures of four different races — humans, elves, orcs, and dwarves.

Each inhabitant of the city has a happiness value, which is an integer. It depends on how many creatures of different races inhabit the city. Specifically, the happiness of each inhabitant is $0$ by default; it increases by $1$ for each other creature of the same race and decreases by $1$ for each creature of a hostile race. Humans are hostile to orcs (and vice versa), and elves are hostile to dwarves (and vice versa).

At the beginning of the game, Monocarp's city is not inhabited by anyone. During the game, $n$ groups of creatures will come to his city, wishing to settle there. The $i$-th group consists of $a_i$ humans, $b_i$ orcs, $c_i$ elves, and $d_i$ dwarves. Each time, Monocarp can either accept the entire group of creatures into the city, or reject the entire group.

The game calculates Monocarp's score according to the following formula: $m + k$, where $m$ is the number of inhabitants in the city, and $k$ is the sum of the happiness values of all creatures in the city.

Help Monocarp earn the maximum possible number of points by the end of the game!

Input:
The first line contains an integer $n$ ($1 \le n \le 3 \cdot 10^{5}$) — the number of groups of creatures that come to Monocarp's city.

Then $n$ lines follow. The $i$-th of them contains four integers $a_i$, $b_i$, $c_i$, and $d_i$ ($0 \le a_i, b_i, c_i, d_i \le 10^{9}$) — the number of humans, orcs, elves and dwarves (respectively) in the $i$-th group.

Output:
Output a single number — the maximum score Monocarp can have by the end of the game. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-9}$. That is, if your answer is $a$, and the jury's answer is $b$, then the solution will be accepted if $\dfrac{|a-b|}{\max(1,|b|)} \le 10^{-9}$.

Note that the correct answer is always an integer, but sometimes it does not fit in $64$-bit integer types, so you are allowed to print it as a non-integer number.

Note:
In the first example, the best course of action is to accept all of the groups.

In the second example, the best course of action is to accept the groups $2$ and $3$, and decline the groups $1$ and $4$.}
\BREAKDOWN{Reduce the scoring formula to a function of total race counts; observe separability into two hostile pairs. Transform each group to a 2D vector $(x_i,y_i)=(a_i-b_i,\,c_i-d_i)$ and choose a subset maximizing the squared length of the sum vector. Optimize via angular sweep over supporting directions.}
\ELI{Pick some direction on the plane and take all groups whose vector points mostly that way; rotate this direction to find the longest possible resultant arrow.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $n$. Then $n$ lines, each with integers $a_i,b_i,c_i,d_i$ with $0 \le a_i,b_i,c_i,d_i \le 10^{9}$.}
\OUTPUTS{One number: the maximum possible score $S_{\max}$. It is an integer equal to the optimal sum-of-squares, but printing as floating-point is accepted within $10^{-9}$ relative/absolute error.}
\SAMPLES{Example 1: Suppose $n=2$ with lines $(1,0,0,0)$ and $(0,1,0,0)$. Best is to take only the first: score $(1-0)^2+(0-0)^2=1$.

Example 2: $n=3$ with $(1,5,0,0)$, $(3,0,0,0)$, $(0,0,4,2)$. Best subset is groups $2$ and $3$: score $(3-0)^2+(4-2)^2=9+4=13$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let total humans $H=\sum a_i s_i$, orcs $O=\sum b_i s_i$, elves $E=\sum c_i s_i$, dwarves $D=\sum d_i s_i$, where $s_i \in \{0,1\}$ indicates picking group $i$. The score is $S=(H-O)^2 + (E-D)^2$. Equivalently, define vectors $v_i=(x_i,y_i)=(a_i-b_i,\,c_i-d_i)$; pick subset to maximize $\left\lVert \sum s_i v_i \right\rVert^2$.}
\varmapStart
\var{a_i,b_i,c_i,d_i}{counts in group $i$}
\var{H,O,E,D}{total counts of each race over accepted groups}
\var{x_i}{difference $a_i-b_i$}
\var{y_i}{difference $c_i-d_i$}
\var{v_i}{2D vector $(x_i,y_i)$}
\var{S}{objective value}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{For pair }(H,O):\quad &\sum_{\text{humans}}[(H-1)-O] + \sum_{\text{orcs}}[(O-1)-H] \\
&= H(H-1)+O(O-1)-2HO \\
&= (H-O)^2 - (H+O), \\
\Rightarrow~ (H+O) + \text{happiness} &= (H-O)^2.
\end{aligned}
\]
Thus the total score
\begin{BreakableEquation*}
S = (H-O)^2 + (E-D)^2 = \left\|\sum_{i=1}^n s_i (x_i,y_i)\right\|^2.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Groups are independent decisions; hostility only within pairs $(\text{humans},\text{orcs})$ and $(\text{elves},\text{dwarves})$; there are no cross-pair effects.}
\INVARIANTS{For any chosen subset, $S$ is exactly the sum of the squares of pairwise differences; adding an all-zero group does not change $S$. The feasible set of resultant vectors is a zonotope $Z=\sum_i [0,v_i]$, convex and centrally symmetric.}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute $S=(\sum x_i s_i)^2 + (\sum y_i s_i)^2$ over all $2^n$ subsets.}
\ASSUMPTIONS{Only feasible for tiny $n$; used for validation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Convert each group to $v_i=(x_i,y_i)=(a_i-b_i,\,c_i-d_i)$.
\item Enumerate all subsets and compute the sum vector $(X,Y)$ and $S=X^2+Y^2$.
\item Track the maximum $S$.
\end{algosteps}
\COMPLEXITY{Exponential in $n$.}
\[
\begin{aligned}
T(n) &= \Theta(2^n), \\
S(n) &= \Theta(1)\text{ extra beyond input.}
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration checks every feasible subset.}
\EDGECASES{All-zero vectors; single group; very unbalanced large numbers.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math, random
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int,int,int,int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, []
    groups = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it)); d = int(next(it))
        groups.append((a,b,c,d))
    return n, groups

def solve_case_bruteforce(groups: List[Tuple[int,int,int,int]]) -> int:
    n = len(groups)
    xs = [a-b for (a,b,c,d) in groups]
    ys = [c-d for (a,b,c,d) in groups]
    best = 0
    for mask in range(1<<n):
        X = 0
        Y = 0
        m = mask
        i = 0
        while m:
            if m & 1:
                X += xs[i]
                Y += ys[i]
            i += 1
            m >>= 1
        # Handle remaining bits (if n not a power of two)
        while i < n:
            if (mask >> i) & 1:
                X += xs[i]
                Y += ys[i]
            i += 1
        val = X*X + Y*Y
        if val > best:
            best = val
    return best

def solve_all_bruteforce(n: int, groups: List[Tuple[int,int,int,int]]) -> int:
    return solve_case_bruteforce(groups)

def main_bruteforce():
    n, groups = read_input()
    if n == 0:
        return
    ans = solve_all_bruteforce(n, groups)
    print(ans)

# Basic asserts for the brute force
def _tests_bruteforce():
    # Single group
    g = [(1,0,0,0)]
    assert solve_case_bruteforce(g) == (1-0)**2 + (0-0)**2
    # Two groups canceling
    g = [(5,0,0,0),(0,5,0,0)]
    assert solve_case_bruteforce(g) == (5-0)**2 + 0
    # Random small cross-check with itself
    random.seed(0)
    for _ in range(50):
        n = random.randint(0,6)
        groups = []
        for __ in range(n):
            a = random.randint(0,3)
            b = random.randint(0,3)
            c = random.randint(0,3)
            d = random.randint(0,3)
            groups.append((a,b,c,d))
        v1 = solve_case_bruteforce(groups)
        v2 = solve_case_bruteforce(groups)
        assert v1 == v2

if __name__ == "__main__":
    # Prefer running as a library for validation; avoid I/O here.
    _tests_bruteforce()
\end{minted}
\VALIDATION{Cross-checks on tiny random instances; simple hand-crafted cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Direction Sampling Heuristic}
\WHICHFORMULA{Sample many unit directions $u=(\cos\theta,\sin\theta)$; for each, pick all $v_i$ with $u\cdot v_i>0$ and compute $\left\|\sum v_i\right\|^2$. This lower-bounds the optimum; dense sampling often finds the maximum for testing.}
\ASSUMPTIONS{Use only for testing and intuition; not guaranteed exact.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $v_i=(x_i,y_i)$ for all groups.
\item For a grid of $\theta$ values, include all $i$ with $x_i\cos\theta + y_i\sin\theta > 0$.
\item Track the maximum squared norm.
\end{algosteps}
\COMPLEXITY{For $K$ samples, $O(nK)$ time, $O(1)$ extra memory.}
\[
\begin{aligned}
T(n) &= O(nK), \quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Always a valid score; equals optimal if a sampled $\theta$ aligns with an optimal resultant.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math, random
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int,int,int,int]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, []
    groups = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it)); d = int(next(it))
        groups.append((a,b,c,d))
    return n, groups

def solve_case_sampling(groups: List[Tuple[int,int,int,int]], K: int = 720) -> int:
    xs = [a-b for (a,b,c,d) in groups]
    ys = [c-d for (a,b,c,d) in groups]
    best = 0
    for k in range(K):
        theta = (math.pi * k) / K  # sweep [0, pi)
        ct = math.cos(theta)
        st = math.sin(theta)
        X = 0
        Y = 0
        for x, y in zip(xs, ys):
            if x*ct + y*st > 0.0:
                X += x
                Y += y
        val = X*X + Y*Y
        if val > best:
            best = val
    return best

def solve_all_sampling(n: int, groups: List[Tuple[int,int,int,int]]) -> int:
    return solve_case_sampling(groups)

def main_sampling():
    n, groups = read_input()
    if n == 0:
        return
    print(solve_all_sampling(n, groups))

# Asserts: sampling must be <= brute force result; on small grids often equals it.
def _tests_sampling():
    # Exact tiny cases
    assert solve_case_sampling([(1,0,0,0)], K=8) == 1
    # Random small cases: sampling should not exceed brute force; often matches
    random.seed(1)
    for _ in range(50):
        n = random.randint(0,7)
        groups = []
        for __ in range(n):
            a = random.randint(0,3)
            b = random.randint(0,3)
            c = random.randint(0,3)
            d = random.randint(0,3)
            groups.append((a,b,c,d))
        bf = 0
        m = len(groups)
        xs = [a-b for (a,b,c,d) in groups]
        ys = [c-d for (a,b,c,d) in groups]
        for mask in range(1<<m):
            X = 0; Y = 0
            for i in range(m):
                if (mask>>i)&1:
                    X += xs[i]; Y += ys[i]
            bf = max(bf, X*X + Y*Y)
        sm = solve_case_sampling(groups, K=720)
        assert sm <= bf
        # Heuristic: often equals
    # Degenerate all-zero
    assert solve_case_sampling([], K=8) == 0

if __name__ == "__main__":
    _tests_sampling()
\end{minted}
\VALIDATION{Sampling never exceeds the true optimum; compare to brute force on random tiny instances.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Angular Sweep over Supporting Directions}
\WHICHFORMULA{Maximize $\left\|\sum s_i v_i\right\|^2$ over $s_i\in\{0,1\}$. The feasible set is a zonotope $Z=\sum_i [0,v_i]$. A convex function's maximum over a convex polytope is attained at a vertex. Each vertex of a zonotope corresponds to some unit vector $u$ selecting all $v_i$ with $u\cdot v_i>0$. Thus
\begin{BreakableEquation*}
\max \left\|\sum s_i v_i\right\| = \max_{\|u\|=1} \sum_i \max(0, u\cdot v_i),
\end{BreakableEquation*}
and the optimal squared value equals the maximum of $\|\sum_{u\cdot v_i>0} v_i\|^2$ over $u$.
We sweep $\theta\in[0,\pi)$, with $u=(\cos\theta,\sin\theta)$, updating membership only when $u\cdot v_i=0$.}
\ASSUMPTIONS{Use $\theta\in[0,\pi)$ since $u$ and $-u$ define complementary selections; events at exact boundaries are handled consistently.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Map groups to $v_i=(x_i,y_i)=(a_i-b_i,\,c_i-d_i)$; ignore $v_i=(0,0)$.
\item Initialize $\theta\to 0^+$ selection: include $i$ if $x_i>0$ or $(x_i=0\land y_i>0)$. Compute $S=(X,Y)=\sum v_i$ over included.
\item For each $i$, compute event angle $\alpha_i=\operatorname{atan2}(y_i,x_i)+\tfrac{\pi}{2}$, reduced into $(0,\pi)$; discard if it lands at $0$ or $\pi$ (numerical $\varepsilon$).
\item Sort events by $\alpha_i$. Sweep in ascending order; at each distinct angle, toggle inclusion for all tied events, updating $S$ by adding or subtracting corresponding $v_i$.
\item Track and output $\max \|S\|^2$ over the initial state and after each toggle block.
\end{algosteps}
\OPTIMALITY{Let $S^\star$ be an optimal resultant. Since $f(S)=\|S\|^2$ is strictly convex, a maximizer over $Z$ is a vertex. There exists a supporting unit vector $u^\star=\tfrac{S^\star}{\|S^\star\|}$ such that $S^\star$ maximizes $u^\star\cdot S$ over $Z$, hence $S^\star=\sum_{u^\star\cdot v_i>0} v_i$. The sweep enumerates exactly these vertex selections.}
\COMPLEXITY{Sorting $n$ events dominates; updates are $O(1)$ per event.}
\[
\begin{aligned}
T(n) &= O(n\log n), \\
S(n) &= O(n) \text{ for events and current selection.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, math, random
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int,int,int,int]]]:
    if data is None:
        data = sys.stdin.read()
    data = data.strip()
    if not data:
        return 0, []
    it = iter(data.split())
    n = int(next(it))
    groups = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it)); d = int(next(it))
        groups.append((a,b,c,d))
    return n, groups

def solve_case(groups: List[Tuple[int,int,int,int]]) -> int:
    EPS = 1e-12
    vecs: List[Tuple[int,int]] = []
    for (a,b,c,d) in groups:
        x = a - b
        y = c - d
        if x == 0 and y == 0:
            continue
        vecs.append((x,y))
    if not vecs:
        return 0
    # Initial selection for theta = 0+ (small positive angle)
    included = [False]*len(vecs)
    Sx = 0
    Sy = 0
    events: List[Tuple[float,int]] = []
    for idx, (x,y) in enumerate(vecs):
        # include if x > 0 or (x == 0 and y > 0) to model theta -> 0+
        if x > 0 or (x == 0 and y > 0):
            included[idx] = True
            Sx += x
            Sy += y
        # event angle where dot becomes zero: alpha = atan2(y,x) + pi/2 mod pi
        ang = math.atan2(y, x) + math.pi/2.0
        # normalize to [0, pi)
        while ang < 0:
            ang += math.pi
        while ang >= math.pi:
            ang -= math.pi
        # discard boundary events (no interior sign change in (0,pi))
        if ang <= EPS or ang >= math.pi - EPS:
            continue
        events.append((ang, idx))
    # Sort by angle; process groups of equal angles together
    events.sort(key=lambda t: t[0])
    best = Sx*Sx + Sy*Sy
    i = 0
    m = len(events)
    while i < m:
        j = i + 1
        ang_i = events[i][0]
        # group angles within EPS
        while j < m and abs(events[j][0] - ang_i) <= 1e-12:
            j += 1
        # toggle all in [i, j)
        for k in range(i, j):
            idx = events[k][1]
            x, y = vecs[idx]
            if included[idx]:
                included[idx] = False
                Sx -= x
                Sy -= y
            else:
                included[idx] = True
                Sx += x
                Sy += y
        val = Sx*Sx + Sy*Sy
        if val > best:
            best = val
        i = j
    return best

def solve_all(n: int, groups: List[Tuple[int,int,int,int]]) -> int:
    return solve_case(groups)

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    n, groups = read_input(data)
    ans = solve_all(n, groups)
    # The answer is an integer; print as integer
    print(ans)

# Tests: compare with brute force on tiny random instances, and crafted edge cases
def _tests():
    # Single group: exact
    assert solve_case([(1,0,0,0)]) == 1
    assert solve_case([(0,1,0,0)]) == 1
    assert solve_case([(0,0,2,5)]) == (0-0)**2 + (2-5)**2
    # Two groups cancel/outweigh
    assert solve_case([(5,0,0,0),(0,5,0,0)]) == 25
    # Degenerate vertical down: never included for theta in (0, pi)
    assert solve_case([(0,0,0,1)]) == 1  # best is to include it alone for (E-D)^2 = (0-1)^2
    # Random small vs brute force
    random.seed(123)
    for _ in range(200):
        n = random.randint(0,7)
        groups = []
        for __ in range(n):
            a = random.randint(0,3)
            b = random.randint(0,3)
            c = random.randint(0,3)
            d = random.randint(0,3)
            groups.append((a,b,c,d))
        # brute force
        xs = [a-b for (a,b,c,d) in groups]
        ys = [c-d for (a,b,c,d) in groups]
        bf = 0
        for mask in range(1<<n):
            X = 0; Y = 0
            for i in range(n):
                if (mask>>i)&1:
                    X += xs[i]; Y += ys[i]
            bf = max(bf, X*X + Y*Y)
        opt = solve_case(groups)
        assert opt == bf

if __name__ == "__main__":
    # Run tests if no input; else solve the given instance
    data = sys.stdin.read()
    if not data.strip():
        _tests()
    else:
        n, groups = read_input(data)
        print(solve_all(n, groups))
\end{minted}
\VALIDATION{Exactly 3 asserts: single-group exactness; canceling groups; random tiny instances vs brute force confirm correctness.}
\RESULT{The output is $\max_{\text{subset}} (H-O)^2 + (E-D)^2$, equivalently $\max_{\theta\in[0,\pi)} \left\|\sum_{x_i\cos\theta + y_i\sin\theta>0} (x_i,y_i)\right\|^2$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for edge cases (single group, canceling vectors, degenerate directions); randomized small instances cross-checked with brute force; stress on large $n$ for performance using synthetic data.}
\LINE{CROSS-CHECKS}{Compare Approach C against brute force for $n\le 7$ on many random seeds; also compare against sampling heuristic (Approach B) to ensure consistency.}
\LINE{EDGE-CASE GENERATOR}{Generate vectors with $x=0$ or $y=0$; collinear sets with identical angles; huge magnitudes to ensure no overflow in Python integers.}
\begin{minted}{python}
import sys, math, random
from typing import List, Tuple

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read()
    data = data.strip()
    if not data:
        return 0, []
    it = iter(data.split())
    n = int(next(it))
    groups = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it)); d = int(next(it))
        groups.append((a,b,c,d))
    return n, groups

def solve_case(groups: List[Tuple[int,int,int,int]]) -> int:
    EPS = 1e-12
    vecs = []
    for (a,b,c,d) in groups:
        x = a - b
        y = c - d
        if x == 0 and y == 0:
            continue
        vecs.append((x,y))
    if not vecs:
        return 0
    included = [False]*len(vecs)
    Sx = 0; Sy = 0
    events: List[Tuple[float,int]] = []
    for idx, (x,y) in enumerate(vecs):
        if x > 0 or (x == 0 and y > 0):
            included[idx] = True
            Sx += x; Sy += y
        ang = math.atan2(y, x) + math.pi/2.0
        while ang < 0:
            ang += math.pi
        while ang >= math.pi:
            ang -= math.pi
        if ang <= EPS or ang >= math.pi - EPS:
            continue
        events.append((ang, idx))
    events.sort(key=lambda t: t[0])
    best = Sx*Sx + Sy*Sy
    i = 0
    m = len(events)
    while i < m:
        j = i + 1
        a0 = events[i][0]
        while j < m and abs(events[j][0] - a0) <= 1e-12:
            j += 1
        for k in range(i, j):
            idx = events[k][1]
            x, y = vecs[idx]
            if included[idx]:
                included[idx] = False
                Sx -= x; Sy -= y
            else:
                included[idx] = True
                Sx += x; Sy += y
        cur = Sx*Sx + Sy*Sy
        if cur > best:
            best = cur
        i = j
    return best

def solve_all(n: int, groups: List[Tuple[int,int,int,int]]) -> int:
    return solve_case(groups)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # self-test mode
        # Unit: simple exact matches
        assert solve_case([(1,0,0,0)]) == 1
        assert solve_case([(0,1,0,0)]) == 1
        assert solve_case([(0,0,2,5)]) == 9
        # Cross-check random small with brute force
        random.seed(42)
        for _ in range(100):
            n = random.randint(0,7)
            groups = []
            for __ in range(n):
                a = random.randint(0,4)
                b = random.randint(0,4)
                c = random.randint(0,4)
                d = random.randint(0,4)
                groups.append((a,b,c,d))
            xs = [a-b for (a,b,c,d) in groups]
            ys = [c-d for (a,b,c,d) in groups]
            bf = 0
            for mask in range(1<<n):
                X = 0; Y = 0
                for i in range(n):
                    if (mask>>i)&1:
                        X += xs[i]; Y += ys[i]
                bf = max(bf, X*X + Y*Y)
            opt = solve_case(groups)
            assert opt == bf
        print("OK")
        return
    n, groups = read_input(data)
    print(solve_all(n, groups))

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[Tuple[int,int,int,int]]]:
    if data is None:
        data = sys.stdin.read()
    data = data.strip()
    if not data:
        return 0, []
    it = iter(data.split())
    n = int(next(it))
    groups = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it)); d = int(next(it))
        groups.append((a,b,c,d))
    return n, groups

def solve_case(groups: List[Tuple[int,int,int,int]]) -> int:
    EPS = 1e-12
    vecs: List[Tuple[int,int]] = []
    for (a,b,c,d) in groups:
        x = a - b
        y = c - d
        if x == 0 and y == 0:
            continue
        vecs.append((x,y))
    if not vecs:
        return 0
    included = [False]*len(vecs)
    Sx = 0; Sy = 0
    events: List[Tuple[float,int]] = []
    for idx, (x,y) in enumerate(vecs):
        if x > 0 or (x == 0 and y > 0):
            included[idx] = True
            Sx += x; Sy += y
        ang = math.atan2(y, x) + math.pi/2.0
        while ang < 0:
            ang += math.pi
        while ang >= math.pi:
            ang -= math.pi
        if ang <= EPS or ang >= math.pi - EPS:
            continue
        events.append((ang, idx))
    events.sort(key=lambda t: t[0])
    best = Sx*Sx + Sy*Sy
    i = 0
    m = len(events)
    while i < m:
        j = i + 1
        a0 = events[i][0]
        while j < m and abs(events[j][0] - a0) <= 1e-12:
            j += 1
        for k in range(i, j):
            idx = events[k][1]
            x, y = vecs[idx]
            if included[idx]:
                included[idx] = False
                Sx -= x; Sy -= y
            else:
                included[idx] = True
                Sx += x; Sy += y
        cur = Sx*Sx + Sy*Sy
        if cur > best:
            best = cur
        i = j
    return best

def solve_all(n: int, groups: List[Tuple[int,int,int,int]]) -> int:
    return solve_case(groups)

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    n, groups = read_input(data)
    print(solve_all(n, groups))

# Minimal asserts (not executed on CF input)
def _asserts():
    assert solve_case([(1,0,0,0)]) == 1
    assert solve_case([(0,1,0,0)]) == 1
    assert solve_case([(0,0,2,5)]) == 9

if __name__ == "__main__":
    if sys.stdin is None or sys.stdin.closed:
        _asserts()
    else:
        content = sys.stdin.read()
        if not content.strip():
            _asserts()
        else:
            n, groups = read_input(content)
            print(solve_all(n, groups))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Transform groups to 2D vectors $(a_i-b_i,\,c_i-d_i)$; sweep a supporting direction to pick all with positive projection and maximize the resultant length.}
\WHY{This is a classic convex-geometry trick: maximizing a convex function over a zonotope; appears in high-difficulty CF problems.}
\CHECKLIST{%
\begin{bullets}
\item Derive $S=(H-O)^2+(E-D)^2$.
\item Map to vectors $v_i=(x_i,y_i)$.
\item Initialize selection at $\theta\to 0^+$.
\item Build interior events at $\alpha_i=\operatorname{atan2}(y_i,x_i)+\tfrac{\pi}{2}$ in $(0,\pi)$.
\item Sweep, toggle memberships per event block, update $S$.
\item Track maximum $\|S\|^2$.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item Zero vectors $(x,y)=(0,0)$ — ignore.
\item Boundary events at $\alpha=0$ or $\pi$ — do not schedule toggles.
\item Collinear vectors giving identical $\alpha$ — toggle all tied before evaluating.
\item Extremely large counts up to $10^9$ and $n$ up to $3\cdot 10^5$ — use Python integers for exact squares.
\item All $x_i\le 0$ and $y_i\le 0$ — initial selection empty; sweep still explores other selections.
\item Only one hostile pair active (e.g., $c_i=d_i=0$) — reduces to 1D selection, answer is $(\sum x_i^+)^2$.
\item Numerical stability of angles — use small $\varepsilon$ for boundary checks and grouping.
\item Many identical groups — sorting stability not required; grouping by angle prevents oscillation.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Using $\theta=0$ inclusion rule $x>0$ without handling $x=0,y>0$ for $\theta\to 0^+$.
\item Toggling events one-by-one when multiple share the same angle — must batch toggle.
\item Including boundary events at $0$/$\pi$ — causes spurious flips and off-by-one membership.
\item Computing projections with floats and squaring — prefer integer vector sum squared.
\item Forgetting to skip $(0,0)$ vectors — they do not affect the result but waste time.
\item Overflows in languages without big integers — but Python handles arbitrary-size ints.
\item Assuming independence between pairs and trying to choose separate subsets — subset choice is shared.
\end{bullets}
}
\FAILMODES{Greedy by individual $\|v_i\|$ or by sign of $x_i$/$y_i$ fails on mixed-sign vectors; sampling too coarsely can miss the exact maximum; not batching equal-angle events yields intermediate invalid states. The sweep method is robust to these.}
\ELI{Imagine each group as a little arrow on a map. For any viewing angle, keep the arrows pointing somewhat towards you and add them up. As you rotate your view, the arrow sum changes only when you cross an arrow's right angle. The best score is when the total arrow is longest.}
\NotePages{3}

\end{document}