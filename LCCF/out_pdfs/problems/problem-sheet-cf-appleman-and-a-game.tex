% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Appleman and a Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/461/E}}
\LINE{DIFFICULTY / RATING}{3000}
\STATEMENT{Appleman and Toastman like games. Today they play a game with strings with the following rules. Firstly Toastman tells Appleman two strings $s$ and $t$ both consisting only of letters `A', `B', `C', `D'. Then Appleman must build string $s$ as quickly as possible. Initially he has empty string, and in one second he can append to end of the current string any contiguous substring of $t$.

Now, Toastman and Appleman are beginning to play the game. Toastman has already told string $t$ to Appleman, but he hasn't come up with string $s$ yet. Toastman only thinks, that he should choose string $s$ consisting of $n$ characters. Of course, he wants to find the worst string for Appleman (such string, that Appleman will spend as much time as possible during the game). Tell Toastman, how much time will Appleman spend during the game if Toastman finds the worst string for him. You can assume that Appleman plays optimally, therefore he builds any string $s$ in minimal possible time.

Input:\\
The first line contains an integer $n$ ($1 \le n \le 10^{18}$). The second line contains string $t$ ($1 \le |t| \le 10^5$). String $t$ consists of only letters `A', `B', `C', `D'. Each letter appears at least once in string $t$.

Output:\\
Print a single integer — the largest possible time Appleman needs.

Note:\\
In the first example, Toastman can choose $s$ equal to ``AAAAA''.

In the second example, Toastman can choose $s$ equal to ``DADDA''.}
\BREAKDOWN{We must compute, for fixed $t$, the maximal minimal number of substrings of $t$ needed to concatenate into an arbitrary string $s$ of length $n$. This equals covering $s$ by substrings of $t$ while minimizing pieces, and then maximizing over $s$. Build an automaton of all substrings of $t$ and analyze the shortest adversarial forced progress per piece.}
\ELI{Find the shortest chunk length an adversary can force when we keep taking the longest substring of $t$ that matches the next part of $s$; then the answer is how many such chunks fit in length $n$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test.\\
- Integer $n$ with $1 \le n \le 10^{18}$.\\
- String $t$ with $1 \le |t| \le 10^5$, over alphabet $\{A,B,C,D\}$; each letter appears at least once in $t$.}
\OUTPUTS{One integer: the maximum, over all strings $s$ of length $n$ over $\{A,B,C,D\}$, of the minimal number of seconds Appleman needs (each second appending a contiguous substring of $t$).}
\SAMPLES{Example 1:\\
Input\\
5\\
ABCD\\
Output\\
5

Example 2:\\
Input\\
5\\
AAABACADBABBBCBDCACBCCCDDADBDCDD\\
Output\\
3}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma=\{A,B,C,D\}$. For fixed $t\in\Sigma^{|t|}$, consider the language $L$ of all substrings of $t$. For any $s\in\Sigma^n$, define $\kappa(s)$ as the minimal $k$ such that $s$ can be written as a concatenation of $k$ strings from $L$. We need $\max_{s\in\Sigma^n}\kappa(s)$.}
\varmapStart
\var{t}{given base string; all substrings form $L$}
\var{n}{target length of $s$}
\var{\Sigma}{alphabet of size 4}
\var{\text{SAM}}{suffix automaton of $t$ recognizing $L$}
\var{L^\star}{adversarially forced minimal chunk length per segment}
\var{f(v)}{DP on SAM state $v$: minimal consumable length before hitting a deficient state}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Define a SAM over } \Sigma \text{ with transition function } \text{go}(v,c).\\
&\text{Let } \text{full}(v) \iff \bigl|\{c\in\Sigma:\text{go}(v,c)\text{ exists}\}\bigr|=4.\\
&f(v) = \begin{cases}
0, & \neg \text{full}(v),\\[2pt]
1 + \min\limits_{c\in\Sigma} f(\text{go}(v,c)), & \text{full}(v).
\end{cases}\\
&L^\star = f(\text{root}),\qquad \text{Answer} = \left\lceil \dfrac{n}{L^\star} \right\rceil.
\end{aligned}
\]
}
\ASSUMPTIONS{Each letter in $\Sigma$ appears at least once in $t$, so the SAM root is full. SAM transitions strictly increase matched length, so the subgraph induced by full states is acyclic, making $f$ well-defined.}
\INVARIANTS{Greedy longest-prefix segmentation is optimal for minimizing pieces. Under adversarial $s$, each segment starts at the root and is forced to consume exactly $L^\star$ characters, except possibly the last partial segment.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Model substrings of $t$ with a suffix automaton (SAM). The worst-case per-segment progress equals the shortest distance (in transitions) from the root to any deficient state (state missing some outgoing letter), staying within full states until arrival.}
\ASSUMPTIONS{Construct SAM in $O(|t|)$ states. BFS over the subgraph of full states finds the minimal depth to any deficient state.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a SAM for $t$ over $\Sigma=\{A,B,C,D\}$.
\item Mark each state as full if it has all four outgoing transitions, else deficient.
\item BFS from the root through only full states; the first time you traverse an edge into a deficient state at depth $d{+}1$, record $L^\star=d{+}1$ and stop.
\item Output $\lceil n / L^\star \rceil$.
\end{algosteps}
\COMPLEXITY{Building SAM is $O(|t|)$ states and $O(|t|)$ transitions for fixed $\lvert\Sigma\rvert=4$. BFS is $O(\text{states}\times 4)$. Space $O(|t|)$.}
\[
\begin{aligned}
T(|t|) &= O(|t|) \text{ (SAM)} + O(|t|) \text{ (BFS)} = O(|t|),\\
S(|t|) &= O(|t|).
\end{aligned}
\]
\CORRECTNESS{Any segment follows transitions from the root until some next letter is missing. The adversary chooses letters to minimize depth; thus the minimal depth to a deficient state equals the per-segment length in the worst case. Greedy segmentation restarts at root each time, so total segments is $\lceil n/L^\star\rceil$.}
\EDGECASES{Root is always full (each letter appears). There cannot be a cycle of full states reachable from root, else substrings of unbounded length would exist.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

ALPH = "ABCD"
IDX = {c: i for i, c in enumerate(ALPH)}

class SAM:
    __slots__ = ("next", "link", "length", "last")
    def __init__(self):
        self.next = [[-1]*4]  # transitions
        self.link = [-1]
        self.length = [0]
        self.last = 0

    def _new_state(self, length):
        self.next.append([-1]*4)
        self.link.append(-1)
        self.length.append(length)
        return len(self.next) - 1

    def extend(self, ch):
        c = IDX[ch]
        cur = self._new_state(self.length[self.last] + 1)
        p = self.last
        while p != -1 and self.next[p][c] == -1:
            self.next[p][c] = cur
            p = self.link[p]
        if p == -1:
            self.link[cur] = 0
        else:
            q = self.next[p][c]
            if self.length[p] + 1 == self.length[q]:
                self.link[cur] = q
            else:
                clone = self._new_state(self.length[p] + 1)
                self.next[clone] = self.next[q][:]  # copy transitions
                self.link[clone] = self.link[q]
                while p != -1 and self.next[p][c] == q:
                    self.next[p][c] = clone
                    p = self.link[p]
                self.link[q] = self.link[cur] = clone
        self.last = cur

def compute_Lstar_bfs(t):
    sam = SAM()
    for ch in t:
        sam.extend(ch)
    nstates = len(sam.next)
    # Mark full states (all four transitions exist)
    is_full = [all(sam.next[v][i] != -1 for i in range(4)) for v in range(nstates)]
    root = 0
    assert is_full[root], "Root must be full because each letter appears at least once in t"
    # BFS on full states; first edge into deficient state gives minimal length
    dist = [-1] * nstates
    q = deque([root])
    dist[root] = 0
    while q:
        v = q.popleft()
        d = dist[v]
        for i in range(4):
            u = sam.next[v][i]
            if u == -1:
                # Cannot happen if v is full; but keep for safety
                return 1
            if not is_full[u]:
                return d + 1
            if dist[u] == -1:
                dist[u] = d + 1
                q.append(u)
    # Should never reach here for finite t; fallback:
    return 1

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0])
    t = data[1].strip()
    return n, t

def solve_case(n, t):
    Lstar = compute_Lstar_bfs(t)
    # ceil(n / Lstar)
    return (n + Lstar - 1) // Lstar

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, t = inp
    print(solve_case(n, t))

def _self_test():
    # Sample 1: t="ABCD" -> worst is "AAAA...": L*=1, answer=n
    assert solve_case(5, "ABCD") == 5
    # Construct t containing all 16 pairs xy so that each single-letter state is full -> L*=2
    t2 = "AAABACAD" + "BABBBCBD" + "CACBCCCD" + "DADBDCDD"
    assert solve_case(5, t2) == 3  # ceil(5/2)=3
    assert solve_case(10, t2) == 5
    # Random small check: single long repeating letters appended with all letters present
    t3 = "AAAABBBBCCCCDDDD"
    assert solve_case(7, t3) == 7  # no pair of same letters exists across all positions

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Checked against two crafted cases: (1) $t=\text{ABCD}$ gives $L^\star=1$ hence answer $n$. (2) $t$ containing all pairs gives $L^\star=2$ hence $\lceil n/2\rceil$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Instead of BFS, compute $L^\star$ by DP on SAM states: $f(v)=0$ if $v$ is deficient; else $f(v)=1+\min_{c} f(\text{go}(v,c))$. This leverages the acyclicity of transitions with respect to increasing matched length.}
\ASSUMPTIONS{SAM over fixed alphabet of size 4; the subgraph of full states is acyclic, so memoized DFS is linear.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build SAM for $t$.
\item Precompute is\_full for each state.
\item Use memoized DFS to compute $f(v)$ for all states, with base $f(v){=}0$ if $\neg$ is\_full[$v$].
\item Output $\lceil n / f(\text{root})\rceil$.
\end{algosteps}
\COMPLEXITY{Same asymptotics as BFS: $O(|t|)$ time and space.}
\[
\begin{aligned}
T(|t|) &= O(|t|), \qquad S(|t|)=O(|t|).
\end{aligned}
\]
\CORRECTNESS{By definition, at a full state the adversary must choose one of four next letters, and chooses the branch minimizing future consumable length. At a deficient state, the adversary can stop immediately on the next letter, contributing 0 further consumed characters. This exactly models the worst-case per-segment progress.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1_000_000)

ALPH = "ABCD"
IDX = {c: i for i, c in enumerate(ALPH)}

class SAM:
    __slots__ = ("next", "link", "length", "last")
    def __init__(self):
        self.next = [[-1]*4]
        self.link = [-1]
        self.length = [0]
        self.last = 0
    def _new_state(self, length):
        self.next.append([-1]*4)
        self.link.append(-1)
        self.length.append(length)
        return len(self.next) - 1
    def extend(self, ch):
        c = IDX[ch]
        cur = self._new_state(self.length[self.last] + 1)
        p = self.last
        while p != -1 and self.next[p][c] == -1:
            self.next[p][c] = cur
            p = self.link[p]
        if p == -1:
            self.link[cur] = 0
        else:
            q = self.next[p][c]
            if self.length[p] + 1 == self.length[q]:
                self.link[cur] = q
            else:
                clone = self._new_state(self.length[p] + 1)
                self.next[clone] = self.next[q][:]
                self.link[clone] = self.link[q]
                while p != -1 and self.next[p][c] == q:
                    self.next[p][c] = clone
                    p = self.link[p]
                self.link[q] = self.link[cur] = clone
        self.last = cur

def compute_Lstar_dp(t):
    sam = SAM()
    for ch in t:
        sam.extend(ch)
    nstates = len(sam.next)
    is_full = [all(sam.next[v][i] != -1 for i in range(4)) for v in range(nstates)]
    dp = [-1] * nstates
    def f(v):
        if not is_full[v]:
            return 0
        if dp[v] != -1:
            return dp[v]
        best = 10**9
        for i in range(4):
            u = sam.next[v][i]
            # At full v, all 4 exist
            cand = f(u)
            if cand < best:
                best = cand
        dp[v] = 1 + best
        return dp[v]
    root = 0
    assert is_full[root], "Root must be full"
    return f(root)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0]); t = data[1].strip()
    return n, t

def solve_case(n, t):
    Lstar = compute_Lstar_dp(t)
    return (n + Lstar - 1) // Lstar

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, t = inp
    print(solve_case(n, t))

def _self_test():
    assert solve_case(5, "ABCD") == 5
    t2 = "AAABACAD" + "BABBBCBD" + "CACBCCCD" + "DADBDCDD"
    assert solve_case(5, t2) == 3
    assert solve_case(10, t2) == 5

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Same checks as baseline; both approaches agree on crafted cases and random sanity checks.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Suffix Automaton + adversarial DP: $L^\star=f(\text{root})$ with $f$ as defined; final answer is $\left\lceil n / L^\star \right\rceil$.}
\ASSUMPTIONS{Alphabet size fixed at 4; $t$ nonempty and contains all letters; SAM fits in memory for $|t|\le 10^5$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build SAM of $t$.
\item Compute is\_full for each state.
\item Compute $L^\star=f(\text{root})$ via memoized DFS.
\item Output $\left\lceil n / L^\star \right\rceil$.
\end{algosteps}
\OPTIMALITY{Greedy segmentation is optimal for minimizing pieces. The adversary's optimal per-segment strategy is a minimax over next letters, captured by $f$. The subgraph of full states is a DAG, so $f$ is well-defined and yields the true worst-case per-segment length; concatenating such segments yields the global worst case, hence $\lceil n/L^\star\rceil$ is tight.}
\COMPLEXITY{Time $O(|t|)$, Space $O(|t|)$.}
\[
\begin{aligned}
T(|t|) &= O(|t|), \quad S(|t|)=O(|t|).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1_000_000)

ALPH = "ABCD"
IDX = {c: i for i, c in enumerate(ALPH)}

class SAM:
    __slots__ = ("next", "link", "length", "last")
    def __init__(self):
        self.next = [[-1]*4]
        self.link = [-1]
        self.length = [0]
        self.last = 0
    def _new_state(self, length):
        self.next.append([-1]*4)
        self.link.append(-1)
        self.length.append(length)
        return len(self.next) - 1
    def extend(self, ch):
        c = IDX[ch]
        cur = self._new_state(self.length[self.last] + 1)
        p = self.last
        while p != -1 and self.next[p][c] == -1:
            self.next[p][c] = cur
            p = self.link[p]
        if p == -1:
            self.link[cur] = 0
        else:
            q = self.next[p][c]
            if self.length[p] + 1 == self.length[q]:
                self.link[cur] = q
            else:
                clone = self._new_state(self.length[p] + 1)
                self.next[clone] = self.next[q][:]
                self.link[clone] = self.link[q]
                while p != -1 and self.next[p][c] == q:
                    self.next[p][c] = clone
                    p = self.link[p]
                self.link[q] = self.link[cur] = clone
        self.last = cur

def L_star(t: str) -> int:
    sam = SAM()
    for ch in t:
        sam.extend(ch)
    nstates = len(sam.next)
    is_full = [all(sam.next[v][i] != -1 for i in range(4)) for v in range(nstates)]
    dp = [-1] * nstates
    def f(v: int) -> int:
        if not is_full[v]:
            return 0
        if dp[v] != -1:
            return dp[v]
        best = 10**9
        for i in range(4):
            u = sam.next[v][i]
            cand = f(u)
            if cand < best:
                best = cand
        dp[v] = 1 + best
        return dp[v]
    root = 0
    assert is_full[root], "By problem guarantee, root has all 4 outgoing letters"
    return f(root)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0]); t = data[1].strip()
    return n, t

def solve_case(n: int, t: str) -> int:
    L = L_star(t)
    return (n + L - 1) // L

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, t = inp
    print(solve_case(n, t))

def _self_test():
    # Test 1
    assert solve_case(5, "ABCD") == 5
    # Test 2: all pairs present -> L*=2
    t2 = "AAABACAD" + "BABBBCBD" + "CACBCCCD" + "DADBDCDD"
    assert solve_case(5, t2) == 3
    assert solve_case(10, t2) == 5

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts provided: (1) trivial $t$, (2) crafted $t$ with all pairs to force $L^\star=2$, (3) another size on same $t$.}
\RESULT{Print a single integer $\left\lceil n / L^\star \right\rceil$, where $L^\star$ is the minimal per-segment progress an adversary can force. Ties do not arise; output is a unique integer.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the core routine on: (a) $t$ with no repeated adjacent letters $\Rightarrow L^\star=1$; (b) $t$ containing all length-2 pairs $\Rightarrow L^\star=2$; (c) random mixes ensuring constraints.}
\LINE{CROSS-CHECKS}{Compare BFS-based $L^\star$ vs DP-based $L^\star$ on random $t$ of small size; they must match.}
\LINE{EDGE-CASE GENERATOR}{Generate $t$ as concatenation of all pairs to make each single-letter state full; generate $t$ as blocks of identical letters to minimize pairs.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

def gen_all_pairs_t():
    # Concatenate all pairs xy for x,y in ABCD
    xs = "ABCD"
    parts = []
    for x in xs:
        for y in xs:
            parts.append(x + y)
    return "".join(parts)

def gen_blocks_t(k=4):
    # k repeats of each letter block; ensures all letters appear, poor adjacency variety
    return "A"*k + "B"*k + "C"*k + "D"*k

def test_generators():
    t1 = gen_all_pairs_t()
    assert len(t1) == 32 and set(t1) == set("ABCD")
    t2 = gen_blocks_t(5)
    assert len(t2) == 20 and set(t2) == set("ABCD")

test_generators()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1_000_000)

ALPH = "ABCD"
IDX = {c: i for i, c in enumerate(ALPH)}

class SAM:
    __slots__ = ("next", "link", "length", "last")
    def __init__(self):
        self.next = [[-1]*4]
        self.link = [-1]
        self.length = [0]
        self.last = 0
    def _new_state(self, length):
        self.next.append([-1]*4)
        self.link.append(-1)
        self.length.append(length)
        return len(self.next) - 1
    def extend(self, ch):
        c = IDX[ch]
        cur = self._new_state(self.length[self.last] + 1)
        p = self.last
        while p != -1 and self.next[p][c] == -1:
            self.next[p][c] = cur
            p = self.link[p]
        if p == -1:
            self.link[cur] = 0
        else:
            q = self.next[p][c]
            if self.length[p] + 1 == self.length[q]:
                self.link[cur] = q
            else:
                clone = self._new_state(self.length[p] + 1)
                self.next[clone] = self.next[q][:]
                self.link[clone] = self.link[q]
                while p != -1 and self.next[p][c] == q:
                    self.next[p][c] = clone
                    p = self.link[p]
                self.link[q] = self.link[cur] = clone
        self.last = cur

def L_star(t: str) -> int:
    sam = SAM()
    for ch in t:
        sam.extend(ch)
    nstates = len(sam.next)
    is_full = [all(sam.next[v][i] != -1 for i in range(4)) for v in range(nstates)]
    dp = [-1] * nstates
    def f(v: int) -> int:
        if not is_full[v]:
            return 0
        if dp[v] != -1:
            return dp[v]
        best = 10**9
        for i in range(4):
            u = sam.next[v][i]
            cand = f(u)
            if cand < best:
                best = cand
        dp[v] = 1 + best
        return dp[v]
    root = 0
    assert is_full[root], "Each letter appears in t, so root is full"
    return f(root)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0]); t = data[1].strip()
    return n, t

def solve_case(n: int, t: str) -> int:
    L = L_star(t)
    return (n + L - 1) // L

def solve_all():
    inp = read_input()
    if inp is None:
        return
    n, t = inp
    print(solve_case(n, t))

def _self_test():
    assert solve_case(5, "ABCD") == 5
    t2 = "AAABACAD" + "BABBBCBD" + "CACBCCCD" + "DADBDCDD"
    assert solve_case(5, t2) == 3
    assert solve_case(10, t2) == 5

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Build a SAM for $t$, compute the minimal adversarially forced chunk length $L^\star$ from the root, then answer $\lceil n/L^\star\rceil$.}
\WHY{This pattern (greedy segmentation over substrings of a fixed text) is a common interview theme; SAM provides an optimal compact representation.}
\CHECKLIST{
\begin{bullets}
\item Build SAM correctly (clone logic).
\item Mark full vs deficient states.
\item DP: $f(v)=0$ if deficient, else $1+\min f(\text{go}(v,c))$.
\item Ensure root is full (alphabet guarantee).
\item Compute answer as ceiling division.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $|t|=1$ but all letters must appear — impossible by constraints; ignore.
\item $t$ where some letter rarely appears: still root full.
\item Repeated blocks like ``AAAABBBBCCCCDDDD'': $L^\star=1$.
\item $t$ containing all pairs: $L^\star=2$.
\item Very large $n$ (up to $10^{18}$): use Python int.
\item Highly repetitive $t$: SAM size still $\le 2|t|$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in chunk length: per-segment length is distance to a deficient state (not including the failing character).
\item Wrong base: $f(v)=0$ for deficient states (not $1$).
\item Assuming transitions graph may have cycles among full states; it does not in this context.
\item Forgetting all four letters exist at root; adding unnecessary checks.
\item Ceiling division overflow in other languages; in Python safe with integers.
\item Misbuilding SAM transitions when cloning (must copy transitions array).
\end{bullets}}
\FAILMODES{Any approach that tries to simulate worst-case $s$ explicitly is exponential. Trying to use suffix links during matching is incorrect: matches must remain within one substring of $t$. The SAM-based DP avoids both issues.}
\ELI{From the starting node, the adversary picks letters to reach a state where some next letter is missing as fast as possible; that number of letters is the shortest per-chunk length you are forced to accept. Repeat this pattern to stretch the number of chunks; divide $n$ by that number and round up.}
\NotePages{3}

\end{document}