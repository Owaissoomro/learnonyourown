% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Moves to Reach Target with Rotations}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{In an $n \times n$ grid, there is a snake that spans 2 cells and starts moving from the top left corner at $(0, 0)$ and $(0, 1)$. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at $(n-1, n-2)$ and $(n-1, n-1)$.\\
In one move the snake can:
\begin{bullets}
\item Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
\item Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
\item Rotate clockwise if it is in a horizontal position and the two cells under it are both empty. In that case the snake moves from $(r, c)$ and $(r, c+1)$ to $(r, c)$ and $(r+1, c)$.
\item Rotate counterclockwise if it is in a vertical position and the two cells to its right are both empty. In that case the snake moves from $(r, c)$ and $(r+1, c)$ to $(r, c)$ and $(r, c+1)$.
\end{bullets}
Return the minimum number of moves to reach the target. If there is no way to reach the target, return \texttt{-1}.\\
\textbf{Example 1:}\\
\textbf{Input:} \texttt{grid = [[0,0,0,0,0,1],} \texttt{[1,1,0,0,1,0],} \texttt{[0,0,0,0,1,1],} \texttt{[0,0,1,0,1,0],} \texttt{[0,1,1,0,0,0],} \texttt{[0,1,1,0,0,0]]}\\
\textbf{Output:} \texttt{11}\\
\textbf{Explanation:} One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].\\
\textbf{Example 2:}\\
\textbf{Input:} \texttt{grid = [[0,0,1,1,1,1],} \texttt{[0,0,0,0,1,1],} \texttt{[1,1,0,0,0,1],} \texttt{[1,1,1,0,0,1],} \texttt{[1,1,1,0,0,1],} \texttt{[1,1,1,0,0,0]]}\\
\textbf{Output:} \texttt{9}\\
\textbf{Constraints:}
\begin{bullets}
\item $2 \le n \le 100$
\item $0 \le \texttt{grid}[i][j] \le 1$
\item It is guaranteed that the snake starts at empty cells.
\end{bullets}}
\BREAKDOWN{Model the snake as a state with head/tail encoded by an anchor $(r,c)$ and an orientation bit (horizontal or vertical). Perform a shortest-path search (BFS) over these states with valid transitions for right, down, and rotations, and return the distance to the target state.}
\ELI{Treat the snake as a Tetris-like piece that can slide or rotate if the nearby cells are free; use BFS to find the fewest steps to the bottom-right configuration.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A matrix \texttt{grid} of shape $n \times n$ where $2 \le n \le 100$ and each entry is in $\{0,1\}$. A \texttt{0} means empty, \texttt{1} means blocked.}
\OUTPUTS{Return the minimum number of moves (nonnegative integer) to transform the initial snake position $((0,0),(0,1))$ into the target $((n-1,n-2),(n-1,n-1))$ using the allowed moves. If impossible, return \texttt{-1}.}
\SAMPLES{
\begin{bullets}
\item \textbf{Input:} \texttt{[[0,0],[0,0]]} $\Rightarrow$ \textbf{Output:} \texttt{1}
\item \textbf{Input:} \texttt{[[0,1],[0,0]]} $\Rightarrow$ \textbf{Output:} \texttt{1} \quad(rotate counterclockwise then right is not needed; a single down move suffices)
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the state space be $V = \{(r,c,o)\}$ where $(r,c)$ is the anchor cell (the upper\slash left endpoint) and $o \in \{0,1\}$ denotes orientation: $o=0$ for horizontal occupying $\{(r,c),(r,c+1)\}$ and $o=1$ for vertical occupying $\{(r,c),(r+1,c)\}$. Build an unweighted directed graph $(V,E)$ where edges encode valid moves under obstacle constraints. The objective is the shortest path length from $s=(0,0,0)$ to $t=(n-1,n-2,0)$.}
\varmapStart
\var{n}{grid dimension}
\var{g_{ij}}{cell occupancy; $0$ empty, $1$ blocked}
\var{(r,c)}{anchor position of the snake piece}
\var{o}{orientation bit; $0$ horizontal, $1$ vertical}
\var{s}{start state $(0,0,0)$}
\var{t}{target state $(n-1,n-2,0)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
E = \{\, &((r,c,0)\to(r,c+1,0)) \ \text{iff}\ c+2<n \land g_{r,c+2}=0; \\
&((r,c,0)\to(r+1,c,0)) \ \text{iff}\ r+1<n \land g_{r+1,c}=0 \land g_{r+1,c+1}=0; \\
&((r,c,0)\to(r,c,1)) \ \text{iff}\ r+1<n \land g_{r+1,c}=0 \land g_{r+1,c+1}=0; \\
&((r,c,1)\to(r+1,c,1)) \ \text{iff}\ r+2<n \land g_{r+2,c}=0; \\
&((r,c,1)\to(r,c+1,1)) \ \text{iff}\ c+1<n \land g_{r,c+1}=0 \land g_{r+1,c+1}=0; \\
&((r,c,1)\to(r,c,0)) \ \text{iff}\ c+1<n \land g_{r,c+1}=0 \land g_{r+1,c+1}=0 \,\}.
\end{aligned}
\]
}
\ASSUMPTIONS{The anchor $(r,c)$ is always chosen so that occupied cells are in-bounds and empty. Start cells $(0,0)$ and $(0,1)$ are empty by constraint.}
\INVARIANTS{
\begin{bullets}
\item Occupancy invariant: every visited state occupies only empty, in-bounds cells.
\item Orientation invariant: $o=0$ implies two horizontal cells; $o=1$ implies two vertical cells.
\item BFS distance invariant: first time a state is dequeued equals its shortest distance from $s$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use BFS on the discrete state graph $(V,E)$ defined by legal moves. Unweighted edges imply BFS gives shortest path length.}
\ASSUMPTIONS{Transitions are checked naively from each state by probing the few needed grid cells.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize queue with start state $(0,0,0)$ and distance $0$; visited set contains the start.
\item While queue nonempty, pop state and, if it is the target $(n-1,n-2,0)$, return its distance.
\item Generate up to five neighbors: move right, move down, and one rotation appropriate to the orientation, each gated by cell-emptiness checks; push unseen neighbors with distance $+1$.
\item If BFS ends without reaching target, return $-1$.
\end{algosteps}
\COMPLEXITY{At most $2n(n-1)$ states; each expansion does $O(1)$ checks. Hence $T(n)=O(n^2)$ and $S(n)=O(n^2)$.}
\[
\begin{aligned}
|V| &\le 2n(n-1) = O(n^2),\\
|E| &\le 5|V| = O(n^2),\quad T(n)=O(|V|+|E|)=O(n^2),\ S(n)=O(n^2).
\end{aligned}
\]
\CORRECTNESS{BFS on an unweighted graph returns shortest path length. Transitions reflect exactly the problem’s legal moves with necessary emptiness checks, thus any valid sequence is a path; any path found is valid.}
\EDGECASES{$n=2$ minimal grid, walls adjacent to the start, fully blocked rows/columns, and rotations at borders.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
from typing import List, Tuple, Deque, Set

class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        # orientation: 0=horizontal (occupies (r,c),(r,c+1)), 1=vertical (occupies (r,c),(r+1,c))
        start = (0, 0, 0)
        target = (n - 1, n - 2, 0)

        def inb(r: int, c: int) -> bool:
            return 0 <= r < n and 0 <= c < n

        def free(r: int, c: int) -> bool:
            return inb(r, c) and grid[r][c] == 0

        q: Deque[Tuple[int, int, int, int]] = deque()
        q.append((0, 0, 0, 0))  # r,c,o,dist
        seen: Set[Tuple[int, int, int]] = {(0, 0, 0)}

        while q:
            r, c, o, d = q.popleft()
            if (r, c, o) == target:
                return d
            if o == 0:
                # move right: need (r, c+2) free
                if c + 2 < n and free(r, c + 2):
                    nxt = (r, c + 1, 0)
                    if nxt not in seen:
                        seen.add(nxt)
                        q.append((r, c + 1, 0, d + 1))
                # move down: need (r+1, c) and (r+1, c+1) free
                if r + 1 < n and free(r + 1, c) and free(r + 1, c + 1):
                    nxt = (r + 1, c, 0)
                    if nxt not in seen:
                        seen.add(nxt)
                        q.append((r + 1, c, 0, d + 1))
                    # rotate clockwise to vertical at same anchor
                    nxt = (r, c, 1)
                    if nxt not in seen:
                        seen.add(nxt)
                        q.append((r, c, 1, d + 1))
            else:
                # o == 1 vertical
                # move down: need (r+2, c) free
                if r + 2 < n and free(r + 2, c):
                    nxt = (r + 1, c, 1)
                    if nxt not in seen:
                        seen.add(nxt)
                        q.append((r + 1, c, 1, d + 1))
                # move right: need (r, c+1) and (r+1, c+1) free
                if c + 1 < n and free(r, c + 1) and free(r + 1, c + 1):
                    nxt = (r, c + 1, 1)
                    if nxt not in seen:
                        seen.add(nxt)
                        q.append((r, c + 1, 1, d + 1))
                    # rotate counterclockwise to horizontal at same anchor
                    nxt = (r, c, 0)
                    if nxt not in seen:
                        seen.add(nxt)
                        q.append((r, c, 0, d + 1))
        return -1

# Tiny baseline tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumMoves([[0,0],[0,0]]) == 1
    assert sol.minimumMoves([[0,1],[0,0]]) == 1
    grid1 = [
        [0,0,0,0,0,1],
        [1,1,0,0,1,0],
        [0,0,0,0,1,1],
        [0,0,1,0,1,0],
        [0,1,1,0,0,0],
        [0,1,1,0,0,0],
    ]
    assert sol.minimumMoves(grid1) == 11
\end{minted}
\VALIDATION{Manually verify start and target indexing, orientation semantics, and that rotations require a $2 \times 2$ empty square adjacent to the anchor.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Emptiness Checks \& Pruning}
\WHICHFORMULA{Cache small predicates to avoid recomputing bounds and emptiness; keep 3D distance array instead of a set to avoid tuple hashing overhead.}
\ASSUMPTIONS{Grid size is modest, but reducing Python overhead yields a practical speedup.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Predefine tiny inline lambdas or local variables for bound checks and cell access to reduce attribute lookups.
\item Use a 3D array \texttt{dist[2][n][n]} initialized to $-1$ for unvisited; set start to $0$.
\item BFS; for each legal neighbor, if \texttt{dist} is $-1$, set it to parent $+1$ and enqueue.
\end{algosteps}
\COMPLEXITY{Asymptotics remain $O(n^2)$ time and space, but constant factors improve due to array indexing and fewer dictionary operations.}
\[
\begin{aligned}
T(n) &= O(n^2),\quad S(n)=O(n^2).
\end{aligned}
\]
\CORRECTNESS{Same state graph; \texttt{dist} invariant ensures each state is first reached with the shortest distance.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque
from typing import List

class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dist = [[[-1]*n for _ in range(n)] for _ in range(2)]
        # start: horizontal at (0,0)
        dist[0][0][0] = 0
        q = deque()
        q.append((0, 0, 0))  # r,c,o

        g = grid  # local alias for speed

        while q:
            r, c, o = q.popleft()
            d = dist[o][r][c]
            if (r, c, o) == (n - 1, n - 2, 0):
                return d
            if o == 0:
                # right
                if c + 2 < n and g[r][c + 2] == 0 and dist[0][r][c + 1] == -1:
                    dist[0][r][c + 1] = d + 1
                    q.append((r, c + 1, 0))
                # down and rotate cw need 2 cells below
                if r + 1 < n and g[r + 1][c] == 0 and g[r + 1][c + 1] == 0:
                    if dist[0][r + 1][c] == -1:
                        dist[0][r + 1][c] = d + 1
                        q.append((r + 1, c, 0))
                    if dist[1][r][c] == -1:
                        dist[1][r][c] = d + 1
                        q.append((r, c, 1))
            else:
                # o == 1
                # down
                if r + 2 < n and g[r + 2][c] == 0 and dist[1][r + 1][c] == -1:
                    dist[1][r + 1][c] = d + 1
                    q.append((r + 1, c, 1))
                # right and rotate ccw need 2 cells to the right
                if c + 1 < n and g[r][c + 1] == 0 and g[r + 1][c + 1] == 0:
                    if dist[1][r][c + 1] == -1:
                        dist[1][r][c + 1] = d + 1
                        q.append((r, c + 1, 1))
                    if dist[0][r][c] == -1:
                        dist[0][r][c] = d + 1
                        q.append((r, c, 0))
        return -1

# Improved tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumMoves([[0,0],[0,0]]) == 1
    grid2 = [
        [0,0,1,1,1,1],
        [0,0,0,0,1,1],
        [1,1,0,0,0,1],
        [1,1,1,0,0,1],
        [1,1,1,0,0,1],
        [1,1,1,0,0,0],
    ]
    assert sol.minimumMoves(grid2) == 9
    assert sol.minimumMoves([[0,1],[0,0]]) == 1
\end{minted}
\VALIDATION{Edge validations: borders where $c+2=n$ or $r+2=n$, rotation requiring a $2\times 2$ free square, and that the target is exactly horizontal at $(n-1,n-2)$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{BFS with Explicit 3D State Space \& Early Exit}
\WHICHFORMULA{Same BFS but with explicit early termination upon dequeuing the target and with strictly minimal state checks; this is optimal under unweighted moves.}
\ASSUMPTIONS{Grid sizes up to $100$ fit comfortably in $O(n^2)$ time/space.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Use \texttt{dist[2][n][n]} initialized to $-1$; enqueue $(0,0,0)$ with distance $0$.
\item Pop states; if equal to target $(n-1,n-2,0)$, return its distance immediately.
\item Push each valid neighbor once, setting distance and marking visited via \texttt{dist}.
\end{algosteps}
\OPTIMALITY{Lower bound is the shortest-path length in the state graph; BFS achieves it exactly. No algorithm can do better in the comparison model without additional problem structure.}
\COMPLEXITY{$O(n^2)$ time and space; each state is enqueued at most once and each transition is $O(1)$.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\quad S(n)=\Theta(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import deque
from typing import List

class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dist = [[[-1]*n for _ in range(n)] for _ in range(2)]
        q = deque()
        dist[0][0][0] = 0
        q.append((0, 0, 0))

        # Target: horizontal at bottom-right two cells, anchor at (n-1, n-2)
        tr, tc, to = n - 1, n - 2, 0

        while q:
            r, c, o = q.popleft()
            d = dist[o][r][c]
            if (r, c, o) == (tr, tc, to):
                return d
            if o == 0:
                # Move right: require (r, c+2) empty
                if c + 2 < n and grid[r][c + 2] == 0 and dist[0][r][c + 1] == -1:
                    dist[0][r][c + 1] = d + 1
                    q.append((r, c + 1, 0))
                # Move down / rotate cw: require cells below both segments empty
                if r + 1 < n and grid[r + 1][c] == 0 and grid[r + 1][c + 1] == 0:
                    if dist[0][r + 1][c] == -1:
                        dist[0][r + 1][c] = d + 1
                        q.append((r + 1, c, 0))
                    if dist[1][r][c] == -1:
                        dist[1][r][c] = d + 1
                        q.append((r, c, 1))
            else:
                # o == 1
                # Move down: require (r+2, c) empty
                if r + 2 < n and grid[r + 2][c] == 0 and dist[1][r + 1][c] == -1:
                    dist[1][r + 1][c] = d + 1
                    q.append((r + 1, c, 1))
                # Move right / rotate ccw: require cells to the right of both segments empty
                if c + 1 < n and grid[r][c + 1] == 0 and grid[r + 1][c + 1] == 0:
                    if dist[1][r][c + 1] == -1:
                        dist[1][r][c + 1] = d + 1
                        q.append((r, c + 1, 1))
                    if dist[0][r][c] == -1:
                        dist[0][r][c] = d + 1
                        q.append((r, c, 0))
        return -1

# Exactly 3 validation asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumMoves([[0,0],[0,0]]) == 1
    grid1 = [
        [0,0,0,0,0,1],
        [1,1,0,0,1,0],
        [0,0,0,0,1,1],
        [0,0,1,0,1,0],
        [0,1,1,0,0,0],
        [0,1,1,0,0,0],
    ]
    assert sol.minimumMoves(grid1) == 11
    grid2 = [
        [0,0,1,1,1,1],
        [0,0,0,0,1,1],
        [1,1,0,0,0,1],
        [1,1,1,0,0,1],
        [1,1,1,0,0,1],
        [1,1,1,0,0,0],
    ]
    assert sol.minimumMoves(grid2) == 9
\end{minted}
\VALIDATION{Three asserts: the $2\times 2$ empty grid yields $1$; and both official samples match $11$ and $9$.}
\RESULT{Return the minimal number of moves as an integer, or \texttt{-1} if unreachable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover minimal grids, full-free paths, blocked rotations, and near-border moves. Property: distances are nondecreasing with BFS layers and target is recognized only in horizontal orientation at the bottom-right.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach A, B, and C on small random grids ($n \le 6$) to ensure agreement; they share the same state graph but differ in implementation details.}
\LINE{EDGE-CASE GENERATOR}{Generate grids with: fully open, single wall near start, walls forming tight corridors, and $2\times 2$ cavities to force rotations.}
\begin{minted}{python}
import random
from typing import List

def gen_grid(n: int, p: float, seed: int = 0) -> List[List[int]]:
    rng = random.Random(seed)
    g = [[1 if rng.random() < p else 0 for _ in range(n)] for _ in range(n)]
    # Ensure start and target occupancy are empty for fairness
    g[0][0] = g[0][1] = 0
    g[n-1][n-2] = g[n-1][n-1] = 0
    return g

# Reference solution (Approach C)
from collections import deque

class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dist = [[[-1]*n for _ in range(n)] for _ in range(2)]
        q = deque([(0, 0, 0)])
        dist[0][0][0] = 0
        TR, TC, TO = n - 1, n - 2, 0
        while q:
            r, c, o = q.popleft()
            d = dist[o][r][c]
            if (r, c, o) == (TR, TC, TO):
                return d
            if o == 0:
                if c + 2 < n and grid[r][c + 2] == 0 and dist[0][r][c + 1] == -1:
                    dist[0][r][c + 1] = d + 1
                    q.append((r, c + 1, 0))
                if r + 1 < n and grid[r + 1][c] == 0 and grid[r + 1][c + 1] == 0:
                    if dist[0][r + 1][c] == -1:
                        dist[0][r + 1][c] = d + 1
                        q.append((r + 1, c, 0))
                    if dist[1][r][c] == -1:
                        dist[1][r][c] = d + 1
                        q.append((r, c, 1))
            else:
                if r + 2 < n and grid[r + 2][c] == 0 and dist[1][r + 1][c] == -1:
                    dist[1][r + 1][c] = d + 1
                    q.append((r + 1, c, 1))
                if c + 1 < n and grid[r][c + 1] == 0 and grid[r + 1][c + 1] == 0:
                    if dist[1][r][c + 1] == -1:
                        dist[1][r][c + 1] = d + 1
                        q.append((r, c + 1, 1))
                    if dist[0][r][c] == -1:
                        dist[0][r][c] = d + 1
                        q.append((r, c, 0))
        return -1

# Quick randomized cross-check
if __name__ == "__main__":
    sol = Solution()
    # Sanity: trivial open 2x2 -> 1
    assert sol.minimumMoves([[0,0],[0,0]]) == 1
    for n in range(3, 7):
        for seed in range(3):
            g = gen_grid(n, p=0.2, seed=seed)
            res = sol.minimumMoves(g)  # should terminate and be finite or -1
            assert isinstance(res, int)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from collections import deque
from typing import List

class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        # dist[o][r][c] is min moves to reach anchor (r,c) with orientation o
        dist = [[[-1]*n for _ in range(n)] for _ in range(2)]
        q = deque()
        q.append((0, 0, 0))
        dist[0][0][0] = 0

        target = (n - 1, n - 2, 0)

        while q:
            r, c, o = q.popleft()
            d = dist[o][r][c]
            if (r, c, o) == target:
                return d

            if o == 0:
                # Move right: check cell ahead of the head
                if c + 2 < n and grid[r][c + 2] == 0 and dist[0][r][c + 1] == -1:
                    dist[0][r][c + 1] = d + 1
                    q.append((r, c + 1, 0))
                # Move down / rotate cw: need 2 cells below
                if r + 1 < n and grid[r + 1][c] == 0 and grid[r + 1][c + 1] == 0:
                    if dist[0][r + 1][c] == -1:
                        dist[0][r + 1][c] = d + 1
                        q.append((r + 1, c, 0))
                    if dist[1][r][c] == -1:
                        dist[1][r][c] = d + 1
                        q.append((r, c, 1))
            else:
                # o == 1
                # Move down: check cell below the lower segment
                if r + 2 < n and grid[r + 2][c] == 0 and dist[1][r + 1][c] == -1:
                    dist[1][r + 1][c] = d + 1
                    q.append((r + 1, c, 1))
                # Move right / rotate ccw: need 2 cells to the right
                if c + 1 < n and grid[r][c + 1] == 0 and grid[r + 1][c + 1] == 0:
                    if dist[1][r][c + 1] == -1:
                        dist[1][r][c + 1] = d + 1
                        q.append((r, c + 1, 1))
                    if dist[0][r][c] == -1:
                        dist[0][r][c] = d + 1
                        q.append((r, c, 0))
        return -1

# Submission-ready quick tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumMoves([[0,0],[0,0]]) == 1
    grid1 = [
        [0,0,0,0,0,1],
        [1,1,0,0,1,0],
        [0,0,0,0,1,1],
        [0,0,1,0,1,0],
        [0,1,1,0,0,0],
        [0,1,1,0,0,0],
    ]
    assert sol.minimumMoves(grid1) == 11
    grid2 = [
        [0,0,1,1,1,1],
        [0,0,0,0,1,1],
        [1,1,0,0,0,1],
        [1,1,1,0,0,1],
        [1,1,1,0,0,1],
        [1,1,1,0,0,0],
    ]
    assert sol.minimumMoves(grid2) == 9
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Shortest path in a small, structured state space using BFS with careful move validity checks.}
\WHY{Common grid-search interview pattern combining position and orientation, testing ability to model states and enforce move preconditions precisely.}
\CHECKLIST{
\begin{bullets}
\item Define state $(r,c,o)$ with $o\in\{0,1\}$.
\item Start $(0,0,0)$, target $(n-1,n-2,0)$.
\item Enumerate neighbors with correct bounds and emptiness checks.
\item Use BFS with visited or distance array.
\item Early exit upon reaching target.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=2$ minimal case.
\item Walls directly to the right or below the start.
\item Rotations at borders: top row, leftmost column, bottom row, rightmost column.
\item Narrow corridors requiring multiple rotations.
\item Grids where only rotation enables progress.
\item Cases where target cells are empty but approach is blocked.
\item Large open grid (performance sanity).
\item Single obstruction breaking a needed $2\times 2$ square.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting that horizontal right move needs only $g[r][c+2]=0$.
\item Forgetting that horizontal down and rotate require both $g[r+1][c]$ and $g[r+1][c+1]$ empty.
\item Similarly, vertical right and rotate need both $g[r][c+1]$ and $g[r+1][c+1]$ empty.
\item Off-by-one in target anchor: must be $(n-1,n-2,0)$.
\item Revisiting states without a visited/dist structure causing exponential blowup.
\item Mis-anchoring after rotations (anchor does not change).
\item Not checking grid bounds before indexing.
\item Using costly tuple operations in hot loops without need.
\end{bullets}
}
\FAILMODES{DFS or greedy strategies can loop or miss the shortest path; A-star without an admissible heuristic might return suboptimal answers. The presented BFS is robust: each state is processed once and edges encode exactly the allowed moves.}
\ELI{Think of the snake as a domino that slides or pivots only when the nearby $2\times 2$ area is clear. Explore all positions in rings of increasing move counts until you reach the goal; the first time you see it is the optimal number of moves.}
\NotePages{3}

\end{document}