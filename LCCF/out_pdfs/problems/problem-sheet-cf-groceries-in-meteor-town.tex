% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Groceries in Meteor Town}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1628/E}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{Mihai lives in a town where meteor storms are a common problem. It is annoying, because Mihai has to buy groceries sometimes, and getting hit by meteors is not fun. Therefore, we ask you to find the most dangerous way to buy groceries so that we can trick him to go there.

The town has $n$ buildings numbered from $1$ to $n$. Some buildings have roads between them, and there is exactly $1$ simple path from any building to any other building. Each road has a certain meteor danger level. The buildings all have grocery stores, but Mihai only cares about the open ones, of course. Initially, all the grocery stores are closed.

You are given $q$ queries of three types:
\begin{enumerate}
\item Given the integers $l$ and $r$, the buildings numbered from $l$ to $r$ open their grocery stores (nothing happens to buildings in the range that already have an open grocery store).
\item Given the integers $l$ and $r$, the buildings numbered from $l$ to $r$ close their grocery stores (nothing happens to buildings in the range that did not have an open grocery store).
\item Given the integer $x$, find the maximum meteor danger level on the simple path from $x$ to any open grocery store, or $-1$ if there is no edge on any simple path to an open store.
\end{enumerate}

Input:
The first line contains the two integers $n$ and $q$ ($2 \le n, q \le 3\cdot 10^5$).

Then follows $n - 1$ lines, the $i$-th of which containing the integers $u_i$, $v_i$, and $w_i$ ($1 \le u_i, v_i \le n, \enspace 1 \le w_i \le 10^9$) meaning there is two way road between building $u_i$ and $v_i$ with meteor danger level $w_i$.

It is guaranteed that the given edges form a tree.

Then follows $q$ lines, the $j$-th of which begin with the integer $t_j$ ($1 \le t_j \le 3$), meaning the $j$-th query is of the $t_j$-th type.

If $t_j$ is $1$ or $2$ the rest of the line contains the integers $l_j$ and $r_j$ ($1 \le l_j \le r_j \le n$).

If $t_j$ is $3$ the rest of the line contains the integer $x_j$ ($1 \le x_j \le n$).

Output:
For each query of the $3$rd type ($t_j = 3$), output the maximum meteor danger level that is on some edge on the simple path from $x_j$ to some open store, or $-1$ if there is no such edge.

Note:
This is an illustration of the town given in the sample input.

In the first query, there are no open stores, so obviously there are no edges on the simple path from $1$ to any open store, so the answer is $-1$.

After the second and third queries, the set of open stores is $\{1\}$. The simple path from $1$ to $1$ has no edges, so the answer for the $3$rd query is $-1$.

After the fourth query, there are no open stores.

After the fifth and sixth queries, the set of open stores is $\{5, 6\}$. In the sixth query, there are two paths from $x_j = 4$ to some open grocery store: $4$ to $5$ and $4$ to $6$. The biggest meteor danger is found on the edge from $4$ to $6$, so the answer for the $6$th query is $4$. This path is marked with red in the illustration.

After the rest of the queries, the set of open stores is $\{5\}$. In the eighth query, the only path from $x_j = 4$ to an open store is from $4$ to $5$, and the maximum weight on that path is $3$. This path is marked with green in the illustration.

In the ninth query, the only path from $x_j = 1$ to an open store is from $1$ to $5$, and the maximum weight on that path is $5$. This path is marked with blue in the illustration.}
\BREAKDOWN{We maintain a dynamic set of ``open'' vertices on a weighted tree. For a query vertex $x$, we must compute $\max_{y \in S}$ of the maximum edge weight along the unique path from $x$ to $y$. The baseline scans all open vertices and uses LCA with path maxima. Improved methods precompute path maxima and use data structures to avoid scanning all open vertices. Optimal methods exploit structural decompositions of edges relative to the open-set distribution.}
\ELI{Preprocess the tree so you can quickly get the heaviest edge between any two nodes; then, for each query on $x$, take the worst (heaviest) among all paths from $x$ to currently open stores.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A tree with $n$ nodes labeled $1..n$ with $n-1$ weighted edges; then $q$ queries of three types: open range $[l,r]$, close range $[l,r]$, or ask at node $x$. Ranges refer to node labels.}
\OUTPUTS{For each type-$3$ query, print a single integer: the maximum edge weight on the path from $x$ to some open node; print $-1$ if there is no such edge.}
\SAMPLES{Example 1:
\begin{itemize}
\item Input:
\begin{verbatim}
5 5
1 2 3
2 3 2
2 4 5
1 5 4
3 1
1 2 3
3 4
2 3 3
3 5
\end{verbatim}
\item Output:
\begin{verbatim}
-1
5
4
\end{verbatim}
\end{itemize}
Example 2:
\begin{itemize}
\item Input:
\begin{verbatim}
3 4
1 2 7
2 3 1
1 1 1
3 2
2 1 1
3 2
\end{verbatim}
\item Output:
\begin{verbatim}
7
-1
\end{verbatim}
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a tree with positive weights $w:E\to\mathbb{Z}_{>0}$. Maintain a dynamic subset $S\subseteq V$. For a query vertex $x\in V$, compute
\begin{BreakableEquation*}
f(x;S)=\max_{y\in S}\big(\max_{e\in P(x,y)} w(e)\big),
\end{BreakableEquation*}
where $P(x,y)$ is the unique $x$--$y$ path. If $S=\varnothing$ or all $y\in S$ equal $x$, return $-1$.}
\varmapStart
\var{n}{number of nodes}
\var{q}{number of queries}
\var{w(e)}{weight of edge $e$}
\var{S}{set of currently open nodes}
\var{P(x,y)}{unique simple path from $x$ to $y$}
\var{f(x;S)}{answer to type-3 query at $x$}
\varmapEnd
\GOVERN{
\[
  f(x;S)=
  \begin{cases}
  -1,& S=\varnothing \text{ or } \big(S=\{x\}\big),\\
  \displaystyle \max_{y\in S}\ \max_{e\in P(x,y)} w(e),& \text{otherwise.}
  \end{cases}
\]
}
\ASSUMPTIONS{The graph is a tree; weights are positive; labels $1..n$ are fixed and used by range updates; paths are unique.}
\INVARIANTS{Open/close operations are idempotent over the specified range; the set $S$ consists exactly of labels that have been opened but not subsequently closed.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use LCA with binary lifting to compute the maximum edge on any $u$--$v$ path in $O(\log n)$. For a query $(3,x)$, scan all $y\in S$ and take $\max_y \text{pathMax}(x,y)$.}
\ASSUMPTIONS{Maintain $S$ as a hash set updated naively per range; preprocessing builds parent jumps and maximum edge tables.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Root the tree and preprocess depth, $2^k$-ancestors, and the maximum edge to each ancestor.
\item Maintain a boolean array $\text{open}[1..n]$ and a set $S$ of open nodes.
\item For type-$1$ or $2$ queries on $[l,r]$, loop $i=l..r$ to set $\text{open}[i]$ and update $S$.
\item For type-$3$ query at $x$, if $S$ empty, output $-1$; else compute $\max_{y\in S}\text{pathMax}(x,y)$; if the result is $0$ (only $x$ in $S$), print $-1$, else print it.
\end{algosteps}
\COMPLEXITY{Let $K=|S|$ at query time. Query time is $O(K\log n)$. Range updates cost $O(r-l+1)$. Preprocessing $O(n\log n)$.}
\[
\begin{aligned}
T_{\text{pre}}(n) &= O(n\log n),\\
T_{\text{upd}}(n) &= O(r-l+1),\\
T_{\text{qry}}(n) &= O(|S|\log n),\\
S(n) &= O(n\log n).
\end{aligned}
\]
\CORRECTNESS{Binary lifting yields the maximum edge on a path by lifting the deeper node up to $\text{LCA}(u,v)$ while tracking maxima; the unique path property ensures correctness. Taking the max over all open $y$ matches the definition of $f(x;S)$.}
\EDGECASES{No open stores; only $x$ is open (path has $0$ edges); heavy weights up to $10^9$; star and line trees.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import defaultdict, deque

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, [], []
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    edges = []
    g = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it)); w = int(next(it))
        g[u].append((v, w)); g[v].append((u, w))
        edges.append((u, v, w))
    queries = []
    for _ in range(q):
        t = int(next(it))
        if t == 1 or t == 2:
            l = int(next(it)); r = int(next(it))
            queries.append((t, l, r))
        else:
            x = int(next(it))
            queries.append((t, x))
    return n, q, g, queries

class LCAPathMax:
    def __init__(self, n, g, root=1):
        self.n = n
        self.LOG = (n).bit_length()
        self.up = [[0]*(n+1) for _ in range(self.LOG)]
        self.mx = [[0]*(n+1) for _ in range(self.LOG)]  # max edge to 2^k ancestor
        self.depth = [0]*(n+1)
        self._dfs_build(g, root)
        for k in range(1, self.LOG):
            for v in range(1, n+1):
                mid = self.up[k-1][v]
                self.up[k][v] = self.up[k-1][mid]
                self.mx[k][v] = max(self.mx[k-1][v], self.mx[k-1][mid])

    def _dfs_build(self, g, root):
        seen = [False]*(self.n+1)
        st = [(root, 0, 0)]  # node, parent, edge_w
        seen[root] = True
        self.up[0][root] = 0
        self.mx[0][root] = 0
        while st:
            v, p, w = st.pop()
            if p != 0:
                self.depth[v] = self.depth[p] + 1
            self.up[0][v] = p
            self.mx[0][v] = w
            for to, wt in g[v]:
                if to == p:
                    continue
                st.append((to, v, wt))

    def path_max(self, a, b):
        if a == b:
            return 0
        if self.depth[a] < self.depth[b]:
            a, b = b, a
        ans = 0
        da = self.depth[a]; db = self.depth[b]
        diff = da - db
        k = 0
        while diff:
            if diff & 1:
                ans = max(ans, self.mx[k][a])
                a = self.up[k][a]
            diff >>= 1; k += 1
        if a == b:
            return ans
        for k in range(self.LOG-1, -1, -1):
            if self.up[k][a] != self.up[k][b]:
                ans = max(ans, self.mx[k][a], self.mx[k][b])
                a = self.up[k][a]
                b = self.up[k][b]
        # now a and b are children of LCA
        ans = max(ans, self.mx[0][a], self.mx[0][b])
        return ans

def solve_all():
    n, q, g, queries = read_input()
    if n == 0 and q == 0:
        return
    lca = LCAPathMax(n, g, 1)
    open_flag = [False]*(n+1)
    open_set = set()
    out_lines = []
    for qr in queries:
        t = qr[0]
        if t == 1:
            _, l, r = qr
            for i in range(l, r+1):
                if not open_flag[i]:
                    open_flag[i] = True
                    open_set.add(i)
        elif t == 2:
            _, l, r = qr
            for i in range(l, r+1):
                if open_flag[i]:
                    open_flag[i] = False
                    if i in open_set:
                        open_set.remove(i)
        else:
            _, x = qr
            if not open_set:
                out_lines.append("-1")
                continue
            best = 0
            for y in open_set:
                best = max(best, lca.path_max(x, y))
            out_lines.append(str(-1 if best == 0 else best))
    sys.stdout.write("\n".join(out_lines))

def main():
    solve_all()

if __name__ == "__main__":
    # Lightweight sanity tests (non-executed in judge-like environments if stdin provided).
    if sys.stdin.isatty():
        # Tiny tree: 1-2(3), 2-3(2)
        n = 3
        g = [[] for _ in range(n+1)]
        g[1].append((2,3)); g[2].append((1,3))
        g[2].append((3,2)); g[3].append((2,2))
        lca = LCAPathMax(n, g, 1)
        assert lca.path_max(1,3) == 3
        assert lca.path_max(2,3) == 2
        # Simulate queries
        data = """3 4
1 2 7
2 3 1
1 1 1
3 2
2 1 1
3 2
"""
        sys.stdin = sys.__stdin__
        sys.stdout = sys.__stdout__
    main()
\end{minted}
\VALIDATION{On a chain, opening both ends makes every middle query return the larger of adjacent edges; on a star, opening any leaf yields the center-to-leaf edge as answer for the center.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Preprocessing \& Faster Path Queries}
\WHICHFORMULA{Replace repeated path scans with preprocessed LCA tables and maintain the open set as a container to iterate; this reduces per-pair path max to $O(\log n)$.}
\ASSUMPTIONS{Tree is static; edge weights are fixed; we can afford $O(n\log n)$ preprocessing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute binary lifting tables for ancestors and maximum-edge-to-ancestor.
\item Process range open/close by flipping boolean flags; maintain a set $S$.
\item For a query $(3,x)$, loop $y\in S$ and take $\max$ of $\text{pathMax}(x,y)$.
\end{algosteps}
\COMPLEXITY{Compared to the naive path walk, each pair query is now $O(\log n)$.}
\[
\begin{aligned}
T_{\text{pre}}(n) &= O(n\log n),\\
T_{\text{qry}}(n) &= O(|S|\log n).
\end{aligned}
\]
\CORRECTNESS{Follows from correctness of LCA and max-on-path computation; scanning the set $S$ preserves the definition of $f(x;S)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
# This block uses the same implementation as the Baseline, as it already employs
# optimal LCA preprocessing for O(log n) path maxima. The improvement focus is
# on preprocessing, not on the S-iteration, which remains O(|S|).
import sys
def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, [], []
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    g = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it)); w = int(next(it))
        g[u].append((v, w)); g[v].append((u, w))
    queries = []
    for _ in range(q):
        t = int(next(it))
        if t == 1 or t == 2:
            l = int(next(it)); r = int(next(it))
            queries.append((t, l, r))
        else:
            x = int(next(it))
            queries.append((t, x))
    return n, q, g, queries

class LCAPathMax:
    def __init__(self, n, g, root=1):
        self.n = n
        self.LOG = (n).bit_length()
        self.up = [[0]*(n+1) for _ in range(self.LOG)]
        self.mx = [[0]*(n+1) for _ in range(self.LOG)]
        self.depth = [0]*(n+1)
        self._dfs_build(g, root)
        for k in range(1, self.LOG):
            for v in range(1, n+1):
                mid = self.up[k-1][v]
                self.up[k][v] = self.up[k-1][mid]
                self.mx[k][v] = max(self.mx[k-1][v], self.mx[k-1][mid])

    def _dfs_build(self, g, root):
        st = [(root, 0, 0)]
        while st:
            v, p, w = st.pop()
            self.up[0][v] = p
            self.mx[0][v] = w
            if p != 0:
                self.depth[v] = self.depth[p] + 1
            for to, wt in g[v]:
                if to == p: continue
                st.append((to, v, wt))

    def path_max(self, a, b):
        if a == b: return 0
        if self.depth[a] < self.depth[b]:
            a, b = b, a
        ans = 0
        diff = self.depth[a] - self.depth[b]
        k = 0
        while diff:
            if diff & 1:
                ans = max(ans, self.mx[k][a])
                a = self.up[k][a]
            diff >>= 1; k += 1
        if a == b: return ans
        for k in range(self.LOG-1, -1, -1):
            if self.up[k][a] != self.up[k][b]:
                ans = max(ans, self.mx[k][a], self.mx[k][b])
                a = self.up[k][a]; b = self.up[k][b]
        ans = max(ans, self.mx[0][a], self.mx[0][b])
        return ans

def solve_all():
    n, q, g, queries = read_input()
    if n == 0 and q == 0:
        return
    lca = LCAPathMax(n, g, 1)
    open_flag = [False]*(n+1)
    open_set = set()
    out = []
    for qr in queries:
        t = qr[0]
        if t == 1:
            _, l, r = qr
            for i in range(l, r+1):
                if not open_flag[i]:
                    open_flag[i] = True
                    open_set.add(i)
        elif t == 2:
            _, l, r = qr
            for i in range(l, r+1):
                if open_flag[i]:
                    open_flag[i] = False
                    if i in open_set: open_set.remove(i)
        else:
            _, x = qr
            if not open_set:
                out.append("-1")
                continue
            best = 0
            for y in open_set:
                best = max(best, lca.path_max(x, y))
            out.append(str(-1 if best == 0 else best))
    sys.stdout.write("\n".join(out))

def main():
    solve_all()

if __name__ == "__main__":
    # Quick assert on path_max
    if sys.stdin.isatty():
        g = [[] for _ in range(4)]
        g[1].append((2,5)); g[2].append((1,5))
        g[2].append((3,1)); g[3].append((2,1))
        g[2].append((4,7)); g[4].append((2,7))
        lca = LCAPathMax(4, g, 1)
        assert lca.path_max(3,4) == 7
    main()
\end{minted}
\VALIDATION{Verify that path maxima match manual calculations on small trees; check $S=\varnothing$ and $S=\{x\}$ return $-1$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Edge-Side Activity Decomposition + HLD Filtering}
\WHICHFORMULA{Key observation: For any directed edge (parent $\to$ child) identified by its child $v$, the path from $x$ to some $y\in S$ uses this edge iff either $x\notin \text{subtree}(v)$ and $\text{act}(v)>0$, or $x\in \text{subtree}(v)$ and $\text{act}(v)<|S|$, where $\text{act}(v)$ is the number of open nodes in $\text{subtree}(v)$. Thus
\begin{BreakableEquation*}
f(x;S)=\max\Big\{\max_{\substack{v:\ x\notin \text{sub}(v)\\ \text{act}(v)>0}} w(v),\ \max_{\substack{v:\ x\in \text{sub}(v)\\ \text{act}(v)<|S|}} w(v)\Big\}.
\end{BreakableEquation*}
The first term is independent of $x$ except for excluding path edges; the second term is a path query over $x\to \text{root}$ with predicate $\text{act}(v)<|S|$. Maintain:
\begin{itemize}
\item a global structure over all child-edges storing $w(v)$ if $\text{act}(v)>0$ (else $-\infty$), supporting point updates and querying max;
\item an HLD segment tree over the same edge-indexing for path maxima with predicate $\text{act}(v)<|S|$ (else $-\infty$).
\end{itemize}
Range open/close updates over label intervals translate to range add/remove on $\text{act}(v)$ via a BIT over Euler tour of vertices (to query subtree counts), or by maintaining a second mapping from labels to Euler-in to allow $O(\log n)$ point toggles.}
\ASSUMPTIONS{Root the tree; identify each edge by its child vertex. Use Heavy-Light Decomposition over vertices to make ancestor-path queries logarithmic; maintain $|S|$ and $\text{act}(v)$ under updates.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute Euler tour $(\text{tin},\text{tout})$ and HLD arrays so each child edge corresponds to a position.
\item Maintain $|S|$ and a BIT over vertex Euler positions to get $\text{act}(v)$ in $O(\log n)$.
\item Maintain two segment trees:
  \begin{itemize}
  \item Global-max tree $A$: at position $v$, store $w(v)$ if $\text{act}(v)>0$, else $-\infty$.
  \item Path-max tree $B$: at position $v$, store $w(v)$ if $\text{act}(v)<|S|$, else $-\infty$.
  \end{itemize}
\item For update on $[l,r]$, toggle each label's membership and update its ancestors' $\text{act}$ using the BIT, reflected to $A$ and $B$ on edges whose $\text{act}$ predicate changes.
\item For query at $x$, compute:
  \begin{itemize}
  \item $v_1 = \text{HLD\_path\_max}(B, x, \text{root})$;
  \item $v_2 = \text{global\_max}(A)$ possibly excluding the edges on the path from $x$ to root (this exclusion can be implemented by querying $A$ on the complement of $O(\log n)$ HLD segments; or by augmenting $A$ with top-2 values to subtract the covered segments).
  \end{itemize}
Return $\max(v_1, v_2)$ if it is finite; else $-1$.
\end{algosteps}
\OPTIMALITY{Each toggle changes $O(\log n)$ edge predicates; each query is $O(\log^2 n)$ using HLD. With careful augmentation for complement queries, $O(\log n)$ is achievable. This matches the per-query lower bounds for dynamic tree set problems with range updates in the comparison model.}
\COMPLEXITY{Preprocessing: $O(n)$. Each point toggle: $O(\log n)$. Each range update with $k$ changes: $O(k\log n)$. Each query: $O(\log^2 n)$ or $O(\log n)$ with augmented segment trees.}
\[
\begin{aligned}
T_{\text{pre}}(n)&=O(n),\quad T_{\text{upd}}=O(k\log n),\quad T_{\text{qry}}=O(\log^2 n)\ \text{(or $O(\log n)$)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# Reference implementation prioritizes clarity and correctness. It uses LCA with
# O(|S| log n) query time; range updates are O(r-l+1). This is suitable as a
# pedagogical reference and for small/medium tests.
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, [], []
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    g = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it)); w = int(next(it))
        g[u].append((v, w)); g[v].append((u, w))
    queries = []
    for _ in range(q):
        t = int(next(it))
        if t == 1 or t == 2:
            l = int(next(it)); r = int(next(it))
            queries.append((t, l, r))
        else:
            x = int(next(it))
            queries.append((t, x))
    return n, q, g, queries

class LCAPathMax:
    def __init__(self, n, g, root=1):
        self.n = n
        self.LOG = (n).bit_length()
        self.up = [[0]*(n+1) for _ in range(self.LOG)]
        self.mx = [[0]*(n+1) for _ in range(self.LOG)]
        self.depth = [0]*(n+1)
        self._dfs_build(g, root)
        for k in range(1, self.LOG):
            upk = self.up[k]; upkm1 = self.up[k-1]
            mxk = self.mx[k]; mxkm1 = self.mx[k-1]
            for v in range(1, n+1):
                mid = upkm1[v]
                upk[v] = upkm1[mid]
                mxk[v] = mxkm1[v] if mxkm1[v] >= mxkm1[mid] else mxkm1[mid]

    def _dfs_build(self, g, root):
        st = [(root, 0, 0)]
        while st:
            v, p, w = st.pop()
            self.up[0][v] = p
            self.mx[0][v] = w
            if p != 0:
                self.depth[v] = self.depth[p] + 1
            for to, wt in g[v]:
                if to == p: continue
                st.append((to, v, wt))

    def path_max(self, a, b):
        if a == b: return 0
        if self.depth[a] < self.depth[b]:
            a, b = b, a
        ans = 0
        diff = self.depth[a] - self.depth[b]
        k = 0
        while diff:
            if diff & 1:
                va = self.mx[k][a]
                if va > ans: ans = va
                a = self.up[k][a]
            diff >>= 1; k += 1
        if a == b: return ans
        for k in range(self.LOG-1, -1, -1):
            if self.up[k][a] != self.up[k][b]:
                va = self.mx[k][a]; vb = self.mx[k][b]
                if va > ans: ans = va
                if vb > ans: ans = vb
                a = self.up[k][a]; b = self.up[k][b]
        # one more step to LCA
        if self.mx[0][a] > ans: ans = self.mx[0][a]
        if self.mx[0][b] > ans: ans = self.mx[0][b]
        return ans

def solve_all():
    n, q, g, queries = read_input()
    if n == 0 and q == 0:
        return
    lca = LCAPathMax(n, g, 1)
    open_flag = [False]*(n+1)
    open_set = set()
    out = []
    for qr in queries:
        t = qr[0]
        if t == 1:
            _, l, r = qr
            for i in range(l, r+1):
                if not open_flag[i]:
                    open_flag[i] = True
                    open_set.add(i)
        elif t == 2:
            _, l, r = qr
            for i in range(l, r+1):
                if open_flag[i]:
                    open_flag[i] = False
                    if i in open_set:
                        open_set.remove(i)
        else:
            _, x = qr
            if not open_set:
                out.append("-1")
                continue
            best = 0
            # Iterate open set and compute path max to x
            for y in open_set:
                pm = lca.path_max(x, y)
                if pm > best: best = pm
            out.append(str(-1 if best == 0 else best))
    sys.stdout.write("\n".join(out))

def main():
    solve_all()

if __name__ == "__main__":
    # Minimal correctness asserts when run interactively
    if sys.stdin.isatty():
        # A tiny tree: 1-2(3), 2-3(2), 1-4(5)
        n = 4
        g = [[] for _ in range(n+1)]
        g[1].append((2,3)); g[2].append((1,3))
        g[2].append((3,2)); g[3].append((2,2))
        g[1].append((4,5)); g[4].append((1,5))
        lca = LCAPathMax(n, g, 1)
        assert lca.path_max(3,4) == 5
        assert lca.path_max(2,3) == 2
        assert lca.path_max(1,4) == 5
    main()
\end{minted}
\VALIDATION{Exactly 3 quick checks:
\begin{itemize}
\item On a line of 3 nodes with weights $(3,2)$, $\text{pathMax}(1,3)=3$.
\item If $S=\varnothing$, any query returns $-1$.
\item If $S=\{x\}$, any query at $x$ returns $-1$.
\end{itemize}}
\RESULT{For each type-$3$ query, the algorithm outputs $f(x;S)$, or $-1$ if no edge lies on a path from $x$ to any open node.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the LCA path-maximum routine on small trees; simulate short sequences of opens/closes/queries; compare against a brute-force path walk that scans edges along LCAs.}
\LINE{CROSS-CHECKS}{For small $n$, run both the baseline and an even simpler $O(n)$ per pair path walk and compare all query outputs over random operations.}
\LINE{EDGE-CASE GENERATOR}{Generate stars, chains, and balanced trees with random weights; test ranges covering none/all nodes; test toggling the same range repeatedly.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_chain(n):
    g = [[] for _ in range(n+1)]
    edges = []
    for i in range(1, n):
        w = i  # deterministic
        g[i].append((i+1, w)); g[i+1].append((i, w))
        edges.append((i, i+1, w))
    return g, edges

def brute_path_max(n, g, u, v):
    # BFS to get path then max; for testing only
    par = [-1]*(n+1); pew = [0]*(n+1)
    from collections import deque
    dq = deque([u]); par[u] = 0
    while dq:
        x = dq.popleft()
        if x == v: break
        for to, w in g[x]:
            if par[to] == -1:
                par[to] = x; pew[to] = w; dq.append(to)
    ans = 0; cur = v
    while cur != u:
        ans = max(ans, pew[cur]); cur = par[cur]
    return ans

def test_small():
    n = 6
    g, edges = gen_chain(n)
    # test brute vs LCA
    lca = LCAPathMax(n, g, 1)
    for u in range(1, n+1):
        for v in range(1, n+1):
            assert lca.path_max(u, v) == brute_path_max(n, g, u, v)

# Note: This test harness is illustrative; the final submission code uses the LCA-based solver.
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
# Matches the "Approach C — Code (Final Submission)" block for consistency.
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, [], []
    it = iter(data)
    n = int(next(it)); q = int(next(it))
    g = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = int(next(it)); v = int(next(it)); w = int(next(it))
        g[u].append((v, w)); g[v].append((u, w))
    queries = []
    for _ in range(q):
        t = int(next(it))
        if t == 1 or t == 2:
            l = int(next(it)); r = int(next(it))
            queries.append((t, l, r))
        else:
            x = int(next(it))
            queries.append((t, x))
    return n, q, g, queries

class LCAPathMax:
    def __init__(self, n, g, root=1):
        self.n = n
        self.LOG = (n).bit_length()
        self.up = [[0]*(n+1) for _ in range(self.LOG)]
        self.mx = [[0]*(n+1) for _ in range(self.LOG)]
        self.depth = [0]*(n+1)
        self._dfs_build(g, root)
        for k in range(1, self.LOG):
            for v in range(1, n+1):
                mid = self.up[k-1][v]
                self.up[k][v] = self.up[k-1][mid]
                self.mx[k][v] = max(self.mx[k-1][v], self.mx[k-1][mid])

    def _dfs_build(self, g, root):
        st = [(root, 0, 0)]
        while st:
            v, p, w = st.pop()
            self.up[0][v] = p
            self.mx[0][v] = w
            if p != 0:
                self.depth[v] = self.depth[p] + 1
            for to, wt in g[v]:
                if to == p: continue
                st.append((to, v, wt))

    def path_max(self, a, b):
        if a == b: return 0
        if self.depth[a] < self.depth[b]:
            a, b = b, a
        ans = 0
        diff = self.depth[a] - self.depth[b]
        k = 0
        while diff:
            if diff & 1:
                ans = max(ans, self.mx[k][a])
                a = self.up[k][a]
            diff >>= 1; k += 1
        if a == b: return ans
        for k in range(self.LOG-1, -1, -1):
            if self.up[k][a] != self.up[k][b]:
                ans = max(ans, self.mx[k][a], self.mx[k][b])
                a = self.up[k][a]; b = self.up[k][b]
        ans = max(ans, self.mx[0][a], self.mx[0][b])
        return ans

def solve_all():
    n, q, g, queries = read_input()
    if n == 0 and q == 0:
        return
    lca = LCAPathMax(n, g, 1)
    open_flag = [False]*(n+1)
    open_set = set()
    out = []
    for qr in queries:
        t = qr[0]
        if t == 1:
            _, l, r = qr
            for i in range(l, r+1):
                if not open_flag[i]:
                    open_flag[i] = True
                    open_set.add(i)
        elif t == 2:
            _, l, r = qr
            for i in range(l, r+1):
                if open_flag[i]:
                    open_flag[i] = False
                    if i in open_set:
                        open_set.remove(i)
        else:
            _, x = qr
            if not open_set:
                out.append("-1")
                continue
            best = 0
            for y in open_set:
                best = max(best, lca.path_max(x, y))
            out.append(str(-1 if best == 0 else best))
    sys.stdout.write("\n".join(out))

def main():
    solve_all()

if __name__ == "__main__":
    # Simple embedded asserts for helper (triggered when no stdin provided)
    if sys.stdin.isatty():
        g = [[] for _ in range(5)]
        g[1].append((2,3)); g[2].append((1,3))
        g[2].append((3,2)); g[3].append((2,2))
        g[1].append((4,5)); g[4].append((1,5))
        g[4].append((5,4)); g[5].append((4,4))
        lca = LCAPathMax(5, g, 1)
        assert lca.path_max(3,5) == 5
        assert lca.path_max(2,3) == 2
        assert lca.path_max(1,1) == 0
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute, for a tree with dynamic open/close of vertex ranges, the maximum edge weight on a path from a query node to any open vertex.}
\WHY{Dynamic tree set queries with various path metrics are common in advanced interviews and competitions; they probe LCA/HLD expertise and data structure design.}
\CHECKLIST{
\begin{bullets}
\item Preprocess LCA and path-maximum tables.
\item Maintain the set of open nodes and its size.
\item For each query, handle empty or singleton cases ($-1$).
\item Combine maxima correctly; path with no edges gives $0$ which maps to $-1$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $S=\varnothing$.
\item $S=\{x\}$ only.
\item All nodes open.
\item Tree is a line; tree is a star.
\item Multiple edges with identical maximum weights.
\item Weights up to $10^9$; ensure no overflow in languages with fixed-size ints.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting that path from $x$ to $x$ has no edges (answer $-1$ if $S=\{x\}$).
\item Off-by-one in range updates.
\item Mixing label order with Euler order; they are different.
\item Not resetting per-query accumulators.
\item Using recursion without increasing limits on deep trees (choose iterative).
\item Inefficient I/O on large inputs (use buffered I/O).
\end{bullets}}
\FAILMODES{Approaches that scan the whole tree per query will time out. Ignoring the distinction between label ranges and subtree ranges leads to incorrect updates if attempted naively.}
\ELI{Precompute how to get the heaviest edge between any two nodes fast. Keep track of which stores are open. When asked about $x$, check all open stores and pick the path with the biggest edge; if there is no edge (only $x$ is open), say $-1$.}
\NotePages{3}

\end{document}