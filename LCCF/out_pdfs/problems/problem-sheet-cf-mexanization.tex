% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — MEXanization}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1870/G}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{Let $f(S)$. Let $S$ be a multiset (i.e., it can contain repeated elements) of non-negative integers. In one operation, you can choose any non-empty subset of $S$ (which can also contain repeated elements), remove this subset (all elements in it) from $S$, and add the MEX of the removed subset to $S$. You can perform any number of such operations. After all the operations, $S$ should contain exactly $1$ number. $f(S)$ is the largest number that could remain in $S$ after any sequence of operations.

You are given an array of non-negative integers $a$ of length $n$. For each of its $n$ prefixes, calculate $f(S)$ if $S$ is the corresponding prefix (for the $i$-th prefix, $S$ consists of the first $i$ elements of array $a$).

The MEX (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. For instance:
\begin{itemize}
\item The MEX of $[2, 2, 1]$ is $0$, because $0$ does not belong to the array.
\item The MEX of $[3, 1, 0, 1]$ is $2$, because $0$ and $1$ belong to the array, but $2$ does not.
\item The MEX of $[0, 3, 1, 2]$ is $4$, because $0$, $1$, $2$ and $3$ belong to the array, but $4$ does not.
\end{itemize}

Input:
The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases. Then follows the description of the test cases.

The first line of each test case contains an integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the size of array $a$.

The second line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le 2 \cdot 10^5$) — the array $a$.

It is guaranteed that the sum of all $n$ values across all test cases does not exceed $2 \cdot 10^5$.

Output:
For each test case, output $n$ numbers: $f(S)$ for each of the $n$ prefixes of array $a$.

Note:
Consider the first test case. For a prefix of length $1$, the initial multiset is $\{179\}$. If we do nothing, we get $179$.

For a prefix of length $2$, the initial multiset is $\{57, 179\}$. Using the following sequence of operations, we can obtain $2$.
\begin{enumerate}
\item Apply the operation to $\{57\}$, the multiset becomes $\{0, 179\}$.
\item Apply the operation to $\{179\}$, the multiset becomes $\{0, 0\}$.
\item Apply the operation to $\{0\}$, the multiset becomes $\{0, 1\}$.
\item Apply the operation to $\{0, 1\}$, the multiset becomes $\{2\}$. This is our answer.
\end{enumerate}
Consider the second test case. For a prefix of length $1$, the initial multiset is $\{0\}$. If we apply the operation to $\{0\}$, the multiset becomes $\{1\}$. This is the answer.}
\BREAKDOWN{We must compute, for each prefix multiset $S$, the maximum final number after repeatedly replacing any chosen submultiset by its MEX until one number remains. Derive a feasibility check characterizing when all $0,1,\ldots,M-1$ can be made present simultaneously while $M$ is absent right before the final all-in operation, and evaluate it efficiently for each prefix.}
\ELI{Right before the last move, try to have all numbers from $0$ to $M-1$ present (but no $M$), then taking the whole multiset gives MEX $=M$. Check if available elements can supply missing values using ``spares''.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integer $n$ and an array $a$ of length $n$ with $0 \le a_i \le 2\cdot 10^5$.}
\OUTPUTS{For each test case, $n$ integers: the value of $f(S)$ for each prefix of $a$. Values are space-separated per test.}
\SAMPLES{Example micro-cases:
\begin{itemize}
\item $a=[0] \Rightarrow$ output $1$ (apply to $\{0\}$ to get $\{1\}$).
\item $a=[57, 179] \Rightarrow$ outputs $179$ for the first prefix, $2$ for the second.
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given multiset $S \subseteq \mathbb{Z}_{\ge 0}$, one move replaces a non-empty submultiset $T \subseteq S$ with $\operatorname{mex}(T)$, i.e., $S \leftarrow (S \multisetminus T) \uplus \{\operatorname{mex}(T)\}$. Define $f(S)$ as the maximum possible remaining element when $|S|$ is reduced to $1$. For prefix $S_i = \{a_1,\ldots,a_i\}$, compute $f(S_i)$.}
\varmapStart
\var{c_x}{frequency of value $x$ in $S$}
\var{n}{current prefix size}
\var{M}{candidate final value}
\var{D(M)}{\textit{duplicates} among $[0,M-1]$: $D(M)=\sum_{x=0}^{M-1}\max(0,c_x-1)$}
\var{G(M)}{\textit{geq}-mass: number of elements $\ge M$, i.e., $G(M)=n-\sum_{x=0}^{M-1}c_x$}
\var{R(M)}{\textit{required spares}: $R(M)=\mathbf{1}[M\ge 1]\mathbf{1}[c_0=0]+\mathbf{1}[M\ge 2]\mathbf{1}[c_1=0]+2\cdot \#\{x\in[2,M-1]:c_x=0\}$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Feasible}(M) \iff D(M)+G(M) \ge R(M),\ \text{and if }n=1,\ f(S)=\max(a_1,1).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Final operation takes the whole multiset; to achieve final value $M$, ensure that right before the last move, each of $0,1,\ldots,M-1$ is present but $M$ is absent. Elements $\ge M$ (including $M$) can be converted via singleton moves into spares. Singleton moves preserve multiset size; combining a subset reduces size and can create higher labels.}
\INVARIANTS{
\begin{itemize}
\item Singleton on $\{x\}$ yields $0$ for $x\ne 0$ and $1$ for $x=0$; hence any element can become $0$ or $1$ without changing $|S|$.
\item To synthesize a missing value $\ge 2$ without losing reserved copies of lower labels, two spare elements suffice (convert to a duplicate $0$ and $1$, then combine to get $2$; iterate inductively).
\item Right before the last move, mex of the whole set equals the desired $M$ iff $[0,M-1]$ are present and $M$ is absent.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{State-space search over multisets by enumerating all non-empty submultisets, replacing by their MEX, and maximizing the terminal value when size becomes $1$.}
\ASSUMPTIONS{Only feasible for tiny $n$ (say $n\le 5$) due to exponential branching ($2^n-1$ subsets at each step).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Represent the multiset state as a sorted tuple.
\item BFS/DFS: for each state, enumerate all non-empty index-subsets, compute MEX of the extracted subarray, and push the new state.
\item Track the maximum terminal value when a length-$1$ state is reached.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ and value spread. Suitable only for verification on tiny inputs.}
\[
\begin{aligned}
T(n) &\approx O\!\left(\text{number of reachable states} \times 2^n\right),\quad S(n)=O(\text{visited states})
\end{aligned}
\]
\CORRECTNESS{By exhaustive exploration of all legal sequences of operations.}
\EDGECASES{Singleton multiset; all elements identical; already containing a long $[0..k]$ block.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
from functools import lru_cache

def mex_of_list(arr):
    s = set(arr)
    m = 0
    while m in s:
        m += 1
    return m

def all_submasks_indices(m):  # non-empty submasks of {0..m-1}
    for mask in range(1, 1 << m):
        yield mask

def apply_subset(state, mask):
    # state is a list, mask selects indices to remove
    removed = []
    rest = []
    for i, v in enumerate(state):
        if (mask >> i) & 1:
            removed.append(v)
        else:
            rest.append(v)
    if not removed:
        return None
    m = mex_of_list(removed)
    rest.append(m)
    rest.sort()
    return tuple(rest)

@lru_cache(maxsize=None)
def brute_max_terminal(state):
    # state: tuple sorted
    if len(state) == 1:
        return state[0]
    best = -1
    m = len(state)
    for mask in all_submasks_indices(m):
        nxt = apply_subset(list(state), mask)
        if nxt is None:
            continue
        best = max(best, brute_max_terminal(nxt))
    return best

def brute_f_of_array(arr):
    return brute_max_terminal(tuple(sorted(arr)))
\end{minted}
\VALIDATION{Use for $n \le 5$ arrays as an oracle to check improved/optimal approaches on random tiny cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy Feasibility via Spares Accounting}
\WHICHFORMULA{Right before the final all-in operation, to get final value $M$, ensure $[0,M-1]$ present and $M$ absent. Available \emph{spares} are duplicates from $[0,M-1]$ plus all elements $\ge M$. Required spares equal the number of missing among $\{0,1\}$ plus $2$ times the number missing in $\{2,\ldots,M-1\}$.}
\ASSUMPTIONS{Singleton operations freely toggle values into $0/1$ without shrinking size; synthesizing a missing $\ge 2$ requires two spare elements.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain frequencies $c_x$ for the current prefix.
\item For any candidate $M$, compute:
\begin{itemize}
\item $S = \sum_{x=0}^{M-1} c_x$ and $U = \#\{x\in[0,M-1]\mid c_x \ge 1\}$.
\item Duplicates $D(M)=S-U$, and $G(M)=n-S$.
\item Missing among $\{0,1\}$, and missing among $\{2,\ldots,M-1\}$.
\end{itemize}
\item Feasible iff $D(M)+G(M) \ge R(M)$; choose maximum $M$.
\end{algosteps}
\COMPLEXITY{Per-prefix feasibility check is $O(1)$ given prefix sums; with binary search on $M$, per-prefix $O(\log V)$ where $V$ is the value bound.}
\[
\begin{aligned}
T(\text{test}) &\approx O\bigl(n \log V\bigr),\quad S(\text{test})=O(V)
\end{aligned}
\]
\CORRECTNESS{Spares count accounts for all elements that can be used without removing the reserved one-per-value in $[0,M-1]$. Each missing in $\{2,\ldots\}$ costs $2$ spares by constructing duplicate $0$ and $1$ and inductively combining; missing among $\{0,1\}$ costs $1$ each.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Fenwick:
    def __init__(self, n):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, i, delta):
        i += 1
        n = self.n + 1
        while i < n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i):
        if i < 0:
            return 0
        if i >= self.n:
            i = self.n - 1
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

def feasible_M(M, n, bit_cnt, bit_dist, freq0, freq1):
    if M == 0:
        return True
    S = bit_cnt.sum(M-1)          # total count in [0..M-1]
    U = bit_dist.sum(M-1)         # number of distinct labels in [0..M-1]
    D = S - U                     # duplicates in [0..M-1]
    G = n - S                     # elements with value >= M
    miss0 = 1 if (M >= 1 and freq0 == 0) else 0
    miss1 = 1 if (M >= 2 and freq1 == 0) else 0
    missing_small = miss0 + miss1
    if M <= 2:
        missing_big = 0
    else:
        has0 = 1 if (M >= 1 and freq0 > 0) else 0
        has1 = 1 if (M >= 2 and freq1 > 0) else 0
        U2 = U - has0 - has1
        missing_big = (M - 2) - U2
    required = missing_small + 2*missing_big
    available = D + G
    return available >= required
\end{minted}
\VALIDATION{Cross-check against brute force for random tiny arrays ($n \le 5$, values in $[0,5]$).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Online Prefix Answers with Fenwick Trees}
\WHICHFORMULA{Maintain two Fenwick trees per test case: one for frequencies and one for distinct indicators. After each prefix extension, binary search the largest feasible $M$ via the feasibility function. For prefix length $1$, the answer is $\max(a_1,1)$ (you may do zero operations).}
\ASSUMPTIONS{Value domain bounded by $\max(a)$ per test plus $n$ slack; Fenwick supports $O(\log V)$ updates/queries.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $V_{\max}$ for the test and size both Fenwicks to $V_{\max} + n + 5$.
\item Maintain frequency dictionary; on adding $x$, increment count BIT and if first occurrence, increment distinct BIT at $x$.
\item If current prefix length is $1$, print $\max(a_1,1)$.
\item Else binary search $M\in[0, U]$ with $U = \max\_seen + \text{prefix\_len} + 5$ using the feasibility function.
\item Output the maximal $M$.
\end{algosteps}
\OPTIMALITY{Each prefix answer uses $O(\log V)$ amortized time. The feasibility inequality is tight via the spares accounting argument; any smaller bound would fail for constructed adversarial distributions.}
\COMPLEXITY{For a test with $n$ elements and value bound $V$, time $O(n\log V\log U)$ with $U=O(V+n)$; space $O(V)$.}
\[
\begin{aligned}
T(n) &= O\bigl(n \log V \log(V+n)\bigr),\quad S(n)=O(V)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from random import Random

class Fenwick:
    def __init__(self, n):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, i, delta):
        if i < 0:
            return
        if i >= self.n:
            return
        i += 1
        n = self.n + 1
        while i < n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i):
        if i < 0:
            return 0
        if i >= self.n:
            i = self.n - 1
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

def feasible_M(M, n, bit_cnt, bit_dist, freq0, freq1):
    if M == 0:
        return True
    S = bit_cnt.sum(M-1)          # total in [0..M-1]
    U = bit_dist.sum(M-1)         # distinct in [0..M-1]
    D = S - U                     # duplicates in [0..M-1]
    G = n - S                     # mass >= M
    miss0 = 1 if (M >= 1 and freq0 == 0) else 0
    miss1 = 1 if (M >= 2 and freq1 == 0) else 0
    missing_small = miss0 + miss1
    if M <= 2:
        missing_big = 0
    else:
        has0 = 1 if (M >= 1 and freq0 > 0) else 0
        has1 = 1 if (M >= 2 and freq1 > 0) else 0
        U2 = U - has0 - has1
        missing_big = (M - 2) - U2
    required = missing_small + 2*missing_big
    available = D + G
    return available >= required

def prefix_answers_for_test(a):
    n = len(a)
    maxA = max(a) if a else 0
    V = maxA + n + 5
    bit_cnt = Fenwick(V)
    bit_dist = Fenwick(V)
    freq = {}
    ans = []
    max_seen = -1
    freq0 = 0
    freq1 = 0
    for i, x in enumerate(a, 1):
        prev = freq.get(x, 0)
        freq[x] = prev + 1
        bit_cnt.add(x, 1)
        if prev == 0:
            bit_dist.add(x, 1)
        if x == 0:
            freq0 += 1
        if x == 1:
            freq1 += 1
        max_seen = max(max_seen, x)
        if i == 1:
            ans.append(max(x, 1))
            continue
        lo, hi = 0, max_seen + i + 5
        # Binary search maximal M
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if feasible_M(mid, i, bit_cnt, bit_dist, freq0, freq1):
                lo = mid
            else:
                hi = mid - 1
        ans.append(lo)
    return ans

def read_input(data):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append(arr)
    return tests

def solve_all(data):
    tests = read_input(data)
    out_lines = []
    for arr in tests:
        res = prefix_answers_for_test(arr)
        out_lines.append(" ".join(map(str, res)))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-test
        # Known tiny checks
        assert prefix_answers_for_test([0]) == [1]
        assert prefix_answers_for_test([57,179])[0] == max(57,1)
        # brute cross-check on small random
        def mex_of_list(arr):
            s = set(arr)
            m = 0
            while m in s:
                m += 1
            return m
        from functools import lru_cache
        def all_submasks_indices(m):
            for mask in range(1, 1 << m):
                yield mask
        def apply_subset(state, mask):
            removed = []
            rest = []
            for i, v in enumerate(state):
                if (mask >> i) & 1:
                    removed.append(v)
                else:
                    rest.append(v)
            if not removed:
                return None
            m = mex_of_list(removed)
            rest.append(m)
            rest.sort()
            return tuple(rest)
        from collections import deque
        import itertools
        @lru_cache(maxsize=None)
        def brute_max_terminal(state):
            if len(state) == 1:
                return state[0]
            best = -1
            m = len(state)
            for mask in all_submasks_indices(m):
                nxt = apply_subset(list(state), mask)
                if nxt is None:
                    continue
                best = max(best, brute_max_terminal(nxt))
            return best
        def brute_f_of_array(arr):
            return brute_max_terminal(tuple(sorted(arr)))
        rng = Random(0)
        for _ in range(50):
            n = rng.randint(1, 4)
            arr = [rng.randint(0, 4) for _ in range(n)]
            pref = []
            cur = []
            ok = True
            for v in arr:
                cur.append(v)
                if len(cur) == 1:
                    got = prefix_answers_for_test(cur)[-1]
                    exp = max(cur[0], 1)
                    assert got == exp
                else:
                    got = prefix_answers_for_test(cur)[-1]
                    exp = brute_f_of_array(cur)
                    # The feasibility-based method should match brute on tiny;
                    # Allow as assertion to catch obvious regressions.
                    assert got == exp, (cur, got, exp)
            # no exception means pass
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts or I/O mini-tests:
\begin{itemize}
\item Assert prefix $[0] \mapsto 1$.
\item Assert first prefix of $[57, 179]$ equals $\max(57, 1)$.
\item Random exhaustive cross-checks for $n \le 4$, values $\le 4$ against brute force.
\end{itemize}
}
\RESULT{For each prefix multiset $S$, the printed value is the maximal final number achievable under the operation rules. Ties are irrelevant as only a single number is output per prefix.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on crafted edge cases; random tiny arrays cross-checked versus brute force; monotone growth of feasible $M$ under addition of helpful elements.}
\LINE{CROSS-CHECKS}{Compare Approach B/C against brute force for small $n$ to validate feasibility inequality and binary search.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with all large values, only zeros, only ones, long consecutive prefixes $[0..k]$, and random mixes.}
\begin{minted}{python}
def gen_edges():
    cases = []
    cases.append([0])
    cases.append([1])
    cases.append([2])
    cases.append([0,0,0])
    cases.append([1,1,1])
    cases.append([2,2,2])
    cases.append([0,1,2])
    cases.append([5,4,3,2,1,0])
    cases.append([0,2,4,6,8,10])
    return cases

def reference_solution_io():
    # Wrapper to feed the solver
    import sys
    data = "3\n1\n0\n2\n57 179\n6\n0 2 4 6 8 10\n"
    print(solve_all(data))

if __name__ == "__main__":
    for c in gen_edges():
        print(c, "->", prefix_answers_for_test(c))
    reference_solution_io()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

class Fenwick:
    def __init__(self, n):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, i, delta):
        if i < 0 or i >= self.n:
            return
        i += 1
        n = self.n + 1
        while i < n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i):
        if i < 0:
            return 0
        if i >= self.n:
            i = self.n - 1
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

def feasible_M(M, n, bit_cnt, bit_dist, freq0, freq1):
    if M == 0:
        return True
    S = bit_cnt.sum(M-1)
    U = bit_dist.sum(M-1)
    D = S - U
    G = n - S
    miss0 = 1 if (M >= 1 and freq0 == 0) else 0
    miss1 = 1 if (M >= 2 and freq1 == 0) else 0
    missing_small = miss0 + miss1
    if M <= 2:
        missing_big = 0
    else:
        has0 = 1 if (M >= 1 and freq0 > 0) else 0
        has1 = 1 if (M >= 2 and freq1 > 0) else 0
        U2 = U - has0 - has1
        missing_big = (M - 2) - U2
    required = missing_small + 2*missing_big
    available = D + G
    return available >= required

def prefix_answers_for_test(a):
    n = len(a)
    maxA = max(a) if a else 0
    V = maxA + n + 5
    bit_cnt = Fenwick(V)
    bit_dist = Fenwick(V)
    freq = {}
    ans = []
    max_seen = -1
    freq0 = 0
    freq1 = 0
    for i, x in enumerate(a, 1):
        prev = freq.get(x, 0)
        freq[x] = prev + 1
        bit_cnt.add(x, 1)
        if prev == 0:
            bit_dist.add(x, 1)
        if x == 0:
            freq0 += 1
        if x == 1:
            freq1 += 1
        max_seen = max(max_seen, x)
        if i == 1:
            ans.append(max(x, 1))
            continue
        lo, hi = 0, max_seen + i + 5
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if feasible_M(mid, i, bit_cnt, bit_dist, freq0, freq1):
                lo = mid
            else:
                hi = mid - 1
        ans.append(lo)
    return ans

def read_input(data):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append(arr)
    return tests

def solve_all(data):
    tests = read_input(data)
    out_lines = []
    for arr in tests:
        res = prefix_answers_for_test(arr)
        out_lines.append(" ".join(map(str, res)))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    print(solve_all(data))

if __name__ == "__main__":
    # Minimal sanity checks
    assert prefix_answers_for_test([0]) == [1]
    assert prefix_answers_for_test([57,179])[0] == max(57, 1)
    assert prefix_answers_for_test([0,1,2])[2] >= 3
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the final MEX by ensuring, right before the last all-in operation, that $[0..M-1]$ are present and $M$ is absent; count whether available spares can cover missing labels.}
\WHY{Mex-centric replacement operations show up in impartial game reductions and interview tasks that test your ability to reason about MEX feasibility with resource accounting.}
\CHECKLIST{
\begin{itemize}
\item Track counts $c_x$.
\item Maintain prefix sums and distinct counts.
\item For a candidate $M$, compute duplicates $D(M)$ and geq mass $G(M)$.
\item Compute required spares $R(M)$: missing among $\{0,1\}$ plus twice missing in $[2..M-1]$.
\item Binary search the largest feasible $M$.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item Single-element prefix: answer is $\max(a_1,1)$.
\item All large elements: feasibility limited by spares only.
\item Already containing long consecutive $[0..k]$ block: can jump to $k+1$ immediately.
\item Many duplicates below $M$: they increase $D(M)$.
\item Presence of $M$: treat as spare via singleton conversion.
\item Zero or one missing at $\{0,1\}$: cost is $1$ each, not $2$.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Forgetting that the final operation must take the whole multiset.
\item Miscounting duplicates vs.\ distincts in $[0..M-1]$.
\item Charging $2$ spares for missing $0$ or $1$ (they cost only $1$ each).
\item Off-by-one in BIT prefix sums for $M=0,1,2$.
\item Not including elements equal to $M$ in $G(M)$ (they are usable spares).
\item Overshooting value-domain size for Fenwick arrays.
\end{itemize}
}
\FAILMODES{Greedy that only pulls spares from already-seen labels fails on inputs like $[57,179]$; you must count all $\ge M$ as spares.}
\ELI{Think of each missing small number as a hole you must fill using extra elements. Duplicates and big numbers are your budget. If the budget covers the cost of the holes (with $0$ and $1$ being cheaper), you can arrange the multiset so that the final MEX is as large as possible.}
\NotePages{3}

\end{document}