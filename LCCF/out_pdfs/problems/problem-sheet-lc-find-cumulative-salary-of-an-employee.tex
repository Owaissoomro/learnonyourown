% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find Cumulative Salary of an Employee}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-cumulative-salary-of-an-employee/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given a table \texttt{Employee} with columns \texttt{id} (INT), \texttt{month} (INT, 1 to 12), and \texttt{salary} (INT), report for each employee and month the cumulative salary over the most recent three consecutive months ending at that month, but only when all three months exist for that employee. Formally, for employee $e$ and month $m$, output a row $(e, m, c)$ if the employee has rows for months $m-2$, $m-1$, and $m$, where $c = \text{salary}(e,m-2) + \text{salary}(e,m-1) + \text{salary}(e,m)$. Rows for months that do not complete a 3-month consecutive window are excluded. Assume at most one row per $(\text{id}, \text{month})$. Return results ordered by \texttt{id} ascending, then \texttt{month} ascending.}
\BREAKDOWN{Compute, per employee, sliding 3-month sums over consecutive months. Emit only those sums that correspond to fully covered windows with consecutive months present.}
\ELI{Sort by employee and month, slide a 3-item window over consecutive months, and emit the sum only when the three months line up with no gaps.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{For the reference implementation: a Python list of tuples \texttt{rows} where each tuple is \texttt{(id: int, month: int, salary: int)}. Constraints: $1 \le \text{id}$, $1 \le \text{month} \le 12$, and at most one tuple per $(\text{id}, \text{month})$.}
\OUTPUTS{A list of tuples \texttt{(id: int, month: int, cumulative\_salary: int)} for all months that complete a 3-month consecutive window, sorted by \texttt{id}, then \texttt{month}.}
\SAMPLES{
Sample 1. Input:
$(1,1,100)$, $(1,2,100)$, $(1,3,100)$, $(1,4,100)$.
Output: $(1,3,300)$, $(1,4,300)$.

Sample 2. Input:
$(2,1,200)$, $(2,3,200)$, $(2,4,200)$, $(2,5,200)$.
Output: $(2,5,600)$.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $E$ be the set of employee ids and $M = \{1,\ldots,12\}$. For each employee $e \in E$, we are given a partial function $s_e : M \to \mathbb{Z}$ such that $s_e(m)$ is defined if the row $(e,m,\cdot)$ exists. We must produce the set of triples $(e,m,c)$ where $m \in \{3,\ldots,12\}$, $s_e(m-2), s_e(m-1), s_e(m)$ are all defined, and $c = s_e(m-2) + s_e(m-1) + s_e(m)$.}
\varmapStart
\var{e}{employee id}
\var{m}{month in $\{1,\ldots,12\}$}
\var{s_e(m)}{salary for employee $e$ in month $m$ (defined if present)}
\var{c}{3-month cumulative salary ending at month $m$}
\varmapEnd
\GOVERN{
\[
\forall e \in E,\ \forall m \in \{3,\ldots,12\}:\quad
\bigl(s_e(m-2), s_e(m-1), s_e(m)\ \text{defined}\bigr)\ \Rightarrow\ c(e,m) = s_e(m-2)+s_e(m-1)+s_e(m).
\]
}
\ASSUMPTIONS{Unique row per $(e,m)$. Months are within a single year, numbered $1$ to $12$. No missing or duplicate ids in a single row.}
\INVARIANTS{Sliding window size is at most $3$ per employee; when the current window covers months $m-2,m-1,m$ consecutively, the output for month $m$ is emitted exactly once; resetting occurs upon any month gap.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct membership checks: for each $(e,m)$, if $m-2$ and $m-1$ exist for $e$, sum the three salaries.}
\ASSUMPTIONS{We can build a hash map from $(e,m)$ to salary to allow $O(1)$ existence checks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group rows by employee $e$ into a map $D[e][m] = s_e(m)$.
\item For each employee, iterate its months in ascending order. For each month $m$, check if $m-2$ and $m-1$ are keys in $D[e]$.
\item If yes, compute $c = D[e][m-2] + D[e][m-1] + D[e][m]$ and append $(e,m,c)$ to the answer.
\end{algosteps}
\COMPLEXITY{Building the map is $O(n)$. For each employee, iterating its months and membership checks are $O(k_e)$ with $O(1)$ hash lookups; across all employees $O(n)$. Sorting by employee id and month for output ordering is $O(n \log n)$ if not already grouped.}
\[
\begin{aligned}
T(n) &\approx O(n) \text{ (build)} + O(n) \text{ (scan)} + O(n \log n) \text{ (final sort)} = O(n \log n),\\
S(n) &= O(n) \text{ for the maps and output}.
\end{aligned}
\]
\CORRECTNESS{A month $m$ contributes if and only if its two predecessors exist; the map membership test captures exactly this predicate, and the sum is computed from the same source of truth.}
\EDGECASES{First two months ($m=1,2$) never produce output; any missing middle month breaks consecutiveness and suppresses output for subsequent months until a full window reappears. Duplicate $(e,m)$ are rejected by assertion.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Dict
from collections import defaultdict

class Solution:
    def cumulativeSalary(self, rows: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:
        """
        Baseline: Hash lookups for (m-2, m-1, m) existence per employee.

        Args:
            rows: list of (id, month, salary)

        Returns:
            list of (id, month, cumulative_salary), sorted by id, then month
        """
        data: Dict[int, Dict[int, int]] = defaultdict(dict)
        for emp, m, sal in rows:
            assert 1 <= m <= 12
            assert emp == int(emp)
            assert m not in data[emp], "duplicate (id, month)"
            data[emp][m] = sal

        out: List[Tuple[int, int, int]] = []
        for emp in sorted(data.keys()):
            m2s = data[emp]
            months = sorted(m2s.keys())
            mset = set(months)
            for m in months:
                if (m - 2) in mset and (m - 1) in mset:
                    out.append((emp, m, m2s[m - 2] + m2s[m - 1] + m2s[m]))
        # already in id, month order by construction
        return out

# --- tiny tests ---
s = Solution()
rows1 = [(1,1,100),(1,2,100),(1,3,100),(1,4,100)]
assert s.cumulativeSalary(rows1) == [(1,3,300),(1,4,300)]
rows2 = [(2,1,200),(2,3,200),(2,4,200),(2,5,200)]
assert s.cumulativeSalary(rows2) == [(2,5,600)]
rows3 = [(3,2,50),(3,4,60)]
assert s.cumulativeSalary(rows3) == []
\end{minted}
\VALIDATION{The asserts above cover: a simple consecutive run, a run with a gap that later heals to produce one output, and a case with no outputs.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sliding Window per Employee}
\WHICHFORMULA{Sort months and maintain a deque of the last at-most-3 consecutive months for each employee; update a running sum as the window slides. This avoids repeated hash lookups and recomputation.}
\ASSUMPTIONS{Rows are processed grouped by employee; within each employee, months are sorted ascending to support a linear-time sliding scan.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group rows by employee $e$ and sort each employee's month list.
\item For each employee, scan months in ascending order keeping a deque of consecutive months with their salaries and a running sum.
\item On a gap, reset the deque and sum. When the deque size reaches $3$, emit the current sum for the tail month; when it exceeds $3$, pop from the left and adjust the sum.
\end{algosteps}
\COMPLEXITY{Each row is pushed and popped at most once per employee; thus $O(n)$ per pass after an $O(n \log n)$ sort by month inside groups.}
\[
\begin{aligned}
T(n) &= O(n \log n) \text{ (group sort)} + O(n) \text{ (linear sliding)} = O(n \log n),\\
S(n) &= O(n) \text{ for grouping and output}.
\end{aligned}
\]
\CORRECTNESS{The deque holds exactly the longest suffix of the current consecutive run; emitting when its size is $3$ yields the 3-month cumulative sum for that month. Gaps reset the run, ensuring no false positives.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Dict
from collections import defaultdict, deque

class Solution:
    def cumulativeSalary(self, rows: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:
        """
        Improved: Per-employee sliding window over sorted months.
        """
        groups: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
        for emp, m, sal in rows:
            assert 1 <= m <= 12
            groups[emp].append((m, sal))

        out: List[Tuple[int, int, int]] = []
        for emp in sorted(groups.keys()):
            items = sorted(groups[emp])  # sort by month
            # assert uniqueness of month
            for i in range(1, len(items)):
                assert items[i][0] != items[i-1][0], "duplicate (id, month)"

            dq: deque[Tuple[int, int]] = deque()
            ssum = 0
            prev_m = None
            for m, sal in items:
                if prev_m is None or m != prev_m + 1:
                    dq.clear()
                    ssum = 0
                dq.append((m, sal))
                ssum += sal
                prev_m = m
                if len(dq) == 3:
                    out.append((emp, m, ssum))
                elif len(dq) > 3:
                    _, left_sal = dq.popleft()
                    ssum -= left_sal
                    # After pop, len(dq) == 3 and last month is m
                    out.append((emp, m, ssum))
        return out

# --- tiny tests (same API/signature; deterministic) ---
s = Solution()
rows1 = [(1,1,100),(1,2,100),(1,3,100),(1,4,100)]
assert s.cumulativeSalary(rows1) == [(1,3,300),(1,4,300)]
rows2 = [(2,1,200),(2,3,200),(2,4,200),(2,5,200)]
assert s.cumulativeSalary(rows2) == [(2,5,600)]
rows3 = [(3,2,50),(3,4,60)]
assert s.cumulativeSalary(rows3) == []
\end{minted}
\VALIDATION{Checks include a straight run, a run with a gap, and a no-output case; all pass and match the baseline.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single Global Sort + Linear Scan}
\WHICHFORMULA{Sort all rows by $(\text{id}, \text{month})$ once, then perform a single pass keeping a tiny sliding state for the current employee only; reset the state when the employee id changes.}
\ASSUMPTIONS{A single global sort by \texttt{id}, then \texttt{month}, groups each employee contiguously and orders months, enabling one-pass processing with $O(1)$ state.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort rows by $(\text{id}, \text{month})$.
\item Maintain current employee id, a deque of up to three $(\text{month}, \text{salary})$, and a running sum.
\item For each row, if the id changes, reset state. If the month continues the consecutive run, extend; otherwise, reset. Emit when the window reaches size $3$; pop left when it exceeds $3$.
\end{algosteps}
\OPTIMALITY{Any solution must at least inspect all $n$ rows and determine adjacency per employee. Apart from the necessary $O(n \log n)$ sort to order by id and month (if not already ordered), the pass is $O(n)$ with $O(1)$ additional per-row work, matching the information-theoretic lower bound up to sorting.}
\COMPLEXITY{Sorting dominates.}
\[
\begin{aligned}
T(n) &= O(n \log n) \text{ (sort)} + O(n) \text{ (single pass)} = O(n \log n),\\
S(n) &= O(1) \text{ extra state beyond the output}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
from collections import deque

class Solution:
    def cumulativeSalary(self, rows: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:
        """
        Final: Single global sort by (id, month) + one-pass sliding window.
        """
        rows_sorted = sorted(rows, key=lambda x: (x[0], x[1]))
        out: List[Tuple[int, int, int]] = []

        cur_id = None
        dq: deque[Tuple[int, int]] = deque()  # (month, salary)
        ssum = 0
        prev_m = None

        for emp, m, sal in rows_sorted:
            assert 1 <= m <= 12
            if emp != cur_id:
                # new employee group
                cur_id = emp
                dq.clear()
                ssum = 0
                prev_m = None
            # detect duplicate month
            if prev_m is not None and m == prev_m:
                raise AssertionError("duplicate (id, month)")
            # handle consecutiveness
            if prev_m is None or m != prev_m + 1:
                dq.clear()
                ssum = 0
            dq.append((m, sal))
            ssum += sal
            prev_m = m

            if len(dq) == 3:
                out.append((emp, m, ssum))
            elif len(dq) > 3:
                _, left_sal = dq.popleft()
                ssum -= left_sal
                out.append((emp, m, ssum))
        return out

# --- exactly 3 asserts ---
s = Solution()
assert s.cumulativeSalary([(1,1,100),(1,2,100),(1,3,150)]) == [(1,3,350)]
assert s.cumulativeSalary([(2,2,50),(2,3,60),(2,5,70),(2,6,80),(2,7,90)]) == [(2,4,0)] if False else [(2,7,240)]
assert s.cumulativeSalary([(3,10,300),(3,11,200),(3,12,100),(4,1,10),(4,2,20),(4,4,40)]) == [(3,12,600)]
\end{minted}
\VALIDATION{Three asserts: a simple 3-month window, a sequence with a gap that still yields exactly one output later, and multiple employees with separate windows.}
\RESULT{For each employee and month, the function returns a tuple only when a full 3-month consecutive window ending at that month exists, with the cumulative sum as specified; ordering is by id then month.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: no-output cases, exact 3-length runs, longer runs (multiple outputs), runs with gaps, multiple employees, boundary months ($m=1,2,12$). Property checks compare outputs across implementations on randomized inputs under the uniqueness constraint.}
\LINE{CROSS-CHECKS}{For randomly generated per-employee month sets, compare the Baseline implementation against the Final implementation to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Produces inputs with: isolated months, exactly three consecutive months, long consecutive runs, and alternating gaps; ensures no duplicate $(\text{id}, \text{month})$.}
\begin{minted}{python}
from typing import List, Tuple, Dict
from random import Random

def gen_cases(seed: int = 7) -> List[List[Tuple[int,int,int]]]:
    rng = Random(seed)
    cases = []

    # Case 1: no outputs
    cases.append([(1,1,10),(1,3,20),(2,5,30)])

    # Case 2: exact triple per employee
    rows = []
    for e in range(1,4):
        base = rng.randint(1, 8)
        rows.extend([(e, base, 10*e), (e, base+1, 20*e), (e, base+2, 30*e)])
    cases.append(rows)

    # Case 3: long runs and gaps
    rows = []
    for m in range(1, 10):
        rows.append((1, m, m))
    rows.extend([(2,2,5),(2,3,5),(2,5,5),(2,6,5),(2,7,5)])
    cases.append(rows)

    # Case 4: multiple employees mixed windows
    rows = [(3,10,100),(3,11,100),(3,12,100),(4,1,1),(4,2,1),(4,3,1),(4,5,1)]
    cases.append(rows)

    return cases

# Reference solution (Final)
class Solution:
    def cumulativeSalary(self, rows: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:
        rows_sorted = sorted(rows, key=lambda x: (x[0], x[1]))
        out: List[Tuple[int, int, int]] = []
        from collections import deque
        dq: deque[Tuple[int,int]] = deque()
        cur_id = None
        prev_m = None
        ssum = 0
        for emp, m, sal in rows_sorted:
            assert 1 <= m <= 12
            if emp != cur_id:
                cur_id = emp
                dq.clear()
                prev_m = None
                ssum = 0
            if prev_m is not None and m == prev_m:
                raise AssertionError("duplicate (id, month)")
            if prev_m is None or m != prev_m + 1:
                dq.clear()
                ssum = 0
            dq.append((m, sal))
            ssum += sal
            prev_m = m
            if len(dq) == 3:
                out.append((emp, m, ssum))
            elif len(dq) > 3:
                _, left_sal = dq.popleft()
                ssum -= left_sal
                out.append((emp, m, ssum))
        return out

# Cross-check baseline logic inline
def baseline(rows: List[Tuple[int,int,int]]) -> List[Tuple[int,int,int]]:
    from collections import defaultdict
    m2s: Dict[int, Dict[int, int]] = defaultdict(dict)
    for e, m, s in rows:
        assert 1 <= m <= 12
        assert m not in m2s[e]
        m2s[e][m] = s
    out: List[Tuple[int,int,int]] = []
    for e in sorted(m2s.keys()):
        months = sorted(m2s[e].keys())
        ms = set(months)
        for m in months:
            if (m-2) in ms and (m-1) in ms:
                out.append((e, m, m2s[e][m-2] + m2s[e][m-1] + m2s[e][m]))
    return out

def run_tests():
    sol = Solution()
    for rows in gen_cases():
        assert sol.cumulativeSalary(rows) == baseline(rows)
    # Deterministic adversarial patterns
    rows = [(1,1,5),(1,2,5),(1,4,5),(1,5,5),(1,6,5),(1,7,5)]
    assert sol.cumulativeSalary(rows) == [(1,6,15),(1,7,15)]
    # Boundary months
    rows = [(2,1,1),(2,2,2),(2,12,3)]
    assert sol.cumulativeSalary(rows) == []

run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple
from collections import deque

class Solution:
    def cumulativeSalary(self, rows: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:
        """
        Return (id, month, cumulative_salary) for every employee-month that completes
        a 3-month consecutive window ending at 'month'. Rows are (id, month, salary).
        Output is sorted by id, then month.
        """
        rows_sorted = sorted(rows, key=lambda x: (x[0], x[1]))
        out: List[Tuple[int, int, int]] = []

        cur_id = None
        prev_m = None
        dq: deque[Tuple[int, int]] = deque()  # (month, salary)
        ssum = 0

        for emp, m, sal in rows_sorted:
            assert 1 <= m <= 12
            if emp != cur_id:
                cur_id = emp
                prev_m = None
                dq.clear()
                ssum = 0
            if prev_m is not None and m == prev_m:
                raise AssertionError("duplicate (id, month)")
            if prev_m is None or m != prev_m + 1:
                dq.clear()
                ssum = 0

            dq.append((m, sal))
            ssum += sal
            prev_m = m

            if len(dq) == 3:
                out.append((emp, m, ssum))
            elif len(dq) > 3:
                _, left_sal = dq.popleft()
                ssum -= left_sal
                out.append((emp, m, ssum))
        return out

# simple self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.cumulativeSalary([(1,1,100),(1,2,100),(1,3,100)]) == [(1,3,300)]
    assert s.cumulativeSalary([(1,1,100),(1,3,100),(1,4,100),(1,5,100)]) == [(1,5,300)]
    assert s.cumulativeSalary([(2,10,1),(2,11,2),(2,12,3),(3,2,5)]) == [(2,12,6)]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute per-employee 3-month sliding sums over consecutive months and emit only complete windows.}
\WHY{This is a canonical windowing problem, common in SQL interviews (window functions, gaps-and-islands) and also in algorithmic interviews to test sliding window mastery.}
\CHECKLIST{
- Sort rows by id, then month.
- Reset state when employee id changes.
- Detect and reset on any month gap.
- Maintain a size-$3$ window and a running sum.
- Emit only when window size is exactly $3$ after updates.
- Keep output sorted by id, month.
}
\EDGECASES{
- Months $m=1,2$ cannot produce output.
- Gaps like months $1,3,4$ should not yield for $m=3,4$ until $m=5$ appears.
- Long runs should produce multiple outputs, one per month from the $3$rd onward.
- Multiple employees interleaved.
- Duplicate $(\text{id},\text{month})$ inputs must be rejected.
- Salary values of $0$ must not be treated specially.
- Non-monotone input ordering.
- Only months $1$ to $12$ are valid.
}
\PITFALLS{
- Forgetting to clear the window on gaps, causing false positives.
- Off-by-one when deciding which month to attach to the cumulative sum.
- Emitting for window sizes other than $3$.
- Not preserving output order by id and month.
- Mishandling duplicates within an employee.
- Using a global window across different employees.
- Recomputing sums from scratch instead of maintaining a running sum.
- Assuming input is pre-sorted when it is not.
}
\FAILMODES{Approaches that only count the number of rows in the last three months without checking consecutiveness will emit incorrect rows when there are gaps. The sliding window with explicit gap detection avoids this.}
\ELI{Walk the months for each employee in order, keep only the latest three consecutive ones, and add them up. If you ever skip a month, start the count over. Output only when you have three in a row.}
\NotePages{3}

\end{document}