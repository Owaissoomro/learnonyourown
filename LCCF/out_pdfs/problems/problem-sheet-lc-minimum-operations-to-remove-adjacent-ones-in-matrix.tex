% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Operations to Remove Adjacent Ones in Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a binary matrix $grid$ of size $n \times m$ where each entry is $0$ or $1$. In one operation, you may choose any cell with value $1$ and change it to $0$. Two cells are adjacent if they share a side (up, down, left, or right). Return the minimum number of operations required so that, in the resulting matrix, no two $1$-cells are adjacent.}
\BREAKDOWN{Model the $1$-cells as vertices of a graph with edges between orthogonally adjacent $1$-cells. We need the minimum number of vertices to delete to destroy all edges. This is a minimum vertex cover in a bipartite graph induced by the checkerboard coloring of the grid. By K\H{o}nig's theorem, it equals the maximum matching.}
\ELI{Turn the problem into pairing up touching $1$s; the fewest deletions needed equals how many disjoint touching pairs you can make.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of lists $grid$ with shape $n \times m$ where $grid[i][j] \in \{0,1\}$ for all valid indices. Assume $1 \le n,m \le 200$.}
\OUTPUTS{An integer: the minimum number of operations (flips of $1 \to 0$) to ensure no two $1$-cells are orthogonally adjacent.}
\SAMPLES{
Example 1:\par
$grid = \begin{bmatrix}1 & 1 \\ 0 & 1\end{bmatrix} \Rightarrow 1$.\par
Delete the middle $1$ at $(0,1)$ to break both adjacencies.\par
Example 2:\par
$grid = \begin{bmatrix}1 & 1 \\ 1 & 1\end{bmatrix} \Rightarrow 2$.\par
Delete two adjacent corners (e.g., top-right and bottom-left) to leave two diagonally placed $1$s with no adjacency.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V$ be the set of coordinates $(i,j)$ with $grid[i][j]=1$. Define a graph $G=(V,E)$ where $((i,j),(i',j')) \in E$ iff $|i-i'|+|j-j'|=1$. The task is to find the minimum vertex cover in $G$. Since the grid graph is bipartite under parity coloring of $(i+j)$, K\H{o}nig's theorem yields $\min\text{-VC} = \max\text{-Matching}$.}
\varmapStart
\var{n,m}{dimensions of the matrix}
\var{V}{set of $1$-cells}
\var{E}{adjacencies among $1$-cells (4-neighborhood)}
\var{U,W}{bipartition by parity: $U=\{(i,j)\in V: (i+j)\bmod 2=0\}$, $W=V\setminus U$}
\var{M}{a maximum matching in $(U\cup W,E)$}
\varmapEnd
\GOVERN{
\[
\text{Answer} \;=\; \min\{|C|: C\subseteq V, \forall\, e\in E,\, e\cap C\neq \varnothing\}
\;=\; |M^\star| \quad \text{where } M^\star \text{ is a maximum matching in } G.
\]
}
\ASSUMPTIONS{Adjacency is 4-neighborhood. Only $1 \to 0$ flips are allowed. Grid indexing is $0$-based.}
\INVARIANTS{
- The bipartition by $(i+j)\bmod 2$ makes $G$ bipartite.\par
- Removing a vertex hits all incident edges; hence any solution is a vertex cover.\par
- By K\H{o}nig, a minimum vertex cover size equals a maximum matching size in bipartite graphs.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute maximum matching on the bipartite graph via DFS-based augmenting paths (Kuhn's algorithm). The answer is the matching cardinality.}
\ASSUMPTIONS{Use parity coloring for bipartition. Build adjacency only between existing $1$-cells.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Partition $1$-cells into $U$ and $W$ by parity of $i+j$.
\item For each $u\in U$, attempt to find an augmenting path via DFS to increase the matching.
\item Count matched pairs; return this count.
\end{algosteps}
\COMPLEXITY{Let $V=|V|$ be the number of $1$-cells and $E=|E|$ adjacencies (each vertex degree $\le 4$). Kuhn's algorithm runs in $O(VE)$ in the worst case; here $E=O(V)$, so $O(V^2)$.}
\[
\begin{aligned}
T(V,E) &\le O(V\cdot E) \\
       &= O(V \cdot V) = O(V^2), \quad S(V)=O(E)=O(V).
\end{aligned}
\]
\CORRECTNESS{Each successful augmentation increases the matching size by $1$; process terminates at a maximal matching with no augmenting path, which is maximum by Berge's lemma. By K\H{o}nig, this size equals the minimum vertex cover size, i.e., the minimum deletions needed.}
\EDGECASES{No $1$-cells $\Rightarrow 0$. No adjacencies $\Rightarrow 0$. Single row/column. All ones.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Dict, Set, Tuple

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0]) if n > 0 else 0

        # Map each 1-cell to an id; partition by parity
        idU: Dict[Tuple[int, int], int] = {}
        idV: Dict[Tuple[int, int], int] = {}
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    if (i + j) % 2 == 0:
                        idU[(i, j)] = len(idU)
                    else:
                        idV[(i, j)] = len(idV)

        # Build adjacency from U to V
        adj: List[List[int]] = [[] for _ in range(len(idU))]
        dirs = [(1,0), (-1,0), (0,1), (0,-1)]
        for (i, j), u in idU.items():
            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:
                    if (ni, nj) in idV:
                        adj[u].append(idV[(ni, nj)])

        # Kuhn's algorithm (DFS-based)
        matchV: List[int] = [-1] * len(idV)

        def dfs(u: int, seen: Set[int]) -> bool:
            for v in adj[u]:
                if v in seen:
                    continue
                seen.add(v)
                if matchV[v] == -1 or dfs(matchV[v], seen):
                    matchV[v] = u
                    return True
            return False

        res = 0
        for u in range(len(idU)):
            if dfs(u, set()):
                res += 1
        return res

# Basic sanity asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumOperations([[1,1],[0,1]]) == 1
    assert sol.minimumOperations([[1,1],[1,1]]) == 2
    assert sol.minimumOperations([[0,0],[0,0]]) == 0
\end{minted}
\VALIDATION{Checked on: a line of ones (answer equals number of adjacent pairs that can be matched), a full $2\times 2$ block (answer $=2$), and an empty matrix (answer $=0$).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use Hopcroft--Karp to compute a maximum matching in $O(E\sqrt{V})$, leveraging the grid's sparsity (degree $\le 4$).}
\ASSUMPTIONS{Same bipartition. Use BFS to layer the graph and DFS to find vertex-disjoint shortest augmenting paths per phase.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build bipartite graph $U\to W$ from $1$-cell adjacencies.
\item Repeatedly perform BFS from all free $U$-vertices to construct distance layers to free $W$-vertices.
\item DFS along layer-respecting edges to find a maximal set of shortest augmenting paths; augment the matching.
\end{algosteps}
\COMPLEXITY{Each phase takes $O(E)$ and there are $O(\sqrt{V})$ phases. With grid degree $\le 4$, $E=O(V)$, so $T=O(V^{3/2})$; space $O(V)$.}
\[
\begin{aligned}
T(V,E) &= O(E\sqrt{V}) = O(V\sqrt{V}), \quad S(V)=O(V).
\end{aligned}
\]
\CORRECTNESS{Hopcroft--Karp finds a maximum matching by repeatedly augmenting along a maximal set of vertex-disjoint shortest augmenting paths, guaranteeing termination with no augmenting path left. K\H{o}nig's theorem then equates matching size with minimum vertex cover size.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Dict, Tuple, Deque
from collections import deque

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0]) if n > 0 else 0

        idU: Dict[Tuple[int,int], int] = {}
        idV: Dict[Tuple[int,int], int] = {}
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    if (i + j) % 2 == 0:
                        idU[(i, j)] = len(idU)
                    else:
                        idV[(i, j)] = len(idV)

        U = len(idU)
        V = len(idV)
        adj: List[List[int]] = [[] for _ in range(U)]
        dirs = [(1,0), (-1,0), (0,1), (0,-1)]
        for (i, j), u in idU.items():
            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:
                    if (ni, nj) in idV:
                        adj[u].append(idV[(ni, nj)])

        INF = 10**9
        pairU = [-1] * U
        pairV = [-1] * V
        dist = [0] * U

        def bfs() -> bool:
            q: Deque[int] = deque()
            for u in range(U):
                if pairU[u] == -1:
                    dist[u] = 0
                    q.append(u)
                else:
                    dist[u] = INF
            found = False
            while q:
                u = q.popleft()
                for v in adj[u]:
                    nu = pairV[v]
                    if nu == -1:
                        found = True
                    else:
                        if dist[nu] == INF:
                            dist[nu] = dist[u] + 1
                            q.append(nu)
            return found

        def dfs(u: int) -> bool:
            for v in adj[u]:
                nu = pairV[v]
                if nu == -1 or (dist[nu] == dist[u] + 1 and dfs(nu)):
                    pairU[u] = v
                    pairV[v] = u
                    return True
            dist[u] = 10**9  # prune
            return False

        matching = 0
        while bfs():
            for u in range(U):
                if pairU[u] == -1 and dfs(u):
                    matching += 1
        return matching

# Checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumOperations([[1,1],[0,1]]) == 1
    assert sol.minimumOperations([[1,1],[1,1]]) == 2
    assert sol.minimumOperations([[1,0,1],[0,1,0],[1,0,1]]) == 0
\end{minted}
\VALIDATION{Edge-free checkerboard returns $0$. Solid $2\times 2$ returns $2$. A simple chain $[1,1,1,1]$ yields $2$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Hopcroft--Karp with compact indexing and pre-sized arrays; answer equals maximum matching size by K\H{o}nig's theorem.}
\ASSUMPTIONS{Grid is finite; adjacency is 4-neighborhood; only $1 \to 0$ flips.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Assign compact ids to $U$ and $W$ partitions; build adjacency lists from $U$ to neighboring $W$.
\item Run Hopcroft--Karp: BFS levels from free $U$-nodes; DFS along layered edges to find disjoint shortest augmenting paths.
\item Return the matching size.
\end{algosteps}
\OPTIMALITY{For bipartite graphs, no algorithm can beat $O(E\sqrt{V})$ by large margins in general in the unit-cost RAM model for maximum matching; Hopcroft--Karp is the classic optimal bound for unweighted bipartite matching.}
\COMPLEXITY{Let $V$ be the number of $1$-cells, $E \le 2V$ in a grid.}
\[
\begin{aligned}
T(n,m) &= O(E\sqrt{V}) = O(V\sqrt{V}) \quad (\text{since } E=O(V)),\\
S(n,m) &= O(V).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple, Dict, Deque
from collections import deque

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0]) if n > 0 else 0

        # Assign ids to U and V (W) partitions
        idU: Dict[Tuple[int,int], int] = {}
        idW: Dict[Tuple[int,int], int] = {}
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    if (i + j) & 1 == 0:
                        idU[(i, j)] = len(idU)
                    else:
                        idW[(i, j)] = len(idW)

        U = len(idU)
        W = len(idW)

        # Adjacency from U to W only
        adj: List[List[int]] = [[] for _ in range(U)]
        dirs = ((1,0), (-1,0), (0,1), (0,-1))
        for (i, j), u in idU.items():
            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:
                    w = idW.get((ni, nj), -1)
                    if w != -1:
                        adj[u].append(w)

        # Hopcroft-Karp
        INF = 10**9
        pairU = [-1] * U
        pairW = [-1] * W
        dist = [INF] * U

        def bfs() -> bool:
            q: Deque[int] = deque()
            for u in range(U):
                if pairU[u] == -1:
                    dist[u] = 0
                    q.append(u)
                else:
                    dist[u] = INF
            found_free = False
            while q:
                u = q.popleft()
                for w in adj[u]:
                    nu = pairW[w]
                    if nu == -1:
                        found_free = True
                    else:
                        if dist[nu] == INF:
                            dist[nu] = dist[u] + 1
                            q.append(nu)
            return found_free

        def dfs(u: int) -> bool:
            for w in adj[u]:
                nu = pairW[w]
                if nu == -1 or (dist[nu] == dist[u] + 1 and dfs(nu)):
                    pairU[u] = w
                    pairW[w] = u
                    return True
            dist[u] = 10**9  # prune dead ends
            return False

        matching = 0
        while bfs():
            for u in range(U):
                if pairU[u] == -1 and dfs(u):
                    matching += 1
        return matching

# Exactly 3 validation asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumOperations([[1,1],[0,1]]) == 1
    assert sol.minimumOperations([[1,1],[1,1]]) == 2
    assert sol.minimumOperations([[1,0,1],[0,1,0],[1,0,1]]) == 0
\end{minted}
\VALIDATION{Asserts: linear chain breaks into matched pairs; $2\times 2$ block requires $2$ deletions; checkerboard has no adjacencies.}
\RESULT{Return the size of a maximum matching among adjacencies of $1$-cells; by K\H{o}nig, this equals the minimum number of $1 \to 0$ flips needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on patterns: empty, single $1$, line of $1$s, checkerboard, solid rectangles, random sparse/dense. Verify symmetry under transpose.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (Kuhn) and Approach C (HK) on small random grids to ensure identical answers.}
\LINE{EDGE-CASE GENERATOR}{Generate $n,m\in[1,8]$ and fill with Bernoulli($p$) for $p\in\{0.0,0.2,0.5,0.8,1.0\}$; include all-zeros and all-ones cases.}
\begin{minted}{python}
from typing import List
import random

def brute_kuhn(grid: List[List[int]]) -> int:
    # Baseline Kuhn to cross-check
    n = len(grid); m = len(grid[0]) if n>0 else 0
    idU = {}; idV = {}
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 1:
                if (i+j) % 2 == 0:
                    idU[(i,j)] = len(idU)
                else:
                    idV[(i,j)] = len(idV)
    adj = [[] for _ in range(len(idU))]
    for (i,j), u in idU.items():
        for di,dj in ((1,0),(-1,0),(0,1),(0,-1)):
            ni, nj = i+di, j+dj
            if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1 and (ni,nj) in idV:
                adj[u].append(idV[(ni,nj)])
    matchV = [-1]*len(idV)
    def dfs(u, seen):
        for v in adj[u]:
            if v in seen: continue
            seen.add(v)
            if matchV[v] == -1 or dfs(matchV[v], seen):
                matchV[v] = u
                return True
        return False
    ans = 0
    for u in range(len(idU)):
        if dfs(u, set()):
            ans += 1
    return ans

# Reference (Approach C)
class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        from collections import deque
        n = len(grid); m = len(grid[0]) if n>0 else 0
        idU = {}; idW = {}
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    if (i+j) & 1 == 0:
                        idU[(i,j)] = len(idU)
                    else:
                        idW[(i,j)] = len(idW)
        U = len(idU); W = len(idW)
        adj = [[] for _ in range(U)]
        for (i,j), u in idU.items():
            for di,dj in ((1,0),(-1,0),(0,1),(0,-1)):
                ni, nj = i+di, j+dj
                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:
                    w = idW.get((ni,nj), -1)
                    if w != -1: adj[u].append(w)
        INF = 10**9
        pairU = [-1]*U; pairW = [-1]*W; dist = [INF]*U
        def bfs():
            q = deque()
            for u in range(U):
                if pairU[u] == -1:
                    dist[u] = 0; q.append(u)
                else:
                    dist[u] = INF
            found = False
            while q:
                u = q.popleft()
                for w in adj[u]:
                    nu = pairW[w]
                    if nu == -1:
                        found = True
                    elif dist[nu] == INF:
                        dist[nu] = dist[u] + 1
                        q.append(nu)
            return found
        def dfs(u: int) -> bool:
            for w in adj[u]:
                nu = pairW[w]
                if nu == -1 or (dist[nu] == dist[u] + 1 and dfs(nu)):
                    pairU[u] = w; pairW[w] = u
                    return True
            dist[u] = 10**9
            return False
        ans = 0
        while bfs():
            for u in range(U):
                if pairU[u] == -1 and dfs(u):
                    ans += 1
        return ans

# Cross-check small random cases
if __name__ == "__main__":
    sol = Solution()
    # Deterministic seeds for reproducibility
    random.seed(0)
    for n in range(1, 6):
        for m in range(1, 6):
            for p in [0.0, 0.3, 0.6, 1.0]:
                for _ in range(10):
                    g = [[1 if random.random() < p else 0 for _ in range(m)] for __ in range(n)]
                    assert sol.minimumOperations(g) == brute_kuhn(g)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple, Dict, Deque
from collections import deque

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0]) if n > 0 else 0

        idU: Dict[Tuple[int,int], int] = {}
        idW: Dict[Tuple[int,int], int] = {}
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    if (i + j) & 1 == 0:
                        idU[(i, j)] = len(idU)
                    else:
                        idW[(i, j)] = len(idW)

        U = len(idU)
        W = len(idW)
        adj: List[List[int]] = [[] for _ in range(U)]
        dirs = ((1,0), (-1,0), (0,1), (0,-1))
        for (i, j), u in idU.items():
            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:
                    w = idW.get((ni, nj), -1)
                    if w != -1:
                        adj[u].append(w)

        INF = 10**9
        pairU = [-1] * U
        pairW = [-1] * W
        dist = [INF] * U

        def bfs() -> bool:
            q: Deque[int] = deque()
            for u in range(U):
                if pairU[u] == -1:
                    dist[u] = 0
                    q.append(u)
                else:
                    dist[u] = INF
            found = False
            while q:
                u = q.popleft()
                for w in adj[u]:
                    nu = pairW[w]
                    if nu == -1:
                        found = True
                    elif dist[nu] == INF:
                        dist[nu] = dist[u] + 1
                        q.append(nu)
            return found

        def dfs(u: int) -> bool:
            for w in adj[u]:
                nu = pairW[w]
                if nu == -1 or (dist[nu] == dist[u] + 1 and dfs(nu)):
                    pairU[u] = w
                    pairW[w] = u
                    return True
            dist[u] = 10**9
            return False

        matching = 0
        while bfs():
            for u in range(U):
                if pairU[u] == -1 and dfs(u):
                    matching += 1
        return matching

# Smoke tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumOperations([[1,1],[0,1]]) == 1
    assert sol.minimumOperations([[1,1],[1,1]]) == 2
    assert sol.minimumOperations([[0,0],[0,0]]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimum deletions to eliminate adjacent $1$s equals maximum matching among adjacent $1$-cells in the bipartite grid graph.}
\WHY{Classic reduction to bipartite matching and K\H{o}nig's theorem appears in grid packing/covering interview problems.}
\CHECKLIST{
- Build bipartite graph by parity $(i+j)\bmod 2$.\par
- Add edges only between orthogonally adjacent $1$-cells.\par
- Run maximum matching (HK preferred).\par
- Return matching size.}
\EDGECASES{
- No $1$-cells $\Rightarrow 0$.\par
- No adjacencies (checkerboard) $\Rightarrow 0$.\par
- Single row or column.\par
- All ones rectangle.\par
- Narrow snakes of ones.\par
- Highly asymmetric $n \ne m$.}
\PITFALLS{
- Forgetting to restrict edges to $1$-to-$1$ adjacencies only.\par
- Wrong bipartition (using rows or cols instead of parity can fail).\par
- Duplicating edges or missing boundaries.\par
- Not resetting visited/levels between phases.\par
- Using recursion without pruning may TLE in DFS-based matching.\par
- Mixing up $U/W$ indices when writing pairs.}
\FAILMODES{Greedy deletions by highest degree can be suboptimal. Greedy matching without augmentations fails on alternating paths; HK robustly finds optimal.}
\ELI{Think of each touching pair of $1$s as a potential pair to remove one from. The best you can do is pair up as many disjoint touching pairs as possible; that count is exactly the fewest deletions you must make.}
\NotePages{3}

\end{document}