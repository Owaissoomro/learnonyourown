% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Showing Off}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1416/F}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{Another dull quarantine day was going by when BThero decided to start researching matrices of size $n \times m$. The rows are numerated $1$ through $n$ from top to bottom, and the columns are numerated $1$ through $m$ from left to right. The cell in the $i$-th row and $j$-th column is denoted as $(i, j)$.

For each cell $(i, j)$ BThero had two values:
\begin{enumerate}
\item The cost of the cell, which is a single positive integer.
\item The direction of the cell, which is one of characters L, R, D, U. Those characters correspond to transitions to adjacent cells $(i, j - 1)$, $(i, j + 1)$, $(i + 1, j)$ or $(i - 1, j)$, respectively. No transition pointed outside of the matrix.
\end{enumerate}

Let us call a cell $(i_2, j_2)$ reachable from $(i_1, j_1)$, if, starting from $(i_1, j_1)$ and repeatedly moving to the adjacent cell according to our current direction, we will, sooner or later, visit $(i_2, j_2)$.

BThehero decided to create another matrix from the existing two. For a cell $(i, j)$, let us denote $S_{i, j}$ as a set of all reachable cells from it (including $(i, j)$ itself). Then, the value at the cell $(i, j)$ in the new matrix will be equal to the sum of costs of all cells in $S_{i, j}$.

After quickly computing the new matrix, BThero immediately sent it to his friends. However, he did not save any of the initial matrices! Help him to restore any two valid matrices, which produce the current one.

Input:
The first line of input file contains a single integer $T$ ($1 \le T \le 100$) denoting the number of test cases. The description of $T$ test cases follows.

First line of a test case contains two integers $n$ and $m$ ($1 \le n \cdot m \le 10^5$).

Each of the following $n$ lines contain exactly $m$ integers — the elements of the produced matrix. Each element belongs to the segment $[2, 10^9]$.

It is guaranteed that $\sum (n \cdot m)$ over all test cases does not exceed $10^5$.

Output:
For each test case, if an answer does not exist, print a single word NO. Otherwise, print YES and both matrices in the same format as in the input.
\begin{itemize}
\item The first matrix should be the cost matrix and the second matrix should be the direction matrix.
\item All integers in the cost matrix should be positive.
\item All characters in the direction matrix should be valid. No direction should point outside of the matrix.
\end{itemize}}
\BREAKDOWN{We are given, for each cell, the sum of costs over the set of cells reachable by following unique outgoing directions. We must reconstruct any valid cost matrix (positive integers) and a direction matrix (each to one of four neighbors, no out-of-bounds) that yields the provided sums, or conclude that none exists.}
\ELI{Treat the grid as a graph where each cell points to exactly one neighbor; the given sum at a cell equals the sum of costs on its forward path and eventual cycle. Make 2-cycles among local minima and direct all other cells towards strictly smaller neighbors; derive costs from differences.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n, m$ with $1 \le n \cdot m \le 10^5$; then an $n \times m$ matrix $S$ with $S_{i,j} \in [2, 10^9]$. Total cells over all tests $\le 10^5$.}
\OUTPUTS{For each test case: if impossible, print NO. Otherwise, print YES, then an $n \times m$ cost matrix with positive integers, then an $n \times m$ direction matrix using characters L, R, U, D with no direction pointing outside the grid.}
\SAMPLES{Example 1 (impossible): $n{=}1,m{=}1$, $S{=}[2]$ $\Rightarrow$ NO. Example 2 (possible): $n{=}1,m{=}2$, $S{=}[5,5]$ $\Rightarrow$ YES with costs $[1,4]$ and directions $[R,L]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Grid $V=\{1,\ldots,n\}\times\{1,\ldots,m\}$. Each $u\in V$ has exactly one successor $\operatorname{succ}(u)$ among its at most 4 neighbors. Let $c(u)\in\mathbb{Z}_{>0}$ be the cost. The given matrix $S$ is $S(u)=\sum_{w\in \mathcal{R}(u)} c(w)$ where $\mathcal{R}(u)$ is the set of vertices visited when repeatedly moving by $\operatorname{succ}(\cdot)$ from $u$.}
\varmapStart
\var{S_{i,j}}{given sum for cell $(i,j)$}
\var{c_{i,j}}{unknown positive cost for cell $(i,j)$}
\var{\operatorname{succ}(i,j)}{chosen neighbor of $(i,j)$ (direction)}
\var{\mathcal{R}(i,j)}{set of cells reachable from $(i,j)$ by following successors}
\varmapEnd
\GOVERN{
\[
\text{Functional-graph structure: outdeg}(u)=1.\quad
\begin{cases}
u \text{ not on a cycle}:\; S(u)=c(u)+S(\operatorname{succ}(u)) \text{ and } S(\operatorname{succ}(u))<S(u),\\
u \text{ on a cycle } C:\; S(u)=\sum_{w\in C} c(w) \text{ is constant over } u\in C.
\end{cases}
\]
}
\ASSUMPTIONS{Grid is bipartite. Each node has at least one neighbor unless $n\cdot m=1$. Costs must be positive. Directions cannot leave the grid.}
\INVARIANTS{Along any edge $u\to v$ with $S(v)<S(u)$, we have $c(u)=S(u)-S(v)\ge 1$. On a cycle, all $S$ are equal. Every path of strict descent in $S$ ends at a local minimum (no strictly smaller neighbor).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Naively try to orient each cell to an arbitrary neighbor that does not increase $S$, and adjust costs by local differences.}
\ASSUMPTIONS{If a cell has a strictly smaller neighbor, direct to any such neighbor; otherwise, try to direct to an equal neighbor.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each cell, if it has a neighbor $v$ with $S(v)<S(u)$, set $\operatorname{succ}(u){=}v$ and $c(u){=}S(u)-S(v)$.
\item For cells with no strictly smaller neighbor, attempt to choose any equal neighbor as successor.
\item If any cell has neither, declare impossible.
\end{algosteps}
\COMPLEXITY{Linear scan and neighbor checks: $T(n)=O(nm)$, $S(n)=O(nm)$.}
\[
\begin{aligned}
T(nm) &= O(nm \cdot 1) \\
     &= O(nm).
\end{aligned}
\]
\CORRECTNESS{Fails for equal-$S$ components: may yield zero costs on cycles and violate positivity, or leave some minima unmatched.}
\EDGECASES{Single cell; equal-valued plateaus; odd-sized equal components.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    try:
        T = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(T):
        n = int(next(it)); m = int(next(it))
        S = [[0]*m for __ in range(n)]
        for i in range(n):
            for j in range(m):
                S[i][j] = int(next(it))
        cases.append((n, m, S))
    return cases

def solve_case(n, m, S):
    N = n*m
    def id_of(i,j): return i*m + j
    def pos_of(idv): return (idv//m, idv % m)
    dirs = ['']*(N)
    cost = [0]*N
    succ = [-1]*N
    # neighbor deltas
    d4 = [(-1,0,'U'),(1,0,'D'),(0,-1,'L'),(0,1,'R')]
    # First pass: attach to any strictly smaller neighbor
    has_lower = [False]*N
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            best = -1
            for di,dj,ch in d4:
                ni, nj = i+di, j+dj
                if 0 <= ni < n and 0 <= nj < m:
                    if S[ni][nj] < S[i][j]:
                        best = id_of(ni,nj)
                        break
            if best != -1:
                has_lower[u] = True
                succ[u] = best
                cost[u] = S[i][j] - S[best//m][best % m]
    # For minima: try any equal neighbor (may fail)
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            if not has_lower[u]:
                picked = -1
                for di,dj,ch in d4:
                    ni, nj = i+di, j+dj
                    if 0 <= ni < n and 0 <= nj < m:
                        if S[ni][nj] == S[i][j]:
                            picked = id_of(ni,nj)
                            break
                if picked == -1:
                    return (False, None, None)
                succ[u] = picked
                # This naive baseline assigns zero here (invalid), we will fix in improved approaches.
                cost[u] = 1  # placeholder to keep positivity
    # Build direction chars
    for u in range(N):
        v = succ[u]
        if v < 0: return (False, None, None)
        ui, uj = pos_of(u); vi, vj = pos_of(v)
        if vi == ui-1 and vj == uj: dirs[u] = 'U'
        elif vi == ui+1 and vj == uj: dirs[u] = 'D'
        elif vi == ui and vj == uj-1: dirs[u] = 'L'
        elif vi == ui and vj == uj+1: dirs[u] = 'R'
        else: return (False, None, None)
    # Ensure positivity
    if any(c <= 0 for c in cost):
        # Baseline may fail here; report impossible
        return (False, None, None)
    # Pack outputs
    C = [[0]*m for _ in range(n)]
    D = [['']*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            C[i][j] = cost[u]
            D[i][j] = dirs[u]
    return (True, C, D)

def solve_all(cases):
    out_lines = []
    for (n,m,S) in cases:
        ok, C, D = solve_case(n,m,S)
        if not ok:
            out_lines.append("NO")
            continue
        out_lines.append("YES")
        for i in range(n):
            out_lines.append(" ".join(str(x) for x in C[i]))
        for i in range(n):
            out_lines.append("".join(D[i]))
    return "\n".join(out_lines)

def _check_reconstruct(n,m,S):
    ok, C, D = solve_case(n,m,S)
    # baseline may return False for tricky cases; just return boolean
    return ok

if __name__ == "__main__":
    # Tiny asserts for baseline API existence and basic behavior
    assert read_input("1 1 1 2") == [(1,1,[[2]])]
    # Single cell impossible
    assert _check_reconstruct(1,1,[[2]]) in (False, True)
    # If stdin present, run on it; else do nothing
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(read_input(data)))
\end{minted}
\VALIDATION{Baseline is intentionally weak; we rely on improved/optimal approaches. The code runs and handles input format; asserts check parsing.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Match Local Minima into 2-Cycles; Descend Otherwise}
\WHICHFORMULA{Observe $S(u)>S(v)$ on non-cycle edges and $S$ is constant on cycles. Make every local minimum (no strictly smaller neighbor) part of a 2-cycle by matching it with an equal-valued neighbor in the grid bipartition.}
\ASSUMPTIONS{Equal-$S$ subgraph on local minima is bipartite (grid), and a perfect matching exists that covers all such nodes.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each cell $u$, if there exists a neighbor $v$ with $S(v)<S(u)$, mark $u$ non-minimum and later set $\operatorname{succ}(u){=}v$.
\item Collect local minima $M$. If any $u\in M$ has no equal-$S$ neighbor, answer NO.
\item Build a bipartite graph on $M$ with edges between equal-$S$ adjacent cells. Run Hopcroft–Karp; if not all $M$ are matched, answer NO.
\item For each matched pair, set successors to each other, forming 2-cycles. For non-minima, set successors to some strictly smaller neighbor. Assign costs: for non-minima $c(u){=}S(u)-S(\operatorname{succ}(u))$; for each 2-cycle $(u,v)$, set $c(u){=}1$, $c(v){=}S(u)-1$.
\end{algosteps}
\COMPLEXITY{Building graph is $O(nm)$; Hopcroft–Karp on at most $10^5$ nodes and $O(1)$ degree runs in $O(E\sqrt{V})$, here $O(nm\sqrt{nm})$ in worst-case but with small constant. Overall linear to near-linear in practice.}
\[
\begin{aligned}
T(nm) &= O(nm) + O(E\sqrt{V}) + O(nm) \\
      &\le O(nm\sqrt{nm}),\quad S(nm)=O(nm).
\end{aligned}
\]
\CORRECTNESS{Strict descent ensures tails terminate in a matched 2-cycle. On tails, $c(u)=S(u)-S(\operatorname{succ}(u))\ge 1$. On 2-cycles, costs sum to the common $S$, satisfying cycle equations and positivity.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    try:
        T = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(T):
        n = int(next(it)); m = int(next(it))
        S = [[0]*m for __ in range(n)]
        for i in range(n):
            for j in range(m):
                S[i][j] = int(next(it))
        cases.append((n, m, S))
    return cases

def hopcroft_karp(left_nodes, adj):
    # left_nodes: iterable of left ids
    # adj[u]: list of right ids
    INF = 10**18
    pairU = {}
    pairV = {}
    dist = {}
    for u in left_nodes:
        pairU[u] = -1
        dist[u] = INF
    rights = set()
    for u in left_nodes:
        for v in adj.get(u, []):
            rights.add(v)
    for v in rights:
        pairV[v] = -1

    from collections import deque

    def bfs():
        q = deque()
        for u in left_nodes:
            if pairU[u] == -1:
                dist[u] = 0
                q.append(u)
            else:
                dist[u] = INF
        found = False
        while q:
            u = q.popleft()
            for v in adj.get(u, []):
                pu = pairV[v]
                if pu != -1 and dist[pu] == INF:
                    dist[pu] = dist[u] + 1
                    q.append(pu)
                if pu == -1:
                    found = True
        return found

    def dfs(u):
        for v in adj.get(u, []):
            pu = pairV[v]
            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):
                pairU[u] = v
                pairV[v] = u
                return True
        dist[u] = 10**18
        return False

    matching = 0
    while bfs():
        for u in left_nodes:
            if pairU[u] == -1:
                if dfs(u):
                    matching += 1
    return pairU, pairV

def solve_case(n, m, S):
    N = n*m
    def id_of(i,j): return i*m + j
    def pos_of(idv): return (idv//m, idv % m)
    d4 = [(-1,0,'U'),(1,0,'D'),(0,-1,'L'),(0,1,'R')]
    succ = [-1]* (N)
    cost = [0]* (N)
    dirs = ['']* (N)

    # Quick impossible: 1x1 grid has no valid outgoing direction
    if n*m == 1:
        return (False, None, None)

    has_lower = [False]*N
    minima = []
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            best = -1
            for di,dj,ch in d4:
                ni, nj = i+di, j+dj
                if 0 <= ni < n and 0 <= nj < m:
                    if S[ni][nj] < S[i][j]:
                        best = id_of(ni,nj)
                        break
            if best != -1:
                has_lower[u] = True
                succ[u] = best
            else:
                minima.append(u)

    # Build bipartite graph among minima with equal S
    # parity: (i+j)%2==0 -> left part
    left_nodes = []
    adj = defaultdict(list)
    is_min = [False]*N
    for u in minima:
        is_min[u] = True
    # early check: each minimum must have at least one equal neighbor
    for u in minima:
        ui, uj = pos_of(u)
        ok = False
        for di,dj,ch in d4:
            vi, vj = ui+di, uj+dj
            if 0 <= vi < n and 0 <= vj < m:
                v = id_of(vi,vj)
                if is_min[v] and S[vi][vj] == S[ui][uj]:
                    ok = True
                    break
        if not ok:
            return (False, None, None)

    for u in minima:
        ui, uj = pos_of(u)
        if (ui + uj) % 2 == 0:
            left_nodes.append(u)
            for di,dj,ch in d4:
                vi, vj = ui+di, uj+dj
                if 0 <= vi < n and 0 <= vj < m:
                    v = id_of(vi,vj)
                    if is_min[v] and S[vi][vj] == S[ui][uj]:
                        adj[u].append(v)

    # Ensure left cover size equals right cover size in each connected comp? Try matching
    pairU, pairV = hopcroft_karp(left_nodes, adj)

    # Assign 2-cycles from matching
    matched_right = set()
    for u in left_nodes:
        v = pairU.get(u, -1)
        if v != -1:
            succ[u] = v
            matched_right.add(v)

    # Any minimum unmatched on left or right -> impossible
    # Right minima are those minima with parity 1
    for u in minima:
        ui, uj = pos_of(u)
        if (ui + uj) % 2 == 0:
            if succ[u] == -1:
                return (False, None, None)
        else:
            if u not in matched_right:
                return (False, None, None)

    # Set reverse succ for matched rights to ensure 2-cycles
    for u in left_nodes:
        v = pairU.get(u, -1)
        if v != -1:
            succ[v] = u

    # Now assign costs
    # For non-minima: cost(u) = S(u) - S(succ(u))
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            if has_lower[u]:
                v = succ[u]
                vi, vj = pos_of(v)
                delta = S[i][j] - S[vi][vj]
                if delta <= 0:
                    return (False, None, None)
                cost[u] = delta

    # For minima pairs: assign 1 to left, S-1 to right
    for u in minima:
        ui, uj = pos_of(u)
        v = succ[u]
        vi, vj = pos_of(v)
        if (ui + uj) % 2 == 0:
            # u is left, v is right
            s_val = S[ui][uj]
            if s_val < 2:
                return (False, None, None)
            cost[u] = 1
            cost[v] = s_val - 1

    # Build direction characters
    for u in range(N):
        v = succ[u]
        if v < 0:
            return (False, None, None)
        ui, uj = pos_of(u); vi, vj = pos_of(v)
        if vi == ui-1 and vj == uj:
            dirs[u] = 'U'
        elif vi == ui+1 and vj == uj:
            dirs[u] = 'D'
        elif vi == ui and vj == uj-1:
            dirs[u] = 'L'
        elif vi == ui and vj == uj+1:
            dirs[u] = 'R'
        else:
            return (False, None, None)

    # Pack
    C = [[0]*m for _ in range(n)]
    D = [['']*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            if cost[u] <= 0:
                return (False, None, None)
            C[i][j] = cost[u]
            D[i][j] = dirs[u]
    return (True, C, D)

def solve_all(cases):
    out_lines = []
    for (n,m,S) in cases:
        ok, C, D = solve_case(n,m,S)
        if not ok:
            out_lines.append("NO")
            continue
        out_lines.append("YES")
        for i in range(n):
            out_lines.append(" ".join(str(x) for x in C[i]))
        for i in range(n):
            out_lines.append("".join(D[i]))
    return "\n".join(out_lines)

def _simulate_S(n,m,C,D):
    def id_of(i,j): return i*m + j
    def pos_of(idv): return (idv//m, idv % m)
    N = n*m
    succ = [-1]*N
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            ch = D[i][j]
            if ch == 'U':
                ni, nj = i-1, j
            elif ch == 'D':
                ni, nj = i+1, j
            elif ch == 'L':
                ni, nj = i, j-1
            elif ch == 'R':
                ni, nj = i, j+1
            else:
                return None
            if not (0 <= ni < n and 0 <= nj < m):
                return None
            succ[u] = id_of(ni,nj)
    S2 = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            seen = {}
            order = []
            x = u
            while x not in seen:
                seen[x] = len(order)
                order.append(x)
                x = succ[x]
            # nodes in reachable set are all visited up to first repeat; unique set
            total = 0
            visset = set(order)  # since order prefixes don't revisit before cycle entry
            for t in visset:
                ti, tj = pos_of(t)
                total += C[ti][tj]
            S2[i][j] = total
    return S2

def _assert_ok(n,m,S):
    ok, C, D = solve_case(n,m,S)
    if not ok:
        return False
    S2 = _simulate_S(n,m,C,D)
    return S2 == S

if __name__ == "__main__":
    # Quick asserts on crafted feasible cases
    assert _assert_ok(1,2,[[5,5]])
    assert _assert_ok(2,2,[[5,5],[7,6]])
    # Equal-plateau 2x2 all 2
    assert _assert_ok(2,2,[[2,2],[2,2]])
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(read_input(data)))
\end{minted}
\VALIDATION{Checks include: 1x2 equal sums (forms 2-cycle); 2x2 with tails descending to a 2-cycle; 2x2 all cells minima matched into disjoint 2-cycles.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{HK Matching on Minima + Greedy Descent}
\WHICHFORMULA{Use Hopcroft–Karp to find a perfect matching on the bipartite graph of local minima at equal $S$, producing disjoint 2-cycles. All other vertices greedily connect to any strictly smaller neighbor; costs are differences for tails and a split on cycles.}
\ASSUMPTIONS{Grid bipartition, existence of at least one equal neighbor for every local minimum, and a perfect matching covering minima.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Identify local minima (no strictly smaller neighbor). If any has no equal neighbor, answer NO.
\item Build bipartite graph on minima; run Hopcroft–Karp. If any minimum unmatched, answer NO.
\item Set successors: matched pairs form 2-cycles; others point to a strictly smaller neighbor.
\item Set costs: for non-minima $c(u){=}S(u){-}S(\operatorname{succ}(u))$; for each 2-cycle $(u,v)$, assign $c(u){=}1$, $c(v){=}S(u){-}1$.
\end{algosteps}
\OPTIMALITY{Formation of 2-cycles guarantees feasibility for any $S \ge 2$ at minima and minimizes cycle-length constraints. The HK matching is asymptotically optimal for maximum matching in bipartite graphs.}
\COMPLEXITY{$O(nm) + O(E\sqrt{V})$ time, $O(nm)$ space, with $E \le 4V$.}
\[
\begin{aligned}
T(nm) &\le O(nm\sqrt{nm}), \quad S(nm)=O(nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import defaultdict

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    try:
        T = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(T):
        n = int(next(it)); m = int(next(it))
        S = [[0]*m for __ in range(n)]
        for i in range(n):
            for j in range(m):
                S[i][j] = int(next(it))
        cases.append((n, m, S))
    return cases

def hopcroft_karp(left_nodes, adj):
    INF = 10**18
    pairU = {u: -1 for u in left_nodes}
    dist = {u: INF for u in left_nodes}
    rights = set()
    for u in left_nodes:
        for v in adj.get(u, []):
            rights.add(v)
    pairV = {v: -1 for v in rights}

    from collections import deque

    def bfs():
        q = deque()
        for u in left_nodes:
            if pairU[u] == -1:
                dist[u] = 0
                q.append(u)
            else:
                dist[u] = INF
        found = False
        while q:
            u = q.popleft()
            for v in adj.get(u, []):
                pu = pairV[v]
                if pu == -1:
                    found = True
                elif dist[pu] == INF:
                    dist[pu] = dist[u] + 1
                    q.append(pu)
        return found

    def dfs(u):
        for v in adj.get(u, []):
            pu = pairV[v]
            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):
                pairU[u] = v
                pairV[v] = u
                return True
        dist[u] = 10**18
        return False

    matching = 0
    while bfs():
        for u in left_nodes:
            if pairU[u] == -1:
                if dfs(u):
                    matching += 1
    return pairU, pairV

def solve_case(n, m, S):
    N = n*m
    def id_of(i,j): return i*m + j
    def pos_of(idv): return (idv//m, idv % m)
    d4 = [(-1,0,'U'),(1,0,'D'),(0,-1,'L'),(0,1,'R')]
    succ = [-1]*N
    cost = [0]*N
    dirs = ['']*N

    if n*m == 1:
        return (False, None, None)

    has_lower = [False]*N
    minima = []
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            for di,dj,ch in d4:
                ni, nj = i+di, j+dj
                if 0 <= ni < n and 0 <= nj < m:
                    if S[ni][nj] < S[i][j]:
                        succ[u] = id_of(ni,nj)
                        has_lower[u] = True
                        break
            if not has_lower[u]:
                minima.append(u)

    is_min = [False]*N
    for u in minima:
        is_min[u] = True

    # Each minimum must have an equal-valued minimum neighbor
    for u in minima:
        ui, uj = pos_of(u)
        ok = False
        for di,dj,ch in d4:
            vi, vj = ui+di, uj+dj
            if 0 <= vi < n and 0 <= vj < m:
                v = id_of(vi,vj)
                if is_min[v] and S[vi][vj] == S[ui][uj]:
                    ok = True
                    break
        if not ok:
            return (False, None, None)

    # Build bipartite graph among minima (equal S)
    left_nodes = []
    adj = defaultdict(list)
    for u in minima:
        ui, uj = pos_of(u)
        if (ui + uj) % 2 == 0:
            left_nodes.append(u)
            for di,dj,ch in d4:
                vi, vj = ui+di, uj+dj
                if 0 <= vi < n and 0 <= vj < m:
                    v = id_of(vi,vj)
                    if is_min[v] and S[vi][vj] == S[ui][uj]:
                        adj[u].append(v)

    pairU, pairV = hopcroft_karp(left_nodes, adj)

    matched_right = set()
    for u in left_nodes:
        v = pairU.get(u, -1)
        if v != -1:
            succ[u] = v
            matched_right.add(v)

    # Check all minima matched
    for u in minima:
        ui, uj = pos_of(u)
        if (ui + uj) % 2 == 0:
            if succ[u] == -1:
                return (False, None, None)
        else:
            if u not in matched_right:
                return (False, None, None)

    # Close 2-cycles
    for u in left_nodes:
        v = pairU.get(u, -1)
        if v != -1:
            succ[v] = u

    # Costs
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            if has_lower[u]:
                v = succ[u]
                vi, vj = pos_of(v)
                delta = S[i][j] - S[vi][vj]
                if delta <= 0:
                    return (False, None, None)
                cost[u] = delta

    for u in minima:
        ui, uj = pos_of(u)
        v = succ[u]
        if v == -1:
            return (False, None, None)
        # Left node sets both costs (right will be overwritten consistently)
        if (ui + uj) % 2 == 0:
            s_val = S[ui][uj]
            if s_val < 2:
                return (False, None, None)
            cost[u] = 1
            vi, vj = pos_of(v)
            cost[v] = s_val - 1

    # Directions
    for u in range(N):
        v = succ[u]
        if v < 0:
            return (False, None, None)
        ui, uj = pos_of(u); vi, vj = pos_of(v)
        if vi == ui-1 and vj == uj:
            dirs[u] = 'U'
        elif vi == ui+1 and vj == uj:
            dirs[u] = 'D'
        elif vi == ui and vj == uj-1:
            dirs[u] = 'L'
        elif vi == ui and vj == uj+1:
            dirs[u] = 'R'
        else:
            return (False, None, None)

    # Pack outputs
    C = [[0]*m for _ in range(n)]
    D = [['']*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            if cost[u] <= 0:
                return (False, None, None)
            C[i][j] = cost[u]
            D[i][j] = dirs[u]
    return (True, C, D)

def solve_all(cases):
    out_lines = []
    for (n,m,S) in cases:
        ok, C, D = solve_case(n,m,S)
        if not ok:
            out_lines.append("NO")
            continue
        out_lines.append("YES")
        for i in range(n):
            out_lines.append(" ".join(str(x) for x in C[i]))
        for i in range(n):
            out_lines.append("".join(D[i]))
    return "\n".join(out_lines)

def _simulate_S(n,m,C,D):
    def id_of(i,j): return i*m + j
    def pos_of(idv): return (idv//m, idv % m)
    N = n*m
    succ = [-1]*N
    for i in range(n):
        for j in range(m):
            ch = D[i][j]
            if ch == 'U':
                ni, nj = i-1, j
            elif ch == 'D':
                ni, nj = i+1, j
            elif ch == 'L':
                ni, nj = i, j-1
            elif ch == 'R':
                ni, nj = i, j+1
            else:
                return None
            if not (0 <= ni < n and 0 <= nj < m):
                return None
            succ[id_of(i,j)] = id_of(ni,nj)
    S2 = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            seen = set()
            x = u
            path = []
            while x not in seen:
                seen.add(x)
                path.append(x)
                x = succ[x]
            total = 0
            for t in seen:
                ti, tj = pos_of(t)
                total += C[ti][tj]
            S2[i][j] = total
    return S2

def _assert_ok(n,m,S):
    ok, C, D = solve_case(n,m,S)
    if not ok:
        return False
    S2 = _simulate_S(n,m,C,D)
    return S2 == S

if __name__ == "__main__":
    # Exactly 3 asserts
    assert _assert_ok(1,2,[[5,5]])
    assert _assert_ok(2,2,[[5,5],[7,6]])
    assert _assert_ok(2,2,[[2,2],[2,2]])
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(read_input(data)))
\end{minted}
\VALIDATION{Three asserts on feasible cases; simulation verifies the reconstructed matrices produce the target $S$.}
\RESULT{If possible, outputs a cost matrix with all entries positive and a direction matrix with each cell pointing to a valid neighbor, forming disjoint 2-cycles among local minima and directed trees descending into them. Ties on cycles are resolved by bipartite matching; costs on each 2-cycle are split as $1$ and $S{-}1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: parsing; impossible cases (single cell, isolated minimum without equal neighbor); feasible patterns (equal pairs, plateaus); verification by simulating reachable-set sums.}
\LINE{CROSS-CHECKS}{Compare reconstructed $S$ from produced $(C,D)$ against input $S$ on crafted instances; ensure strict descent edges have positive differences and cycle sums match.}
\LINE{EDGE-CASE GENERATOR}{Cover boundaries: $1\times 2$ equal; $2\times 2$ all equal; tails of varying lengths onto a 2-cycle; disconnected equal-$S$ plateaus.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cycle_pair(Sval):
    # 1x2 with both S equal to Sval
    return (1,2,[[Sval,Sval]])

def gen_tail_to_pair():
    # 2x2 with top row a 2-cycle (S=5), tails below with S 7 and 6
    return (2,2,[[5,5],[7,6]])

def gen_all_equal_2x2(Sval=2):
    return (2,2,[[Sval,Sval],[Sval,Sval]])

def run_reference():
    from sys import stdout
    tests = [gen_cycle_pair(5), gen_tail_to_pair(), gen_all_equal_2x2(3)]
    out = []
    for (n,m,S) in tests:
        ok, C, D = solve_case(n,m,S)
        out.append(ok)
        if ok:
            # verify
            S2 = _simulate_S(n,m,C,D)
            out.append(S2 == S)
    return out

if __name__ == "__main__":
    res = run_reference()
    assert all(res)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys
from collections import defaultdict

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    try:
        T = int(next(it))
    except StopIteration:
        return []
    cases = []
    for _ in range(T):
        n = int(next(it)); m = int(next(it))
        S = [[0]*m for __ in range(n)]
        for i in range(n):
            for j in range(m):
                S[i][j] = int(next(it))
        cases.append((n, m, S))
    return cases

def hopcroft_karp(left_nodes, adj):
    INF = 10**18
    pairU = {u: -1 for u in left_nodes}
    dist = {u: INF for u in left_nodes}
    rights = set()
    for u in left_nodes:
        for v in adj.get(u, []):
            rights.add(v)
    pairV = {v: -1 for v in rights}

    from collections import deque

    def bfs():
        q = deque()
        for u in left_nodes:
            if pairU[u] == -1:
                dist[u] = 0
                q.append(u)
            else:
                dist[u] = INF
        found = False
        while q:
            u = q.popleft()
            for v in adj.get(u, []):
                pu = pairV[v]
                if pu == -1:
                    found = True
                elif dist[pu] == INF:
                    dist[pu] = dist[u] + 1
                    q.append(pu)
        return found

    def dfs(u):
        for v in adj.get(u, []):
            pu = pairV[v]
            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):
                pairU[u] = v
                pairV[v] = u
                return True
        dist[u] = 10**18
        return False

    matching = 0
    while bfs():
        for u in left_nodes:
            if pairU[u] == -1:
                if dfs(u):
                    matching += 1
    return pairU, pairV

def solve_case(n, m, S):
    N = n*m
    def id_of(i,j): return i*m + j
    def pos_of(idv): return (idv//m, idv % m)
    d4 = [(-1,0,'U'),(1,0,'D'),(0,-1,'L'),(0,1,'R')]
    succ = [-1]*N
    cost = [0]*N
    dirs = ['']*N

    if n*m == 1:
        return (False, None, None)

    has_lower = [False]*N
    minima = []
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            for di,dj,ch in d4:
                ni, nj = i+di, j+dj
                if 0 <= ni < n and 0 <= nj < m:
                    if S[ni][nj] < S[i][j]:
                        succ[u] = id_of(ni,nj)
                        has_lower[u] = True
                        break
            if not has_lower[u]:
                minima.append(u)

    is_min = [False]*N
    for u in minima:
        is_min[u] = True

    for u in minima:
        ui, uj = pos_of(u)
        ok = False
        for di,dj,ch in d4:
            vi, vj = ui+di, uj+dj
            if 0 <= vi < n and 0 <= vj < m:
                v = id_of(vi,vj)
                if is_min[v] and S[vi][vj] == S[ui][uj]:
                    ok = True
                    break
        if not ok:
            return (False, None, None)

    left_nodes = []
    adj = defaultdict(list)
    for u in minima:
        ui, uj = pos_of(u)
        if (ui + uj) % 2 == 0:
            left_nodes.append(u)
            for di,dj,ch in d4:
                vi, vj = ui+di, uj+dj
                if 0 <= vi < n and 0 <= vj < m:
                    v = id_of(vi,vj)
                    if is_min[v] and S[vi][vj] == S[ui][uj]:
                        adj[u].append(v)

    pairU, pairV = hopcroft_karp(left_nodes, adj)

    matched_right = set()
    for u in left_nodes:
        v = pairU.get(u, -1)
        if v != -1:
            succ[u] = v
            matched_right.add(v)

    for u in minima:
        ui, uj = pos_of(u)
        if (ui + uj) % 2 == 0:
            if succ[u] == -1:
                return (False, None, None)
        else:
            if u not in matched_right:
                return (False, None, None)

    for u in left_nodes:
        v = pairU.get(u, -1)
        if v != -1:
            succ[v] = u

    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            if has_lower[u]:
                v = succ[u]
                vi, vj = pos_of(v)
                delta = S[i][j] - S[vi][vj]
                if delta <= 0:
                    return (False, None, None)
                cost[u] = delta

    for u in minima:
        ui, uj = pos_of(u)
        v = succ[u]
        if (ui + uj) % 2 == 0:
            s_val = S[ui][uj]
            if s_val < 2:
                return (False, None, None)
            cost[u] = 1
            vi, vj = pos_of(v)
            cost[v] = s_val - 1

    for u in range(N):
        v = succ[u]
        if v < 0:
            return (False, None, None)
        ui, uj = pos_of(u); vi, vj = pos_of(v)
        if vi == ui-1 and vj == uj:
            dirs[u] = 'U'
        elif vi == ui+1 and vj == uj:
            dirs[u] = 'D'
        elif vi == ui and vj == uj-1:
            dirs[u] = 'L'
        elif vi == ui and vj == uj+1:
            dirs[u] = 'R'
        else:
            return (False, None, None)

    C = [[0]*m for _ in range(n)]
    D = [['']*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            if cost[u] <= 0:
                return (False, None, None)
            C[i][j] = cost[u]
            D[i][j] = dirs[u]
    return (True, C, D)

def solve_all(cases):
    out_lines = []
    for (n,m,S) in cases:
        ok, C, D = solve_case(n,m,S)
        if not ok:
            out_lines.append("NO")
            continue
        out_lines.append("YES")
        for i in range(n):
            out_lines.append(" ".join(str(x) for x in C[i]))
        for i in range(n):
            out_lines.append("".join(D[i]))
    return "\n".join(out_lines)

def _simulate_S(n,m,C,D):
    def id_of(i,j): return i*m + j
    def pos_of(idv): return (idv//m, idv % m)
    N = n*m
    succ = [-1]*N
    for i in range(n):
        for j in range(m):
            ch = D[i][j]
            if ch == 'U':
                ni, nj = i-1, j
            elif ch == 'D':
                ni, nj = i+1, j
            elif ch == 'L':
                ni, nj = i, j-1
            elif ch == 'R':
                ni, nj = i, j+1
            else:
                return None
            if not (0 <= ni < n and 0 <= nj < m):
                return None
            succ[id_of(i,j)] = id_of(ni,nj)
    S2 = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            u = id_of(i,j)
            seen = set()
            x = u
            while x not in seen:
                seen.add(x)
                x = succ[x]
            total = 0
            for t in seen:
                ti, tj = pos_of(t)
                total += C[ti][tj]
            S2[i][j] = total
    return S2

def _assert_ok(n,m,S):
    ok, C, D = solve_case(n,m,S)
    if not ok:
        return False
    S2 = _simulate_S(n,m,C,D)
    return S2 == S

if __name__ == "__main__":
    # Quick sanity asserts
    assert _assert_ok(1,2,[[5,5]])
    assert _assert_ok(2,2,[[5,5],[7,6]])
    assert _assert_ok(2,2,[[2,2],[2,2]])
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(read_input(data)))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reconstruct a functional graph on the grid and positive costs so that each cell's value equals the sum over its forward-reachable set.}
\WHY{Combines graph structure (functional graphs, cycles with in-trees), matching (HK), and constructive reconstruction — a classic high-difficulty CF pattern.}
\CHECKLIST{
\begin{bullets}
\item Identify strictly smaller neighbors; mark local minima.
\item For minima, ensure existence of equal neighbor; build bipartite graph.
\item Run Hopcroft–Karp; all minima must be matched.
\item Assign successors: 2-cycles for minima; descend otherwise.
\item Costs: differences for tails; split on cycles to sum to $S$.
\item Emit matrices; verify positivity and valid directions.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n\cdot m=1$ is impossible (no valid outgoing direction).
\item A local minimum with no equal neighbor $\Rightarrow$ NO.
\item Equal-$S$ component with odd imbalance across bipartition $\Rightarrow$ matching fails.
\item Long tails strictly decreasing in $S$.
\item Plateaus spanning multiple rows/columns.
\item Borders and corners with fewer neighbors.
\item Very large $S$ values; ensure no integer overflow (Python is safe).
\item Multiple test cases with total size $10^5$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Assigning $c(u){=}S(u)-S(\operatorname{succ}(u))$ on cycles yields zero — must special-case cycles.
\item Forgetting to match both directions in a 2-cycle (set both successors).
\item Using non-adjacent equal cells in matching (must be 4-neighbor adjacency).
\item Mismapping grid indices to IDs, causing wrong directions.
\item Not checking that every minimum is matched (left and right sides).
\item Accidentally allowing direction to leave the grid.
\item Using DFS matching leading to TLE; HK is safer.
\item Not handling the case $S<2$ on a minimum (but input guarantees $S\ge 2$).
\end{bullets}
}
\FAILMODES{Baseline that arbitrarily connects equal-$S$ minima without matching can force cycles longer than $S$, making positivity impossible. Our 2-cycle construction avoids this by ensuring cycle length $2$ with minimal sum requirement $2$.}
\ELI{Cells with no strictly smaller neighbors must be on cycles where $S$ is constant. Pair them into 2-cycles via bipartite matching and set their costs to sum to $S$. All other cells point to a strictly smaller neighbor and get cost equal to the drop in $S$. This reconstructs a valid original.}
\NotePages{3}

\end{document}