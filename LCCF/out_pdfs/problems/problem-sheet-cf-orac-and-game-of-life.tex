% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Orac and Game of Life}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1349/C}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{Please notice the unusual memory limit of this problem.

Orac likes games. Recently he came up with the new game, ``Game of Life''.

You should play this game on a black and white grid with $n$ rows and $m$ columns. Each cell is either black or white.

For each iteration of the game (the initial iteration is $0$), the color of each cell will change under the following rules:
\begin{bullets}
\item If there are no adjacent cells with the same color as this cell on the current iteration, the color of it on the next iteration will be the same.
\item Otherwise, the color of the cell on the next iteration will be different.
\end{bullets}
Two cells are adjacent if they have a mutual edge.

Now Orac has set an initial situation, and he wants to know for the cell $(i,j)$ (in $i$-th row and $j$-th column), what will be its color at the iteration $p$. He may ask you these questions several times.

Input: The first line contains three integers $n,m,t\ (1\le n,m\le 1000, 1\le t\le 100{,}000)$, representing the number of rows, columns, and the number of Orac queries.

Each of the following $n$ lines contains a binary string of length $m$, the $j$-th character in $i$-th line represents the initial color of cell $(i,j)$. \texttt{'0'} stands for white, \texttt{'1'} stands for black.

Each of the following $t$ lines contains three integers $i,j,p\ (1\le i\le n, 1\le j\le m, 1\le p\le 10^{18})$, representing a query from Orac.

Output: Print $t$ lines, in $i$-th line you should print the answer to the $i$-th query by Orac. If the color of this cell is black, you should print \texttt{'1'}; otherwise, you should write \texttt{'0'}.

Note: For the first example, the picture above shows the initial situation and the color of cells at the iteration $1$, $2$, and $3$. We can see that the color of $(1,1)$ at the iteration $1$ is black, the color of $(2,2)$ at the iteration $2$ is black, and the color of $(3,3)$ at the iteration $3$ is also black.

For the second example, you can prove that the cells will never change their colors.}
\BREAKDOWN{Identify when each cell starts being affected by an adjacent equal-color neighbor; precompute the earliest time each cell can change using a multi-source BFS; answer each query from parity after its activation time.}
\ELI{Cells either never change or start toggling every step from some first time; find that time by spreading from any adjacent-equal pair.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n,m,t$; $n$ lines of a $0/1$ grid of length $m$; then $t$ queries with $i,j,p$ where $1\le i\le n$, $1\le j\le m$, $1\le p\le 10^{18}$.}
\OUTPUTS{For each query, print one character \texttt{0} or \texttt{1} on its own line: the color of cell $(i,j)$ at iteration $p$.}
\SAMPLES{Example 1:
\begin{verbatim}
3 3 3
010
000
110
1 1 1
2 2 2
3 3 3
\end{verbatim}
Example 2:
\begin{verbatim}
2 2 2
01
10
1 1 10
2 2 7
\end{verbatim}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Grid $G$ with vertices $V=\{(i,j)\mid 1\le i\le n,\,1\le j\le m\}$ and 4-neighbor edges. Initial color $c_0:V\to\{0,1\}$. Dynamics: $c_{t+1}(v)=c_t(v)$ if all neighbors have color $\ne c_t(v)$; otherwise $c_{t+1}(v)=1-c_t(v)$. Queries ask $c_p(v)$.}
\varmapStart
\var{G}{grid graph with 4-neighborhood}
\var{c_0}{initial cell colors}
\var{d(v)}{minimum time when $v$ is influenced by some equal-colored neighbor from time $0$}
\var{p}{query time}
\var{v=(i,j)}{queried cell}
\varmapEnd
\GOVERN{
\[
d(v)=\begin{cases}
0,& \exists u\sim v:\ c_0(u)=c_0(v),\\
1+\min\{d(u)\},& \text{over neighbors }u\sim v \text{ with } d(u)\ne\infty,\\
\infty,& \text{otherwise,}
\end{cases}
\qquad
c_p(v)=
\begin{cases}
c_0(v), & p\le d(v),\\
c_0(v)\oplus \bigl((p-d(v))\bmod 2\bigr), & p>d(v).
\end{cases}
\]
}
\ASSUMPTIONS{Grid indices are 1-based in the statement; we compute 0-based internally. The neighbor relation is 4-directional. If no cell starts with an equal-colored neighbor, then $d(v)=\infty$ for all $v$ and colors never change.}
\INVARIANTS{The set $\{v\mid d(v)=0\}$ is exactly cells that have an equal-colored neighbor at $t=0$. The breadth-first propagation of $d$ along edges yields minimal times due to unit edge weights. After time $d(v)$, cell $v$ alternates color every step.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct simulation of the cellular automaton up to the largest needed $p$ among queries, or per-query simulate up to its $p$.}
\ASSUMPTIONS{Feasible only for tiny grids or tiny $p$; retains correctness by literal application of the update rule each step.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse input, read grid as integers $\{0,1\}$.
\item For a given number of steps $K$, iteratively compute next states from current using the rule.
\item Answer queries by simulating up to their $p$ independently or up to $\max p$ once.
\end{algosteps}
\COMPLEXITY{For $n\times m$ grid and $K$ steps, time $\Theta(nmK)$ and space $\Theta(nm)$. Not viable for large $K$ (up to $10^{18}$).}
\[
\begin{aligned}
T(n,m,K) &= K\cdot (nm)\cdot O(1) = O(nmK).
\end{aligned}
\]
\CORRECTNESS{By construction, each iteration exactly implements the rule, so the state at step $k$ is correct.}
\EDGECASES{Single cell; checkerboard that never changes; all-equal grid that flips everywhere each step.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it)); t = int(next(it))
    except StopIteration:
        return None
    grid = [list(map(int, list(next(it).strip()))) for _ in range(n)]
    queries = []
    for _ in range(t):
        i = int(next(it)); j = int(next(it)); p = int(next(it))
        queries.append((i-1, j-1, p))
    return n, m, t, grid, queries

def step_once(grid):
    n = len(grid); m = len(grid[0])
    nxt = [[grid[i][j] for j in range(m)] for i in range(n)]
    dirs = [(-1,0),(1,0),(0,-1),(0,1)]
    for i in range(n):
        for j in range(m):
            col = grid[i][j]
            same_adj = False
            for di, dj in dirs:
                ni, nj = i+di, j+dj
                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == col:
                    same_adj = True
                    break
            if same_adj:
                nxt[i][j] = 1 - col
            else:
                nxt[i][j] = col
    return nxt

def simulate_until(grid, p):
    # Simulate p steps; for small p only
    cur = [row[:] for row in grid]
    for _ in range(p):
        cur = step_once(cur)
    return cur

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    n, m, t, grid, queries = parsed
    # Baseline: simulate per-query (only safe for tiny inputs)
    out_lines = []
    for i, j, p in queries:
        if p == 0:
            out_lines.append(str(grid[i][j]))
        else:
            # cap to something small to avoid explosion in accidental runs
            # but for correctness in tests, we will use small p
            final_grid = simulate_until(grid, p)
            out_lines.append(str(final_grid[i][j]))
    sys.stdout.write("\n".join(out_lines))

def main():
    solve_all()

if __name__ == "__main__":
    # tiny self-checks for the baseline
    g = [
        [0,1],
        [1,0],
    ]
    assert step_once(g) == g  # checkerboard unchanged
    g2 = [
        [1,1],
        [1,1],
    ]
    g2s = step_once(g2)
    assert g2s == [[0,0],[0,0]]
    # simulate tiny
    sim = simulate_until([[0]], 5)
    assert sim == [[0]]
    # do not run solve_all() in tests
    pass
\end{minted}
\VALIDATION{Checked: checkerboard invariance; all-equal flips; single cell fixed.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Multi-Source BFS Activation Times}
\WHICHFORMULA{Compute $d(v)$, the earliest time a cell can be affected, by multi-source BFS initiated from cells that already have an equal-colored neighbor at $t=0$. Then answer by parity from $d(v)$.}
\ASSUMPTIONS{Unit edge weights in the grid justify BFS for shortest activation time. If $d(v)=\infty$, the color never changes.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For every cell, check if it has a same-color neighbor; if so, set $d(v)=0$ and push to deque.
\item Run BFS over 4-neighbors, assigning $d(u)=d(v)+1$ to any unvisited neighbor $u$.
\item For a query $(i,j,p)$ with initial color $c_0$, if $d(i,j)=-1$ or $p\le d(i,j)$, answer $c_0$. Otherwise answer $c_0\oplus ((p-d(i,j))\bmod 2)$. 
\end{algosteps}
\COMPLEXITY{Preprocess $O(nm)$ time and space. Each query $O(1)$. This dominates the brute force by avoiding dependence on $p$.}
\[
\begin{aligned}
T_{\text{pre}} &= O(nm),\quad S=O(nm),\quad T_{\text{per query}}=O(1).
\end{aligned}
\]
\CORRECTNESS{Any cell that starts with a same-color neighbor toggles immediately at $t=1$ so $d=0$. Influence can only propagate along edges in unit time, and BFS assigns minimal distances. After $d(v)$, each step flips the state, hence parity controls the answer.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); t = int(next(it))
    grid = [next(it).strip() for _ in range(n)]
    queries = [(int(next(it))-1, int(next(it))-1, int(next(it))) for _ in range(t)]
    return n, m, t, grid, queries

def build_activation_times(n, m, grid):
    dist = [[-1]*m for _ in range(n)]
    dq = deque()
    dirs = [(-1,0),(1,0),(0,-1),(0,1)]
    for i in range(n):
        row = grid[i]
        for j in range(m):
            col = row[j]
            same = False
            for di, dj in dirs:
                ni, nj = i+di, j+dj
                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == col:
                    same = True
                    break
            if same:
                dist[i][j] = 0
                dq.append((i,j))
    # BFS
    while dq:
        i, j = dq.popleft()
        for di, dj in dirs:
            ni, nj = i+di, j+dj
            if 0 <= ni < n and 0 <= nj < m and dist[ni][nj] == -1:
                dist[ni][nj] = dist[i][j] + 1
                dq.append((ni, nj))
    return dist

def answer_queries(n, m, grid, dist, queries):
    out = []
    for i, j, p in queries:
        c0 = int(grid[i][j])
        d = dist[i][j]
        if d == -1 or p <= d:
            out.append(str(c0))
        else:
            out.append(str(c0 ^ ((p - d) & 1)))
    return out

def solve_all():
    n, m, t, grid, queries = read_input()
    dist = build_activation_times(n, m, grid)
    ans = answer_queries(n, m, grid, dist, queries)
    sys.stdout.write("\n".join(ans))

def main():
    solve_all()

if __name__ == "__main__":
    # sanity tests on tiny cases
    n, m = 2, 2
    grid = ["01","10"]  # checkerboard; no same-color neighbors
    dist = build_activation_times(n, m, grid)
    assert all(dist[i][j] == -1 for i in range(n) for j in range(m))
    out = answer_queries(n, m, grid, dist, [(0,0,1),(1,1,7)])
    assert out == ["0","0"]
    grid2 = ["11","11"]
    dist2 = build_activation_times(2, 2, grid2)
    assert all(dist2[i][j] == 0 for i in range(2) for j in range(2))
    out2 = answer_queries(2, 2, grid2, dist2, [(0,0,1),(1,1,2)])
    assert out2 == ["0","1"]
\end{minted}
\VALIDATION{Covered: no-activation case; all-activation case with parity across steps.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Multi-Source BFS + O(1) Query Parity}
\WHICHFORMULA{Compute activation times once with a deque BFS seeded by cells having any equal-color neighbor. Query answer uses $c_0\oplus ((p-d)\bmod 2)$ if $p>d$, else $c_0$.}
\ASSUMPTIONS{Grid connectivity is unit-weight; the process depends only on the earliest influence time and then alternates deterministically.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Mark $d(v)=0$ for any $v$ having a 4-neighbor of same color in the initial grid; push to deque.
\item BFS to fill $d$ for all reachable cells; unvisited cells have $d=-1$ meaning never activated.
\item For each query $(i,j,p)$, if $d=-1$ or $p\le d$, print the initial bit. Otherwise flip by parity $(p-d)\bmod 2$. 
\end{algosteps}
\OPTIMALITY{The dynamic is local and propagates along edges in unit time, so shortest activation times are necessary and sufficient to characterize all future states. Each query is answered in $O(1)$, which is optimal.}
\COMPLEXITY{$O(nm)$ preprocessing time and memory; $O(1)$ per query; total $O(nm+t)$.}
\[
\begin{aligned}
T_{\text{total}} &= O(nm + t),\quad S=O(nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); t = int(next(it))
    grid = [next(it).decode() for _ in range(n)]
    queries = [(int(next(it))-1, int(next(it))-1, int(next(it))) for _ in range(t)]
    return n, m, t, grid, queries

def build_activation_times(n, m, grid):
    dist = [[-1]*m for _ in range(n)]
    dq = deque()
    dirs = [(-1,0),(1,0),(0,-1),(0,1)]
    for i in range(n):
        gi = grid[i]
        for j in range(m):
            v = gi[j]
            same = False
            # check four neighbors
            if i > 0 and grid[i-1][j] == v: same = True
            elif i+1 < n and grid[i+1][j] == v: same = True
            elif j > 0 and gi[j-1] == v: same = True
            elif j+1 < m and gi[j+1] == v: same = True
            if same:
                dist[i][j] = 0
                dq.append((i, j))
    # BFS to fill distances
    while dq:
        i, j = dq.popleft()
        nd = dist[i][j] + 1
        if i > 0 and dist[i-1][j] == -1:
            dist[i-1][j] = nd; dq.append((i-1, j))
        if i+1 < n and dist[i+1][j] == -1:
            dist[i+1][j] = nd; dq.append((i+1, j))
        if j > 0 and dist[i][j-1] == -1:
            dist[i][j-1] = nd; dq.append((i, j-1))
        if j+1 < m and dist[i][j+1] == -1:
            dist[i][j+1] = nd; dq.append((i, j+1))
    return dist

def solve_all():
    n, m, t, grid, queries = read_input()
    dist = build_activation_times(n, m, grid)
    out_lines = []
    for i, j, p in queries:
        c0 = ord(grid[i][j]) & 1  # '0'->0, '1'->1
        d = dist[i][j]
        if d == -1 or p <= d:
            out_lines.append(str(c0))
        else:
            out_lines.append(str(c0 ^ ((p - d) & 1)))
    sys.stdout.write("\n".join(out_lines))

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts (unit tests)
    # 1) Checkerboard never changes
    n, m = 2, 2
    grid = ["01","10"]
    dist = build_activation_times(n, m, grid)
    assert all(dist[i][j] == -1 for i in range(n) for j in range(m))
    # 2) All-equal grid: toggles with parity after t>=1
    grid2 = ["11","11"]
    dist2 = build_activation_times(2, 2, grid2)
    assert all(d == 0 for row in dist2 for d in row)
    # 3) Mixed: center activated later
    grid3 = ["010","111","010"]
    dist3 = build_activation_times(3, 3, grid3)
    assert dist3[1][1] == 0 and dist3[0][0] >= 1
\end{minted}
\VALIDATION{Three asserts cover never-activating case, immediate-activating case, and delayed activation via BFS.}
\RESULT{For each query, the printed bit equals the initial bit if $p\le d$, else toggled by $(p-d)\bmod 2$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests of BFS activation times on crafted patterns; property check that answers remain constant when $d=-1$; parity checks when $d=0$.}
\LINE{CROSS-CHECKS}{Compare brute force simulation for tiny $p$ against BFS-parity answers; random small grids with random small $p$ values.}
\LINE{EDGE-CASE GENERATOR}{Generates single-cell, lines, checkerboards, all-equal, and random seeds to exercise activation/non-activation behavior.}
\begin{minted}{python}
import random

def gen_checkerboard(n, m):
    return ["".join(str((i+j)&1) for j in range(m)) for i in range(n)]

def gen_all_equal(n, m, bit):
    return [str(bit)*m for _ in range(n)]

def brute_step(grid):
    n = len(grid); m = len(grid[0])
    g = [list(map(int, list(row))) for row in grid]
    nxt = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            v = g[i][j]
            same = False
            if i>0 and g[i-1][j]==v: same=True
            elif i+1<n and g[i+1][j]==v: same=True
            elif j>0 and g[i][j-1]==v: same=True
            elif j+1<m and g[i][j+1]==v: same=True
            nxt[i][j] = (1-v) if same else v
    return ["".join(str(x) for x in row) for row in nxt]

def brute_sim(grid, p):
    cur = grid[:]
    for _ in range(p):
        cur = brute_step(cur)
    return cur

def property_check_once(n=4,m=4,steps=5,trials=20):
    for _ in range(trials):
        grid = ["".join(random.choice("01") for _ in range(m)) for _ in range(n)]
        dist = build_activation_times(n, m, grid)
        for _ in range(5):
            i = random.randrange(n); j = random.randrange(m); p = random.randrange(steps+1)
            brute = brute_sim(grid, p)[i][j]
            c0 = ord(grid[i][j]) & 1
            d = dist[i][j]
            if d == -1 or p <= d:
                fast = str(c0)
            else:
                fast = str(c0 ^ ((p - d) & 1))
            assert brute == fast, (grid, (i,j,p), brute, fast)

if __name__ == "__main__":
    # Run a quick property check
    property_check_once()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it)); t = int(next(it))
    grid = [next(it).decode() for _ in range(n)]
    queries = [(int(next(it))-1, int(next(it))-1, int(next(it))) for _ in range(t)]
    return n, m, t, grid, queries

def build_activation_times(n, m, grid):
    dist = [[-1]*m for _ in range(n)]
    dq = deque()
    for i in range(n):
        gi = grid[i]
        for j in range(m):
            v = gi[j]
            same = False
            if i > 0 and grid[i-1][j] == v: same = True
            elif i+1 < n and grid[i+1][j] == v: same = True
            elif j > 0 and gi[j-1] == v: same = True
            elif j+1 < m and gi[j+1] == v: same = True
            if same:
                dist[i][j] = 0
                dq.append((i, j))
    while dq:
        i, j = dq.popleft()
        nd = dist[i][j] + 1
        if i > 0 and dist[i-1][j] == -1:
            dist[i-1][j] = nd; dq.append((i-1, j))
        if i+1 < n and dist[i+1][j] == -1:
            dist[i+1][j] = nd; dq.append((i+1, j))
        if j > 0 and dist[i][j-1] == -1:
            dist[i][j-1] = nd; dq.append((i, j-1))
        if j+1 < m and dist[i][j+1] == -1:
            dist[i][j+1] = nd; dq.append((i, j+1))
    return dist

def solve_all():
    n, m, t, grid, queries = read_input()
    dist = build_activation_times(n, m, grid)
    out_lines = []
    for i, j, p in queries:
        c0 = ord(grid[i][j]) & 1
        d = dist[i][j]
        if d == -1 or p <= d:
            out_lines.append(str(c0))
        else:
            out_lines.append(str(c0 ^ ((p - d) & 1)))
    sys.stdout.write("\n".join(out_lines))

def main():
    solve_all()

if __name__ == "__main__":
    # minimal asserts to ensure logic intact
    n, m = 2, 2
    grid = ["01","10"]
    dist = build_activation_times(n, m, grid)
    assert all(dist[i][j] == -1 for i in range(n) for j in range(m))
    grid2 = ["11","11"]
    dist2 = build_activation_times(2, 2, grid2)
    assert all(d == 0 for row in dist2 for d in row)
    # do not run solve_all() here
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Precompute the earliest activation time by multi-source BFS from cells with an initial equal-colored neighbor; then answer queries by parity after activation.}
\WHY{This pattern of ``first-change time then parity toggling'' appears in grid dynamics, influence spread, and shortest-time activation problems common in interviews and contests.}
\CHECKLIST{%
\begin{bullets}
\item Identify all cells with any same-color neighbor; seed BFS with $d=0$.
\item BFS to fill minimal $d$ for all cells; leave $-1$ if unreachable.
\item For query $(i,j,p)$: if $p\le d$, output initial; else output initial xor parity of $(p-d)$.
\item Watch indexing (convert to 0-based for arrays).
\item Use fast I/O and avoid extra allocations in BFS.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $n=1$ or $m=1$ lines.
\item All cells identical: every cell has $d=0$.
\item Perfect checkerboard: no $d=0$ seeds; never changes.
\item Mixed components where only borders activate first.
\item Queries with very large $p$ (parity only matters).
\item Cells with $d=0$ and $p=1$ should flip once.
\item Single cell grid: never changes.
\item Multiple queries on same cell with varying $p$.
\item Grids where only one pair of equal neighbors exists.
\item Max sizes to ensure no overflow of time; Python ints safe.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Off-by-one on the condition $p\le d$ vs $p<d$; the correct is $p\le d$ gives no change.
\item Forgetting to include all four neighbors.
\item Marking $d=1$ for seeds instead of $0$ causes parity shift.
\item Re-checking neighbors from original instead of current during BFS; BFS is on static graph, not states.
\item Using recursion (risk of recursion depth) instead of iterative BFS.
\item Excessive memory per cell (store only needed arrays).
\item Misreading input indices (1-based to 0-based).
\item Using string concatenation in inner loops; keep operations simple.
\item Comparing $p$ to $d$ when $d=-1$ without checking first.
\item Incorrectly treating $p=0$ (not present here, but good to guard).
\end{bullets}
}
\FAILMODES{Brute force fails for large $p$ due to time; per-query local simulation fails because changes can arrive later from distant seeds. The BFS-parity method remains robust for all inputs and large $p$.}
\ELI{Some cells start in a crowd and begin flipping right away; the flipping spreads out one step per time unit. A cell stays as it was until the wave reaches it, then it flips every time after, so only the parity since activation matters.}
\NotePages{3}

\end{document}