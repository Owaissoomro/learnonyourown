% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Level Generation}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/818/F}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{Ivan is developing his own computer game. Now he tries to create some levels for his game. But firstly for each level he needs to draw a graph representing the structure of the level.

Ivan decided that there should be exactly $n_i$ vertices in the graph representing level $i$, and the edges have to be bidirectional. When constructing the graph, Ivan is interested in special edges called bridges. An edge between two vertices $u$ and $v$ is called a bridge if this edge belongs to every path between $u$ and $v$ (and these vertices will belong to different connected components if we delete this edge). For each level Ivan wants to construct a graph where at least half of the edges are bridges. He also wants to maximize the number of edges in each constructed graph.

So the task Ivan gave you is: given $q$ numbers $n_1, n_2, \ldots, n_q$, for each $i$ tell the maximum number of edges in a graph with $n_i$ vertices, if at least half of the edges are bridges. Note that the graphs cannot contain multiple edges or self-loops.

Input:
The first line of input file contains a positive integer $q$ ($1 \le q \le 100{,}000$) — the number of graphs Ivan needs to construct.

Then $q$ lines follow, $i$-th line contains one positive integer $n_i$ ($1 \le n_i \le 2\cdot10^9$) — the number of vertices in $i$-th graph.

Note that in hacks you have to use $q = 1$.

Output:
Output $q$ numbers, $i$-th of them must be equal to the maximum number of edges in $i$-th graph.

Note:
In the first example it is possible to construct these graphs:

1. 1-2, 1-3;
2. 1-2, 1-3, 2-4;
3. 1-2, 1-3, 2-3, 1-4, 2-5, 3-6.}
\BREAKDOWN{Translate the combinatorial constraint \lq at least half the edges are bridges\rq{} into equations over the bridge-tree (2-edge-connected component tree). Show the optimal structure is one dense 2-edge-connected block (a clique on $k$ vertices) plus $s$ leaves hung by bridges, with $s \ge \binom{k}{2}$. Derive the optimal $k$ as the largest integer with $k(k+1)/2 \le n$, and compute the maximal number of edges.}
\ELI{Pack as many cycle edges as allowed into one clique and use the remaining vertices as leaf attachments so that bridges $\ge$ non-bridges.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $q$; then $q$ lines with integers $n_i$.
Ranges: $1 \le q \le 100{,}000$; $1 \le n_i \le 2\cdot10^9$.}
\OUTPUTS{For each $n_i$, print the maximum number of edges $m(n_i)$ in any simple graph on $n_i$ vertices such that the number of bridges is at least half of all edges (equivalently, bridges $\ge$ non-bridges). One answer per line.}
\SAMPLES{Examples (not from the platform statement but consistent):
- Input: 3; $n=[3,4,6]$ → Output: $[2,3,6]$.
- Input: 5; $n=[1,2,5,7,10]$ → Output: $[0,1,4,7,12]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the graph be decomposed into its 2-edge-connected components (2ECCs). Compressing each 2ECC to a node, bridges form a tree over components. Let $k$ be the size of a single dense 2ECC (a clique), and $s$ be the number of leaf vertices attached by bridges.}
\varmapStart
\var{n}{number of vertices}
\var{k}{size of the single dense 2ECC (we will choose $k \ge 3$ when possible)}
\var{s}{number of leaves attached by bridges; $s = n - k$}
\var{t}{number of non-bridge edges (all inside 2ECCs)}
\var{b}{number of bridges (tree edges between components)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Edges } m = b + t, \quad \text{constraint } b \ge t.\\
&\text{Capacity: } t \le \sum_j \binom{s_j}{2} \ \text{over 2ECC sizes } s_j, \text{ hence } t \le \binom{k}{2} \text{ if using one 2ECC of size } k.\\
&\text{Bridge-tree: } b = (\#\text{components}) - 1 = s \quad \text{(one 2ECC plus } s \text{ leaves)}.\\
&\text{Feasibility: } \binom{k}{2} \le s \iff k + \binom{k}{2} \le n \iff \frac{k(k+1)}{2} \le n.\\
&\text{Thus choose } k = \max\{k \in \mathbb{Z}_{\ge 0} : \tfrac{k(k+1)}{2} \le n\}.\\
&\text{Optimal } t = \binom{k}{2}, \quad b = s = n - k,\quad m(n) = (n - k) + \binom{k}{2}.
\end{aligned}
\]
}
\ASSUMPTIONS{Simple graphs (no multi-edges, no self-loops). Disconnected graphs are allowed; the optimal construction is connected but this is not required. 2-edge-connected components hosting non-bridge edges must have size at least $3$.}
\INVARIANTS{Bridges form a forest (tree if the graph is connected). Non-bridge edges occur only inside 2ECCs. For fixed total vertices allocated to 2ECCs, the sum of $\binom{s_j}{2}$ is maximized by concentrating all into one component (convexity).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{For each $n$, scan $k=0,1,2,\ldots$ upward until $\tfrac{k(k+1)}{2} \le n$ fails; take the last valid $k$ and compute $m(n)=n-k+\binom{k}{2}$.}
\ASSUMPTIONS{Direct incremental search; worst-case $k=O(\sqrt{n})$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a given $n$, start with $k=0$ and increase $k$ while $\tfrac{k(k+1)}{2} \le n$.
\item Let $k^\star$ be the last valid $k$.
\item Output $m(n)=n-k^\star+\tfrac{k^\star(k^\star-1)}{2}$.
\end{algosteps}
\COMPLEXITY{Per query $O(\sqrt{n})$ iterations; total $O(q\sqrt{n_{\max}})$ time; $O(1)$ space.}
\[
\begin{aligned}
T(n) &= \Theta\!\big(\max k: \tfrac{k(k+1)}{2} \le n\big) = \Theta(\sqrt{n}),\\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{By the model, the optimal $k$ is the largest with $\tfrac{k(k+1)}{2} \le n$. The baseline finds this $k$ by linear scan and uses the derived formula for $m(n)$.}
\EDGECASES{$n=1,2$ yield trees with $m=n-1$. For $3 \le n \le 5$, still $m=n-1$. For $n \ge 6$, $k \ge 3$ becomes feasible.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def max_edges_baseline(n: int) -> int:
    # Incremental scan for k with T_k = k(k+1)/2 <= n
    k = 0
    while (k + 1) * (k + 2) // 2 <= n:
        k += 1
    # m = n - k + C(k,2)
    return n - k + k * (k - 1) // 2

def read_input(data: str):
    it = data.strip().split()
    if not it:
        return []
    q = int(it[0])
    arr = [int(x) for x in it[1:1+q]]
    return arr

def solve_case(n: int) -> int:
    return max_edges_baseline(n)

def solve_all(arr):
    return "\n"+ "\n".join(str(solve_case(n)) for n in arr) if arr else ""

def _self_test():
    # Tiny sanity checks
    known = {1:0, 2:1, 3:2, 4:3, 5:4, 6:6, 7:7, 8:8, 10:12}
    for n, ans in known.items():
        assert max_edges_baseline(n) == ans
    # Monotonicity: m(n+1) >= m(n)
    prev = 0
    for n in range(1, 200):
        cur = max_edges_baseline(n)
        assert cur >= prev
        prev = cur

def main():
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
        return
    arr = read_input(data)
    out = solve_all(arr)
    sys.stdout.write(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked known small cases and monotonicity for $n \le 200$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search for Triangular Threshold}
\WHICHFORMULA{Compute $k=\max\{k: k(k+1)/2 \le n\}$ via binary search over $k \in [0, 2\sqrt{n}]$.}
\ASSUMPTIONS{Binary search ensures $O(\log n)$ per query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a given $n$, set low $=0$, high $=2\cdot\lfloor\sqrt{n}\rfloor+3$ (safe upper bound on $k$).
\item While low $\le$ high, mid $=\lfloor (low+high)/2 \rfloor$; if $\tfrac{\text{mid}(\text{mid}+1)}{2} \le n$, move low up and record mid; else move high down.
\item Compute $m(n)=n-k+\binom{k}{2}$ with the found $k$.
\end{algosteps}
\COMPLEXITY{Per query $O(\log n)$ arithmetic; $O(1)$ space.}
\[
\begin{aligned}
T(n) &= O(\log n), \quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Binary search finds the maximal $k$ satisfying the monotone predicate $k(k+1)/2 \le n$. The formula for $m(n)$ is the same as derived.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
import math

def max_edges_binary(n: int) -> int:
    # Find k via binary search: max k with k(k+1)/2 <= n
    lo, hi = 0, int(2*math.isqrt(n) + 5)
    best = 0
    while lo <= hi:
        mid = (lo + hi) // 2
        t = mid * (mid + 1) // 2
        if t <= n:
            best = mid
            lo = mid + 1
        else:
            hi = mid - 1
    k = best
    return n - k + k * (k - 1) // 2

def read_input(data: str):
    it = data.strip().split()
    if not it:
        return []
    q = int(it[0])
    arr = [int(x) for x in it[1:1+q]]
    return arr

def solve_case(n: int) -> int:
    return max_edges_binary(n)

def solve_all(arr):
    return "\n"+ "\n".join(str(solve_case(n)) for n in arr) if arr else ""

def _self_test():
    # Cross-check with baseline on a range
    def baseline(n: int) -> int:
        k = 0
        while (k + 1) * (k + 2) // 2 <= n:
            k += 1
        return n - k + k * (k - 1) // 2
    for n in range(1, 2000):
        assert max_edges_binary(n) == baseline(n)
    # Spot checks
    for n, ans in {1:0,2:1,3:2,4:3,5:4,6:6,7:7,8:8,10:12,15:18}.items():
        assert max_edges_binary(n) == ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
        return
    arr = read_input(data)
    out = solve_all(arr)
    sys.stdout.write(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Verified against the baseline for $n \le 2000$ and additional spot checks.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Closed Form via Integer Square Root}
\WHICHFORMULA{Use $k=\left\lfloor \dfrac{\sqrt{8n+1}-1}{2}\right\rfloor$ from solving $k(k+1)/2 \le n$. Then $m(n)=n-k+\binom{k}{2}$. Compute $\lfloor\sqrt{8n+1}\rfloor$ with integer sqrt to avoid floating-point errors.}
\ASSUMPTIONS{$n$ up to $2\cdot10^9$; $8n+1$ fits in 64 bits; using integer arithmetic is exact.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $s=\lfloor\sqrt{8n+1}\rfloor$ by integer square root.
\item Let $k=(s-1)\mathbin{//}2$ (this is the maximal $k$ with $k(k+1)/2 \le n$).
\item Output $m(n)=n-k+k(k-1)/2$.
\end{algosteps}
\OPTIMALITY{This achieves the theoretical upper bound by saturating $t=\binom{k}{2}$ non-bridge edges and $b=s=n-k$ bridges with $s \ge t$. Concentrating all non-bridges into one 2ECC is optimal by convexity of $\binom{\cdot}{2}$.}
\COMPLEXITY{Per query $O(1)$ time and space.}
\[
\begin{aligned}
T(n) &= O(1), \quad S(n)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from math import isqrt

def max_edges_optimal(n: int) -> int:
    # k = floor((sqrt(8n+1)-1)/2)
    s = isqrt(8*n + 1)
    k = (s - 1) // 2
    return n - k + k * (k - 1) // 2

def read_input(data: str):
    it = data.strip().split()
    if not it:
        return []
    q = int(it[0])
    arr = [int(x) for x in it[1:1+q]]
    return arr

def solve_case(n: int) -> int:
    return max_edges_optimal(n)

def solve_all(arr):
    return "\n"+ "\n".join(str(solve_case(n)) for n in arr) if arr else ""

def _self_test():
    # Exact checks
    assert max_edges_optimal(1) == 0
    assert max_edges_optimal(6) == 6
    assert max_edges_optimal(10) == 12
    # Cross-check small range with a safe method
    def safe(n: int) -> int:
        k = (isqrt(8*n + 1) - 1) // 2
        return n - k + k * (k - 1) // 2
    for n in range(1, 5000):
        assert max_edges_optimal(n) == safe(n)

def main():
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
        return
    arr = read_input(data)
    out = solve_all(arr)
    sys.stdout.write(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 checks on $n=1,6,10$ plus a range cross-check against the same closed form for $n<5000$.}
\RESULT{For each $n$, compute $k=\left\lfloor (\sqrt{8n+1}-1)/2 \right\rfloor$ and return $m(n)=n-k+\binom{k}{2}$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Property tests: monotonicity of $m(n)$; boundary values $n=1,2,3,4,5,6$; random $n$ cross-checked across approaches.}
\LINE{CROSS-CHECKS}{Ensure Approach A, B, and C return identical results for $n$ in a dense grid (e.g., $1$ to $10^4$).}
\LINE{EDGE-CASE GENERATOR}{Construct near-triangular thresholds: $n=T_k$, $n=T_k\pm 1$, where $T_k=\tfrac{k(k+1)}{2}$, to verify off-by-one correctness of $k$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from math import isqrt

def tri(k): return k*(k+1)//2

def reference(n: int) -> int:
    s = isqrt(8*n + 1)
    k = (s - 1)//2
    return n - k + k*(k-1)//2

def generate_tests(limit_k=2000):
    cases = set()
    for k in range(1, limit_k+1):
        T = tri(k)
        for d in (-1, 0, 1, 2, 3):
            n = max(1, T + d)
            cases.add(n)
    # Add small and spaced random-like values deterministically
    for n in range(1, 1000):
        cases.add(n)
    return sorted(cases)

def run_tests():
    # Cross-check that all implementations agree
    def baseline(n):
        k=0
        while (k+1)*(k+2)//2 <= n:
            k+=1
        return n - k + k*(k-1)//2
    def binary(n):
        lo, hi, best = 0, int(2*isqrt(n) + 5), 0
        while lo <= hi:
            mid = (lo + hi)//2
            t = mid*(mid+1)//2
            if t <= n:
                best = mid; lo = mid+1
            else:
                hi = mid-1
        k = best
        return n - k + k*(k-1)//2
    for n in generate_tests():
        r = reference(n)
        assert r == baseline(n) == binary(n)
    return True

if __name__ == "__main__":
    assert run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from math import isqrt

def read_input(data: str):
    it = data.strip().split()
    if not it:
        return []
    q = int(it[0])
    arr = [int(x) for x in it[1:1+q]]
    return arr

def solve_case(n: int) -> int:
    s = isqrt(8*n + 1)
    k = (s - 1) // 2
    return n - k + k * (k - 1) // 2

def solve_all(arr):
    return "\n"+ "\n".join(str(solve_case(n)) for n in arr) if arr else ""

def _self_test():
    pairs = [(1,0),(2,1),(3,2),(4,3),(5,4),(6,6),(7,7),(8,8),(9,9),(10,12)]
    for n, ans in pairs:
        assert solve_case(n) == ans
    # Triangular thresholds
    for k in range(1, 2000):
        T = k*(k+1)//2
        assert solve_case(T) == k*(k-1)
        assert solve_case(T+1) >= solve_case(T)

def main():
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
        return
    arr = read_input(data)
    out = solve_all(arr)
    sys.stdout.write(out)

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize edges in an $n$-vertex simple graph with at least half of edges being bridges; answer via a triangular-threshold closed form.}
\WHY{Tests ability to reduce structural graph constraints to algebra using block decompositions, and to derive tight extremal constructions.}
\CHECKLIST{
- Translate condition to $b \ge t$ with $m=b+t$.
- Use 2-edge-connected component (2ECC) tree; non-bridges live only inside 2ECCs.
- Concentrate all non-bridges in one 2ECC of size $k$.
- Enforce feasibility $\binom{k}{2} \le n-k \iff k(k+1)/2 \le n$.
- Take maximal such $k$; compute $m=n-k+\binom{k}{2}$.
- Implement $k$ via integer sqrt: $k=\lfloor(\sqrt{8n+1}-1)/2\rfloor$.}
\EDGECASES{
- $n=1$: $m=0$.
- $n=2$: $m=1$ (single edge).
- $n=3,4,5$: trees are optimal, $m=n-1$.
- First nontrivial 2ECC at $n=6$ (triangle plus $3$ leaves), $m=6$.
- Near triangular thresholds $n=T_k$ and $n=T_k\pm 1$.}
\PITFALLS{
- Treating a size-2 component as a 2ECC (impossible in simple graphs).
- Floating-point sqrt rounding; use integer sqrt.
- Off-by-one in $k(k+1)/2 \le n$ vs. $<$.
- Overflow if using 32-bit intermediates (avoid in C++; use 64-bit).
- Forgetting that graphs need not be connected (construction does not require connectivity).}
\FAILMODES{Brute-force or simulation over graphs is infeasible. Greedy addition of edges without the 2ECC perspective can violate $b \ge t$. The closed form avoids both.}
\ELI{Make one dense block (a clique) to host all cycle edges, and hang enough leaves by bridges so that bridges outnumber cycle edges. The largest clique you can afford is the biggest $k$ with $k(k+1)/2 \le n$, and the edge count follows directly.}
\NotePages{3}

\end{document}