% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Vova and Trophies}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1082/B}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Vova has won $n$ trophies in different competitions. Each trophy is either golden or silver. The trophies are arranged in a row.

The beauty of the arrangement is the length of the longest subsegment consisting of golden trophies. Vova wants to swap two trophies (not necessarily adjacent ones) to make the arrangement as beautiful as possible — that means, to maximize the length of the longest such subsegment.

Help Vova! Tell him the maximum possible beauty of the arrangement if he is allowed to do at most one swap.

Input: The first line contains one integer $n$ ($2 \le n \le 10^5$) — the number of trophies.

The second line contains $n$ characters, each of them is either G or S. If the $i$-th character is G, then the $i$-th trophy is a golden one, otherwise it is a silver trophy.

Output: Print the maximum possible length of a subsegment of golden trophies, if Vova is allowed to do at most one swap.

Note: In the first example Vova has to swap trophies with indices $4$ and $10$. Thus he will obtain the sequence ``GGGGGGGSGS'', the length of the longest subsegment of golden trophies is $7$.

In the second example Vova can make no swaps at all. The length of the longest subsegment of golden trophies in the sequence is $4$.

In the third example Vova cannot do anything to make the length of the longest subsegment of golden trophies in the sequence greater than $0$.}
\BREAKDOWN{We need to maximize the longest run of consecutive G after at most one swap of any two positions. Key observations: total count of G is fixed; we can either extend an existing run by $1$ (if there is any spare G elsewhere) or bridge two G runs separated by exactly one S, possibly gaining $+1$ if there exists an extra G outside those runs.}
\ELI{Count G's; find current runs; try replacing each S with a G once to see the best merged length, but never exceed the total number of G's.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two lines: (1) integer $n$ with $2 \le n \le 10^5$; (2) a string of length $n$ over the alphabet $\{ \text{G}, \text{S} \}$.}
\OUTPUTS{A single integer: the maximum length of a contiguous subsegment consisting only of G that can be achieved by performing at most one swap of any two positions (or zero swaps).}
\SAMPLES{Example 1: input: $n=10$, string ``GGGSGSSGGG''; output: $7$.

Example 2: input: $n=6$, string ``GGGGSS''; output: $4$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a binary string $s \in \{\text{G},\text{S}\}^n$, let $T=\#\{i : s_i=\text{G}\}$ denote the total number of G. Let $f(s)$ be the maximum length of a run of consecutive G in $s$. We seek
\begin{BreakableEquation*}
\max\{ f(s') : s' \text{ is obtained from } s \text{ by at most one swap of positions} \}.
\end{BreakableEquation*}}
\varmapStart
\var{n}{length of the trophy row}
\var{T}{total number of G in the string}
\var{f(s)}{length of the longest contiguous run of G in string $s$}
\var{L_i}{number of consecutive G ending at position $i$}
\var{R_i}{number of consecutive G starting at position $i$}
\var{a,b}{indices of a potential swap}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer} \;=\; \max\Bigg( f(s), \;\max_{i:\,s_i=\text{S}} \min\big(T,\;L_{i-1}+R_{i+1}+1\big)\Bigg),
\end{BreakableEquation*}
with boundary conventions $L_0=0$ and $R_{n+1}=0$, and where $L_{i-1}$ is the run of G immediately to the left of $i$ and $R_{i+1}$ to the right. The $\min$ by $T$ ensures we cannot exceed the total number of G.}
\ASSUMPTIONS{Indices are $1$-based in the model; implementation may use $0$-based. A swap can be between any two positions. Zero swap is allowed.}
\INVARIANTS{Total $T$ of G is invariant under swaps. Any new longest run cannot exceed $T$. Bridging two G runs across a single S yields length $L+R$ if $T=L+R$, else $L+R+1$ if there exists an extra G elsewhere.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all pairs of positions to swap (including the option to not swap) and compute the longest G-run each time.}
\ASSUMPTIONS{This is for correctness validation on small inputs; it is too slow for large $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute the current longest run of G.
\item For every pair $(i,j)$ with $0 \le i < j < n$, if $s[i]\ne s[j]$, swap them virtually, compute the longest run, and restore.
\item Track the maximum over all tries.
\end{algosteps}
\COMPLEXITY{Brute force checks $O(n^2)$ swaps and each check scans $O(n)$, so $T(n)=O(n^3)$ time, $S(n)=O(1)$ space.}
\[
\begin{aligned}
T(n) &= \binom{n}{2}\cdot O(n) + O(n) \\
     &= O(n^3).
\end{aligned}
\]
\CORRECTNESS{Enumerates all possible single swaps, so the best achievable arrangement will be considered.}
\EDGECASES{All G $\Rightarrow$ answer $=n$. All S $\Rightarrow$ answer $=0$. Single S or single G cases are handled by the scan.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def longest_g_run(s: str) -> int:
    best = 0
    cur = 0
    for ch in s:
        if ch == 'G':
            cur += 1
            if cur > best:
                best = cur
        else:
            cur = 0
    return best

def brute_force_best(s: str) -> int:
    n = len(s)
    ans = longest_g_run(s)
    arr = list(s)
    for i in range(n):
        for j in range(i + 1, n):
            if arr[i] == arr[j]:
                continue
            arr[i], arr[j] = arr[j], arr[i]
            cand = longest_g_run(''.join(arr))
            if cand > ans:
                ans = cand
            arr[i], arr[j] = arr[j], arr[i]
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0])
    s = data[1].strip()
    return n, s

def solve_case(n: int, s: str) -> int:
    # Baseline brute force (only for small n)
    return brute_force_best(s)

def solve_all():
    got = read_input()
    if got is None:
        return
    n, s = got
    print(solve_case(n, s))

def _run_asserts():
    assert longest_g_run("SSSS") == 0
    assert longest_g_run("GGGG") == 4
    assert brute_force_best("GGGSGGG") == 6  # merge across one S, limited by total G
    assert brute_force_best("GSGSG") == 3

if __name__ == "__main__":
    # Uncomment to run local asserts
    # _run_asserts()
    solve_all()
\end{minted}
\VALIDATION{Checked symmetric strings, all G, all S, and a bridgeable case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Runs \& Single-Gap Bridge}
\WHICHFORMULA{Precompute runs of consecutive G and examine each S position: the best after one swap is $\min\big(T, L+R+1\big)$ where $L$ and $R$ are the adjacent run lengths.}
\ASSUMPTIONS{Single pass arrays $L$ and $R$ suffice; answer never exceeds total $T$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count $T=\#\text{G}$; if $T=0$ return $0$, if $T=n$ return $n$.
\item Compute arrays $L$ (G-run ending at $i$) and $R$ (G-run starting at $i$), and current $f(s)$.
\item For every $i$ with $s[i]=\text{S}$, compute $L_{i-1}+R_{i+1}$ and candidate $\min(T, L_{i-1}+R_{i+1}+1)$; take the maximum over all $i$ and $f(s)$. 
\end{algosteps}
\COMPLEXITY{Single pass for $L$, $R$, and a scan over $n$ positions gives $T(n)=O(n)$ time and $S(n)=O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Covers both extending a run by $1$ (swapping in one external G) and bridging two runs across a single S; the $\min$ by $T$ enforces the global cap.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def best_after_one_swap_linear(s: str) -> int:
    n = len(s)
    T = s.count('G')
    if T == 0:
        return 0
    if T == n:
        return n
    L = [0] * n
    R = [0] * n
    # L: consecutive G ending at i
    for i in range(n):
        if s[i] == 'G':
            L[i] = 1 + (L[i - 1] if i > 0 else 0)
        else:
            L[i] = 0
    # R: consecutive G starting at i
    for i in range(n - 1, -1, -1):
        if s[i] == 'G':
            R[i] = 1 + (R[i + 1] if i + 1 < n else 0)
        else:
            R[i] = 0
    base = max(L) if n > 0 else 0
    ans = base
    for i in range(n):
        if s[i] == 'S':
            left = L[i - 1] if i > 0 else 0
            right = R[i + 1] if i + 1 < n else 0
            cand = min(T, left + right + 1)
            if cand > ans:
                ans = cand
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0])
    s = data[1].strip()
    return n, s

def solve_case(n: int, s: str) -> int:
    return best_after_one_swap_linear(s)

def solve_all():
    got = read_input()
    if got is None:
        return
    n, s = got
    print(solve_case(n, s))

def _run_asserts():
    assert best_after_one_swap_linear("SSSS") == 0
    assert best_after_one_swap_linear("GGGG") == 4
    assert best_after_one_swap_linear("GGGSGGG") == 6
    assert best_after_one_swap_linear("GSGSG") == 3
    assert best_after_one_swap_linear("SGGGG") == 5 - 1 + 1  # total G=4, capped

if __name__ == "__main__":
    # _run_asserts()
    solve_all()
\end{minted}
\VALIDATION{Covers no G, all G, bridgeable, alternating, and cap-by-total cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Left-Right Runs with Global Cap}
\WHICHFORMULA{Use left and right G-run lengths at each S to test the unique swap that would place a G at that S; cap by total $T$.}
\ASSUMPTIONS{Works for all $n$; linear time and memory.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count total G, and handle $T=0$ and $T=n$ immediately.
\item Compute $L$ and $R$ in $O(n)$.
\item Initialize $ans=f(s)$. For each S at position $i$, compute $cand=\min(T, L_{i-1}+R_{i+1}+1)$ and maximize $ans$.
\end{algosteps}
\OPTIMALITY{Any single swap can only affect the adjacency around at most two positions; considering each S as the recipient of a G after the swap exhausts all distinct beneficial outcomes. The cap by $T$ is information-theoretic.}
\COMPLEXITY{$T(n)=O(n)$, $S(n)=O(n)$ for arrays; can be reduced to $O(1)$ extra space by rolling computation if desired.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def best_after_one_swap_linear(s: str) -> int:
    n = len(s)
    T = s.count('G')
    if T == 0:
        return 0
    if T == n:
        return n
    L = [0] * n
    R = [0] * n
    for i in range(n):
        if s[i] == 'G':
            L[i] = 1 + (L[i - 1] if i > 0 else 0)
        else:
            L[i] = 0
    for i in range(n - 1, -1, -1):
        if s[i] == 'G':
            R[i] = 1 + (R[i + 1] if i + 1 < n else 0)
        else:
            R[i] = 0
    base = max(L) if n > 0 else 0
    ans = base
    for i in range(n):
        if s[i] == 'S':
            left = L[i - 1] if i > 0 else 0
            right = R[i + 1] if i + 1 < n else 0
            cand = min(T, left + right + 1)
            if cand > ans:
                ans = cand
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0])
    s = data[1].strip()
    return n, s

def solve_case(n: int, s: str) -> int:
    return best_after_one_swap_linear(s)

def solve_all():
    got = read_input()
    if got is None:
        return
    n, s = got
    print(solve_case(n, s))

def _run_asserts():
    # Exactly 3 asserts
    assert solve_case(10, "GGGSGSSGGG") == 7
    assert solve_case(6, "GGGGSS") == 4
    assert solve_case(5, "SSSSS") == 0

if __name__ == "__main__":
    # _run_asserts()
    solve_all()
\end{minted}
\VALIDATION{Three asserts covering the sample-like scenarios and extremes.}
\RESULT{Print the maximum achievable length of a contiguous block of G after at most one swap, never exceeding the total number of G.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test helper functions on edge cases: all G, all S, single S, alternating patterns, and random strings; property: result $\le T$ and $\ge f(s)$.}
\LINE{CROSS-CHECKS}{For small $n$ ($\le 20$), compare brute force (Approach A) with optimal (Approach C) over random strings.}
\LINE{EDGE-CASE GENERATOR}{Generate strings with runs of length $0,1,n$, single-gap bridges, and cases with no single-gap bridges.}
\begin{minted}{python}
import random

def gen_cases(n, trials=100):
    cases = []
    for _ in range(trials):
        s = ''.join(random.choice('GS') for _ in range(n))
        cases.append(s)
    # Hand-crafted edges
    cases += ["G"*n, "S"*n, "G"*(n-1)+"S", "S"+"G"*(n-1), "G"*3+"S"+"G"*3, "GSGSGS", "SGSGSG"]
    return cases

def cross_check_small(nmax=12):
    from itertools import product
    def brute_force_best(s: str) -> int:
        def longest_g_run(t: str) -> int:
            best = 0
            cur = 0
            for ch in t:
                if ch == 'G':
                    cur += 1
                    best = max(best, cur)
                else:
                    cur = 0
            return best
        n = len(s)
        ans = longest_g_run(s)
        arr = list(s)
        for i in range(n):
            for j in range(i+1, n):
                if arr[i] == arr[j]:
                    continue
                arr[i], arr[j] = arr[j], arr[i]
                ans = max(ans, longest_g_run(''.join(arr)))
                arr[i], arr[j] = arr[j], arr[i]
        return ans

    def best_after_one_swap_linear(s: str) -> int:
        n = len(s)
        T = s.count('G')
        if T == 0: return 0
        if T == n: return n
        L = [0]*n; R = [0]*n
        for i in range(n):
            L[i] = (L[i-1] + 1) if s[i]=='G' else 0
        for i in range(n-1, -1, -1):
            R[i] = (R[i+1] + 1) if s[i]=='G' else 0
        base = max(L)
        ans = base
        for i,ch in enumerate(s):
            if ch == 'S':
                left = L[i-1] if i>0 else 0
                right = R[i+1] if i+1<n else 0
                ans = max(ans, min(T, left+right+1))
        return ans

    for n in range(2, nmax+1):
        for bits in product('GS', repeat=n):
            s = ''.join(bits)
            a = brute_force_best(s)
            b = best_after_one_swap_linear(s)
            assert a == b, (n, s, a, b)

if __name__ == "__main__":
    # cross_check_small()
    pass
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def best_after_one_swap_linear(s: str) -> int:
    n = len(s)
    T = s.count('G')
    if T == 0:
        return 0
    if T == n:
        return n
    L = [0] * n
    R = [0] * n
    for i in range(n):
        if s[i] == 'G':
            L[i] = 1 + (L[i - 1] if i > 0 else 0)
        else:
            L[i] = 0
    for i in range(n - 1, -1, -1):
        if s[i] == 'G':
            R[i] = 1 + (R[i + 1] if i + 1 < n else 0)
        else:
            R[i] = 0
    base = max(L) if n > 0 else 0
    ans = base
    for i in range(n):
        if s[i] == 'S':
            left = L[i - 1] if i > 0 else 0
            right = R[i + 1] if i + 1 < n else 0
            cand = min(T, left + right + 1)
            if cand > ans:
                ans = cand
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n = int(data[0])
    s = data[1].strip()
    return n, s

def solve_case(n: int, s: str) -> int:
    return best_after_one_swap_linear(s)

def solve_all():
    got = read_input()
    if got is None:
        return
    n, s = got
    print(solve_case(n, s))

def _run_asserts():
    assert solve_case(10, "GGGSGSSGGG") == 7
    assert solve_case(6, "GGGGSS") == 4
    assert solve_case(5, "SSSSS") == 0

if __name__ == "__main__":
    # _run_asserts()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the longest contiguous G-run after at most one swap; examine each S as a potential recipient of a G and cap by total G.}
\WHY{Common string-run and one-move optimization pattern; tests ability to turn observations into linear-time solutions.}
\CHECKLIST{%
\begin{bullets}
\item Count total G ($T$).
\item Handle trivial $T=0$ and $T=n$.
\item Build $L$ and $R$ arrays.
\item Initialize answer with current longest run.
\item For each S, update with $\min(T, L_{i-1}+R_{i+1}+1)$.
\item Print the maximum.
\end{bullets}}
\EDGECASES{%
\begin{bullets}
\item All G: answer is $n$.
\item All S: answer is $0$.
\item Single S in middle: bridge limited by $T$.
\item Single G: answer is $1$.
\item S at ends: extension by $+1$ capped by $T$.
\item Multiple disjoint runs with no single-gap: best is $\min(T, \text{max\_run}+1)$.
\item Very long $n$: ensure $O(n)$ method.
\item Alternate GS pattern.
\item Leading/trailing spaces in input.
\item Non-adjacent swap allowed — do not constrain to neighbors.
\end{bullets}}
\PITFALLS{%
\begin{bullets}
\item Forgetting the global cap by $T$ can overcount by $1$.
\item Not initializing with current longest run when no beneficial swap exists.
\item Off-by-one at boundaries for $L_{i-1}$ and $R_{i+1}$.
\item Mishandling $T=n$ (no S to iterate).
\item Counting $L+R+1$ when there is no extra G (should be capped).
\item Using quadratic or cubic time for large $n$.
\item Misreading input (newline after $n$).
\item Treating swap as adjacent only.
\item Using 1-based indexing in code without care.
\item Mutating the string without restoring in brute force tests.
\end{bullets}}
\FAILMODES{Weak approaches that only extend the maximum run by $+1$ miss the bridge-across-single-S case; conversely, merging without the global cap overshoots when $T$ equals the sum of the two runs. The linear method survives both.}
\ELI{Look at each S and imagine turning it into a G once; the run that would form is left-run plus right-run plus possibly one more if there exists another G somewhere else. The best of these (capped by total G) is the answer.}
\NotePages{3}

\end{document}