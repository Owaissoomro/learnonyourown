% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Last Substring in Lexicographical Order}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/last-substring-in-lexicographical-order/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given a string \texttt{s}, return the last substring of \texttt{s} in lexicographical order.

\textbf{Example 1:}

\textbf{Input:} \texttt{s = "abab"} \\
\textbf{Output:} \texttt{"bab"} \\
\textbf{Explanation:} The substrings are [\,"a", "ab", "aba", "abab", "b", "ba", "bab"\,]. The lexicographically maximum substring is \texttt{"bab"}.

\textbf{Example 2:}

\textbf{Input:} \texttt{s = "leetcode"} \\
\textbf{Output:} \texttt{"tcode"}

\textbf{Constraints:}
\begin{bullets}
\item $1 \le |s| \le 4 \times 10^5$.
\item \texttt{s} contains only lowercase English letters.
\end{bullets}
}
\BREAKDOWN{Identify the lexicographically largest suffix among all substrings. Observing that any lexicographically maximal substring must be a suffix, reduce the search to comparing suffixes efficiently.}
\ELI{Among all cut-offs of the string, choose the one whose remaining tail looks the biggest in dictionary order.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single string $s$ of length $n$ with $1 \le n \le 4 \times 10^5$, consisting only of lowercase English letters \texttt{a}--\texttt{z}.}
\OUTPUTS{Return the lexicographically largest substring of $s$; equivalently, return the largest suffix of $s$ under lexicographic order.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{"abab"} $\to$ Output: \texttt{"bab"}.
\item Input: \texttt{"leetcode"} $\to$ Output: \texttt{"tcode"}.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s = s_0 s_1 \ldots s_{n-1}$ over alphabet $\Sigma = \{a,\ldots,z\}$. For any index $i \in \{0,\ldots,n-1\}$, define the suffix $S_i := s[i\,..\,n-1]$. The goal is to return $S_{i^\star}$ where $i^\star \in \arg\max_{0 \le i < n} S_i$ under standard lexicographic order on $\Sigma^\ast$.}
\varmapStart
\var{n}{length of the string $s$}
\var{i,j}{candidate starting indices of maximal suffixes}
\var{k}{current offset while comparing two suffixes}
\var{i^\star}{starting index of the lexicographically largest suffix}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
i^\star \in \arg\max_{0 \le i < n} S_i,\quad \text{where } S_i \prec S_j \iff \exists\,t \ge 0:\ \forall u < t,\ s_{i+u}=s_{j+u},\ \text{and } s_{i+t} < s_{j+t},
\end{BreakableEquation*}
with the convention that a shorter string that is a prefix of a longer one is lexicographically smaller.
}
\ASSUMPTIONS{Zero-based indexing. Standard lexicographic comparison. If multiple indices yield the same maximal substring value, returning any yields the same string value.}
\INVARIANTS{
\begin{bullets}
\item Any lexicographically maximal substring must be a suffix: if a substring starts at $i$ and ends before $n-1$, extending it by $s_{n-1}$ cannot decrease its lexicographic value relative to any suffix starting at $i$.
\item During two-pointer scanning, indices that are proven worse than a competitor for all future alignments are discarded permanently.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all suffixes $S_i = s[i\,..\,n-1]$ and take the lexicographic maximum.}
\ASSUMPTIONS{Use language-native lexicographic string comparison; store or stream-compute suffixes.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $i$ from $0$ to $n-1$, form the suffix $S_i = s[i:]$.
\item Track the running maximum string under lexicographic order.
\item Return the maximum suffix found.
\end{algosteps}
\COMPLEXITY{Building or comparing suffixes costs $\Theta(n)$ per index, yielding $\Theta(n^2)$ time in the worst case and up to $\Theta(n^2)$ extra space if all suffixes are materialized; a streamed maximum uses $O(1)$ extra space.}
\[
\begin{aligned}
T(n) &= \sum_{i=0}^{n-1} \Theta(n-i) \\
     &= \Theta\!\left(\sum_{k=1}^{n} k\right) \\
     &= \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{Every substring is dominated by some suffix that starts at the same position, so the lexicographic maximum over all substrings equals the maximum over all suffixes. The algorithm explicitly examines all suffixes and selects the maximum.}
\EDGECASES{Single-character strings; all-equal characters (e.g., \texttt{"aaaaa"}); strictly increasing/ decreasing patterns; tie cases where multiple positions yield identical maximal strings.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def lastSubstring(self, s: str) -> str:
        # Brute-force: scan all suffixes and keep the largest.
        best = ""
        for i in range(len(s)):
            suf = s[i:]
            if suf > best:
                best = suf
        return best

# Tiny baseline checks
sol = Solution()
assert sol.lastSubstring("abab") == "bab"
assert sol.lastSubstring("leetcode") == "tcode"
assert sol.lastSubstring("aaaa") == "aaaa"
\end{minted}
\VALIDATION{Checked against the two samples and an edge case of all-equal letters.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Filter by Maximal First Character + Direct Suffix Compare}
\WHICHFORMULA{The maximal suffix must start at a position whose first character is the global maximum character in $s$. Restrict candidates to those indices, then compare suffixes pairwise to select the best.}
\ASSUMPTIONS{If $m=\max(s)$, then any suffix starting with a character $< m$ is dominated and can be ignored.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Find $m = \max(s)$ and collect candidate start indices $C=\{i \mid s[i]=m\}$.
\item Initialize $best \leftarrow$ first element of $C$.
\item For each $j \in C \setminus \{best\}$, compare $s[j:]$ and $s[best:]$ character-by-character; if $s[j:]$ is larger, set $best \leftarrow j$.
\item Return $s[best:]$.
\end{algosteps}
\COMPLEXITY{If there are $k$ candidate positions, each comparison can scan up to $O(n)$ characters in the worst case. Thus $T(n)=O(kn)$ with $k \le n$, which is typically much smaller than $n^2$ when $k \ll n$.}
\[
\begin{aligned}
T(n) &\le O(k \cdot n),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Any optimal suffix must start with the maximal letter $m$. Among those candidates, pairwise lexicographic comparison is transitive; selecting the maximum among them yields the global maximum suffix.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def lastSubstring(self, s: str) -> str:
        n = len(s)
        if n <= 1:
            return s
        m = max(s)
        candidates = [i for i, ch in enumerate(s) if ch == m]
        best = candidates[0]
        for j in candidates[1:]:
            if self._cmp_suffix(s, j, best) > 0:
                best = j
        return s[best:]

    @staticmethod
    def _cmp_suffix(s: str, i: int, j: int) -> int:
        """Return 1 if s[i:] > s[j:], -1 if smaller, 0 if equal."""
        n = len(s)
        while i < n and j < n:
            if s[i] != s[j]:
                return 1 if s[i] > s[j] else -1
            i += 1
            j += 1
        if i == n and j == n:
            return 0
        return -1 if i == n else 1

# Spot checks
sol = Solution()
assert sol.lastSubstring("abab") == "bab"
assert sol.lastSubstring("zzza") == "zzza"
assert sol.lastSubstring("azzz") == "zzzz"[1:]  # "zzz"
\end{minted}
\VALIDATION{Validated on crafted inputs emphasizing concentration of the maximal character and ties among candidates.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two-Pointer Maximal Suffix Algorithm (Duval/KMP-style)}
\WHICHFORMULA{Use the classic linear-time two-pointer algorithm for finding the lexicographically maximal suffix: maintain two candidate starts $i$ and $j$ and an offset $k$, skipping dominated regions greedily.}
\ASSUMPTIONS{Standard total lexicographic order; random access to characters.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $i=0$, $j=1$, $k=0$.
\item While $j+k<n$: compare $s[i+k]$ vs. $s[j+k]$.
\begin{bullets}
\item If equal, increment $k$.
\item If $s[i+k] < s[j+k]$, advance $i \leftarrow i+k+1$; if $i \le j$, set $i \leftarrow j+1$; reset $k \leftarrow 0$.
\item If $s[i+k] > s[j+k]$, advance $j \leftarrow j+k+1$; if $j \le i$, set $j \leftarrow i+1$; reset $k \leftarrow 0$.
\end{bullets}
\item Return $s[\min(i,j):]$.
\end{algosteps}
\OPTIMALITY{Each character is compared at most a constant number of times across pointer moves; indices skipped can never start a better suffix than the survivor. This yields tight $O(n)$ time and $O(1)$ space, which matches known lower bounds for comparison-based selection over $n$-length inputs.}
\COMPLEXITY{Each step either increases $k$ or advances $i$ or $j$ past at least one new position. Hence $T(n)=O(n)$, $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= O(n),\qquad S(n) = O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def lastSubstring(self, s: str) -> str:
        n = len(s)
        if n <= 1:
            return s
        i, j, k = 0, 1, 0
        while j + k < n:
            if s[i + k] == s[j + k]:
                k += 1
            elif s[i + k] < s[j + k]:
                i = i + k + 1
                if i <= j:
                    i = j + 1
                k = 0
            else:
                j = j + k + 1
                if j <= i:
                    j = i + 1
                k = 0
        start = min(i, j)
        return s[start:]

# Exactly 3 validation asserts
sol = Solution()
assert sol.lastSubstring("abab") == "bab"
assert sol.lastSubstring("leetcode") == "tcode"
assert sol.lastSubstring("zzza") == "zzza"
\end{minted}
\VALIDATION{Confirmed on both provided samples and a concentrated-maximum case.}
\RESULT{Returns the lexicographically maximal suffix of $s$ as a string. If multiple starting positions yield the same maximal string value, any such maximal suffix string is identical, so the return is unique as a value.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test canonical samples, edge cases (all same letters, alternating patterns), and randomized small strings by cross-checking the optimal solution against a simple quadratic baseline.}
\LINE{CROSS-CHECKS}{For many small inputs, verify that the optimal two-pointer result equals the brute-force maximum of all suffixes.}
\LINE{EDGE-CASE GENERATOR}{Generate fixed-seed random lowercase strings of small sizes; include degenerate cases like all \texttt{a}'s and all \texttt{z}'s.}
\begin{minted}{python}
import random
import string

def baseline_last_substring(s: str) -> str:
    best = ""
    for i in range(len(s)):
        suf = s[i:]
        if suf > best:
            best = suf
    return best

class Optimal:
    def lastSubstring(self, s: str) -> str:
        n = len(s)
        if n <= 1:
            return s
        i, j, k = 0, 1, 0
        while j + k < n:
            if s[i + k] == s[j + k]:
                k += 1
            elif s[i + k] < s[j + k]:
                i = i + k + 1
                if i <= j:
                    i = j + 1
                k = 0
            else:
                j = j + k + 1
                if j <= i:
                    j = i + 1
                k = 0
        return s[min(i, j):]

# Deterministic property tests
random.seed(0)
opt = Optimal()
for n in range(1, 25):
    for _ in range(50):
        s = "".join(random.choice(string.ascii_lowercase[:6]) for _ in range(n))
        assert opt.lastSubstring(s) == baseline_last_substring(s)

# Edge checks
for s in ["a", "aaaaa", "zzzz", "az", "za", "abababab", "babababa", "leetcode", "abab", "zzza"]:
    assert opt.lastSubstring(s) == baseline_last_substring(s)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def lastSubstring(self, s: str) -> str:
        n = len(s)
        if n <= 1:
            return s
        i, j, k = 0, 1, 0
        while j + k < n:
            if s[i + k] == s[j + k]:
                k += 1
            elif s[i + k] < s[j + k]:
                i = i + k + 1
                if i <= j:
                    i = j + 1
                k = 0
            else:
                j = j + k + 1
                if j <= i:
                    j = i + 1
                k = 0
        start = min(i, j)
        return s[start:]

# Sanity asserts for submission-local verification
sol = Solution()
assert sol.lastSubstring("abab") == "bab"
assert sol.lastSubstring("leetcode") == "tcode"
assert sol.lastSubstring("aaaa") == "aaaa"
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the lexicographically largest suffix of a given string in $O(n)$ time and $O(1)$ space.}
\WHY{A classic string-selection problem that tests deep understanding of lexicographic comparisons, two-pointer reasoning, and linear-time string algorithms.}
\CHECKLIST{
\begin{bullets}
\item Reduce to suffixes; substrings are unnecessary.
\item Consider maximal first character heuristic; then move to the two-pointer optimal algorithm.
\item Maintain $(i,j,k)$ invariants; reset $k$ correctly after pointer jumps.
\item Decide tie-handling: identical maximal substrings yield the same returned string.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All characters identical (e.g., \texttt{"aaaaaa"}).
\item Strictly increasing or decreasing letters.
\item Alternating patterns (e.g., \texttt{"abababab"}).
\item Multiple maximal letters grouped vs. scattered (e.g., \texttt{"zzza"}, \texttt{"zazzz"}).
\item Very short strings ($n=1,2$).
\item Long runs of equal characters creating long $k$ stretches.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to realign $i$ or $j$ past each other: must enforce $i \ne j$.
\item Not resetting $k$ to $0$ after advancing $i$ or $j$.
\item Off-by-one in the loop guard: use \texttt{while j + k < n}.
\item Returning the wrong start index: use \texttt{min(i, j)} at the end.
\item Misinterpreting lexicographic order when one suffix is a prefix of the other.
\item Building substrings repeatedly in the inner loop causing $O(n^2)$ time.
\end{bullets}
}
\FAILMODES{Brute force times out for $n$ near $4 \times 10^5$. The improved filter-by-max-letter approach can still degrade to quadratic on strings like many repeated maximal letters; the two-pointer algorithm remains linear.}
\ELI{Compare two candidate cut points by sliding until a difference appears; drop the worse one entirely and continue. Since every position is dropped at most once, the whole process is linear.}
\NotePages{3}

\end{document}