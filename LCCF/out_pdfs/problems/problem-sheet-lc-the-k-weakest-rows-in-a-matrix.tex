% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — The K Weakest Rows in a Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given an $m \times n$ binary matrix \texttt{mat} of $1$'s (representing soldiers) and $0$'s (representing civilians). The soldiers are positioned \textbf{in front} of the civilians. That is, in each row, all the $1$'s appear to the \textbf{left} of all the $0$'s. A row $i$ is \textbf{weaker} than a row $j$ if one of the following is true:
\begin{bullets}
\item The number of soldiers in row $i$ is less than the number of soldiers in row $j$.
\item Both rows have the same number of soldiers and $i<j$.
\end{bullets}
Return the indices of the $k$ weakest rows in the matrix ordered from weakest to strongest.

Example 1:

Input: \texttt{mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]]}, \texttt{k = 3}

Output: \texttt{[2,0,3]}

Explanation: The number of soldiers in each row is:
\begin{bullets}
\item Row 0: $2$
\item Row 1: $4$
\item Row 2: $1$
\item Row 3: $2$
\item Row 4: $5$
\end{bullets}
The rows ordered from weakest to strongest are \texttt{[2,0,3,1,4]}.

Example 2:

Input: \texttt{mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]]}, \texttt{k = 2}

Output: \texttt{[0,2]}

Explanation: The number of soldiers in each row is:
\begin{bullets}
\item Row 0: $1$
\item Row 1: $4$
\item Row 2: $1$
\item Row 3: $1$
\end{bullets}
The rows ordered from weakest to strongest are \texttt{[0,2,3,1]}.

Constraints:
\begin{bullets}
\item $m = \texttt{mat.length}$
\item $n = \texttt{mat[i].length}$
\item $2 \le n,m \le 100$
\item $1 \le k \le m$
\item $\texttt{mat[i][j]} \in \{0,1\}$ for all valid $i,j$.
\end{bullets}}
\BREAKDOWN{Count soldiers in each row; break ties by row index; select the $k$ smallest by the pair (soldiers, index).}
\ELI{Count $1$'s in every row, sort rows by that count and by index, then take the first $k$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An $m \times n$ binary matrix \texttt{mat} with each row's $1$'s left of $0$'s; integer $k$ with $1 \le k \le m$.}
\OUTPUTS{A list of $k$ row indices ordered from weakest to strongest according to soldier count, tie-broken by smaller row index.}
\SAMPLES{Example 1: \texttt{mat=[[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]]}, \texttt{k=3} $\to$ \texttt{[2,0,3]}. Example 2: \texttt{mat=[[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]]}, \texttt{k=2} $\to$ \texttt{[0,2]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in \{0,1\}^{m \times n}$ with each row nonincreasing: $A_{i,1} \ge A_{i,2} \ge \cdots \ge A_{i,n}$. Define $s_i = \sum_{j=1}^n A_{i,j}$. We totally order rows by $(s_i,i)$ in lexicographic order. The task is to return the indices of the first $k$ rows under this order.}
\varmapStart
\var{m,n}{Matrix dimensions.}
\var{A}{Input binary matrix with row-wise $1$'s followed by $0$'s.}
\var{s_i}{Soldier count in row $i$.}
\var{k}{Number of weakest rows to report.}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Row monotonicity:}\quad A_{i,j} \ge A_{i,j+1}\ \forall i,\ \forall j \in \{1,\ldots,n-1\}.\\
&\text{Soldier count:}\quad s_i = \sum_{j=1}^n A_{i,j}.\\
&\text{Weakness order:}\quad (i \prec j) \iff \big(s_i < s_j\big)\ \text{ or }\ \big(s_i = s_j \ \wedge\ i<j\big).\\
&\text{Output:}\quad \text{indices of the first } k \text{ rows in the order } \prec.
\end{aligned}
\]
}
\ASSUMPTIONS{Rows are valid binary and respect the $1$'s-then-$0$'s structure; $1 \le k \le m$; no ties beyond index ordering.}
\INVARIANTS{
\begin{bullets}
\item For each row $i$, $s_i$ equals the number of leading $1$'s (can be found by binary search).
\item Sorting by $(s_i,i)$ yields a total order compatible with the problem definition.
\item Selecting the $k$ smallest keys by a max-heap of size $k$ preserves the $k$ weakest rows.
\end{bullets}
}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute $s_i$ by direct summation per row and sort pairs $(s_i,i)$. Python's sort is stable and respects tie-breaking by including $i$ in the key.}
\ASSUMPTIONS{Constraints are small ($m,n \le 100$), so $O(mn + m\log m)$ is acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each row $i$, compute $s_i = \sum_j A_{i,j}$.
\item Form pairs $(s_i,i)$, sort ascending.
\item Return the first $k$ indices.
\end{algosteps}
\COMPLEXITY{$O(mn)$ to count soldiers plus $O(m\log m)$ to sort; space $O(m)$.}
\[
\begin{aligned}
T(m,n) &= O\big(mn\big) + O\big(m\log m\big),\\
S(m,n) &= O(m).
\end{aligned}
\]
\CORRECTNESS{Because rows are ordered by soldier count with index tie-break, sorting $(s_i,i)$ produces the exact weakness order. Taking the first $k$ yields the $k$ weakest.}
\EDGECASES{All rows equal; $k=1$; $k=m$; rows of all $1$'s or all $0$'s; multiple ties on $s_i$ resolved by smaller $i$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        pairs = []
        for i, row in enumerate(mat):
            cnt = sum(row)
            pairs.append((cnt, i))
        pairs.sort()
        return [i for _, i in pairs[:k]]

# Asserts (Baseline)
s = Solution()
assert s.kWeakestRows(
    [[1,1,0,0,0],
     [1,1,1,1,0],
     [1,0,0,0,0],
     [1,1,0,0,0],
     [1,1,1,1,1]], 3) == [2,0,3]
assert s.kWeakestRows(
    [[1,0,0,0],
     [1,1,1,1],
     [1,0,0,0],
     [1,0,0,0]], 2) == [0,2]
# Tie stability on equal counts (indices decide)
assert s.kWeakestRows([[1,0,0],[1,0,0],[1,0,0]], 2) == [0,1]
\end{minted}
\VALIDATION{Checked given samples; verified tie-breaking via indices; verified extreme with identical rows.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Counting with Binary Search}
\WHICHFORMULA{Use binary search per row to count leading $1$'s in $O(\log n)$ leveraging the monotone $1$'s-then-$0$'s structure; then select $k$ smallest using a heap-based partial selection.}
\ASSUMPTIONS{Each row is nonincreasing; binary search returns the first $0$ index which equals soldier count.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each row, binary search to find the count of $1$'s.
\item Build pairs $(s_i,i)$.
\item Use a partial selection (e.g., \texttt{heapq.nsmallest}) to extract the $k$ smallest by the pair.
\end{algosteps}
\COMPLEXITY{Counting improves to $O(m\log n)$; selection can be $O(m \log k)$; overall $O(m\log n + m\log k)$.}
\[
\begin{aligned}
T(m,n,k) &= O\big(m\log n\big) + O\big(m\log k\big),\\
S(m,n,k) &= O(m).
\end{aligned}
\]
\CORRECTNESS{Binary search yields exact $s_i$ due to row monotonicity; selecting the $k$ smallest by $(s_i,i)$ mirrors the definition.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def _count_ones(self, row: List[int]) -> int:
        lo, hi = 0, len(row)
        while lo < hi:
            mid = (lo + hi) // 2
            if row[mid] == 1:
                lo = mid + 1
            else:
                hi = mid
        return lo

    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        pairs = [(self._count_ones(row), i) for i, row in enumerate(mat)]
        smallest = heapq.nsmallest(k, pairs)  # by (count, index)
        return [i for _, i in smallest]

# Asserts (Improved)
s = Solution()
assert s.kWeakestRows(
    [[1,1,0,0,0],
     [1,1,1,1,0],
     [1,0,0,0,0],
     [1,1,0,0,0],
     [1,1,1,1,1]], 3) == [2,0,3]
assert s.kWeakestRows(
    [[1,0,0,0],
     [1,1,1,1],
     [1,0,0,0],
     [1,0,0,0]], 2) == [0,2]
# Edge: k == m
assert s.kWeakestRows([[1,1],[1,0],[0,0]], 3) == [2,1,0]
\end{minted}
\VALIDATION{Verified against samples and the case $k=m$; binary search correctness holds for all-zero and all-one rows.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Streaming Top-$k$ via Max-Heap of Size $k$}
\WHICHFORMULA{Maintain a max-heap (simulated with negated keys) of size $k$ keyed by $(s_i,i)$. For each row, push its key and pop when size exceeds $k$ so the heap retains the $k$ weakest rows.}
\ASSUMPTIONS{Row monotonicity allows $O(\log n)$ counting; heap comparisons over pairs correctly encode weakness and tie-breaking.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each row $i$, compute $s_i$ by binary search.
\item Push $(-s_i,-i)$ into a min-heap; if heap size exceeds $k$, pop once (removes the strongest among kept).
\item Convert heap entries to $(s_i,i)$, sort ascending, and output indices.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect all rows to distinguish weakness, yielding an $\Omega(m)$ lower bound. Counting each row in $O(\log n)$ is optimal under comparison, and selecting $k$ smallest in streaming with a size-$k$ heap is $O(m\log k)$, which is optimal for unordered input.}
\COMPLEXITY{$O(m\log n + m\log k)$ time, $O(k)$ heap space plus $O(1)$ auxiliary per row.}
\[
\begin{aligned}
T(m,n,k) &= \sum_{i=1}^{m} O(\log n) + \sum_{i=1}^{m} O(\log k) \;=\; O\big(m(\log n + \log k)\big).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def _count_ones(self, row: List[int]) -> int:
        lo, hi = 0, len(row)
        while lo < hi:
            mid = (lo + hi) // 2
            if row[mid] == 1:
                lo = mid + 1
            else:
                hi = mid
        return lo

    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        heap: List[tuple[int, int]] = []  # stores (-count, -index)
        for i, row in enumerate(mat):
            cnt = self._count_ones(row)
            heapq.heappush(heap, (-cnt, -i))
            if len(heap) > k:
                heapq.heappop(heap)
        items = [(-a, -b) for (a, b) in heap]
        items.sort()  # sort by (count, index) ascending
        return [i for _, i in items]

# Asserts (Final)
s = Solution()
assert s.kWeakestRows(
    [[1,1,0,0,0],
     [1,1,1,1,0],
     [1,0,0,0,0],
     [1,1,0,0,0],
     [1,1,1,1,1]], 3) == [2,0,3]
assert s.kWeakestRows(
    [[1,0,0,0],
     [1,1,1,1],
     [1,0,0,0],
     [1,0,0,0]], 2) == [0,2]
assert s.kWeakestRows([[0,0,0,0],[1,1,1,1],[1,1,0,0],[1,0,0,0]], 3) == [0,3,2]
\end{minted}
\VALIDATION{Three asserts: two official examples and a mixed-strength case covering all-zero and all-one rows.}
\RESULT{Returns a list of $k$ row indices sorted from weakest to strongest; ties by smaller index.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for samples; ties; extremes (all zeros, all ones); $k=1$ and $k=m$; random-free exhaustive checks on tiny matrices to cross-validate implementations.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (sort) and Approach C (heap) for all $m,n \le 3$ monotone rows; ensure identical lists.}
\LINE{EDGE-CASE GENERATOR}{Generate all valid monotone rows of length $n \le 3$ and all matrices of height $m \le 3$; iterate all $k \in [1,m]$.}
\begin{minted}{python}
from typing import List, Iterable, Tuple
import itertools
import heapq

def all_monotone_rows(n: int) -> List[List[int]]:
    # Rows of form [1]*t + [0]*(n-t)
    return [[1]*t + [0]*(n-t) for t in range(n+1)]

def generate_mats(m: int, n: int) -> Iterable[List[List[int]]]:
    rows = all_monotone_rows(n)
    for combo in itertools.product(rows, repeat=m):
        yield [list(r) for r in combo]

# Approach A (reference sort)
class A:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        pairs = [(sum(row), i) for i, row in enumerate(mat)]
        pairs.sort()
        return [i for _, i in pairs[:k]]

# Approach C (heap)
class C:
    def _count_ones(self, row: List[int]) -> int:
        lo, hi = 0, len(row)
        while lo < hi:
            mid = (lo + hi) // 2
            if row[mid] == 1:
                lo = mid + 1
            else:
                hi = mid
        return lo
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        heap: List[Tuple[int,int]] = []
        for i, row in enumerate(mat):
            cnt = self._count_ones(row)
            heapq.heappush(heap, (-cnt, -i))
            if len(heap) > k:
                heapq.heappop(heap)
        arr = [(-a, -b) for (a, b) in heap]
        arr.sort()
        return [i for _, i in arr]

def cross_check():
    for m in range(1, 4):
        for n in range(1, 4):
            for mat in generate_mats(m, n):
                for k in range(1, m+1):
                    ra = A().kWeakestRows(mat, k)
                    rc = C().kWeakestRows(mat, k)
                    assert ra == rc, (m, n, mat, k, ra, rc)

# Run cross-check and a few explicit tests
cross_check()
assert A().kWeakestRows([[1,1],[1,0],[0,0]], 3) == [2,1,0]
assert C().kWeakestRows([[1,1],[1,0],[0,0]], 1) == [2]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def _count_ones(self, row: List[int]) -> int:
        lo, hi = 0, len(row)
        while lo < hi:
            mid = (lo + hi) // 2
            if row[mid] == 1:
                lo = mid + 1
            else:
                hi = mid
        return lo

    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        heap: List[tuple[int, int]] = []
        for i, row in enumerate(mat):
            cnt = self._count_ones(row)
            heapq.heappush(heap, (-cnt, -i))
            if len(heap) > k:
                heapq.heappop(heap)
        items = [(-a, -b) for (a, b) in heap]
        items.sort()
        return [i for _, i in items]

# Self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.kWeakestRows(
        [[1,1,0,0,0],
         [1,1,1,1,0],
         [1,0,0,0,0],
         [1,1,0,0,0],
         [1,1,1,1,1]], 3) == [2,0,3]
    assert s.kWeakestRows(
        [[1,0,0,0],
         [1,1,1,1],
         [1,0,0,0],
         [1,0,0,0]], 2) == [0,2]
    assert s.kWeakestRows([[0,0,0],[1,1,1],[1,0,0]], 2) == [0,2]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Rank rows by soldier count; break ties by index; return the first $k$.}
\WHY{Common pattern: counting via binary search in monotone rows and selecting $k$ smallest via heaps or stable sort.}
\CHECKLIST{
\begin{bullets}
\item Compute $s_i$ correctly (do not miscount).
\item Encode key as $(s_i,i)$ so ties respect index.
\item Use binary search for $O(\log n)$ per row if $n$ is large.
\item For large $m$, use a size-$k$ heap to avoid full sort.
\item Return indices in ascending weakness order.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All rows identical.
\item Rows with all $1$'s or all $0$'s.
\item Multiple rows sharing the same soldier count.
\item $k=1$ and $k=m$.
\item Minimal sizes $m=2,n=2$.
\item Non-square matrices (e.g., $m \ne n$).
\item Very small $n$ (binary search base cases).
\item Already sorted vs. adversarial ordering.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting tie-break by index when counts equal.
\item Binary search off-by-one: returning first zero vs. last one.
\item Misusing heap sign convention; popping the wrong element.
\item Returning heap order without final sort to weakness order.
\item Using unstable sort without index in key.
\item Assuming row monotonicity without validating inputs.
\item Confusing $k$ indices with $k$ counts.
\item Not handling $k=m$ correctly.
\end{bullets}
}
\FAILMODES{Full sorting is fine here, but for larger $m$ a naive approach can be slower than a size-$k$ heap. Incorrect binary search or heap key inversion will produce wrong indices, especially under ties.}
\ELI{Count how many $1$'s are at the start of each row. Sort rows by this count and by their index. Take the first $k$ indices. A heap lets you keep only the $k$ weakest as you scan.}
\NotePages{3}

\end{document}