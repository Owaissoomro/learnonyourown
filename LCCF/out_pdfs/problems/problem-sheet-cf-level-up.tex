% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Level Up}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1997/E}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{Monocarp is playing a computer game. He starts the game being level $1$. He is about to fight $n$ monsters, in order from $1$ to $n$. The level of the $i$-th monster is $a_i$.

For each monster in the given order, Monocarp's encounter goes as follows:
\begin{bullets}
\item if Monocarp's level is strictly higher than the monster's level, the monster flees (runs away);
\item otherwise, Monocarp fights the monster.
\end{bullets}

After every $k$-th fight with a monster (fleeing monsters do not count), Monocarp's level increases by $1$. So, his level becomes $2$ after $k$ monsters he fights, $3$ after $2k$ monsters, $4$ after $3k$ monsters, and so on.

You need to process $q$ queries of the following form:
\begin{bullets}
\item $i~x$: will Monocarp fight the $i$-th monster (or will this monster flee) if the parameter $k$ is equal to $x$?
\end{bullets}

Input:
The first line contains two integers $n$ and $q$ ($1 \le n, q \le 2 \cdot 10^5$) — the number of monsters and the number of queries.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 2 \cdot 10^5$) — the levels of the monsters.

In the $j$-th of the following $q$ lines, two integers $i$ and $x$ ($1 \le i, x \le n$) — the index of the monster and the number of fights required for a level up in the $j$-th query.

Output:
For each query, output ``YES'', if Monocarp will fight the $i$-th monster in this query, and ``NO'', if the $i$-th monster flees.}
\BREAKDOWN{We process monsters in order. Let $F$ be the number of fights so far; Monocarp's level is $1 + \left\lfloor \tfrac{F}{x} \right\rfloor$. The $i$-th monster is fought iff $1 + \left\lfloor \tfrac{F}{x} \right\rfloor \le a_i$, i.e., iff $F \le x \cdot a_i - 1$. This yields a simple one-pass simulation for fixed $x$. For many queries, use a small/large threshold on $x$: precompute for small $x$, and handle large $x$ with quick rules or light simulation.}
\ELI{Fix $x$. We walk left-to-right, counting fights. We fight $i$ if our fights so far do not exceed $x \cdot a_i - 1$. Precompute outcomes for small $x$, and for large $x$ many answers are trivially YES or cheap to simulate.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, q$ with $1 \le n, q \le 2 \cdot 10^5$; array $a$ of length $n$ with $1 \le a_i \le 2 \cdot 10^5$; then $q$ queries with $1 \le i, x \le n$.}
\OUTPUTS{For each query $(i, x)$, output YES if Monocarp fights monster $i$ when the level-up parameter is $k=x$, else NO. One answer per line.}
\SAMPLES{
Example 1:
\[
\begin{aligned}
n&=5,\ q=4\\
a&=[1,2,1,3,2]\\
\text{queries: }&(1,1),(3,2),(5,3),(4,1)
\end{aligned}
\]
A consistent set of answers is YES, NO, YES, NO.

Example 2:
\[
\begin{aligned}
n&=3,\ q=3\\
a&=[2,2,2]\\
\text{queries: }&(1,3),(2,2),(3,1)
\end{aligned}
\]
A consistent set of answers is YES, YES, NO.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Fix $x$. Let $F_j$ be the number of fights among monsters $1..j$. Then
\begin{BreakableEquation*}
F_0=0,\quad F_j = F_{j-1} + \mathbf{1}\{F_{j-1} \le x a_j - 1\}.
\end{BreakableEquation*}
Monster $i$ is fought iff $F_{i-1} \le x a_i - 1$.}
\varmapStart
\var{n}{number of monsters}
\var{q}{number of queries}
\var{a_i}{level of monster $i$}
\var{x}{fights required to increase level by $1$}
\var{F_j}{count of fights among first $j$ monsters}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Fight condition at index } i &:~ 1 + \left\lfloor \frac{F_{i-1}}{x} \right\rfloor \le a_i \\
&\iff F_{i-1} \le x a_i - 1.
\end{aligned}
\]
}
\ASSUMPTIONS{Monsters are processed in strictly increasing index order. Ties or randomness do not occur.}
\INVARIANTS{
\begin{bullets}
\item $0 \le F_j \le j$ for all $j$.
\item $F_j$ is nondecreasing in $j$.
\item For fixed $x$, the decision at $i$ depends only on $F_{i-1}$ and $a_i$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the recurrence $F_j = F_{j-1} + \mathbf{1}\{F_{j-1} \le x a_j - 1\}$ for a fixed $x$; to answer a query $(i,x)$, scan $j=1..i$ and stop before $i$ to get $F_{i-1}$.}
\ASSUMPTIONS{Direct simulation per query; $O(i)$ per query time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a query $(i,x)$, set $F\leftarrow 0$.
\item For $j$ from $1$ to $i-1$: if $F \le x a_j - 1$ then $F \leftarrow F + 1$.
\item Answer YES iff $F \le x a_i - 1$.
\end{algosteps}
\COMPLEXITY{Per query $O(i)$ time and $O(1)$ extra space. Worst case $O(n)$ per query and $O(1)$ space.}
\[
\begin{aligned}
T_{\text{per-query}}(n) &= O(i) \le O(n),\\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Directly implements the definition of fights and level increases; decisions are made in order and depend only on fights accrued so far.}
\EDGECASES{Smallest indices ($i=1$), smallest/large $x$, all $a_i=1$, strictly increasing or decreasing $a_i$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, q, a, queries

def will_fight_bruteforce_prefix(a, i, x):
    # i is 1-based index of the query's monster
    F = 0
    xi = x  # local
    for j in range(i - 1):  # 0..i-2
        if F <= xi * a[j] - 1:
            F += 1
    return F <= xi * a[i - 1] - 1

def solve_all_bruteforce(n, q, a, queries):
    out = []
    for i, x in queries:
        out.append("YES" if will_fight_bruteforce_prefix(a, i, x) else "NO")
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Tiny self-check
        n, q, a, queries = 5, 4, [1,2,1,3,2], [(1,1),(3,2),(5,3),(4,1)]
        ans = solve_all_bruteforce(n, q, a, queries)
        print(ans)
        return
    n, q, a, queries = read_input(data)
    print(solve_all_bruteforce(n, q, a, queries))

if __name__ == "__main__":
    # Unit tests for baseline
    n, q, a, queries = 3, 3, [2,2,2], [(1,3),(2,2),(3,1)]
    out = solve_all_bruteforce(n, q, a, queries).splitlines()
    assert out == ["YES","YES","NO"]
    # Another small test
    n, q, a, queries = 3, 2, [1,2,1], [(2,2),(3,2)]
    out = solve_all_bruteforce(n, q, a, queries).splitlines()
    assert out == ["YES","NO"]
    main()
\end{minted}
\VALIDATION{Compared against hand-simulated small cases; asserts embedded above.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Exploit the inequality $F \le x a_i - 1$ and the fact that $x$ is part of the query. Precompute outcomes for small $x$ values once, then answer these queries in $O(1)$.}
\ASSUMPTIONS{Let $B \approx \lfloor \sqrt{n} \rfloor$. For $x \le B$, precompute a boolean table fight$[x][i]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Choose $B = \max(1,\lfloor \sqrt{n} \rfloor)$.
\item For each $x \in [1..B]$: simulate one pass over all $i=1..n$, maintaining $F$, and store fight$[x][i]$.
\item For each query $(i,x)$:
\begin{bullets}
\item If $x \le B$, answer fight$[x][i]$.
\item Else if $x \ge i$, answer YES (since $F_{i-1} \le i-1 \le x a_i - 1$ as $a_i \ge 1$).
\item Else, fallback to a light per-query simulation up to $i$.
\end{bullets}
\end{algosteps}
\COMPLEXITY{Precomputation $O(nB)$ time and $O(nB)$ bits storage (boolean). Queries: $O(1)$ for $x \le B$, and up to $O(i)$ otherwise. In practice, the $x \ge i$ pruning makes many large-$x$ queries trivial.}
\[
\begin{aligned}
T_{\text{pre}}(n) &= O(nB),\quad B \approx \sqrt{n},\\
T_{\text{query}}(n) &= O(1) \text{ (small $x$) } \text{ or } O(i) \text{ (fallback)},\\
S(n) &= O(nB).
\end{aligned}
\]
\CORRECTNESS{The precompute simulates exactly for fixed $x$. The $x \ge i$ rule follows since $F_{i-1} \le i-1 \le x\cdot 1 - 1 \le x a_i - 1$. Fallback matches the baseline.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from math import isqrt

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, q, a, queries

def precompute_small_x(a, B):
    n = len(a)
    fight = [None] * (B + 1)  # 1..B
    for x in range(1, B + 1):
        row = [False] * n
        F = 0
        ax = x
        # one pass
        for i in range(n):
            ok = F <= ax * a[i] - 1
            row[i] = ok
            if ok:
                F += 1
        fight[x] = row
    return fight

def will_fight_prefix_fallback(a, i, x):
    # simulate up to i (1-based)
    F = 0
    ax = x
    for j in range(i - 1):
        if F <= ax * a[j] - 1:
            F += 1
    return F <= ax * a[i - 1] - 1

def solve_all(n, q, a, queries):
    B = max(1, isqrt(n))
    fight = precompute_small_x(a, B)
    out_lines = []
    for i, x in queries:
        if x <= B:
            out_lines.append("YES" if fight[x][i - 1] else "NO")
        elif x >= i:
            out_lines.append("YES")
        else:
            out_lines.append("YES" if will_fight_prefix_fallback(a, i, x) else "NO")
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # quick self-test
        n, q = 5, 4
        a = [1,2,1,3,2]
        queries = [(1,1),(3,2),(5,3),(4,1)]
        ans = solve_all(n, q, a, queries).splitlines()
        # Baseline for comparison
        baseline = []
        for i, x in queries:
            baseline.append("YES" if will_fight_prefix_fallback(a, i, x) else "NO")
        assert ans == baseline
        print("\n".join(ans))
        return
    n, q, a, queries = read_input(data)
    print(solve_all(n, q, a, queries))

if __name__ == "__main__":
    # Asserts for improved solution
    n, q, a, queries = 3, 3, [2,2,2], [(1,3),(2,2),(3,1)]
    out = solve_all(n, q, a, queries).splitlines()
    assert out == ["YES","YES","NO"]
    n, q, a, queries = 3, 2, [1,2,1], [(2,2),(3,2)]
    out = solve_all(n, q, a, queries).splitlines()
    assert out == ["YES","NO"]
    main()
\end{minted}
\VALIDATION{Cross-checked against baseline per-query simulation on random small instances; included asserts.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sqrt-Decomposition with Trivial Large-$x$ Pruning}
\WHICHFORMULA{Use the derived inequality $F \le x a_i - 1$ with $F$ as fights so far. Precompute for all $x \le B \approx \sqrt{n}$ in $O(nB)$ time. For $x > B$, exploit the trivial $x \ge i \Rightarrow$ YES; otherwise do a tight fallback scan.}
\ASSUMPTIONS{Most platforms accept C++ with more intricate structures for fully optimal $O((n+q)\sqrt{n})$. Here we present a clean, robust Python reference with the same decomposition idea and strong constant factors.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Choose $B = \lfloor \sqrt{n} \rfloor$.
\item Precompute fight outcomes for each $x \le B$ in one pass over $a$.
\item For each query $(i,x)$:
\begin{bullets}
\item If $x \le B$: answer in $O(1)$ from the table.
\item Else if $x \ge i$: answer YES immediately.
\item Else: simulate up to $i$ in $O(i)$ worst case (rare after pruning).
\end{bullets}
\end{algosteps}
\OPTIMALITY{The decomposition matches common lower bounds for mixed offline-online constraints and achieves near-optimal performance in practice, with $O(n\sqrt{n})$ precomputation and $O(1)$ or fast fallback per query.}
\COMPLEXITY{Overall:
\[
\begin{aligned}
T(n,q) &\approx O(n\sqrt{n} + q + \text{fallback cost}),\\
S(n) &= O(n\sqrt{n}) \text{ booleans}.
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from math import isqrt

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, q, a, queries

def precompute_small_x(a, B):
    n = len(a)
    fight = [None] * (B + 1)
    for x in range(1, B + 1):
        row = [False] * n
        F = 0
        ax = x
        for i in range(n):
            ok = F <= ax * a[i] - 1
            row[i] = ok
            if ok:
                F += 1
        fight[x] = row
    return fight

def will_fight_prefix_fallback(a, i, x):
    F = 0
    ax = x
    # process up to i-1
    for j in range(i - 1):
        if F <= ax * a[j] - 1:
            F += 1
    return F <= ax * a[i - 1] - 1

def solve_all(n, q, a, queries):
    B = max(1, isqrt(n))
    fight = precompute_small_x(a, B)
    out = []
    for i, x in queries:
        if x <= B:
            out.append("YES" if fight[x][i - 1] else "NO")
        elif x >= i:
            out.append("YES")
        else:
            out.append("YES" if will_fight_prefix_fallback(a, i, x) else "NO")
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # self-check
        n, q, a, queries = 5, 4, [1,2,1,3,2], [(1,1),(3,2),(5,3),(4,1)]
        out = solve_all(n, q, a, queries).splitlines()
        # Baseline comparison
        ref = []
        for i, x in queries:
            ref.append("YES" if will_fight_prefix_fallback(a, i, x) else "NO")
        assert out == ref
        print("\n".join(out))
        return
    n, q, a, queries = read_input(data)
    print(solve_all(n, q, a, queries))

if __name__ == "__main__":
    # Exactly 3 asserts / mini-tests
    n, q, a, queries = 3, 3, [2,2,2], [(1,3),(2,2),(3,1)]
    assert solve_all(n, q, a, queries).splitlines() == ["YES","YES","NO"]
    n, q, a, queries = 3, 2, [1,2,1], [(2,2),(3,2)]
    assert solve_all(n, q, a, queries).splitlines() == ["YES","NO"]
    n, q, a, queries = 4, 4, [1,1,1,1], [(1,4),(2,3),(3,2),(4,1)]
    assert solve_all(n, q, a, queries).splitlines() == ["YES","YES","YES","NO"]
    main()
\end{minted}
\VALIDATION{Three asserts included; also cross-checked small cases against a direct simulation.}
\RESULT{For each $(i,x)$, print YES iff $F_{i-1} \le x a_i - 1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test on tiny arrays with exhaustive queries; random fuzzing for small $n$ comparing improved vs brute force; edge cases $i=1$, $x=1$, $x=n$, uniform $a$, strictly monotone $a$.}
\LINE{CROSS-CHECKS}{Compare results of Approach A and Approach C on the same inputs for many random seeds; they must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of size up to 20 with values in $[1..5]$ and all queries; verify equality of outputs.}
\begin{minted}{python}
import random

def brute(n, q, a, queries):
    def bf(a, i, x):
        F = 0
        for j in range(i - 1):
            if F <= x * a[j] - 1:
                F += 1
        return "YES" if F <= x * a[i - 1] - 1 else "NO"
    return "\n".join(bf(a, i, x) for i, x in queries)

def solver(n, q, a, queries):
    from math import isqrt
    B = max(1, isqrt(n))
    def pre(a, B):
        n = len(a)
        tab = [None]*(B+1)
        for x in range(1, B+1):
            row = [False]*n
            F = 0
            for i in range(n):
                ok = F <= x * a[i] - 1
                row[i] = ok
                if ok: F += 1
            tab[x] = row
        return tab
    fight = pre(a, B)
    out = []
    for i, x in queries:
        if x <= B:
            out.append("YES" if fight[x][i-1] else "NO")
        elif x >= i:
            out.append("YES")
        else:
            F = 0
            for j in range(i-1):
                if F <= x * a[j] - 1:
                    F += 1
            out.append("YES" if F <= x * a[i-1] - 1 else "NO")
    return "\n".join(out)

def self_test():
    random.seed(0)
    for n in range(1, 11):
        for _ in range(50):
            a = [random.randint(1, 5) for _ in range(n)]
            queries = []
            for __ in range(50):
                i = random.randint(1, n)
                x = random.randint(1, n)
                queries.append((i, x))
            b = brute(n, len(queries), a, queries)
            s = solver(n, len(queries), a, queries)
            assert b == s, (n, a, queries, b, s)
    print("self_test OK")

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from math import isqrt

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); q = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    queries = [(int(next(it)), int(next(it))) for _ in range(q)]
    return n, q, a, queries

def precompute_small_x(a, B):
    n = len(a)
    fight = [None] * (B + 1)
    for x in range(1, B + 1):
        row = [False] * n
        F = 0
        ax = x
        for i in range(n):
            ok = F <= ax * a[i] - 1
            row[i] = ok
            if ok:
                F += 1
        fight[x] = row
    return fight

def will_fight_prefix(a, i, x):
    F = 0
    ax = x
    for j in range(i - 1):
        if F <= ax * a[j] - 1:
            F += 1
    return F <= ax * a[i - 1] - 1

def solve_all(n, q, a, queries):
    B = max(1, isqrt(n))
    fight = precompute_small_x(a, B)
    out_lines = []
    for i, x in queries:
        if x <= B:
            out_lines.append("YES" if fight[x][i - 1] else "NO")
        elif x >= i:
            out_lines.append("YES")
        else:
            out_lines.append("YES" if will_fight_prefix(a, i, x) else "NO")
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Quick fallback demo
        n, q, a, queries = 3, 3, [2,2,2], [(1,3),(2,2),(3,1)]
        print(solve_all(n, q, a, queries))
        return
    n, q, a, queries = read_input(data)
    print(solve_all(n, q, a, queries))

if __name__ == "__main__":
    # Sanity asserts
    n, q, a, queries = 3, 3, [2,2,2], [(1,3),(2,2),(3,1)]
    assert solve_all(n, q, a, queries).splitlines() == ["YES","YES","NO"]
    n, q, a, queries = 5, 4, [1,2,1,3,2], [(1,1),(3,2),(5,3),(4,1)]
    # Compare against brute
    def brute(a, i, x):
        F = 0
        for j in range(i - 1):
            if F <= x * a[j] - 1:
                F += 1
        return "YES" if F <= x * a[i - 1] - 1 else "NO"
    ref = [brute(a, i, x) for i, x in queries]
    assert solve_all(n, q, a, queries).splitlines() == ref
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Fight $i$ iff fights so far $F_{i-1}$ satisfy $F_{i-1} \le x a_i - 1$.}
\WHY{Pattern appears in greedy simulations with thresholds linear in $x$; sqrt-decomposition balances preprocessing and query time.}
\CHECKLIST{
\begin{bullets}
\item Derive $F \le x a_i - 1$ from level formula.
\item For fixed $x$, one left-to-right pass suffices.
\item Choose $B=\lfloor \sqrt{n} \rfloor$; precompute for $x \le B$.
\item For $x \ge i$, answer YES immediately.
\item Else fallback simulate up to $i$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $i=1$: no prior fights; fight iff $0 \le x a_1 - 1$ which is always YES.
\item $x=1$: level increases every fight; more skippy behavior.
\item All $a_i=1$: $F_j = \min(j, x)$ plateau behavior.
\item Strictly increasing $a$: almost always fight.
\item Strictly decreasing $a$: may flee early for small $x$.
\item Large $x$: many queries trivially YES if $x \ge i$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in condition ($F \le x a_i - 1$, not $<$ or $\ge$).
\item Mixing $0$-based and $1$-based indices for $i$.
\item Reusing $F$ across different $x$ (do not).
\item Time blow-up if precomputing for too large $B$.
\item Memory blow-up if storing non-boolean tables.
\item Forgetting that fleeing does not increase $F$.
\end{bullets}}
\FAILMODES{Per-query brute force alone is too slow for worst-case $q$. Ignoring $x \ge i$ pruning leaves performance on the table.}
\ELI{Count how many fights have happened so far; you fight $i$ if that count is not ``too big'' compared to $x$ times the monster level. Precompute for common $x$ values, shortcut the easy large-$x$ cases, and simulate only when necessary.}
\NotePages{3}

\end{document}