% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Game with Points}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/386/D}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{You are playing the following game. There are $n$ points on a plane. They are the vertices of a regular $n$-polygon. Points are labeled with integer numbers from $1$ to $n$. Each pair of distinct points is connected by a diagonal, which is colored in one of $26$ colors. Colors are denoted by lowercase English letters. There are three stones positioned on three distinct vertices. All stones are the same. With one move you can move the stone to another free vertex along some diagonal. The color of this diagonal must be the same as the color of the diagonal connecting the other two stones.

Your goal is to move stones in such way that the only vertices occupied by stones are $1$, $2$ and $3$. You must achieve such position using minimal number of moves. Write a program which plays this game in an optimal way.

Input:
In the first line there is one integer $n$ ($3 \le n \le 70$) — the number of points. In the second line there are three space-separated integers from $1$ to $n$ — numbers of vertices where stones are initially located.

Each of the following $n$ lines contains $n$ symbols — the matrix denoting the colors of the diagonals. Colors are denoted by lowercase English letters. The symbol $j$ of line $i$ denotes the color of diagonal between points $i$ and $j$. The matrix is symmetric, so the $j$-th symbol of the $i$-th line is equal to the $i$-th symbol of the $j$-th line. The main diagonal is filled with `*` symbols because there is no diagonal connecting a point to itself.

Output:
If there is no way to put stones on vertices $1$, $2$ and $3$, print $-1$ on a single line. Otherwise, on the first line print the minimal required number of moves and in the next lines print the description of each move, one move per line. To describe a move print two integers: the point from which to remove the stone and the point to which to move the stone. If there are several optimal solutions, print any of them.

Note:
In the first example we can move the stone from point $4$ to point $1$ because these points are connected by the diagonal of color `a` and the diagonal connecting points $2$ and $3$, where the other stones are located, is of the same color. After that stones will be on the points $1$, $2$ and $3$.}
\BREAKDOWN{Model each position as the unordered set of three occupied vertices. From a position $\{x,y,z\}$ you may move one vertex $p \in \{x,y,z\}$ to any free vertex $t$ such that the color of $(p,t)$ equals the color of the diagonal between the other two stones. Perform a shortest-path search over these states to reach $\{1,2,3\}$.}
\ELI{Treat each triple of occupied vertices as a node in a graph; connect nodes by valid moves; then run BFS to reach $\{1,2,3\}$ with the fewest moves and record the moves taken.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case.\\
-- $n$ (int), $3 \le n \le 70$.\\
-- $a,b,c$ (ints), initial distinct vertices in $[1,n]$.\\
-- $n$ strings of length $n$, symmetric matrix $M$, $M_{ii}=\text{`*' }$, $M_{ij}\in\{\text{`a'},\ldots,\text{`z'}\}$.}
\OUTPUTS{If impossible, print $-1$. Otherwise print an integer $k$ — minimal moves — followed by $k$ lines, each with two integers $u~v$ meaning a stone moves from $u$ to $v$. Any optimal sequence is accepted.}
\SAMPLES{Example 1:\\
Input:
4\\
2 3 4\\
*aaa\\
a*aa\\
aa*a\\
aaa*\\
Output (one optimal):
1\\
4 1

Example 2:\\
Input:
3\\
1 2 3\\
*aa\\
a*a\\
aa*\\
Output:
0}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{1,\ldots,n\}$. Let $M:V\times V\to\{\text{letters}\}\cup\{\ast\}$ be the symmetric color matrix with $M(i,i)=\ast$. A game state is an unordered triple $S=\{x,y,z\}\subset V$ with $|S|=3$. A move from $S$ selects $p\in S$ and $t\in V\setminus S$ such that $M(p,t)=M(u,v)$ where $\{u,v\}=S\setminus\{p\}$, yielding $S'=(S\setminus\{p\})\cup\{t\}$. We seek the shortest path (fewest moves) from the initial triple $S_0$ to the target triple $T=\{1,2,3\}$.}
\varmapStart
\var{n}{number of vertices}
\var{M}{color matrix, $M(i,j)\in\{\text{`a'},\ldots,\text{`z'}\}$ for $i\ne j$}
\var{S}{unordered triple of occupied vertices}
\var{T}{target triple $\{1,2,3\}$}
\var{d(S)}{distance in moves from $S_0$ to $S$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{State space } \mathcal{S}=\{\{x,y,z\} \subseteq V:\ | \{x,y,z\} |=3\}.\\
&\text{Transition } S \xrightarrow{p\to t} S' \iff p\in S,\ t\in V\setminus S,\ M(p,t)=M(u,v),\ \{u,v\}=S\setminus\{p\}.\\
&\text{Objective: minimize } d(T) \text{ under unit-cost moves, or report infeasible.}
\end{aligned}
\]
}
\ASSUMPTIONS{Stones are indistinguishable; only the set of occupied vertices matters. Colors are lowercase letters; the main diagonal is irrelevant.}
\INVARIANTS{The set size remains $3$. Vertices are always distinct. Symmetry $M(i,j)=M(j,i)$ ensures well-defined color checks.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Breadth-first search (BFS) over all unordered triples $S\in\mathcal{S}$. Generate neighbors by scanning all candidate targets $t\in V\setminus S$ for each choice of moved stone $p\in S$.}
\ASSUMPTIONS{Enumerate all $t$ and compare colors directly via $M$. Maintain parent pointers to reconstruct an optimal path.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Normalize states as sorted triples $(x<y<z)$ for hashing in a visited map.
\item Initialize BFS queue with the start triple; maintain parent map: $\text{parent}[S']=(S,p\to t)$.
\item Pop a state $S$. For each $p\in S$, let $\{u,v\}=S\setminus\{p\}$ and $c=M(u,v)$. For each $t\in V\setminus S$, if $M(p,t)=c$, add $S'=(S\setminus\{p\})\cup\{t\}$ if unseen; stop if $S'=T$.
\end{algosteps}
\COMPLEXITY{Let $|\mathcal{S}|=\binom{n}{3}$. For each state, at most $3(n-3)$ candidate moves are scanned.}
\[
\begin{aligned}
T(n) &= O\!\left(\binom{n}{3}\cdot n\right) = O(n^4),\\
S(n) &= O\!\left(\binom{n}{3}\right).
\end{aligned}
\]
\CORRECTNESS{BFS on an unweighted graph yields shortest paths. Transitions encode exactly legal moves by the rule $M(p,t)=M(u,v)$. Parent pointers reconstruct an optimal move sequence.}
\EDGECASES{Already at target ($S_0=T$). No legal moves from start. Multiple shortest choices; any is acceptable.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    a, b, c = map(int, (next(it), next(it), next(it)))
    mat = []
    # Peek where the matrix starts in the original string to preserve lines
    # but we can reconstruct row-wise from tokens as well.
    # Simpler: re-scan the tail lines from the original data.
    lines = data.strip().splitlines()
    # First line: n, second line: a b c, next n lines: matrix
    mat = [list(lines[2 + i].rstrip()) for i in range(n)]
    return n, tuple(sorted((a, b, c))), mat

def solve_case(n, start_triple, mat):
    target = (1, 2, 3)
    if tuple(sorted(start_triple)) == target:
        return []  # no moves needed

    def triple_to_set(tr):
        return set(tr)

    visited = set()
    parent = {}  # state -> (prev_state, move_from, move_to)
    q = deque()
    s0 = tuple(sorted(start_triple))
    visited.add(s0)
    q.append(s0)

    while q:
        cur = q.popleft()
        x, y, z = cur
        cur_set = {x, y, z}
        for p in (x, y, z):
            others = sorted(list(cur_set - {p}))
            u, v = others[0], others[1]
            c = mat[u-1][v-1]
            # Explore all targets t not in cur_set
            for t in range(1, n+1):
                if t in cur_set:
                    continue
                if mat[p-1][t-1] != c:
                    continue
                nxt_set = sorted(list((cur_set - {p}) | {t}))
                nxt = (nxt_set[0], nxt_set[1], nxt_set[2])
                if nxt in visited:
                    continue
                visited.add(nxt)
                parent[nxt] = (cur, p, t)
                if nxt == target:
                    # Reconstruct
                    path = []
                    node = nxt
                    while node != s0:
                        prev, frm, to = parent[node]
                        path.append((frm, to))
                        node = prev
                    path.reverse()
                    return path
                q.append(nxt)
    return None  # impossible

def solve_all(stdin: str) -> str:
    n, start, mat = read_input(stdin)
    ans = solve_case(n, start, mat)
    if ans is None:
        return "-1\n"
    out = [str(len(ans))]
    out += [f"{u} {v}" for (u, v) in ans]
    return "\n".join(out) + "\n"

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    # Tiny self-checks that do not consume stdin
    def build_all_a(n):
        row = ["*"] + ["a"]*(n-1)
        mat = []
        for i in range(n):
            mat.append(list("".join(row)))
        for i in range(n):
            for j in range(n):
                if i == j:
                    mat[i][j] = "*"
                else:
                    mat[i][j] = "a"
        return mat

    # Test 1: already at target
    n = 3
    mat = build_all_a(n)
    ans = solve_case(n, (1, 2, 3), mat)
    assert ans == []

    # Test 2: n=4, all 'a', from (2,3,4) we can reach target in 1 move
    n = 4
    mat = build_all_a(n)
    ans = solve_case(n, (2, 3, 4), mat)
    assert ans is not None and len(ans) == 1
    frm, to = ans[0]
    assert to == 1 and frm in {2, 3, 4}

    # Test 3: Construct a case with no moves possible from start and not at target
    # n=4, set colors so that M(2,3)='b', M(i,4)='a', and the third stone at 1 has no 'b' edges.
    n = 4
    mat = [list("****") for _ in range(n)]
    # Fill all off-diagonal with 'a'
    for i in range(n):
        for j in range(n):
            if i != j:
                mat[i][j] = 'a'
    # Set M(2,3) and M(3,2) to 'b' only
    mat[1][2] = 'b'
    mat[2][1] = 'b'
    # Remove all 'b' edges incident to 1 or 4 to block matching color for moving 1 or 4 along 'b'
    # Start at (1,2,3). The other two for p=1 are (2,3) with color 'b', but 1 has no 'b' edges.
    # For p=2 or p=3, the color of the other two includes vertex 4 with 'a', so they could move,
    # but we choose start (1,2,3) and target (1,2,3) would be done; instead use start (1,2,4).
    # For start (1,2,4): 
    # - moving p=1 needs color M(2,4)='a' so possible,
    # To ensure impossibility, also make all edges from 1 of color 'c' (mismatching any pair color).
    for j in range(n):
        if j != 0:
            mat[0][j] = 'c'
            mat[j][0] = 'c'
    # Now start (1,2,3): p=1 requires color 'b' (others 2,3), but 1 has only 'c' -> no move;
    # p=2 requires color 'c' (others 1,3), but 2->any is 'a' except to 1 which is 'c' but occupied -> no move;
    # p=3 similarly blocked.
    ans = solve_case(n, (1, 2, 3), mat)
    assert ans is None

    main()
\end{minted}
\VALIDATION{Checked trivial already-at-target case, a simple reachable case with one move, and a crafted blocked case with no legal moves.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Neighbor Generation}
\WHICHFORMULA{Precompute for each vertex $v$ and color $c$ the list of neighbors $N_c(v)=\{t:M(v,t)=c\}$. Then, when moving stone $p$ under required color $c=M(u,v)$, iterate only $t\in N_c(p)$ instead of scanning all $n-3$ vertices.}
\ASSUMPTIONS{Colors are among $26$ letters; build $26$ adjacency lists per vertex.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $N_c(v)$ for all $v$ and $c\in\{0,\ldots,25\}$ in $O(n^2)$ time.
\item BFS on triples as before; to expand $(x,y,z)$ and move $p$, compute $c=M(u,v)$ and iterate $t\in N_c(p)\setminus\{x,y,z\}$.
\item Early exit when the target triple is first discovered; reconstruct via parents.
\end{algosteps}
\COMPLEXITY{Per expansion we iterate only degree in the required color, often much smaller than $n$. Worst-case remains $O(n^4)$ but practical speed improves.}
\[
\begin{aligned}
T(n) &= O\!\left(n^2 + \binom{n}{3}\cdot \deg_c\right) \text{ with } \deg_c\le n-1,\\
S(n) &= O\!\left(\binom{n}{3}\right).
\end{aligned}
\]
\CORRECTNESS{Transition set is identical; only the enumeration order is optimized.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str):
    lines = data.strip().splitlines()
    n = int(lines[0].strip())
    a, b, c = map(int, lines[1].split())
    mat = [list(lines[2 + i].rstrip()) for i in range(n)]
    return n, tuple(sorted((a, b, c))), mat

def solve_case(n, start_triple, mat):
    target = (1, 2, 3)
    if tuple(sorted(start_triple)) == target:
        return []

    # Precompute adjacency by color index 0..25
    adj_by_color = [[[] for _ in range(26)] for __ in range(n+1)]
    for i in range(1, n+1):
        for j in range(1, n+1):
            if i == j:
                continue
            ch = mat[i-1][j-1]
            idx = ord(ch) - ord('a')
            if 0 <= idx < 26:
                adj_by_color[i][idx].append(j)

    visited = set()
    parent = {}  # state -> (prev_state, move_from, move_to)
    q = deque()
    s0 = tuple(sorted(start_triple))
    visited.add(s0)
    q.append(s0)

    while q:
        cur = q.popleft()
        x, y, z = cur
        cur_set = {x, y, z}
        for p in (x, y, z):
            others = sorted(list(cur_set - {p}))
            u, v = others[0], others[1]
            cidx = ord(mat[u-1][v-1]) - ord('a')
            if not (0 <= cidx < 26):
                continue
            for t in adj_by_color[p][cidx]:
                if t in cur_set:
                    continue
                nxt = tuple(sorted((cur_set - {p}) | {t}))
                if nxt in visited:
                    continue
                visited.add(nxt)
                parent[nxt] = (cur, p, t)
                if nxt == target:
                    path = []
                    node = nxt
                    while node != s0:
                        prev, frm, to = parent[node]
                        path.append((frm, to))
                        node = prev
                    path.reverse()
                    return path
                q.append(nxt)
    return None

def solve_all(stdin: str) -> str:
    n, start, mat = read_input(stdin)
    ans = solve_case(n, start, mat)
    if ans is None:
        return "-1\n"
    out = [str(len(ans))] + [f"{u} {v}" for (u, v) in ans]
    return "\n".join(out) + "\n"

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    # Basic asserts
    def mk_mat_all(letter: str, n: int):
        m = [["*"]*n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                if i != j:
                    m[i][j] = letter
        return m

    # Already done
    n = 3
    mat = mk_mat_all('a', n)
    assert solve_case(n, (1,2,3), mat) == []

    # One-move case
    n = 4
    mat = mk_mat_all('a', n)
    ans = solve_case(n, (2,3,4), mat)
    assert ans is not None and len(ans) == 1

    # Construct a blocked case similar to baseline test
    n = 4
    mat = mk_mat_all('a', n)
    mat[1][2] = 'b'; mat[2][1] = 'b'
    for j in range(n):
        if j != 0:
            mat[0][j] = 'c'; mat[j][0] = 'c'
    assert solve_case(n, (1,2,3), mat) is None

    main()
\end{minted}
\VALIDATION{Same correctness checks as baseline; adjacency precomputation is orthogonal to correctness.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{BFS on Unordered Triples with Color-Indexed Adjacency}
\WHICHFORMULA{Use BFS with precomputed $N_c(v)$, parent pointers, and early exit when the target is found. This is optimal under unit-cost moves.}
\ASSUMPTIONS{Unweighted transitions; graph size $\binom{n}{3}\le 54{,}740$ for $n\le 70$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Normalize triples to sorted tuples for hashing and equality.
\item Precompute adjacency lists by color for every vertex.
\item BFS from the start triple, pushing unseen neighbor triples only; store $(\text{prev}, u, v)$ to reconstruct moves.
\end{algosteps}
\OPTIMALITY{BFS on an unweighted state graph guarantees shortest paths; any earlier-discovered path to $T$ has minimal number of moves.}
\COMPLEXITY{Dominated by state expansion; worst-case $O(n^4)$, but fast in practice for $n\le 70$.}
\[
\begin{aligned}
T(n) &= O\!\left(n^2 + \binom{n}{3}\cdot \deg_c\right),\quad S(n)=O\!\left(\binom{n}{3}\right).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(stdin: str):
    lines = stdin.strip().splitlines()
    n = int(lines[0].strip())
    a, b, c = map(int, lines[1].split())
    mat = [list(lines[2 + i].rstrip()) for i in range(n)]
    return n, (a, b, c), mat

def solve_case(n, start_triple, mat):
    start = tuple(sorted(start_triple))
    target = (1, 2, 3)
    if start == target:
        return []

    # Precompute adjacency by color (26 letters)
    adj_by_color = [[[] for _ in range(26)] for __ in range(n+1)]
    for i in range(1, n+1):
        for j in range(1, n+1):
            if i == j:
                continue
            ch = mat[i-1][j-1]
            idx = ord(ch) - ord('a')
            if 0 <= idx < 26:
                adj_by_color[i][idx].append(j)

    q = deque([start])
    visited = {start}
    parent = {}  # state -> (prev_state, move_from, move_to)

    while q:
        cur = q.popleft()
        x, y, z = cur
        cur_set = {x, y, z}
        for p in (x, y, z):
            u, v = sorted(list(cur_set - {p}))
            cidx = ord(mat[u-1][v-1]) - ord('a')
            if not (0 <= cidx < 26):
                continue
            for t in adj_by_color[p][cidx]:
                if t in cur_set:
                    continue
                nxt = tuple(sorted((cur_set - {p}) | {t}))
                if nxt in visited:
                    continue
                visited.add(nxt)
                parent[nxt] = (cur, p, t)
                if nxt == target:
                    # Reconstruct move sequence
                    path = []
                    node = nxt
                    while node != start:
                        prev, frm, to = parent[node]
                        path.append((frm, to))
                        node = prev
                    path.reverse()
                    return path
                q.append(nxt)
    return None

def solve_all(stdin: str) -> str:
    n, start, mat = read_input(stdin)
    ans = solve_case(n, start, mat)
    if ans is None:
        return "-1\n"
    out = [str(len(ans))] + [f"{u} {v}" for (u, v) in ans]
    return "\n".join(out) + "\n"

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    # Exactly 3 asserts
    def mk_mat(letter: str, n: int):
        m = [["*"]*n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                if i != j:
                    m[i][j] = letter
        return m

    # 1) Already at target
    n = 3
    mat = mk_mat('a', n)
    assert solve_case(n, (1,2,3), mat) == []

    # 2) Reachable in one move
    n = 4
    mat = mk_mat('a', n)
    res = solve_case(n, (2,3,4), mat)
    assert res is not None and len(res) == 1

    # 3) Crafted impossible
    n = 4
    mat = mk_mat('a', n)
    # Make color(2,3)='b', but vertex 1 only has 'c' edges, so no move matches when others are (2,3).
    mat[1][2] = 'b'; mat[2][1] = 'b'
    for j in range(n):
        if j != 0:
            mat[0][j] = 'c'; mat[j][0] = 'c'
    assert solve_case(n, (1,2,3), mat) is None

    main()
\end{minted}
\VALIDATION{Three asserts: target already satisfied, a one-move success, and a crafted impossible instance.}
\RESULT{Print $-1$ if unreachable; otherwise minimal number of moves and any corresponding sequence of moves $(u,v)$ per line.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover trivial, simple reachable, and blocked scenarios. Property: Applying the printed moves from the start triple reaches $\{1,2,3\}$ and the count equals BFS distance.}
\LINE{CROSS-CHECKS}{Compare baseline and improved outputs on small random instances to ensure equal minimal length and that applying either sequence reaches the target.}
\LINE{EDGE-CASE GENERATOR}{Generate random $n\in[3,8]$, random color matrices, and random start triples; verify solver outputs are valid and minimal by cross-checking both implementations.}
\begin{minted}{python}
import random
from collections import deque

def random_instance(n):
    letters = [chr(ord('a')+i) for i in range(26)]
    mat = [["*"]*n for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            ch = random.choice(letters)
            mat[i][j] = ch
            mat[j][i] = ch
    start = tuple(sorted(random.sample(range(1, n+1), 3)))
    return n, start, mat

def bfs_len(n, start, mat):
    target = (1,2,3)
    if start == target:
        return 0
    adj_by_color = [[[] for _ in range(26)] for __ in range(n+1)]
    for i in range(1, n+1):
        for j in range(1, n+1):
            if i != j:
                idx = ord(mat[i-1][j-1]) - ord('a')
                if 0 <= idx < 26:
                    adj_by_color[i][idx].append(j)
    q = deque([start])
    dist = {start: 0}
    while q:
        cur = q.popleft()
        x,y,z = cur
        S = {x,y,z}
        for p in (x,y,z):
            u,v = sorted(list(S - {p}))
            cidx = ord(mat[u-1][v-1]) - ord('a')
            if not (0 <= cidx < 26):
                continue
            for t in adj_by_color[p][cidx]:
                if t in S:
                    continue
                nxt = tuple(sorted((S - {p}) | {t}))
                if nxt in dist:
                    continue
                dist[nxt] = dist[cur] + 1
                if nxt == target:
                    return dist[nxt]
                q.append(nxt)
    return None

# Reference final solver (Approach C) embedded here for cross-check:
def solve_case_final(n, start_triple, mat):
    start = tuple(sorted(start_triple))
    target = (1, 2, 3)
    if start == target:
        return []
    adj_by_color = [[[] for _ in range(26)] for __ in range(n+1)]
    for i in range(1, n+1):
        for j in range(1, n+1):
            if i != j:
                idx = ord(mat[i-1][j-1]) - ord('a')
                if 0 <= idx < 26:
                    adj_by_color[i][idx].append(j)
    from collections import deque
    q = deque([start])
    parent = {start: None}
    while q:
        cur = q.popleft()
        x,y,z = cur
        S = {x,y,z}
        for p in (x,y,z):
            u,v = sorted(list(S - {p}))
            cidx = ord(mat[u-1][v-1]) - ord('a')
            if not (0 <= cidx < 26):
                continue
            for t in adj_by_color[p][cidx]:
                if t in S:
                    continue
                nxt = tuple(sorted((S - {p}) | {t}))
                if nxt in parent:
                    continue
                parent[nxt] = (cur, p, t)
                if nxt == target:
                    path = []
                    node = nxt
                    while node != start:
                        prev, frm, to = parent[node]
                        path.append((frm, to))
                        node = prev
                    path.reverse()
                    return path
                q.append(nxt)
    return None

def apply_moves(start, moves):
    S = set(start)
    for u,v in moves:
        assert u in S and v not in S
        S.remove(u)
        S.add(v)
    return tuple(sorted(S))

# Deterministic tiny checks
random.seed(0)
for n in range(3, 8):
    for _ in range(10):
        n_, start, mat = random_instance(n)
        dist = bfs_len(n_, start, mat)
        moves = solve_case_final(n_, start, mat)
        if dist is None:
            assert moves is None
        else:
            assert moves is not None
            assert len(moves) == dist
            assert apply_moves(start, moves) == (1,2,3)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(stdin: str):
    lines = stdin.strip().splitlines()
    n = int(lines[0].strip())
    a, b, c = map(int, lines[1].split())
    mat = [list(lines[2 + i].rstrip()) for i in range(n)]
    return n, (a, b, c), mat

def solve_case(n, start_triple, mat):
    start = tuple(sorted(start_triple))
    target = (1, 2, 3)
    if start == target:
        return []

    # Precompute adjacency by color (26 letters)
    adj_by_color = [[[] for _ in range(26)] for __ in range(n+1)]
    for i in range(1, n+1):
        for j in range(1, n+1):
            if i == j:
                continue
            ch = mat[i-1][j-1]
            idx = ord(ch) - ord('a')
            if 0 <= idx < 26:
                adj_by_color[i][idx].append(j)

    q = deque([start])
    visited = {start}
    parent = {}  # state -> (prev_state, move_from, move_to)

    while q:
        cur = q.popleft()
        x, y, z = cur
        cur_set = {x, y, z}
        for p in (x, y, z):
            u, v = sorted(list(cur_set - {p}))
            cidx = ord(mat[u-1][v-1]) - ord('a')
            if not (0 <= cidx < 26):
                continue
            for t in adj_by_color[p][cidx]:
                if t in cur_set:
                    continue
                nxt = tuple(sorted((cur_set - {p}) | {t}))
                if nxt in visited:
                    continue
                visited.add(nxt)
                parent[nxt] = (cur, p, t)
                if nxt == target:
                    # Reconstruct
                    path = []
                    node = nxt
                    while node != start:
                        prev, frm, to = parent[node]
                        path.append((frm, to))
                        node = prev
                    path.reverse()
                    return path
                q.append(nxt)
    return None

def solve_all(stdin: str) -> str:
    n, start, mat = read_input(stdin)
    ans = solve_case(n, start, mat)
    if ans is None:
        return "-1\n"
    out = [str(len(ans))] + [f"{u} {v}" for (u, v) in ans]
    return "\n".join(out) + "\n"

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    # Minimal asserts
    def mk_mat(letter: str, n: int):
        m = [["*"]*n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                if i != j:
                    m[i][j] = letter
        return m
    # Done already
    n = 3; mat = mk_mat('a', n)
    assert solve_case(n, (1,2,3), mat) == []
    # One move possible
    n = 4; mat = mk_mat('a', n)
    res = solve_case(n, (2,3,4), mat)
    assert res is not None and len(res) == 1
    # Blocked
    n = 4; mat = mk_mat('a', n)
    mat[1][2] = 'b'; mat[2][1] = 'b'
    for j in range(n):
        if j != 0:
            mat[0][j] = 'c'; mat[j][0] = 'c'
    assert solve_case(n, (1,2,3), mat) is None

    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Shortest-path search over unordered triples of occupied vertices; legal moves match the color of the other two stones' diagonal.}
\WHY{Tests ability to model indistinguishable-object states, compress state space, and reconstruct shortest paths with constraints dependent on pairs.}
\CHECKLIST{Ensure triples are normalized; precompute neighbors by color; BFS with parent reconstruction; early exit at target; handle already-at-target and impossible cases.}
\EDGECASES{Start already equals target. No legal moves from start. Multiple optimal paths. Colors outside `a`..`z` only on main diagonal. Very small $n=3$.}
\PITFALLS{Treating stones as ordered triples causes unnecessary state blow-up. Forgetting to exclude occupied targets. Not sorting the triple, breaking visited checks. Not reconstructing moves correctly. Missing early exit conditions. Off-by-one on 1-based indices.}
\FAILMODES{Naive DFS may loop and miss minimality. Scanning all $t$ per move is slower but still acceptable; precomputing color adjacency avoids timeouts in tight languages.}
\ELI{Think of each position as which three vertices are occupied. From there, you can move one stone along a same-colored edge as the edge between the other two stones. BFS finds the fewest moves to end up with stones on vertices $1$, $2$, and $3$.}
\NotePages{3}

\end{document}