% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tournament Countdown}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1713/D}}
\LINE{DIFFICULTY / RATING}{1800}
\STATEMENT{This is an interactive problem (originally).

There was a tournament consisting of $2^n$ contestants. The $1$-st contestant competed with the $2$-nd, the $3$-rd competed with the $4$-th, and so on. After that, the winner of the first match competed with the winner of second match, etc. The tournament ended when there was only one contestant left, who was declared the winner of the tournament. Such a tournament scheme is known as the single-elimination tournament.

You do not know the results, but you want to find the winner of the tournament. In one query, you select two integers $a$ and $b$, which are the indices of two contestants. The jury will return $1$ if $a$ won more matches than $b$, $2$ if $b$ won more matches than $a$, or $0$ if their number of wins was equal.

Find the winner in no more than $\left\lceil \tfrac{1}{3}\cdot 2^{n+1} \right\rceil$ queries. Here $\lceil x \rceil$ denotes the value of $x$ rounded up to the nearest integer.

Note that the tournament is long over, meaning that the results are fixed and do not depend on your queries.

For this sheet we use an equivalent \emph{offline} version for testing: for each test you are given $n$ and an array of total wins of all $2^n$ contestants consistent with a single-elimination tournament. You must output the index (1-based) of the overall winner.

Input:
The first line contains a single integer $t$ ($1 \le t \le 2^{14}$) — the number of test cases.

For each test case, the first line contains a single integer $n$ ($1 \le n \le 17$). The next line contains $2^n$ integers $w_1,\ldots,w_{2^n}$ — the number of matches each contestant won in the tournament (consistent with some single-elimination bracket).

It is guaranteed that the sum of $2^n$ over all test cases does not exceed $2^{17}$.

Output:
For each test case, print a single integer — the index of the winner.}
\BREAKDOWN{We need to identify the tournament winner using only comparisons of contestants' total win counts. The interactive optimum uses quartets to reduce players with exactly 2 queries per 4 contestants, yielding at most $\lceil 2^{n+1}/3 \rceil$ queries. Offline we can verify correctness against provided wins arrays.}
\ELI{Compare players smartly in groups of four so that each two comparisons leave only one candidate; repeat until one or two candidates remain, then finish.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{For each test case:
\begin{bullets}
\item $n$ (integer), with $1 \le n \le 17$.
\item Array $w$ of length $m=2^n$, where $w_i$ is the total number of matches contestant $i$ won. The array is consistent with some single-elimination bracket (exactly one contestant has $n$ wins).
\end{bullets}}
\OUTPUTS{For each test case, output a single line with the 1-based index of the winner (the unique $i$ with $w_i=n$).}
\SAMPLES{Example 1:
\begin{minted}{python}
Input
1
3
1 0 0 2 0 1 3 0

Output
7
\end{minted}
Example 2:
\begin{minted}{python}
Input
2
1
1 0
2
2 1 0 0

Output
1
1
\end{minted}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $P=\{1,\ldots,2^n\}$ be contestants. There exists a fixed tournament bracket and outcomes producing an array $w\in\{0,1,\ldots,n\}^{2^n}$ of total wins. Define an oracle $\mathrm{cmp}(i,j)$ returning $\operatorname{sign}(w_i-w_j)$ as $\{0,1,2\}$ for tie/$i$-better/$j$-better. Goal: find $\operatorname*{arg\,max}_i w_i$.}
\varmapStart
\var{n}{number of rounds; $m=2^n$ contestants}
\var{w_i}{total wins of contestant $i$}
\var{\mathrm{cmp}(i,j)}{oracle comparison of total wins}
\var{\mathcal{C}}{current set (list) of candidates}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Oracle: } \mathrm{cmp}(i,j)=
\begin{cases}
1,& w_i>w_j,\\
0,& w_i=w_j,\\
2,& w_i<w_j,
\end{cases}\\
&\text{Winner index } i^\star=\operatorname*{arg\,max}_{i\in P} w_i.
\end{aligned}
\]
}
\ASSUMPTIONS{Exactly one $i$ has $w_i=n$; all $w_i$ are consistent with a single-elimination bracket. Access to $w$ is available offline for verification; in interactive setting, only $\mathrm{cmp}$ is available.}
\INVARIANTS{
\begin{bullets}
\item The true winner $i^\star$ is never eliminated by any compare-and-keep-better step.
\item In quartet reduction, after two comparisons, at least one of $\{a,b,c,d\}$ with maximum $w$ is retained.
\item Candidate list size decreases monotonically: $|\mathcal{C}_{k+1}|\in\{\lceil|\mathcal{C}_k|/4\rceil,1,2\}$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute the winner as $i^\star=\operatorname*{arg\,max}_i w_i$ by scanning the wins array.}
\ASSUMPTIONS{Offline access to $w$; ignores the interactive constraint entirely.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$ and array $w$ of length $m=2^n$.
\item Scan all indices, keep the index with the largest $w_i$ (break ties by smaller index for determinism, though in valid inputs the winner is unique).
\item Output the index.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(2^n)$; space $S(n)=\Theta(1)$ beyond the input.}
\[
\begin{aligned}
T(n) &= c\cdot 2^n + O(1).
\end{aligned}
\]
\CORRECTNESS{Since $w$ lists total wins, the champion is exactly the unique index with $w_i=n=\max_j w_j$. A linear scan returns that index.}
\EDGECASES{Smallest $n=1$; already unique winner. Input already guarantees uniqueness and consistency.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return []
    t = it[0]; idx = 1
    cases = []
    for _ in range(t):
        n = it[idx]; idx += 1
        m = 1 << n
        wins = it[idx:idx+m]; idx += m
        assert len(wins) == m
        cases.append((n, wins))
    return cases

def solve_case_baseline(n: int, wins):
    # Returns 1-based index of max wins
    best_i = 1
    best_w = wins[0]
    for i, w in enumerate(wins, start=1):
        if w > best_w or (w == best_w and i < best_i):
            best_w = w
            best_i = i
    return best_i

def solve_all(cases):
    out = []
    for n, wins in cases:
        out.append(str(solve_case_baseline(n, wins)))
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-test when no input
        # Example from statement
        assert solve_case_baseline(3, [1,0,0,2,0,1,3,0]) == 7
        # Tiny
        assert solve_case_baseline(1, [1,0]) == 1
        # Another
        assert solve_case_baseline(2, [2,1,0,0]) == 1
        print("OK")
        return
    cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks:
\begin{bullets}
\item Uses the exact sample array $[1,0,0,2,0,1,3,0] \to 7$.
\item Verifies tiny $n=1$ and a crafted $n=2$ case.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Knockout via Adjacent Pairing}
\WHICHFORMULA{Use the comparison oracle $\mathrm{cmp}(i,j)=\operatorname{sign}(w_i-w_j)$ to run a knockout bracket over the current candidate list by adjacent pairs, halving the list each round. This mirrors a standard tournament over total wins.}
\ASSUMPTIONS{Only pairwise comparisons are allowed; this uses $m-1$ comparisons overall, which is correct but not query-optimal.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize candidates $\mathcal{C}=[1,2,\ldots,2^n]$.
\item While $|\mathcal{C}|>1$, in blocks of 2, compare each pair and keep the better index (break ties by the smaller index).
\item Output the sole remaining index.
\end{algosteps}
\COMPLEXITY{At each round, $|\mathcal{C}|$ halves after $|\mathcal{C}|/2$ comparisons; total is $2^n-1$ comparisons. Time $\Theta(2^n)$; space $\Theta(2^n)$.}
\[
\begin{aligned}
T(n) &= \sum_{k=0}^{n-1} 2^{n-k-1} \;=\; 2^n-1.
\end{aligned}
\]
\CORRECTNESS{At each comparison, the contestant with smaller total wins cannot be the global maximum, so discarding them preserves the true winner. By induction, the final survivor has maximal $w_i$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return []
    t = it[0]; idx = 1
    cases = []
    for _ in range(t):
        n = it[idx]; idx += 1
        m = 1 << n
        wins = it[idx:idx+m]; idx += m
        assert len(wins) == m
        cases.append((n, wins))
    return cases

class Oracle:
    def __init__(self, wins):
        self.wins = wins
        self.queries = 0
    def cmp(self, i, j):
        # i, j are 1-based
        self.queries += 1
        wi, wj = self.wins[i-1], self.wins[j-1]
        if wi > wj: return 1
        if wi < wj: return 2
        return 0

def solve_case_knockout(n: int, wins):
    m = 1 << n
    O = Oracle(wins)
    cand = list(range(1, m+1))
    # Knockout by adjacent pairs
    while len(cand) > 1:
        nxt = []
        for i in range(0, len(cand), 2):
            a, b = cand[i], cand[i+1]
            r = O.cmp(a, b)
            if r == 1: nxt.append(a)
            elif r == 2: nxt.append(b)
            else: nxt.append(min(a, b))
        cand = nxt
    return cand[0], O.queries

def solve_all(cases):
    out = []
    for n, wins in cases:
        idx, _ = solve_case_knockout(n, wins)
        out.append(str(idx))
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests
        idx, q = solve_case_knockout(3, [1,0,0,2,0,1,3,0])
        assert idx == 7 and q == (1<<3) - 1  # 7 comparisons
        idx, q = solve_case_knockout(1, [1,0])
        assert idx == 1 and q == 1
        idx, q = solve_case_knockout(2, [2,1,0,0])
        assert idx == 1 and q == 3
        print("OK")
        return
    cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks on:
\begin{bullets}
\item The sample case; verifies both winner and exact comparison count $2^n-1$.
\item Two additional tiny cases.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Quartet Reduction (2 Queries per 4 Contestants)}
\WHICHFORMULA{Process contestants in blocks of four $(a,b,c,d)$. Use two comparisons to select a single survivor:
\begin{bullets}
\item Compare $a$ vs $c$.
\item If result is 1, compare $a$ vs $d$; keep $a$ if 1 else $d$.
\item If result is 2, compare $b$ vs $c$; keep $b$ if 1 else $c$.
\item If result is 0, compare $b$ vs $d$; keep $b$ if 1 else $d$.
\end{bullets}
Repeat this reduction until $|\mathcal{C}|\le 2$, then finish with at most one final comparison.}
\ASSUMPTIONS{Length $m=2^n$. While $|\mathcal{C}|>2$, $|\mathcal{C}|$ is divisible by $4$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $\mathcal{C}=[1,2,\ldots,2^n]$.
\item While $|\mathcal{C}|>2$, partition into consecutive quadruples and apply the 2-comparison reduction to each quadruple, forming the next candidate list.
\item If two remain, compare them once and keep the better (break tie by smaller index).
\item Output the survivor.
\end{algosteps}
\OPTIMALITY{Let $Q(m)$ be the number of comparisons on $m=2^n$ contestants. Each quartet uses 2 comparisons and reduces $4\to 1$: $Q(m)=\tfrac{m}{2}+Q(m/4)$ with $Q(1)=0$, $Q(2)=1$. Solving,
\begin{BreakableEquation*}
Q(m) = \frac{2m}{3}\Bigl(1-4^{-k}\Bigr) + \delta \le \left\lceil \frac{2m}{3} \right\rceil = \left\lceil \frac{2^{n+1}}{3} \right\rceil,
\end{BreakableEquation*}
for appropriate integer $k$ and base correction $\delta\in\{0,1\}$. This matches the known optimal bound.}
\COMPLEXITY{Time $\Theta(2^n)$ comparisons with constant $\approx \tfrac{2}{3}$ factor; auxiliary space $\Theta(2^n)$ for candidate lists.}
\[
\begin{aligned}
T(n) &= \frac{2}{3}\cdot 2^n \;\pm O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from math import ceil

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return []
    t = it[0]; idx = 1
    cases = []
    for _ in range(t):
        n = it[idx]; idx += 1
        m = 1 << n
        wins = it[idx:idx+m]; idx += m
        assert len(wins) == m
        cases.append((n, wins))
    return cases

class Oracle:
    def __init__(self, wins):
        self.wins = wins
        self.queries = 0
    def cmp(self, i, j):
        # 1-based indices
        self.queries += 1
        wi, wj = self.wins[i-1], self.wins[j-1]
        if wi > wj: return 1
        if wi < wj: return 2
        return 0

def reduce_quad(O: Oracle, a: int, b: int, c: int, d: int) -> int:
    r1 = O.cmp(a, c)
    if r1 == 1:
        r2 = O.cmp(a, d)
        return a if r2 == 1 else d
    elif r1 == 2:
        r2 = O.cmp(b, c)
        return b if r2 == 1 else c
    else:
        r2 = O.cmp(b, d)
        return b if r2 == 1 else d

def winner_optimal(n: int, wins):
    m = 1 << n
    O = Oracle(wins)
    cand = list(range(1, m+1))
    while len(cand) > 2:
        nxt = []
        for i in range(0, len(cand), 4):
            a, b, c, d = cand[i], cand[i+1], cand[i+2], cand[i+3]
            nxt.append(reduce_quad(O, a, b, c, d))
        cand = nxt
    if len(cand) == 2:
        r = O.cmp(cand[0], cand[1])
        if r == 1:
            ans = cand[0]
        elif r == 2:
            ans = cand[1]
        else:
            ans = min(cand[0], cand[1])
    else:
        ans = cand[0]
    # Bound check
    bound = ceil((2 * m) / 3)
    assert O.queries <= bound
    return ans, O.queries

def solve_case(n: int, wins):
    idx, _ = winner_optimal(n, wins)
    return idx

def solve_all(cases):
    return "\n".join(str(solve_case(n, wins)) for n, wins in cases)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Exactly 3 asserts
        idx, q = winner_optimal(3, [1,0,0,2,0,1,3,0])
        assert idx == 7 and q <= ceil((2*(1<<3))/3)
        idx, q = winner_optimal(1, [1,0])
        assert idx == 1 and q <= ceil((2*(1<<1))/3)
        idx, q = winner_optimal(2, [2,1,0,0])
        assert idx == 1 and q <= ceil((2*(1<<2))/3)
        print("OK")
        return
    cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts on:
\begin{bullets}
\item The sample case ($n=3$).
\item The minimal case ($n=1$).
\item A crafted $n=2$ case.
\end{bullets}}
\RESULT{Outputs the 1-based index of the winner for each test case. Ties in the final 2-comparison are broken by smaller index for determinism (though valid inputs have a unique champion with $n$ wins).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover tiny cases and the provided example. Property-style checks assert the query bound $q \le \lceil 2^{n+1}/3 \rceil$.}
\LINE{CROSS-CHECKS}{Compare outputs across Approaches A, B, and C on the same wins arrays; all must return the same winner index.}
\LINE{EDGE-CASE GENERATOR}{Deterministically generate tournament wins from a strength array by simulating a single-elimination bracket; ensures exactly one contestant with $n$ wins.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple

def simulate_wins_from_strengths(n: int, strengths: List[int]) -> List[int]:
    """Simulate a standard bracket (1 vs 2, 3 vs 4, ...) each round;
    higher strength always wins; return total wins per player."""
    m = 1 << n
    assert len(strengths) == m
    wins = [0] * m
    cur = list(range(m))  # 0-based indices for internal simulation
    for _ in range(n):
        nxt = []
        for i in range(0, len(cur), 2):
            a, b = cur[i], cur[i+1]
            if strengths[a] >= strengths[b]:
                wins[a] += 1
                nxt.append(a)
            else:
                wins[b] += 1
                nxt.append(b)
        cur = nxt
    return wins

def cross_check():
    # Cross-validate A, B, C agree and C meets the bound.
    from math import ceil
    def solveA(n, w):
        best_i, best_w = 1, w[0]
        for i, wi in enumerate(w, start=1):
            if wi > best_w or (wi == best_w and i < best_i):
                best_i, best_w = i, wi
        return best_i
    def solveB(n, w):
        class O:
            def __init__(self, wins): self.w=w; self.q=0
            def cmp(self,i,j):
                self.q+=1
                wi,wj=self.w[i-1],self.w[j-1]
                return 1 if wi>wj else (2 if wi<wj else 0)
        O1=O(w)
        m=1<<n
        cand=list(range(1,m+1))
        while len(cand)>1:
            nxt=[]
            for i in range(0,len(cand),2):
                a,b=cand[i],cand[i+1]
                r=O1.cmp(a,b)
                nxt.append(a if r==1 else (b if r==2 else min(a,b)))
            cand=nxt
        return cand[0], O1.q
    # Try some strengths
    for n in range(1,6):
        m = 1 << n
        strengths = list(range(m))  # strictly increasing
        wins = simulate_wins_from_strengths(n, strengths)
        A = solveA(n, wins)
        B, qB = solveB(n, wins)
        from math import ceil
        # Reuse winner_optimal from Approach C by inlining minimal copy:
        idxC, qC = winner_optimal(n, wins)
        assert A == B == idxC
        assert qC <= ceil((2*m)/3)
        assert qB == m-1
    return True

if __name__ == "__main__":
    assert cross_check()
    print("CROSS-CHECK OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys
from math import ceil

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return []
    t = it[0]; idx = 1
    cases = []
    for _ in range(t):
        n = it[idx]; idx += 1
        m = 1 << n
        wins = it[idx:idx+m]; idx += m
        assert len(wins) == m
        cases.append((n, wins))
    return cases

class Oracle:
    def __init__(self, wins):
        self.wins = wins
        self.queries = 0
    def cmp(self, i, j):
        self.queries += 1
        wi, wj = self.wins[i-1], self.wins[j-1]
        if wi > wj: return 1
        if wi < wj: return 2
        return 0

def reduce_quad(O: Oracle, a: int, b: int, c: int, d: int) -> int:
    r1 = O.cmp(a, c)
    if r1 == 1:
        r2 = O.cmp(a, d)
        return a if r2 == 1 else d
    elif r1 == 2:
        r2 = O.cmp(b, c)
        return b if r2 == 1 else c
    else:
        r2 = O.cmp(b, d)
        return b if r2 == 1 else d

def solve_case(n: int, wins):
    m = 1 << n
    O = Oracle(wins)
    cand = list(range(1, m+1))
    while len(cand) > 2:
        nxt = []
        for i in range(0, len(cand), 4):
            a, b, c, d = cand[i], cand[i+1], cand[i+2], cand[i+3]
            nxt.append(reduce_quad(O, a, b, c, d))
        cand = nxt
    if len(cand) == 2:
        r = O.cmp(cand[0], cand[1])
        if r == 1:
            ans = cand[0]
        elif r == 2:
            ans = cand[1]
        else:
            ans = min(cand[0], cand[1])
    else:
        ans = cand[0]
    # Optional: ensure bound in offline mode
    assert O.queries <= ceil((2 * m) / 3)
    return ans

def solve_all(cases):
    return "\n".join(str(solve_case(n, wins)) for n, wins in cases)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Minimal asserts
        assert solve_case(3, [1,0,0,2,0,1,3,0]) == 7
        assert solve_case(1, [1,0]) == 1
        assert solve_case(2, [2,1,0,0]) == 1
        print("OK")
        return
    cases = read_input(data)
    print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the winner with minimal comparisons by reducing groups of four contestants using exactly two comparisons per group.}
\WHY{Interactive tournament problems often hide structure in the comparison relation; exploiting that structure (here, total wins) yields sublinear-factor savings in query count.}
\CHECKLIST{
\begin{bullets}
\item Always compare $a$ vs $c$ first inside a quartet.
\item Branch on the three-way result to pick the second comparison.
\item Repeat quartet reduction until at most two candidates remain.
\item Do a final comparison if needed.
\item Track and verify the $\lceil 2^{n+1}/3 \rceil$ bound.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ (two contestants) — exactly one comparison.
\item $n=2$ — one quartet, two comparisons.
\item Final tie ($\mathrm{cmp}=0$) due to identical $w$ values among non-champions — break by smaller index for determinism.
\item Input consistency: exactly one $w_i=n$.
\item Large $n$ up to $17$; stay linear-time.
\item Multiple test cases — do not leak state between cases.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one on 1-based vs 0-based indices in the oracle.
\item Mishandling the $\mathrm{cmp}$ return code $0$ in quartet or final comparison.
\item Forgetting that while $|\mathcal{C}|>2$, the size is divisible by $4$; do not index past the end.
\item Not resetting the query counter between test cases (for instrumentation).
\item Assuming ties cannot occur among non-champions; they can.
\item Using recursion without care may hit Python recursion limits; iterative is safer.
\end{bullets}}
\FAILMODES{Adjacent-pair knockout uses $2^n-1$ comparisons and violates the interactive bound for large $n$; quartet reduction sustains the bound. Randomly comparing pairs without structure may eliminate the true winner in non-greedy schemes.}
\ELI{Compare smartly: in each group of four, two well-chosen comparisons are enough to find the best of the four. Repeating this shrinks the field fast, guaranteeing the champion is found within the promised number of comparisons.}
\NotePages{3}

\end{document}