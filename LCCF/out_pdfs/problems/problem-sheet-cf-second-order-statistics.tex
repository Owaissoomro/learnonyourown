% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Second Order Statistics}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/22/A}}
\LINE{DIFFICULTY / RATING}{800 (CF 22/A)}
\STATEMENT{Once Bob needed to find the second order statistics of a sequence of integer numbers. Let us choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words, it is the smallest element strictly greater than the minimum. Help Bob solve this problem.

Input: The first input line contains integer $n$ ($1 \le n \le 100$) — amount of numbers in the sequence. The second line contains $n$ space-separated integer numbers — elements of the sequence. These numbers do not exceed $100$ in absolute value.

Output: If the given sequence has the second order statistics, output this order statistics, otherwise output \texttt{NO}.}
\BREAKDOWN{We need the smallest value that is strictly greater than the minimum of the list. If all values are equal (or $n=1$), there is no such value, so print \texttt{NO}.}
\ELI{Take all distinct numbers, sort them, and print the second one if it exists; otherwise print \texttt{NO}.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single test:
\begin{bullets}
\item Integer $n$ with $1 \le n \le 100$.
\item A line of $n$ integers $a_i$ with $\lvert a_i \rvert \le 100$.
\end{bullets}}
\OUTPUTS{Print the second smallest distinct value if it exists; otherwise print the string \texttt{NO}. Output is a single line.}
\SAMPLES{Example 1:
\begin{verbatim}
Input
4
1 2 1 3
Output
2
\end{verbatim}
Example 2:
\begin{verbatim}
Input
3
2 2 2
Output
NO
\end{verbatim}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a multiset $S = \{a_1,\ldots,a_n\}$ of integers, define $m = \min S$. If there exists $x \in S$ with $x > m$, define the second order statistic as $s = \min\{x \in S : x > m\}$. Otherwise, the statistic does not exist.}
\varmapStart
\var{n}{number of elements}
\var{a_i}{the $i$-th integer in the sequence}
\var{m}{minimum value in the sequence}
\var{s}{second order statistic (second distinct minimum), if it exists}
\varmapEnd
\GOVERN{
\[
  m = \min_{1 \le i \le n} a_i,\qquad
  s =
  \begin{cases}
    \min\{\,a_i : a_i > m\,\}, & \text{if }\exists i \text{ with } a_i > m,\\
    \text{undefined}, & \text{otherwise.}
  \end{cases}
\]
}
\ASSUMPTIONS{Elements are integers within $\lvert a_i \rvert \le 100$. $n \in \{1,\ldots,100\}$.}
\INVARIANTS{
\begin{bullets}
\item $m$ is the smallest value seen so far during a single pass.
\item If $s$ exists, then $m < s$ and there is no $x$ with $m < x < s$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Form the set of distinct values and sort it; the second element (if any) is the answer. This directly implements the definition.}
\ASSUMPTIONS{Sorting cost dominates; with $n \le 100$, $O(n \log n)$ is trivial.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$ and the array $a$.
\item Compute $b = \text{sorted}(\text{set}(a))$.
\item If $\lvert b \rvert \ge 2$, print $b[1]$; otherwise print \texttt{NO}.
\end{algosteps}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= O(n \log n) \text{ for sorting the distinct values} \\
S(n) &= O(n) \text{ for storing the set and sorted list.}
\end{aligned}
\]
}
\CORRECTNESS{Sorting the distinct values puts them in nondecreasing order; the second element is the smallest value strictly greater than the minimum. If fewer than two distinct values exist, the statistic does not exist.}
\EDGECASES{All equal values; $n=1$; negative and positive mix; already sorted input; duplicates interleaved.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / solve_all / main + guard + asserts)
from sys import stdin, stdout

def read_input():
    data = list(map(str.strip, stdin.read().strip().splitlines()))
    if not data:
        return 0, []
    n = int(data[0])
    arr = list(map(int, data[1].split())) if n > 0 and len(data) > 1 else []
    return n, arr

def second_order_statistics_sort(arr):
    uniq = sorted(set(arr))
    if len(uniq) >= 2:
        return str(uniq[1])
    return "NO"

def solve_case(n, arr):
    # n is not strictly needed since arr length is authoritative
    return second_order_statistics_sort(arr)

def solve_all():
    n, arr = read_input()
    stdout.write(solve_case(n, arr))

def _unit_tests():
    assert solve_case(4, [1, 2, 1, 3]) == "2"
    assert solve_case(3, [2, 2, 2]) == "NO"
    assert solve_case(1, [5]) == "NO"
    assert solve_case(5, [-1, -1, -2, -2, -3]) == "-2"

if __name__ == "__main__":
    _unit_tests()
    solve_all()
\end{minted}
\VALIDATION{Checked with distinct values, all equal, single element, and negatives.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Single-Pass Tracking of Minimums}
\WHICHFORMULA{Track the smallest and second-smallest distinct values in one pass without sorting.}
\ASSUMPTIONS{Initialize sentinels to $+\infty$ and update them while scanning.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $m_1 \leftarrow +\infty$, $m_2 \leftarrow +\infty$.
\item For each $x$ in $a$:
\begin{bullets}
\item If $x < m_1$: set $m_2 \leftarrow m_1$, $m_1 \leftarrow x$.
\item Else if $m_1 < x < m_2$: set $m_2 \leftarrow x$.
\end{bullets}
\item If $m_2 \ne +\infty$, print $m_2$; else print \texttt{NO}.
\end{algosteps}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= O(n) \quad \text{single pass},\\
S(n) &= O(1).
\end{aligned}
\]
}
\CORRECTNESS{Invariant: after processing prefix $a[0..i]$, $m_1$ is the minimum, and $m_2$ is the smallest value greater than $m_1$ if any; updates preserve this.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from sys import stdin, stdout

def read_input():
    data = list(map(str.strip, stdin.read().strip().splitlines()))
    if not data:
        return 0, []
    n = int(data[0])
    arr = list(map(int, data[1].split())) if n > 0 and len(data) > 1 else []
    return n, arr

def second_order_statistics_one_pass(arr):
    INF = 10**9
    m1, m2 = INF, INF
    for x in arr:
        if x < m1:
            m2 = m1
            m1 = x
        elif m1 < x < m2:
            m2 = x
    return str(m2) if m2 != INF else "NO"

def solve_case(n, arr):
    return second_order_statistics_one_pass(arr)

def solve_all():
    n, arr = read_input()
    stdout.write(solve_case(n, arr))

def _unit_tests():
    assert solve_case(4, [1, 2, 1, 3]) == "2"
    assert solve_case(3, [2, 2, 2]) == "NO"
    assert solve_case(5, [-1, -1, -2, -2, -3]) == "-2"
    assert solve_case(5, [0, 0, 1, 0, 2]) == "1"

if __name__ == "__main__":
    _unit_tests()
    solve_all()
\end{minted}
\VALIDATION{Covers duplicates, negatives, and mixed inputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Counting Over Bounded Value Range}
\WHICHFORMULA{Exploit the bounded domain $\lvert a_i \rvert \le 100$: count occurrences for indices in $[-100,100]$ and scan twice to find the first two distinct present values.}
\ASSUMPTIONS{Applicable because the value range is fixed and tiny; time $O(R)$ with $R=201$ independent of $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build frequency array $cnt[201]$ with offset $+100$.
\item Scan from $-100$ to $100$ to find the first value $v_1$ with $cnt>0$.
\item Continue scanning to find the next value $v_2$ with $cnt>0$; print $v_2$ or \texttt{NO} if absent.
\end{algosteps}
\OPTIMALITY{Given the domain bound, $O(R)$ is optimal in terms of dependence on the value range and does not exceed $O(n)$ for $n \le 100$.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= O(n + R) = O(201) \text{ here},\\
S(n) &= O(R) = O(201).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from sys import stdin, stdout

def read_input():
    data = list(map(str.strip, stdin.read().strip().splitlines()))
    if not data:
        return 0, []
    n = int(data[0])
    arr = list(map(int, data[1].split())) if n > 0 and len(data) > 1 else []
    return n, arr

def second_order_statistics_counting(arr):
    OFFSET = 100
    R = 201
    cnt = [0] * R
    for x in arr:
        if -100 <= x <= 100:
            cnt[x + OFFSET] += 1
        else:
            # Outside documented range; still handle gracefully
            # Fallback: we can extend counting via a set approach
            pass
    found_first = False
    first_val = None
    for v in range(-100, 101):
        if cnt[v + OFFSET] > 0:
            if not found_first:
                found_first = True
                first_val = v
            else:
                return str(v)
    return "NO"

def solve_case(n, arr):
    return second_order_statistics_counting(arr)

def solve_all():
    n, arr = read_input()
    stdout.write(solve_case(n, arr))

def _unit_tests():
    # exactly 3 asserts
    assert solve_case(4, [1, 2, 1, 3]) == "2"
    assert solve_case(3, [2, 2, 2]) == "NO"
    assert solve_case(5, [-1, -1, -2, -2, -3]) == "-2"

if __name__ == "__main__":
    _unit_tests()
    solve_all()
\end{minted}
\VALIDATION{Exactly three unit asserts cover distinct, all-equal, and negative-only cases.}
\RESULT{Print the second smallest distinct value if present; otherwise print \texttt{NO}. No tie-breaking is needed because order is total over integers.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-check helper with arrays; fuzz over small ranges; cross-validate sorting-based and one-pass implementations.}
\LINE{CROSS-CHECKS}{Randomly generate arrays with $n \in [1,10]$ and values in $[-3,3]$; compare outputs of sort-based, one-pass, and counting implementations. They must match.}
\LINE{EDGE-CASE GENERATOR}{Covers $n=1$, all-equal arrays, strictly increasing, strictly decreasing, and mixtures with duplicates and negatives.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_equal(n, v):
    return [v] * n

def gen_increasing(n, start=-2):
    return list(range(start, start + n))

def gen_with_dups():
    return [0, 1, 0, 1, 2, 2, 3, 3]

def ref_sort(arr):
    uniq = sorted(set(arr))
    return str(uniq[1]) if len(uniq) >= 2 else "NO"

def ref_one_pass(arr):
    INF = 10**9
    m1, m2 = INF, INF
    for x in arr:
        if x < m1:
            m2, m1 = m1, x
        elif m1 < x < m2:
            m2 = x
    return str(m2) if m2 != INF else "NO"

def ref_counting(arr):
    OFFSET = 100
    cnt = [0]*201
    for x in arr:
        if -100 <= x <= 100:
            cnt[x+OFFSET] += 1
        else:
            # fallback to set if out-of-range appears in tests
            return ref_sort(arr)
    stage = 0
    for v in range(-100, 101):
        if cnt[v+OFFSET] > 0:
            if stage == 0:
                stage = 1
            else:
                return str(v)
    return "NO"

def cross_check():
    cases = []
    cases.append(gen_all_equal(5, 7))
    cases.append(gen_increasing(5, -2))
    cases.append(gen_with_dups())
    cases.append([1])
    cases.append([3, 3, 2, 2, 1, 1])
    for arr in cases:
        a = ref_sort(arr)
        b = ref_one_pass(arr)
        c = ref_counting(arr)
        assert a == b == c

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
from sys import stdin, stdout

def read_input():
    data = list(map(str.strip, stdin.read().strip().splitlines()))
    if not data:
        return 0, []
    n = int(data[0])
    arr = list(map(int, data[1].split())) if n > 0 and len(data) > 1 else []
    return n, arr

def solve_case(n, arr):
    # One-pass is simple and optimal for n; range is tiny but not required
    INF = 10**9
    m1, m2 = INF, INF
    for x in arr:
        if x < m1:
            m2 = m1
            m1 = x
        elif m1 < x < m2:
            m2 = x
    return str(m2) if m2 != INF else "NO"

def solve_all():
    n, arr = read_input()
    stdout.write(solve_case(n, arr))

def _unit_tests():
    # Core correctness checks
    assert solve_case(4, [1, 2, 1, 3]) == "2"
    assert solve_case(3, [2, 2, 2]) == "NO"
    assert solve_case(5, [-1, -1, -2, -2, -3]) == "-2"
    # Additional edge checks
    assert solve_case(1, [10]) == "NO"
    assert solve_case(5, [5, 4, 3, 2, 1]) == "2"

if __name__ == "__main__":
    _unit_tests()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the smallest value strictly greater than the minimum (second distinct minimum) or report \texttt{NO}.}
\WHY{Classic warm-up on distinctness and simple selection; tests set logic, duplicates handling, and off-by-one mistakes.}
\CHECKLIST{
\begin{bullets}
\item Read $n$ and the array.
\item Handle duplicates via set or strict comparisons.
\item Output the second distinct minimum if it exists, else \texttt{NO}.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item All values equal.
\item Exactly two distinct values.
\item Negative values only.
\item Mixed signs with many duplicates.
\item Already sorted vs. reverse-sorted inputs.
\item Zeros and repeated zeros.
\item Min occurs many times.
\item Values at domain boundaries $-100$ and $100$.
\item Sparse distincts: e.g., $[-100, 100, 100]$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Treating second smallest by index rather than by distinct value.
\item Forgetting strict inequality when updating $m_2$.
\item Initializing $m_2$ incorrectly (e.g., to $m_1$).
\item Printing the minimum when only one distinct value exists.
\item Mishandling input parsing when $n=0$ or missing line (robustness).
\item Assuming sorted input.
\item Using $>$ instead of $\ge$ or vice versa in comparisons.
\item Not covering negative values in counting offset.
\end{bullets}}
\FAILMODES{Sorting the full array without deduplication gives wrong answers with duplicates. A min-heap of all elements also fails unless deduped. The presented methods avoid these by either deduping or using strict comparisons.}
\ELI{Look for the smallest number; then look for the next different number that is bigger. If you cannot find a different bigger number, say \texttt{NO}.}
\NotePages{3}

\end{document}