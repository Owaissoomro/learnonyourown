% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Greedy Elevator}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/257/E}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{The m-floor ($m>1$) office of international corporation CodeForces has the advanced elevator control system established. It works as follows.

All office floors are sequentially numbered with integers from $1$ to $m$. At time $t=0$, the elevator is on the first floor, the elevator is empty and nobody is waiting for the elevator on other floors. Next, at times $t_i$ ($t_i>0$) people come to the elevator. For simplicity, we assume that one person uses the elevator only once during the reported interval. For every person we know three parameters: the time at which the person comes to the elevator, the floor on which the person is initially, and the floor to which he wants to go.

The movement of the elevator between the floors is as follows. At time $t$ ($t\ge 0$, $t$ is an integer) the elevator is always at some floor. First the elevator releases all people who are in the elevator and want to get to the current floor. Then it lets in all the people waiting for the elevator on this floor. If a person comes to the elevator exactly at time $t$, then he has enough time to get into it. We can assume that all of these actions (going in or out from the elevator) are made instantly. After that the elevator decides, which way to move and at time $(t+1)$ the elevator gets to the selected floor.

The elevator selects the direction of moving by the following algorithm.
\begin{itemize}
\item If the elevator is empty and at the current time no one is waiting for the elevator on any floor, then the elevator remains at the current floor.
\item Otherwise, let's assume that the elevator is on the floor number $x$ ($1\le x\le m$). Then elevator calculates the directions' ``priorities'' $p_{\text{up}}$ and $p_{\text{down}}$: $p_{\text{up}}$ is the sum of the number of people waiting for the elevator on the floors with numbers greater than $x$, and the number of people in the elevator, who want to get to the floors with the numbers greater than $x$; $p_{\text{down}}$ is the sum of the number of people waiting for the elevator on the floors with numbers less than $x$, and the number of people in the elevator, who want to get to the floors with the numbers less than $x$. If $p_{\text{up}}\ge p_{\text{down}}$, then the elevator goes one floor above the current one (that is, from floor $x$ to floor $x+1$), otherwise the elevator goes one floor below the current one (that is, from floor $x$ to floor $x-1$).
\end{itemize}

Your task is to simulate the work of the elevator and for each person to tell the time when the elevator will get to the floor this person needs. Please note that the elevator is large enough to accommodate all the people at once.

Input:
The first line contains two space-separated integers: $n, m$ ($1\le n\le 10^5$, $2\le m\le 10^5$) — the number of people and floors in the building, correspondingly.

Next $n$ lines each contain three space-separated integers: $t_i, s_i, f_i$ ($1\le t_i\le 10^9$, $1\le s_i, f_i\le m, s_i\ne f_i$) — the time when the $i$-th person begins waiting for the elevator, the floor number, where the $i$-th person was initially located, and the number of the floor, where he wants to go.

Output:
Print $n$ lines. In the $i$-th line print a single number — the moment of time, when the $i$-th person gets to the floor he needs. The people are numbered in the order, in which they are given in the input.

Please do not use the \%\texttt{lld} specifier to read or write 64-bit integers in C\texttt{++}. It is preferred to use the \texttt{cin}, \texttt{cout} streams or the \%\texttt{I64d} specifier.

Note (illustrative run):
\begin{itemize}
\item $t=1$. The elevator is on the floor number $1$. The elevator is empty. The floor number $2$ has one person waiting. $p_{\text{up}}=1+0=1$, $p_{\text{down}}=0+0=0$, $p_{\text{up}}\ge p_{\text{down}}$. So the elevator goes to the floor number $2$.
\item $t=2$. The elevator is on the floor number $2$. One person enters the elevator, he wants to go to the floor number $7$. $p_{\text{up}}=0+1=1$, $p_{\text{down}}=0+0=0$, $p_{\text{up}}\ge p_{\text{down}}$. So the elevator goes to the floor number $3$.
\item $t=3$. The elevator is on the floor number $3$. There is one person in the elevator, he wants to go to floor $7$. The floors number $4$ and $6$ have two people waiting for the elevator. $p_{\text{up}}=2+1=3$, $p_{\text{down}}=0+0=0$, $p_{\text{up}}\ge p_{\text{down}}$. So the elevator goes to the floor number $4$.
\item $t=4$. The elevator is on the floor number $4$. There is one person in the elevator who wants to go to the floor number $7$. One person goes into the elevator, he wants to get to the floor number $8$. The floor number $6$ has one man waiting. $p_{\text{up}}=1+2=3$, $p_{\text{down}}=0+0=0$, $p_{\text{up}}\ge p_{\text{down}}$. So the elevator goes to the floor number $5$.
\item $t=5$. The elevator is on the floor number $5$. There are two people in the elevator, they want to get to the floors number $7$ and $8$, correspondingly. There is one person waiting for the elevator on the floor number $6$. $p_{\text{up}}=1+2=3$, $p_{\text{down}}=0+0=0$, $p_{\text{up}}\ge p_{\text{down}}$. So the elevator goes to the floor number $6$.
\item $t=6$. The elevator is on the floor number $6$. There are two people in the elevator, they want to get to the floors number $7$ and $8$, correspondingly. One man enters the elevator, he wants to get to the floor number $5$. $p_{\text{up}}=0+2=2$, $p_{\text{down}}=0+1=1$, $p_{\text{up}}\ge p_{\text{down}}$. So the elevator goes to the floor number $7$.
\item $t=7$. The elevator is on the floor number $7$. One person leaves the elevator, this person wanted to get to the floor number $7$. There are two people in the elevator, they want to get to the floors with numbers $8$ and $5$, correspondingly. $p_{\text{up}}=0+1=1$, $p_{\text{down}}=0+1=1$, $p_{\text{up}}\ge p_{\text{down}}$. So the elevator goes to the floor number $8$.
\item $t=8$. The elevator is on the floor number $8$. One person leaves the elevator, this person wanted to go to the floor number $8$. There is one person in the elevator, he wants to go to the floor number $5$. $p_{\text{up}}=0+0=0$, $p_{\text{down}}=0+1=1$, $p_{\text{up}}<p_{\text{down}}$. So the elevator goes to the floor number $7$.
\item $t=9$. The elevator is on the floor number $7$. There is one person in the elevator, this person wants to get to the floor number $5$. $p_{\text{up}}=0+0=0$, $p_{\text{down}}=0+1=1$, $p_{\text{up}}<p_{\text{down}}$. So the elevator goes to the floor number $6$.
\item $t=10$. The elevator is on the floor number $6$. There is one person in the elevator, he wants to get to the floor number $5$. $p_{\text{up}}=0+0=0$, $p_{\text{down}}=0+1=1$, $p_{\text{up}}<p_{\text{down}}$. So the elevator goes to the floor number $5$.
\item $t=11$. The elevator is on the floor number $5$. One person leaves the elevator, this person initially wanted to get to the floor number $5$. The elevator is empty and nobody needs it, so the elevator remains at the floor number $5$.
\end{itemize}}
\BREAKDOWN{We must simulate a discrete-time elevator that, at each integer time, unloads at the current floor, boards all arriving or waiting people on this floor, then chooses direction by comparing counts above vs. below. We need to output each rider's delivery time. Direct per-second simulation is infeasible; we need an event-driven technique that jumps between floors/events while honoring new arrivals at exact times.}
\ELI{Treat each active person as a ``point'': if still waiting, at $s_i$; if onboard, at $f_i$. The elevator always moves toward the upper median of these points and only changes direction at floors that contain some point or when new people arrive.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case. First line: integers $n, m$ with $1\le n\le 10^5$, $2\le m\le 10^5$. Next $n$ lines: $t_i, s_i, f_i$ with $1\le t_i\le 10^9$, $1\le s_i,f_i\le m$, and $s_i\ne f_i$.}
\OUTPUTS{Print $n$ integers; the $i$-th line is the time when person $i$ reaches floor $f_i$.}
\SAMPLES{Example (from the narrative run): $n=3$, $m=8$ with lines $(1,2,7)$, $(3,4,8)$, $(6,6,5)$ should output times $7, 8, 11$. Another tiny case: $n=1$, $m=3$ with $(1,1,3)$ outputs $3$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{At any time $t\in\mathbb{Z}_{\ge 0}$, elevator at floor $x_t\in\{1,\ldots,m\}$. Let $A_t$ be the multiset of active points: for each person $i$ s.t. $t\ge t_i$ and not delivered, contribute $s_i$ if still waiting, else contribute $f_i$ if onboard. If $A_t=\varnothing$ the elevator rests; else it moves one floor toward the upper median $\operatorname{med}^+(A_t)$, after resolving unload/load at time $t$.}
\varmapStart
\var{n}{number of people}
\var{m}{number of floors}
\var{t_i}{arrival time of person $i$}
\var{s_i}{start floor of person $i$}
\var{f_i}{destination floor of person $i$}
\var{x_t}{elevator floor at time $t$}
\var{A_t}{multiset of active points at time $t$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{At integer time }t: \\
&\quad \text{Unload at }x_t:\ A_t \gets A_t \setminus \{f_i=f=x_t\}.\\
&\quad \text{Arrivals with }t_i=t:\ \text{if }s_i=x_t,\ A_t\text{ adds }f_i;\ \text{else }A_t\text{ adds }s_i.\\
&\quad \text{Board all waiting at }x_t:\ A_t\text{ replaces each }s_i=x_t\text{ with }f_i.\\[3pt]
&\quad \text{If }A_t=\varnothing,\ x_{t+1}=x_t;\ \text{else let }m_t=\operatorname{med}^+(A_t),\\
&\qquad x_{t+1}=x_t+\begin{cases}+1,& x_t\le m_t,\\ -1,& x_t>m_t.\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{All changes (unload/load) at time $t$ are instantaneous before the direction choice. The elevator capacity is unbounded. Times and floors are integers.}
\INVARIANTS{
\begin{itemize}
\item The elevator never skips unloading at the exact destination floor.
\item Points equal to the current floor do not remain in $A_t$ after unloading/loading at time $t$.
\item Between two consecutive floors with any active point, the chosen direction does not change (no state change occurs between them except time passing).
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct per-second simulation of the system definition: at each time $t$ and floor $x$, unload, board, compute $p_{\text{up}}$ and $p_{\text{down}}$ by scanning all floors and onboard passengers, then move by $\pm 1$.}
\ASSUMPTIONS{Intended for very small $n,m,t_i$ only; used for validation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep current time $t$, floor $x$, per-floor waiting lists, and onboard set.
\item At each integer time $t$: unload at $x$, add new arrivals, board all waiting at $x$, compute $p_{\text{up}}$ and $p_{\text{down}}$ by summing counts, decide direction, and move one floor or stay idle if no active people exist (fast-forward $t$ to next arrival).
\item Stop when all $n$ are delivered.
\end{algosteps}
\COMPLEXITY{For worst-case it is $O(T\cdot(m+n))$ where $T$ is the total number of time steps, impractical for large inputs but fine for tiny validation.}
\[
\begin{aligned}
T(n) &\approx \text{total travel time in seconds} \\
S(n) &= O(m+n)
\end{aligned}
\]
\CORRECTNESS{Implements the problem statement literally: correct by construction for small inputs.}
\EDGECASES{No arrivals yet (fast-forward), multiple arrivals at the same time and floor, tie-breaking when $p_{\text{up}}=p_{\text{down}}$ goes up.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, sys
from collections import defaultdict, deque

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip()
    it = iter(data.split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return 0, 0, [], [], []
    t = [0]*n; s = [0]*n; f = [0]*n
    for i in range(n):
        t[i] = int(next(it)); s[i] = int(next(it)); f[i] = int(next(it))
    return n, m, t, s, f

def solve_all():
    n, m, t, s, f = read_input()
    if n == 0:
        return
    ans = [-1]*n
    # Group arrivals by time
    arrivals = defaultdict(list)
    for i in range(n):
        arrivals[t[i]].append(i)
    waiting = [deque() for _ in range(m+1)]
    onboard = set()
    delivered = 0
    x = 1
    cur_t = 0
    # Fast-forward to first arrival
    future_times = sorted(arrivals.keys())
    ptr_time_idx = 0
    def next_arrival_time(after):
        nonlocal ptr_time_idx, future_times
        # Find first time >= after
        while ptr_time_idx < len(future_times) and future_times[ptr_time_idx] < after:
            ptr_time_idx += 1
        if ptr_time_idx < len(future_times):
            return future_times[ptr_time_idx]
        return None

    # For small validation only
    max_guard = 100000  # avoid infinite loops in accidental misuse
    guard = 0
    while delivered < n and guard < max_guard:
        guard += 1
        # Unload
        to_remove = []
        for i in list(onboard):
            if f[i] == x:
                ans[i] = cur_t
                to_remove.append(i)
        for i in to_remove:
            onboard.remove(i)
            delivered += 1
        # Arrivals at cur_t
        for i in arrivals.get(cur_t, []):
            if s[i] == x:
                onboard.add(i)
            else:
                waiting[s[i]].append(i)
        # Board
        while waiting[x]:
            i = waiting[x].popleft()
            onboard.add(i)
        # Decide direction
        total_wait = sum(len(waiting[fl]) for fl in range(1, m+1))
        total_on_up = sum(1 for i in onboard if f[i] > x)
        total_on_down = sum(1 for i in onboard if f[i] < x)
        up_wait = sum(len(waiting[fl]) for fl in range(x+1, m+1))
        down_wait = sum(len(waiting[fl]) for fl in range(1, x))
        pup = up_wait + total_on_up
        pdown = down_wait + total_on_down
        if len(onboard) == 0 and total_wait == 0:
            # Idle until next arrival
            nxt = next_arrival_time(cur_t+1)
            if nxt is None:
                break
            cur_t = nxt
            continue
        if pup >= pdown:
            x = min(m, x+1)
        else:
            x = max(1, x-1)
        cur_t += 1
    # Output (do not print in baseline; used in tests)
    out = "\n".join(str(v) for v in ans)
    sys.stdout.write(out)

def _run_baseline_on(data: str) -> str:
    from io import StringIO
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = StringIO(data)
        out_io = StringIO()
        sys.stdout = out_io
        solve_all()
        return out_io.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

def main():
    if sys.stdin.isatty():
        # Tiny sanity assert on handcrafted example from statement narrative
        data = "3 8\n1 2 7\n3 4 8\n6 6 5\n"
        out = _run_baseline_on(data)
        got = list(map(int, out.strip().split()))
        assert got == [7, 8, 11]
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Includes a tiny assert with the narrative example; suitable only for small cases due to brute-force nature.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Event-Driven Without Global Median}
\WHICHFORMULA{Jump over idle times: if no one is active (no waiting and no onboard), the elevator remains; we fast-forward time to the next arrival. Within active periods, still step by step, but arrivals are batched per time.}
\ASSUMPTIONS{Avoid per-time checks when idle; keep state per floor.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain per-floor waiting lists and onboard set.
\item If active set is empty, jump the clock to the next arrival time.
\item Otherwise, perform unload, batched arrivals, boarding, then move one floor by comparing $p_{\text{up}}$ and $p_{\text{down}}$; repeat.
\end{algosteps}
\COMPLEXITY{Beats pure brute force on inputs with large gaps in time. Still worst-case $O(T\cdot(m+n))$ in dense scenarios, but fewer iterations.}
\[
\begin{aligned}
T(n) &= \text{active seconds only (idle gaps skipped)}
\end{aligned}
\]
\CORRECTNESS{Same semantics as baseline; strictly fewer no-op iterations.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import defaultdict, deque

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip()
    it = iter(data.split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return 0, 0, [], [], []
    t = [0]*n; s = [0]*n; f = [0]*n
    for i in range(n):
        t[i] = int(next(it)); s[i] = int(next(it)); f[i] = int(next(it))
    return n, m, t, s, f

def solve_all():
    n, m, t, s, f = read_input()
    if n == 0:
        return
    ans = [-1]*n
    arrivals = defaultdict(list)
    for i in range(n):
        arrivals[t[i]].append(i)
    waiting = [deque() for _ in range(m+1)]
    onboard = set()
    delivered = 0
    x = 1
    cur_t = 0

    all_times = sorted(arrivals.keys())
    time_idx = 0

    def advance_to_next_arrival(after_t):
        nonlocal time_idx
        # Move time index to first >= after_t
        lo, hi = time_idx, len(all_times)
        while lo < hi:
            mid = (lo+hi)//2
            if all_times[mid] < after_t:
                lo = mid + 1
            else:
                hi = mid
        time_idx = lo
        return all_times[time_idx] if time_idx < len(all_times) else None

    while delivered < n:
        # Unload
        drop = [i for i in onboard if f[i] == x]
        if drop:
            for i in drop:
                onboard.remove(i)
                ans[i] = cur_t
                delivered += 1
        # Arrivals
        if cur_t in arrivals:
            for i in arrivals[cur_t]:
                if s[i] == x:
                    onboard.add(i)
                else:
                    waiting[s[i]].append(i)
        # Board
        while waiting[x]:
            onboard.add(waiting[x].popleft())
        # If no active, fast-forward to next arrival time
        if not onboard and all(len(waiting[fl]) == 0 for fl in range(1, m+1)):
            nxt = advance_to_next_arrival(cur_t+1)
            if nxt is None:
                break
            cur_t = nxt
            continue
        # Compute priorities
        up_wait = sum(len(waiting[fl]) for fl in range(x+1, m+1))
        down_wait = sum(len(waiting[fl]) for fl in range(1, x))
        up_on = sum(1 for i in onboard if f[i] > x)
        down_on = sum(1 for i in onboard if f[i] < x)
        pup = up_wait + up_on
        pdown = down_wait + down_on
        if pup >= pdown:
            x = min(m, x+1)
        else:
            x = max(1, x-1)
        cur_t += 1

    sys.stdout.write("\n".join(map(str, ans)))

def _run_improved_on(data: str) -> str:
    from io import StringIO
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = StringIO(data)
        out_io = StringIO()
        sys.stdout = out_io
        solve_all()
        return out_io.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

def main():
    if sys.stdin.isatty():
        # Deterministic small-case assert
        data = "3 8\n1 2 7\n3 4 8\n6 6 5\n"
        got = list(map(int, _run_improved_on(data).strip().split()))
        assert got == [7, 8, 11]
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Includes the narrative example assert.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Median-Chasing with Event Skips}
\WHICHFORMULA{Represent each active person by a point: waiting contributes $s_i$, onboard contributes $f_i$. The elevator moves toward the upper median $\operatorname{med}^+$ of these points. State changes only at floors containing some point or at new arrival times. Maintain:
(1) a dynamic median with two heaps and lazy deletions,
(2) two heaps of event floors (upward and downward) with lazy invalidation,
(3) per-floor buckets for waiting and onboard-by-destination to transform/remove points at visits.
Jump the elevator by $\min($distance to next event floor in the chosen direction$, $time$ $to$ $next$ $arrival$)$.}
\ASSUMPTIONS{Upper-median direction matches $p_{\text{up}}\ge p_{\text{down}}$ tie-breaking. No point remains equal to current floor after unload/load at time $t$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort all arrivals by time. Initialize $t=0$, $x=1$, active multiset empty.
\item At each time $t$ at floor $x$: unload $f_i=x$ (remove their $f_i$ from the median, record answers); insert arrivals at time $t$ ($s_i=x$ go straight onboard as $f_i$, others as $s_i$); board all waiting at $x$ (replace $s_i$ with $f_i$).
\item If no active points, fast-forward $t$ to the next arrival. Else compute $m_t=\operatorname{med}^+$; set direction up iff $x\le m_t$.
\item Let $y$ be the nearest event floor in that direction (minimum $>x$ or maximum $<x$ among floors with active waiting/destination). Move by $s=\min(|y-x|,\ \text{time until next arrival})$, i.e., $x\gets x+\text{dir}\cdot s$, $t\gets t+s$, and repeat.
\end{algosteps}
\OPTIMALITY{Each jump crosses only empty floors with no state change, and arrivals are the only time-indexed interruptions. Each person causes $O(1)$ median updates plus two event-floor on/off transitions. Total time is $O((n+m)\log(n+m))$ in practice.}
\COMPLEXITY{Median/events updates are $O(\log n)$ per insert/delete; each person is processed a constant number of times.}
\[
\begin{aligned}
T(n) &= O\big((n + K)\log(n+K)\big)\ \text{with }K\text{ event-floor toggles}\ (\le 2n),\\
S(n) &= O(n+m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
import heapq
from collections import defaultdict, deque

INF = 10**30

class Median:
    # Upper-median maintainer with two heaps and lazy deletion.
    def __init__(self):
        self.lo = []     # max-heap (store as negatives)
        self.hi = []     # min-heap
        self.size_lo = 0
        self.size_hi = 0
        self.delmap = defaultdict(int)  # value -> how many to delete lazily

    def _clean_top(self, heap, is_hi):
        # Pop while top is marked deleted.
        while heap:
            v = heap[0] if is_hi else -heap[0]
            if self.delmap.get(v, 0) > 0:
                self.delmap[v] -= 1
                if self.delmap[v] == 0:
                    del self.delmap[v]
                heapq.heappop(heap)
            else:
                break

    def _fix(self):
        self._clean_top(self.hi, True)
        self._clean_top(self.lo, False)

    def _rebalance(self):
        self._fix()
        # Ensure hi has >= lo and at most +1 more
        while self.size_hi < self.size_lo:
            # move from lo to hi
            self._clean_top(self.lo, False)
            v = -heapq.heappop(self.lo)
            heapq.heappush(self.hi, v)
            self.size_lo -= 1
            self.size_hi += 1
            self._fix()
        while self.size_hi > self.size_lo + 1:
            # move from hi to lo
            self._clean_top(self.hi, True)
            v = heapq.heappop(self.hi)
            heapq.heappush(self.lo, -v)
            self.size_hi -= 1
            self.size_lo += 1
            self._fix()

    def add(self, v: int):
        # Put into proper heap
        self._fix()
        if self.size_hi == 0:
            heapq.heappush(self.hi, v); self.size_hi += 1
        else:
            self._fix()
            # Compare to current upper median
            med = self.median()
            if v >= med:
                heapq.heappush(self.hi, v); self.size_hi += 1
            else:
                heapq.heappush(self.lo, -v); self.size_lo += 1
        self._rebalance()

    def remove(self, v: int):
        # Mark for lazy deletion; adjust sizes by side decision using current median
        self._fix()
        if self.size_hi + self.size_lo == 0:
            return
        med = self.median()
        if v >= med:
            self.size_hi -= 1
        else:
            self.size_lo -= 1
        self.delmap[v] += 1
        self._rebalance()

    def median(self) -> int:
        self._fix()
        if self.size_hi == 0:
            # Should not happen if nonempty; fallback
            if self.lo:
                return -self.lo[0]
            return 0
        return self.hi[0]

    def size(self) -> int:
        return self.size_lo + self.size_hi

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip()
    it = iter(data.split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return 0, 0, [], [], []
    t = [0]*n; s = [0]*n; f = [0]*n
    for i in range(n):
        t[i] = int(next(it)); s[i] = int(next(it)); f[i] = int(next(it))
    return n, m, t, s, f

def solve_all():
    n, m, t, s, f = read_input()
    if n == 0:
        return
    # Sort arrivals by time; keep original indices
    order = sorted(range(n), key=lambda i: t[i])
    ptr = 0
    # Per-floor containers
    waiting = [deque() for _ in range(m+2)]
    onboard_by_dest = [deque() for _ in range(m+2)]
    wait_cnt = [0]*(m+2)
    dest_cnt = [0]*(m+2)
    has_event = [False]*(m+2)  # True iff wait_cnt+dest_cnt > 0
    up_heap = []   # min-heap of floors (candidate event floors for upwards)
    down_heap = [] # max-heap via negatives (candidate event floors for downwards)

    def event_on(fl):
        if not has_event[fl]:
            has_event[fl] = True
            heapq.heappush(up_heap, fl)
            heapq.heappush(down_heap, -fl)

    def event_off_if_empty(fl):
        if wait_cnt[fl] + dest_cnt[fl] == 0 and has_event[fl]:
            has_event[fl] = False
            # lazy removal: leave in heaps; they will be skipped

    def next_up(x):
        while up_heap:
            y = up_heap[0]
            if y <= x or not has_event[y]:
                heapq.heappop(up_heap)
                continue
            return y
        return None

    def next_down(x):
        while down_heap:
            y = -down_heap[0]
            if y >= x or not has_event[y]:
                heapq.heappop(down_heap)
                continue
            return y
        return None

    ans = [-1]*n
    delivered = 0
    x = 1
    cur_t = 0
    med = Median()

    # convenience: process arrivals at time cur_t
    def process_arrivals_at_time(tnow, cur_x):
        nonlocal ptr
        while ptr < n and t[order[ptr]] == tnow:
            i = order[ptr]
            si, fi = s[i], f[i]
            if si == cur_x:
                # immediate boarding: add destination point/event
                onboard_by_dest[fi].append(i)
                dest_cnt[fi] += 1
                med.add(fi)
                event_on(fi)
            else:
                waiting[si].append(i)
                wait_cnt[si] += 1
                med.add(si)
                event_on(si)
            ptr += 1

    while delivered < n:
        # 1) Unload at current floor
        if onboard_by_dest[x]:
            while onboard_by_dest[x]:
                i = onboard_by_dest[x].popleft()
                ans[i] = cur_t
                delivered += 1
                med.remove(f[i])
                dest_cnt[x] -= 1
            event_off_if_empty(x)

        # 2) Arrivals at current time (affect priorities immediately)
        process_arrivals_at_time(cur_t, x)

        # 3) Board all waiting at current floor: replace s_i=x with f_i
        if waiting[x]:
            while waiting[x]:
                i = waiting[x].popleft()
                med.remove(x)  # remove waiting point
                wait_cnt[x] -= 1
                # Add destination point
                onboard_by_dest[f[i]].append(i)
                dest_cnt[f[i]] += 1
                med.add(f[i])
                event_on(f[i])
            event_off_if_empty(x)

        # 4) If no active, idle until next arrival
        if med.size() == 0:
            if ptr < n:
                cur_t = t[order[ptr]]
                continue
            else:
                break

        # 5) Choose direction by upper median
        mval = med.median()
        dir_up = (x <= mval)

        # 6) Find nearest event floor in the chosen direction
        y = next_up(x) if dir_up else next_down(x)
        # There must be one because med.size()>0 implies at least one active point
        assert y is not None
        d_event = abs(y - x)
        # 7) Bound by next arrival time
        next_time = t[order[ptr]] if ptr < n else INF
        d_time = next_time - cur_t
        # 8) Move by the minimum bound
        step = d_event if d_event < d_time else d_time
        # Safety: step must be >= 1 unless we just processed a state change
        if step == 0:
            # To avoid stalling (can happen if y == x due to simultaneous on/off normalization),
            # advance one time unit toward the median.
            step = 1
        x += (1 if dir_up else -1) * step
        if x < 1:
            x = 1
        if x > m:
            x = m
        cur_t += step

    sys.stdout.write("\n".join(map(str, ans)))

# ---------------- Tests & Runner ----------------

def _run_solver_on(data: str) -> str:
    from io import StringIO
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = StringIO(data)
        out_io = StringIO()
        sys.stdout = out_io
        solve_all()
        return out_io.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

def _baseline_for_check(data: str) -> str:
    # Tiny baseline to cross-check on very small cases.
    from collections import defaultdict, deque
    n, m, tt, ss, ff = read_input(data)
    arrivals = defaultdict(list)
    for i in range(n):
        arrivals[tt[i]].append(i)
    waiting = [deque() for _ in range(m+1)]
    onboard = set()
    ans = [-1]*n
    delivered = 0
    x = 1
    cur_t = 0
    times = sorted(arrivals.keys())
    idx = 0
    def next_arrival(after):
        nonlocal idx
        while idx < len(times) and times[idx] < after:
            idx += 1
        return times[idx] if idx < len(times) else None
    guard = 0
    while delivered < n and guard < 20000:
        guard += 1
        # unload
        for i in list(onboard):
            if ff[i] == x:
                ans[i] = cur_t
                onboard.remove(i)
                delivered += 1
        # arrivals
        for i in arrivals.get(cur_t, []):
            if ss[i] == x:
                onboard.add(i)
            else:
                waiting[ss[i]].append(i)
        # board
        while waiting[x]:
            onboard.add(waiting[x].popleft())
        # move or idle
        total_wait = sum(len(waiting[fl]) for fl in range(1, m+1))
        if not onboard and total_wait == 0:
            nxt = next_arrival(cur_t+1)
            if nxt is None: break
            cur_t = nxt
            continue
        pup = sum(len(waiting[fl]) for fl in range(x+1, m+1)) + sum(1 for i in onboard if ff[i] > x)
        pdown = sum(len(waiting[fl]) for fl in range(1, x)) + sum(1 for i in onboard if ff[i] < x)
        if pup >= pdown:
            x = min(m, x+1)
        else:
            x = max(1, x-1)
        cur_t += 1
    return "\n".join(map(str, ans)) + ("\n" if n else "")

def main():
    if sys.stdin.isatty():
        # Deterministic example from problem narrative:
        data = "3 8\n1 2 7\n3 4 8\n6 6 5\n"
        out = _run_solver_on(data).strip().split()
        assert list(map(int, out)) == [7, 8, 11]
        # Random small cross-checks vs. baseline
        import random
        random.seed(0)
        for _ in range(30):
            m = random.randint(2, 7)
            n = random.randint(1, 5)
            items = []
            for i in range(n):
                ti = random.randint(1, 10)
                si = random.randint(1, m)
                fi = random.randint(1, m)
                while fi == si:
                    fi = random.randint(1, m)
                items.append((ti, si, fi))
            sdata = [f"{n} {m}"] + [f"{ti} {si} {fi}" for (ti, si, fi) in items]
            sdata = "\n".join(sdata) + "\n"
            got = _run_solver_on(sdata)
            ref = _baseline_for_check(sdata)
            assert got == ref, (sdata, got, ref)
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Includes: (1) a deterministic assert with the narrative example; (2) randomized cross-checks against a baseline on tiny cases; (3) safety against stalling states.}
\RESULT{For each person $i$, the printed time is the first integer time $t$ such that the elevator is at floor $f_i$ at time $t$. Ties in priority are resolved upward as required.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests: narrative example; randomized tiny cases compared to a brute-force simulator; edge cases with simultaneous arrivals at current floor; all riders going same direction.}
\LINE{CROSS-CHECKS}{Approach A vs. Approach C on small random instances to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate random $m\in[2,7]$, $n\in[1,5]$, $t_i\in[1,10]$, $s_i,f_i\in[1,m]$, $s_i\ne f_i$. Covers simultaneous arrivals and tie situations.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_case_small(seed=1):
    random.seed(seed)
    m = random.randint(2, 7)
    n = random.randint(1, 5)
    items = []
    for _ in range(n):
        ti = random.randint(1, 10)
        si = random.randint(1, m)
        fi = random.randint(1, m)
        while fi == si:
            fi = random.randint(1, m)
        items.append((ti, si, fi))
    lines = [f"{n} {m}"] + [f"{ti} {si} {fi}" for (ti, si, fi) in items]
    return "\n".join(lines) + "\n"

def run_and_compare():
    from io import StringIO
    import sys as _sys
    from collections import defaultdict, deque

    def run_final(inp):
        import sys
        backup_stdin, backup_stdout = sys.stdin, sys.stdout
        try:
            sys.stdin = StringIO(inp)
            out_io = StringIO()
            sys.stdout = out_io
            # import from Approach C cell not feasible here; placeholder for conceptual run
            return out_io.getvalue()
        finally:
            sys.stdin, sys.stdout = backup_stdin, backup_stdout

    # Placeholder: in-sheet we validated already in Approach C.
    return True

if __name__ == "__main__":
    # Example crafted input consistent with narrative
    example = "3 8\n1 2 7\n3 4 8\n6 6 5\n"
    # This section is a reference scaffold; main asserts live in Approach C code.
    pass
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
import sys
import heapq
from collections import defaultdict, deque

INF = 10**30

class Median:
    def __init__(self):
        self.lo = []     # max-heap (negatives)
        self.hi = []     # min-heap
        self.size_lo = 0
        self.size_hi = 0
        self.delmap = defaultdict(int)

    def _clean_top(self, heap, is_hi):
        while heap:
            v = heap[0] if is_hi else -heap[0]
            if self.delmap.get(v, 0) > 0:
                self.delmap[v] -= 1
                if self.delmap[v] == 0:
                    del self.delmap[v]
                heapq.heappop(heap)
            else:
                break

    def _fix(self):
        self._clean_top(self.hi, True)
        self._clean_top(self.lo, False)

    def _rebalance(self):
        self._fix()
        while self.size_hi < self.size_lo:
            self._clean_top(self.lo, False)
            v = -heapq.heappop(self.lo)
            heapq.heappush(self.hi, v)
            self.size_lo -= 1
            self.size_hi += 1
            self._fix()
        while self.size_hi > self.size_lo + 1:
            self._clean_top(self.hi, True)
            v = heapq.heappop(self.hi)
            heapq.heappush(self.lo, -v)
            self.size_hi -= 1
            self.size_lo += 1
            self._fix()

    def add(self, v: int):
        self._fix()
        if self.size_hi == 0:
            heapq.heappush(self.hi, v); self.size_hi += 1
        else:
            med = self.median()
            if v >= med:
                heapq.heappush(self.hi, v); self.size_hi += 1
            else:
                heapq.heappush(self.lo, -v); self.size_lo += 1
        self._rebalance()

    def remove(self, v: int):
        self._fix()
        if self.size_lo + self.size_hi == 0:
            return
        med = self.median()
        if v >= med:
            self.size_hi -= 1
        else:
            self.size_lo -= 1
        self.delmap[v] += 1
        self._rebalance()

    def median(self) -> int:
        self._fix()
        if self.size_hi == 0:
            return -self.lo[0] if self.lo else 0
        return self.hi[0]

    def size(self) -> int:
        return self.size_lo + self.size_hi

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip()
    it = iter(data.split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return 0, 0, [], [], []
    t = [0]*n; s = [0]*n; f = [0]*n
    for i in range(n):
        t[i] = int(next(it)); s[i] = int(next(it)); f[i] = int(next(it))
    return n, m, t, s, f

def solve_all():
    n, m, t, s, f = read_input()
    if n == 0:
        return
    order = sorted(range(n), key=lambda i: t[i])
    ptr = 0
    waiting = [deque() for _ in range(m+2)]
    onboard_by_dest = [deque() for _ in range(m+2)]
    wait_cnt = [0]*(m+2)
    dest_cnt = [0]*(m+2)
    has_event = [False]*(m+2)
    up_heap = []
    down_heap = []

    def event_on(fl):
        if not has_event[fl]:
            has_event[fl] = True
            heapq.heappush(up_heap, fl)
            heapq.heappush(down_heap, -fl)

    def event_off_if_empty(fl):
        if wait_cnt[fl] + dest_cnt[fl] == 0 and has_event[fl]:
            has_event[fl] = False

    def next_up(x):
        while up_heap:
            y = up_heap[0]
            if y <= x or not has_event[y]:
                heapq.heappop(up_heap)
                continue
            return y
        return None

    def next_down(x):
        while down_heap:
            y = -down_heap[0]
            if y >= x or not has_event[y]:
                heapq.heappop(down_heap)
                continue
            return y
        return None

    ans = [-1]*n
    delivered = 0
    x = 1
    cur_t = 0
    med = Median()

    def process_arrivals_at_time(tnow, cur_x):
        nonlocal ptr
        while ptr < n and t[order[ptr]] == tnow:
            i = order[ptr]
            si, fi = s[i], f[i]
            if si == cur_x:
                onboard_by_dest[fi].append(i)
                dest_cnt[fi] += 1
                med.add(fi)
                event_on(fi)
            else:
                waiting[si].append(i)
                wait_cnt[si] += 1
                med.add(si)
                event_on(si)
            ptr += 1

    while delivered < n:
        # unload
        if onboard_by_dest[x]:
            while onboard_by_dest[x]:
                i = onboard_by_dest[x].popleft()
                ans[i] = cur_t
                delivered += 1
                med.remove(f[i])
                dest_cnt[x] -= 1
            event_off_if_empty(x)
        # arrivals
        process_arrivals_at_time(cur_t, x)
        # board
        if waiting[x]:
            while waiting[x]:
                i = waiting[x].popleft()
                med.remove(x)
                wait_cnt[x] -= 1
                onboard_by_dest[f[i]].append(i)
                dest_cnt[f[i]] += 1
                med.add(f[i])
                event_on(f[i])
            event_off_if_empty(x)
        # idle if no active
        if med.size() == 0:
            if ptr < n:
                cur_t = t[order[ptr]]
                continue
            else:
                break
        # choose direction
        mval = med.median()
        dir_up = (x <= mval)
        # next event
        y = next_up(x) if dir_up else next_down(x)
        assert y is not None
        d_event = abs(y - x)
        next_time = t[order[ptr]] if ptr < n else INF
        d_time = next_time - cur_t
        step = d_event if d_event < d_time else d_time
        if step == 0:
            step = 1
        x += (1 if dir_up else -1) * step
        if x < 1: x = 1
        if x > m: x = m
        cur_t += step

    sys.stdout.write("\n".join(map(str, ans)))

def _run_on(data: str) -> str:
    from io import StringIO
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = StringIO(data)
        out_io = StringIO()
        sys.stdout = out_io
        solve_all()
        return out_io.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

def main():
    if sys.stdin.isatty():
        # Narrative example
        data = "3 8\n1 2 7\n3 4 8\n6 6 5\n"
        got = list(map(int, _run_on(data).strip().split()))
        assert got == [7, 8, 11]
        # Tiny randomized cross-check vs. a naive reference embedded in Approach C
        import random
        random.seed(1)
        for _ in range(20):
            m = random.randint(2, 7)
            n = random.randint(1, 5)
            items = []
            for i in range(n):
                ti = random.randint(1, 10)
                si = random.randint(1, m)
                fi = random.randint(1, m)
                while fi == si:
                    fi = random.randint(1, m)
                items.append((ti, si, fi))
            sdata = [f"{n} {m}"] + [f"{ti} {si} {fi}" for (ti, si, fi) in items]
            sdata = "\n".join(sdata) + "\n"
            out = _run_on(sdata)
            # No baseline here to avoid duplication; sanity: outputs are n lines
            assert len(out.strip().split()) == n
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Simulate an elevator that always moves toward the upper median of active points (waiting floors or destinations), jumping between event floors and respecting arrivals at exact times.}
\WHY{Tests ability to transform a simulation into an event-driven process and to maintain medians with lazy deletions and multiple priority queues.}
\CHECKLIST{
\begin{itemize}
\item Replace waiting $s_i=x$ with destination $f_i$ before deciding direction at time $t$.
\item Unload before boarding.
\item Include arrivals at time $t$ everywhere in $p_{\text{up}}/p_{\text{down}}$ (or median) computation.
\item Move by $\min($next event distance$, $time$ $to$ $next$ $arrival$)$.
\item Use upper median to model ``go up on tie''.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item No active people: elevator idles until next arrival.
\item Many arrivals at the same time and floor as the elevator: they board immediately.
\item All active points on one side: nearest event must exist in that direction.
\item Floors toggling between waiting and destination multiple times.
\item Arrivals occurring exactly when reaching an event floor.
\item Duplicate floors in events/heaps; ensure lazy invalidation.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Forgetting to process arrivals at time $t$ before computing direction.
\item Keeping points equal to current floor in the active multiset after boarding/unloading.
\item Incorrect median deletion side with duplicates; bias deletions to the upper side.
\item Not lazily invalidating event floors; heaps may hold stale entries.
\item Off-by-one when selecting next event ($>$ or $<$ the current floor).
\item Stalling when both next event distance and time gap are zero; guard with a single-step advance.
\end{itemize}}
\FAILMODES{Pure per-second simulation times out. Ignoring arrivals at other floors at time $t$ causes wrong direction. Using a single heap without direction-specific event heaps makes finding the next event expensive.}
\ELI{Think of all active riders as pins on a ruler: if waiting, pin at their start; if onboard, pin at their destination. Each tick, the elevator unloads/loads at its spot, then moves one step toward the upper median pin. We only need to stop at pins or when new pins appear at some time.}
\NotePages{3}

\end{document}