% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Factorial zeros}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/162/F}}
\LINE{DIFFICULTY / RATING}{1800}
\STATEMENT{You are given a positive integer $n$. Output the number of trailing zeros in $n!$ (here $n!$ denotes the product of integers between $1$ and $n$, inclusive).

Input: The only line of input contains an integer $n$ ($1 \le n \le 1{,}000{,}000$).

Output: Output the number of trailing zeros in $n!$.

Note: In the first sample $6! = 720$.

In the second sample $24! = 620448401733239439360000$.}
\BREAKDOWN{Compute the exponent of $10$ in $n!$, which is $\min\{v_2(n!), v_5(n!)\}$. Since $v_2(n!) \ge v_5(n!)$, count the total number of factors of $5$ in $n!$.}
\ELI{Every trailing zero needs a factor $10 = 2 \times 5$, and fives are rarer than twos, so just count how many fives appear in $n!$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $n$ with $1 \le n \le 1{,}000{,}000$.}
\OUTPUTS{A single integer: the number of trailing zeros in $n!$. No extra spaces or lines.}
\SAMPLES{Example 1: input ``6'' $\rightarrow$ output ``1''. Example 2: input ``24'' $\rightarrow$ output ``4''.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n \in \mathbb{Z}_{\ge 1}$. Let $v_p(m)$ denote the exponent of prime $p$ in the prime factorization of $m$. The number of trailing zeros in $n!$ equals $v_{10}(n!) = \min\{v_2(n!), v_5(n!)\} = v_5(n!)$.}
\varmapStart
\var{n}{input integer}
\var{v_p(m)}{exponent of prime $p$ in $m$}
\var{z(n)}{number of trailing zeros in $n!$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
z(n) = v_5(n!) = \sum_{k=1}^{\infty} \left\lfloor \frac{n}{5^k} \right\rfloor,
\end{BreakableEquation*}
where the sum is finite since $\left\lfloor \dfrac{n}{5^k} \right\rfloor = 0$ for $5^k > n$.
}
\ASSUMPTIONS{Standard integer arithmetic; $n$ within bounds ensures all computations fit in $64$-bit integers.}
\INVARIANTS{The partial sum $\sum_{k=1}^{t} \left\lfloor \tfrac{n}{5^k} \right\rfloor$ is nondecreasing in $t$ and stabilizes once $5^t > n$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Count factors of $5$ contributed by each $i \in \{1,\ldots,n\}$ by repeatedly dividing $i$ by $5$ while divisible.}
\ASSUMPTIONS{Iterate all numbers up to $n$; perform integer divisions only.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $ans \leftarrow 0$.
\item For each $i$ from $1$ to $n$:
  \begin{bullets}
  \item Set $x \leftarrow i$; while $x \bmod 5 = 0$, increment $ans$ and set $x \leftarrow \tfrac{x}{5}$.
  \end{bullets}
\item Output $ans$.
\end{algosteps}
\COMPLEXITY{Worst-case $T(n) = \Theta(n \log_5 n)$ divisions; $S(n) = O(1)$.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} O\!\big(\text{times }5\text{ divides }i\big) \\
     &= O\!\left(\sum_{k \ge 1} \left\lfloor \frac{n}{5^k} \right\rfloor\right) = O(n).
\end{aligned}
\]
\CORRECTNESS{Each multiple of $5$ contributes at least one factor $5$, each multiple of $25$ contributes an extra factor, etc.; summing per-integer contributions equals $v_5(n!)$.}
\EDGECASES{$n<5 \Rightarrow 0$; $n=5 \Rightarrow 1$; powers of $5$ such as $25,125$ add extra counts.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return [int(x) for x in data]

def factors_of_five_up_to(n: int) -> int:
    ans = 0
    for i in range(1, n + 1):
        x = i
        while x % 5 == 0:
            ans += 1
            x //= 5
    return ans

def solve_case(n: int) -> int:
    return factors_of_five_up_to(n)

def solve_all(nums):
    return [solve_case(n) for n in nums]

def _self_test():
    assert solve_case(6) == 1
    assert solve_case(24) == 4
    assert solve_case(100) == 24

def main():
    nums = read_input()
    if not nums:
        _self_test()
        return
    res = solve_all(nums)
    # CF problem expects a single integer; if multiple provided, print all lines.
    if len(res) == 1:
        sys.stdout.write(str(res[0]))
    else:
        sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Quick checks: $6 \mapsto 1$, $24 \mapsto 4$, $100 \mapsto 24$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Summation via Powers of Five}
\WHICHFORMULA{Use $z(n)=\sum_{k \ge 1}\left\lfloor \tfrac{n}{5^k}\right\rfloor$ and loop over $k$ until $5^k>n$. This skips scanning all $i \le n$.}
\ASSUMPTIONS{Integer division; loop length is $O(\log_5 n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $ans \leftarrow 0$, $p \leftarrow 5$.
\item While $p \le n$: add $\left\lfloor \tfrac{n}{p} \right\rfloor$ to $ans$ and set $p \leftarrow 5p$.
\item Output $ans$.
\end{algosteps}
\COMPLEXITY{$T(n)=\Theta(\log_5 n)$ divisions and multiplications; $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= \left\lfloor \log_5 n \right\rfloor + O(1).
\end{aligned}
\]
\CORRECTNESS{Each term counts how many numbers contribute at least $k$ copies of $5$; summing over $k$ counts all factor-$5$ contributions exactly once.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return [int(x) for x in data]

def trailing_zeros_sum_powers(n: int) -> int:
    ans = 0
    p = 5
    while p <= n:
        ans += n // p
        p *= 5
    return ans

def solve_case(n: int) -> int:
    return trailing_zeros_sum_powers(n)

def solve_all(nums):
    return [solve_case(n) for n in nums]

def _self_test():
    assert solve_case(6) == 1
    assert solve_case(24) == 4
    assert solve_case(100) == 24

def main():
    nums = read_input()
    if not nums:
        _self_test()
        return
    res = solve_all(nums)
    if len(res) == 1:
        sys.stdout.write(str(res[0]))
    else:
        sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge checks: $1 \mapsto 0$, $5 \mapsto 1$, $25 \mapsto 6$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divide-and-Accumulate v\_5 via n //= 5 loop}
\WHICHFORMULA{Accumulate $n \leftarrow \left\lfloor \tfrac{n}{5} \right\rfloor$ and add to $ans$ until $n=0$. This computes the same sum without tracking powers explicitly.}
\ASSUMPTIONS{Works for all $n \ge 1$; requires only integer division and addition.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $ans \leftarrow 0$.
\item While $n > 0$: set $n \leftarrow \left\lfloor \tfrac{n}{5} \right\rfloor$ and $ans \leftarrow ans + n$.
\item Output $ans$.
\end{algosteps}
\OPTIMALITY{The loop runs exactly $\left\lfloor \log_5 n \right\rfloor + 1$ iterations, which matches the information-theoretic minimum to identify all nonzero terms in the sum; time and space are asymptotically optimal among exact methods.}
\COMPLEXITY{$T(n)=\Theta(\log n)$, $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= \left\lfloor \log_5 n \right\rfloor + 1.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return [int(x) for x in data]

def solve_case(n: int) -> int:
    ans = 0
    while n > 0:
        n //= 5
        ans += n
    return ans

def solve_all(nums):
    return [solve_case(n) for n in nums]

def _self_test():
    assert solve_case(6) == 1
    assert solve_case(24) == 4
    assert solve_case(100) == 24

def main():
    nums = read_input()
    if not nums:
        _self_test()
        return
    res = solve_all(nums)
    if len(res) == 1:
        sys.stdout.write(str(res[0]))
    else:
        sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Assertions: $6 \to 1$, $24 \to 4$, $100 \to 24$.}
\RESULT{Print the integer $v_5(n!)$, the number of trailing zeros in $n!$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test known values: small $n$ ($1..30$), powers of five ($5, 25, 125$), random values; compare implementations A, B, and C for equality.}
\LINE{CROSS-CHECKS}{On a grid of $n \in \{1,2,\ldots,200\}$, verify A, B, C yield identical outputs; spot-check $n=10^k$ for $k\le 6$.}
\LINE{EDGE-CASE GENERATOR}{Generate $n \in \{1,4,5,24,25,99,100,10^6\}$ to cover no-fives, single-five, multiple fives, and upper bound.}
\begin{minted}{python}
import random

def gen_edges():
    return [1, 2, 3, 4, 5, 6, 24, 25, 99, 100, 10**6]

def brute(n):
    ans = 0
    for i in range(1, n + 1):
        x = i
        while x % 5 == 0:
            ans += 1
            x //= 5
    return ans

def fast(n):
    ans = 0
    while n:
        n //= 5
        ans += n
    return ans

def test_cross():
    # Deterministic checks
    for n in gen_edges():
        assert brute(n) == fast(n)
    # Random checks
    rng = random.Random(0)
    for _ in range(200):
        n = rng.randint(1, 10**6)
        assert brute(n) == fast(n)

if __name__ == "__main__":
    test_cross()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return [int(x) for x in data]

def solve_case(n: int) -> int:
    ans = 0
    while n > 0:
        n //= 5
        ans += n
    return ans

def solve_all(nums):
    return [solve_case(n) for n in nums]

def _self_test():
    assert solve_case(5) == 1
    assert solve_case(25) == 6
    assert solve_case(10**6) == 249998

def main():
    nums = read_input()
    if not nums:
        _self_test()
        return
    res = solve_all(nums)
    if len(res) == 1:
        sys.stdout.write(str(res[0]))
    else:
        sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Trailing zeros in $n!$ equal $v_5(n!) = \sum_{k \ge 1} \left\lfloor \tfrac{n}{5^k} \right\rfloor$.}
\WHY{Classic interview/combinatorics task testing understanding of prime exponents and counting multiples.}
\CHECKLIST{
\begin{bullets}
\item Identify that zeros come from pairs $(2,5)$.
\item Realize $v_2(n!) \ge v_5(n!)$; only count fives.
\item Use the division loop $n \leftarrow \left\lfloor \tfrac{n}{5} \right\rfloor$ accumulating the sum.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n<5 \Rightarrow 0$.
\item $n=5 \Rightarrow 1$.
\item $n=10 \Rightarrow 2$.
\item $n=25 \Rightarrow 6$ (extra from $25$).
\item $n=100 \Rightarrow 24$.
\item $n=1{,}000{,}000 \Rightarrow 249{,}998$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Computing $n!$ explicitly overflows and is unnecessary.
\item Forgetting higher powers like $25, 125,\ldots$ leading to undercount.
\item Off-by-one: stopping before $n$ becomes $0$ in the loop.
\item Using floating division instead of integer division.
\item Mishandling I/O when no input is present during self-tests.
\item Printing extra whitespace or lines in CF submission.
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item Brute factorial construction fails for large $n$ due to time/space.
\item Single-pass counting of multiples of $5$ only (without higher powers) undercounts.
\item Looping to $n$ is too slow if used inside tighter constraints; $\Theta(\log n)$ method survives.
\end{bullets}
}
\ELI{Zeros at the end of $n!$ come from multiplying by $10$s. There are plenty of $2$s, so just count how many $5$s appear in all the numbers from $1$ to $n$. Add $n//5$, then $n//25$, and so on, until it becomes $0$.}
\NotePages{3}

\end{document}