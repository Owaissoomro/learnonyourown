% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Count Odd Numbers in an Interval Range}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given two non-negative integers \texttt{low} and \texttt{high}, return the count of odd integers between \texttt{low} and \texttt{high} (inclusive).

Example 1:

Input: \texttt{low = 3}, \texttt{high = 7}

Output: \texttt{3}

Explanation: The odd numbers between 3 and 7 are [3, 5, 7].

Example 2:

Input: \texttt{low = 8}, \texttt{high = 10}

Output: \texttt{1}

Explanation: The odd numbers between 8 and 10 are [9].

Constraints:
\begin{itemize}
\item $0 \le \texttt{low} \le \texttt{high} \le 10^9$.
\end{itemize}}
\BREAKDOWN{We need a function that, given bounds $[\texttt{low}, \texttt{high}]$, returns the number of odd integers in that inclusive interval. A direct loop works but is linear; an $O(1)$ arithmetic formula exists using floor division or parity adjustment.}
\ELI{Half of any long run of integers are odd; add one more if both ends are odd.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers \texttt{low}, \texttt{high} with $0 \le \texttt{low} \le \texttt{high} \le 10^9$.}
\OUTPUTS{An integer equal to the number of odd integers $x$ such that $\texttt{low} \le x \le \texttt{high}$.}
\SAMPLES{Examples (function-call style):
\begin{itemize}
\item \texttt{countOdds(3, 7)} $\to$ \texttt{3}.
\item \texttt{countOdds(8, 10)} $\to$ \texttt{1}.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given integers $l, r \in \mathbb{Z}$ with $0 \le l \le r \le 10^9$, compute the cardinality of the set $\{x \in \mathbb{Z} \mid l \le x \le r,\ x \equiv 1 \pmod 2\}$.}
\varmapStart
\var{l}{the inclusive lower bound (maps to \texttt{low})}
\var{r}{the inclusive upper bound (maps to \texttt{high})}
\var{\#\text{odds}(l,r)}{number of odd integers in the interval $[l,r]$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\#\text{odds}(l,r) \;=\; \left\lfloor \dfrac{r+1}{2} \right\rfloor \;-\; \left\lfloor \dfrac{l}{2} \right\rfloor.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Closed, integer interval; $l$ and $r$ are 32-bit safe but Python integers are unbounded; no overflow concerns.}
\INVARIANTS{
\begin{itemize}
\item Parity alternates every integer: exactly one of $k$ and $k+1$ is odd.
\item For any $n \in \mathbb{Z}_{\ge 0}$, $\left\lfloor \dfrac{n}{2} \right\rfloor$ counts the number of pairs in $\{0,\ldots,n-1\}$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Count by iterating through $[l,r]$ and increment when $x \bmod 2 = 1$.}
\ASSUMPTIONS{Simple loop; safe for small ranges only.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize counter $c \gets 0$.
\item For each integer $x$ from $l$ to $r$ inclusive, if $x \bmod 2 = 1$, increment $c$.
\item Return $c$.
\end{algosteps}
\COMPLEXITY{Let $n = r-l+1$. Time $\Theta(n)$, space $O(1)$.}
\[
\begin{aligned}
T(n) &= \Theta(n) \text{ checks of parity} \\
     &= \Theta(r-l+1).
\end{aligned}
\]
\CORRECTNESS{Every odd in $[l,r]$ is found by the loop and counted once; no even is counted.}
\EDGECASES{Single-element intervals; both endpoints even; both odd; $l=0$; $l=r$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def countOdds(self, low: int, high: int) -> int:
        cnt = 0
        for x in range(low, high + 1):
            if x & 1:
                cnt += 1
        return cnt

# basic asserts (LC-style local tests)
s = Solution()
assert s.countOdds(3, 7) == 3
assert s.countOdds(8, 10) == 1
assert s.countOdds(0, 0) == 0
assert s.countOdds(0, 1) == 1
\end{minted}
\VALIDATION{Manual checks: consecutive small ranges; parity boundaries; zero-width range.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Arithmetic via Range Halving}
\WHICHFORMULA{Let $n = r-l+1$. Exactly $\lfloor n/2 \rfloor$ numbers are odd, plus one extra iff both endpoints are odd.}
\ASSUMPTIONS{Uses parity of endpoints only; $O(1)$ time and space.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $n \gets r-l+1$ and $base \gets \left\lfloor \tfrac{n}{2} \right\rfloor$.
\item If $l$ and $r$ are both odd, add $1$ to $base$.
\item Return the result.
\end{algosteps}
\COMPLEXITY{Constant time, constant space; improves upon the linear scan when $r-l$ is large.}
\[
\begin{aligned}
T(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Pairs $(2k,2k+1)$ contribute exactly one odd. If both ends are odd, there is an unpaired odd at both ends, adding one.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def countOdds(self, low: int, high: int) -> int:
        n = high - low + 1
        base = n // 2
        if (low & 1) and (high & 1):
            return base + 1
        return base

# checks on edge inputs
s = Solution()
assert s.countOdds(3, 7) == 3
assert s.countOdds(8, 10) == 1
assert s.countOdds(2, 2) == 0
assert s.countOdds(1, 1) == 1
\end{minted}
\VALIDATION{Covers both endpoints odd/even; singletons; small intervals.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Floor-Difference Formula}
\WHICHFORMULA{Count odds up to $x$ equals $\left\lfloor \dfrac{x+1}{2} \right\rfloor$. Thus result is
\begin{BreakableEquation*}
\left\lfloor \dfrac{r+1}{2} \right\rfloor - \left\lfloor \dfrac{l}{2} \right\rfloor,
\end{BreakableEquation*}
implemented with integer division.}
\ASSUMPTIONS{Relies on properties of floor and parity; valid for all integers $l \le r$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $a \gets \left\lfloor \dfrac{r+1}{2} \right\rfloor$ and $b \gets \left\lfloor \dfrac{l}{2} \right\rfloor$.
\item Return $a-b$.
\end{algosteps}
\OPTIMALITY{Uses $O(1)$ arithmetic operations, which is information-theoretically optimal for constant-size input.}
\COMPLEXITY{Time $O(1)$, space $O(1)$.}
\[
\begin{aligned}
T(n) &= \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def countOdds(self, low: int, high: int) -> int:
        return (high + 1) // 2 - (low // 2)

# exactly 3 asserts
s = Solution()
assert s.countOdds(3, 7) == 3
assert s.countOdds(8, 10) == 1
assert s.countOdds(0, 0) == 0
\end{minted}
\VALIDATION{Matches examples and boundary zero-width range.}
\RESULT{Returns the number of odd integers in $[\texttt{low}, \texttt{high}]$ with no side effects or tie-breaking.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify against brute force on small domains; check random and adversarial parity boundaries; confirm monotonicity as interval expands.}
\LINE{CROSS-CHECKS}{Compare Approach A vs C for all $0 \le l \le r \le 200$; they must agree.}
\LINE{EDGE-CASE GENERATOR}{Systematically iterate small ranges to cover all parity combinations and zero-width intervals.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def brute_count(low: int, high: int) -> int:
    return sum(1 for x in range(low, high + 1) if x & 1)

def formula_count(low: int, high: int) -> int:
    return (high + 1) // 2 - (low // 2)

# Exhaustive small-range check
for L in range(0, 51):
    for R in range(L, 51):
        assert brute_count(L, R) == formula_count(L, R)

# Adversarial parity boundaries
pairs = [(0, 0), (1, 1), (2, 2), (0, 1), (1, 2), (2, 3), (10, 19), (10, 20), (11, 21)]
for L, R in pairs:
    assert brute_count(L, R) == formula_count(L, R)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def countOdds(self, low: int, high: int) -> int:
        # Count of odds in [0, x] is floor((x + 1) / 2). Subtract prefix up to low - 1.
        return (high + 1) // 2 - (low // 2)

# Reference asserts (examples + a few extras)
s = Solution()
assert s.countOdds(3, 7) == 3
assert s.countOdds(8, 10) == 1
assert s.countOdds(0, 0) == 0
assert s.countOdds(1, 2) == 1
assert s.countOdds(2, 3) == 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute the number of odd integers in an inclusive interval using a constant-time formula.}
\WHY{Classic warm-up that checks reasoning about parity, floors, and off-by-one boundaries.}
\CHECKLIST{
\begin{itemize}
\item Confirm inclusivity of both ends.
\item Derive or recall $\lfloor \tfrac{x+1}{2} \rfloor$ as count of odds up to $x$.
\item Apply difference of floors correctly.
\item Validate with tiny examples.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item $l=r=0$.
\item $l=r=1$.
\item Both endpoints even, e.g., $[2, 10]$.
\item Both endpoints odd, e.g., $[3, 9]$.
\item Mixed parity starts/ends, e.g., $[2, 3]$, $[1, 2]$.
\item Large values near $10^9$.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Off-by-one from using $(r-l)/2$ instead of $\lfloor (r-l+1)/2 \rfloor$.
\item Forgetting inclusivity of both ends.
\item Using floating-point division instead of integer division.
\item Assuming negative inputs; constraints exclude them.
\item Overflow in languages with fixed-size ints (not an issue in Python, but relevant elsewhere).
\item Misinterpreting when to add the extra $1$ in the parity-adjust method.
\end{itemize}}
\FAILMODES{Brute force times out for huge ranges in constrained environments; arithmetic formula avoids iteration entirely.}
\ELI{About half the numbers are odd. Count pairs of consecutive integers and add one more only if you start and end on odd numbers. The floor-difference formula captures this in one line.}
\NotePages{3}

\end{document}