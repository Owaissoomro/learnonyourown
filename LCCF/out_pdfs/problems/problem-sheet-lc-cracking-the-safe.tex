% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cracking the Safe}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/cracking-the-safe/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{There is a safe protected by a password. The password is a sequence of $n$ digits where each digit can be in the range $[0, k - 1]$. The safe has a peculiar way of checking the password: when you enter a sequence, it checks the most recent $n$ digits that were entered each time you type a digit.

Example: suppose the correct password is ``345'' and you enter ``012345'':
\begin{bullets}
\item After typing 0, the most recent 3 digits is ``0'', which is incorrect.
\item After typing 1, the most recent 3 digits is ``01'', which is incorrect.
\item After typing 2, the most recent 3 digits is ``012'', which is incorrect.
\item After typing 3, the most recent 3 digits is ``123'', which is incorrect.
\item After typing 4, the most recent 3 digits is ``234'', which is incorrect.
\item After typing 5, the most recent 3 digits is ``345'', which is correct and the safe unlocks.
\end{bullets}

Return any string of minimum length that will unlock the safe at some point of entering it.

Examples:
\begin{bullets}
\item Input: $n=1$, $k=2$; Output: ``10''. Explanation: the password is a single digit, so enter each digit. ``01'' would also unlock the safe.
\item Input: $n=2$, $k=2$; Output: ``01100''. Explanation: for each possible password:
\begin{bullets}
\item ``00'' is typed in starting from the 4th digit.
\item ``01'' is typed in starting from the 1st digit.
\item ``10'' is typed in starting from the 3rd digit.
\item ``11'' is typed in starting from the 2nd digit.
\end{bullets}
Thus ``01100'' will unlock the safe. ``10011'' and ``11001'' would also unlock the safe.
\end{bullets}

Constraints:
\begin{bullets}
\item $1 \le n \le 4$
\item $1 \le k \le 10$
\item $1 \le k^n \le 4096$
\end{bullets}}
\BREAKDOWN{We must generate a shortest string that contains every length-$n$ string over the alphabet $\{0,\ldots,k-1\}$ as a contiguous substring. This is a classical de Bruijn sequence problem.}
\ELI{Construct a cyclic sequence that contains every password exactly once as a window, then linearize it by appending $n-1$ starting digits.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode method signature: \texttt{def crackSafe(self, n: int, k: int) -\textgreater{} str}. Valid ranges: $1 \le n \le 4$, $1 \le k \le 10$.}
\OUTPUTS{A string over digits $\{0,\ldots,k-1\}$ of length exactly $k^n + n - 1$ that contains every length-$n$ digit string over $\{0,\ldots,k-1\}$ as a substring (so some prefix's last $n$ digits match the secret). Any such string is accepted.}
\SAMPLES{
\begin{bullets}
\item Input: $n=1$, $k=3$; One valid output: ``012''.
\item Input: $n=2$, $k=2$; One valid output: ``00110'' or ``01100''.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma=\{0,1,\ldots,k-1\}$. We seek a shortest string $S \in \Sigma^\*$ such that every word $w \in \Sigma^n$ appears as a contiguous substring of $S$. The optimal length is $k^n + n - 1$, achievable by a de Bruijn sequence of order $n$ over alphabet size $k$.}
\varmapStart
\var{n}{window length (password length)}
\var{k}{alphabet size; digits $0,\ldots,k-1$}
\var{V}{set of nodes $\Sigma^{n-1}$}
\var{E}{set of edges $\Sigma^n$; edge $u \xrightarrow{d} v$ where $u$ suffix + $d$ = $v$}
\var{S}{constructed unlocking string of length $k^n + n - 1$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
|V| &= k^{n-1},\quad |E| = k^n,\\
\forall v \in V:\ \deg^+(v) &= k,\ \deg^-(v) = k,\\
\text{Thus }G=(V,E)\text{ is Eulerian} &\implies \exists\ \text{Eulerian circuit covering all }E.\\
\text{If }e_1 e_2 \cdots e_{k^n}\text{ is such a circuit},\ \ S &= \text{label}(e_1)\cdots\text{label}(e_{k^n}) + \text{first }(n-1)\text{ chars}.
\end{aligned}
\]
}
\ASSUMPTIONS{Digits are $0$-to-$(k-1)$; we can break ties by smallest digit to get a canonical answer. The de Bruijn graph is strongly connected and Eulerian for all $k\ge1$ and $n\ge1$.}
\INVARIANTS{
\begin{bullets}
\item Each edge (an $n$-length word) appears exactly once in the Eulerian traversal.
\item The sliding window of length $n$ over $S$ visits all $k^n$ words with no repeats.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Backtracking on $n$-length edges: starting from the node $0^{n-1}$, try appending digits $0,\ldots,k-1$; mark each formed $n$-length word as visited; upon dead-end, backtrack. This is a depth-first Eulerian traversal.}
\ASSUMPTIONS{We maintain a set of visited edges ($n$-length substrings). Try digits in increasing order to get a deterministic minimal-lexicographic answer.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize start node $s=0^{n-1}$; visited set $E'=\varnothing$; output list $R$ empty.
\item DFS(node): for $d$ in $0,\ldots,k-1$, let $e=\text{node}+d$. If $e\notin E'$, add to $E'$, recurse on $e[1:]$, then append $d$ to $R$.
\item Run DFS($s$) and return $s$ concatenated with the reverse of $R$.
\end{algosteps}
\COMPLEXITY{Visits each of the $k^n$ edges once; each edge processed $O(1)$ amortized.}
\[
\begin{aligned}
T(n,k) &= \Theta(k^n),\\
S(n,k) &= \Theta(k^n) \text{ for the visited set and recursion stack.}
\end{aligned}
\]
\CORRECTNESS{Standard Hierholzer-style DFS on an Eulerian directed multigraph yields an Eulerian circuit covering all edges exactly once; appending digits on backtrack constructs the circuit in reverse. The produced string contains each $n$-length word exactly once as a window.}
\EDGECASES{Smallest cases $n=1$, $k=1$ produce ``0''. For $n=1$, answer is ``012\ldots(k-1)''.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LeetCode 753. Cracking the Safe — Baseline DFS (recursive)
# Contract: class Solution with crackSafe(self, n: int, k: int) -> str, plus asserts.

from typing import List, Set

class Solution:
    def crackSafe(self, n: int, k: int) -> str:
        if n == 1:
            return "".join(str(i) for i in range(k))
        start = "0" * (n - 1)
        seen: Set[str] = set()
        res: List[str] = []

        def dfs(node: str) -> None:
            for d in map(str, range(k)):
                edge = node + d
                if edge not in seen:
                    seen.add(edge)
                    dfs(edge[1:])
                    res.append(d)

        dfs(start)
        return start + "".join(reversed(res))

# Helpers for validation
def contains_all_n_words(s: str, n: int, k: int) -> bool:
    if len(s) != (k ** n) + n - 1:
        return False
    alphabet = {str(i) for i in range(k)}
    if any(ch not in alphabet for ch in s):
        return False
    seen = set()
    for i in range(len(s) - n + 1):
        seen.add(s[i:i+n])
    return len(seen) == k ** n

# Basic asserts
sol = Solution()
s1 = sol.crackSafe(1, 2)
assert contains_all_n_words(s1, 1, 2)
s2 = sol.crackSafe(2, 2)
assert contains_all_n_words(s2, 2, 2)
s3 = sol.crackSafe(2, 3)
assert contains_all_n_words(s3, 2, 3)
\end{minted}
\VALIDATION{Checked string length $k^n + n - 1$, alphabet validity, and that all $k^n$ length-$n$ substrings appear.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Iterative DFS (Stack) / Pruning}
\WHICHFORMULA{Eliminate recursion depth by simulating DFS with an explicit stack and track edge digits to append on backtracking. This avoids recursion overhead and stack limits while preserving Eulerian traversal.}
\ASSUMPTIONS{Try digits in increasing order for determinism. Maintain a stack of nodes and a parallel stack of edge digits used to reach them.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $s=0^{n-1}$, an empty set $E'$ for visited edges, stacks $S=[s]$, $D=[]$ for digits, and answer list $R=[]$.
\item While $S$ not empty: from top node $u$, find first digit $d$ with edge $e=u+d$ unseen; push next node $e[1:]$ and push $d$ to $D$; if none, pop $u$ and, if $D$ nonempty, pop last digit into $R$.
\item Return $s$ plus reverse of $R$.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline; improved constant factors and no recursion.}
\[
\begin{aligned}
T(n,k) &= \Theta(k^n),\quad S(n,k) = \Theta(k^n).
\end{aligned}
\]
\CORRECTNESS{This is an explicit-stack implementation of Hierholzer's method. Each directed edge is traversed once; digits are appended in reverse of traversal, yielding a valid de Bruijn sequence.}
\textbf{Code (Improved)}
\begin{minted}{python}
# LeetCode 753. Cracking the Safe — Iterative DFS with explicit stacks

from typing import List, Set

class Solution:
    def crackSafe(self, n: int, k: int) -> str:
        if n == 1:
            return "".join(str(i) for i in range(k))
        start = "0" * (n - 1)
        seen: Set[str] = set()
        stack: List[str] = [start]
        edge_digits: List[str] = []
        res: List[str] = []
        digits = [str(i) for i in range(k)]

        while stack:
            node = stack[-1]
            advanced = False
            for d in digits:
                e = node + d
                if e not in seen:
                    seen.add(e)
                    stack.append(e[1:])
                    edge_digits.append(d)
                    advanced = True
                    break
            if not advanced:
                stack.pop()
                if edge_digits:
                    res.append(edge_digits.pop())
        return start + "".join(reversed(res))

# Validation helpers
def contains_all_n_words(s: str, n: int, k: int) -> bool:
    if len(s) != (k ** n) + n - 1:
        return False
    alphabet = {str(i) for i in range(k)}
    if any(ch not in alphabet for ch in s):
        return False
    seen = set()
    for i in range(len(s) - n + 1):
        seen.add(s[i:i+n])
    return len(seen) == k ** n

# Checks on edge inputs
sol = Solution()
assert contains_all_n_words(sol.crackSafe(1, 1), 1, 1)
assert contains_all_n_words(sol.crackSafe(1, 10), 1, 10)
assert contains_all_n_words(sol.crackSafe(3, 2), 3, 2)
\end{minted}
\VALIDATION{Verified smallest $k=1$, largest $k=10$ with $n=1$, and a mid-size case $n=3,k=2$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Classical de Bruijn Sequence Construction}
\WHICHFORMULA{Use the Lyndon-word-based de Bruijn generator $db(t,p)$ to produce a cyclic sequence of length $k^n$ over alphabet $\{0,\ldots,k-1\}$, then linearize by appending $n-1$ zeros.}
\ASSUMPTIONS{Alphabet is digits $0$ to $k-1$; base case $n=1$ returns the alphabet in order. The $db$ recursion runs in $\Theta(k^n)$ time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate cyclic de Bruijn sequence $C$ via $db$ algorithm with working array $a$ and recursion $(t,p)$.
\item Convert the sequence of integers to a string $C'$, and return $C' + 0^{n-1}$.
\item This yields a string of length $k^n + n - 1$ containing all length-$n$ substrings exactly once.
\end{algosteps}
\OPTIMALITY{A lower bound on length is $k^n + n - 1$ since a string with all $k^n$ windows of size $n$ needs at least $k^n$ new characters plus the initial $n-1$ seed. De Bruijn constructions achieve this bound with equality.}
\COMPLEXITY{Linear in output size.}
\[
\begin{aligned}
T(n,k) &= \Theta(k^n),\quad S(n,k) = O(n + k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# LeetCode 753. Cracking the Safe — de Bruijn (Lyndon-based) optimal construction

from typing import List

class Solution:
    def crackSafe(self, n: int, k: int) -> str:
        if n == 1:
            return "".join(str(i) for i in range(k))

        def de_bruijn(k: int, n: int) -> List[int]:
            a = [0] * (k * n)
            seq: List[int] = []

            def db(t: int, p: int) -> None:
                if t > n:
                    if n % p == 0:
                        seq.extend(a[1:p+1])
                else:
                    a[t] = a[t - p]
                    db(t + 1, p)
                    for j in range(a[t - p] + 1, k):
                        a[t] = j
                        db(t + 1, t)

            db(1, 1)
            return seq  # length k^n, cyclic

        cycle = de_bruijn(k, n)
        s = "".join(str(d) for d in cycle) + "0" * (n - 1)
        return s

# Validation (exactly 3 asserts)
def contains_all_n_words(s: str, n: int, k: int) -> bool:
    if len(s) != (k ** n) + n - 1:
        return False
    alphabet = {str(i) for i in range(k)}
    if any(ch not in alphabet for ch in s):
        return False
    seen = set()
    for i in range(len(s) - n + 1):
        seen.add(s[i:i+n])
    return len(seen) == k ** n

sol = Solution()
assert contains_all_n_words(sol.crackSafe(1, 5), 1, 5)
assert contains_all_n_words(sol.crackSafe(2, 2), 2, 2)
assert contains_all_n_words(sol.crackSafe(3, 3), 3, 3)
\end{minted}
\VALIDATION{Exactly three asserts: $(n,k)=(1,5)$, $(2,2)$, $(3,3)$.}
\RESULT{Returns a string of length $k^n + n - 1$ over digits $0$--$k-1$ that contains every length-$n$ word exactly once as a window; any such string is accepted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate structure: correct length, alphabet restriction, and coverage of all $k^n$ substrings. Spot-check small and moderate inputs; include boundary cases $n=1$ or $k=1$.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A/B/C on small $(n,k)$, verifying identical set of substrings and minimal length.}
\LINE{EDGE-CASE GENERATOR}{Generate all pairs $(n,k)$ with $1 \le n \le 4$, $1 \le k \le 5$ for fast checks.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

from typing import Tuple, List, Set

def contains_all_n_words(s: str, n: int, k: int) -> bool:
    if len(s) != (k ** n) + n - 1:
        return False
    alphabet = {str(i) for i in range(k)}
    if any(ch not in alphabet for ch in s):
        return False
    seen = set()
    for i in range(len(s) - n + 1):
        seen.add(s[i:i+n])
    return len(seen) == k ** n

# Reference final solution
class Solution:
    def crackSafe(self, n: int, k: int) -> str:
        if n == 1:
            return "".join(str(i) for i in range(k))

        def de_bruijn(k: int, n: int) -> List[int]:
            a = [0] * (k * n)
            seq: List[int] = []

            def db(t: int, p: int) -> None:
                if t > n:
                    if n % p == 0:
                        seq.extend(a[1:p+1])
                else:
                    a[t] = a[t - p]
                    db(t + 1, p)
                    for j in range(a[t - p] + 1, k):
                        a[t] = j
                        db(t + 1, t)

            db(1, 1)
            return seq

        cycle = de_bruijn(k, n)
        return "".join(str(d) for d in cycle) + "0" * (n - 1)

def batch_check():
    sol = Solution()
    for n in range(1, 5):
        for k in range(1, 6):
            s = sol.crackSafe(n, k)
            assert contains_all_n_words(s, n, k), (n, k)
    # Spot biggish: (n=4,k=4) still small by constraint k^n<=4096
    s = sol.crackSafe(4, 4)
    assert contains_all_n_words(s, 4, 4)

batch_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# LeetCode 753 Reference Solution (submit class only). Includes local asserts for sanity.

from typing import List

class Solution:
    def crackSafe(self, n: int, k: int) -> str:
        if n == 1:
            return "".join(str(i) for i in range(k))

        def de_bruijn(k: int, n: int) -> List[int]:
            a = [0] * (k * n)
            seq: List[int] = []

            def db(t: int, p: int) -> None:
                if t > n:
                    if n % p == 0:
                        seq.extend(a[1:p+1])
                else:
                    a[t] = a[t - p]
                    db(t + 1, p)
                    for j in range(a[t - p] + 1, k):
                        a[t] = j
                        db(t + 1, t)

            db(1, 1)
            return seq

        cycle = de_bruijn(k, n)
        return "".join(str(d) for d in cycle) + "0" * (n - 1)

# Local sanity asserts (will not be part of LC judge, safe to run standalone)
def _ok(s: str, n: int, k: int) -> bool:
    if len(s) != (k ** n) + n - 1:
        return False
    alphabet = {str(i) for i in range(k)}
    if any(ch not in alphabet for ch in s):
        return False
    seen = set(s[i:i+n] for i in range(len(s) - n + 1))
    return len(seen) == k ** n

_sol = Solution()
assert _ok(_sol.crackSafe(1, 7), 1, 7)
assert _ok(_sol.crackSafe(2, 2), 2, 2)
assert _ok(_sol.crackSafe(4, 3), 4, 3)
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Generate a de Bruijn sequence of order $n$ over $k$ digits and linearize it to get a shortest unlocking string.}
\WHY{Appears in interviews as Eulerian path, combinatorics over strings, or constructive minimal superstring variants.}
\CHECKLIST{
\begin{bullets}
\item Model as de Bruijn graph on $(n-1)$-length nodes and $n$-length edges.
\item Use Hierholzer (DFS or iterative) or the classical $db$ construction.
\item Return length exactly $k^n + n - 1$.
\item Ensure digits are in $[0,k-1]$ and deterministically ordered if needed.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ trivial: output ``012\ldots(k-1)''.
\item $k=1$ trivial: output ``0\ldots0'' of length $1 + n - 1 = n$.
\item Leading zeros: start from $0^{n-1}$ to linearize properly.
\item Maximum within constraints, e.g., $k^n=4096$ is easily feasible.
\item Validate that all substrings have length $n$ (ignore initial shorter windows).
\item Non-decimal alphabets are not required; digits only.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to append the initial $n-1$ digits after a cyclic construction.
\item Appending wrong digit on backtrack in iterative DFS; track edge digits explicitly.
\item Recursion depth limits if using recursive DFS without care (prefer iterative for safety).
\item Using strings for nodes and building large temporary objects; reuse slices minimally.
\item Off-by-one in window enumeration when validating.
\item Non-deterministic digit order can still work but may complicate testing; fix an order.
\end{bullets}
}
\FAILMODES{Naive concatenation of all words with overlaps can be $O(k^n \cdot n)$ or produce non-minimal strings; using Eulerian traversal or the $db$ algorithm guarantees minimality and linear time in output.}
\ELI{Think of all $n$-digit passwords as edges in a graph where edges connect when their last $n-1$ digits match the next one's first $n-1$. Walk through all edges exactly once (an Eulerian tour) and write down the digits; that gives a shortest sequence that must eventually show any password.}
\NotePages{3}

\end{document}