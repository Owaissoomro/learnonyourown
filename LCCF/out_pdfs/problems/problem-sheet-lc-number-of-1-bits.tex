% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Number of 1 Bits}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/number-of-1-bits/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given a positive integer \texttt{n}, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).\par
\textbf{Example 1:}\par
\textbf{Input:} \texttt{n = 11}\par
\textbf{Output:} \texttt{3}\par
\textbf{Explanation:} The input binary string \textbf{1011} has a total of three set bits.\par
\textbf{Example 2:}\par
\textbf{Input:} \texttt{n = 128}\par
\textbf{Output:} \texttt{1}\par
\textbf{Explanation:} The input binary string \textbf{10000000} has a total of one set bit.\par
\textbf{Example 3:}\par
\textbf{Input:} \texttt{n = 2147483645}\par
\textbf{Output:} \texttt{30}\par
\textbf{Explanation:} The input binary string \textbf{1111111111111111111111111111101} has a total of thirty set bits.\par
\textbf{Constraints:}\par
\quad\texttt{1 \le n \le 2^{31}-1}\par
\textbf{Follow up:} If this function is called many times, how would you optimize it?}
\BREAKDOWN{Compute the Hamming weight of an unsigned 32-bit integer efficiently. Start with a simple bit-by-bit scan, then improve using a bit trick that clears the lowest set bit, and finally consider constant-time bit counting or table methods for repeated queries.}
\ELI{Count how many 1s are in the binary form of the number.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer \texttt{n} with \texttt{1 \le n \le 2^{31}-1}.}
\OUTPUTS{Return an integer: the number of set bits (1s) in the 32-bit binary representation of \texttt{n}.}
\SAMPLES{\begin{bullets}
\item \texttt{n = 11} $\to$ \texttt{3}
\item \texttt{n = 128} $\to$ \texttt{1}
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n \in \{1,\ldots,2^{31}-1\}$. Define the Hamming weight $w(n)$ as the number of 1-bits in the standard binary expansion of $n$.}
\varmapStart
\var{n}{input integer}
\var{w(n)}{Hamming weight (number of set bits) of $n$}
\var{b_i}{the $i$-th bit of $n$ in $\{0,1\}$ for $i \in [0,31)$}
\varmapEnd
\GOVERN{
\[
  b_i = \left\lfloor \frac{n}{2^i} \right\rfloor \bmod 2,\quad
  w(n) = \sum_{i=0}^{30} b_i.
\]
Equivalently, letting $\operatorname{lowbit}(n) = 2^{\nu_2(n)}$ be the largest power of two dividing $n$ (i.e., the least significant set bit when $n>0$),
\begin{BreakableEquation*}
w(0)=0,\quad w(n)=1+w\bigl(n-\operatorname{lowbit}(n)\bigr)\ \text{for }n>0.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Treat \texttt{n} as a non-negative 32-bit quantity; shifts are logical; no sign-extension issues since \texttt{n} is positive.}
\INVARIANTS{\begin{bullets}
\item In the recurrence, $n$ strictly decreases and remains non-negative, ensuring termination.
\item The number of times we can subtract $\operatorname{lowbit}(n)$ equals the number of 1-bits in $n$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Scan all bit positions, counting ones by testing the least-significant bit and right-shifting.}
\ASSUMPTIONS{We can iterate until \texttt{n} becomes zero; for 32-bit inputs this is $O(\log n)$ iterations.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{count = 0}.
\item While \texttt{n > 0}: add \texttt{n \& 1} to \texttt{count}, then set \texttt{n >>= 1}.
\item Return \texttt{count}.
\end{algosteps}
\COMPLEXITY{Each loop shifts one bit. For 32-bit inputs this is at most 32 iterations: $T(n)=O(32)=O(1)$ in fixed width, or $O(\log n)$ more generally; $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= \text{number of shifts} \le 32 \\
     &= O(1)\ \text{for fixed-width integers.}
\end{aligned}
\]
\CORRECTNESS{Each iteration examines and removes the current least-significant bit, adding 1 iff it is set. After all bits are processed, \texttt{count} equals the total number of 1-bits.}
\EDGECASES{Powers of two (exactly one set bit); maximal value \texttt{2^{31}-1} (all low 31 bits set); alternating bit patterns.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def hammingWeight(self, n: int) -> int:
        """Count bits by scanning LSB and shifting right."""
        count = 0
        while n:
            count += n & 1
            n >>= 1
        return count

# Basic asserts (from prompt examples)
if __name__ == "__main__":
    s = Solution()
    assert s.hammingWeight(11) == 3          # 1011
    assert s.hammingWeight(128) == 1         # 10000000
    assert s.hammingWeight(2147483645) == 30 # 111...1101 (31 bits with one zero)
\end{minted}
\VALIDATION{Also check a power of two and a dense number: \texttt{1} maps to \texttt{1}; \texttt{2^{31}-1} maps to \texttt{31}.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized via Lowest-Set-Bit Clearing (Kernighan)}
\WHICHFORMULA{Use the identity that repeatedly clearing the lowest set bit visits exactly as many iterations as there are set bits.}
\ASSUMPTIONS{Each iteration transforms \texttt{n} to \texttt{n \& (n-1)}, which strictly reduces the number of set bits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{count = 0}.
\item While \texttt{n > 0}: set \texttt{n = n \& (n-1)} and increment \texttt{count}.
\item Return \texttt{count}.
\end{algosteps}
\COMPLEXITY{Runs in $O(k)$ where $k$ is the number of set bits of \texttt{n}, which is optimal in terms of bit flips; $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= \text{number of set bits in } n = k \le 31.
\end{aligned}
\]
\CORRECTNESS{Invariant: \texttt{n} decreases by clearing exactly one previously set bit each iteration; thus the loop executes once per set bit and returns the correct count.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def hammingWeight(self, n: int) -> int:
        """Brian Kernighan's algorithm: clear lowest set bit each step."""
        count = 0
        while n:
            n &= n - 1
            count += 1
        return count

# Asserts (same semantics as baseline)
if __name__ == "__main__":
    s = Solution()
    assert s.hammingWeight(11) == 3
    assert s.hammingWeight(128) == 1
    assert s.hammingWeight(2147483645) == 30
\end{minted}
\VALIDATION{Edge checks: \texttt{1} yields \texttt{1}; \texttt{2^{31}-1} yields \texttt{31}; powers of two all yield \texttt{1}.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Built-in Popcount or Precomputed Table}
\WHICHFORMULA{Use the language's constant-time popcount when available; otherwise fall back to the $O(k)$ bit-clearing loop. For many queries, consider an 8-bit lookup table and sum four bytes.}
\ASSUMPTIONS{Python \texttt{int} supports \texttt{bit\_count()} in modern versions. If unavailable, the fallback remains $O(k)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If \texttt{int} has \texttt{bit\_count}, return \texttt{n.bit\_count()}.
\item Else, while \texttt{n > 0}: \texttt{n \&= n-1}; increment \texttt{count}.
\item Return the count.
\end{algosteps}
\OPTIMALITY{Hardware/popcount or built-in popcount is constant-time on fixed-width integers and usually compiled to a single instruction. For many queries without built-ins, a table-based byte-sum does constant 4 lookups per call.}
\COMPLEXITY{With built-in or table: $T(n)=O(1)$ on fixed 32-bit width; fallback: $O(k)$; space is $O(1)$ or $O(256)$ for a byte table.}
\[
\begin{aligned}
T(n) &= 
\begin{cases}
O(1) & \text{built-in or 4-byte table (fixed width)}\\
O(k) & \text{fallback (}k=\text{set bits)}\\
\end{cases}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def hammingWeight(self, n: int) -> int:
        """
        Prefer constant-time built-in popcount when available; otherwise use
        Kernighan's O(k) loop.
        """
        # Use built-in if present (Python 3.8+/3.10+ depending on environment)
        if hasattr(int, "bit_count"):
            return n.bit_count()
        # Fallback
        count = 0
        while n:
            n &= n - 1
            count += 1
        return count

# Exactly 3 asserts (prompt examples)
if __name__ == "__main__":
    s = Solution()
    assert s.hammingWeight(11) == 3
    assert s.hammingWeight(128) == 1
    assert s.hammingWeight(2147483645) == 30
\end{minted}
\VALIDATION{The three provided asserts mirror the platform examples and exercise typical sparse/dense bit patterns.}
\RESULT{Return the number of 1-bits in \texttt{n}. No tie-breaking is needed; the result is a single integer.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test representative categories: zeros near lower bound, powers of two, all-ones mask \texttt{2^{31}-1}, alternating bit patterns, and random-looking composites. Compare implementations pairwise on a curated deterministic set.}
\LINE{CROSS-CHECKS}{Verify that baseline, improved, and optimal all agree on the same suite of inputs.}
\LINE{EDGE-CASE GENERATOR}{Produce a deterministic array: small numbers, powers of two, masks, and crafted patterns.}
\begin{minted}{python}
def generate_cases():
    """Deterministic set of interesting 32-bit unsigned values within [1, 2^31-1]."""
    cases = []
    # smalls
    cases += list(range(1, 20))
    # powers of two
    for i in range(0, 31):
        cases.append(1 << i)
        if i > 0:
            cases.append((1 << i) - 1)  # all ones up to i bits
    # dense near upper bound
    cases += [2**31 - 1, 2**31 - 2, 2**31 - 3, 2**31 - 1024]
    # alternating patterns within 31 bits
    alt1 = int("01" * 16, 2) & ((1 << 31) - 1)
    alt2 = int("10" * 16, 2) & ((1 << 31) - 1)
    cases += [alt1, alt2]
    # some composites
    cases += [123456789, 987654321, 0x0F0F0F0F & ((1 << 31) - 1), 0xAAAAAAAA & ((1 << 31) - 1)]
    # unique and within range
    cases = sorted({x for x in cases if 1 <= x <= 2**31 - 1})
    return cases

class Baseline:
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        while n:
            cnt += n & 1
            n >>= 1
        return cnt

class Improved:
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        while n:
            n &= n - 1
            cnt += 1
        return cnt

class Optimal:
    def hammingWeight(self, n: int) -> int:
        if hasattr(int, "bit_count"):
            return n.bit_count()
        cnt = 0
        while n:
            n &= n - 1
            cnt += 1
        return cnt

if __name__ == "__main__":
    base, imp, opt = Baseline(), Improved(), Optimal()
    for x in generate_cases():
        b, i, o = base.hammingWeight(x), imp.hammingWeight(x), opt.hammingWeight(x)
        assert b == i == o, (x, b, i, o)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def hammingWeight(self, n: int) -> int:
        """
        Return the number of set bits in n.
        Uses built-in popcount when available; otherwise Kernighan's method.
        """
        if hasattr(int, "bit_count"):
            return n.bit_count()
        count = 0
        while n:
            n &= n - 1
            count += 1
        return count

# Self-checks against known results
if __name__ == "__main__":
    s = Solution()
    # Examples
    assert s.hammingWeight(11) == 3
    assert s.hammingWeight(128) == 1
    assert s.hammingWeight(2147483645) == 30
    # Extra edges
    assert s.hammingWeight(1) == 1
    assert s.hammingWeight((1 << 31) - 1) == 31
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute Hamming weight of a 32-bit positive integer quickly.}
\WHY{Bit counting is a classic that appears in many bitmask DP, hashing, and low-level optimization tasks.}
\CHECKLIST{\begin{bullets}
\item Confirm input domain and unsigned interpretation.
\item Choose method: scan bits, clear-lowest-set-bit, or built-in/table.
\item Mind constant factors if called many times.
\item Validate with powers of two and dense masks.
\end{bullets}}
\EDGECASES{\begin{bullets}
\item \texttt{n = 1} minimal positive input.
\item Power of two: exactly one 1-bit.
\item \texttt{n = 2^{31}-1}: all 31 bits set.
\item Alternating patterns like \texttt{0b0101...} within 31 bits.
\item Numbers with very few set bits vs. very many.
\item Near upper bound values: \texttt{2^{31}-2}, \texttt{2^{31}-3}.
\end{bullets}}
\PITFALLS{\begin{bullets}
\item Using arithmetic right shift on signed types in languages where that matters; here \texttt{n} is positive.
\item Infinite loop if \texttt{n} is not reduced (e.g., forgetting to shift or clear a bit).
\item Miscounting when masking is omitted for environments that require exactly 32-bit width.
\item Overcomplicating when a built-in popcount exists.
\item Confusing bitwise \texttt{\&} with logical \texttt{and}.
\item Off-by-one when iterating fixed 32 positions vs. until \texttt{n==0}.
\end{bullets}}
\FAILMODES{A naive 32-iteration loop is fine on fixed width, but on arbitrary-precision integers without bounds it becomes $O(\log n)$; the bit-clearing loop is $O(k)$ and can be much faster on sparse numbers.}
\ELI{We just count how many switches in the number are on. Either check each switch one-by-one, or keep flipping off the lowest on-switch until none remain. On modern platforms, there is often a built-in that tells you the count instantly.}
\NotePages{3}

\end{document}