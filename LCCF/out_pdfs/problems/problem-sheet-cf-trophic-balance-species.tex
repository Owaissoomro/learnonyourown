% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Trophic Balance Species}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2041/K}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{Image generated by ChatGPT 4o.

In an interdisciplinary collaboration, an ecosystem scientist and a computer scientist join forces to analyze the structure of a complex ecosystem using computational methods. The ecosystem scientist models the ecosystem as a directed graph $D = (V, A)$, where each species is represented by a node $v \in V$, and each feeding relationship is represented as a directed edge $(x, y) \in A$ from prey $x$ to predator $y$. This graph structure allows them to simulate the flow of energy throughout the ecosystem from one species to another.

Two essential features of the ecosystem are defined:

- Independent Trophic Group: A set $S$ of animal species is classified as an independent trophic group if no species $x \in S$ can reach another species $y \in S$ (for some $y \ne x$) through a series of directed feeding relationships, meaning there is no directed path in $D$ from $x$ to $y$.
- Trophic Balance Species: A species is termed a trophic balance species if it has a nearly equal number of species that affect it as directly or indirectly predators (species it can reach via a directed path in $D$, excluding itself) and species that affect it as directly or indirectly prey (species that can reach it via a directed path in $D$, excluding itself). Specifically, trophic balance species are those for which the absolute difference between the above two numbers is minimum among all species in the ecosystem.

Consider an ecosystem with $n = 4$ species and $m = 3$ feeding relationships:

- Species 1: Grass (Node 1)
- Species 2: Rabbits (Node 2)
- Species 3: Foxes (Node 3)
- Species 4: Hawks (Node 4)

The directed edges representing the feeding relationships are as follows:

- $(1, 2)$: Grass is eaten by Rabbits.
- $(2, 3)$: Rabbits are eaten by Foxes.
- $(2, 4)$: Rabbits are also eaten by Hawks.

Now, consider the set $S=\{3,4\}$ (Foxes and Hawks). There are no directed paths between Foxes (Node 3) and Hawks (Node 4); Foxes cannot reach Hawks, and Hawks cannot reach Foxes through any directed paths. Therefore, this set qualifies as an independent trophic group.

Examination of Species

- Species 1 (Grass): Can reach: 3 (Rabbits, Foxes, and Hawks) Can be reached by: 0 (None) Absolute difference: $|3 - 0| = 3$
- Species 2 (Rabbits): Can reach: 2 (Foxes and Hawks) Can be reached by: 1 (Grass) Absolute difference: $|2 - 1| = 1$
- Species 3 (Foxes): Can reach: 0 (None) Can be reached by: 2 (Grass and Rabbits) Absolute difference: $|0-2| = 2$
- Species 4 (Hawks): Can reach: 0 (None) Can be reached by: 2 (Grass and Rabbits) Absolute difference: $|0-2| = 2$

Among these species, Rabbits have the smallest absolute difference of $1$, indicating that they are a trophic balance species within the ecosystem.

It is known that any independent trophic group in the ecosystem has a size of at most $k$. The task is to find the set of all trophic balance species in the ecosystem.

Input:
The first line contains exactly two integers $n$ and $m$, where $n$ (resp. $m$) denotes the number of nodes (resp. edges) in the directed graph $D$ induced by the investigated ecosystem. The nodes are numbered as $1, 2, \ldots, n$. Then, $m$ lines follow. The $i$-th line contains two integers $x_i$ and $y_i$ indicating a directed edge from node $x_i$ to node $y_i$.

- $1 \le n \le 2 \times 10^5$
- $0 \le m \le \min\{ n(n-1), 4 \times 10^5\}$
- $k$ is not an input value, and it is guaranteed that $1 \le k \le 16$ for each investigated ecosystem.
- For all $i$ ($1\le i\le m$), $1\le x_i, y_i\le n$ and $x_i\neq y_i$.
- Each ordered pair $(x_i, y_i)$ appears at most once in the input.

Output:
Output on a single line the node identifiers of all trophic balance species in ascending order. For any two consecutive node identifiers, separate them by a space.}
\BREAKDOWN{Compress strongly connected components to a DAG, decompose this DAG into at most $k$ vertex-disjoint paths (minimum path cover), and use dynamic programming across these $k$ chains to count, for each component, the total number of reachable successors and predecessors (by reachability). Then select all original nodes whose component minimizes the absolute difference.}
\ELI{Squeeze the graph into a small-number-of-lines picture; from any node you can enter each line at some earliest point and then walk to the end. Counting these suffixes in both the original and reversed graphs gives the successor vs. predecessor counts.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A directed graph with $n$ nodes labeled $1..n$ and $m$ directed edges $(x_i,y_i)$ with $x_i\neq y_i$. No multi-edges.}
\OUTPUTS{All nodes minimizing $\bigl|\#\text{succ}(v)-\#\text{pred}(v)\bigr|$, where $\#\text{succ}(v)$ is the number of nodes reachable from $v$ (excluding $v$) and $\#\text{pred}(v)$ is the number of nodes that can reach $v$ (excluding $v$). Print in increasing order, space-separated.}
\SAMPLES{
Example 1:
$n=4, m=3$ with edges $(1,2),(2,3),(2,4)$. Output: 2.

Example 2:
$n=3, m=0$ (no edges). All nodes have 0 successors and 0 predecessors, so output: 1 2 3.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a directed graph. Let $\mathcal{C}$ be the set of strongly connected components (SCCs) and $D=(\mathcal{C},E_D)$ the condensation DAG with node weights $w(C)=|C|$. For each $C\in\mathcal{C}$ define
\[
S^+(C) = \sum_{C'\in\mathcal{C}:\,C\leadsto C'} w(C') \quad\text{and}\quad
S^-(C) = \sum_{C'\in\mathcal{C}:\,C'\leadsto C} w(C').
\]
For any original $v\in C$, the successor and predecessor counts (excluding $v$) are $S^+(C)-1$ and $S^-(C)-1$, respectively, hence the objective per node equals $\bigl|S^+(C)-S^-(C)\bigr|$.}
\varmapStart
\var{n,m}{number of vertices and edges in $G$}
\var{\mathcal{C}}{SCCs of $G$; $|\mathcal{C}|=N$}
\var{w(C)}{size of component $C$}
\var{D}{condensation DAG on $\mathcal{C}$}
\var{P}{a minimum path cover of $D$; $|P|\le k\le 16$}
\var{p(C)}{index of the chain containing $C$ in $P$}
\var{idx(C)}{1-based position of $C$ in its chain}
\var{pref_p(t)}{prefix sums of weights along chain $p$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let }P\text{ be a min path cover of }D\text{ with }|P|=K\le 16.\\
&\forall C, \forall p\in[1..K]:~ \pi^+_p(C)=\min\{\text{idx}(X)\mid C\leadsto X,\ p(X)=p\}\ \text{or }+\infty.\\
&S^+(C)=\sum_{p=1}^K \bigl(\text{pref}_p(L_p)-\text{pref}_p(\pi^+_p(C)-1)\bigr),\quad
S^-(C)=\sum_{p=1}^K \bigl(\text{pref}_p(L_p)-\text{pref}_p(\pi^-_p(C)-1)\bigr),\\
&\text{where }\pi^-_p(C)\text{ are computed on }D^\top\text{ analogously, and }L_p\text{ is the length of chain }p.
\end{aligned}
\]
}
\ASSUMPTIONS{All computations are performed on the condensation DAG $D$, which is acyclic. The promised width bound implies the minimum path cover has size at most $k\le 16$.}
\INVARIANTS{
- Dynamic programming order respects a topological order on $D$ (and the reverse DAG for predecessors).
- On any chain, the set of nodes reachable from a fixed component is a suffix segment; dually, nodes that can reach it form a suffix in $D^\top$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute reachability from every vertex by BFS/DFS and count successors and predecessors directly.}
\ASSUMPTIONS{Use adjacency and reverse adjacency; treat each vertex separately.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $v$, run DFS on $G$ from $v$ to count successors.
\item For each $v$, run DFS on $G^\top$ from $v$ to count predecessors.
\item Track the minimum absolute difference and list all $v$ attaining it.
\end{algosteps}
\COMPLEXITY{Clearly too slow for large instances.}
\[
\begin{aligned}
T(n) &\approx O\bigl(n(n+m)\bigr) \\
S(n) &\approx O(n+m).
\end{aligned}
\]
\CORRECTNESS{Counts are exact by definition of reachability.}
\EDGECASES{Disconnected graphs, isolated nodes, multiple SCCs; all handled as reachability degenerates.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    edges = [(next(it)-1, next(it)-1) for _ in range(m)]
    return n, m, edges

def solve_case_baseline(n, m, edges):
    g = [[] for _ in range(n)]
    gr = [[] for _ in range(n)]
    for u, v in edges:
        if u == v: 
            continue
        g[u].append(v)
        gr[v].append(u)
    def bfs(start, G):
        seen = [False]*n
        q = deque([start]); seen[start] = True
        cnt = -1  # exclude self
        while q:
            u = q.popleft()
            cnt += 1
            for w in G[u]:
                if not seen[w]:
                    seen[w] = True
                    q.append(w)
        return cnt
    best = None
    ans = []
    for v in range(n):
        succ = bfs(v, g)
        pred = bfs(v, gr)
        diff = abs(succ - pred)
        if best is None or diff < best:
            best = diff
            ans = [v+1]
        elif diff == best:
            ans.append(v+1)
    return ans

def solve_all_baseline():
    data = read_input()
    if data is None:
        return
    n, m, edges = data
    ans = solve_case_baseline(n, m, edges)
    print(" ".join(map(str, ans)))

def main():
    solve_all_baseline()

if __name__ == "__main__":
    # Tiny self-checks (do not run on CF due to performance)
    assert solve_case_baseline(3, 0, []) == [1,2,3]
    n, m = 4, 3
    edges = [(0,1),(1,2),(1,3)]
    assert solve_case_baseline(n, m, edges) == [2]
    # No I/O run here
    pass
\end{minted}
\VALIDATION{Checked on a graph with no edges and the 4-node example.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{SCC Compression + Bitset Reachability (still heavy)}
\WHICHFORMULA{Compress to a DAG of SCCs and attempt bitset DP for reachability; however, with $n$ up to $2\times 10^5$, bitsets per node are still too large.}
\ASSUMPTIONS{SCC compression reduces cycles; topological DP allows propagation but memory is prohibitive without further structure.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute SCCs and the condensation DAG.
\item Maintain per-node bitsets of reachability; propagate in topological order.
\item Count ones for successors and repeat on reversed DAG for predecessors.
\end{algosteps}
\COMPLEXITY{Time and especially space blow up: $O(N^2/\text{wordsize})$ in worst case; not viable.}
\[
\begin{aligned}
T(n) &\approx O(m \cdot N/64), \\
S(n) &\approx O(N^2/64).
\end{aligned}
\]
\CORRECTNESS{Exact but impractical under constraints.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Skipped: would exceed memory limits for the given constraints in Python.
def placeholder():
    return "This approach is not implemented due to memory constraints."
assert placeholder() == "This approach is not implemented due to memory constraints."
\end{minted}
\VALIDATION{N/A.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{SCC DAG + Minimum Path Cover (K chains) + K-way DP of suffix coverage}
\WHICHFORMULA{Use Dilworth/Mirsky: in a DAG, the size of a minimum path cover equals the width (maximum antichain) of the reachability poset. The promise $k\le 16$ lets us decompose the condensation DAG into $K\le 16$ vertex-disjoint paths. For any vertex, among each chain, the set of reachable vertices is a suffix; similarly, in the reverse DAG, predecessors form a suffix. Summing over $K$ chains yields $S^+$ and $S^-$.}
\ASSUMPTIONS{Operate on the condensation DAG. Build a minimum path cover via Hopcroft–Karp on the bipartite representation. Dynamic programming runs in $O((N+M)K)$ with $K\le 16$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute SCCs, build condensation DAG $D$ with node weights equal to component sizes, and a topological order.
\item Build a minimum path cover of $D$ using Hopcroft–Karp on the bipartite graph of $D$; extract chains and per-chain prefix sums of weights.
\item DP on $D$ in reverse topological order to compute, for each node and each chain, the earliest index of that chain reachable from the node; sum suffix weights to obtain $S^+$.
\item DP on $D^\top$ in reverse-topological order of $D^\top$ (i.e., forward order of $D$) to obtain $S^-$.
\item For each SCC, compute $\bigl|S^+ - S^-\bigr|$. Output all original vertices whose SCC achieves the minimum value, in ascending order.
\end{algosteps}
\OPTIMALITY{Counts are exact by construction on the DAG of SCCs. The $K$-chain representation is lossless for reachability counting because reachable sets on a chain are suffixes. The overall complexity is near-linear times $K\le 16$.}
\COMPLEXITY{Let $N=|\mathcal{C}|$, $M=|E_D|$, and $K\le 16$.}
\[
\begin{aligned}
T &=
O\bigl((n+m)\bigr)~\text{(SCC)}~+~
O\bigl(M\sqrt{N}\bigr)~\text{(HK)}~+~
O\bigl((N+M)K\bigr)~\text{(DP)} \\
S &= O(n+m) + O(NK)~\text{(flat arrays for DP)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import deque
from array import array

# ========== Core Solver ==========

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    edges = [(next(it)-1, next(it)-1) for _ in range(m)]
    return n, m, edges

def scc_kosaraju(n, edges):
    g = [[] for _ in range(n)]
    gr = [[] for _ in range(n)]
    for u, v in edges:
        if u == v:
            continue
        g[u].append(v)
        gr[v].append(u)
    seen = [False]*n
    order = []
    def dfs1(start):
        stack = [(start, 0)]
        while stack:
            u, it = stack.pop()
            if it == 0:
                if seen[u]:
                    continue
                seen[u] = True
                stack.append((u, 1))
                for w in g[u]:
                    if not seen[w]:
                        stack.append((w, 0))
            else:
                order.append(u)
    for v in range(n):
        if not seen[v]:
            dfs1(v)
    comp = [-1]*n
    cid = 0
    def dfs2(start, cid):
        stack = [start]
        comp[start] = cid
        while stack:
            u = stack.pop()
            for w in gr[u]:
                if comp[w] == -1:
                    comp[w] = cid
                    stack.append(w)
    for v in reversed(order):
        if comp[v] == -1:
            dfs2(v, cid)
            cid += 1
    # Build condensation DAG
    N = cid
    sz = [0]*N
    for v in range(n):
        sz[comp[v]] += 1
    # collect edges, deduplicate by sorting
    pairs = []
    for u, v in edges:
        cu, cv = comp[u], comp[v]
        if cu != cv:
            pairs.append((cu, cv))
    if pairs:
        pairs.sort()
        uniq = []
        prev = (-1, -1)
        for e in pairs:
            if e != prev:
                uniq.append(e)
                prev = e
        pairs = uniq
    else:
        pairs = []
    adj = [[] for _ in range(N)]
    radj = [[] for _ in range(N)]
    indeg = [0]*N
    for u, v in pairs:
        adj[u].append(v)
        radj[v].append(u)
        indeg[v] += 1
    # topo (Kahn)
    q = deque([i for i in range(N) if indeg[i] == 0])
    topo = []
    indeg2 = indeg[:]  # keep a copy if needed
    while q:
        u = q.popleft()
        topo.append(u)
        for w in adj[u]:
            indeg2[w] -= 1
            if indeg2[w] == 0:
                q.append(w)
    # topo may be shorter only if graph isn't a DAG; but condensation is DAG, so lengths must match
    return comp, N, sz, adj, radj, topo

def hopcroft_karp(adj):
    # adj: list of lists; left size = n, right size = n; vertices indexed 0..n-1 both sides
    n = len(adj)
    pairU = array('i', [-1]*n)
    pairV = array('i', [-1]*n)
    dist = array('i', [0]*n)
    from collections import deque
    def bfs():
        dq = deque()
        for u in range(n):
            if pairU[u] == -1:
                dist[u] = 0
                dq.append(u)
            else:
                dist[u] = -1
        found = False
        while dq:
            u = dq.popleft()
            for v in adj[u]:
                pu = pairV[v]
                if pu != -1:
                    if dist[pu] == -1:
                        dist[pu] = dist[u] + 1
                        dq.append(pu)
                else:
                    found = True
        return found
    def dfs(u):
        for v in adj[u]:
            pu = pairV[v]
            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):
                pairU[u] = v
                pairV[v] = u
                return True
        dist[u] = -1
        return False
    matching = 0
    while bfs():
        for u in range(n):
            if pairU[u] == -1 and dfs(u):
                matching += 1
    return pairU, pairV, matching

def min_path_cover_chains(adj, topo):
    # DAG with nodes 0..N-1. Build minimum path cover and return chains as lists of nodes.
    N = len(adj)
    pairU, pairV, _ = hopcroft_karp(adj)
    # start nodes: nodes with no matched incoming (i.e., pairV[u] == -1)
    starts = [u for u in range(N) if pairV[u] == -1]
    visited = [False]*N
    chains = []
    for s in starts:
        cur = s
        chain = []
        while cur != -1 and not visited[cur]:
            chain.append(cur)
            visited[cur] = True
            nxt = pairU[cur]
            cur = nxt
        chains.append(chain)
    # Some nodes may not be visited if they are in a matched cycle (should not happen in DAG) or isolated but matched both sides (they'll be visited from some start). As a safeguard:
    for u in range(N):
        if not visited[u]:
            chains.append([u])
            visited[u] = True
    return chains

def compute_counts(n, m, edges):
    comp, N, sz, adj, radj, topo = scc_kosaraju(n, edges)
    # Build min path cover chains
    chains = min_path_cover_chains(adj, topo)
    K = len(chains)
    # Map nodes to chain id and index (1-based)
    chain_id = [-1]*N
    idx = [-1]*N
    chain_len = [0]*K
    chain_nodes = []
    for c, chain in enumerate(chains):
        chain_len[c] = len(chain)
        chain_nodes.append(chain[:])
        for i, u in enumerate(chain, start=1):
            chain_id[u] = c
            idx[u] = i
    # Per-chain prefix sums of weights
    pref = []
    for c in range(K):
        L = chain_len[c]
        p = [0]*(L+1)
        for i in range(1, L+1):
            u = chain_nodes[c][i-1]
            p[i] = p[i-1] + sz[u]
        pref.append(p)
    # Flat arrays for DP positions (earliest reachable index per chain)
    INF = 10**9
    total_slots = N * K
    pos_out = array('I', [INF]*total_slots)
    pos_in  = array('I', [INF]*total_slots)
    # Initialize own chain index
    for u in range(N):
        c = chain_id[u]
        pos_out[u*K + c] = idx[u]
        pos_in[u*K + c] = idx[u]
    # DP for successors: process reverse topo
    for u in reversed(topo):
        base = u * K
        for v in adj[u]:
            vb = v * K
            # loop over chains
            for c in range(K):
                pv = pos_out[vb + c]
                if pv < pos_out[base + c]:
                    pos_out[base + c] = pv
    # DP for predecessors: process reverse-topo of reverse DAG, equivalently topo of original
    for u in topo:
        base = u * K
        for v in radj[u]:
            vb = v * K
            for c in range(K):
                pv = pos_in[vb + c]
                if pv < pos_in[base + c]:
                    pos_in[base + c] = pv
    # Sum suffix weights
    Sout = [0]*N
    Sin  = [0]*N
    for u in range(N):
        s1 = 0
        s2 = 0
        for c in range(K):
            p1 = pos_out[u*K + c]
            p2 = pos_in[u*K + c]
            L = chain_len[c]
            if p1 <= L:
                s1 += pref[c][L] - pref[c][p1-1]
            if p2 <= L:
                s2 += pref[c][L] - pref[c][p2-1]
        Sout[u] = s1
        Sin[u] = s2
    # Per SCC diff
    diff = [abs(Sout[u] - Sin[u]) for u in range(N)]
    best = min(diff) if N > 0 else 0
    # Collect vertex ids in ascending order
    ans = [i+1 for i in range(n) if diff[comp[i]] == best]
    ans.sort()
    return ans

def solve_all():
    data = read_input()
    if data is None:
        return
    n, m, edges = data
    ans = compute_counts(n, m, edges)
    print(" ".join(map(str, ans)))

def main():
    solve_all()

# ========== Self-tests (run only when no input is provided) ==========
if __name__ == "__main__":
    import sys
    data = sys.stdin.read()
    if not data.strip():
        # Test 1: No edges
        assert compute_counts(3, 0, []) == [1,2,3]
        # Test 2: Example from statement
        n, m = 4, 3
        edges = [(0,1),(1,2),(1,3)]
        assert compute_counts(n, m, edges) == [2]
        # Test 3: Single SCC fully connected (cycle)
        n, m = 4, 4
        edges = [(0,1),(1,2),(2,3),(3,0)]
        # All nodes have identical counts and hence all are optimal
        assert compute_counts(n, m, edges) == [1,2,3,4]
    else:
        # Re-inject for normal solve
        sys.stdin = sys.__stdin__
        sys.stdin = type(sys.stdin)(data)
        solve_all()
\end{minted}
\VALIDATION{Three asserts: no edges, the 4-node chain-fork example, and a single SCC cycle.}
\RESULT{All vertices achieving the minimum absolute difference between the number of reachable successors and reachable predecessors (both excluding the vertex itself), printed in increasing order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: empty graph, simple DAG with a fork, and a single SCC. Randomized cross-checks can compare the optimal method against the brute force on tiny $n\le 10$.}
\LINE{CROSS-CHECKS}{For small graphs, compare Approach A (brute force) vs. Approach C (optimal). They must produce identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate graphs with: no edges, all edges forming one SCC, multiple SCCs with varying sizes, and sparse vs. dense DAGs.}
\begin{minted}{python}
import random

def gen_tiny(n, p=0.3, seed=0):
    random.seed(seed)
    edges = []
    for u in range(n):
        for v in range(n):
            if u != v and random.random() < p:
                edges.append((u, v))
    return n, len(edges), edges

def brute_check(n, m, edges):
    # Brute-force reference from Approach A
    from collections import deque
    g = [[] for _ in range(n)]
    gr = [[] for _ in range(n)]
    for u, v in edges:
        if u == v: continue
        g[u].append(v)
        gr[v].append(u)
    def bfs(start, G):
        seen = [False]*n
        dq = deque([start])
        seen[start] = True
        cnt = -1
        while dq:
            u = dq.popleft()
            cnt += 1
            for w in G[u]:
                if not seen[w]:
                    seen[w] = True
                    dq.append(w)
        return cnt
    best = None; ans = []
    for v in range(n):
        s1 = bfs(v, g)
        s2 = bfs(v, gr)
        d = abs(s1 - s2)
        if best is None or d < best:
            best = d; ans = [v+1]
        elif d == best:
            ans.append(v+1)
    return ans

def quick_cross_check():
    for n in range(1, 9):
        for seed in range(5):
            nn, mm, ee = gen_tiny(n, p=0.3, seed=seed)
            a = brute_check(nn, mm, ee)
            c = compute_counts(nn, mm, ee)
            assert a == c, f"Mismatch: {a} vs {c} for seed {seed}, n={n}"

if __name__ == "__main__":
    quick_cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Combine everything from Approach C into a single ready-to-submit file.

from collections import deque
from array import array

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it); m = next(it)
    edges = [(next(it)-1, next(it)-1) for _ in range(m)]
    return n, m, edges

def scc_kosaraju(n, edges):
    g = [[] for _ in range(n)]
    gr = [[] for _ in range(n)]
    for u, v in edges:
        if u == v:
            continue
        g[u].append(v)
        gr[v].append(u)
    seen = [False]*n
    order = []
    def dfs1(start):
        stack = [(start, 0)]
        while stack:
            u, it = stack.pop()
            if it == 0:
                if seen[u]:
                    continue
                seen[u] = True
                stack.append((u, 1))
                for w in g[u]:
                    if not seen[w]:
                        stack.append((w, 0))
            else:
                order.append(u)
    for v in range(n):
        if not seen[v]:
            dfs1(v)
    comp = [-1]*n
    cid = 0
    def dfs2(start, cid):
        stack = [start]
        comp[start] = cid
        while stack:
            u = stack.pop()
            for w in gr[u]:
                if comp[w] == -1:
                    comp[w] = cid
                    stack.append(w)
    for v in reversed(order):
        if comp[v] == -1:
            dfs2(v, cid)
            cid += 1
    N = cid
    sz = [0]*N
    for v in range(n):
        sz[comp[v]] += 1
    pairs = []
    for u, v in edges:
        cu, cv = comp[u], comp[v]
        if cu != cv:
            pairs.append((cu, cv))
    if pairs:
        pairs.sort()
        uniq = []
        prev = (-1, -1)
        for e in pairs:
            if e != prev:
                uniq.append(e)
                prev = e
        pairs = uniq
    else:
        pairs = []
    adj = [[] for _ in range(N)]
    radj = [[] for _ in range(N)]
    indeg = [0]*N
    for u, v in pairs:
        adj[u].append(v)
        radj[v].append(u)
        indeg[v] += 1
    q = deque([i for i in range(N) if indeg[i] == 0])
    topo = []
    indeg2 = indeg[:]
    while q:
        u = q.popleft()
        topo.append(u)
        for w in adj[u]:
            indeg2[w] -= 1
            if indeg2[w] == 0:
                q.append(w)
    return comp, N, sz, adj, radj, topo

def hopcroft_karp(adj):
    n = len(adj)
    pairU = array('i', [-1]*n)
    pairV = array('i', [-1]*n)
    dist = array('i', [0]*n)
    from collections import deque
    def bfs():
        dq = deque()
        for u in range(n):
            if pairU[u] == -1:
                dist[u] = 0
                dq.append(u)
            else:
                dist[u] = -1
        found = False
        while dq:
            u = dq.popleft()
            for v in adj[u]:
                pu = pairV[v]
                if pu != -1:
                    if dist[pu] == -1:
                        dist[pu] = dist[u] + 1
                        dq.append(pu)
                else:
                    found = True
        return found
    def dfs(u):
        for v in adj[u]:
            pu = pairV[v]
            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):
                pairU[u] = v
                pairV[v] = u
                return True
        dist[u] = -1
        return False
    while bfs():
        for u in range(n):
            if pairU[u] == -1:
                dfs(u)
    return pairU, pairV

def min_path_cover_chains(adj, topo):
    pairU, pairV = hopcroft_karp(adj)
    N = len(adj)
    starts = [u for u in range(N) if pairV[u] == -1]
    visited = [False]*N
    chains = []
    for s in starts:
        cur = s
        chain = []
        while cur != -1 and not visited[cur]:
            chain.append(cur)
            visited[cur] = True
            cur = pairU[cur]
        chains.append(chain)
    for u in range(N):
        if not visited[u]:
            chains.append([u])
            visited[u] = True
    return chains

def compute_counts(n, m, edges):
    comp, N, sz, adj, radj, topo = scc_kosaraju(n, edges)
    chains = min_path_cover_chains(adj, topo)
    K = len(chains)
    chain_id = [-1]*N
    idx = [-1]*N
    chain_len = [0]*K
    chain_nodes = []
    for c, chain in enumerate(chains):
        chain_len[c] = len(chain)
        chain_nodes.append(chain[:])
        for i, u in enumerate(chain, start=1):
            chain_id[u] = c
            idx[u] = i
    pref = []
    for c in range(K):
        L = chain_len[c]
        p = [0]*(L+1)
        for i in range(1, L+1):
            u = chain_nodes[c][i-1]
            p[i] = p[i-1] + sz[u]
        pref.append(p)
    INF = 10**9
    total_slots = N * K
    pos_out = array('I', [INF]*total_slots)
    pos_in  = array('I', [INF]*total_slots)
    for u in range(N):
        c = chain_id[u]
        pos_out[u*K + c] = idx[u]
        pos_in[u*K + c] = idx[u]
    for u in reversed(topo):
        base = u * K
        for v in adj[u]:
            vb = v * K
            for c in range(K):
                pv = pos_out[vb + c]
                if pv < pos_out[base + c]:
                    pos_out[base + c] = pv
    for u in topo:
        base = u * K
        for v in radj[u]:
            vb = v * K
            for c in range(K):
                pv = pos_in[vb + c]
                if pv < pos_in[base + c]:
                    pos_in[base + c] = pv
    Sout = [0]*N
    Sin  = [0]*N
    for u in range(N):
        s1 = 0
        s2 = 0
        for c in range(K):
            p1 = pos_out[u*K + c]
            p2 = pos_in[u*K + c]
            L = chain_len[c]
            if p1 <= L:
                s1 += pref[c][L] - pref[c][p1-1]
            if p2 <= L:
                s2 += pref[c][L] - pref[c][p2-1]
        Sout[u] = s1
        Sin[u] = s2
    diff = [abs(Sout[u] - Sin[u]) for u in range(N)]
    best = min(diff) if N > 0 else 0
    ans = [i+1 for i in range(n) if diff[comp[i]] == best]
    ans.sort()
    return ans

def solve_all():
    data = read_input()
    if data is None:
        return
    n, m, edges = data
    ans = compute_counts(n, m, edges)
    print(" ".join(map(str, ans)))

def main():
    solve_all()

if __name__ == "__main__":
    # Run small asserts only when no input is piped
    import sys
    data = sys.stdin.read()
    if not data.strip():
        assert compute_counts(3, 0, []) == [1,2,3]
        n, m = 4, 3
        edges = [(0,1),(1,2),(1,3)]
        assert compute_counts(n, m, edges) == [2]
        n, m = 4, 4
        edges = [(0,1),(1,2),(2,3),(3,0)]
        assert compute_counts(n, m, edges) == [1,2,3,4]
    else:
        sys.stdin = sys.__stdin__
        sys.stdin = type(sys.stdin)(data)
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute, for each node, the difference between the number of reachable successors and predecessors, using SCC compression and a $K$-chain DP with $K\le 16$.}
\WHY{This uses classic poset/decomposition ideas; bounding the width enables near-linear-time counting rather than quadratic reachability.}
\CHECKLIST{
- Build SCC condensation DAG and topological order.
- Minimum path cover via Hopcroft–Karp; extract chains.
- Per-chain prefix sums of SCC sizes.
- DP (reverse topo) for successors; DP (topo) for predecessors on the reverse DAG.
- Sum suffix weights per chain; compute per-component differences.
- Emit all original nodes from components attaining the minimum.}
\EDGECASES{
- No edges: every node is optimal.
- One big SCC: every node identical.
- Multiple SCCs with large size variance.
- DAG with multiple sources/sinks.
- Self-loops (ignored) and duplicate edges (ignored).
- $K=1$ (a single chain) and $K=16$ (worst case).}
\PITFALLS{
- Forgetting to exclude self: handled implicitly; cancels in the difference.
- Using original graph instead of condensation DAG (would break acyclicity).
- Memory blowup from per-node bitsets; avoided with $K$-dimensional flat arrays.
- Incorrect path cover reconstruction; ensure starts are nodes with no matched incoming.
- Not deduplicating multiple parallel edges in the DAG bipartite graph.
- Wrong DP order (must respect topo/reverse-topo).}
\FAILMODES{Naive all-pairs reachability or transitive closure will time out or run out of memory. The $K$-chain DP survives due to $K\le 16$ and linearithmic matching cost.}
\ELI{Shrink cycles to single blobs and lay the blobs onto at most 16 lines. From each blob, mark where you can first jump onto each line; everything to the right is reachable. Do that forward and backward, compare totals, and list the most balanced species.}
\NotePages{3}

\end{document}