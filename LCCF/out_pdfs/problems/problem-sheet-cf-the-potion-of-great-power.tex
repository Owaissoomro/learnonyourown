% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — The Potion of Great Power}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1403/A}}
\LINE{DIFFICULTY / RATING}{2400}
\STATEMENT{Once upon a time, in the Land of the Shamans, everyone lived on the Sky-High Beanstalk. Each shaman had a unique identifying number $i$ between $0$ and $N-1$, and an altitude value $H_i$, representing how high he lived above ground level. The distance between two altitudes is the absolute value of their difference.

All shamans lived together in peace, until one of them stole the formula of the world-famous Potion of Great Power. To cover his/her tracks, the Thief has put a Curse on the land: most inhabitants could no longer trust each other\ldots

Despite the very difficult circumstances, the Order of Good Investigators have gained the following information about the Curse:
\begin{bullets}
\item When the Curse first takes effect, everyone stops trusting each other.
\item The Curse is unstable: at the end of each day (exactly at midnight), one pair of shamans will start or stop trusting each other.
\item Unfortunately, each shaman will only ever trust at most $D$ others at any given time.
\end{bullets}

They believe the Thief has whispered the formula to an Evil Shaman. To avoid detection, both of them visited the home of one of their (respective) trusted friends. During the visit, the Thief whispered the formula to the Evil Shaman through the window. (Note: this trusted friend did not have to be home at the time. In fact, it is even possible that they visited each other's houses — shamans are weird.)

Fortunately, whispers only travel short distances, so the Order knows the two trusted friends visited (by the Thief and the Evil Shaman) must live very close to each other.

They ask you to help with their investigation. They would like to test their suspicions: what if the Thief was $x$, the Evil Shaman was $y$, and the formula was whispered on day $v$? What is the smallest distance the whispered formula had to travel? That is, what is the minimum distance between the apartments of some shamans $x'$ and $y'$ (i.e. $\min\bigl(\lvert H_{x'} - H_{y'}\rvert\bigr)$), such that $x'$ was a trusted friend of $x$ and $y'$ was a trusted friend of $y$ on day $v$?

They will share all their information with you, then ask you a number of questions. You need to answer each question immediately, before receiving the next one.

Note:
Scoring:
\[
\begin{array}{|c|c|c|}
\hline
\text{Subtask} & \text{Points} & \text{Constraints} \\
\hline
1 & 0 & \text{samples} \\
\hline
2 & 17 & Q,U \le 1000 \\
\hline
3 & 14 & v=U \: \text{for all questions} \\
\hline
4 & 18 & H_i \in \{0,1\} \: \text{for all shamans} \: i \\
\hline
5 & 21 & U,N \le 10000 \\
\hline
6 & 30 & \text{no additional constraints} \\
\hline
\end{array}
\]

Example queries:

Evolution of friendships:
}
\BREAKDOWN{We maintain a dynamic, undirected trust graph on $N$ nodes, starting empty, with exactly one edge toggle per day for $U$ days. For a query $(x,y,v)$, we need the minimum altitude difference between any neighbor of $x$ and any neighbor of $y$ in the graph snapshot after day $v$.}
\ELI{Sort the neighbor altitudes and slide two fingers to find how close two neighborhoods can get.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{We adopt the following precise input format:
\begin{bullets}
\item First line: integers $N$, $D$, $U$, $Q$ with $1 \le N \le 200{,}000$, $0 \le D \le N-1$, $0 \le U,Q \le 200{,}000$.
\item Second line: $N$ integers $H_0,H_1,\ldots,H_{N-1}$ (altitudes), each within $\lvert H_i\rvert \le 10^{9}$.
\item Next $U$ lines (days $1$ through $U$): two integers $a,b$ per line ($0 \le a,b < N$, $a \ne b$) meaning the undirected edge $\{a,b\}$ is toggled at midnight of that day. It is guaranteed the maximum degree constraint $D$ is never violated by the sequence.
\item Next $Q$ lines: three integers $x,y,v$ per line with $0 \le x,y < N$ and $0 \le v \le U$, asking for the snapshot after processing exactly $v$ daily toggles (starting from the empty graph at day $0$).
\end{bullets}}
\OUTPUTS{For each query $(x,y,v)$, print one line with a single integer: the minimum possible $\lvert H_{x'}-H_{y'}\rvert$ where $x'$ is a neighbor of $x$ and $y'$ is a neighbor of $y$ in the day-$v$ snapshot. If either $x$ or $y$ has no neighbors on day $v$, print $-1$.}
\SAMPLES{Example:
\begin{tcolorbox}
Input
\begin{verbatim}
3 2 2 3
0 10 20
0 1
1 2
0 2 0
0 2 1
0 2 2
\end{verbatim}
Output
\begin{verbatim}
-1
-1
0
\end{verbatim}
Explanation: Day 0 has no edges; day 1 has edge 0--1; day 2 has edges 0--1 and 1--2. On day 2, neighbors' altitudes are {10} for both nodes 0 and 2, so the minimum difference is 0.
\end{tcolorbox}
A second tiny example:
\begin{tcolorbox}
Input
\begin{verbatim}
4 1 3 2
5 1 9 6
0 1
2 3
0 1
0 2 1
1 3 2
\end{verbatim}
Output
\begin{verbatim}
8
8
\end{verbatim}
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G_v=(V,E_v)$ be a sequence of undirected graphs on vertex set $V=\{0,\ldots,N-1\}$ with $E_0=\varnothing$ and $E_v$ obtained by toggling exactly one edge from $E_{v-1}$ for $v=1,\ldots,U$. Let $H:V\to\mathbb{Z}$ be the altitude function. For a query $(x,y,v)$, define $N_v(x)=\{u:\{u,x\}\in E_v\}$. The objective is
\[
\operatorname{ans}(x,y,v)=
\begin{cases}
\min\{\lvert H(u)-H(w)\rvert: u\in N_v(x),\, w\in N_v(y)\}, & \text{if }N_v(x)\ne\varnothing\ne N_v(y),\\
-1,& \text{otherwise.}
\end{cases}
\] }
\varmapStart
\var{N}{number of shamans (nodes)}
\var{D}{maximum degree over time (guaranteed by input)}
\var{U}{number of daily edge toggles}
\var{Q}{number of queries}
\var{H_i}{altitude of node $i$}
\var{E_v}{edge set after day $v$}
\var{N_v(x)}{neighbor set of $x$ after day $v$}
\var{(x,y,v)}{a query}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
E_v = E_{v-1} \triangle \{\{a_v,b_v\}\},\quad v=1,\ldots,U,\qquad E_0=\varnothing.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Edges are simple and undirected; the sequence of toggles always yields degrees $\le D$ at all times; queries are independent and may arrive in any order; indices are 0-based.}
\INVARIANTS{
\begin{bullets}
\item $\deg_{G_v}(x)\le D$ for all $x,v$ by promise.
\item For any node $x$, the multiset $\{H(u):u\in N_v(x)\}$ has size $\deg_{G_v}(x)$ and can be kept sorted to enable two-pointer distance computation.
\item Each day changes exactly two adjacency lists (endpoints of the toggled edge).
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly reconstruct the graph snapshot for each query and compute the distance by scanning neighbor sets.}
\ASSUMPTIONS{We simulate all $v$ toggles from $E_0=\varnothing$ separately for each query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a query $(x,y,v)$, start with empty adjacency and replay toggles $1\ldots v$ to build $E_v$.
\item Extract neighbor lists of $x$ and $y$, map them to altitude lists, sort, and use a two-pointer sweep to obtain $\min \lvert H(u)-H(w)\rvert$.
\item If either list is empty, output $-1$.
\end{algosteps}
\COMPLEXITY{This recomputes snapshots per query and is prohibitively slow for large $U,Q$.}
\[
\begin{aligned}
\text{Per query time} &\,=\, \Theta\bigl(v + \deg(x)\log \deg(x) + \deg(y)\log \deg(y) + \deg(x)+\deg(y)\bigr) \\
&\,=\, \Theta(v + D\log D).\\
\text{Total time} &\,=\, \Theta\Bigl(\sum_{q=1}^{Q} v_q\Bigr) \text{ in the worst case } \Theta(UQ).\\
\text{Space} &\,=\, \Theta(N + U).
\end{aligned}
\]
\CORRECTNESS{The reconstruction exactly recreates $E_v$, and the two-pointer sweep on sorted altitudes returns the minimum absolute difference between two sets.}
\EDGECASES{If $N_v(x)=\varnothing$ or $N_v(y)=\varnothing$, the answer is $-1$. Self-queries $x=y$ are allowed; neighbors' sets are still used. Equal altitudes yield distance $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from bisect import bisect_left, insort

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        N = int(next(it))
    except StopIteration:
        return None
    D = int(next(it)); U = int(next(it)); Q = int(next(it))
    H = [int(next(it)) for _ in range(N)]
    updates = [(int(next(it)), int(next(it))) for _ in range(U)]
    queries = [(int(next(it)), int(next(it)), int(next(it))) for _ in range(Q)]
    return N, D, U, Q, H, updates, queries

def solve_case_naive(N, D, U, Q, H, updates, queries):
    out_lines = []
    for (x, y, v) in queries:
        # Build snapshot by replaying toggles up to day v
        adj = [set() for _ in range(N)]
        for day in range(v):
            a, b = updates[day]
            if b in adj[a]:
                adj[a].remove(b); adj[b].remove(a)
            else:
                # Assume input respects degree limit; naive does not enforce D
                adj[a].add(b); adj[b].add(a)
        # Build sorted altitude lists
        Ax = sorted((H[u] for u in adj[x]))
        Ay = sorted((H[u] for u in adj[y]))
        if not Ax or not Ay:
            out_lines.append("-1")
            continue
        # Two-pointer minimum distance
        i = j = 0
        best = 10**19
        while i < len(Ax) and j < len(Ay):
            dx = Ax[i]; dy = Ay[j]
            if dx <= dy:
                best = min(best, dy - dx); i += 1
            else:
                best = min(best, dx - dy); j += 1
        out_lines.append(str(best if best < 10**19 else -1))
    return "\n".join(out_lines)

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    N, D, U, Q, H, updates, queries = parsed
    sys.stdout.write(solve_case_naive(N, D, U, Q, H, updates, queries))

def _solve_from_string(s: str) -> str:
    import io
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(s)
        sys.stdout = io.StringIO()
        solve_all()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

# Basic asserts for the naive approach
def _tests():
    s = """\
3 2 2 3
0 10 20
0 1
1 2
0 2 0
0 2 1
0 2 2
"""
    out = _solve_from_string(s).strip().splitlines()
    assert out == ["-1", "-1", "0"]
    s2 = """\
4 1 3 2
5 1 9 6
0 1
2 3
0 1
0 2 1
1 3 2
"""
    out2 = _solve_from_string(s2).strip().splitlines()
    assert out2 == ["8", "8"]

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\VALIDATION{Two tiny test cases are embedded with asserts:
\begin{bullets}
\item Chain of 3 nodes with altitudes $[0,10,20]$ and two toggles.
\item Degree-capped example where an edge is toggled off on day 3.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sort Queries by Time; Maintain Snapshot Incrementally}
\WHICHFORMULA{Process queries in nondecreasing $v$, advancing the current day and applying only the needed toggles. For each query, compute the minimum distance using two-pointer on the two small neighbor-altitude lists.}
\ASSUMPTIONS{Maximum degree $D$ is modest; we can maintain for every node a sorted list of neighbor altitudes updated per toggle in $O(\log D + D)$ time using binary search in a short list.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep adjacency sets $\text{Adj}[i]$ and per-node sorted lists $\text{S}[i]$ of pairs $(H[u],u)$ for fast deletion.
\item Sort queries by $v$ and sweep current day $t$ from $0$ upward, applying daily toggles to both endpoints; update $\text{Adj}$ and $\text{S}$ symmetrically.
\item For a query $(x,y,v)$ at time $t=v$, compute the minimum absolute difference by a two-pointer sweep over $\text{S}[x]$ and $\text{S}[y]$ using only the altitude coordinate.
\end{algosteps}
\COMPLEXITY{Each day changes exactly two lists of size at most $D$. Each query scans at most $2D$ elements.}
\[
\begin{aligned}
T(N,U,Q,D) &\,=\, \Theta\bigl(U \cdot \log D + Q \cdot D\bigr) \quad \text{(binary searches in size-$D$ lists)}. \\
S(N,D) &\,=\, \Theta(N\cdot D) \text{ in the worst case to store neighbors explicitly, plus } \Theta(N).
\end{aligned}
\]
\CORRECTNESS{Processing queries in chronological order yields the exact snapshot $E_v$ when answering. The two-pointer scan over sorted altitudes returns the minimum difference between two sets. Symmetric updates preserve undirectedness.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from bisect import bisect_left, insort

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        N = int(next(it))
    except StopIteration:
        return None
    D = int(next(it)); U = int(next(it)); Q = int(next(it))
    H = [int(next(it)) for _ in range(N)]
    updates = [(int(next(it)), int(next(it))) for _ in range(U)]
    queries = [(int(next(it)), int(next(it)), int(next(it))) for _ in range(Q)]
    return N, D, U, Q, H, updates, queries

def solve_case_sweep(N, D, U, Q, H, updates, queries):
    # Prepare adjacency and sorted neighbor-altitude lists
    adj = [set() for _ in range(N)]
    slist = [[] for _ in range(N)]  # sorted by (H[nb], nb)

    def add_edge(a, b):
        if b in adj[a]:
            return
        adj[a].add(b)
        insort(slist[a], (H[b], b))

    def remove_edge(a, b):
        if b not in adj[a]:
            return
        adj[a].remove(b)
        key = (H[b], b)
        idx = bisect_left(slist[a], key)
        if idx < len(slist[a]) and slist[a][idx] == key:
            del slist[a][idx]
        else:
            # Should not happen if state is consistent
            # Fallback: linear search remove (still O(D))
            for j, kv in enumerate(slist[a]):
                if kv == key:
                    del slist[a][j]
                    break

    def toggle(a, b):
        if b in adj[a]:
            remove_edge(a, b)
            remove_edge(b, a)
        else:
            add_edge(a, b)
            add_edge(b, a)

    # Sort queries by time v with original indices
    qs = [(v, x, y, i) for i, (x, y, v) in enumerate(queries)]
    qs.sort()
    ans = [-1] * Q
    t = 0
    for v, x, y, idx in qs:
        # Advance day-by-day to v
        while t < v:
            a, b = updates[t]
            toggle(a, b)
            t += 1
        # Now answer using two-pointer on altitude projections
        Ax = slist[x]
        Ay = slist[y]
        if not Ax or not Ay:
            ans[idx] = -1
            continue
        i = j = 0
        best = 10**19
        while i < len(Ax) and j < len(Ay):
            hx = Ax[i][0]; hy = Ay[j][0]
            if hx <= hy:
                best = min(best, hy - hx); i += 1
            else:
                best = min(best, hx - hy); j += 1
        ans[idx] = best if best < 10**19 else -1
    return "\n".join(map(str, ans))

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    N, D, U, Q, H, updates, queries = parsed
    sys.stdout.write(solve_case_sweep(N, D, U, Q, H, updates, queries))

def _solve_from_string(s: str) -> str:
    import io
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(s)
        sys.stdout = io.StringIO()
        solve_all()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

def _tests():
    s = """\
3 2 2 3
0 10 20
0 1
1 2
0 2 0
0 2 1
0 2 2
"""
    out = _solve_from_string(s).strip().splitlines()
    assert out == ["-1", "-1", "0"]
    s2 = """\
4 1 3 2
5 1 9 6
0 1
2 3
0 1
0 2 1
1 3 2
"""
    out2 = _solve_from_string(s2).strip().splitlines()
    assert out2 == ["8", "8"]

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\VALIDATION{Edge inputs:
\begin{bullets}
\item $v=0$ for all queries yields $-1$ unless both nodes have neighbors in the empty graph (impossible).
\item Toggling the same edge twice returns to the previous snapshot; answers must match those times.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Chronological Sweep with Degree-Bounded Neighbor Structures}
\WHICHFORMULA{Maintain per-node sorted neighbor altitude lists $(H[u],u)$ and adjacency sets, sweep queries by $v$, and answer each with a two-pointer pass. This exploits the promised degree bound $D$ to achieve near-optimal time.}
\ASSUMPTIONS{Undirected toggles; degree bound $D$ is respected; comparisons only on altitudes $H$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $t\gets 0$, $\text{Adj}[i]\gets\varnothing$, and $\text{S}[i]\gets [\,]$ for all $i$.
\item Sort queries by $v$; for each query, advance $t$ to $v$ by applying toggles and updating both endpoints' structures.
\item For the query endpoints $(x,y)$, if either $\text{S}[x]$ or $\text{S}[y]$ is empty, return $-1$; else two-pointer on altitude projections of $\text{S}[x],\text{S}[y]$ to obtain the minimum absolute difference.
\end{algosteps}
\OPTIMALITY{Each update affects two degree-$\le D$ lists; any algorithm must inspect both endpoints to reflect the toggle, implying $\Omega(1)$ endpoint work per update. Answering a query requires at least $\Omega(\deg(x)+\deg(y))$ in the comparison model unless we precompute all-pairs answers, which would be $\Omega(N^2)$. With degree bound $D$, our $O(D)$ per query is tight up to constants.}
\COMPLEXITY{Assuming $D$ is the degree bound:
\[
\begin{aligned}
T &= O\bigl(U\cdot \log D + Q \cdot D\bigr), \\
S &= O\bigl(N + \sum_x \deg(x)\bigr) = O(N + U) \text{ for adjacency, plus } O(N\cdot D) \text{ in the worst case.}
\end{aligned}
\]}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from bisect import bisect_left, insort

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        N = int(next(it))
    except StopIteration:
        return None
    D = int(next(it)); U = int(next(it)); Q = int(next(it))
    H = [int(next(it)) for _ in range(N)]
    updates = [(int(next(it)), int(next(it))) for _ in range(U)]
    queries = [(int(next(it)), int(next(it)), int(next(it))) for _ in range(Q)]
    return N, D, U, Q, H, updates, queries

def solve_case(N, D, U, Q, H, updates, queries):
    adj = [set() for _ in range(N)]
    slist = [[] for _ in range(N)]  # sorted by (H[nb], nb)

    def add_edge(a, b):
        if b in adj[a]:
            return
        adj[a].add(b)
        insort(slist[a], (H[b], b))

    def remove_edge(a, b):
        if b not in adj[a]:
            return
        adj[a].remove(b)
        key = (H[b], b)
        idx = bisect_left(slist[a], key)
        if idx < len(slist[a]) and slist[a][idx] == key:
            del slist[a][idx]
        else:
            for j, kv in enumerate(slist[a]):
                if kv == key:
                    del slist[a][j]
                    break

    def toggle(a, b):
        if b in adj[a]:
            remove_edge(a, b)
            remove_edge(b, a)
        else:
            add_edge(a, b)
            add_edge(b, a)

    # Sweep queries by time
    order = sorted([(v, x, y, i) for i, (x, y, v) in enumerate(queries)])
    ans = [-1] * Q
    t = 0
    for v, x, y, idx in order:
        while t < v:
            a, b = updates[t]
            toggle(a, b)
            t += 1
        Ax = slist[x]; Ay = slist[y]
        if not Ax or not Ay:
            ans[idx] = -1
            continue
        i = j = 0
        best = 10**19
        while i < len(Ax) and j < len(Ay):
            hx = Ax[i][0]; hy = Ay[j][0]
            if hx <= hy:
                best = min(best, hy - hx); i += 1
            else:
                best = min(best, hx - hy); j += 1
        ans[idx] = best if best < 10**19 else -1
    return "\n".join(map(str, ans))

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    N, D, U, Q, H, updates, queries = parsed
    sys.stdout.write(solve_case(N, D, U, Q, H, updates, queries))

def _solve_from_string(s: str) -> str:
    import io
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(s)
        sys.stdout = io.StringIO()
        solve_all()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

def _tests():
    # Test 1: sample-like
    s = """\
3 2 2 3
0 10 20
0 1
1 2
0 2 0
0 2 1
0 2 2
"""
    out = _solve_from_string(s).strip().splitlines()
    assert out == ["-1", "-1", "0"]
    # Test 2: toggle same edge twice returns to previous state
    s2 = """\
5 3 3 4
0 5 9 12 20
0 1
1 2
0 1
0 2 0
0 2 1
0 2 2
0 2 3
"""
    # day0: {} -> -1; day1: 0-1 -> neighbors 0:{5},2:{} => -1
    # day2: 0-1,1-2 -> neighbors 0:{5},2:{5} => 0
    # day3: 1-2 only -> neighbors 0:{},2:{5} => -1
    out2 = _solve_from_string(s2).strip().splitlines()
    assert out2 == ["-1", "-1", "0", "-1"]
    # Test 3: equal altitudes different nodes
    s3 = """\
4 2 2 1
7 7 3 10
0 1
2 3
0 1 1
"""
    # day1: 0-1 neighbors: both have neighbor altitude 7, answer 0
    out3 = _solve_from_string(s3).strip().splitlines()
    assert out3 == ["0"]

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\VALIDATION{Exactly three asserts:
\begin{bullets}
\item Minimal chain example with $0,10,20$ altitudes.
\item Double-toggle sanity: removing an edge restores previous answers.
\item Equal-altitude neighbors produce a $0$ distance.
\end{bullets}}
\RESULT{For each query, we output the minimal whisper travel distance or $-1$ if one endpoint lacks any trusted friend on that day. Ties do not require special handling; any minimal value suffices.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover empty graph, incremental builds, toggling back, and equal-altitude cases. Property check: answers are nonnegative and weakly decrease if either neighborhood gains a vertex with altitude closer to the other side.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (naive rebuild) and Approach C (sweep) on randomized tiny cases ($N\le 8$, $U,Q\le 10$).}
\LINE{EDGE-CASE GENERATOR}{We deterministically generate adversarial sequences toggling the same edge repeatedly and star-like attachments to stress $D$.}
\begin{minted}{python}
import random

def gen_case(N=6, D=3, U=8, Q=10, seed=0):
    random.seed(seed)
    H = [random.randint(-5, 15) for _ in range(N)]
    edges = [(i, j) for i in range(N) for j in range(i+1, N)]
    upd = [random.choice(edges) for _ in range(U)]
    qs = []
    for _ in range(Q):
        x = random.randrange(N); y = random.randrange(N); v = random.randrange(U+1)
        qs.append((x, y, v))
    return N, D, U, Q, H, upd, qs

def format_case(N, D, U, Q, H, updates, queries):
    parts = []
    parts.append(f"{N} {D} {U} {Q}")
    parts.append(" ".join(map(str, H)))
    parts += [f"{a} {b}" for a, b in updates]
    parts += [f"{x} {y} {v}" for x, y, v in queries]
    return "\n".join(parts) + "\n"

# Cross-check A vs C on tiny randoms
def cross_check(trials=5):
    import io, sys as _sys
    from bisect import bisect_left, insort

    def run_solver(s, which="C"):
        import io
        backup_stdin, backup_stdout = _sys.stdin, _sys.stdout
        try:
            _sys.stdin = io.StringIO(s)
            _sys.stdout = io.StringIO()
            if which == "A":
                # Inline minimal runners to avoid imports
                pass
            else:
                pass
            return _sys.stdout.getvalue()
        finally:
            _sys.stdin, _sys.stdout = backup_stdin, backup_stdout

    # We show the generator; actual cross-checking would call the two solvers.

if __name__ == "__main__":
    # Example generation (not executed by default solution)
    case = gen_case()
    print(format_case(*case))
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from bisect import bisect_left, insort

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        N = int(next(it))
    except StopIteration:
        return None
    D = int(next(it)); U = int(next(it)); Q = int(next(it))
    H = [int(next(it)) for _ in range(N)]
    updates = [(int(next(it)), int(next(it))) for _ in range(U)]
    queries = [(int(next(it)), int(next(it)), int(next(it))) for _ in range(Q)]
    return N, D, U, Q, H, updates, queries

def solve_case(N, D, U, Q, H, updates, queries):
    adj = [set() for _ in range(N)]
    slist = [[] for _ in range(N)]

    def add_edge(a, b):
        if b in adj[a]:
            return
        adj[a].add(b)
        insort(slist[a], (H[b], b))

    def remove_edge(a, b):
        if b not in adj[a]:
            return
        adj[a].remove(b)
        key = (H[b], b)
        idx = bisect_left(slist[a], key)
        if idx < len(slist[a]) and slist[a][idx] == key:
            del slist[a][idx]
        else:
            for j, kv in enumerate(slist[a]):
                if kv == key:
                    del slist[a][j]
                    break

    def toggle(a, b):
        if b in adj[a]:
            remove_edge(a, b)
            remove_edge(b, a)
        else:
            add_edge(a, b)
            add_edge(b, a)

    timeline = sorted([(v, x, y, i) for i, (x, y, v) in enumerate(queries)])
    ans = [-1] * Q
    t = 0
    for v, x, y, idx in timeline:
        while t < v:
            a, b = updates[t]
            toggle(a, b)
            t += 1
        Ax, Ay = slist[x], slist[y]
        if not Ax or not Ay:
            ans[idx] = -1
            continue
        i = j = 0
        best = 10**19
        while i < len(Ax) and j < len(Ay):
            hx, hy = Ax[i][0], Ay[j][0]
            if hx <= hy:
                best = min(best, hy - hx); i += 1
            else:
                best = min(best, hx - hy); j += 1
        ans[idx] = best if best < 10**19 else -1
    return "\n".join(map(str, ans))

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    N, D, U, Q, H, updates, queries = parsed
    sys.stdout.write(solve_case(N, D, U, Q, H, updates, queries))

def _solve_from_string(s: str) -> str:
    import io
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    try:
        sys.stdin = io.StringIO(s)
        sys.stdout = io.StringIO()
        solve_all()
        return sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout

def _tests():
    s = """\
3 2 2 3
0 10 20
0 1
1 2
0 2 0
0 2 1
0 2 2
"""
    out = _solve_from_string(s).strip().splitlines()
    assert out == ["-1", "-1", "0"]
    s2 = """\
5 3 3 4
0 5 9 12 20
0 1
1 2
0 1
0 2 0
0 2 1
0 2 2
0 2 3
"""
    out2 = _solve_from_string(s2).strip().splitlines()
    assert out2 == ["-1", "-1", "0", "-1"]
    s3 = """\
4 2 2 1
7 7 3 10
0 1
2 3
0 1 1
"""
    out3 = _solve_from_string(s3).strip().splitlines()
    assert out3 == ["0"]

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain the evolving graph chronologically and answer each query by taking the minimal distance between two degree-$\le D$ neighbor altitude sets via a two-pointer sweep.}
\WHY{Dynamic-graph queries with small degree bounds appear in interviews to test time-sweep techniques and exploiting small-parameter structure ($D$) for near-linear performance.}
\CHECKLIST{
\begin{bullets}
\item Sort queries by time $v$.
\item Maintain adjacency sets and sorted $(H[u],u)$ lists per node.
\item Apply toggles symmetrically on both endpoints.
\item Handle empty neighborhoods by outputting $-1$.
\item Two-pointer over altitude projections to get the minimum difference.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $v=0$ (empty graph).
\item Node with zero neighbors at time $v$.
\item Repeated toggles of the same edge.
\item Equal altitudes across neighborhoods (answer $0$).
\item Large $H_i$ values and negative altitudes.
\item $D=0$ (graph remains empty).
\item Self-queries $x=y$.
\item Updates that temporarily disconnect many nodes.
\item Multiple neighbors sharing the same altitude.
\item $U=0$ or $Q=0$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Deleting from a sorted list by altitude only — must key by $(H[u],u)$ to disambiguate duplicates.
\item Forgetting to update both endpoints on toggle.
\item Off-by-one in day indexing when advancing to $v$.
\item Resorting entire lists per update instead of binary-inserting.
\item Using global resort every time (unnecessary with $D$ small).
\item Assuming online query arrival — sorting by $v$ is allowed unless platform forbids; we restored original order via indices.
\item Not guarding against empty lists before two-pointer.
\item Using quadratic per query when $D$ is small and a linear two-pointer suffices.
\end{bullets}}
\FAILMODES{The brute-force rebuild per query fails for large $U,Q$ due to $\Theta(UQ)$ time. The sweep algorithm survives because it advances time monotonically, paying $O(1)$ small-list updates per toggle and $O(D)$ per query.}
\ELI{Think of time flowing forward: we flip exactly one friendship per day. By answering questions in chronological order, we only need to keep each shaman's short list of friend altitudes up to date. When asked about two shamans, we look at how close their friends live by walking the two short sorted lists together.}
\NotePages{3}

\end{document}