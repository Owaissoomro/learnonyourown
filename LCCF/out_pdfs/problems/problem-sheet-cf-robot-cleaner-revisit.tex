% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Robot Cleaner Revisit}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1623/D}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{The statement of this problem shares a lot with problem A. The differences are that in this problem, the probability is introduced, and the constraint is different.

A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of $n$ rows and $m$ columns. The rows of the floor are numbered from $1$ to $n$ from top to bottom, and columns of the floor are numbered from $1$ to $m$ from left to right. The cell on the intersection of the $r$-th row and the $c$-th column is denoted as $(r,c)$. The initial position of the robot is $(r_b, c_b)$.

In one second, the robot moves by $dr$ rows and $dc$ columns, that is, after one second, the robot moves from the cell $(r, c)$ to $(r + dr, c + dc)$. Initially $dr = 1$, $dc = 1$. If there is a vertical wall (the left or the right walls) in the movement direction, $dc$ is reflected before the movement, so the new value of $dc$ is $-dc$. And if there is a horizontal wall (the upper or lower walls), $dr$ is reflected before the movement, so the new value of $dr$ is $-dr$.

Each second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at $(r_d, c_d)$. The job of the robot is to clean that dirty cell.

After a lot of testings in problem A, the robot is now broken. It cleans the floor as described above, but at each second the cleaning operation is performed with probability $\tfrac{p}{100}$ only, and not performed with probability $1 - \tfrac{p}{100}$. The cleaning or not cleaning outcomes are independent each second.

Given the floor size $n$ and $m$, the robot's initial position $(r_b, c_b)$ and the dirty cell's position $(r_d, c_d)$, find the expected time for the robot to do its job.

It can be shown that the answer can be expressed as an irreducible fraction $\tfrac{x}{y}$, where $x$ and $y$ are integers and $y \not\equiv 0 \pmod{10^9 + 7}$. Output the integer equal to $x \cdot y^{-1} \bmod (10^9 + 7)$. In other words, output such an integer $a$ that $0 \le a < 10^9 + 7$ and $a \cdot y \equiv x \pmod {10^9 + 7}$.

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10$). Description of the test cases follows.

A test case consists of only one line, containing $n$, $m$, $r_b$, $c_b$, $r_d$, $c_d$, and $p$ ($4 \le n \cdot m \le 10^5$, $n, m \ge 2$, $1 \le r_b, r_d \le n$, $1 \le c_b, c_d \le m$, $1 \le p \le 99$) — the sizes of the room, the initial position of the robot, the position of the dirt cell and the probability of cleaning in percentage.

Output:
For each test case, print a single integer — the expected time for the robot to clean the dirty cell, modulo $10^9 + 7$.

Note:
In the first test case, the robot has the opportunity to clean the dirty cell every second. Using the geometric distribution, we can find out that with the success rate of $25\%$, the expected number of tries to clear the dirty cell is $\tfrac{1}{0.25} = 4$. But because the first moment the robot has the opportunity to clean the cell is before the robot starts moving, the answer is $3$.

Illustration for the first example. The blue arc is the robot. The red star is the target dirt cell. The purple square is the initial position of the robot. Each second the robot has an opportunity to clean a row and a column, denoted by yellow stripes.

In the second test case, the board size and the position are different, but the robot still has the opportunity to clean the dirty cell every second, and it has the same probability of cleaning. Therefore the answer is the same as in the first example.

Illustration for the second example.

The third and the fourth case are almost the same. The only difference is that the position of the dirty cell and the robot are swapped. But the movements in both cases are identical, hence the same result.}
\BREAKDOWN{The motion in each axis is a periodic reflection with period $2(n-1)$ and $2(m-1)$. The robot can clean the target only at seconds when either its row equals $r_d$ or its column equals $c_d$. Cleaning succeeds independently with probability $q=\tfrac{p}{100}$. Over one combined period $L=\operatorname{lcm}(2(n-1),\,2(m-1))$, the pattern of opportunities repeats, allowing a closed-form expected time via periodic geometric series.}
\ELI{Compute all seconds in one period when the robot lines up with the target's row or column, then combine them with the cleaning probability using a geometric-series formula.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n, m, r_b, c_b, r_d, c_d, p$ with $n, m \ge 2$, $4 \le n \cdot m \le 10^5$, $1 \le r_b, r_d \le n$, $1 \le c_b, c_d \le m$, $1 \le p \le 99$.}
\OUTPUTS{For each test, a single integer: the expected time to clean, modulo $10^9+7$.}
\SAMPLES{Example 1:
Input
1
2 2 1 1 1 1 100
Output
0

Example 2:
Input
1
2 2 1 1 2 2 100
Output
1}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the robot position at integer time $t \ge 0$ be $(r(t),c(t))$, where the reflections follow ``bouncing'' on $[1,n]$ and $[1,m]$. Let $a_t \in \{0,1\}$ indicate an ``opportunity'' at time $t$: $a_t=1$ iff $r(t)=r_d$ or $c(t)=c_d$. Cleaning succeeds at time $t$ with probability $q a_t$, where $q=\tfrac{p}{100}$, independently over $t$.}
\varmapStart
\var{n,m}{room dimensions}
\var{r_b,c_b}{robot initial position}
\var{r_d,c_d}{dirty cell position}
\var{q}{clean probability per second, $q=\tfrac{p}{100}$}
\var{L}{combined period, $L=\operatorname{lcm}(2(n-1),\,2(m-1))$}
\var{S}{period failure probability, $S=\prod_{t=0}^{L-1}(1-qa_t)$}
\var{w_t}{within-period success weight, $w_t = qa_t\prod_{i=0}^{t-1}(1-qa_i)$}
\varmapEnd
\GOVERN{
\[
\text{For } t \ge 0:\quad
\mathbb{P}(\text{success at }t) = q a_t \prod_{i=0}^{t-1}(1-qa_i).
\]
\begin{BreakableEquation*}
\text{Pattern repeats every }L,\ \ a_{t+L}=a_t.
\end{BreakableEquation*}
\[
\mathbb{E}[T] \;=\; \sum_{j\ge 0}\sum_{t=0}^{L-1} (t+jL)\, S^j\, w_t
\;=\; \frac{L S}{1-S} + \frac{\sum_{t=0}^{L-1} t\, w_t}{1-S}.
\]
}
\ASSUMPTIONS{The bouncing motion on each axis cycles over period $2(n-1)$ and $2(m-1)$, visiting all positions. Independence of cleaning outcomes across seconds.}
\INVARIANTS{In one period $L$, the multiset of opportunities $\{t:a_t=1\}$ is fixed; $S=(1-q)^k$ where $k=\#\{t\in[0,L):a_t=1\}$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the robot's motion for one full combined period $L$, marking every second $t$ with an opportunity and accumulating $t\,q(1-q)^{\#\text{prior opps}}$. Then use $\mathbb{E}[T]=\dfrac{LS+\sum t w_t}{1-S}$.}
\ASSUMPTIONS{Direct simulation over at most $L=\operatorname{lcm}(2(n-1),2(m-1))$ steps is feasible since $n\cdot m \le 10^5 \Rightarrow L$ is small in practice.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $R=2(n-1)$, $C=2(m-1)$, $L=\operatorname{lcm}(R,C)$.
\item Simulate $t=0,\ldots,L-1$ with $(r,c,dr,dc)$ bouncing. At each $t$, if $r=r_d$ or $c=c_d$, add $t \cdot q \cdot \text{cur\_fail}$ to the sum and update $\text{cur\_fail}\leftarrow \text{cur\_fail}\cdot (1-q)$.
\item Set $S=\text{cur\_fail}$ at the end. Return $\big(L\cdot S + \sum t w_t\big)/(1-S)$ modulo $10^9+7$.
\end{algosteps}
\COMPLEXITY{Simulating one period:
\[
\begin{aligned}
T(n) &= \mathcal{O}(L) = \mathcal{O}(\operatorname{lcm}(2(n-1),2(m-1))) \\
     &\le \mathcal{O}(n+m) \text{ in practice under } n\cdot m \le 10^5,\\
S(n) &= \mathcal{O}(1).
\end{aligned}
\]
}
\CORRECTNESS{Every second within a period is visited exactly once; opportunities repeat with period $L$. Independence across seconds implies period-wise geometric sums collapse to the closed form.}
\EDGECASES{Initial opportunity at $t=0$. Boundaries reflect before moving. $p\in[1,99]$ guarantees $q\neq 0$, and the robot always has at least one opportunity per period, ensuring $S\neq 1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 1623D — Robot Cleaner Revisit
# Baseline: simulate one full period of the bouncing motion.

import sys
from math import gcd

MOD = 1_000_000_007

def modinv(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def lcm(a: int, b: int) -> int:
    return a // gcd(a, b) * b

def solve_case_baseline(n, m, rb, cb, rd, cd, p):
    R = 2 * (n - 1)
    C = 2 * (m - 1)
    L = lcm(R, C)

    inv100 = modinv(100)
    q = (p * inv100) % MOD
    one_minus_q = (1 - q) % MOD

    r, c = rb, cb
    dr, dc = 1, 1

    cur_fail = 1  # (1-q)^(# of prior opportunities in the current period)
    sum_t_wt = 0  # sum over opportunities: t * q * (1-q)^{prior}

    for t in range(L):
        if r == rd or c == cd:
            sum_t_wt = (sum_t_wt + (t % MOD) * q % MOD * cur_fail) % MOD
            cur_fail = (cur_fail * one_minus_q) % MOD

        # reflect before movement if hitting walls
        if r + dr < 1 or r + dr > n:
            dr = -dr
        if c + dc < 1 or c + dc > m:
            dc = -dc
        r += dr
        c += dc

    S = cur_fail  # probability to fail within one period

    denom = (1 - S) % MOD
    inv_denom = modinv(denom)
    ans = ((L % MOD) * S + sum_t_wt) % MOD
    ans = (ans * inv_denom) % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        rb = int(next(it)); cb = int(next(it))
        rd = int(next(it)); cd = int(next(it))
        p = int(next(it))
        cases.append((n, m, rb, cb, rd, cd, p))
    return t, cases

def solve_all_baseline(cases):
    out = []
    for (n, m, rb, cb, rd, cd, p) in cases:
        out.append(str(solve_case_baseline(n, m, rb, cb, rd, cd, p)))
    return "\n".join(out)

def main():
    t, cases = read_input()
    if t:
        print(solve_all_baseline(cases))

if __name__ == "__main__":
    # Tiny sanity asserts (do not print):
    assert solve_case_baseline(2, 2, 1, 1, 1, 1, 100) == 0
    assert solve_case_baseline(2, 2, 1, 1, 2, 2, 100) == 1
    # A few more checks
    _ans1 = solve_case_baseline(2, 3, 1, 1, 2, 3, 50)
    _ans2 = solve_case_baseline(3, 2, 1, 1, 3, 2, 50)
    # Symmetry under swapping n/m and r/c for rectangular swap
    assert _ans1 == _ans2
    main()
\end{minted}
\VALIDATION{Sanity on $2\times 2$ with $p=100$ gives $0$ and $1$ as expected. Symmetry checks across transposed boards confirm consistency.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Avoid step-by-step simulation by generating all opportunity times within one period using modular arithmetic on the bouncing trajectory. Row opportunities are the union of two residues modulo $2(n-1)$; similarly for columns. Their union over $[0,L)$ yields all opportunity times.}
\ASSUMPTIONS{Use congruence classes: if we index rows/cols by $0$-based positions on a $2N$-cycle, hitting value $y$ occurs when the linear index equals $y$ or $2N-y$ modulo $2N$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $R=2(n-1)$, $C=2(m-1)$, $L=\operatorname{lcm}(R,C)$; $rb_0=rb-1$, $rd_0=rd-1$, and similarly for columns.
\item Row residues: $a_r^{(1)}\equiv rd_0-rb_0 \pmod{R}$ and $a_r^{(2)}\equiv R-rd_0-rb_0 \pmod{R}$. Column residues analogously modulo $C$.
\item For each residue $a$ modulo its period, enumerate $t=a+k\cdot \text{period}$ for $k=0,\ldots,\tfrac{L}{\text{period}}-1$. Put all such $t$ into a set to form the union.
\item Sort the unique $t$ in $[0,L)$. Fold them in increasing order with the same $q,(1-q)$ accumulation to compute $\sum t w_t$ and $S=(1-q)^k$.
\item Return $\big(L\cdot S + \sum t w_t\big)/(1-S)$ modulo $10^9+7$.
\end{algosteps}
\COMPLEXITY{Let $k_r \le 2\cdot \tfrac{L}{R}$ and $k_c \le 2\cdot \tfrac{L}{C}$. The union has size $k \le k_r + k_c$, and the whole method runs in $\mathcal{O}(k\log k)$ due to sorting (often $\mathcal{O}(k)$ since $k$ is tiny here).}
\[
\begin{aligned}
T(n) &= \mathcal{O}\!\left(\tfrac{L}{R}+\tfrac{L}{C}+\log L\right), \quad S(n)=\mathcal{O}(1).
\end{aligned}
\]
\CORRECTNESS{Equating the bounce to linear motion on a cycle captures exactly the hitting times for given row/column values; the union of the two row and two column congruences produces all and only opportunity times.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved: generate opportunity times by congruences (no step simulation).

import sys
from math import gcd

MOD = 1_000_000_007

def modinv(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def lcm(a: int, b: int) -> int:
    return a // gcd(a, b) * b

def opportunity_times(n, m, rb, cb, rd, cd):
    # Returns sorted unique times t in [0, L) when r==rd or c==cd.
    R = 2 * (n - 1)
    C = 2 * (m - 1)
    L = lcm(R, C)

    rb0, rd0 = rb - 1, rd - 1
    cb0, cd0 = cb - 1, cd - 1

    # residues for row equality
    ar1 = (rd0 - rb0) % R
    ar2 = (R - rd0 - rb0) % R
    row_res = {ar1, ar2}

    # residues for col equality
    ac1 = (cd0 - cb0) % C
    ac2 = (C - cd0 - cb0) % C
    col_res = {ac1, ac2}

    times = set()
    LR = L // R
    LC = L // C

    for a in row_res:
        for k in range(LR):
            times.add(a + k * R)
    for a in col_res:
        for k in range(LC):
            times.add(a + k * C)

    ts = sorted(times)
    return L, ts

def solve_case_improved(n, m, rb, cb, rd, cd, p):
    L, ts = opportunity_times(n, m, rb, cb, rd, cd)
    inv100 = modinv(100)
    q = (p * inv100) % MOD
    one_minus_q = (1 - q) % MOD

    cur_fail = 1
    sum_t_wt = 0
    for t in ts:
        sum_t_wt = (sum_t_wt + (t % MOD) * q % MOD * cur_fail) % MOD
        cur_fail = (cur_fail * one_minus_q) % MOD

    S = cur_fail
    denom = (1 - S) % MOD
    inv_denom = modinv(denom)
    ans = ((L % MOD) * S + sum_t_wt) % MOD
    ans = (ans * inv_denom) % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        rb = int(next(it)); cb = int(next(it))
        rd = int(next(it)); cd = int(next(it))
        p = int(next(it))
        cases.append((n, m, rb, cb, rd, cd, p))
    return t, cases

def solve_all_improved(cases):
    out = []
    for (n, m, rb, cb, rd, cd, p) in cases:
        out.append(str(solve_case_improved(n, m, rb, cb, rd, cd, p)))
    return "\n".join(out)

def main():
    t, cases = read_input()
    if t:
        print(solve_all_improved(cases))

if __name__ == "__main__":
    # Cross-check congruence method vs baseline simulation for small cases
    from random import Random
    rng = Random(0)
    for n in range(2, 8):
        for m in range(2, 8):
            if n * m > 40:
                continue
            for rb in range(1, n+1):
                for cb in range(1, m+1):
                    for rd in range(1, n+1):
                        for cd in range(1, m+1):
                            p = rng.randrange(1, 100)
                            a = solve_case_improved(n, m, rb, cb, rd, cd, p)
                            # Compare to baseline simulation
                            # re-import here to avoid name clash
                            def baseline(n, m, rb, cb, rd, cd, p):
                                R = 2 * (n - 1)
                                C = 2 * (m - 1)
                                from math import gcd
                                L = (R // gcd(R, C)) * C
                                inv100 = pow(100, MOD-2, MOD)
                                q = (p * inv100) % MOD
                                one_minus_q = (1 - q) % MOD
                                r, c, dr, dc = rb, cb, 1, 1
                                cur_fail = 1
                                sum_t_wt = 0
                                for t in range(L):
                                    if r == rd or c == cd:
                                        sum_t_wt = (sum_t_wt + (t % MOD) * q % MOD * cur_fail) % MOD
                                        cur_fail = (cur_fail * one_minus_q) % MOD
                                    if r + dr < 1 or r + dr > n:
                                        dr = -dr
                                    if c + dc < 1 or c + dc > m:
                                        dc = -dc
                                    r += dr; c += dc
                                S = cur_fail
                                denom = (1 - S) % MOD
                                ans = ((L % MOD) * S + sum_t_wt) % MOD
                                ans = (ans * pow(denom, MOD-2, MOD)) % MOD
                                return ans
                            b = baseline(n, m, rb, cb, rd, cd, p)
                            assert a == b
    main()
\end{minted}
\VALIDATION{Property tests compare the congruence-based method against step simulation across many tiny boards and random $p$, ensuring identical outputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the congruence-union to enumerate opportunity times within one period, aggregate weights $w_t=q(1-q)^{\text{prior}}$, then apply the closed form $\mathbb{E}[T]=\dfrac{LS+\sum t w_t}{1-S}$. This is optimal under the constraints.}
\ASSUMPTIONS{Applicability requires $n,m\ge 2$; the bounce periods are $2(n-1)$ and $2(m-1)$; independence across seconds justifies the geometric sums.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $L=\operatorname{lcm}(2(n-1),2(m-1))$ and the four residues for row/column hits.
\item Build the union of arithmetic progressions over $[0,L)$ and sort times.
\item Fold contributions with $q$ and $(1-q)$; compute $S$ and the final formula modulo $10^9+7$.
\end{algosteps}
\OPTIMALITY{Each axis is independent and periodic; enumerating only opportunity seconds avoids $\mathcal{O}(L)$ where many seconds are irrelevant on sparse patterns, and gives an exact result with minimal arithmetic. The closed form is tight from periodic renewal theory.}
\COMPLEXITY{$\mathcal{O}\!\left(\tfrac{L}{2(n-1)}+\tfrac{L}{2(m-1)}\right)$ time and $\mathcal{O}(k)$ memory, where $k$ is the number of unique opportunities in one period.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(k \log k)\ \text{(or } \mathcal{O}(k)\text{ with bucketed merge)},\\
S(n) &= \mathcal{O}(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final CF-ready solution (deterministic; uses congruence-union approach)
import sys
from math import gcd

MOD = 1_000_000_007

def modinv(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def lcm(a: int, b: int) -> int:
    return a // gcd(a, b) * b

def opportunity_times(n, m, rb, cb, rd, cd):
    R = 2 * (n - 1)
    C = 2 * (m - 1)
    L = lcm(R, C)
    rb0, rd0 = rb - 1, rd - 1
    cb0, cd0 = cb - 1, cd - 1

    ar1 = (rd0 - rb0) % R
    ar2 = (R - rd0 - rb0) % R
    ac1 = (cd0 - cb0) % C
    ac2 = (C - cd0 - cb0) % C

    times = set()
    LR = L // R
    LC = L // C
    for a in {ar1, ar2}:
        for k in range(LR):
            times.add(a + k * R)
    for a in {ac1, ac2}:
        for k in range(LC):
            times.add(a + k * C)
    return L, sorted(times)

def solve_case(n, m, rb, cb, rd, cd, p):
    L, ts = opportunity_times(n, m, rb, cb, rd, cd)
    inv100 = modinv(100)
    q = (p * inv100) % MOD
    one_minus_q = (1 - q) % MOD

    cur_fail = 1
    sum_t_wt = 0
    for t in ts:
        sum_t_wt = (sum_t_wt + (t % MOD) * q % MOD * cur_fail) % MOD
        cur_fail = (cur_fail * one_minus_q) % MOD

    S = cur_fail
    denom = (1 - S) % MOD
    ans = ((L % MOD) * S + sum_t_wt) % MOD
    ans = (ans * modinv(denom)) % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        rb = int(next(it)); cb = int(next(it))
        rd = int(next(it)); cd = int(next(it))
        p = int(next(it))
        cases.append((n, m, rb, cb, rd, cd, p))
    return t, cases

def solve_all(cases):
    out = []
    for (n, m, rb, cb, rd, cd, p) in cases:
        out.append(str(solve_case(n, m, rb, cb, rd, cd, p)))
    return "\n".join(out)

def main():
    t, cases = read_input()
    if t:
        print(solve_all(cases))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case(2, 2, 1, 1, 1, 1, 100) == 0
    assert solve_case(2, 2, 1, 1, 2, 2, 100) == 1
    # Consistency: baseline vs final on a composite case
    def baseline(n, m, rb, cb, rd, cd, p):
        R = 2 * (n - 1)
        C = 2 * (m - 1)
        from math import gcd as _g
        L = (R // _g(R, C)) * C
        inv100 = pow(100, MOD-2, MOD)
        q = (p * inv100) % MOD
        one_minus_q = (1 - q) % MOD
        r, c, dr, dc = rb, cb, 1, 1
        cur_fail = 1
        sum_t_wt = 0
        for t in range(L):
            if r == rd or c == cd:
                sum_t_wt = (sum_t_wt + (t % MOD) * q % MOD * cur_fail) % MOD
                cur_fail = (cur_fail * one_minus_q) % MOD
            if r + dr < 1 or r + dr > n:
                dr = -dr
            if c + dc < 1 or c + dc > m:
                dc = -dc
            r += dr; c += dc
        S = cur_fail
        denom = (1 - S) % MOD
        ans = ((L % MOD) * S + sum_t_wt) % MOD
        ans = (ans * pow(denom, MOD-2, MOD)) % MOD
        return ans
    assert solve_case(3, 4, 2, 3, 1, 4, 37) == baseline(3, 4, 2, 3, 1, 4, 37)
    main()
\end{minted}
\VALIDATION{Exactly three asserts: trivial $2\times2$ cases and a cross-check with a baseline step simulation on $(n,m)=(3,4)$ confirm correctness.}
\RESULT{For each test case, print the expected time (an integer modulo $10^9+7$) to clean the dirty cell, where ties are irrelevant because the expectation is unique.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit assertions on simple boards; property tests comparing congruence-derived opportunity times vs simulation times; cross-check final formula against baseline simulation across small grids and random $p$.}
\LINE{CROSS-CHECKS}{Ensure the set of opportunity times within one period matches between methods; verify $S=(1-q)^k$ equals the product accumulated in order; compare expected times.}
\LINE{EDGE-CASE GENERATOR}{Generate minimal boards (e.g., $2\times m$ and $n\times 2$), corners, edges, and central targets; verify symmetry $n\leftrightarrow m$, $(r,c)\leftrightarrow(c,r)$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from math import gcd
MOD = 1_000_000_007

def modinv(a: int) -> int:
    return pow(a, MOD-2, MOD)

def lcm(a, b): return a // gcd(a, b) * b

def opportunity_times(n, m, rb, cb, rd, cd):
    R = 2 * (n - 1); C = 2 * (m - 1); L = lcm(R, C)
    rb0, rd0 = rb - 1, rd - 1; cb0, cd0 = cb - 1, cd - 1
    ar1 = (rd0 - rb0) % R; ar2 = (R - rd0 - rb0) % R
    ac1 = (cd0 - cb0) % C; ac2 = (C - cd0 - cb0) % C
    times = set()
    for a in {ar1, ar2}:
        for k in range(L // R):
            times.add(a + k * R)
    for a in {ac1, ac2}:
        for k in range(L // C):
            times.add(a + k * C)
    return L, sorted(times)

def simulate_times(n, m, rb, cb, rd, cd):
    R = 2 * (n - 1); C = 2 * (m - 1); L = lcm(R, C)
    r, c, dr, dc = rb, cb, 1, 1
    ts = []
    for t in range(L):
        if r == rd or c == cd:
            ts.append(t)
        if r + dr < 1 or r + dr > n:
            dr = -dr
        if c + dc < 1 or c + dc > m:
            dc = -dc
        r += dr; c += dc
    return L, ts

def expected_time(n, m, rb, cb, rd, cd, p):
    L, ts = opportunity_times(n, m, rb, cb, rd, cd)
    q = (p * modinv(100)) % MOD
    one_minus_q = (1 - q) % MOD
    cur_fail = 1; sum_t_wt = 0
    for t in ts:
        sum_t_wt = (sum_t_wt + (t % MOD) * q % MOD * cur_fail) % MOD
        cur_fail = (cur_fail * one_minus_q) % MOD
    S = cur_fail
    return (((L % MOD) * S + sum_t_wt) % MOD) * modinv((1 - S) % MOD) % MOD

def reference_solution_io(data: str) -> str:
    it = iter(map(int, data.strip().split()))
    t = next(it)
    out = []
    for _ in range(t):
        n = next(it); m = next(it)
        rb = next(it); cb = next(it)
        rd = next(it); cd = next(it)
        p = next(it)
        out.append(str(expected_time(n, m, rb, cb, rd, cd, p)))
    return "\n".join(out)

# Self-checks
for n in range(2, 8):
    for m in range(2, 8):
        if n * m > 40: continue
        for rb in range(1, n+1):
            for cb in range(1, m+1):
                for rd in range(1, n+1):
                    for cd in range(1, m+1):
                        L1, ts1 = opportunity_times(n, m, rb, cb, rd, cd)
                        L2, ts2 = simulate_times(n, m, rb, cb, rd, cd)
                        assert L1 == L2 and ts1 == ts2

# Final reference function for submission
def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it); m = next(it)
        rb = next(it); cb = next(it)
        rd = next(it); cd = next(it)
        p = next(it)
        cases.append((n, m, rb, cb, rd, cd, p))
    return t, cases

def main():
    t, cases = read_input()
    if not t: 
        return
    out = []
    for (n, m, rb, cb, rd, cd, p) in cases:
        out.append(str(expected_time(n, m, rb, cb, rd, cd, p)))
    print("\n".join(out))

if __name__ == "__main__":
    # Quick IO test
    s_in = "2\n2 2 1 1 1 1 100\n2 2 1 1 2 2 100\n"
    s_out = reference_solution_io(s_in)
    assert s_out.split() == ["0", "1"]
    # main()  # not called to avoid accidental I/O in this test cell
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution (same as Approach C)

import sys
from math import gcd

MOD = 1_000_000_007

def modinv(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def lcm(a: int, b: int) -> int:
    return a // gcd(a, b) * b

def opportunity_times(n, m, rb, cb, rd, cd):
    R = 2 * (n - 1)
    C = 2 * (m - 1)
    L = lcm(R, C)
    rb0, rd0 = rb - 1, rd - 1
    cb0, cd0 = cb - 1, cd - 1

    ar1 = (rd0 - rb0) % R
    ar2 = (R - rd0 - rb0) % R
    ac1 = (cd0 - cb0) % C
    ac2 = (C - cd0 - cb0) % C

    times = set()
    for k in range(L // R):
        base = k * R
        times.add(base + ar1)
        times.add(base + ar2)
    for k in range(L // C):
        base = k * C
        times.add(base + ac1)
        times.add(base + ac2)
    return L, sorted(times)

def solve_case(n, m, rb, cb, rd, cd, p):
    L, ts = opportunity_times(n, m, rb, cb, rd, cd)
    q = (p * modinv(100)) % MOD
    one_minus_q = (1 - q) % MOD

    cur_fail = 1
    sum_t_wt = 0
    for t in ts:
        sum_t_wt = (sum_t_wt + (t % MOD) * q % MOD * cur_fail) % MOD
        cur_fail = (cur_fail * one_minus_q) % MOD

    S = cur_fail
    denom = (1 - S) % MOD
    ans = ((L % MOD) * S + sum_t_wt) % MOD
    ans = (ans * modinv(denom)) % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        rb = int(next(it)); cb = int(next(it))
        rd = int(next(it)); cd = int(next(it))
        p = int(next(it))
        cases.append((n, m, rb, cb, rd, cd, p))
    return t, cases

def solve_all(cases):
    out = []
    for (n, m, rb, cb, rd, cd, p) in cases:
        out.append(str(solve_case(n, m, rb, cb, rd, cd, p)))
    return "\n".join(out)

def main():
    t, cases = read_input()
    if t:
        print(solve_all(cases))

if __name__ == "__main__":
    # Minimal asserts
    assert solve_case(2, 2, 1, 1, 1, 1, 100) == 0
    assert solve_case(2, 2, 1, 1, 2, 2, 100) == 1
    assert solve_case(3, 4, 2, 3, 1, 4, 37) == solve_case(3, 4, 2, 3, 1, 4, 37)
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Enumerate opportunity times in one period of the bouncing motion and use a periodic geometric-series formula to get the expected time modulo $10^9+7$.}
\WHY{This pattern—periodic states with probabilistic success—appears in cyclic Markov chains and reflective motion problems common in interviews and contests.}
\CHECKLIST{
- Compute $R=2(n-1)$, $C=2(m-1)$, $L=\operatorname{lcm}(R,C)$.
- Build residues for row/col hits and the union of their progressions in $[0,L)$.
- Accumulate $\sum t w_t$ with $w_t=q(1-q)^{\text{prior}}$ and $S=(1-q)^k$.
- Return $\big(L S + \sum t w_t\big)\cdot (1-S)^{-1} \bmod 10^9+7$.
}
\EDGECASES{
- Initial second $t=0$ counts as an opportunity.
- Boundary reflection happens before moving each second.
- No division by zero: ensure $S\neq 1$ (holds for $p\in[1,99]$ and at least one opportunity per period).
- Deduplicate overlaps where both row and column align.
- Avoid off-by-one in $0$-based vs $1$-based conversions.
- Keep all arithmetic modulo $10^9+7$.
}
\PITFALLS{
- Using the wrong reflection order (must reflect before moving if about to hit a wall).
- Double-counting times when both row and column match.
- Forgetting that opportunities and cleaning attempts also occur at $t=0$.
- Computing $L$ incorrectly (must use $\operatorname{lcm}(2(n-1),2(m-1))$).
- Floating-point probabilities; use modular arithmetic instead.
- Missing that $S=(1-q)^k$ where $k$ is the number of opportunities in one period.
}
\FAILMODES{Naive infinite-time simulation or summing until ``probability small'' will time out or be inaccurate. Counting every second instead of only opportunities wastes time. The presented method handles all inputs within constraints exactly.}
\ELI{The robot repeats a pattern. List all seconds in one loop when it lines up with the dirty cell, then compute the expected waiting time using a tidy fraction that accounts for repeating loops. Do all math modulo $10^9+7$.}
\NotePages{3}

\end{document}