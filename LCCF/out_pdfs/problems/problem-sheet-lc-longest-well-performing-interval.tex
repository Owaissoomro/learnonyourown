% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Longest Well-Performing Interval}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/longest-well-performing-interval/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{We are given \texttt{hours}, a list of the number of hours worked per day for a given employee. A day is considered to be a \emph{tiring day} if and only if the number of hours worked is strictly greater than 8. A \emph{well-performing interval} is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days. Return the length of the longest well-performing interval.

Example 1: Input: \texttt{hours = [9, 9, 6, 0, 6, 6, 9]}. Output: \texttt{3}. Explanation: The longest well-performing interval is \texttt{[9, 9, 6]}.

Example 2: Input: \texttt{hours = [6, 6, 6]}. Output: \texttt{0}.

Constraints:
\begin{bullets}
\item \(1 \le n \le 10^4\), where \(n = \text{len}(\texttt{hours})\).
\item For each day \(i\), \(0 \le \texttt{hours}[i] \le 16\).
\end{bullets}}
\BREAKDOWN{Turn days into scores \(+1\) for tiring and \(-1\) otherwise and find the longest subarray with positive sum. Use prefix sums so the task becomes finding the maximum width pair \((i,j)\) with \(P_j - P_i > 0\).}
\ELI{Map each day to \(+1/-1\) and find the longest stretch where the total is positive using prefix sums and a clever first-occurrence lookup.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single list \texttt{hours} of length \(n\) with integers, \(1 \le n \le 10^4\), and \(0 \le \texttt{hours}[i] \le 16\).}
\OUTPUTS{An integer: the length of the longest contiguous interval where the number of days with \(\texttt{hours}[i] > 8\) exceeds the number of days with \(\texttt{hours}[i] \le 8\).}
\SAMPLES{Example A: \texttt{[9, 9, 6, 0, 6, 6, 9]} \(\to\) \texttt{3}. Example B: \texttt{[6, 6, 6]} \(\to\) \texttt{0}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let \(h_1,\ldots,h_n\) be the daily hours. Define scores \(s_i = \begin{cases} +1,& h_i > 8\\ -1,& h_i \le 8\end{cases}\). Let prefix sums \(P_0=0\) and \(P_k = \sum_{i=1}^{k} s_i\) for \(k \ge 1\). The goal is to compute the maximum length \(L = \max\{j-i : 0 \le i < j \le n,\; P_j - P_i > 0\}\).}
\varmapStart
\var{n}{number of days}
\var{h_i}{hours on day \(i\)}
\var{s_i}{\(+1\) if \(h_i>8\), else \(-1\)}
\var{P_k}{prefix sum up to day \(k\)}
\var{L}{answer: the maximum interval length with positive sum}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
s_i &= \mathbf{1}[h_i>8] - \mathbf{1}[h_i \le 8] \in \{-1, +1\},\\
P_0 &= 0,\quad P_k = \sum_{i=1}^k s_i,\\
L &= \max_{0 \le i < j \le n}\{(j-i) : P_j - P_i > 0\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are 0-based in implementation; ties for equality do not count as well-performing since strict positivity is required.}
\INVARIANTS{
\begin{bullets}
\item If \(P_j > 0\), then the interval \([1..j]\) is well-performing, so \(L \ge j\).
\item If we know the earliest index of a value \(x\) in \(P\), then for any \(j\) with \(P_j \ge x+1\), there exists \(i\) s.t. \(P_i = x\) and \(P_j - P_i > 0\).
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use prefix sums to get interval sums in \(O(1)\), then check all \((i,j)\) to find the longest with \(P_j - P_i > 0\).}
\ASSUMPTIONS{We can precompute \(P\) in \(O(n)\); then an \(O(n^2)\) scan is acceptable only for small \(n\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Map \(\texttt{hours}\) to \(s_i \in \{+1,-1\}\) by threshold 8.
\item Build prefix sums \(P\) of length \(n+1\).
\item For all pairs \(0 \le i < j \le n\), if \(P_j - P_i > 0\), update the answer with \(j-i\).
\end{algosteps}
\COMPLEXITY{Check all pairs: \(O(n^2)\) time; \(O(n)\) space for the prefix array.}
\[
\begin{aligned}
T(n) &= O(n)~(\text{map}) + O(n)~(\text{prefix}) + O(n^2)~(\text{scan}) \\
     &= O(n^2),\quad S(n) = O(n).
\end{aligned}
\]
\CORRECTNESS{By construction, for each interval \([i..j-1]\) the sum equals \(P_j - P_i\). The algorithm tests all intervals and takes the maximum length among those with positive sum, which is exactly the definition.}
\EDGECASES{All non-tiring days yield 0; all tiring days yield \(n\); single-day inputs yield 1 if \(>8\), else 0.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        n = len(hours)
        score = [1 if h > 8 else -1 for h in hours]
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + score[i]
        ans = 0
        for i in range(n):
            for j in range(i + 1, n + 1):
                if prefix[j] - prefix[i] > 0:
                    if j - i > ans:
                        ans = j - i
        return ans

if __name__ == "__main__":
    s = Solution()
    assert s.longestWPI([9, 9, 6, 0, 6, 6, 9]) == 3
    assert s.longestWPI([6, 6, 6]) == 0
    assert s.longestWPI([9]) == 1
\end{minted}
\VALIDATION{The asserts cover a mixed case, all non-tiring, and a single tiring day.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Monotonic Stack on Prefix Sums}
\WHICHFORMULA{Build a strictly decreasing stack of prefix-sum indices, then scan from the right to find the widest pair \((i,j)\) with \(P_j > P_i\).}
\ASSUMPTIONS{Prefix sums of \(\pm 1\) permit a decreasing stack because equal or higher prefixes later are not better starting points.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute \(P_0,\ldots,P_n\).
\item Build a stack of indices \(S\) such that \(P_{S[0]} > P_{S[1]} > \cdots\) by scanning left to right and pushing an index if its prefix is strictly smaller than the stack top's prefix.
\item Scan \(j\) from \(n\) down to \(0\); while the stack is nonempty and \(P_j > P_{S[-1]}\), pop \(i=S[-1]\) and update answer with \(j-i\).
\end{algosteps}
\COMPLEXITY{Each index is pushed and popped at most once.}
\[
\begin{aligned}
T(n) &= O(n) \text{ build} + O(n) \text{ scan} = O(n),\quad S(n) = O(n).
\end{aligned}
\]
\CORRECTNESS{The stack stores earliest indices for strictly decreasing prefix values. If \(P_j > P_i\) with \(i\) the earliest for its value, then any later \(i'\) with \(P_{i'} \ge P_i\) would not yield a longer interval. Scanning from the right ensures we get the widest \(j-i\) for each popped \(i\).}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        n = len(hours)
        score = [1 if h > 8 else -1 for h in hours]
        P = [0] * (n + 1)
        for i in range(n):
            P[i + 1] = P[i] + score[i]
        stack = []
        for i in range(n + 1):
            if not stack or P[i] < P[stack[-1]]:
                stack.append(i)
        ans = 0
        j = n
        while j >= 0 and stack:
            while stack and P[j] > P[stack[-1]]:
                i = stack.pop()
                if j - i > ans:
                    ans = j - i
            j -= 1
        return ans

if __name__ == "__main__":
    s = Solution()
    assert s.longestWPI([9, 9, 6, 0, 6, 6, 9]) == 3
    assert s.longestWPI([6, 6, 6]) == 0
    assert s.longestWPI([9, 9, 9]) == 3
\end{minted}
\VALIDATION{Covers mixed, all non-tiring, and all tiring scenarios; the last ensures full-length detection.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{First-Occurrence Hash Map on Prefix Sums}
\WHICHFORMULA{Track the earliest index of each prefix sum \(x\). For each \(j\): if \(P_j>0\) then answer is at least \(j\); else, if \(P_j-1\) has an earliest index \(i\), then \((i,j)\) is well-performing with length \(j-i\).}
\ASSUMPTIONS{Works for arbitrary \(\pm 1\) scores and strict positivity. We store the first time each prefix value appears.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Map \(\texttt{hours}\) to scores and compute prefix \(P_j\) on the fly.
\item Maintain a dictionary \(\texttt{first}\) from prefix value to earliest index; insert only if unseen.
\item For each \(j\) from 1 to \(n\): if \(P_j>0\) set answer to \(j\); else if \(P_j-1\) in \(\texttt{first}\), update answer with \(j-\texttt{first}[P_j-1]\).
\end{algosteps}
\OPTIMALITY{Each step is \(O(1)\) expected with a hash map; every element is processed once. This matches known lower bounds for reading input, hence optimal up to constants.}
\COMPLEXITY{Linear time and space.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n) = O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        first = {0: 0}
        ans = 0
        prefix = 0
        for j, h in enumerate(hours, start=1):
            prefix += 1 if h > 8 else -1
            if prefix > 0:
                ans = j
            else:
                prev = prefix - 1
                if prev in first:
                    cand = j - first[prev]
                    if cand > ans:
                        ans = cand
            if prefix not in first:
                first[prefix] = j
        return ans

if __name__ == "__main__":
    s = Solution()
    assert s.longestWPI([9, 9, 6, 0, 6, 6, 9]) == 3
    assert s.longestWPI([6, 6, 6]) == 0
    assert s.longestWPI([9, 6, 9, 6, 9]) == 5
\end{minted}
\VALIDATION{Exactly three asserts: mixed example, all non-tiring, and an alternating case whose entire length is well-performing.}
\RESULT{Return the maximum length of a contiguous interval with more days \(>8\) hours than days \(\le 8\) hours.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for samples; property test comparing brute force and optimal on many small random inputs; boundary tests including all non-tiring and all tiring.}
\LINE{CROSS-CHECKS}{For small \(n\), verify Approach C equals Approach A on the same inputs.}
\LINE{EDGE-CASE GENERATOR}{Create arrays of size up to 10 with values chosen from \{6, 9\} under a fixed random seed; include degenerate sizes 1 and 2.}
\begin{minted}{python}
from typing import List
import random

def brute(hours: List[int]) -> int:
    n = len(hours)
    score = [1 if h > 8 else -1 for h in hours]
    P = [0] * (n + 1)
    for i in range(n):
        P[i + 1] = P[i] + score[i]
    ans = 0
    for i in range(n):
        for j in range(i + 1, n + 1):
            if P[j] - P[i] > 0:
                if j - i > ans:
                    ans = j - i
    return ans

def optimal(hours: List[int]) -> int:
    first = {0: 0}
    ans = 0
    prefix = 0
    for j, h in enumerate(hours, start=1):
        prefix += 1 if h > 8 else -1
        if prefix > 0:
            ans = j
        else:
            if (prefix - 1) in first:
                cand = j - first[prefix - 1]
                if cand > ans:
                    ans = cand
        if prefix not in first:
            first[prefix] = j
    return ans

def run_tests():
    # Samples
    assert optimal([9, 9, 6, 0, 6, 6, 9]) == 3
    assert optimal([6, 6, 6]) == 0
    assert optimal([9]) == 1
    assert optimal([6]) == 0

    # Cross-check brute vs optimal on random small cases
    rng = random.Random(12345)
    for n in range(1, 11):
        for _ in range(50):
            arr = [9 if rng.random() < 0.5 else 6 for _ in range(n)]
            assert optimal(arr) == brute(arr)

    # Patterned edge cases
    assert optimal([9, 6, 9, 6, 9]) == 5
    assert optimal([6, 9, 6, 9, 6, 9]) == 5
    assert optimal([9, 9, 9, 9]) == 4
    assert optimal([6, 6, 6, 6]) == 0

if __name__ == "__main__":
    run_tests()
    print("OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        first = {0: 0}
        ans = 0
        prefix = 0
        for j, h in enumerate(hours, start=1):
            prefix += 1 if h > 8 else -1
            if prefix > 0:
                ans = j
            else:
                prev = prefix - 1
                if prev in first:
                    cand = j - first[prev]
                    if cand > ans:
                        ans = cand
            if prefix not in first:
                first[prefix] = j
        return ans

if __name__ == "__main__":
    s = Solution()
    assert s.longestWPI([9, 9, 6, 0, 6, 6, 9]) == 3
    assert s.longestWPI([6, 6, 6]) == 0
    assert s.longestWPI([9, 6, 9, 6, 9]) == 5
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to longest subarray with positive sum after mapping \(>8\) to \(+1\) and \(\le 8\) to \(-1\); solve via prefix sums and earliest-occurrence logic.}
\WHY{Common LC medium that tests prefix sums, monotonic stacks, and hash-based first-occurrence patterns.}
\CHECKLIST{
\begin{bullets}
\item Map hours to \(\pm 1\).
\item Maintain prefix sum and earliest index per value.
\item For each position \(j\): if \(P_j>0\), set answer \(=j\); else, try \(P_j-1\).
\item Insert unseen \(P_j\) with earliest index \(j\).
\item Return the best width.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All non-tiring days \(\to 0\).
\item All tiring days \(\to n\).
\item Single day tiring \(\to 1\); single day non-tiring \(\to 0\).
\item Alternating starting with tiring often yields full length.
\item Long prefixes with tie \(P_j=0\) do not count unless we can find \(P_i=-1\).
\item Mixed zeros in hours do not matter beyond thresholding at 8.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting strictness: intervals with equal tiring and non-tiring are not valid.
\item Not storing earliest index for each prefix value (later indices shrink width).
\item Off-by-one between 0-based indices and 1-based prefix steps.
\item Using \(P_j\) directly in the map check instead of \(P_j-1\).
\item Mishandling \(P_j>0\) case; it should immediately set answer to \(j\).
\item Overflow is not an issue in Python, but watch types in other languages.
\end{bullets}
}
\FAILMODES{A naive sliding window fails because the target condition is not monotone under window expansion. Greedy truncation from either side without prefix logic can miss optimal intervals.}
\ELI{Count \(+1\) for tiring and \(-1\) for others. Keep the first time each total appears. At each day, either the entire prefix is good or you can pair it with an earlier total one less to make a positive stretch.}
\NotePages{3}

\end{document}