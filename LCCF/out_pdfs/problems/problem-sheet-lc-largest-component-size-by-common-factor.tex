% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Largest Component Size by Common Factor}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/largest-component-size-by-common-factor/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an integer array of unique positive integers \texttt{nums}. Consider the following graph:
\begin{itemize}
\item There are \texttt{nums.length} nodes, labeled \texttt{nums[0]} to \texttt{nums[nums.length - 1]},
\item There is an undirected edge between \texttt{nums[i]} and \texttt{nums[j]} if \texttt{nums[i]} and \texttt{nums[j]} share a common factor greater than 1.
\end{itemize}
Return \emph{the size of the largest connected component in the graph}.

\textbf{Example 1:}

\textbf{Input:} \texttt{nums = [4,6,15,35]} \quad \textbf{Output:} \texttt{4}

\textbf{Example 2:}

\textbf{Input:} \texttt{nums = [20,50,9,63]} \quad \textbf{Output:} \texttt{2}

\textbf{Example 3:}

\textbf{Input:} \texttt{nums = [2,3,6,7,4,12,21,39]} \quad \textbf{Output:} \texttt{8}

\textbf{Constraints:}
\begin{itemize}
\item $1 \le \texttt{nums.length} \le 2 \times 10^{4}$
\item $1 \le \texttt{nums[i]} \le 10^{5}$
\item All the values of \texttt{nums} are unique.
\end{itemize}}
\BREAKDOWN{Model numbers as nodes in a graph with edges for $\gcd>1$. The task is to compute the largest connected component size. Efficiently connect numbers sharing a prime factor using union--find, avoiding explicit $O(n^{2})$ edge checks.}
\ELI{Group numbers that share any prime factor into clusters; return the size of the biggest cluster.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode method \texttt{largestComponentSize(self, nums: List[int]) -\textgreater{} int}. Here \texttt{nums} is a list of unique positive integers with $1 \le \lvert\texttt{nums}\rvert \le 2 \times 10^{4}$ and each $1 \le \texttt{nums[i]} \le 10^{5}$.}
\OUTPUTS{Return a single integer: the size of the largest connected component under the relation ``share a common factor greater than $1$''.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{[4,6,15,35]} $\rightarrow$ Output: \texttt{4}
\item Input: \texttt{[20,50,9,63]} $\rightarrow$ Output: \texttt{2}
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=\{a_{1},\ldots,a_{n}\}$ be the set of input integers (all distinct). Define an undirected graph $G=(V,E)$ with $V=A$ and
\begin{BreakableEquation*}
E=\bigl\{\{a_{i},a_{j}\}\,:\, 1 \le i<j \le n,\ \gcd(a_{i},a_{j})>1 \bigr\}.
\end{BreakableEquation*}
Goal: compute $\max$ component size of $G$.}
\varmapStart
\var{n}{number of input integers}
\var{a_i}{the $i$-th integer in \texttt{nums}}
\var{P(a)}{the set of distinct prime factors of $a$}
\var{\pi_{\max}}{largest prime not exceeding $\max(A)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\{a_{i},a_{j}\} \in E \iff \exists p \text{ prime } (p \mid a_{i} \land p \mid a_{j}) \iff \gcd(a_{i},a_{j})>1.
\end{BreakableEquation*}
}
\ASSUMPTIONS{All $a_{i}$ are unique; $n \ge 1$. Values may include $1$, which has no prime factors and hence is isolated.}
\INVARIANTS{
\begin{itemize}
\item Connectivity is transitive via prime factors: if $p \mid a$, $p \mid b$, and $q \mid b$, $q \mid c$, then $a$ and $c$ are connected through $b$.
\item Union--find operations merge precisely the equivalence classes induced by the transitive closure of ``share a prime factor''.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly build components by checking every pair $(i,j)$ and union them if $\gcd(a_{i},a_{j})>1$.}
\ASSUMPTIONS{Feasible only for small $n$ due to $O(n^{2})$ pair checks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize DSU over $n$ indices.
\item For each pair $0 \le i<j<n$, if $\gcd(\texttt{nums}[i],\texttt{nums}[j])>1$, union $i$ and $j$.
\item Return the maximum size among DSU component sizes.
\end{algosteps}
\COMPLEXITY{Let $W=\max(\texttt{nums})$.
\[
\begin{aligned}
T(n) &= \Theta\bigl(n^{2} \cdot \log W\bigr)\quad \text{(Euclid's $\gcd$)}\\
S(n) &= \Theta(n)\quad \text{(DSU arrays)}.
\end{aligned}
\]
}
\CORRECTNESS{Two indices are unioned iff their numbers share a factor $>1$. By transitivity of unions, DSU components equal connected components of $G$.}
\EDGECASES{Presence of $1$ yields isolated nodes; all primes with no shared factor produce multiple singleton components.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
from math import gcd

class DSU:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.size = [1] * n
    def find(self, x: int) -> int:
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        self.size[ra] += self.size[rb]

class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        n = len(nums)
        dsu = DSU(n)
        for i in range(n):
            for j in range(i + 1, n):
                if gcd(nums[i], nums[j]) > 1:
                    dsu.union(i, j)
        # Count sizes by root
        best = 0
        count = {}
        for i in range(n):
            r = dsu.find(i)
            count[r] = count.get(r, 0) + 1
            if count[r] > best:
                best = count[r]
        return best

# Tiny self-checks (baseline intended for small n)
if __name__ == "__main__":
    sol = Solution()
    assert sol.largestComponentSize([4, 6, 15, 35]) == 4
    assert sol.largestComponentSize([20, 50, 9, 63]) == 2
    assert sol.largestComponentSize([2, 3, 6, 7, 4, 12, 21, 39]) == 8
\end{minted}
\VALIDATION{Verified on the three samples; also implicitly handles arrays containing 1 by producing isolated components.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Union by Prime Factors via Trial Division}
\WHICHFORMULA{Union indices that share any prime factor by keeping, for each prime $p$, the first index seen with $p$ and unioning subsequent indices to it. Factor each number by trial division up to $\sqrt{a}$.}
\ASSUMPTIONS{Numbers are $\le 10^{5}$, so trial division is acceptable but still near worst-case $O(\sqrt{a})$ per number.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize DSU over indices $[0..n-1]$.
\item For each number $a$ at index $i$, factor $a$ into its distinct primes $P(a)$ using trial division.
\item For each $p \in P(a)$, if $p$ has appeared at some index $j$, union $i$ with $j$; else record $p \mapsto i$.
\item Count DSU component sizes and return the maximum.
\end{algosteps}
\COMPLEXITY{Let $W=\max(\texttt{nums})$.
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} O\bigl(\sqrt{\texttt{nums}[i]}\bigr) + \alpha(n) \approx O\bigl(n \sqrt{W}\bigr) \\
S(n) &= O(n + \pi(\sqrt{W}))\quad \text{(DSU + prime-to-index map)}.
\end{aligned}
\]
}
\CORRECTNESS{Every number is connected to others sharing a prime via that prime's first occurrence; unions preserve connectivity equivalence classes.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class DSU:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.size = [1] * n
    def find(self, x: int) -> int:
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        self.size[ra] += self.size[rb]

def factor_distinct_trial(x: int) -> List[int]:
    res = []
    d = 2
    while d * d <= x:
        if x % d == 0:
            res.append(d)
            while x % d == 0:
                x //= d
        d += 1 if d == 2 else 2  # small skip of even numbers
    if x > 1:
        res.append(x)
    return res

class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        n = len(nums)
        dsu = DSU(n)
        first_idx = {}  # prime -> index of first occurrence
        for i, a in enumerate(nums):
            primes = factor_distinct_trial(a)
            seen = set()
            for p in primes:
                if p in seen:
                    continue
                seen.add(p)
                if p in first_idx:
                    dsu.union(i, first_idx[p])
                else:
                    first_idx[p] = i
        # Count sizes
        best = 0
        count = {}
        for i in range(n):
            r = dsu.find(i)
            count[r] = count.get(r, 0) + 1
            if count[r] > best:
                best = count[r]
        return best

if __name__ == "__main__":
    sol = Solution()
    assert sol.largestComponentSize([4, 6, 15, 35]) == 4
    assert sol.largestComponentSize([20, 50, 9, 63]) == 2
    assert sol.largestComponentSize([2, 3, 6, 7, 4, 12, 21, 39]) == 8
    assert sol.largestComponentSize([1, 2, 3]) == 1
\end{minted}
\VALIDATION{Checks on provided samples and a case containing 1.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{SPF Sieve + Union by Prime Factors}
\WHICHFORMULA{Precompute the smallest prime factor (SPF) for all values up to $W=\max(\texttt{nums})$ in $O(W \log\log W)$, then factor each number in $O(\log W)$ using SPF. For each prime $p$ factor, union the current index to the first index seen with $p$.}
\ASSUMPTIONS{Works for $W \le 10^{5}$ comfortably within time; union--find with path compression and union by size.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build \texttt{spf} array of size $W$ where \texttt{spf[x]} is the smallest prime dividing $x$.
\item For each index $i$ with value $a$, enumerate the distinct prime factors via repeated \texttt{spf} division.
\item For each factor $p$, union $i$ with the first index recorded for $p$; otherwise record $p \mapsto i$.
\item Return the maximum DSU component size.
\end{algosteps}
\OPTIMALITY{Each number contributes unions equal to its number of distinct prime factors, which is $O(\log a)$; SPF factorization is near-optimal for many queries. Any method must, in effect, associate numbers via their prime factors or equivalent gcd links; this achieves that with optimal precomputation.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= O(W \log\log W) + \sum_{i=1}^{n} O(\log \texttt{nums}[i]) + O(n\alpha(n)) \\
     &\subseteq O(W \log\log W + n \log W), \\
S(n) &= O(W) \text{ for SPF } + O(n) \text{ for DSU and maps}.
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class DSU:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.size = [1] * n
    def find(self, x: int) -> int:
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        self.size[ra] += self.size[rb]

def build_spf(limit: int) -> List[int]:
    spf = [0] * (limit + 1)
    if limit >= 1:
        spf[1] = 1
    for i in range(2, limit + 1):
        if spf[i] == 0:
            spf[i] = i
            if i * i <= limit:
                step = i
                start = i * i
                for j in range(start, limit + 1, step):
                    if spf[j] == 0:
                        spf[j] = i
    return spf

def factor_distinct_spf(x: int, spf: List[int]) -> List[int]:
    if x <= 1:
        return []
    res = []
    while x > 1:
        p = spf[x]
        res.append(p)
        while x % p == 0:
            x //= p
    # make distinct
    res.sort()
    uniq = []
    for v in res:
        if not uniq or uniq[-1] != v:
            uniq.append(v)
    return uniq

class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        W = max(nums)
        spf = build_spf(W)
        dsu = DSU(n)
        first_idx = {}  # prime -> first index having this prime
        for i, a in enumerate(nums):
            primes = factor_distinct_spf(a, spf)
            for p in primes:
                if p in first_idx:
                    dsu.union(i, first_idx[p])
                else:
                    first_idx[p] = i
        # Count sizes
        best = 0
        count = {}
        for i in range(n):
            r = dsu.find(i)
            count[r] = count.get(r, 0) + 1
            if count[r] > best:
                best = count[r]
        return best

if __name__ == "__main__":
    sol = Solution()
    # Exactly 3 asserts / mini-tests
    assert sol.largestComponentSize([4, 6, 15, 35]) == 4
    assert sol.largestComponentSize([20, 50, 9, 63]) == 2
    assert sol.largestComponentSize([2, 3, 6, 7, 4, 12, 21, 39]) == 8
\end{minted}
\VALIDATION{Three sample asserts pass.}
\RESULT{Returns the size of the largest connected component of numbers connected by sharing a factor $>1$; ties are irrelevant since only the size is required.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify against samples; include degenerate cases with 1; all primes; all multiples of a common prime; mixed cases with chains via shared factors.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline (A), Improved (B), and Final (C) on tiny crafted inputs ($n \le 10$) to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Deterministically produce small arrays that stress factorization: powers of a prime, coprimes, inclusion of 1, and chained composites.}
\begin{minted}{python}
from typing import List
from math import gcd

# Edge-case input generators (deterministic)
def gens():
    yield [1]
    yield [1, 2, 3]
    yield [2, 3, 5, 7, 11]               # all primes -> all singletons
    yield [2, 4, 8, 16, 32]              # same prime factor -> one component
    yield [6, 10, 15]                    # chain via 5? no; components: {6,10},{15} size 2
    yield [4, 6, 9, 21, 14, 35]          # multiple clusters
    yield [30, 42, 70, 105]              # all share primes -> one component
    yield [4, 6, 15, 35]
    yield [20, 50, 9, 63]
    yield [2, 3, 6, 7, 4, 12, 21, 39]

# Reference final solution (SPF + DSU)
class DSU:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.size = [1] * n
    def find(self, x: int) -> int:
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        self.size[ra] += self.size[rb]

def build_spf(limit: int):
    spf = [0] * (limit + 1)
    if limit >= 1:
        spf[1] = 1
    for i in range(2, limit + 1):
        if spf[i] == 0:
            spf[i] = i
            if i * i <= limit:
                for j in range(i * i, limit + 1, i):
                    if spf[j] == 0:
                        spf[j] = i
    return spf

def factor_distinct_spf(x: int, spf):
    if x <= 1:
        return []
    res = []
    while x > 1:
        p = spf[x]
        res.append(p)
        while x % p == 0:
            x //= p
    res.sort()
    out = []
    for v in res:
        if not out or out[-1] != v:
            out.append(v)
    return out

class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        if not nums:
            return 0
        n = len(nums)
        W = max(nums)
        spf = build_spf(W)
        dsu = DSU(n)
        first_idx = {}
        for i, a in enumerate(nums):
            for p in factor_distinct_spf(a, spf):
                if p in first_idx:
                    dsu.union(i, first_idx[p])
                else:
                    first_idx[p] = i
        best = 0
        count = {}
        for i in range(n):
            r = dsu.find(i)
            count[r] = count.get(r, 0) + 1
            best = max(best, count[r])
        return best

# Cross-check baseline (pairwise gcd)
class SolutionBF:
    def largestComponentSize(self, nums: List[int]) -> int:
        n = len(nums)
        dsu = DSU(n)
        for i in range(n):
            for j in range(i + 1, n):
                if gcd(nums[i], nums[j]) > 1:
                    dsu.union(i, j)
        count = {}
        best = 0
        for i in range(n):
            r = dsu.find(i)
            count[r] = count.get(r, 0) + 1
            best = max(best, count[r])
        return best

if __name__ == "__main__":
    ref = Solution()
    bf = SolutionBF()
    for arr in gens():
        assert ref.largestComponentSize(arr) == bf.largestComponentSize(arr)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class DSU:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.size = [1] * n
    def find(self, x: int) -> int:
        # Path halving
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        self.size[ra] += self.size[rb]

def build_spf(limit: int):
    spf = [0] * (limit + 1)
    if limit >= 1:
        spf[1] = 1
    for i in range(2, limit + 1):
        if spf[i] == 0:
            spf[i] = i
            if i * i <= limit:
                for j in range(i * i, limit + 1, i):
                    if spf[j] == 0:
                        spf[j] = i
    return spf

def factor_distinct_spf(x: int, spf):
    if x <= 1:
        return []
    res = []
    while x > 1:
        p = spf[x]
        res.append(p)
        while x % p == 0:
            x //= p
    res.sort()
    out = []
    for v in res:
        if not out or out[-1] != v:
            out.append(v)
    return out

class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        if not nums:
            return 0
        n = len(nums)
        spf = build_spf(max(nums))
        dsu = DSU(n)
        first_idx = {}
        for i, a in enumerate(nums):
            for p in factor_distinct_spf(a, spf):
                j = first_idx.get(p)
                if j is None:
                    first_idx[p] = i
                else:
                    dsu.union(i, j)
        best = 0
        count = {}
        for i in range(n):
            r = dsu.find(i)
            count[r] = count.get(r, 0) + 1
            if count[r] > best:
                best = count[r]
        return best

if __name__ == "__main__":
    sol = Solution()
    assert sol.largestComponentSize([4, 6, 15, 35]) == 4
    assert sol.largestComponentSize([20, 50, 9, 63]) == 2
    assert sol.largestComponentSize([2, 3, 6, 7, 4, 12, 21, 39]) == 8
    assert sol.largestComponentSize([1]) == 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Largest connected component where edges link numbers sharing a common factor $>1$.}
\WHY{Tests graph modeling, DSU mastery, and number theory factorization under time constraints.}
\CHECKLIST{
\begin{itemize}
\item Identify the graph and that $\gcd>1$ links via shared primes.
\item Decide DSU approach; avoid explicit graph materialization.
\item Choose factorization method: SPF sieve for speed.
\item Union by first occurrence per prime factor.
\item Count component sizes by root.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item Presence of $1$ (isolated).
\item All primes with no shared factors (all singletons).
\item All numbers multiples of the same prime (one component).
\item Chains via different primes (transitive connectivity).
\item Repeated prime factors in a number (use distinct primes only).
\item Large $n$ with small $W$ versus small $n$ with large $W$.
\item Mixed small and large primes (ensure SPF correctness).
\item Single-element input ($n=1$).
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Counting repeated prime factors causing redundant unions; deduplicate factors.
\item Forgetting to path-compress or union by size/rank (performance).
\item Building edges explicitly leads to $O(n^{2})$ blowup.
\item Incorrect SPF sieve (not setting composites properly).
\item Using $\gcd$ chains without union--find leading to revisits.
\item Overflow not an issue in Python, but watch time due to nested loops.
\item Missing the case with number 1.
\item Not returning the largest count but the largest DSU internal size array entry without compressing roots when counting.
\end{itemize}
}
\FAILMODES{Brute-force pairwise $\gcd$ TLEs on $n \approx 2 \times 10^{4}$. Trial division may be borderline; SPF sieve avoids worst cases and scales.}
\ELI{Connect numbers that share any prime factor. Use a fast prime lookup (SPF) to find factors, union indices that share a prime, then count the biggest group.}
\NotePages{3}

\end{document}