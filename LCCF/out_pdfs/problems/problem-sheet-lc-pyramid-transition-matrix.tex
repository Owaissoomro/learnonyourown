% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Pyramid Transition Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/pyramid-transition-matrix/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains \textbf{one less block} than the row beneath it and is centered on top.

To make the pyramid aesthetically pleasing, there are only specific \textbf{triangular patterns} that are allowed. A triangular pattern consists of a \textbf{single block} stacked on top of \textbf{two blocks}. The patterns are given as a list of three-letter strings \texttt{allowed}, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.

For example, \texttt{"ABC"} represents a triangular pattern with a \texttt{'C'} block stacked on top of an \texttt{'A'} (left) and \texttt{'B'} (right) block. Note that this is different from \texttt{"BAC"} where \texttt{'B'} is on the left bottom and \texttt{'A'} is on the right bottom.

You start with a bottom row of blocks \texttt{bottom}, given as a single string, that you \textbf{must} use as the base of the pyramid.

Given \texttt{bottom} and \texttt{allowed}, return \texttt{true} if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in \texttt{allowed}, or \texttt{false} otherwise.

Example 1:

\quad Input: \texttt{bottom = "BCD"}, \texttt{allowed = ["BCC","CDE","CEA","FFF"]}

\quad Output: \texttt{true}

\quad Explanation: Starting from the bottom (level 3), we can build \texttt{"CE"} on level 2 and then build \texttt{"A"} on level 1. The patterns \texttt{"BCC"}, \texttt{"CDE"}, and \texttt{"CEA"} are all allowed.

Example 2:

\quad Input: \texttt{bottom = "AAAA"}, \texttt{allowed = ["AAB","AAC","BCD","BBE","DEF"]}

\quad Output: \texttt{false}

\quad Explanation: Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilities, you will always get stuck before building level 1.

Constraints:
\begin{bullets}
\item \texttt{2 <= bottom.length <= 6}
\item \texttt{0 <= allowed.length <= 216}
\item \texttt{allowed[i].length == 3}
\item The letters in all input strings are from the set \(\{\texttt{'A'}, \texttt{'B'}, \texttt{'C'}, \texttt{'D'}, \texttt{'E'}, \texttt{'F'}\}\).
\item All the values of \texttt{allowed} are unique.
\end{bullets}
}
\BREAKDOWN{Map each adjacent pair of blocks to the set of allowed top blocks. Perform a search from the bottom row upward, generating possible next rows and pruning whenever a pair has no allowed top.}
\ELI{Think of a triangle puzzle: each pair of touching blocks must allow a specific top; can we stack to the apex using only allowed triplets?}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A string \texttt{bottom} of length \(n\) with \(2 \le n \le 6\), letters from \(\{\texttt{A},\ldots,\texttt{F}\}\). A list \texttt{allowed} of distinct strings of length \(3\), each over \(\{\texttt{A},\ldots,\texttt{F}\}\).}
\OUTPUTS{A Boolean: \texttt{true} if there exists a pyramid up to height \(1\) whose every triangular pattern belongs to \texttt{allowed}; \texttt{false} otherwise.}
\SAMPLES{Example~1: \texttt{bottom = "BCD"}, \texttt{allowed = ["BCC","CDE","CEA","FFF"]} \(\to\) \texttt{true}. Example~2: \texttt{bottom = "AAAA"}, \texttt{allowed = ["AAB","AAC","BCD","BBE","DEF"]} \(\to\) \texttt{false}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let \(\Sigma=\{\texttt{A},\ldots,\texttt{F}\}\). Define a relation \(R \subseteq \Sigma \times \Sigma \times \Sigma\) by \((x,y,z)\in R\) iff the triplet \(\texttt{xyz}\) is in \texttt{allowed}. Given bottom row \(b_1 b_2 \ldots b_n \in \Sigma^n\), does there exist a sequence of rows \(r^{(k)}\) for \(k=n,n-1,\ldots,1\) with \(r^{(n)}=b_1\ldots b_n\), \(|r^{(k)}|=k\), such that for all \(k>1\) and all \(i\in\{1,\ldots,k-1\}\) there exists \(z\in\Sigma\) with \((r^{(k)}_i, r^{(k)}_{i+1}, r^{(k-1)}_i) \in R\)?}
\varmapStart
\var{n}{length of the bottom row}
\var{\Sigma}{alphabet of colors \(\{\texttt{A},\ldots,\texttt{F}\}\)}
\var{R}{allowed triplet relation}
\var{r^{(k)}}{row string at level \(k\)}
\var{b_i}{\(i\)-th character of the bottom}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall k>1,\ \forall i\in\{1,\ldots,k-1\}:\ (r^{(k)}_i, r^{(k)}_{i+1}, r^{(k-1)}_i)\in R,\quad r^{(n)} = b_1\ldots b_n.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Alphabet size is \(6\). Rows strictly decrease by one per level. All patterns are directed in the bottom pair order.}
\INVARIANTS{
\begin{bullets}
\item If a pair \((x,y)\) has no \(z\) with \((x,y,z)\in R\), then no completion above any row containing \(xy\) is possible.
\item Row length decreases by exactly \(1\) each level until length \(1\) or a dead end is reached.
\item Search state depends only on the current row's characters, enabling memoization.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Depth-first search over all possible next rows. For each adjacent pair \(xy\) in the current row, try every \(z\) with \(\texttt{xyz}\in\texttt{allowed}\), concatenate, and recurse.}
\ASSUMPTIONS{No memoization; fully enumerate all next rows before recursing to the level above.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a map \(M: \Sigma^2 \to 2^{\Sigma}\) where \(M[xy]=\{z \mid (x,y,z)\in R\}\).
\item Given a row \(s\), recursively generate all strings \(t\) of length \(|s|-1\) by appending each allowed \(z\) for each adjacent pair.
\item Recurse on each generated \(t\); success if any path reaches length \(1\).
\end{algosteps}
\COMPLEXITY{Worst case exponential in \(n\) (small \(n\le 6\)). In the worst balanced branching, each level may branch up to \(6\), giving a loose bound of \(O(6^{n(n-1)/2})\). Space is \(O(n)\) for recursion plus output buffering.}
\[
\begin{aligned}
T(n) &\le \prod_{k=2}^{n} b_k \quad \text{where } b_k \text{ is avg.\ branching for length } k\\
&= \exp\!\Big(\sum_{k=2}^{n} \ln b_k\Big) \quad \text{exponential in } n.
\end{aligned}
\]
\CORRECTNESS{The algorithm enumerates all possible pyramids consistent with \texttt{allowed}. A path is accepted only if every local triple is allowed at every level and the apex is reached.}
\EDGECASES{Pairs with no allowed tops cause immediate dead ends; bottom length \(2\) reduces to a single pair check; empty \texttt{allowed} gives \texttt{false} unless \(n=1\) (not possible here).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Dict, Set

class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        # Build mapping from pair -> set of possible tops
        mp: Dict[str, Set[str]] = {}
        for trip in allowed:
            a, b, c = trip[0], trip[1], trip[2]
            key = a + b
            if key not in mp:
                mp[key] = set()
            mp[key].add(c)

        # Generate all next rows for a given row by DFS
        def gen_next_rows(row: str, idx: int, build: List[str], out: List[str]) -> None:
            if idx == len(row) - 1:
                out.append("".join(build))
                return
            pair = row[idx:idx+2]
            if pair not in mp:
                return
            for ch in mp[pair]:
                build.append(ch)
                gen_next_rows(row, idx + 1, build, out)
                build.pop()

        def dfs(row: str) -> bool:
            if len(row) == 1:
                return True
            next_rows: List[str] = []
            gen_next_rows(row, 0, [], next_rows)
            for nr in next_rows:
                if dfs(nr):
                    return True
            return False

        return dfs(bottom)

if __name__ == "__main__":
    s = Solution()
    assert s.pyramidTransition("BCD", ["BCC", "CDE", "CEA", "FFF"]) is True
    assert s.pyramidTransition("AAAA", ["AAB", "AAC", "BCD", "BBE", "DEF"]) is False
    # Pair with no transitions immediately fails
    assert s.pyramidTransition("AB", ["ACA"]) is False
\end{minted}
\VALIDATION{Covers the two official examples and a tiny negative pair case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Backtracking with On-the-fly Pruning \& Memoization}
\WHICHFORMULA{Instead of generating full next rows, build the next row character-by-character, and memoize rows that are known to be impossible. This prunes early and avoids recomputation.}
\ASSUMPTIONS{Store a set of failed rows; reuse the same mapping \(M\). Recursively attempt to assemble the next row while checking feasibility at each position.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build \(M\) as before.
\item Maintain a set \(\mathcal{B}\) of ``bad'' rows known not to lead to the apex.
\item For a row \(s\), try to build its next row left-to-right. When a pair has no allowed tops, backtrack immediately.
\item If no completion for \(s\) exists, cache \(s\) in \(\mathcal{B}\).
\end{algosteps}
\COMPLEXITY{Same worst-case exponential, but practical runtime is much smaller due to pruning and memoization. Space remains \(O(n + |\mathcal{B}|)\).}
\[
\begin{aligned}
T(n) &\approx \text{Exponential in the pruned search space}, \quad S(n)=O(n+|\mathcal{B}|).
\end{aligned}
\]
\CORRECTNESS{Caching failed rows is safe because the feasibility of completing a row depends only on its characters and the fixed \texttt{allowed} relation. On-the-fly pruning maintains the invariant that every partial build is consistent with \texttt{allowed} so far.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Dict, Set

class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        mp: Dict[str, Set[str]] = {}
        for trip in allowed:
            key = trip[:2]
            mp.setdefault(key, set()).add(trip[2])

        bad: Set[str] = set()

        def can_build(row: str) -> bool:
            if len(row) == 1:
                return True
            if row in bad:
                return False

            n = len(row)
            next_row: List[str] = []

            def build_next(i: int) -> bool:
                if i == n - 1:
                    return can_build("".join(next_row))
                pair = row[i:i+2]
                if pair not in mp:
                    return False
                for ch in mp[pair]:
                    next_row.append(ch)
                    if build_next(i + 1):
                        return True
                    next_row.pop()
                return False

            ok = build_next(0)
            if not ok:
                bad.add(row)
            return ok

        return can_build(bottom)

if __name__ == "__main__":
    s = Solution()
    # Official examples
    assert s.pyramidTransition("BCD", ["BCC", "CDE", "CEA", "FFF"]) is True
    assert s.pyramidTransition("AAAA", ["AAB", "AAC", "BCD", "BBE", "DEF"]) is False
    # Edge: bottom length 2
    assert s.pyramidTransition("AB", ["ABC", "ABD"]) is True
\end{minted}
\VALIDATION{Checks two examples and a minimal length-2 case where a top exists.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Bitmask-Accelerated DFS with Memoization}
\WHICHFORMULA{Encode colors \(\texttt{A}\ldots\texttt{F}\) as bits \(0\)–\(5\). Precompute \(\text{up}[a][b]\) as a 6-bit mask of allowed tops. During DFS, compute for each adjacent position the mask of possible tops, then enumerate choices using bit tricks. Memoize by the tuple of current row's single-bit choices to deduplicate states.}
\ASSUMPTIONS{Alphabet size is \(6\), making bitmasks natural; recursion depth \(\le 6\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Map each character \(c\) to index \(\text{id}(c)\in\{0,\ldots,5\}\), and precompute \(\text{up}[6][6]\) as bitmasks.
\item Represent a row as a tuple of single-bit masks \((1 \ll \text{id}(c_i))\).
\item For a row, compute masks for each top position by combining children: for each set bit \(a\) in left and \(b\) in right, OR \(\text{up}[a][b]\).
\item Enumerate one set bit per position to form the next row; recurse. Memoize failures/successes for the current row tuple.
\end{algosteps}
\OPTIMALITY{Bitmasks reduce constant factors for combining possibilities and checking emptiness. Memoization by row states is asymptotically optimal for this search space, which is exponential in the height but bounded by problem constraints.}
\COMPLEXITY{Same asymptotic exponential in worst case, but with minimal overhead. Space is \(O(H)\) for recursion and \(O(S)\) for memoization states.}
\[
\begin{aligned}
T(n) &\text{ is exponential in } n \le 6,\quad S(n)=O(n + \text{states}).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
from functools import lru_cache

class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        # Map A..F -> 0..5
        def idx(c: str) -> int:
            return ord(c) - ord('A')

        # Precompute up masks: up[a][b] is bitmask of possible tops
        up = [[0] * 6 for _ in range(6)]
        for trip in allowed:
            a, b, c = idx(trip[0]), idx(trip[1]), idx(trip[2])
            up[a][b] |= (1 << c)

        # Convert bottom to tuple of single-bit masks
        row0: Tuple[int, ...] = tuple(1 << idx(c) for c in bottom)

        @lru_cache(maxsize=None)
        def dfs(row: Tuple[int, ...]) -> bool:
            if len(row) == 1:
                # Any bit set is acceptable; row entries are single-bit in this construction.
                return row[0] != 0

            n = len(row)
            # Precompute masks for each position in the next row
            masks = [0] * (n - 1)
            for i in range(n - 1):
                left_bits = row[i]
                right_bits = row[i + 1]
                m = 0
                lb = left_bits
                while lb:
                    a = (lb & -lb).bit_length() - 1
                    rb = right_bits
                    while rb:
                        b = (rb & -rb).bit_length() - 1
                        m |= up[a][b]
                        rb &= rb - 1
                    lb &= lb - 1
                masks[i] = m
                if m == 0:
                    return False  # early prune

            next_row = [0] * (n - 1)

            def choose(pos: int) -> bool:
                if pos == n - 1:
                    return dfs(tuple(next_row))
                m = masks[pos]
                while m:
                    bit = m & -m
                    next_row[pos] = bit
                    if choose(pos + 1):
                        return True
                    m -= bit
                return False

            return choose(0)

        return dfs(row0)

if __name__ == "__main__":
    s = Solution()
    # Exactly 3 asserts
    assert s.pyramidTransition("BCD", ["BCC", "CDE", "CEA", "FFF"]) is True
    assert s.pyramidTransition("AAAA", ["AAB", "AAC", "BCD", "BBE", "DEF"]) is False
    assert s.pyramidTransition("AB", ["ABA", "ABB"]) is True
\end{minted}
\VALIDATION{Three asserts: two official examples and a minimal positive case.}
\RESULT{Returns \texttt{True} iff there exists at least one pyramid consistent with \texttt{allowed}. If multiple exist, no tie-breaking is needed since the result is Boolean.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate on official examples; exhaustively test all \(\texttt{allowed}\) subsets for very short bottoms (e.g., length \(2\)) to ensure base correctness; random tests for consistency across implementations.}
\LINE{CROSS-CHECKS}{Run Approaches A, B, and C on the same small inputs and verify identical Booleans. Any discrepancy indicates a bug in pruning or state caching.}
\LINE{EDGE-CASE GENERATOR}{Generate bottoms of lengths \(2\)–\(4\) using alphabet \(\{\texttt{A},\texttt{B}\}\) and random \texttt{allowed} sets; enumerate all to check consistency and ensure pruning does not miss valid constructions.}
\begin{minted}{python}
from typing import List, Set, Dict, Tuple
import random

def gen_random_allowed(alpha: List[str]) -> List[str]:
    trips = []
    for a in alpha:
        for b in alpha:
            # include each possible top with small probability
            for c in alpha:
                if random.Random(123).randint(0, 4) == 0:
                    trips.append(a + b + c)
    # ensure uniqueness
    return list(dict.fromkeys(trips))

class Baseline:
    def solve(self, bottom: str, allowed: List[str]) -> bool:
        mp: Dict[str, Set[str]] = {}
        for t in allowed:
            mp.setdefault(t[:2], set()).add(t[2])

        def gen_next(row: str, i: int, acc: List[str], out: List[str]):
            if i == len(row) - 1:
                out.append("".join(acc))
                return
            key = row[i:i+2]
            for ch in mp.get(key, []):
                acc.append(ch)
                gen_next(row, i+1, acc, out)
                acc.pop()

        def dfs(row: str) -> bool:
            if len(row) == 1:
                return True
            nxt: List[str] = []
            gen_next(row, 0, [], nxt)
            return any(dfs(r) for r in nxt)

        return dfs(bottom)

class FinalBitmask:
    def solve(self, bottom: str, allowed: List[str]) -> bool:
        from functools import lru_cache

        def idx(c: str) -> int:
            return ord(c) - ord('A')

        up = [[0] * 6 for _ in range(6)]
        for t in allowed:
            a, b, c = idx(t[0]), idx(t[1]), idx(t[2])
            up[a][b] |= 1 << c

        row0 = tuple(1 << idx(c) for c in bottom)

        @lru_cache(maxsize=None)
        def dfs(row: Tuple[int, ...]) -> bool:
            if len(row) == 1:
                return row[0] != 0
            n = len(row)
            masks = [0] * (n - 1)
            for i in range(n - 1):
                m = 0
                lb = row[i]
                while lb:
                    a = (lb & -lb).bit_length() - 1
                    rb = row[i+1]
                    while rb:
                        b = (rb & -rb).bit_length() - 1
                        m |= up[a][b]
                        rb &= rb - 1
                    lb &= lb - 1
                if m == 0:
                    return False
                masks[i] = m
            nxt = [0] * (n - 1)
            def go(pos: int) -> bool:
                if pos == n - 1:
                    return dfs(tuple(nxt))
                m = masks[pos]
                while m:
                    bit = m & -m
                    nxt[pos] = bit
                    if go(pos + 1):
                        return True
                    m -= bit
                return False
            return go(0)

        return dfs(row0)

def cross_check():
    alpha = ['A', 'B']
    bottoms = ["AA", "AB", "BA", "BB", "ABA"]
    for bottom in bottoms:
        for _ in range(5):
            allowed = gen_random_allowed(alpha)
            b = Baseline().solve(bottom, allowed)
            f = FinalBitmask().solve(bottom, allowed)
            assert b == f, (bottom, allowed, b, f)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple
from functools import lru_cache

class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        # Bitmask-accelerated DFS with memoization
        def idx(c: str) -> int:
            return ord(c) - ord('A')

        up = [[0] * 6 for _ in range(6)]
        for trip in allowed:
            a, b, c = idx(trip[0]), idx(trip[1]), idx(trip[2])
            up[a][b] |= 1 << c

        row0: Tuple[int, ...] = tuple(1 << idx(c) for c in bottom)

        @lru_cache(maxsize=None)
        def dfs(row: Tuple[int, ...]) -> bool:
            if len(row) == 1:
                return row[0] != 0
            n = len(row)
            masks = [0] * (n - 1)
            for i in range(n - 1):
                m = 0
                lb = row[i]
                while lb:
                    a = (lb & -lb).bit_length() - 1
                    rb = row[i + 1]
                    while rb:
                        b = (rb & -rb).bit_length() - 1
                        m |= up[a][b]
                        rb &= rb - 1
                    lb &= lb - 1
                if m == 0:
                    return False
                masks[i] = m
            next_row = [0] * (n - 1)
            def build(pos: int) -> bool:
                if pos == n - 1:
                    return dfs(tuple(next_row))
                m = masks[pos]
                while m:
                    bit = m & -m
                    next_row[pos] = bit
                    if build(pos + 1):
                        return True
                    m -= bit
                return False
            return build(0)

        return dfs(row0)

if __name__ == "__main__":
    s = Solution()
    assert s.pyramidTransition("BCD", ["BCC", "CDE", "CEA", "FFF"]) is True
    assert s.pyramidTransition("AAAA", ["AAB", "AAC", "BCD", "BBE", "DEF"]) is False
    assert s.pyramidTransition("AB", ["ABA", "ABB"]) is True
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Backtracking from the bottom, mapping every adjacent pair to allowed tops; prune early and memoize rows.}
\WHY{A canonical small-search problem testing recursion, pruning, memoization, and efficient encoding.}
\CHECKLIST{
\begin{bullets}
\item Build pair-to-tops map correctly with order sensitivity.
\item Early-prune when a pair has zero allowed tops.
\item Use memoization keyed by the whole row string or row state.
\item Stop at row length \(1\) and return success.
\item Keep recursion deterministic and stack-safe for \(n \le 6\).
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Bottom length \(2\): only one pair to check.
\item Empty \texttt{allowed}: always \texttt{false}.
\item Allowed contains pairs irrelevant to the given bottom.
\item Multiple tops for a pair; ensure all are considered.
\item Symmetric pairs like \texttt{"ABA"} vs.\ \texttt{"BAA"} are distinct.
\item Repeated letters in bottom (e.g., \texttt{"AAAA"}).
\item Paths that look promising but dead-end at the final step.
\item Duplicate triplets in input are ruled out by constraints but should be harmless.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Treating \texttt{"AB"} and \texttt{"BA"} as the same pair (they are not).
\item Forgetting to backtrack the builder when constructing next rows.
\item Memoizing only partial prefixes instead of whole row states, losing correctness.
\item Not pruning immediately when a pair has no allowed tops.
\item Inefficient recomputation of transitions without caching.
\item Using global mutable state that leaks across test cases.
\item Off-by-one when iterating adjacent pairs.
\item Confusing character indices with bit indices in bitmask solution.
\end{bullets}
}
\FAILMODES{Baseline may time out on adversarial allowed sets with many branches; improved and bitmask solutions maintain correctness while pruning and speeding transitions.}
\ELI{We repeatedly check if neighboring blocks can support a block above them. If at any point no block fits, we stop going up that path. With smart memory and bit tricks, we avoid repeating the same failed climbs.}
\NotePages{3}

\end{document}