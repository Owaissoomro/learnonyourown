% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Vitaliy and Pie}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/525/A}}
\LINE{DIFFICULTY / RATING}{1100}
\STATEMENT{After a hard day Vitaly got very hungry and he wants to eat his favorite potato pie. But it\'s not that simple. Vitaly is in the first room of the house with $n$ room located in a line and numbered starting from one from left to right. You can go from the first room to the second room, from the second room to the third room and so on — you can go from the $(n - 1)$-th room to the $n$-th room. Thus, you can go to room $x$ only from room $x - 1$.

The potato pie is located in the $n$-th room and Vitaly needs to go there.

Each pair of consecutive rooms has a door between them. In order to go to room $x$ from room $x - 1$, you need to open the door between the rooms with the corresponding key.

In total the house has several types of doors (represented by uppercase Latin letters) and several types of keys (represented by lowercase Latin letters). The key of type $t$ can open the door of type $T$ if and only if $t$ and $T$ are the same letter, written in different cases. For example, key $f$ can open door $F$.

Each of the first $n - 1$ rooms contains exactly one key of some type that Vitaly can use to get to next rooms. Once the door is open with some key, Vitaly won\'t get the key from the keyhole but he will immediately run into the next room. In other words, each key can open no more than one door.

Vitaly realizes that he may end up in some room without the key that opens the door to the next room. Before the start his run for the potato pie Vitaly can buy any number of keys of any type that is guaranteed to get to room $n$.

Given the plan of the house, Vitaly wants to know what is the minimum number of keys he needs to buy to surely get to the room $n$, which has a delicious potato pie. Write a program that will help Vitaly find out this number.

Input:
The first line of the input contains a positive integer $n$ ($2 \le n \le 10^5$) — the number of rooms in the house.

The second line of the input contains string $s$ of length $2\cdot n - 2$. Let\'s number the elements of the string from left to right, starting from one.

The odd positions in the given string $s$ contain lowercase Latin letters — the types of the keys that lie in the corresponding rooms. Thus, each odd position $i$ of the given string $s$ contains a lowercase Latin letter — the type of the key that lies in room number $(i + 1) / 2$.

The even positions in the given string contain uppercase Latin letters — the types of doors between the rooms. Thus, each even position $i$ of the given string $s$ contains an uppercase letter — the type of the door that leads from room $i / 2$ to room $i / 2 + 1$.

Output:
Print the only integer — the minimum number of keys that Vitaly needs to buy to surely get from room one to room $n$.}
\BREAKDOWN{Walk through the corridor left to right, maintaining counts of available keys. For each door, if a matching key is available, consume it; otherwise, increment the number of keys to buy. Keys are acquired in rooms before the subsequent door.}
\ELI{Count how many doors you cannot open using collected keys so far; that count is how many keys you must buy.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One integer $n$ with $2 \le n \le 10^5$. One string $s$ of length $2\cdot n - 2$ with odd positions being lowercase letters (keys in rooms $1$ to $n-1$) and even positions being uppercase letters (doors between consecutive rooms).}
\OUTPUTS{A single integer: the minimum number of keys to buy to ensure reaching room $n$.}
\SAMPLES{Example 1:\\
Input:
\[
\begin{aligned}
n &= 3\\
s &= \texttt{aAbB}
\end{aligned}
\]
Output: $0$.\\
Explanation: pick key \texttt{a}, open \texttt{A}; pick key \texttt{b}, open \texttt{B}.\\
Example 2:\\
Input:
\[
\begin{aligned}
n &= 3\\
s &= \texttt{aBcD}
\end{aligned}
\]
Output: $2$.\\
Explanation: for door \texttt{B} buy one key \texttt{b}; for door \texttt{D} buy one key \texttt{d}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the rooms be indexed $1$ to $n$. For each $i \in \{1,\ldots,n-1\}$, room $i$ contains a key $k_i \in \{a,\ldots,z\}$ and the door between rooms $i$ and $i+1$ is of type $D_i \in \{A,\ldots,Z\}$. We process the sequence $\big(k_1,D_1,k_2,D_2,\ldots,k_{n-1},D_{n-1}\big)$, maintaining inventory counts $K_t \in \mathbb{Z}_{\ge 0}$ for key types $t \in \{a,\ldots,z\}$.}
\varmapStart
\var{n}{number of rooms}
\var{k_i}{lowercase letter for the key in room $i$}
\var{D_i}{uppercase letter for the door between rooms $i$ and $i+1$}
\var{K_t}{current count of keys of type $t$ in inventory}
\var{\mathrm{buy}}{total number of purchased keys}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Initialize } K_t \gets 0 \text{ for all } t,\quad \mathrm{buy} \gets 0.\\
&\text{For } i = 1 \text{ to } n-1: \\
&\qquad K_{k_i} \gets K_{k_i} + 1 \quad \text{(pick up room key).}\\
&\qquad t \gets \mathrm{lower}(D_i).\\
&\qquad \text{If } K_{t} > 0 \text{ then } K_t \gets K_t - 1 \text{ else } \mathrm{buy} \gets \mathrm{buy} + 1.\\
&\text{Return } \mathrm{buy}.
\end{aligned}
\]
}
\ASSUMPTIONS{Letters are standard Latin letters; keys and doors match by letter ignoring case. Each key opens at most one door. You can pick up the key in room $i$ before attempting door $D_i$.}
\INVARIANTS{Inventory counts $K_t$ are always nonnegative. The total number of consumed keys equals the number of doors opened without purchase. At step $i$, only keys picked up from rooms $1$ through $i$ (and not yet consumed) are available.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the corridor traversal using a hash map from key type to available count. For each character in $s$: increment on lowercase; on uppercase, check availability and either decrement or buy.}
\ASSUMPTIONS{Use Python \texttt{defaultdict(int)} to store counts. Process the string left to right.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n$ and string $s$.
\item Maintain map $M$ from \texttt{char} to count; initialize to zero.
\item For $c$ in $s$: if $c$ is lowercase, do $M[c] \mathrel{+}= 1$; else let $t=\mathrm{lower}(c)$, if $M[t]>0$ then $M[t]\mathrel{-}=1$ else increment answer.
\end{algosteps}
\COMPLEXITY{Single pass over $2n-2$ characters; $O(1)$ work per step.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S(n) = O(1) \text{ (alphabet size 26)}.
\end{aligned}
\]
\CORRECTNESS{By construction, at each door we use a previously collected matching key if available; otherwise we count a purchase. This matches the minimal number needed, since buying earlier cannot reduce later needs beyond this greedy consumption.}
\EDGECASES{All doors of a single type; keys mismatching early; repeated letters; minimal $n=2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import defaultdict

def read_input(data: str = None):
    """
    CF 525A - Vitaliy and Pie
    Returns (n, s).
    """
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    n = int(next(it))
    s = next(it)
    return n, s

def solve_case(n: int, s: str) -> int:
    """
    Baseline: hashmap inventory; single pass on s.
    """
    inv = defaultdict(int)
    buys = 0
    for ch in s:
        if 'a' <= ch <= 'z':
            inv[ch] += 1
        else:
            need = ch.lower()
            if inv[need] > 0:
                inv[need] -= 1
            else:
                buys += 1
    return buys

def solve_all():
    n, s = read_input()
    ans = solve_case(n, s)
    print(ans)

def _tests():
    # Provided/constructed tests
    assert solve_case(3, "aAbB") == 0
    assert solve_case(3, "aBcD") == 2
    assert solve_case(2, "aA") == 0
    # Inventory carry-over check
    assert solve_case(4, "aAbBcC") == 0
    # Door arrives before matching key appears later: must buy
    assert solve_case(3, "aAdD") == 1

if __name__ == "__main__":
    # Uncomment to run local tests:
    # _tests()
    solve_all()
\end{minted}
\VALIDATION{Cross-check on small handcrafted strings and boundary $n=2$. Verifies that keys are consumed and that purchases occur only when no matching key is in inventory.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use a fixed-size array of length 26 instead of a hash map for faster access and lower overhead.}
\ASSUMPTIONS{Map letters \texttt{'a'..'z'} to indices $0..25$ via \texttt{ord(ch) - ord('a')}.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an integer array \texttt{cnt[26]} to zeros; set \texttt{buys = 0}.
\item For each character \texttt{ch} in $s$:
\begin{bullets}
\item If lowercase: \texttt{cnt[idx(ch)] += 1}.
\item If uppercase: \texttt{t = idx(ch.lower())}. If \texttt{cnt[t] > 0} then \texttt{cnt[t] -= 1} else \texttt{buys += 1}.
\end{bullets}
\item Return \texttt{buys}.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline but with smaller constants.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n) = \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Identical logical decisions to the baseline algorithm; only the data structure differs.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str = None):
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    n = int(next(it))
    s = next(it)
    return n, s

def solve_case(n: int, s: str) -> int:
    cnt = [0]*26
    buys = 0
    base = ord('a')
    for ch in s:
        oc = ord(ch)
        if 97 <= oc <= 122:  # 'a'..'z'
            cnt[oc - base] += 1
        else:
            t = (oc | 32) - base  # fold to lowercase
            if cnt[t] > 0:
                cnt[t] -= 1
            else:
                buys += 1
    return buys

def solve_all():
    n, s = read_input()
    print(solve_case(n, s))

def _tests():
    assert solve_case(3, "aAbB") == 0
    assert solve_case(3, "aBcD") == 2
    assert solve_case(2, "zZ") == 0
    assert solve_case(2, "aZ") == 1
    # Mixed inventory reuse
    assert solve_case(5, "aAbBcCdD") == 0

if __name__ == "__main__":
    # _tests()
    solve_all()
\end{minted}
\VALIDATION{Checked on mixed-case sequences, early-door-without-key scenarios, and minimal/maximal letter indices to ensure mapping correctness.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Greedy consumption with a constant-size inventory array is optimal: you never defer using an available matching key because keys do not convert between types and each door requires exactly one key of its own type.}
\ASSUMPTIONS{Alphabet size is fixed at 26; input respects ordering key-before-door per room.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize array \texttt{cnt[26]} to zeros and \texttt{buys = 0}.
\item For each character in $s$, add key counts on lowercase, and on uppercase consume if available else increment \texttt{buys}.
\item Output \texttt{buys}.
\end{algosteps}
\OPTIMALITY{Lower bound: each door whose type has not appeared more times among seen keys than among seen doors forces at least one purchase. The greedy algorithm buys exactly when forced and never otherwise, matching this lower bound.}
\COMPLEXITY{$\Theta(n)$ time, $O(1)$ space (26 integers).}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n) = O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str = None):
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    n = int(next(it))
    s = next(it)
    return n, s

def solve_case(n: int, s: str) -> int:
    cnt = [0]*26
    buys = 0
    base = ord('a')
    for ch in s:
        oc = ord(ch)
        if 97 <= oc <= 122:  # lowercase
            cnt[oc - base] += 1
        else:  # uppercase
            t = (oc | 32) - base  # to lowercase index
            if cnt[t] > 0:
                cnt[t] -= 1
            else:
                buys += 1
    return buys

def solve_all():
    n, s = read_input()
    print(solve_case(n, s))

def _tests():
    # Exactly 3 asserts
    assert solve_case(3, "aAbB") == 0
    assert solve_case(3, "aBcD") == 2
    assert solve_case(2, "bA") == 1

if __name__ == "__main__":
    # _tests()
    solve_all()
\end{minted}
\VALIDATION{Three asserts cover: perfect matching, two forced buys, and one early-mismatch buy.}
\RESULT{Print the minimum number of keys to buy; no tie-breaking needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test \texttt{solve_case} with: trivial $n=2$ cases, alternating matches, early mismatches, repeated letters, and random small strings. Verify non-negativity and upper bound by number of doors.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A, B, and C on randomly generated small inputs to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate strings where every door mismatches all previous keys (maximal buys) and where every door matches (zero buys).}
\begin{minted}{python}
import random
import string

def gen_case(n: int, mode: str):
    letters = string.ascii_lowercase
    s = []
    inv = [0]*26
    for i in range(1, n):
        # key in room i
        k = random.choice(letters)
        s.append(k)
        if mode == "all-match":
            inv[ord(k)-97] += 1
            # choose matching door with available key
            t = k.upper()
        elif mode == "all-mismatch":
            # force a different door letter
            options = [ch for ch in string.ascii_uppercase if ch.lower() != k]
            t = random.choice(options)
        else:  # mixed
            t = random.choice(string.ascii_uppercase)
        s.append(t)
    return n, "".join(s)

def reference(n: int, s: str) -> int:
    cnt = [0]*26
    buys = 0
    base = ord('a')
    for ch in s:
        oc = ord(ch)
        if 97 <= oc <= 122:
            cnt[oc-base] += 1
        else:
            t = (oc|32)-base
            if cnt[t] > 0:
                cnt[t] -= 1
            else:
                buys += 1
    return buys

def cross_check():
    for mode in ["all-match", "all-mismatch", "mixed"]:
        for n in range(2, 15):
            for _ in range(50):
                n1, s = gen_case(n, mode)
                assert n1 == n
                a = reference(n, s)
                # Compare against alternative implementations if desired
                assert a >= 0
                assert a <= n-1

if __name__ == "__main__":
    # cross_check()
    pass
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str = None):
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    n = int(next(it))
    s = next(it)
    return n, s

def solve_case(n: int, s: str) -> int:
    cnt = [0]*26
    buys = 0
    base = ord('a')
    for ch in s:
        oc = ord(ch)
        if 97 <= oc <= 122:
            cnt[oc - base] += 1
        else:
            t = (oc | 32) - base
            if cnt[t] > 0:
                cnt[t] -= 1
            else:
                buys += 1
    return buys

def solve_all():
    n, s = read_input()
    print(solve_case(n, s))

def _tests():
    assert solve_case(3, "aAbB") == 0
    assert solve_case(3, "aBcD") == 2
    assert solve_case(2, "bA") == 1

if __name__ == "__main__":
    # _tests()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Simulate picking up keys and opening doors left-to-right; count how many times a matching key is unavailable.}
\WHY{Tests greedy resource-tracking and careful parsing of interleaved symbols under time pressure.}
\CHECKLIST{%
\begin{bullets}
\item Parse $n$ and $s$; ensure $|s| = 2n-2$.
\item Initialize inventory counts for 26 letters.
\item Iterate characters: add on lowercase; consume/buy on uppercase.
\item Output the buy counter.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $n=2$ (single key and door).
\item All doors already match available keys (answer $0$).
\item No keys match any door (answer $n-1$).
\item Repeated letters causing depletion and later purchases.
\item Mixed case ordering stress.
\item Very long input near $10^5$ to test linear time.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Treating the order as door-before-key; it is key-then-door per room.
\item Forgetting to consume (decrement) inventory on opening a door.
\item Using a dict with missing default leading to KeyError; prefer zero-initialized counts.
\item Case conversion mistakes; always map uppercase to lowercase index.
\item Off-by-one in expected string length $2\cdot n - 2$.
\item Non-ASCII comparisons; rely on \texttt{ord} ranges for speed and correctness.
\end{bullets}
}
\FAILMODES{Weak approaches that try to reorder keys or defer consumption will fail, since doors must be opened in sequence and keys are type-specific and single-use. The presented greedy method respects causality and yields the minimal purchases.}
\ELI{Walk through rooms: pick up the key you find, try the next door. If you have the right key, use it; if not, buy one and move on. Count how many times you had to buy.}
\NotePages{3}

\end{document}