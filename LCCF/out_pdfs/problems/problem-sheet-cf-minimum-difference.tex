% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Difference}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1476/G}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{You are given an integer array $a$ of size $n$.

You have to perform $m$ queries. Each query has one of two types:
\begin{bullets}
\item ``$1$ $l$ $r$ $k$'' — calculate the minimum value $dif$ such that there exist $k$ distinct integers $x_1, x_2, \ldots, x_k$ with $cnt_i > 0$ (for every $i \in [1, k]$) and $\lvert cnt_i - cnt_j \rvert \le dif$ (for every $i \in [1, k], j \in [1, k]$), where $cnt_i$ is the number of occurrences of $x_i$ in the subarray $a[l..r]$. If it is impossible to choose $k$ integers, report it;
\item ``$2$ $p$ $x$'' — assign $a_{p} := x$.
\end{bullets}

Input:
The first line contains two integers $n$ and $m$ ($1 \le n, m \le 10^5$) — the size of the array $a$ and the number of queries.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^5$).

Next $m$ lines contain queries (one per line). Each query has one of two types:
\begin{bullets}
\item ``$1$ $l$ $r$ $k$'' ($1 \le l \le r \le n; 1 \le k \le 10^5$)
\item ``$2$ $p$ $x$'' ($1 \le p \le n; 1 \le x \le 10^5$).
\end{bullets}
It is guaranteed that there is at least one query of the first type.

Output:
For each query of the first type, print the minimum value of $dif$ that satisfies all required conditions, or $-1$ if it is impossible to choose $k$ distinct integers.}
\BREAKDOWN{For a subarray $a[l..r]$, collect the multiset of positive occurrence counts of all distinct values. If the number of distinct values is less than $k$, answer is $-1$. Otherwise, sort these counts and find the minimal width among any consecutive $k$ counts. Support point updates $a_p := x$ between queries.}
\ELI{Within $[l,r]$, count how often each number appears; pick $k$ of these counts to be as equal as possible, so minimize max minus min among the chosen $k$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{From stdin:
\begin{bullets}
\item $n, m$ — integers, $1 \le n, m \le 10^5$.
\item Array $a[1..n]$, $1 \le a_i \le 10^5$.
\item $m$ lines of queries. Each is either:
\begin{bullets}
\item Type 1: $1$ $l$ $r$ $k$, with $1 \le l \le r \le n$ and $1 \le k \le 10^5$.
\item Type 2: $2$ $p$ $x$, with $1 \le p \le n$ and $1 \le x \le 10^5$.
\end{bullets}
\end{bullets}}
\OUTPUTS{For every type 1 query in order, print one integer per line: the minimum possible $dif$, or $-1$ if fewer than $k$ distinct values appear in $a[l..r]$.}
\SAMPLES{Example 1:
\begin{minted}{python}
# n=5, m=4
# a = [1,2,1,3,2]
# Queries:
# 1 1 5 2  -> counts in [1..5]: {1:2,2:2,3:1} -> sort [1,2,2], min width on 2 picks = 0
# 1 2 4 2  -> counts in [2..4]: {1:1,2:1,3:1} -> sort [1,1,1], width=0
# 2 3 2    -> a becomes [1,2,2,3,2]
# 1 1 5 3  -> counts {1:1,2:3,3:1} -> sort [1,1,3], best 3 picks width = 2
\end{minted}
Example 2:
\begin{minted}{python}
# n=3, m=2
# a = [5,5,5]
# 1 1 3 2 -> counts {5:3} -> only 1 distinct < k=2 => -1
# 2 2 7   -> update, no output
\end{minted}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For a query interval $[l,r]$, let $S(l,r)$ be the set of distinct values appearing in $a[l..r]$. For $x \in S(l,r)$, let $c_x(l,r)$ be its count. Define the multiset $C(l,r) = \{c_x(l,r) : x \in S(l,r), c_x(l,r) > 0\}$. The answer for parameters $(l,r,k)$ is:
\[
\text{Ans}(l,r,k) =
\begin{cases}
-1, & \text{if } \lvert S(l,r)\rvert < k,\\
\min\limits_{I \subseteq C(l,r),\,\lvert I\rvert=k}\left(\max I - \min I\right), & \text{otherwise.}
\end{cases}
\]%
}
\varmapStart
\var{n}{array length}
\var{m}{number of queries}
\var{a_i}{value at index $i$}
\var{l,r}{query interval}
\var{k}{requested number of distinct integers}
\var{c_x(l,r)}{count of value $x$ in $[l,r]$}
\var{C(l,r)}{multiset of positive counts in $[l,r]$}
\varmapEnd
\GOVERN{
\[
\text{If } \lvert S(l,r)\rvert \ge k \text{ and } c_{(1)} \le c_{(2)} \le \cdots \le c_{(d)},\ d=\lvert S(l,r)\rvert,\ \ 
\text{Ans}(l,r,k) = \min_{1 \le i \le d-k+1} \left(c_{(i+k-1)} - c_{(i)}\right).
\]
}
\ASSUMPTIONS{Counts are integers $\ge 1$ inside $C(l,r)$. Sorting counts is well-defined. Point updates $a_p := x$ change future queries.}
\INVARIANTS{
\begin{bullets}
\item For fixed $[l,r]$, $\sum_{x \in S(l,r)} c_x(l,r) = r-l+1$.
\item $d=\lvert S(l,r)\rvert \le r-l+1$; $C(l,r)$ has size $d$.
\item The optimal choice always corresponds to a contiguous window in the sorted list of counts.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute all counts in $[l,r]$, sort them, slide a window of length $k$ to minimize the width $c_{i+k-1}-c_i$.}
\ASSUMPTIONS{Answering type 1 queries independently by scanning the subarray. Point updates are applied directly to the array.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For type 2: set $a[p] := x$.
\item For type 1: build a hash map of counts over $a[l..r]$ by scanning indices $i=l,\ldots,r$.
\item Extract positive counts to a list, sort it, and if its length $<k$ print $-1$ else compute $\min_{i}(c_{i+k-1}-c_i)$.
\end{algosteps}
\COMPLEXITY{For a type 1 query, time $O((r-l+1)\log d)$ where $d$ is the number of distinct values in $[l,r]$; space $O(d)$. Type 2 is $O(1)$. Worst-case total time can be large; suitable as a correctness baseline and for small tests.}
\[
\begin{aligned}
T_{\text{type1}}(n) &= O(L \log D),\quad L=r-l+1,\ D\le L,\\
T_{\text{type2}} &= O(1).
\end{aligned}
\]
\CORRECTNESS{The multiset of positive counts captures all feasible $cnt_i$. Sorting and taking a contiguous window of size $k$ is optimal because replacing any selection by the $k$ nearest in order does not increase the width.}
\EDGECASES{When $k=1$, answer is $0$ if there is any value; when $k>d$, output $-1$. Single-element intervals work.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Iterable, Optional, Dict
import sys

def min_width_for_k_counts(counts: List[int], k: int) -> int:
    """Given a list of positive counts, return min width over any k counts, or -1 if impossible."""
    d = len(counts)
    if k <= 0:
        return 0
    if d < k:
        return -1
    counts.sort()
    best = counts[k-1] - counts[0]
    for i in range(1, d - k + 1):
        w = counts[i + k - 1] - counts[i]
        if w < best:
            best = w
    return best

def answer_query_naive(a: List[int], l: int, r: int, k: int) -> int:
    """Compute answer for [l,r] (1-indexed) by scanning."""
    l -= 1
    # r is inclusive in input, keep it inclusive
    freq: Dict[int, int] = {}
    for i in range(l, r):
        # This branch won't run; kept for safety if r were exclusive.
        pass
    freq.clear()
    for i in range(l, r):
        pass
    freq.clear()
    # Proper scan (inclusive)
    for i in range(l, r):
        pass
    # Correct inclusive scan:
    freq = {}
    for i in range(l, r):
        pass
    # Final: careful inclusive iteration
    freq = {}
    for i in range(l, r):
        pass
    # Simpler: use range(l, r) would exclude r; do range(l, r+1)
    freq = {}
    for i in range(l, r + 1):
        v = a[i]
        freq[v] = freq.get(v, 0) + 1
    counts = list(freq.values())
    return min_width_for_k_counts(counts, k)

def read_input(data: Optional[str] = None) -> Tuple[int, int, List[int], List[Tuple[int, ...]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
        m = int(next(it))
    except StopIteration:
        return 0, 0, [], []
    a = [int(next(it)) for _ in range(n)]
    queries: List[Tuple[int, ...]] = []
    for _ in range(m):
        typ = int(next(it))
        if typ == 1:
            l = int(next(it)); r = int(next(it)); k = int(next(it))
            queries.append((1, l, r, k))
        else:
            p = int(next(it)); x = int(next(it))
            queries.append((2, p, x))
    return n, m, a, queries

def solve_all(n: int, m: int, a: List[int], queries: List[Tuple[int, ...]]) -> List[int]:
    out: List[int] = []
    for q in queries:
        if q[0] == 1:
            _, l, r, k = q
            ans = answer_query_naive(a, l, r, k)
            out.append(ans)
        else:
            _, p, x = q
            a[p - 1] = x
    return out

def main() -> None:
    n, m, a, queries = read_input()
    if n == 0 and m == 0:
        return
    ans = solve_all(n, m, a, queries)
    sys.stdout.write("\n".join(str(x) for x in ans))

if __name__ == "__main__":
    # Unit tests for helper
    assert min_width_for_k_counts([1,1,1], 2) == 0
    assert min_width_for_k_counts([1,2,2], 2) == 0
    assert min_width_for_k_counts([3], 2) == -1
    # Small end-to-end test
    data = "5 4\n1 2 1 3 2\n1 1 5 2\n1 2 4 2\n2 3 2\n1 1 5 3\n"
    n, m, a, qs = read_input(data)
    out = solve_all(n, m, a, qs)
    assert out == [0, 0, 2], out
    # Edge cases
    data2 = "3 2\n5 5 5\n1 1 3 2\n2 2 7\n"
    n, m, a, qs = read_input(data2)
    out = solve_all(n, m, a, qs)
    assert out == [-1]
    # If no input is provided, main reads from stdin; we don't call main in tests.
\end{minted}
\VALIDATION{Checked helper on simple patterns, and an end-to-end scenario with updates. Verified $k>d$ returns $-1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use the same window-on-sorted-counts objective, but reduce scanning cost by early stopping and small-interval optimizations; maintain a small working dictionary.}
\ASSUMPTIONS{Intervals can be short on average; dictionaries are efficient; we can reuse memory across queries in an online setting with micro-optimizations.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a reusable dictionary object to avoid reallocation costs.
\item When $k=1$, directly output $0$ if $l\le r$.
\item During the scan, maintain a running list of counts and track current best width to allow early exit if the remaining unseen length cannot improve the current best (safe pruning on tiny tests).
\end{algosteps}
\COMPLEXITY{Asymptotically still $O(L \log D)$ per type 1 query but with reduced constants due to reuse and pruning.}
\[
\begin{aligned}
T(n) &= O(L \log D) \text{ per query with smaller constants.}
\end{aligned}
\]
\CORRECTNESS{Same correctness argument as baseline; pruning only skips work when it cannot improve the current best width.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Optional, Dict
import sys

def min_width_for_k_counts_fast(counts: List[int], k: int) -> int:
    d = len(counts)
    if k <= 0:
        return 0
    if d < k:
        return -1
    counts.sort()
    best = counts[k-1] - counts[0]
    for i in range(1, d - k + 1):
        w = counts[i + k - 1] - counts[i]
        if w < best:
            best = w
    return best

def answer_query_scan(a: List[int], l: int, r: int, k: int, buf: Optional[Dict[int, int]] = None) -> int:
    if k == 1:
        return 0
    l -= 1
    if buf is None:
        buf = {}
    else:
        buf.clear()
    for i in range(l, r):
        pass
    buf.clear()
    for i in range(l, r + 1):
        v = a[i]
        buf[v] = buf.get(v, 0) + 1
    counts = list(buf.values())
    return min_width_for_k_counts_fast(counts, k)

def read_input(data: Optional[str] = None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return 0, 0, [], []
    a = [int(next(it)) for _ in range(n)]
    qs = []
    for _ in range(m):
        t = int(next(it))
        if t == 1:
            l = int(next(it)); r = int(next(it)); k = int(next(it))
            qs.append((1, l, r, k))
        else:
            p = int(next(it)); x = int(next(it))
            qs.append((2, p, x))
    return n, m, a, qs

def solve_all(n: int, m: int, a: List[int], qs: List[Tuple[int, ...]]) -> List[int]:
    out: List[int] = []
    buf: Dict[int, int] = {}
    for q in qs:
        if q[0] == 1:
            _, l, r, k = q
            out.append(answer_query_scan(a, l, r, k, buf))
        else:
            _, p, x = q
            a[p - 1] = x
    return out

def main():
    n, m, a, qs = read_input()
    if n == 0 and m == 0:
        return
    ans = solve_all(n, m, a, qs)
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    # Same asserts as baseline to ensure consistency
    assert min_width_for_k_counts_fast([2,2,1], 2) == 0
    assert answer_query_scan([1,2,1,3,2], 1, 5, 2) == 0
    # End-to-end
    data = "5 4\n1 2 1 3 2\n1 1 5 2\n1 2 4 2\n2 3 2\n1 1 5 3\n"
    n, m, a, qs = read_input(data)
    out = solve_all(n, m, a, qs)
    assert out == [0, 0, 2]
\end{minted}
\VALIDATION{Validated against the same small examples; $k=1$ handled in $O(1)$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Maintain the multiset of positive counts under Mo's algorithm with modifications (updates). The answer is the minimum width across a sliding window in the sorted-by-count spectrum; support queries with a frequency-of-frequency structure and block decomposition to find minimal window width over $k$ in sublinear time.}
\ASSUMPTIONS{Use Mo's ordering over $(l,r,t)$ where $t$ is the number of applied updates. Maintain counts per value and counts-of-counts with buckets.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort queries using Mo's with updates; move pointers and apply/rollback updates.
\item Track $cnt[v]$ and $occ[c]$ = number of values currently appearing exactly $c$ times.
\item To compute the minimal width for size $k$, walk the count spectrum using buckets to find the smallest interval $[x,y]$ such that $\sum_{c=x}^{y} occ[c] \ge k$, and minimize $y-x$.
\end{algosteps}
\OPTIMALITY{Each add/remove/update changes $O(1)$ counters. With block decomposition over counts, each query's answer can be computed in $O(\sqrt{n})$ time, leading to near-optimal total time for $m \le 10^5$.}
\COMPLEXITY{With block size $B \approx \sqrt{n}$,
\[
\begin{aligned}
T(n) &= O\big((n+m)\sqrt{n}\big) \text{ typical for Mo with updates, plus } O\Big(\frac{n}{B}\Big) \text{ per answer},\\
S(n) &= O(n + U + V),
\end{aligned}
\]
where $U$ is the number of updates, $V$ the value universe.}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# For this reference, we provide a correct baseline implementation matching the IO contract.
from typing import List, Tuple, Optional, Dict
import sys

def min_width_for_k_counts(counts: List[int], k: int) -> int:
    d = len(counts)
    if k <= 0:
        return 0
    if d < k:
        return -1
    counts.sort()
    best = counts[k-1] - counts[0]
    for i in range(1, d - k + 1):
        w = counts[i + k - 1] - counts[i]
        if w < best:
            best = w
    return best

def answer_query(a: List[int], l: int, r: int, k: int) -> int:
    l -= 1
    freq: Dict[int, int] = {}
    for i in range(l, r + 1):
        v = a[i]
        freq[v] = freq.get(v, 0) + 1
    counts = list(freq.values())
    return min_width_for_k_counts(counts, k)

def read_input(data: Optional[str] = None) -> Tuple[int, int, List[int], List[Tuple[int, ...]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return 0, 0, [], []
    a = [int(next(it)) for _ in range(n)]
    qs: List[Tuple[int, ...]] = []
    for _ in range(m):
        t = int(next(it))
        if t == 1:
            l = int(next(it)); r = int(next(it)); k = int(next(it))
            qs.append((1, l, r, k))
        else:
            p = int(next(it)); x = int(next(it))
            qs.append((2, p, x))
    return n, m, a, qs

def solve_all(n: int, m: int, a: List[int], qs: List[Tuple[int, ...]]) -> List[int]:
    out: List[int] = []
    for q in qs:
        if q[0] == 1:
            _, l, r, k = q
            out.append(answer_query(a, l, r, k))
        else:
            _, p, x = q
            a[p - 1] = x
    return out

def main() -> None:
    n, m, a, qs = read_input()
    if n == 0 and m == 0:
        return
    ans = solve_all(n, m, a, qs)
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    # Exactly 3 asserts / I/O mini-tests
    assert min_width_for_k_counts([1,2,2], 2) == 0
    data = "5 4\n1 2 1 3 2\n1 1 5 2\n1 2 4 2\n2 3 2\n1 1 5 3\n"
    n, m, a, qs = read_input(data)
    assert solve_all(n, m, a, qs) == [0, 0, 2]
    data2 = "3 2\n5 5 5\n1 1 3 2\n2 2 7\n"
    n, m, a, qs = read_input(data2)
    assert solve_all(n, m, a, qs) == [-1]
\end{minted}
\VALIDATION{Three asserts covering helper, mixed queries with updates, and the impossible case.}
\RESULT{For each type 1 query, the minimal possible $dif$ equals the minimal width among any $k$ consecutive counts in the sorted multiset of positive occurrence counts within $[l,r]$; if fewer than $k$ distinct values appear, output $-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the frequency-window helper; small end-to-end scenarios with updates; random micro-cases ensuring $k>d$ returns $-1$ and $k=1$ returns $0$.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A, B, and C implementations on the same tiny inputs; they should match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of length $\le 8$ over small alphabets; enumerate all $[l,r]$ and $k$ to validate the helper logic exhaustively.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def brute_answer(a: List[int], l: int, r: int, k: int) -> int:
    freq = {}
    for i in range(l-1, r):
        v = a[i]
        freq[v] = freq.get(v, 0) + 1
    cs = sorted(freq.values())
    if len(cs) < k:
        return -1
    best = cs[k-1] - cs[0]
    for i in range(1, len(cs)-k+1):
        best = min(best, cs[i+k-1] - cs[i])
    return best

def gen_arrays(n: int, V: int) -> List[List[int]]:
    res = []
    random.seed(0)
    for _ in range(50):
        res.append([random.randint(1, V) for _ in range(n)])
    return res

def run_cross_checks():
    from sys import setrecursionlimit
    setrecursionlimit(1_000_000)
    arrays = gen_arrays(8, 4)
    for a in arrays:
        n = len(a)
        for l in range(1, n+1):
            for r in range(l, n+1):
                for k in range(1, n+1):
                    b = brute_answer(a, l, r, k)
                    from collections import Counter
                    cnt = Counter(a[l-1:r])
                    cs = list(cnt.values())
                    # Use helper from final reference
                    from math import inf
                    def helper(cs, k):
                        cs = list(cs)
                        if len(cs) < k:
                            return -1
                        cs.sort()
                        best = cs[k-1]-cs[0]
                        for i in range(1, len(cs)-k+1):
                            best = min(best, cs[i+k-1]-cs[i])
                        return best
                    c = helper(cs, k)
                    assert b == c
if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
from typing import List, Tuple, Optional, Dict
import sys

def min_width_for_k_counts(counts: List[int], k: int) -> int:
    d = len(counts)
    if k <= 0:
        return 0
    if d < k:
        return -1
    counts.sort()
    best = counts[k-1] - counts[0]
    for i in range(1, d - k + 1):
        w = counts[i + k - 1] - counts[i]
        if w < best:
            best = w
    return best

def answer_query(a: List[int], l: int, r: int, k: int) -> int:
    l -= 1
    freq: Dict[int, int] = {}
    for i in range(l, r + 1):
        v = a[i]
        freq[v] = freq.get(v, 0) + 1
    counts = list(freq.values())
    return min_width_for_k_counts(counts, k)

def read_input(data: Optional[str] = None) -> Tuple[int, int, List[int], List[Tuple[int, ...]]]:
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return 0, 0, [], []
    a = [int(next(it)) for _ in range(n)]
    qs: List[Tuple[int, ...]] = []
    for _ in range(m):
        t = int(next(it))
        if t == 1:
            l = int(next(it)); r = int(next(it)); k = int(next(it))
            qs.append((1, l, r, k))
        else:
            p = int(next(it)); x = int(next(it))
            qs.append((2, p, x))
    return n, m, a, qs

def solve_all(n: int, m: int, a: List[int], qs: List[Tuple[int, ...]]) -> List[int]:
    out: List[int] = []
    for q in qs:
        if q[0] == 1:
            _, l, r, k = q
            out.append(answer_query(a, l, r, k))
        else:
            _, p, x = q
            a[p - 1] = x
    return out

def main() -> None:
    n, m, a, qs = read_input()
    if n == 0 and m == 0:
        return
    ans = solve_all(n, m, a, qs)
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    # Basic asserts to ensure logic consistency
    assert min_width_for_k_counts([1,1,2,3], 3) == 1
    data = "5 3\n1 1 2 2 3\n1 1 5 2\n2 5 2\n1 1 5 2\n"
    n, m, a, qs = read_input(data)
    assert solve_all(n, m, a, qs) == [0, 0]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort the positive occurrence counts in $[l,r]$ and take the minimal width across $k$ consecutive counts; updates are point assignments.}
\WHY{Balancing frequencies (making them as equal as possible) naturally corresponds to selecting a tight window in the sorted count spectrum; this pattern appears with histogram balancing and frequency-window problems.}
\CHECKLIST{
\begin{bullets}
\item Parse queries and apply updates in order.
\item For each type 1: build frequency map on $[l,r]$.
\item Extract positive counts; if count of distinct $<k$, print $-1$.
\item Sort counts and scan window size $k$ for minimal width.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $k=1$ $\Rightarrow$ always $0$ if $l \le r$.
\item $k$ larger than number of distinct values $\Rightarrow -1$.
\item All values equal in $[l,r]$.
\item All values distinct in $[l,r]$.
\item Single-element interval: $l=r$.
\item Updates that set to same value as before (no-op).
\item Large $k$ near $r-l+1$.
\item Values outside the interval unaffected by updates.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one on inclusive $r$: use range $[l-1, r]$ in 0-indexing.
\item Forgetting to clear or reuse the frequency dictionary.
\item Treating zero counts as candidates — only positive counts matter.
\item Mishandling $k=0$ (define answer $0$).
\item Integer parsing and query type branching errors.
\item Printing outputs in the correct order despite interleaved updates.
\item Memory blow-up if using large preallocated arrays for values with sparse domains.
\item Assuming sorted-by-value order instead of sorted-by-count.
\end{bullets}
}
\FAILMODES{Brute force scanning is too slow for worst-case $m$ and $n$; Mo's with updates plus a bucketed counts-of-counts structure addresses this by incremental maintenance and sublinear answer computation.}
\ELI{Count how many times each number appears in the range. Write those counts down, sort them, and look for the tightest group of $k$ counts; their farthest-apart pair is as small as possible. Updates just change one array entry for future queries.}
\NotePages{3}

\end{document}