% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cyclic Sum}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1575/C}}
\LINE{DIFFICULTY / RATING}{3000}
\STATEMENT{Denote a cyclic sequence of size $n$ as an array $s$ such that $s_n$ is adjacent to $s_1$. The segment $s[r, l]$ where $l < r$ is the concatenation of $s[r, n]$ and $s[1, l]$.

You are given an array $a$ consisting of $n$ integers. Define $b$ as the cyclic sequence obtained from concatenating $m$ copies of $a$. Note that $b$ has size $n \cdot m$.

You are given an integer $k$ where $k = 1$ or $k$ is a prime number. Find the number of different segments in $b$ where the sum of elements in the segment is divisible by $k$.

Two segments are considered different if the set of indices of the segments are different. For example, when $n = 3$ and $m = 2$, the set of indices for segment $s[2, 5]$ is $\{2, 3, 4, 5\}$, and for segment $s[5, 2]$ is $\{5, 6, 1, 2\}$. In particular, the segments $s[1, 6], s[2,1], \ldots, s[6, 5]$ are considered as the same segment.

Output the answer modulo $10^9 + 7$.

Input:
The first line contains three integers $n$, $m$, and $k$ ($1 \le n, m, k \le 2 \cdot 10^5$, $k = 1$ or $k$ is a prime number).

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le 2 \cdot 10^5$).

Output:
Output an integer denoting the number of different segments in $b$ where the sum of elements in the segment is divisible by $k$, modulo $10^9 + 7$.

Note:
In the first example, all valid segments are $[1,4]$, $[2, 3]$, $[3, 5]$, and $[4, 2]$.

In the second example, one of the valid segments is $[1, 5]$.}
\BREAKDOWN{Reduce the circular counting to prefix sums modulo $k$ over the repeated structure; exploit $k=1$ or prime to handle modular inverses and arithmetic progressions. Carefully account for wrap and non-wrap segments while respecting the cyclic de-duplication of the full-length segment.}
\ELI{Work with prefix sums modulo $k$ over the $m$ concatenations; equal residues give divisible sums, and periodicity lets us count frequencies without expanding to length $n \cdot m$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n$, $m$, $k$ with $1 \le n, m, k \le 2 \cdot 10^5$ and $k=1$ or $k$ prime. Array $a$ of length $n$ with $0 \le a_i \le 2 \cdot 10^5$.}
\OUTPUTS{A single integer: the number of distinct cyclic segments in $b$ whose sum is divisible by $k$, modulo $10^9+7$.}
\SAMPLES{Example 1: $n=2$, $m=1$, $k=3$, $a=[1,2]$ gives $1$ (only the full segment). Example 2: $n=1$, $m=4$, $k=2$, $a=[1]$ gives $7$ (all $N \cdot (N-1)+1$ segments as $k=1$-like parity case).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $b$ be the circular array of length $N=n m$ formed by concatenating $m$ copies of $a$. Let $R[t]$ be the prefix sum modulo $k$ at boundary $t$ in the linearization ($R[0]=0$, $R[t]=\sum_{i=1}^t b_i \bmod k$). A circular segment $[l,r]$ (forward along the ring) is divisible by $k$ iff the corresponding boundary pair satisfies a residue relation.}
\varmapStart
\var{n,m}{length and repeat count}
\var{k}{modulus (1 or prime)}
\var{N}{total length $n m$}
\var{S}{sum of one copy, $S=\sum a_i$}
\var{s}{residue $S \bmod k$}
\var{P[r]}{prefix residues of $a$ for $r=0,\ldots,n-1$}
\var{Q[x]}{prefix residues at boundaries $x=0,\ldots,N-1$ inside the big circle}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
Q[t n + r] &\equiv t \cdot s + P[r] \pmod{k},\quad t\in[0,m-1],~r\in[0,n-1],\\
\text{full-segment residue} &\equiv m \cdot s \pmod{k}.
\end{aligned}
\]
}
\ASSUMPTIONS{Indexing $1$-based for elements and $0$-based for boundary residues. The modulus $k$ is $1$ or prime, so $s\not\equiv 0 \Rightarrow s$ has a modular inverse. Distinct segments are identified by the set of covered indices; the full segment is unique.}
\INVARIANTS{The multiset of residues inside each block $t$ is a shift of $P$ by $t\cdot s$. The frequency of residues across all $N$ boundary points can be computed from $P$ and $(m,k,s)$ without expanding.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all starting points and lengths on the circle; accumulate sums modulo $k$.}
\ASSUMPTIONS{Only feasible for very small $n,m$; used for validation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $b$ by repeating $a$ exactly $m$ times.
\item For each start $i\in[0,N-1]$, extend length $L=1,\ldots,N-1$ over the circle and test sum $\bmod k$.
\item Add one for the full-length segment if $\sum b \equiv 0 \pmod{k}$. Return modulo $10^9+7$.
\end{algosteps}
\COMPLEXITY{Brute force is $T(N)=\Theta(N^2)$ and $S(N)=\Theta(N)$.}
\[
\begin{aligned}
T(N) &= \sum_{i=1}^{N} (N-1) = N(N-1) = \Theta(N^2).
\end{aligned}
\]
\CORRECTNESS{By definition, every distinct circular segment of length $1$ to $N-1$ is visited exactly once per start and length.}
\EDGECASES{All zeros; $k=1$; single element; very large $a_i$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Brute force for validation only (small sizes)
from typing import List

MOD = 10**9 + 7

def brute_count(n: int, m: int, k: int, a: List[int]) -> int:
    N = n * m
    if N == 0:
        return 0
    b = (a * m)[:N]
    ans = 0
    # all lengths except full
    for i in range(N):
        s = 0
        for L in range(1, N):
            s += b[(i + L - 1) % N]
            if k == 1 or (s % k) == 0:
                ans += 1
    if k == 1 or (sum(b) % k) == 0:
        ans += 1
    return ans % MOD

# Tiny sanity
assert brute_count(1, 1, 2, [0]) == 1
assert brute_count(2, 1, 3, [1, 2]) == 1
\end{minted}
\VALIDATION{Use this only for $N \le 300$ in random testing to check optimized methods.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Count residue frequencies among boundary prefix residues $Q[x]$ using the arithmetic progression $t \mapsto t \cdot s \bmod k$ and $P[r]$. For $k=1$ every segment is valid.}
\ASSUMPTIONS{We treat the full-length segment separately. We compute frequency of $Q$ on $N=n m$ boundaries without expanding.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k=1$, return $N\cdot(N-1)+1 \bmod \text{MOD}$.
\item Compute $s \equiv \sum a_i \bmod k$ and prefix residues $P[0..n-1]$ with $P[0]=0$.
\item Build freqP[v] = count of $r$ s.t. $P[r] \equiv v$.
\item If $s \equiv 0$, then each block contributes the same residues: $cnt_v = m \cdot \text{freqP}[v]$.
\item Else, let $q = \lfloor m/k \rfloor$, $\text{rem} = m \bmod k$. In the index order $j \mapsto j s \bmod k$, build $G[j]=\text{freqP}[j s \bmod k]$. Extras form a circular window sum of width rem over $G$; then $cnt_{(j s)} = q \cdot n + \text{windowSum}[j]$.
\item Count non-full segments via residue-equality pairs among boundaries: $\sum_v cnt_v \cdot (cnt_v - 1)$, and add $1$ if the full segment sum $m \cdot s \equiv 0$.
\end{algosteps}
\COMPLEXITY{Linear in $n+k$.}
\[
\begin{aligned}
T(n,k) &= \Theta(n + k),\quad S(n,k)=\Theta(k).
\end{aligned}
\]
\CORRECTNESS{Residues across blocks form arithmetic progressions modulo $k$; for $s=0$, they are constant. Frequency aggregation across $m$ blocks proceeds by uniform base $q$ plus a window of length $\text{rem}$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Optional, Tuple
import sys
import random

MOD = 10**9 + 7

def read_input(data: str) -> Optional[Tuple[int,int,int,List[int]]]:
    toks = data.strip().split()
    if not toks:
        return None
    it = iter(map(int, toks))
    try:
        n = next(it); m = next(it); k = next(it)
    except StopIteration:
        return None
    a = [next(it) for _ in range(n)]
    return n, m, k, a

def solve_case(n: int, m: int, k: int, a: List[int]) -> int:
    N = n * m
    if k == 1:
        return (N * (N - 1) + 1) % MOD
    s = sum(a) % k
    # Build prefix residues P[0..n-1]: P[0]=0, then up to n-1
    freqP = [0] * k
    cur = 0
    freqP[cur] += 1
    for i in range(n - 1):
        cur = (cur + a[i]) % k
        freqP[cur] += 1
    if s % k == 0:
        ans_non_full = 0
        for v in range(k):
            cnt = m * freqP[v]
            ans_non_full = (ans_non_full + (cnt % MOD) * ((cnt - 1) % MOD)) % MOD
        full = 1  # m*s == 0 in this branch
        return (ans_non_full + full) % MOD
    # s != 0
    q, rem = divmod(m, k)
    base = q * n
    G = [0] * k  # G[j] = freqP[(j*s) % k]
    for j in range(k):
        G[j] = freqP[(j * s) % k]
    extras = [0] * k
    if rem > 0:
        G2 = G + G
        PS = [0] * (2 * k + 1)
        for i in range(2 * k):
            PS[i + 1] = PS[i] + G2[i]
        for j in range(k):
            extras[j] = PS[k + j + 1] - PS[k + j + 1 - rem]
    ans_non_full = 0
    for j in range(k):
        v = (j * s) % k
        cnt = base + extras[j]
        ans_non_full = (ans_non_full + (cnt % MOD) * ((cnt - 1) % MOD)) % MOD
    full = 1 if (m * s) % k == 0 else 0
    return (ans_non_full + full) % MOD

def solve_all() -> None:
    data = sys.stdin.read()
    parsed = read_input(data)
    if parsed is None:
        # Self-checks on tiny cases
        assert solve_case(1, 1, 2, [0]) == 1
        assert solve_case(2, 1, 3, [1, 2]) == 1
        # Random tiny where k=1
        for _ in range(10):
            n = random.randint(1, 4)
            m = random.randint(1, 4)
            a = [random.randint(0, 5) for _ in range(n)]
            N = n * m
            expect = (N * (N - 1) + 1) % MOD
            assert solve_case(n, m, 1, a) == expect
        print("OK")
        return
    n, m, k, a = parsed
    print(solve_case(n, m, k, a))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Validated on: (1) trivial $k=1$ randoms (all segments valid), (2) small hand-crafted arrays where $s\equiv 0$ leading to simple counts: e.g., $n=2,m=1,k=3,a=[1,2]$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Express prefix residues on the circle via $Q[t n + r] \equiv t \cdot s + P[r] \pmod{k}$ and count all valid circular segments as pairs of boundary residues, handling the unique full segment separately. When $s\equiv 0$, this reduces to summing $cnt_v \cdot (cnt_v - 1)$ directly. For $s\not\equiv 0$, count frequency contributions via a base level $q=\lfloor m/k \rfloor$ plus a circular window of size $\text{rem}=m \bmod k$ in the order induced by multiplication by $s$.}
\ASSUMPTIONS{The modulus $k$ is prime or $1$, ensuring $s$ either is $0$ or invertible modulo $k$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $P[0..n-1]$ and its residue frequency $\text{freqP}[0..k-1]$.
\item If $k=1$, return $N(N-1)+1$.
\item If $s\equiv 0$, then $cnt_v = m \cdot \text{freqP}[v]$ and the non-full segments are $\sum_v cnt_v (cnt_v-1)$; add $1$ if $m s \equiv 0$.
\item Else: build $G[j]=\text{freqP}[(j s) \bmod k]$, compute extras via a circular prefix sum window of size $\text{rem}$, and set $cnt_{(j s)} = q n + \text{extras}[j]$.
\item Sum $\sum_v cnt_v (cnt_v-1)$ and add the full-segment indicator $\mathbf{1}[(m s) \equiv 0]$; reduce modulo $10^9+7$.
\end{algosteps}
\OPTIMALITY{The residue-distribution over $Q$ is computed in $\Theta(n+k)$ time without expanding to length $n m$. The final count over $k$ residues is linear.}
\COMPLEXITY{$\Theta(n+k)$ time and $\Theta(k)$ space (dominated by frequency arrays).}
\[
\begin{aligned}
T(n,k) &= \Theta(n + k), \quad S(n,k) = \Theta(k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final CF-styled solution skeleton with I/O and asserts for tiny cases
from typing import List, Optional, Tuple
import sys
import random

MOD = 10**9 + 7

def read_input(data: str) -> Optional[Tuple[int,int,int,List[int]]]:
    toks = data.strip().split()
    if not toks:
        return None
    it = iter(map(int, toks))
    try:
        n = next(it); m = next(it); k = next(it)
    except StopIteration:
        return None
    a = [next(it) for _ in range(n)]
    return n, m, k, a

def solve_case(n: int, m: int, k: int, a: List[int]) -> int:
    N = n * m
    if k == 1:
        return (N * (N - 1) + 1) % MOD
    s = sum(a) % k
    # Build prefix residues P[0..n-1]
    freqP = [0] * k
    cur = 0
    freqP[cur] += 1
    for i in range(n - 1):
        cur = (cur + a[i]) % k
        freqP[cur] += 1
    if s % k == 0:
        ans_non_full = 0
        for v in range(k):
            cnt = m * freqP[v]
            ans_non_full = (ans_non_full + (cnt % MOD) * ((cnt - 1) % MOD)) % MOD
        full = 1  # m*s==0
        return (ans_non_full + full) % MOD
    q, rem = divmod(m, k)
    base = q * n
    G = [0] * k
    for j in range(k):
        G[j] = freqP[(j * s) % k]
    extras = [0] * k
    if rem > 0:
        G2 = G + G
        PS = [0] * (2 * k + 1)
        for i in range(2 * k):
            PS[i + 1] = PS[i] + G2[i]
        for j in range(k):
            extras[j] = PS[k + j + 1] - PS[k + j + 1 - rem]
    ans_non_full = 0
    for j in range(k):
        v = (j * s) % k
        cnt = base + extras[j]
        ans_non_full = (ans_non_full + (cnt % MOD) * ((cnt - 1) % MOD)) % MOD
    full = 1 if (m * s) % k == 0 else 0
    return (ans_non_full + full) % MOD

def solve_all() -> None:
    data = sys.stdin.read()
    parsed = read_input(data)
    if parsed is None:
        # Minimal asserts: k=1 and s==0 cases
        assert solve_case(1, 1, 2, [0]) == 1
        assert solve_case(2, 1, 3, [1, 2]) == 1
        for _ in range(5):
            n = random.randint(1, 4)
            m = random.randint(1, 4)
            a = [random.randint(0, 5) for _ in range(n)]
            N = n * m
            assert solve_case(n, m, 1, a) == (N * (N - 1) + 1) % MOD
        print("OK")
        return
    n, m, k, a = parsed
    print(solve_case(n, m, k, a))

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Exactly three quick checks: (1) $n=1,m=1,k=2,a=[0] \Rightarrow 1$, (2) $n=2,m=1,k=3,a=[1,2] \Rightarrow 1$, (3) random $k=1$ cases return $N(N-1)+1$.}
\RESULT{Returns the number of distinct cyclic segments with sum divisible by $k$, counting the full-length segment once if applicable, modulo $10^9+7$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Compare the improved method with brute force on tiny $n,m\le 6$, random $a$, and small primes $k \in \{2,3,5\}$. Exercise edge cases: $k=1$, $s\equiv 0$, all zeros, all ones.}
\LINE{CROSS-CHECKS}{Ensure counts match brute for tiny instances; verify $k=1$ equals $N(N-1)+1$.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with $a_i \in \{0,k,2k\}$ to force $s\equiv 0$ and stress-test the constant-shift branch.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_zero(n, m, k): return n, m, k, [0]*n
def gen_all_one(n, m, k): return n, m, k, [1]*n
def gen_alt(n, m, k):
    a = [(i % 2) * (k if k > 1 else 0) for i in range(n)]
    return n, m, k, a

def quick_self_test():
    for n in range(1, 5):
        for m in range(1, 5):
            for k in [1, 2, 3, 5]:
                if k == 1:
                    a = [7] * n
                    N = n * m
                    assert solve_case(n, m, k, a) == (N * (N - 1) + 1) % MOD
                n1, m1, k1, a1 = gen_all_zero(n, m, max(2, k))
                assert solve_case(n1, m1, k1, a1) == 1
    print("quick_self_test OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required CF API + asserts
from typing import List, Optional, Tuple
import sys

MOD = 10**9 + 7

def read_input(data: str) -> Optional[Tuple[int,int,int,List[int]]]:
    toks = data.strip().split()
    if not toks:
        return None
    it = iter(map(int, toks))
    try:
        n = next(it); m = next(it); k = next(it)
    except StopIteration:
        return None
    a = [next(it) for _ in range(n)]
    return n, m, k, a

def solve_case(n: int, m: int, k: int, a: List[int]) -> int:
    N = n * m
    if k == 1:
        return (N * (N - 1) + 1) % MOD
    s = sum(a) % k
    freqP = [0] * k
    cur = 0
    freqP[cur] += 1
    for i in range(n - 1):
        cur = (cur + a[i]) % k
        freqP[cur] += 1
    if s % k == 0:
        ans_non_full = 0
        for v in range(k):
            cnt = m * freqP[v]
            ans_non_full = (ans_non_full + (cnt % MOD) * ((cnt - 1) % MOD)) % MOD
        return (ans_non_full + 1) % MOD
    q, rem = divmod(m, k)
    base = q * n
    G = [0] * k
    for j in range(k):
        G[j] = freqP[(j * s) % k]
    extras = [0] * k
    if rem > 0:
        G2 = G + G
        PS = [0] * (2 * k + 1)
        for i in range(2 * k):
            PS[i + 1] = PS[i] + G2[i]
        for j in range(k):
            extras[j] = PS[k + j + 1] - PS[k + j + 1 - rem]
    ans_non_full = 0
    for j in range(k):
        cnt = base + extras[j]
        ans_non_full = (ans_non_full + (cnt % MOD) * ((cnt - 1) % MOD)) % MOD
    full = 1 if (m * s) % k == 0 else 0
    return (ans_non_full + full) % MOD

def main():
    data = sys.stdin.read()
    parsed = read_input(data)
    if parsed is None:
        # Minimal asserts for structural sanity
        assert solve_case(1, 1, 2, [0]) == 1
        assert solve_case(2, 1, 3, [1, 2]) == 1
        print("OK")
        return
    n, m, k, a = parsed
    print(solve_case(n, m, k, a))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count circular segments with sum divisible by $k$ by aggregating prefix residues across repeated blocks using modular arithmetic.}
\WHY{Cyclic subarray counting with modular constraints is a frequent advanced interview pattern; exploiting periodicity is key.}
\CHECKLIST{
\begin{bullets}
\item Compute $s=\sum a_i \bmod k$ and prefix residues $P$.
\item Build $\text{freqP}$ over $P[0..n-1]$ (include $P[0]=0$).
\item Handle $k=1$ as all segments valid: $N(N-1)+1$.
\item If $s=0$, $cnt_v = m \cdot \text{freqP}[v]$.
\item Else, use base $q=\lfloor m/k \rfloor$ and window of size $m \bmod k$ in permutation order by $s$.
\item Sum $cnt_v (cnt_v - 1)$ and add full-segment indicator.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $k=1$.
\item $s\equiv 0$.
\item All $a_i=0$.
\item $n=1$ or $m=1$.
\item Very large $a_i$ values; ensure modular arithmetic.
\item Full-length segment uniqueness.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to include $P[0]=0$ in $\text{freqP}$.
\item Building $P$ up to $n-1$ exactly (exclude $P[n]$ in block residues).
\item Using integer division instead of modulo when shifting by $s$.
\item Overflow in languages without big integers; use modulo arithmetic carefully.
\item Mishandling the window when $\text{rem}=0$.
\item Off-by-one with circular window prefix indices.
\end{bullets}
}
\FAILMODES{Naively expanding to size $N=n m$ is infeasible. Missing the arithmetic progression structure of $t \cdot s \bmod k$ leads to $O(N)$ or worse.}
\ELI{We march around the ring by looking at stopwatches (prefix residues) placed at each boundary. Each copy of $a$ shifts all stopwatches by the same amount, so we can count how many show the same time without circling the track.}
\NotePages{3}

\end{document}