% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Score Triangulation of Polygon}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-score-triangulation-of-polygon/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You have a convex $n$-sided polygon where each vertex has an integer value. You are given an integer array \texttt{values} where \texttt{values[i]} is the value of the $i$th vertex in clockwise order.

Polygon triangulation is a process where you divide a polygon into a set of triangles and the vertices of each triangle must also be vertices of the original polygon. No other shapes are allowed. This process results in $n-2$ triangles.

You will triangulate the polygon. For each triangle, the weight of that triangle is the product of the values at its vertices. The total score of the triangulation is the sum of these weights over all $n-2$ triangles.

Return the minimum possible score that you can achieve with some triangulation of the polygon.

Examples:
1) Input: \texttt{values = [1,2,3]} — Output: \texttt{6}. The polygon is already triangulated; the score of the only triangle is $1\times 2\times 3=6$.

2) Input: \texttt{values = [3,7,4,5]} — Output: \texttt{144}. Two triangulations yield scores $3\times 7\times 5 + 4\times 5\times 7 = 245$ or $3\times 4\times 5 + 3\times 4\times 7 = 144$; the minimum is $144$.

3) Input: \texttt{values = [1,3,1,4,1,5]} — Output: \texttt{13}. One minimum triangulation has score $1\times 1\times 3 + 1\times 1\times 4 + 1\times 1\times 5 + 1\times 1\times 1 = 13$.

Constraints: $n = \texttt{len}(\texttt{values})$, $3 \le n \le 50$, and $1 \le \texttt{values[i]} \le 100$.}
\BREAKDOWN{We need the minimum sum of triangle products formed by triangulating a convex polygon with vertex weights given in circular order. This is a classic interval dynamic programming problem: fix an edge $(i,j)$ and choose a middle vertex $k$ to form triangle $(i,k,j)$, combining optimal subproblems $(i,k)$ and $(k,j)$.}
\ELI{Split the polygon by picking a middle vertex to form one triangle, solve the two smaller polygons optimally, and take the best split.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single list \texttt{values} of length $n$:
\begin{bullets}
\item Type: list of integers.
\item Ordering: clockwise around a convex polygon.
\item Ranges: $3 \le n \le 50$; $1 \le \texttt{values[i]} \le 100$.
\end{bullets}}
\OUTPUTS{A single integer: the minimum possible triangulation score, i.e., the minimum sum of $v_i v_j v_k$ over the $n-2$ triangles in the triangulation.}
\SAMPLES{Examples in LC style:
\begin{bullets}
\item Input: \texttt{[1,2,3]} — Output: \texttt{6}.
\item Input: \texttt{[3,7,4,5]} — Output: \texttt{144}.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the polygon vertices be indexed $0,1,\ldots,n-1$ in clockwise order with weights $v_0,\ldots,v_{n-1}$. A triangulation decomposes the polygon into $n-2$ triangles $(i,k,j)$ with $i<k<j$ in the linearized order respecting noncrossing diagonals. The objective is to minimize the sum of triangle costs $v_i v_k v_j$.}
\varmapStart
\var{n}{number of vertices}
\var{v_i}{value at vertex $i$}
\var{\text{dp}[i][j]}{minimum score to triangulate the chain of vertices $i,i+1,\ldots,j$}
\var{(i,k,j)}{a triangle using edge $(i,j)$ and middle vertex $k$ with $i<k<j$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{dp}[i][i+1]=0,\quad \text{for all } 0\le i<n-1.
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{For } j-i\ge 2:\quad \text{dp}[i][j] = \min_{i<k<j}\bigl(\text{dp}[i][k]+\text{dp}[k][j]+v_i v_k v_j\bigr).
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Answer}=\text{dp}[0][n-1].
\end{BreakableEquation*}
}
\ASSUMPTIONS{The polygon is convex; indices are treated in linear order $[0,n-1]$ with fixed outer edge $(0,n-1)$; all values are positive integers.}
\INVARIANTS{
\begin{bullets}
\item For any $i<j$, $\text{dp}[i][j]\ge 0$ and equals $0$ iff $j=i+1$ (no triangle possible).
\item Optimal substructure: an optimal triangulation across $(i,j)$ has an optimal partition at some $k$ and includes optimal triangulations of $(i,k)$ and $(k,j)$.
\item Noncrossing: triangles considered by the recurrence never produce crossing diagonals due to interval structure.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all triangulations recursively by picking every possible middle vertex $k$ between $i$ and $j$; sum costs without caching. Correct by optimal substructure, but exponential.}
\ASSUMPTIONS{Use recursion on intervals $(i,j)$; treat the polygon as a chain from $0$ to $n-1$; base case when $j-i<2$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $j-i<2$, return $0$.
\item Otherwise, try all $k\in\{i+1,\ldots,j-1\}$ and compute cost of triangle $(i,k,j)$ plus recursive costs on $(i,k)$ and $(k,j)$.
\item Return the minimum over all $k$.
\end{algosteps}
\COMPLEXITY{Let $T(m)$ be time on a chain of length $m=j-i+1$. Then $T(m)=\sum_{k=2}^{m-1} T(k)T(m-k+1)+O(1)$, which is the Catalan recursion; thus $T(n)=\Theta(C_{n-2})\sim \dfrac{4^{n}}{n^{3/2}\sqrt{\pi}}$. Space is $O(n)$ for recursion depth.}
\[
\begin{aligned}
T(n) &\in \Theta(C_{n-2}) \\
     &\sim \frac{4^{n}}{n^{3/2}\sqrt{\pi}}.
\end{aligned}
\]
\CORRECTNESS{By construction, every triangulation corresponds to a unique sequence of splits $(i,k,j)$ and we consider all $k$. Base cases handle chains too short to form a triangle. The minimum over all $k$ yields the optimal triangulation score.}
\EDGECASES{Smallest $n=3$ returns $v_0 v_1 v_2$; identical values; increasing or decreasing sequences; all ones.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)

        def solve(i: int, j: int) -> int:
            if j - i < 2:
                return 0
            best = 10**18
            for k in range(i + 1, j):
                cost = values[i] * values[k] * values[j]
                best = min(best, solve(i, k) + solve(k, j) + cost)
            return best

        return solve(0, n - 1)

# basic asserts (small n to avoid exponential blowup)
assert Solution().minScoreTriangulation([1, 2, 3]) == 6
assert Solution().minScoreTriangulation([3, 7, 4, 5]) == 144
assert Solution().minScoreTriangulation([1, 3, 1, 4, 1, 5]) == 13
\end{minted}
\VALIDATION{Checks:
\begin{bullets}
\item Single triangle \texttt{[1,2,3]} gives 6.
\item Example \texttt{[3,7,4,5]} gives 144.
\item Example \texttt{[1,3,1,4,1,5]} gives 13.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Top-down interval DP with memoization on $(i,j)$ eliminates repeated subproblems in the brute force recursion.}
\ASSUMPTIONS{Memoize \texttt{solve(i,j)} using \texttt{functools.lru\_cache}. Positive weights ensure no negative cycles or special handling.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define memoized \texttt{solve(i,j)} returning $\text{dp}[i][j]$.
\item If $j-i<2$, return $0$.
\item Otherwise compute $\min_{i<k<j}\bigl(\text{solve}(i,k)+\text{solve}(k,j)+v_i v_k v_j\bigr)$ and cache.
\end{algosteps}
\COMPLEXITY{There are $O(n^2)$ states $(i,j)$, each considers $O(n)$ splits $k$, so $T(n)=O(n^3)$ and $S(n)=O(n^2)$ for the memo table plus $O(n)$ recursion depth.}
\[
\begin{aligned}
T(n) &= O(n^2 \cdot n) = O(n^3).
\end{aligned}
\]
\CORRECTNESS{Matches the governing recurrence exactly; memoization ensures each subproblem is solved optimally once.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from functools import lru_cache

class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)

        @lru_cache(maxsize=None)
        def solve(i: int, j: int) -> int:
            if j - i < 2:
                return 0
            best = 10**18
            for k in range(i + 1, j):
                best = min(best, solve(i, k) + solve(k, j) + values[i] * values[k] * values[j])
            return best

        return solve(0, n - 1)

# asserts (covers provided examples)
assert Solution().minScoreTriangulation([1, 2, 3]) == 6
assert Solution().minScoreTriangulation([3, 7, 4, 5]) == 144
assert Solution().minScoreTriangulation([1, 3, 1, 4, 1, 5]) == 13
\end{minted}
\VALIDATION{Edge inputs:
\begin{bullets}
\item Minimum $n=3$ returns product of all three.
\item All ones \texttt{[1,1,1,1,1]} returns $n-2=3$.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Bottom-up interval DP filling increasing lengths $\ell=j-i$. Transition: $\text{dp}[i][j]=\min_{i<k<j}\text{dp}[i][k]+\text{dp}[k][j]+v_i v_k v_j$.}
\ASSUMPTIONS{Convex polygon and clockwise order; base $\text{dp}[i][i+1]=0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $\text{dp}[i][i+1]=0$ for all $i$ and others to $+\infty$.
\item For lengths $\ell=2$ to $n-1$, for all $i$, set $j=i+\ell$ and compute the transition over all $k$ with $i<k<j$.
\item Return $\text{dp}[0][n-1]$.
\end{algosteps}
\OPTIMALITY{This DP exactly implements the optimal substructure with no overlaps remaining; for convex polygons any triangulation can be decomposed into interval subproblems. A standard lower bound via considering all $k$ shows $O(n^3)$ time is tight for this DP formulation.}
\COMPLEXITY{$O(n^3)$ time and $O(n^2)$ space.}
\[
\begin{aligned}
T(n) &= \sum_{\ell=2}^{n-1}\sum_{i=0}^{n-\ell-1} O(\ell) = O(n^3).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)
        INF = 10**18
        dp = [[0 if j == i + 1 else INF for j in range(n)] for i in range(n)]
        for length in range(2, n):  # length = j - i
            for i in range(0, n - length):
                j = i + length
                best = INF
                for k in range(i + 1, j):
                    cand = dp[i][k] + dp[k][j] + values[i] * values[k] * values[j]
                    if cand < best:
                        best = cand
                dp[i][j] = best
        return dp[0][n - 1]

# exactly 3 asserts
assert Solution().minScoreTriangulation([1, 2, 3]) == 6
assert Solution().minScoreTriangulation([3, 7, 4, 5]) == 144
assert Solution().minScoreTriangulation([1, 3, 1, 4, 1, 5]) == 13
\end{minted}
\VALIDATION{Three sample-based asserts pass deterministically.}
\RESULT{Returns the minimum achievable triangulation score; there is no tie-breaking since the value returned is the score (an integer).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests over:
\begin{bullets}
\item Base case $n=3$.
\item Small hand-crafted arrays including strictly increasing, decreasing, and all ones.
\item Random small arrays (length $\le 8$) cross-checked between top-down and bottom-up implementations.
\end{bullets}}
\LINE{CROSS-CHECKS}{Verify equality of results from Approach B and C for many random seeds on small $n$; both must match brute force (Approach A) for $n\le 7$.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of 1s, arrays with alternating 1 and large values, and monotone arrays to stress the choice of middle $k$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_ones(n: int) -> List[int]:
    return [1] * n

def gen_alternating(n: int, a: int = 1, b: int = 100) -> List[int]:
    return [a if i % 2 == 0 else b for i in range(n)]

def gen_monotone(n: int, start: int = 1, step: int = 1) -> List[int]:
    return [start + i * step for i in range(n)]

def cross_check(values: List[int]) -> None:
    from functools import lru_cache

    class TopDown:
        def solve(self, values: List[int]) -> int:
            n = len(values)
            @lru_cache(maxsize=None)
            def f(i: int, j: int) -> int:
                if j - i < 2: return 0
                best = 10**18
                for k in range(i + 1, j):
                    best = min(best, f(i, k) + f(k, j) + values[i]*values[k]*values[j])
                return best
            return f(0, n - 1)

    class BottomUp:
        def solve(self, values: List[int]) -> int:
            n = len(values)
            INF = 10**18
            dp = [[0 if j == i + 1 else INF for j in range(n)] for i in range(n)]
            for length in range(2, n):
                for i in range(0, n - length):
                    j = i + length
                    best = INF
                    for k in range(i + 1, j):
                        cand = dp[i][k] + dp[k][j] + values[i]*values[k]*values[j]
                        if cand < best: best = cand
                    dp[i][j] = best
            return dp[0][n - 1]

    td, bu = TopDown(), BottomUp()
    assert td.solve(values) == bu.solve(values)

# quick deterministic checks
for n in [3, 4, 5, 6]:
    cross_check(gen_all_ones(n))
    cross_check(gen_alternating(n))
    cross_check(gen_monotone(n, start=1, step=2))
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)
        INF = 10**18
        dp = [[0 if j == i + 1 else INF for j in range(n)] for i in range(n)]
        for length in range(2, n):  # length = j - i
            for i in range(0, n - length):
                j = i + length
                best = INF
                for k in range(i + 1, j):
                    cand = dp[i][k] + dp[k][j] + values[i] * values[k] * values[j]
                    if cand < best:
                        best = cand
                dp[i][j] = best
        return dp[0][n - 1]

# sanity asserts
assert Solution().minScoreTriangulation([1, 2, 3]) == 6
assert Solution().minScoreTriangulation([3, 7, 4, 5]) == 144
assert Solution().minScoreTriangulation([1, 3, 1, 4, 1, 5]) == 13
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize the sum of triangle products in a convex polygon via interval DP: $\text{dp}[i][j]=\min_{i<k<j}\text{dp}[i][k]+\text{dp}[k][j]+v_i v_k v_j$.}
\WHY{A staple LC/ICPC pattern for polygon triangulation, matrix chain multiplication, and optimal BST; tests interval DP mastery.}
\CHECKLIST{
\begin{bullets}
\item Define state on an interval $(i,j)$ with base $0$ for length $\le 2$.
\item Transition over all middle $k$ between $i$ and $j$.
\item Order computation by increasing interval length or memoize.
\item Return $\text{dp}[0][n-1]$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=3$ single triangle.
\item All values equal.
\item Alternating small/large values.
\item Monotone increasing or decreasing values.
\item Presence of $1$ values near endpoints.
\item Maximum $n=50$ to ensure $O(n^3)$ fits time.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting base $\text{dp}[i][i+1]=0$.
\item Wrong interval length loop bounds ($\ell$ from $2$ to $n-1$).
\item Off-by-one when iterating $k$ in $(i+1,\ldots,j-1)$.
\item Using $+\infty$ initialization incorrectly (must take $\min$ over $k$).
\item Mixing circular vs linear indexing; fix endpoints $(0,n-1)$.
\item Integer overflow not an issue in Python but watch in other languages.
\item Returning $\min_k v_i v_k v_j$ only (forgetting subproblem costs).
\item Misreading order (clockwise) — here order only fixes indexing.
\end{bullets}}
\FAILMODES{Brute force explodes on $n>10$ due to Catalan growth; memoized or bottom-up DP avoids repeated work and runs in $O(n^3)$ for $n\le 50$.}
\ELI{Always cut the polygon along an edge by choosing a middle vertex, pay that triangle's cost, and add the best costs of the two smaller polygons. Try all possible cuts and keep the cheapest.}
\NotePages{3}

\end{document}