% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tennis Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/628/A}}
\LINE{DIFFICULTY / RATING}{1000}
\STATEMENT{A tennis tournament with $n$ participants is running. The participants are playing by an olympic system, so the winners move on and the losers drop out.

The tournament takes place in the following way (below, $m$ is the number of the participants of the current round):
\begin{bullets}
\item let $k$ be the maximal power of the number $2$ such that $k \le m$,
\item $k$ participants compete in the current round and a half of them passes to the next round, the other $m - k$ participants pass to the next round directly,
\item when only one participant remains, the tournament finishes.
\end{bullets}
Each match requires $b$ bottles of water for each participant and one bottle for the judge. Besides $p$ towels are given to each participant for the whole tournament.

Find the number of bottles and towels needed for the tournament.

Note that it is a tennis tournament so in each match two participants compete (one of them will win and the other will lose).

Input:
The only line contains three integers $n$, $b$, $p$ ($1 \le n, b, p \le 500$) — the number of participants and the parameters described in the problem statement.

Output:
Print two integers $x$ and $y$ — the number of bottles and towels needed for the tournament.

Note:
In the first example there will be three rounds:
\begin{enumerate}[leftmargin=2em]
\item in the first round there will be two matches and for each match $5$ bottles of water are needed (two for each of the participants and one for the judge),
\item in the second round there will be only one match, so we need another $5$ bottles of water,
\item in the third round there will also be only one match, so we need another $5$ bottles of water.
\end{enumerate}
So in total we need $20$ bottles of water.

In the second example no participant will move on to some round directly.}
\BREAKDOWN{Determine the total number of matches played under the given bye scheme, then multiply by per-match bottle usage; towels are simply $p$ per participant. Use the invariant that each match eliminates exactly one participant.}
\ELI{Every match knocks out exactly one player, so there are $n-1$ matches; each match uses $2b+1$ bottles and towels are $p$ per player.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One line with three integers $n$, $b$, $p$ where $1 \le n, b, p \le 500$.}
\OUTPUTS{Two integers $x$ and $y$ separated by a space:
\begin{bullets}
\item $x$ — total number of bottles used across all matches,
\item $y$ — total number of towels distributed to all participants.
\end{bullets}}
\SAMPLES{Example 1:
\begin{bullets}
\item Input: 5 2 1
\item Output: 20 5
\end{bullets}
Example 2:
\begin{bullets}
\item Input: 8 3 2
\item Output: 49 16
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Single-elimination with byes to the next round does not change the total number of matches. Each match eliminates exactly one participant until one remains.}
\varmapStart
\var{n}{initial number of participants}
\var{b}{bottles per participant in a match}
\var{p}{towels per participant (once for the whole tournament)}
\var{x}{total bottles consumed}
\var{y}{total towels distributed}
\var{M}{total number of matches}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
M &= n - 1,\\
x &= (2b + 1)\,M = (2b + 1)\,(n - 1),\\
y &= n\,p.
\end{aligned}
\]
}
\ASSUMPTIONS{Two participants per match; every match eliminates exactly one participant; the bye scheme only skips matches but still ends when $1$ remains.}
\INVARIANTS{
\begin{bullets}
\item Participants remaining decrease by exactly $1$ per match.
\item Total eliminations from start to finish equal $n-1$.
\item Towels distribution is independent of match structure: each participant gets $p$ towels exactly once.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate rounds using the problem's $k$ definition: in each round let $k$ be the largest power of $2$ with $k \le m$; schedule $k/2$ matches, let $m-k$ pass, and iterate. Accumulate bottles by matches $\times (2b+1)$.}
\ASSUMPTIONS{Use integer arithmetic; loop until $m=1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $m \gets n$, $x \gets 0$.
\item While $m > 1$: let $k$ be the largest power of $2$ with $k \le m$; add $(k/2)\times(2b+1)$ to $x$; update $m \gets (m-k) + (k/2)$.
\item Set $y \gets n\times p$, output $x$ and $y$.
\end{algosteps}
\COMPLEXITY{Each loop at least halves the number of active competitors, thus $O(\log n)$ iterations; $O(1)$ work per iteration.}
\[
\begin{aligned}
T(n) &= O(\log n), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Each iteration accounts exactly for the matches played in that round as per the statement. Because each match eliminates one participant, after finishing we end with exactly one participant and have accumulated the correct number of matches and thus bottles. Towels are simply $n p$.}
\EDGECASES{$n=1$ yields zero matches and thus zero bottles; towels remain $n p$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import Tuple

def highest_power_of_two_leq(m: int) -> int:
    k = 1
    while (k << 1) <= m:
        k <<= 1
    return k

def compute_totals_simulation(n: int, b: int, p: int) -> Tuple[int, int]:
    m = n
    bottles = 0
    while m > 1:
        k = highest_power_of_two_leq(m)
        matches = k // 2
        bottles += matches * (2 * b + 1)
        # survivors: (m - k) pass + matches winners
        m = (m - k) + matches
    towels = n * p
    return bottles, towels

def read_input() -> Tuple[int, int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0
    n, b, p = map(int, data[:3])
    return n, b, p

def solve_case(n: int, b: int, p: int) -> Tuple[int, int]:
    return compute_totals_simulation(n, b, p)

def solve_all() -> None:
    n, b, p = read_input()
    if n == 0 and b == 0 and p == 0:
        return
    x, y = solve_case(n, b, p)
    print(x, y)

# --- tests / asserts ---
def _formula(n: int, b: int, p: int) -> Tuple[int, int]:
    matches = max(0, n - 1)
    return matches * (2 * b + 1), n * p

# Known cases
assert compute_totals_simulation(5, 2, 1) == (20, 5)
assert compute_totals_simulation(1, 10, 7) == (0, 7)
assert compute_totals_simulation(8, 3, 2) == (49, 16)
# Cross-check simulation vs formula for a range
for n in range(1, 21):
    for b in range(1, 6):
        for p in range(1, 4):
            assert compute_totals_simulation(n, b, p) == _formula(n, b, p)

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Checked against closed-form for many small values; explicit asserts for $n \in \{1,5,8\}$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Closed Form}
\WHICHFORMULA{Use the invariant that each match eliminates exactly one participant. Hence total matches $M=n-1$ regardless of byes. Compute directly without simulation.}
\ASSUMPTIONS{Single-elimination; two participants per match; $n \ge 1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $M \gets n-1$.
\item Compute $x \gets (2b+1)\,M$.
\item Compute $y \gets n\,p$ and output $x, y$.
\end{algosteps}
\COMPLEXITY{Constant time and space.}
\[
\begin{aligned}
T(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{In a single-elimination tournament, every match removes exactly one participant and the tournament ends at one remaining participant. Therefore $M=n-1$ always. Multiplying by per-match bottle usage and per-participant towels gives the totals.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import Tuple

def compute_totals_direct(n: int, b: int, p: int) -> Tuple[int, int]:
    matches = max(0, n - 1)
    bottles = matches * (2 * b + 1)
    towels = n * p
    return bottles, towels

def read_input() -> Tuple[int, int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0
    n, b, p = map(int, data[:3])
    return n, b, p

def solve_case(n: int, b: int, p: int) -> Tuple[int, int]:
    return compute_totals_direct(n, b, p)

def solve_all() -> None:
    n, b, p = read_input()
    if n == 0 and b == 0 and p == 0:
        return
    x, y = solve_case(n, b, p)
    print(x, y)

# --- tests / asserts ---
assert compute_totals_direct(5, 2, 1) == (20, 5)
assert compute_totals_direct(1, 10, 7) == (0, 7)
assert compute_totals_direct(8, 3, 2) == (49, 16)

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Edge cases $n=1$ and powers of two; random small checks show agreement with the simulation approach.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Constant-Time Formula}
\WHICHFORMULA{Final method: compute $x=(2b+1)\,(n-1)$, $y=n\,p$.}
\ASSUMPTIONS{Applies to any $n \ge 1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set $x \gets (2b+1)\,(n-1)$.
\item Set $y \gets n\,p$.
\item Print $x$ and $y$.
\end{algosteps}
\OPTIMALITY{Any correct solution must account for at least all $n-1$ eliminations; computing directly is asymptotically optimal in both time and space.}
\COMPLEXITY{Constant time and space.}
\[
\begin{aligned}
T(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import Tuple

def read_input() -> Tuple[int, int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0
    n, b, p = map(int, data[:3])
    return n, b, p

def solve_case(n: int, b: int, p: int) -> Tuple[int, int]:
    matches = max(0, n - 1)
    return matches * (2 * b + 1), n * p

def solve_all() -> None:
    n, b, p = read_input()
    if n == 0 and b == 0 and p == 0:
        return
    x, y = solve_case(n, b, p)
    print(x, y)

# --- tests / asserts ---
def _simulate(n: int, b: int, p: int) -> Tuple[int, int]:
    def highest_pow2_leq(m: int) -> int:
        k = 1
        while (k << 1) <= m:
            k <<= 1
        return k
    m = n
    bottles = 0
    while m > 1:
        k = highest_pow2_leq(m)
        matches = k // 2
        bottles += matches * (2 * b + 1)
        m = (m - k) + matches
    return bottles, n * p

assert solve_case(5, 2, 1) == (20, 5)
assert solve_case(8, 3, 2) == (49, 16)
assert solve_case(1, 4, 9) == (0, 9)
# Cross-check vs simulation for a few random small values
for n in range(1, 12):
    for b in range(1, 5):
        for p in range(1, 4):
            assert solve_case(n, b, p) == _simulate(n, b, p)

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 direct asserts plus a small cross-check loop against a simulation oracle.}
\RESULT{Print two integers: total bottles $x=(2b+1)\,(n-1)$ and total towels $y=n\,p$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the direct formula against the simulation across a grid of small inputs; include edge cases like $n=1$ and $n$ a power of two.}
\LINE{CROSS-CHECKS}{Compare Approach A (simulation) vs B/C (formula) for many small triplets $(n,b,p)$.}
\LINE{EDGE-CASE GENERATOR}{Generate $n \in \{1,2,3,4,5,8,9\}$, $b \in \{1,2,3,4\}$, $p \in \{1,2,3\}$ to cover byes and exact powers of two.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    for n in [1,2,3,4,5,7,8,9,16]:
        for b in [1,2,3,4,5]:
            for p in [1,2,3]:
                yield n, b, p

def simulate(n, b, p):
    def highest_pow2_leq(m):
        k = 1
        while (k << 1) <= m:
            k <<= 1
        return k
    m = n
    bottles = 0
    while m > 1:
        k = highest_pow2_leq(m)
        matches = k // 2
        bottles += matches * (2 * b + 1)
        m = (m - k) + matches
    return bottles, n * p

def direct(n, b, p):
    return max(0, n - 1) * (2 * b + 1), n * p

# Cross-check
for n, b, p in gen_cases():
    assert simulate(n, b, p) == direct(n, b, p)

print("OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, 0
    n, b, p = map(int, data[:3])
    return n, b, p

def solve_case(n, b, p):
    matches = max(0, n - 1)
    x = matches * (2 * b + 1)
    y = n * p
    return x, y

def solve_all():
    n, b, p = read_input()
    if n == 0 and b == 0 and p == 0:
        return
    x, y = solve_case(n, b, p)
    print(x, y)

# basic asserts
assert solve_case(5, 2, 1) == (20, 5)
assert solve_case(8, 3, 2) == (49, 16)
assert solve_case(1, 10, 7) == (0, 7)

if __name__ == "__main__":
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Total matches in single-elimination with byes is $n-1$, so bottles are $(2b+1)(n-1)$ and towels are $n p$.}
\WHY{This pattern shows up in tournament or elimination-style problems; recognizing the invariant saves time over simulating rounds.}
\CHECKLIST{
\begin{bullets}
\item Remember: each match eliminates one participant $\Rightarrow$ $n-1$ matches.
\item Per-match bottles: two players $\Rightarrow$ $2b$ plus $1$ judge bottle.
\item Towels: $p$ per participant, once.
\item Handle $n=1$ correctly: zero matches, zero bottles.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ (no matches).
\item $n$ a power of two (no byes occur).
\item $n$ just above a power of two (many byes initially).
\item Minimum values $b=1$, $p=1$.
\item Larger small bounds $n=500$, $b=500$, $p=500$.
\item Mixed cases where $b$ or $p$ dominate the output scale.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting the judge bottle per match ($+1$).
\item Miscounting towels per match instead of per participant.
\item Attempting complex simulation that risks off-by-one in round transitions.
\item Overflow not an issue here but keep integer arithmetic exact.
\item Printing order reversed ($y$ then $x$) — ensure $x~y$.
\item Mishandling $n=1$ leading to negative matches.
\end{bullets}
}
\FAILMODES{Round-by-round simulation that incorrectly updates the survivor count or chooses $k$ may miscount matches; the invariant-based formula avoids such logic errors entirely.}
\ELI{You knock out exactly one player every time two people play. Starting from $n$ and ending at $1$ means you played $n-1$ matches. Multiply by the bottles per match; towels are just $p$ per person.}
\NotePages{3}

\end{document}