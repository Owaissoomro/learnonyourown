% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — The Dining Philosophers}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/the-dining-philosophers/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Five silent philosophers sit at a round table with bowls of spaghetti. Forks are placed between each pair of adjacent philosophers.

Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. A philosopher can take the fork on their right or the one on their left as they become available, but cannot start eating before getting both forks.

Eating is not limited by the remaining amounts of spaghetti or stomach space; an infinite supply and an infinite demand are assumed.

Design a discipline of behaviour (a concurrent algorithm) such that no philosopher will starve; \_i.e.\_, each can forever continue to alternate between eating and thinking, assuming that no philosopher can know when others may want to eat or think.

The problem statement and the image above are taken from \url{https://en.wikipedia.org/wiki/Dining_philosophers_problem}.

The philosophers' ids are numbered from 0 to 4 in a clockwise order. Implement the function \texttt{void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)} where:
\begin{bullets}
\item \texttt{philosopher} is the id of the philosopher who wants to eat.
\item \texttt{pickLeftFork} and \texttt{pickRightFork} are functions you can call to pick the corresponding forks of that philosopher.
\item \texttt{eat} is a function you can call to let the philosopher eat once he has picked both forks.
\item \texttt{putLeftFork} and \texttt{putRightFork} are functions you can call to put down the corresponding forks of that philosopher.
\item The philosophers are assumed to be thinking as long as they are not asking to eat (the function is not being called with their number).
\end{bullets}

Five threads, each representing a philosopher, will simultaneously use one object of your class to simulate the process. The function may be called for the same philosopher more than once, even before the last call ends.

Example 1:

Input: \texttt{n = 1}

Output: \texttt{[[3,2,1],[3,1,1],[3,0,3],[3,1,2],[3,2,2],[4,2,1],[4,1,1],[2,2,1],[2,1,1],[1,2,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[4,2,2],[1,1,1],[1,0,3],[1,1,2],[1,2,2],[0,1,1],[0,2,1],[0,0,3],[0,1,2],[0,2,2]]}

Explanation: \texttt{n} is the number of times each philosopher will call the function. The output array describes the calls you made to the functions controlling the forks and the eat function, its format is: \texttt{output[i] = [a, b, c]} (three integers).
\begin{bullets}
\item \texttt{a} is the id of a philosopher.
\item \texttt{b} specifies the fork: \{1 : left, 2 : right\}.
\item \texttt{c} specifies the operation: \{1 : pick, 2 : put, 3 : eat\}.
\end{bullets}

Constraints: \quad $1 \le n \le 60$.}
\BREAKDOWN{We must implement a thread-safe coordination scheme for five forks and five philosophers that guarantees safety (no two philosophers hold the same fork), avoids deadlock, and ensures starvation-freedom so each philosopher repeatedly eats and thinks.}
\ELI{Coordinate picking of two forks per philosopher using locks and a scheduling rule so no cyclic waiting occurs and everyone eventually eats.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{The judge repeatedly invokes \texttt{wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)} concurrently across five threads, where:
\begin{bullets}
\item \texttt{philosopher} is an integer in $\{0,1,2,3,4\}$.
\item \texttt{pickLeftFork}, \texttt{pickRightFork}, \texttt{eat}, \texttt{putLeftFork}, \texttt{putRightFork} are callback functions provided by the judge that must be called in a correct order to reflect actions.
\end{bullets}
There is also an integer \texttt{n} (with $1 \le n \le 60$) representing how many times each philosopher will try to eat.}
\OUTPUTS{A correct interleaving of callback calls satisfying:
\begin{bullets}
\item Mutual exclusion per fork: no two philosophers hold the same fork simultaneously.
\item Per philosopher: picks both forks before calling \texttt{eat}, and puts both down afterwards.
\item Progress: the algorithm must avoid deadlock and starvation. The judge verifies by checking that each philosopher performs \texttt{eat} exactly \texttt{n} times.
\end{bullets}}
\SAMPLES{Example style (conceptual):
\begin{bullets}
\item Input: \texttt{n = 1}. One valid trace segment: \texttt{[0,1,1]} (0 picks left), \texttt{[0,2,1]} (0 picks right), \texttt{[0,0,3]} (0 eats), \texttt{[0,1,2]}, \texttt{[0,2,2]}.
\item Input: \texttt{n = 2}. One valid global trace may interleave different philosophers as long as the safety/order constraints above are respected.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $P=\{0,\ldots,4\}$ be philosophers sitting on a cycle. Let forks be edges $F=\{(i,(i{+}1)\bmod 5): i\in P\}$, each a unit-capacity resource. Each execution consists of actions pick and put on forks and an eat action per philosopher, respecting resource capacity and per-philosopher ordering constraints. Objective: design a protocol so that the system is deadlock-free and starvation-free while maximizing concurrency where possible.}
\varmapStart
\var{i}{philosopher id in $P$}
\var{L(i)}{left fork index for $i$ (we use $L(i)=i$)}
\var{R(i)}{right fork index for $i$ (we use $R(i)=(i{+}1)\bmod 5$)}
\var{\ell_f(t)}{owner of fork $f$ at time $t$, or $\bot$ if free}
\var{S}{scheduling policy (e.g., resource ordering or a waiter semaphore)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Capacity:}&& \forall f\in F,\ \forall t:~ \ell_f(t)\in P\ \text{or}\ \ell_f(t)=\bot; \quad \ell_f \text{ is single-valued (at most one owner).}\\
&\text{Eat precondition:}&& \text{$i$ may call eat only if } \ell_{L(i)}(t)=i \text{ and } \ell_{R(i)}(t)=i.\\
&\text{Put postcondition:}&& \text{After eating, } \ell_{L(i)}:=\bot,\ \ell_{R(i)}:=\bot.\\
&\text{Deadlock freedom:}&& \text{Protocol $S$ enforces an acyclic wait-for relation at all times.}\\
&\text{Starvation freedom:}&& \forall i\in P:\ \text{if $i$ requests to eat infinitely often, } i \text{ eats infinitely often.}
\end{aligned}
\]
}
\ASSUMPTIONS{Forks are atomic lockable resources; callbacks are instantaneous abstractions; threads are fair enough that a thread eventually acquires a lock if it remains enabled; philosopher indices and fork assignments are fixed.}
\INVARIANTS{
\begin{bullets}
\item Mutual exclusion: each fork is held by at most one philosopher.
\item Order compliance: each philosopher performs pick(s) $\rightarrow$ eat $\rightarrow$ put(s) in that order per eating cycle.
\item Acyclic waits (for Approaches B/C): resource ordering or the waiter bound ensures no directed cycle of waits exists.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use a single global mutex (``waiter'') so that only one philosopher can attempt to pick forks at a time. This trivially prevents deadlock and starvation, at the cost of zero parallelism.}
\ASSUMPTIONS{Callbacks are fast; the critical section can be coarse without timing out.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain one global mutex and five fork mutexes.
\item When a philosopher wants to eat: acquire the global mutex, then lock both forks (left and right), perform picks, eat, put both forks, unlock both forks, then release the global mutex.
\item Left/right choice does not matter because exclusivity is global.
\end{algosteps}
\COMPLEXITY{Per eating event is $O(1)$ time and $O(1)$ space. Throughput is limited to one eater at a time.}
\[
\begin{aligned}
T(n) &= \Theta(n) \text{ per philosopher, with a constant bound per event.}\\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Global mutual exclusion eliminates cyclic waits and thus deadlock. Every request eventually acquires the waiter lock and proceeds, implying starvation-freedom under fair scheduling. Fork-level mutual exclusion preserves safety.}
\EDGECASES{Reentrant calls from the same philosopher; immediate consecutive calls; all five request simultaneously. All are serialized by the waiter.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import Callable, List, Tuple, Dict, Optional
import threading

class DiningPhilosophersA:
    def __init__(self) -> None:
        self.forks = [threading.Lock() for _ in range(5)]
        self.waiter = threading.Lock()

    def wantsToEat(
        self,
        philosopher: int,
        pickLeftFork: Callable[[], None],
        pickRightFork: Callable[[], None],
        eat: Callable[[], None],
        putLeftFork: Callable[[], None],
        putRightFork: Callable[[], None],
    ) -> None:
        left = philosopher
        right = (philosopher + 1) % 5
        with self.waiter:
            # lock order arbitrary due to global exclusivity
            self.forks[left].acquire()
            self.forks[right].acquire()
            try:
                pickLeftFork()
                pickRightFork()
                eat()
                putLeftFork()
                putRightFork()
            finally:
                self.forks[right].release()
                self.forks[left].release()

# Test harness helpers (deterministic, single-thread simulation)
class Recorder:
    def __init__(self):
        self.events: List[Tuple[int,int,int]] = []
        self.held_by: Dict[int, Optional[int]] = {i: None for i in range(5)}
        self.both_held: Dict[int, bool] = {i: False for i in range(5)}

    def _pick(self, phil: int, fork_idx: int, side: int):
        assert self.held_by[fork_idx] is None, "Fork already held"
        self.held_by[fork_idx] = phil
        self.events.append((phil, side, 1))
        self.both_held[phil] = (
            self.held_by[phil] == phil and self.held_by[(phil + 1) % 5] == phil
        )

    def _put(self, phil: int, fork_idx: int, side: int):
        assert self.held_by[fork_idx] == phil, "Putting fork not held by this phil"
        self.events.append((phil, side, 2))
        self.held_by[fork_idx] = None
        self.both_held[phil] = False

    def pickLeft(self, phil: int):
        self._pick(phil, phil, 1)

    def pickRight(self, phil: int):
        self._pick(phil, (phil + 1) % 5, 2)

    def putLeft(self, phil: int):
        self._put(phil, phil, 1)

    def putRight(self, phil: int):
        self._put(phil, (phil + 1) % 5, 2)

    def eat(self, phil: int):
        # Must have both forks
        assert self.held_by[phil] == phil and self.held_by[(phil + 1) % 5] == phil, "Eat without both forks"
        self.events.append((phil, 0, 3))

def _run_sequence(dining) -> List[Tuple[int,int,int]]:
    rec = Recorder()
    def mk(ph):
        return (
            lambda: rec.pickLeft(ph),
            lambda: rec.pickRight(ph),
            lambda: rec.eat(ph),
            lambda: rec.putLeft(ph),
            lambda: rec.putRight(ph),
        )
    # Interleave requests (sequentially here)
    for round_ in range(2):
        for ph in [0,2,4,1,3]:
            pl, pr, e, ql, qr = mk(ph)
            dining.wantsToEat(ph, pl, pr, e, ql, qr)
    # Post: all forks free
    assert all(owner is None for owner in rec.held_by.values())
    # Event structure sanity
    for (a,b,c) in rec.events:
        assert c in (1,2,3)
    return rec.events

class Solution:
    def test(self) -> bool:
        dining = DiningPhilosophersA()
        ev = _run_sequence(dining)
        # Each eating cycle must include a 3 (eat)
        assert any(c == 3 for (_,_,c) in ev), "No eat events recorded"
        return True

# Quick asserts
assert Solution().test()
\end{minted}
\VALIDATION{Checks:
\begin{bullets}
\item Asserts that no fork is ever simultaneously held by two philosophers.
\item Asserts that \texttt{eat} is called only when both forks are held by the philosopher.
\item After the interleaved sequence, all forks are free.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Impose a global resource ordering: always acquire the lower-indexed fork first, then the higher-indexed fork. This breaks the wait-for cycle and allows concurrent eating by non-adjacent philosophers.}
\ASSUMPTIONS{Forks are modeled as mutexes; ordering by fork index is globally consistent and known to all.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain five fork mutexes.
\item For philosopher $i$, compute $L=i$, $R=(i{+}1)\bmod 5$, and let $(F_1,F_2)$ be the forks in increasing order.
\item Lock $F_1$ then $F_2$, call the corresponding picks in the same order, then \texttt{eat}, then call puts in reverse order, and release both locks.
\end{algosteps}
\COMPLEXITY{Same $O(1)$ per event, but improved throughput: two non-adjacent philosophers may eat simultaneously.}
\[
\begin{aligned}
T(n) &= \Theta(1) \text{ per event; no global serialization.}
\end{aligned}
\]
\CORRECTNESS{Total order on resources removes cycles in the wait-for graph, preventing deadlock. Mutual exclusion via fork locks ensures safety. Under fair locking, starvation does not occur because no philosopher is perpetually bypassed when its forks become available.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import Callable, List, Tuple, Dict, Optional
import threading

class DiningPhilosophersB:
    def __init__(self) -> None:
        self.forks = [threading.Lock() for _ in range(5)]

    def wantsToEat(
        self,
        philosopher: int,
        pickLeftFork: Callable[[], None],
        pickRightFork: Callable[[], None],
        eat: Callable[[], None],
        putLeftFork: Callable[[], None],
        putRightFork: Callable[[], None],
    ) -> None:
        left = philosopher
        right = (philosopher + 1) % 5
        # Order forks to avoid cycles
        first_fork = min(left, right)
        second_fork = max(left, right)
        # Acquire in order
        self.forks[first_fork].acquire()
        self.forks[second_fork].acquire()
        try:
            # Call pick functions in the same order as locks
            if first_fork == left:
                pickLeftFork()
                pickRightFork()
            else:
                pickRightFork()
                pickLeftFork()
            eat()
            # Put in reverse order of picks
            if first_fork == left:
                putLeftFork()
                putRightFork()
            else:
                putRightFork()
                putLeftFork()
        finally:
            self.forks[second_fork].release()
            self.forks[first_fork].release()

# Deterministic tests (single-thread simulation)
class RecorderB:
    def __init__(self):
        self.events: List[Tuple[int,int,int]] = []
        self.held_by: Dict[int, Optional[int]] = {i: None for i in range(5)}

    def pick(self, phil: int, fork_idx: int, side: int):
        assert self.held_by[fork_idx] is None
        self.held_by[fork_idx] = phil
        self.events.append((phil, side, 1))

    def put(self, phil: int, fork_idx: int, side: int):
        assert self.held_by[fork_idx] == phil
        self.events.append((phil, side, 2))
        self.held_by[fork_idx] = None

    def eat(self, phil: int):
        l, r = phil, (phil + 1) % 5
        assert self.held_by[l] == phil and self.held_by[r] == phil
        self.events.append((phil, 0, 3))

def _run_sequence_B(dining) -> List[Tuple[int,int,int]]:
    rec = RecorderB()
    def mk(ph):
        return (
            lambda: rec.pick(ph, ph, 1),
            lambda: rec.pick(ph, (ph + 1) % 5, 2),
            lambda: rec.eat(ph),
            lambda: rec.put(ph, ph, 1),
            lambda: rec.put(ph, (ph + 1) % 5, 2),
        )
    # Interleave and check invariants
    for ph in [0,2,4,1,3,0,3]:
        pl, pr, e, ql, qr = mk(ph)
        dining.wantsToEat(ph, pl, pr, e, ql, qr)
    assert all(v is None for v in rec.held_by.values())
    return rec.events

class Solution:
    def test(self) -> bool:
        dining = DiningPhilosophersB()
        ev = _run_sequence_B(dining)
        # Every eat event must be preceded by two picks by the same philosopher
        last_two: Dict[int, List[int]] = {}
        for a,b,c in ev:
            last_two.setdefault(a, [])
            if c == 1:
                last_two[a].append(b)
                last_two[a] = last_two[a][-2:]
            if c == 3:
                assert set(last_two[a]) == {1,2}
        return True

assert Solution().test()
\end{minted}
\VALIDATION{We validate via:
\begin{bullets}
\item Enforcing that no fork is double-held.
\item Ensuring each \texttt{eat} is preceded by both picks by the same philosopher.
\item Ensuring all forks are free at the end.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use a ``waiter'' semaphore permitting at most 4 concurrent philosophers to attempt picking forks, plus fork mutexes. This zeroes the possibility of the 5-way cycle and offers high concurrency while being simple and robust.}
\ASSUMPTIONS{Semaphore and mutex primitives are fair; callbacks are invoked inside the critical regions.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a semaphore initialized to 4 and five fork mutexes.
\item When a philosopher wants to eat: acquire the semaphore, then lock left and right fork (order arbitrary), call picks, call \texttt{eat}, call puts, release both fork locks, then release the semaphore.
\item The capacity-4 semaphore ensures that at least one fork remains available system-wide, eliminating the all-hold-left deadlock pattern.
\end{algosteps}
\OPTIMALITY{At most four philosophers contend for forks concurrently, which is sufficient to avoid cyclic waits. This approach is deadlock-free and starvation-free under fair scheduling. Concurrency is comparable to the resource-ordering approach while conceptually simpler.}
\COMPLEXITY{Per event $O(1)$ time and $O(1)$ space.}
\[
\begin{aligned}
T(n) &= \Theta(1) \text{ per event; up to two non-adjacent philosophers can eat concurrently.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import Callable, List, Tuple, Dict, Optional
import threading

class DiningPhilosophers:
    def __init__(self) -> None:
        self.forks = [threading.Lock() for _ in range(5)]
        self.waiter = threading.Semaphore(4)  # allow up to 4 to try acquiring forks

    def wantsToEat(
        self,
        philosopher: int,
        pickLeftFork: Callable[[], None],
        pickRightFork: Callable[[], None],
        eat: Callable[[], None],
        putLeftFork: Callable[[], None],
        putRightFork: Callable[[], None],
    ) -> None:
        left = philosopher
        right = (philosopher + 1) % 5
        self.waiter.acquire()
        # Acquire both forks (order can be consistent but not required with waiter)
        self.forks[left].acquire()
        self.forks[right].acquire()
        try:
            pickLeftFork()
            pickRightFork()
            eat()
            putLeftFork()
            putRightFork()
        finally:
            self.forks[right].release()
            self.forks[left].release()
            self.waiter.release()

# Deterministic validation without threads (simulated callbacks)
class RecorderC:
    def __init__(self):
        self.events: List[Tuple[int,int,int]] = []
        self.held_by: Dict[int, Optional[int]] = {i: None for i in range(5)}

    def pick(self, phil: int, fork_idx: int, side: int):
        assert self.held_by[fork_idx] is None
        self.held_by[fork_idx] = phil
        self.events.append((phil, side, 1))

    def put(self, phil: int, fork_idx: int, side: int):
        assert self.held_by[fork_idx] == phil
        self.events.append((phil, side, 2))
        self.held_by[fork_idx] = None

    def eat(self, phil: int):
        l, r = phil, (phil + 1) % 5
        assert self.held_by[l] == phil and self.held_by[r] == phil
        self.events.append((phil, 0, 3))

def _simulate_calls(dining) -> List[Tuple[int,int,int]]:
    rec = RecorderC()
    def mk(ph):
        return (
            lambda: rec.pick(ph, ph, 1),
            lambda: rec.pick(ph, (ph + 1) % 5, 2),
            lambda: rec.eat(ph),
            lambda: rec.put(ph, ph, 1),
            lambda: rec.put(ph, (ph + 1) % 5, 2),
        )
    # Simulate multiple rounds
    for ph in [0,1,2,3,4,0,2,4,1,3]:
        pl, pr, e, ql, qr = mk(ph)
        dining.wantsToEat(ph, pl, pr, e, ql, qr)
    assert all(v is None for v in rec.held_by.values())
    return rec.events

class Solution:
    def test(self) -> bool:
        d = DiningPhilosophers()
        ev = _simulate_calls(d)
        # 1) At least one eat happened
        assert any(c == 3 for (_,_,c) in ev)
        # 2) Safety: after each pick, no double-hold of same fork occurs (Recorder enforces)
        # 3) Order: each eat by a philosopher must have two picks by same philosopher since last puts
        seen_picks: Dict[int, List[int]] = {i: [] for i in range(5)}
        for a,b,c in ev:
            if c == 1:
                seen_picks[a].append(b)
                seen_picks[a] = seen_picks[a][-2:]
            if c == 3:
                assert set(seen_picks[a]) == {1,2}
        return True

# Exactly 3 asserts / mini-tests
assert Solution().test()
assert isinstance(DiningPhilosophers(), DiningPhilosophers)
assert len(_simulate_calls(DiningPhilosophers())) > 0
\end{minted}
\VALIDATION{Exactly three checks:
\begin{bullets}
\item Sanity test of the protocol using simulated callbacks.
\item Class construction validity.
\item Non-empty event trace with correct invariants.
\end{bullets}}
\RESULT{The final class \texttt{DiningPhilosophers} coordinates fork acquisition using a capacity-4 semaphore plus per-fork mutexes, guaranteeing safety, deadlock-freedom, and (under fair scheduling) starvation-freedom.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-level invariants via simulated callbacks: enforce mutual exclusion of forks; ensure \texttt{eat} only occurs when both forks are held; ensure forks are released after each cycle; vary call order across philosophers.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C on the same deterministic interleavings; traces should all respect constraints. Approach B/C allow higher concurrency in real threads; A serializes all.}
\LINE{EDGE-CASE GENERATOR}{Generate sequences with repeated immediate calls by the same philosopher, alternating neighbors, and round-robin cycles to test put/pick boundaries.}
\begin{minted}{python}
from typing import Callable, List, Tuple, Dict, Optional
import threading
import random

def gen_sequences(rounds: int = 3) -> List[int]:
    # Deterministic edge-heavy schedule: neighbors and repeats
    seq = []
    for _ in range(rounds):
        seq += [0,1,0,2,3,4,4,3,2,1]
    return seq

class ReferenceRecorder:
    def __init__(self):
        self.events: List[Tuple[int,int,int]] = []
        self.held_by: Dict[int, Optional[int]] = {i: None for i in range(5)}
    def pick(self, phil: int, fork_idx: int, side: int):
        assert self.held_by[fork_idx] is None
        self.held_by[fork_idx] = phil
        self.events.append((phil, side, 1))
    def put(self, phil: int, fork_idx: int, side: int):
        assert self.held_by[fork_idx] == phil
        self.events.append((phil, side, 2))
        self.held_by[fork_idx] = None
    def eat(self, phil: int):
        l, r = phil, (phil + 1) % 5
        assert self.held_by[l] == phil and self.held_by[r] == phil
        self.events.append((phil, 0, 3))

def run_harness(dining_cls) -> List[Tuple[int,int,int]]:
    d = dining_cls()
    rec = ReferenceRecorder()
    def mk(ph):
        return (
            lambda: rec.pick(ph, ph, 1),
            lambda: rec.pick(ph, (ph + 1) % 5, 2),
            lambda: rec.eat(ph),
            lambda: rec.put(ph, ph, 1),
            lambda: rec.put(ph, (ph + 1) % 5, 2),
        )
    for ph in gen_sequences():
        pl, pr, e, ql, qr = mk(ph)
        d.wantsToEat(ph, pl, pr, e, ql, qr)
    assert all(v is None for v in rec.held_by.values())
    return rec.events

# Reference Code (Ready to Submit): Approach C
class DiningPhilosophers:
    def __init__(self) -> None:
        self.forks = [threading.Lock() for _ in range(5)]
        self.waiter = threading.Semaphore(4)
    def wantsToEat(
        self,
        philosopher: int,
        pickLeftFork: Callable[[], None],
        pickRightFork: Callable[[], None],
        eat: Callable[[], None],
        putLeftFork: Callable[[], None],
        putRightFork: Callable[[], None],
    ) -> None:
        l = philosopher
        r = (philosopher + 1) % 5
        self.waiter.acquire()
        self.forks[l].acquire()
        self.forks[r].acquire()
        try:
            pickLeftFork()
            pickRightFork()
            eat()
            putLeftFork()
            putRightFork()
        finally:
            self.forks[r].release()
            self.forks[l].release()
            self.waiter.release()

# Quick consistency checks
trace = run_harness(DiningPhilosophers)
assert any(c == 3 for (_,_,c) in trace)
assert len(trace) > 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Coordinate five threads to acquire two shared resources each, preventing deadlock and starvation, and preserving per-fork mutual exclusion.}
\WHY{Classic concurrency interview staple; tests understanding of deadlock, resource ordering, semaphores, and fairness.}
\CHECKLIST{
\begin{bullets}
\item Map each philosopher to fork indices: left $=i$, right $=(i{+}1)\bmod 5$.
\item Choose a deadlock-avoidance rule: total order or waiter semaphore.
\item Ensure pick order matches lock order; put after eat.
\item Release resources in a finally block to avoid leaks on exceptions.
\item Consider fairness to argue starvation-freedom.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All five request simultaneously.
\item Re-entrant calls for the same philosopher.
\item Immediate neighbor contentions (e.g., 0 and 1 alternating).
\item Long sequences where one philosopher requests very frequently.
\item Callback failures or unexpected exceptions (guard with \texttt{finally}).
\item Correct handling of modulo arithmetic for fork indices.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Picking both forks without a global rule leads to deadlock.
\item Calling picks in an order different from lock acquisition order can confuse trace validators.
\item Forgetting to release a fork on early return or exception.
\item Using busy-wait instead of blocking locks can waste CPU.
\item Assuming fairness without justification (document it).
\item Off-by-one on right fork index $(i{+}1)\bmod 5$.
\item Using non-reentrant locks then recursively calling \texttt{wantsToEat} from callbacks (do not do this).
\item Mixing left/right labels when the lock order is swapped.
\end{bullets}}
\FAILMODES{A naive left-then-right for all philosophers deadlocks if all pick left first. Even/odd asymmetric picking helps, but a clean proof comes from total ordering or a waiter semaphore with capacity 4.}
\ELI{Make the rule simple: at most four try at once, and each takes both forks before eating. Or, always take the lower-numbered fork first. Either way, no cycles form, so everyone eventually eats.}
\NotePages{3}

\end{document}