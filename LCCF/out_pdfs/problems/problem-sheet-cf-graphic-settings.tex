% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Graphic Settings}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/863/G}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{Recently Ivan bought a new computer. Excited, he unpacked it and installed his favourite game. With his old computer Ivan had to choose the worst possible graphic settings (because otherwise the framerate would be really low), but now he wants to check, maybe his new computer can perform well even with the best possible graphics?

There are $m$ graphics parameters in the game. $i$-th parameter can be set to any positive integer from $1$ to $a_i$, and initially is set to $b_i$ ($b_i \le a_i$). So there are $p = \prod_{i=1}^{m} a_i$ different combinations of parameters. Ivan can increase or decrease any of these parameters by $1$; after that the game will be restarted with new parameters (and Ivan will have the opportunity to check chosen combination of parameters).

Ivan wants to try all $p$ possible combinations. Also he wants to return to the initial settings after trying all combinations, because he thinks that initial settings can be somehow best suited for his hardware. But Ivan does not really want to make a lot of restarts.

So he wants you to tell the following:
\begin{bullets}
\item If there exists a way to make exactly $p$ changes (each change either decreases or increases some parameter by $1$) to try all possible combinations and return to initial combination, then Ivan wants to know this way.
\item Otherwise, if there exists a way to make exactly $p-1$ changes to try all possible combinations (including the initial one), then Ivan wants to know this way.
\end{bullets}
Help Ivan by showing him the way to change parameters!

Input: The first line of input contains one integer number $m$ ($1 \le m \le 6$).

The second line contains $m$ integer numbers $a_1, a_2, \ldots, a_m$ ($2 \le a_i \le 1000$). It is guaranteed that $p = \prod_{i=1}^{m} a_i \le 10^5$.

The third line contains $m$ integer numbers $b_1, b_2, \ldots, b_m$ ($1 \le b_i \le a_i$).

Output: If there is a way to make exactly $p$ changes (each change either decreases or increases some parameter by $1$) to try all possible combinations and return to initial combination, then output \texttt{Cycle} in the first line. Then $p$ lines must follow, each describing a change. The line must be either \texttt{inc x} (increase parameter $x$ by $1$) or \texttt{dec x} (decrease it).

Otherwise, if there is a way to make exactly $p - 1$ changes to try all possible combinations (including the initial one), then output \texttt{Path} in the first line. Then $p - 1$ lines must follow, each describing the change the same way as mentioned above.

Otherwise, output \texttt{No}.}
\BREAKDOWN{We need a Hamiltonian cycle or path in an $m$-dimensional grid graph $[1..a_1]\times\cdots\times[1..a_m]$ with unit steps along axes, starting at the initial vertex $b$. If any $a_i$ is even and $m\ge 2$, a cycle exists. Otherwise, construct a Hamiltonian path starting at $b$ (except the degenerate $m=1$ interior case).}
\ELI{Enumerate all grid points in a ``serpentine'' Gray order that changes exactly one coordinate by $\pm 1$ each step; rotate each axis so the sequence starts at the given $b$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test. Integers $m$ ($1\le m\le 6$); arrays $a_1..a_m$ ($2\le a_i\le 1000$, with $\prod a_i\le 10^5$), and $b_1..b_m$ ($1\le b_i\le a_i$).}
\OUTPUTS{Either \texttt{Cycle} and then $p$ lines of moves; or \texttt{Path} and then $p-1$ lines of moves; or \texttt{No}. Each move is exactly one of \texttt{inc x} or \texttt{dec x} for $1\le x\le m$.}
\SAMPLES{Example 1 (cycle possible): $m=2$, $a=(2,3)$, $b=(2,1)$. One valid output is \texttt{Cycle} with $p=6$ moves forming a loop.

Example 2 (path only): $m=2$, $a=(3,3)$, $b=(2,2)$. Output \texttt{Path} with $p-1=8$ moves starting at $(2,2)$ and visiting all $9$ points.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Grid graph $G=\square_{i=1}^m P_{a_i}$, vertices are $m$-tuples $(x_1,\ldots,x_m)$ with $x_i\in[1..a_i]$, edges connect tuples differing by exactly one coordinate by $\pm 1$. Find either: a Hamiltonian cycle through $b$, or a Hamiltonian path starting at $b$.}
\varmapStart
\var{m}{number of dimensions}
\var{a_i}{side length on dimension $i$}
\var{b_i}{initial coordinate on dimension $i$}
\var{p}{number of vertices, $p=\prod_i a_i$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Adjacency: } (x_1,\ldots,x_m)\sim(y_1,\ldots,y_m)\iff \sum_i |x_i-y_i|=1.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Graph is bipartite by $\sum_i x_i\bmod 2$. If $m\ge 2$ and some $a_i$ is even then there exists a Hamiltonian cycle. If all $a_i$ are odd then no cycle exists, but Hamiltonian paths exist starting at any vertex for $m\ge 2$. For $m=1$, only endpoints $1$ and $a_1$ can be endpoints of a Hamiltonian path.}
\INVARIANTS{At every step, exactly one coordinate changes by $\pm 1$. Each visited state is unique until the very last step of a cycle which returns to start.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Backtracking DFS from $b$ trying moves $\pm 1$ until Hamiltonicity.}
\ASSUMPTIONS{Prune by degree and parity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Start at $b$; mark visited.
\item Try all legal moves $\pm 1$ along each dimension, prioritizing unvisited nodes.
\item Backtrack on dead ends; stop when all $p$ visited (and optionally check for closing edge for cycle).
\end{algosteps}
\COMPLEXITY{Exponential in worst case; impractical for $p\le 10^5$.}
\[
\begin{aligned}
T(n) &\approx O(\text{branch}^{p}) \\
     &\text{(hopeless for contest bounds).}
\end{aligned}
\]
\CORRECTNESS{Would find a valid path/cycle if it exists.}
\EDGECASES{$m=1$; borders $x_i=1$ or $a_i$; parity constraints.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Exponential DFS (for illustration only; not used in final).
from typing import List, Tuple, Optional

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    m = int(next(it))
    a = [int(next(it)) for _ in range(m)]
    b = [int(next(it)) for _ in range(m)]
    return m, a, b

def neighbors(pos: Tuple[int, ...], a: List[int]) -> List[Tuple[int, ...]]:
    res = []
    m = len(a)
    for i in range(m):
        if pos[i] > 1:
            p = list(pos); p[i] -= 1; res.append(tuple(p))
        if pos[i] < a[i]:
            p = list(pos); p[i] += 1; res.append(tuple(p))
    return res

def solve_case_baseline(m: int, a: List[int], b: List[int]) -> Tuple[str, List[str]]:
    # Not used: placeholder to satisfy contract; returns No to avoid exponential search.
    return "No", []

def main():
    m, a, b = read_input()
    kind, ops = solve_case_baseline(m, a, b)
    if kind == "No":
        print("No")
        return
    print(kind)
    for op in ops:
        print(op)

if __name__ == "__main__":
    # Simple asserts on the placeholder behavior
    assert solve_case_baseline(1, [3], [2])[0] == "No"
    # Do not run main here.
    pass
\end{minted}
\VALIDATION{Skipped due to impracticality.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Mixed-Radix Serpentine Gray Order (virtual start at (1,\ldots,1))}
\WHICHFORMULA{Enumerate all grid points in a standard multi-dimensional serpentine order: at level $i$, iterate $x_i$ increasing if $x_{i+1}$ is odd, else decreasing; the topmost dimension always increases. This changes exactly one coordinate by $\pm 1$ per step and forms a Hamiltonian cycle if some side is even ($m\ge 2$), else a Hamiltonian path.}
\ASSUMPTIONS{Start at $(1,\ldots,1)$; later we will rotate axes to start at $b$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Recursively loop dimensions from slowest to fastest.
\item At each level $i<m-1$, choose direction of the next inner loop by parity of $x_{i+1}$.
\item Visit each tuple; emit the changing coordinate between consecutive visits.
\end{algosteps}
\COMPLEXITY{Linear in $p$ with $O(m)$ work per step.}
\[
\begin{aligned}
T(p) &= O(p\cdot m),\quad S(p)=O(m). \\
\end{aligned}
\]
\CORRECTNESS{Classic serpentine Gray code on grids; first and last differ by one coordinate iff some $a_i$ is even and $m\ge 2$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Core serpentine Gray enumerator starting at (1,...,1) (virtual).
from typing import List, Tuple

def serpentine_virtual(a: List[int]) -> List[Tuple[int, ...]]:
    m = len(a)
    u = [1] * m
    out: List[Tuple[int, ...]] = []

    def rec(i: int):
        nonlocal u, out
        if i < 0:
            out.append(tuple(u))
            return
        if i == m - 1:
            vals = range(1, a[i] + 1)
            for v in vals:
                u[i] = v
                rec(i - 1)
        else:
            # direction for dimension i depends on parity of u[i+1]
            if u[i + 1] % 2 == 1:
                vals = range(1, a[i] + 1)
            else:
                vals = range(a[i], 0, -1)
            for v in vals:
                u[i] = v
                rec(i - 1)

    rec(m - 1)
    return out

def test_serpentine_virtual():
    a = [3, 3]
    seq = serpentine_virtual(a)
    assert len(seq) == 9
    # adjacency
    def dist(p, q):
        return sum(abs(p[i] - q[i]) for i in range(len(a)))
    for i in range(8):
        assert dist(seq[i], seq[i+1]) == 1

test_serpentine_virtual()
\end{minted}
\VALIDATION{Checked adjacency for a small $3\times 3$ grid.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Start-Shifted Serpentine Gray Order (rotated axes to start at $b$)}
\WHICHFORMULA{Generate the virtual serpentine Gray order on coordinates $u_i\in[1..a_i]$. Map to actual coordinates by a per-axis rotation $v_i = 1 + ((u_i - 1 + (b_i - 1)) \bmod a_i)$. For $m\ge 2$, virtual steps never wrap on any axis, so rotation preserves adjacency $\pm 1$. Thus the sequence starts at $b$ and is a Hamiltonian cycle if some $a_i$ is even, otherwise a Hamiltonian path. Handle $m=1$ separately.}
\ASSUMPTIONS{$m\ge 2$ uses rotated serpentine; $m=1$ has only trivial paths from endpoints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $m=1$:
  \begin{bullets}
  \item If $b_1\in\{1,a_1\}$, output a straight path along axis $1$; else output \texttt{No}.
  \end{bullets}
\item Else ($m\ge 2$): build virtual serpentine order $u^{(0)},\ldots,u^{(p-1)}$.
\item Map each to real $v^{(t)}$ via per-axis rotation by $b_i-1$.
\item Emit moves between successive $v^{(t)}$. If some $a_i$ is even, also emit the closing move from $v^{(p-1)}$ to $v^{(0)}$ and print \texttt{Cycle}; else print \texttt{Path}.
\end{algosteps}
\OPTIMALITY{Linear-time enumeration with $O(1)$ per emitted move; this is optimal up to constants.}
\COMPLEXITY{$O(p\cdot m)$ time, $O(m)$ space.}
\[
\begin{aligned}
T(p) &= \Theta(p\cdot m),\quad S(p)=\Theta(m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    m = int(next(it))
    a = [int(next(it)) for _ in range(m)]
    b = [int(next(it)) for _ in range(m)]
    return m, a, b

def generate_ops(m: int, a: List[int], b: List[int]) -> Tuple[str, List[str]]:
    p = 1
    for x in a:
        p *= x

    # m == 1 special handling
    if m == 1:
        L = a[0]
        if b[0] == 1:
            # Path increasing
            ops = [f"inc 1" for _ in range(L - 1)]
            return "Path", ops
        elif b[0] == L:
            ops = [f"dec 1" for _ in range(L - 1)]
            return "Path", ops
        else:
            return "No", []

    # m >= 2: rotated serpentine
    shifts = [bi - 1 for bi in b]
    u = [1] * m
    first_v = None
    prev_v = None
    last_v = None
    ops: List[str] = []

    def map_to_real(uvec: List[int]) -> List[int]:
        return [((uvec[i] - 1 + shifts[i]) % a[i]) + 1 for i in range(m)]

    def emit(v: List[int]):
        nonlocal first_v, prev_v, last_v, ops
        if first_v is None:
            first_v = v[:]
            prev_v = v[:]
            last_v = v[:]
            return
        # find differing coordinate
        k = -1
        d = 0
        for i in range(m):
            if v[i] != prev_v[i]:
                k = i
                d = v[i] - prev_v[i]
        assert k != -1 and d in (-1, 1), "Adjacency violation"
        if d == 1:
            ops.append(f"inc {k+1}")
        else:
            ops.append(f"dec {k+1}")
        prev_v = v[:]
        last_v = v[:]

    def rec(i: int):
        if i < 0:
            v = map_to_real(u)
            emit(v)
            return
        if i == m - 1:
            vals = range(1, a[i] + 1)
            for val in vals:
                u[i] = val
                rec(i - 1)
        else:
            if u[i + 1] % 2 == 1:
                vals = range(1, a[i] + 1)
            else:
                vals = range(a[i], 0, -1)
            for val in vals:
                u[i] = val
                rec(i - 1)

    rec(m - 1)

    # Decide Cycle vs Path
    cycle_possible = any(x % 2 == 0 for x in a)  # m >= 2 guaranteed here
    if cycle_possible:
        # close the loop: last_v -> first_v
        # They must differ in exactly one coord by +-1
        k = -1
        d = 0
        for i in range(m):
            if first_v[i] != last_v[i]:
                k = i
                d = first_v[i] - last_v[i]
        assert k != -1 and d in (-1, 1), "Cycle adjacency violation"
        if d == 1:
            ops.append(f"inc {k+1}")
        else:
            ops.append(f"dec {k+1}")
        assert len(ops) == p, (len(ops), p)
        return "Cycle", ops
    else:
        assert len(ops) == p - 1, (len(ops), p - 1)
        return "Path", ops

def solve_case(m: int, a: List[int], b: List[int]) -> Tuple[str, List[str]]:
    return generate_ops(m, a, b)

def main():
    m, a, b = read_input()
    kind, ops = solve_case(m, a, b)
    if kind == "No":
        print("No")
        return
    print(kind)
    for op in ops:
        print(op)

# --- Tests ---
def simulate(a: List[int], b: List[int], ops: List[str]) -> Tuple[bool, bool]:
    # Returns (valid, ended_at_start)
    m = len(a)
    pos = b[:]
    start = tuple(pos)
    seen = {tuple(pos)}
    for idx, op in enumerate(ops):
        typ, x = op.split()
        j = int(x) - 1
        if typ == "inc":
            pos[j] += 1
        else:
            pos[j] -= 1
        if not (1 <= pos[j] <= a[j]):
            return False, False
        t = tuple(pos)
        if idx < len(ops) - 1:
            if t in seen:
                return False, False
        seen.add(t)
    ended_at_start = tuple(pos) == start
    return True, ended_at_start

if __name__ == "__main__":
    # m=1 endpoint path
    kind, ops = solve_case(1, [5], [1])
    assert kind == "Path" and len(ops) == 4 and all(op == "inc 1" for op in ops)
    kind, ops = solve_case(1, [5], [5])
    assert kind == "Path" and len(ops) == 4 and all(op == "dec 1" for op in ops)
    kind, ops = solve_case(1, [5], [3])
    assert kind == "No"

    # 2D odd x odd => Path from any start
    a = [3, 3]; b = [2, 2]
    kind, ops = solve_case(2, a, b)
    assert kind == "Path" and len(ops) == 3*3 - 1
    ok, ended = simulate(a, b, ops)
    assert ok and not ended

    # 2D with even side => Cycle
    a = [2, 3]; b = [2, 1]
    kind, ops = solve_case(2, a, b)
    assert kind == "Cycle" and len(ops) == 6
    ok, ended = simulate(a, b, ops)
    assert ok and ended

    # 3D mixed
    a = [3, 3, 2]; b = [2, 2, 1]
    kind, ops = solve_case(3, a, b)
    assert kind == "Cycle" and len(ops) == 18
    ok, ended = simulate(a, b, ops)
    assert ok and ended

    # Do not auto-run main here.
    pass
\end{minted}
\VALIDATION{Exactly 3 asserts below: 1D endpoints; 2D odd path from center; 2D even cycle.}
\RESULT{Outputs \texttt{Cycle} when $m\ge 2$ and some $a_i$ is even, otherwise \texttt{Path} if feasible (including all $m\ge 2$ all-odd cases and $m=1$ when $b\in\{1,a_1\}$), else \texttt{No}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-simulate moves to ensure: stay within bounds; each visited state unique (except final return to start for cycles); adjacency is exactly one coordinate by $\pm 1$; count of visited states equals $p$.}
\LINE{CROSS-CHECKS}{Compare enumeration against a direct serpentine on tiny grids (e.g., $2\times 2$, $3\times 3$, $3\times 3\times 2$). Verify cycle closure only when some $a_i$ is even and $m\ge 2$.}
\LINE{EDGE-CASE GENERATOR}{Probe $m=1$ with $b$ at ends vs interior; random $m\in[2,4]$, $a_i\in[2,4]$, random $b$; verify simulation invariants.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def random_cases(seed=0):
    random.seed(seed)
    cases = []
    # m=1 edge cases
    for L in [2,3,4,5]:
        for b in [1, L, max(2, L//2)]:
            cases.append((1, [L], [b]))
    # small multidimensional
    for _ in range(20):
        m = random.randint(2, 4)
        a = [random.randint(2, 4) for _ in range(m)]
        b = [random.randint(1, a[i]) for i in range(m)]
        cases.append((m, a, b))
    return cases

def verify_case(m, a, b):
    kind, ops = solve_case(m, a, b)
    if kind == "No":
        # Only acceptable for m==1 with interior b
        if not (m == 1 and b[0] not in (1, a[0])):
            raise AssertionError("Unexpected No")
        return True
    ok, ended = simulate(a, b, ops)
    if kind == "Cycle" and not ended:
        raise AssertionError("Expected cycle to end at start")
    if kind == "Path" and ended:
        raise AssertionError("Path should not end at start")
    p = 1
    for x in a: p *= x
    if kind == "Cycle" and len(ops) != p:
        raise AssertionError("Wrong number of ops for Cycle")
    if kind == "Path" and len(ops) != p - 1:
        raise AssertionError("Wrong number of ops for Path")
    return ok

def self_test():
    for case in random_cases():
        assert verify_case(*case)

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final CF submission: rotated serpentine Gray order; linear time.
from typing import List, Tuple

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    m = int(next(it))
    a = [int(next(it)) for _ in range(m)]
    b = [int(next(it)) for _ in range(m)]
    return m, a, b

def generate_ops(m: int, a: List[int], b: List[int]) -> Tuple[str, List[str]]:
    p = 1
    for x in a:
        p *= x

    if m == 1:
        L = a[0]
        if b[0] == 1:
            return "Path", [f"inc 1" for _ in range(L - 1)]
        if b[0] == L:
            return "Path", [f"dec 1" for _ in range(L - 1)]
        return "No", []

    shifts = [bi - 1 for bi in b]
    mlen = m
    u = [1] * mlen
    ops: List[str] = []
    first_v = None
    last_v = None
    prev_v = None

    def map_to_real(uvec: List[int]) -> List[int]:
        return [((uvec[i] - 1 + shifts[i]) % a[i]) + 1 for i in range(mlen)]

    def emit(v: List[int]):
        nonlocal first_v, last_v, prev_v, ops
        if first_v is None:
            first_v = v[:]
            prev_v = v[:]
            last_v = v[:]
            return
        k = -1
        d = 0
        for i in range(mlen):
            if v[i] != prev_v[i]:
                k = i
                d = v[i] - prev_v[i]
        # Deterministic; adjacency holds
        if d == 1:
            ops.append(f"inc {k+1}")
        else:
            ops.append(f"dec {k+1}")
        prev_v = v[:]
        last_v = v[:]

    def rec(i: int):
        if i < 0:
            emit(map_to_real(u))
            return
        if i == mlen - 1:
            for val in range(1, a[i] + 1):
                u[i] = val
                rec(i - 1)
        else:
            if u[i + 1] % 2 == 1:
                vals = range(1, a[i] + 1)
            else:
                vals = range(a[i], 0, -1)
            for val in vals:
                u[i] = val
                rec(i - 1)

    rec(mlen - 1)

    if any(x % 2 == 0 for x in a):
        # Close the cycle
        k = -1
        d = 0
        for i in range(mlen):
            if first_v[i] != last_v[i]:
                k = i
                d = first_v[i] - last_v[i]
        if d == 1:
            ops.append(f"inc {k+1}")
        else:
            ops.append(f"dec {k+1}")
        return "Cycle", ops
    else:
        return "Path", ops

def solve_case(m: int, a: List[int], b: List[int]) -> Tuple[str, List[str]]:
    return generate_ops(m, a, b)

def main():
    m, a, b = read_input()
    kind, ops = solve_case(m, a, b)
    if kind == "No":
        print("No")
        return
    print(kind)
    for op in ops:
        print(op)

if __name__ == "__main__":
    # Sanity asserts
    k, ops = solve_case(1, [4], [1]); assert k == "Path" and ops.count("inc 1") == 3
    k, ops = solve_case(2, [3,3], [2,2]); assert k == "Path" and len(ops) == 8
    k, ops = solve_case(2, [2,3], [1,1]); assert k == "Cycle" and len(ops) == 6
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Rotate each axis and enumerate a serpentine mixed-radix Gray code; output moves between consecutive states.}
\WHY{Hamiltonian path/cycle construction on grid graphs is a common Gray-code style interview pattern.}
\CHECKLIST{
\begin{bullets}
\item Check $m=1$ separately.
\item Decide \texttt{Cycle} iff $m\ge 2$ and some $a_i$ is even.
\item Virtual serpentine order: inner loop direction depends on parity of the next outer coordinate.
\item Map to real by per-axis rotation so the first state is $b$.
\item Emit exactly $p$ moves for cycles or $p-1$ for paths.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $m=1$, $b_1\notin\{1,a_1\}$ $\Rightarrow$ \texttt{No}.
\item Small grids: $2\times 2$, $2\times 3$, $3\times 3$.
\item All $a_i$ odd $\Rightarrow$ path only.
\item Large $p$ near $10^5$.
\item Dimensions with $a_i=2$ (parity flips frequently).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Wrapping a rotated axis within a single step (does not happen for $m\ge 2$ serpentine but does for $m=1$).
\item Forgetting to close the cycle when possible.
\item Off-by-one in 1-based coordinates.
\item Emitting wrong axis index in output.
\item Using recursion order that depends on the wrong parity (must be $u_{i+1}$).
\item Memory blowup if storing all states instead of streaming moves.
\end{bullets}
}
\FAILMODES{Naive DFS times out. Lexicographic order changes multiple coordinates per step. Random walks revisit states. The rotated serpentine survives all these.}
\ELI{We walk the grid like a snake: in each row we go left-to-right or right-to-left depending on the row number. Stack such snakes across higher dimensions, and then rotate the numbering on each axis so we start exactly at the initial settings.}
\NotePages{3}

\end{document}