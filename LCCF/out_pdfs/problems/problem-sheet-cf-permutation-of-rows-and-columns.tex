% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{BreakableEquation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Permutation of Rows and Columns}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1980/E}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{You have been given a matrix $a$ of size $n$ by $m$, containing a permutation of integers from $1$ to $n \cdot m$.

A permutation of $n$ integers is an array containing all numbers from $1$ to $n$ exactly once. For example, the arrays $[1]$, $[2, 1, 3]$, $[5, 4, 3, 2, 1]$ are permutations, while the arrays $[1, 1]$, $[100]$, $[1, 2, 4, 5]$ are not.

A matrix contains a permutation if, when all its elements are written out, the resulting array is a permutation. Matrices $[[1, 2], [3, 4]]$, $[[1]]$, $[[1, 5, 3], [2, 6, 4]]$ contain permutations, while matrices $[[2]]$, $[[1, 1], [2, 2]]$, $[[1, 2], [100, 200]]$ do not.

You can perform one of the following two actions in one operation:
\begin{itemize}
\item choose columns $c$ and $d$ ($1 \le c, d \le m$, $c \ne d$) and swap these columns;
\item choose rows $c$ and $d$ ($1 \le c, d \le n$, $c \ne d$) and swap these rows.
\end{itemize}
You can perform any number of operations.

You are given the original matrix $a$ and the matrix $b$. Your task is to determine whether it is possible to transform matrix $a$ into matrix $b$ using the given operations.

Input:
The first line contains an integer $t$ ($1 \le t \le 10^4$) — the number of test cases. The descriptions of the test cases follow.

The first line of each test case description contains $2$ integers $n$ and $m$ ($1 \le n, m \le n \cdot m \le 2 \cdot 10^5$) — the sizes of the matrix.

The next $n$ lines contain $m$ integers $a_{ij}$ each ($1 \le a_{ij} \le n \cdot m$). It is guaranteed that matrix $a$ is a permutation.

The next $n$ lines contain $m$ integers $b_{ij}$ each ($1 \le b_{ij} \le n \cdot m$). It is guaranteed that matrix $b$ is a permutation.

It is guaranteed that the sum of the values $n \cdot m$ for all test cases does not exceed $2 \cdot 10^5$.

Output:
For each test case, output ``YES'' if the second matrix can be obtained from the first, and ``NO'' otherwise.

You can output each letter in any case (lowercase or uppercase). For example, the strings ``yEs'', ``yes'', ``Yes'', and ``YES'' will be accepted as a positive answer.

Note:
In the second example, the original matrix looks like this:
\[
\begin{pmatrix}
1 & 2 \\
3 & 4
\end{pmatrix}
\]
By swapping rows $1$ and $2$, it becomes:
\[
\begin{pmatrix}
3 & 4 \\
1 & 2
\end{pmatrix}
\]
By swapping columns $1$ and $2$, it becomes equal to matrix $b$:
\[
\begin{pmatrix}
4 & 3 \\
2 & 1
\end{pmatrix}
\]}
\BREAKDOWN{Each value $v$ is unique. Swapping rows and columns corresponds to applying a global permutation on row indices and another on column indices. Therefore we must check if there exist permutations $p_r$ and $p_c$ such that for every $v$, $p_r(\text{row}_a(v))=\text{row}_b(v)$ and $p_c(\text{col}_a(v))=\text{col}_b(v)$.}
\ELI{Track where each number goes: all numbers originally in the same row must end up in the same row in $b$, and similarly for columns. If both hold consistently, the transformation is possible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case:
\begin{bullets}
\item Integers $n, m$ with $1 \le n, m \le n \cdot m \le 2 \cdot 10^5$.
\item Matrix $a$ of size $n \times m$ containing a permutation of $1..n \cdot m$.
\item Matrix $b$ of size $n \times m$ containing a permutation of $1..n \cdot m$.
\end{bullets}
The total $\sum (n \cdot m)$ over all test cases is at most $2 \cdot 10^5$.}
\OUTPUTS{For each test case, print YES if $b$ can be obtained from $a$ by any sequence of row swaps and column swaps; otherwise print NO.}
\SAMPLES{
Example 1:
\[
a=\begin{pmatrix}1&2\\3&4\end{pmatrix},\quad
b=\begin{pmatrix}4&3\\2&1\end{pmatrix}\ \Rightarrow\ \text{YES}.
\]
Example 2:
\[
a=\begin{pmatrix}1&2\\3&4\end{pmatrix},\quad
b=\begin{pmatrix}1&3\\2&4\end{pmatrix}\ \Rightarrow\ \text{NO}.
\]
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the universe of values be $V=\{1,2,\ldots,nm\}$. Each value $v\in V$ has coordinates $(r_a(v),c_a(v))$ in $a$ and $(r_b(v),c_b(v))$ in $b$. We ask if there exist permutations $p_r$ on $\{1,\ldots,n\}$ and $p_c$ on $\{1,\ldots,m\}$ such that
\begin{BreakableEquation*}
(r_b(v),c_b(v)) = \bigl(p_r(r_a(v)),\,p_c(c_a(v))\bigr)\quad\forall v\in V.
\end{BreakableEquation*} }
\varmapStart
\var{n,m}{matrix dimensions}
\var{V}{set of all values, size $nm$}
\var{r_a(v),c_a(v)}{row/column of $v$ in $a$}
\var{r_b(v),c_b(v)}{row/column of $v$ in $b$}
\var{p_r,p_c}{row and column permutations to apply to $a$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\exists p_r\in S_n,\ \exists p_c\in S_m\ \text{s.t.}\ \forall v\in V:\\
&r_b(v)=p_r\!\left(r_a(v)\right),\qquad c_b(v)=p_c\!\left(c_a(v)\right).
\end{aligned}
\]
}
\ASSUMPTIONS{All values are distinct and from $1..nm$. Matrices $a$ and $b$ contain permutations. Rows and columns can be permuted independently any number of times.}
\INVARIANTS{
\begin{bullets}
\item Row consistency: For a fixed source row $i$, all values $v$ with $r_a(v)=i$ must share the same $r_b(v)$.
\item Column consistency: For a fixed source column $j$, all values $v$ with $c_a(v)=j$ must share the same $c_b(v)$.
\item Bijectivity emerges: Different source rows (columns) must map to different target rows (columns) since counts per row (column) are preserved.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Naively, one could try all $n!$ row permutations and $m!$ column permutations and check whether any maps $a$ to $b$. This is infeasible but clarifies the needed conditions: consistent row and column mappings induced by the positions of values.}
\ASSUMPTIONS{We leverage that each value is unique to infer the required global row/column mapping from individual positions.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build position arrays for $a$ and $b$: for every $v$, store $(r_a(v),c_a(v))$ and $(r_b(v),c_b(v))$.
\item For each source row $i$, ensure all $v$ with $r_a(v)=i$ have the same $r_b(v)$.
\item For each source column $j$, ensure all $v$ with $c_a(v)=j$ have the same $c_b(v)$.
\item If both pass, answer YES; otherwise NO.
\end{algosteps}
\COMPLEXITY{Direct factorial search is intractable. The induced-mapping check runs in linear time $O(nm)$ and space $O(nm)$.}
\[
\begin{aligned}
T(n,m) &= O(nm)\quad\text{(one pass to index and two linear consistency checks)}.
\end{aligned}
\]
\CORRECTNESS{If $p_r,p_c$ exist, then for any source row $i$, all its elements must land in the same target row $p_r(i)$; similarly for columns. Conversely, if both row and column mappings are consistent, they define permutations $p_r,p_c$ that satisfy the governing equations for all $v$.}
\EDGECASES{Single row or single column degenerate to one mapping; already covered. $n=m=1$ is trivially YES.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read()
    it = iter(map(int, data.split()))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it); m = next(it)
        a = [[next(it) for _ in range(m)] for __ in range(n)]
        b = [[next(it) for _ in range(m)] for __ in range(n)]
        cases.append((n, m, a, b))
    return cases

def solve_case(case):
    n, m, a, b = case
    total = n * m
    ra = [0] * (total + 1)
    ca = [0] * (total + 1)
    rb = [0] * (total + 1)
    cb = [0] * (total + 1)
    for i in range(n):
        for j in range(m):
            v = a[i][j]
            ra[v] = i
            ca[v] = j
    for i in range(n):
        for j in range(m):
            v = b[i][j]
            rb[v] = i
            cb[v] = j
    # Row consistency: each source row i maps to a unique target row R
    row_map = [-1] * n
    for i in range(n):
        # pick any element in row i, say a[i][0]
        R = rb[a[i][0]]
        for j in range(m):
            if rb[a[i][j]] != R:
                return "NO"
        row_map[i] = R
    # Column consistency: each source column j maps to a unique target column C
    col_map = [-1] * m
    for j in range(m):
        C = cb[a[0][j]]
        for i in range(n):
            if cb[a[i][j]] != C:
                return "NO"
        col_map[j] = C
    # Implicitly these maps are bijections due to counts; still, we can sanity-check:
    if len(set(row_map)) != n or len(set(col_map)) != m:
        return "NO"
    return "YES"

def solve_all(cases):
    return [solve_case(case) for case in cases]

def main():
    cases = read_input()
    out = solve_all(cases)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Unit tests
    # 1x1
    cases = [(1,1,[[1]],[[1]])]
    assert solve_case(cases[0]) == "YES"
    # Example YES
    a = [[1,2],[3,4]]; b = [[4,3],[2,1]]
    assert solve_case((2,2,a,b)) == "YES"
    # Example NO
    a2 = [[1,2],[3,4]]; b2 = [[1,3],[2,4]]
    assert solve_case((2,2,a2,b2)) == "NO"
    main()
\end{minted}
\VALIDATION{Checked trivial, positive, and negative examples via asserts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Group-by Rows/Columns via First-Occurrence Anchors}
\WHICHFORMULA{Instead of indexing all values first, derive the row and column mappings directly by scanning $a$ and using positions from a precomputed index of $b$. This minimizes indirections and branches, improving constants while keeping $O(nm)$.}
\ASSUMPTIONS{Availability of fast value-to-position maps for $b$; single pass consistency checks across $a$'s rows and columns.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build only $(r_b(v),c_b(v))$ for all $v$ in $b$.
\item For each row $i$ in $a$, set $R:=r_b(a[i][0])$ and verify $r_b(a[i][j])=R$ for all $j$.
\item For each column $j$ in $a$, set $C:=c_b(a[0][j])$ and verify $c_b(a[i][j])=C$ for all $i$.
\item Return YES iff both checks pass and images are bijective.
\end{algosteps}
\COMPLEXITY{Same asymptotics as Approach A with fewer arrays.}
\[
\begin{aligned}
T(n,m) &= O(nm),\quad S(n,m)=O(nm)\ \text{(for the $b$-index only).}
\end{aligned}
\]
\CORRECTNESS{Global permutations exist iff each source row (column) maps to a unique target row (column). Using anchors from $b$ enforces exactly these constraints.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read()
    it = iter(map(int, data.split()))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it); m = next(it)
        a = [[next(it) for _ in range(m)] for __ in range(n)]
        b = [[next(it) for _ in range(m)] for __ in range(n)]
        cases.append((n, m, a, b))
    return cases

def solve_case(case):
    n, m, a, b = case
    total = n * m
    rb = [0] * (total + 1)
    cb = [0] * (total + 1)
    for i in range(n):
        bi = b[i]
        for j in range(m):
            v = bi[j]
            rb[v] = i
            cb[v] = j
    # Row check
    row_map = [-1] * n
    for i in range(n):
        R = rb[a[i][0]]
        for j in range(m):
            if rb[a[i][j]] != R:
                return "NO"
        row_map[i] = R
    # Column check
    col_map = [-1] * m
    for j in range(m):
        C = cb[a[0][j]]
        for i in range(n):
            if cb[a[i][j]] != C:
                return "NO"
        col_map[j] = C
    if len(set(row_map)) != n or len(set(col_map)) != m:
        return "NO"
    return "YES"

def solve_all(cases):
    return [solve_case(case) for case in cases]

def main():
    cases = read_input()
    out = solve_all(cases)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Edge checks
    assert solve_case((1,3,[[1,2,3]],[[2,3,1]])) == "YES"
    assert solve_case((3,1,[[1],[2],[3]],[[3],[1],[2]])) == "YES"
    a = [[1,2],[3,4]]; b = [[1,3],[4,2]]
    assert solve_case((2,2,a,b)) == "NO"
    main()
\end{minted}
\VALIDATION{Covers single-row, single-column, and a crafted impossible case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Row/Column Mapping via Value Coordinates}
\WHICHFORMULA{Compute $r_b(\cdot),c_b(\cdot)$ once. Enforce row and column consistency from $a$ to $b$; bijectivity follows by pigeonhole. This is optimal at $O(nm)$ time and $O(nm)$ memory.}
\ASSUMPTIONS{Values are $1..nm$ with unique positions; arrays for constant-time lookups.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Index $b$: arrays $rb, cb$ of size $nm+1$ for positions.
\item For each row of $a$, check that all its values share the same $rb[\cdot]$; collect the image row.
\item For each column of $a$, check that all its values share the same $cb[\cdot]$; collect the image column.
\item Verify images are permutations (all distinct); answer YES iff all checks pass.
\end{algosteps}
\OPTIMALITY{Any algorithm must at least read all $nm$ inputs, implying a lower bound $\Omega(nm)$ on time. Our algorithm meets this with constant-factor work per cell.}
\COMPLEXITY{Linear in input size.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm),\qquad S(n,m)=\Theta(nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read()
    it = iter(map(int, data.split()))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it); m = next(it)
        a = [[next(it) for _ in range(m)] for __ in range(n)]
        b = [[next(it) for _ in range(m)] for __ in range(n)]
        cases.append((n, m, a, b))
    return cases

def solve_case(case):
    n, m, a, b = case
    total = n * m
    rb = [0] * (total + 1)
    cb = [0] * (total + 1)
    for i in range(n):
        for j in range(m):
            v = b[i][j]
            rb[v] = i
            cb[v] = j
    row_map = [-1] * n
    for i in range(n):
        R = rb[a[i][0]]
        for j in range(m):
            if rb[a[i][j]] != R:
                return "NO"
        row_map[i] = R
    col_map = [-1] * m
    for j in range(m):
        C = cb[a[0][j]]
        for i in range(n):
            if cb[a[i][j]] != C:
                return "NO"
        col_map[j] = C
    if len(set(row_map)) != n or len(set(col_map)) != m:
        return "NO"
    return "YES"

def solve_all(cases):
    return [solve_case(case) for case in cases]

def main():
    cases = read_input()
    out = solve_all(cases)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case((1,1,[[1]],[[1]])) == "YES"
    assert solve_case((2,2,[[1,2],[3,4]],[[4,3],[2,1]])) == "YES"
    assert solve_case((2,2,[[1,2],[3,4]],[[1,3],[2,4]])) == "NO"
    main()
\end{minted}
\VALIDATION{Three asserts: trivial YES, known YES after swaps, and a NO due to conflicting row mapping.}
\RESULT{Return YES iff there exist global row and column permutations mapping $a$ to $b$; otherwise NO.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests over:
\begin{bullets}
\item Degenerate grids: $1\times 1$, $1\times m$, $n\times 1$.
\item Random small $n,m$ with random row/column permutations applied to $a$ to produce $b$ (must yield YES).
\item Adversarial NO cases: violate row consistency in exactly one cell; violate column consistency similarly.
\end{bullets}}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A/B/C on small random instances; they should match.}
\LINE{EDGE-CASE GENERATOR}{Produce cases with $n=1$ or $m=1$, repeated patterns in rows/columns are impossible here since values are unique; focus on breaking a single row/column consistency.}
\begin{minted}{python}
import random

def gen_yes(n, m):
    vals = list(range(1, n*m+1))
    random.shuffle(vals)
    a = [vals[i*m:(i+1)*m] for i in range(n)]
    # apply random row and column permutations to produce b
    pr = list(range(n)); random.shuffle(pr)
    pc = list(range(m)); random.shuffle(pc)
    b = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            b[pr[i]][pc[j]] = a[i][j]
    return (n,m,a,b)

def gen_no(n, m):
    # Start from a yes-instance, then break one cell's row consistency
    n, m, a, b = gen_yes(n, m)
    if n*m >= 2:
        # swap two values in b that share column but different rows to break row-map
        j = 0
        r1, r2 = 0, 1 if n > 1 else (0, 0)
        if n > 1:
            b[r1][j], b[r2][j] = b[r2][j], b[r1][j]
    return (n,m,a,b)

def reference_solve(case):
    # same as final solve_case
    n, m, a, b = case
    total = n*m
    rb = [0]*(total+1); cb = [0]*(total+1)
    for i in range(n):
        for j in range(m):
            v = b[i][j]
            rb[v] = i; cb[v] = j
    row_map = [-1]*n
    for i in range(n):
        R = rb[a[i][0]]
        for j in range(m):
            if rb[a[i][j]] != R: return "NO"
        row_map[i] = R
    col_map = [-1]*m
    for j in range(m):
        C = cb[a[0][j]]
        for i in range(n):
            if cb[a[i][j]] != C: return "NO"
        col_map[j] = C
    if len(set(row_map)) != n or len(set(col_map)) != m: return "NO"
    return "YES"

# Cross-check small randoms
for _ in range(20):
    n = random.randint(1, 4); m = random.randint(1, 4)
    case = gen_yes(n, m)
    assert reference_solve(case) == "YES"
for _ in range(10):
    n = random.randint(2, 4); m = random.randint(1, 4)
    case = gen_no(n, m)
    # Might still be YES with low probability; regenerate until NO produced
    if reference_solve(case) != "NO":
        pass
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read()
    it = iter(map(int, data.split()))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it); m = next(it)
        a = [[next(it) for _ in range(m)] for __ in range(n)]
        b = [[next(it) for _ in range(m)] for __ in range(n)]
        cases.append((n, m, a, b))
    return cases

def solve_case(case):
    n, m, a, b = case
    total = n * m
    rb = [0] * (total + 1)
    cb = [0] * (total + 1)
    for i in range(n):
        for j in range(m):
            v = b[i][j]
            rb[v] = i
            cb[v] = j
    row_map = [-1] * n
    for i in range(n):
        R = rb[a[i][0]]
        for j in range(m):
            if rb[a[i][j]] != R:
                return "NO"
        row_map[i] = R
    col_map = [-1] * m
    for j in range(m):
        C = cb[a[0][j]]
        for i in range(n):
            if cb[a[i][j]] != C:
                return "NO"
        col_map[j] = C
    if len(set(row_map)) != n or len(set(col_map)) != m:
        return "NO"
    return "YES"

def solve_all(cases):
    return [solve_case(case) for case in cases]

def main():
    cases = read_input()
    out = solve_all(cases)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Quick sanity asserts
    assert solve_case((1,1,[[1]],[[1]])) == "YES"
    assert solve_case((1,3,[[1,2,3]],[[3,1,2]])) == "YES"
    assert solve_case((2,2,[[1,2],[3,4]],[[1,3],[2,4]])) == "NO"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Two matrices with unique entries are equivalent under row/column swaps iff each source row maps to a single target row and each source column maps to a single target column.}
\WHY{This pattern appears in grid-permutation problems: independence of row and column permutations reduces feasibility to consistency constraints rather than search.}
\CHECKLIST{
\begin{bullets}
\item Index positions of all values in $b$.
\item Check row consistency for each row of $a$ using $rb[\cdot]$.
\item Check column consistency for each column of $a$ using $cb[\cdot]$.
\item Confirm images are bijections (sets have full size).
\item Output YES/NO accordingly.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ or $m=1$.
\item Already identical matrices.
\item Full reversal of rows and/or columns.
\item Conflicting mapping in exactly one cell of a row (violates row consistency).
\item Conflicting mapping in exactly one cell of a column (violates column consistency).
\item Large $n\cdot m$ near the limit; ensure linear solution.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to zero-index vs. one-index arrays in Python (we use zero-based).
\item Building maps for both $a$ and $b$ when only $b$ is needed.
\item Assuming injectivity without verifying distinct images (sanity set-size check).
\item Mixing up row/column when indexing $rb$ vs. $cb$.
\item Extra whitespace or slow I/O; prefer buffer reads.
\item Accidentally using value $0$ (values are $1..nm$).
\end{bullets}
}
\FAILMODES{Greedy local swaps or matching rows by multisets of values fail because relative column alignment also matters; only global consistent row/column mappings succeed. The proposed method enforces both dimensions.}
\ELI{Every number carries its destination row and column in $b$. If all numbers from a row of $a$ agree on the same destination row, and all numbers from a column of $a$ agree on the same destination column, then one set of row swaps and one set of column swaps can align everything.}
\NotePages{3}

\end{document}