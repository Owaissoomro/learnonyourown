% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Kilani and the Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1105/D}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{Kilani is playing a game with his friends. This game can be represented as a grid of size $n \times m$, where each cell is either empty or blocked, and every player has one or more castles in some cells (there are no two castles in one cell).

The game is played in rounds. In each round players expand turn by turn: firstly, the first player expands, then the second player expands and so on. The expansion happens as follows: for each castle the player owns now, he tries to expand into the empty cells nearby. The player $i$ can expand from a cell with his castle to the empty cell if it's possible to reach it in at most $s_i$ (where $s_i$ is the player's expansion speed) moves to the left, up, right or down without going through blocked cells or cells occupied by some other player's castle. The player examines the set of cells he can expand to and builds a castle in each of them at once. The turn is passed to the next player after that.

The game ends when no player can make a move. You are given the game field and the speed of expansion for each player. Kilani wants to know for each player how many cells he will control (have a castle there) after the game ends.

Input: The first line contains three integers $n$, $m$ and $p$ ($1 \le n, m \le 1000$, $1 \le p \le 9$) — the size of the grid and the number of players.

The second line contains $p$ integers $s_i$ ($1 \le s_i \le 10^9$) — the speed of the expansion for every player.

The following $n$ lines describe the game grid. Each of them consists of $m$ symbols, where `.' denotes an empty cell, `\#' denotes a blocked cell and digit $x$ ($1 \le x \le p$) denotes the castle owned by player $x$.

It is guaranteed that each player has at least one castle on the grid.

Output: Print $p$ integers — the number of cells controlled by each player after the game ends.

Note: The picture below shows the game before it started, the game after the first round and the game after the second round in the first example.

In the second example, the first player is blocked so he will not capture new cells for the entire game. All other players will expand up during the first two rounds and in the third round only the second player will move to the left.}
\BREAKDOWN{Simulate round-based expansion with per-player speed limits. Maintain frontiers for each player and expand breadth-first up to $s_i$ layers per round, respecting walls and already captured cells, until no player can move.}
\ELI{Do multi-source BFS for each player, but only $s_i$ BFS layers per turn, rotating through players until the board stops changing.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m, p$; array $s_1,\ldots,s_p$ with $1 \le s_i \le 10^9$; grid of $n$ strings of length $m$ over the alphabet `.', `\#', and digits `1'..`$p$'.}
\OUTPUTS{Print $p$ integers separated by spaces: the number of cells owned by players $1,2,\ldots,p$ after the process stabilizes.}
\SAMPLES{Example 1:
\[
\begin{aligned}
\text{Input} &= \texttt{1 5 2}\\
             &\texttt{1 1}\\
             &\texttt{1...2}\\
\text{Output} &= \texttt{3 2}
\end{aligned}
\]
Example 2:
\[
\begin{aligned}
\text{Input} &= \texttt{3 5 3}\\
             &\texttt{3 1 1}\\
             &\texttt{1.\#..}\\
             &\texttt{..2..}\\
             &\texttt{...\#3}\\
\text{Output} &= \texttt{7 3 3}
\end{aligned}
\]}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be the grid graph on $n \times m$ cells with edges between orthogonally adjacent cells that are not blocked. Each player $i\in\{1,\ldots,p\}$ has initial occupied set $A_i^{(0)}\subseteq V$; occupied sets are disjoint. In round $t=1,2,\ldots$, players act in order $1,\ldots,p$. When player $i$ acts in round $t$, they expand from all cells in their current frontier by at most $s_i$ BFS layers over $G$ restricted to unoccupied cells. All newly reached cells become permanently assigned to player $i$. The process ends when a whole round passes with no acquisitions.}
\varmapStart
\var{n,m}{grid dimensions}
\var{p}{number of players}
\var{s_i}{per-turn expansion depth for player $i$}
\var{A_i^{(t)}}{cells owned by player $i$ after round $t$ completes}
\var{F_i^{(t)}}{frontier of player $i$ when their turn in round $t$ begins}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let }U^{(t,i)} = V \setminus \bigcup_{j=1}^{p} A_j^{(t,i)} \text{ be unowned cells just before player $i$ acts in round } t.\\
&\text{Define } R_i^{(t)} = \{\, v \in U^{(t,i)} : \operatorname{dist}_{G[U^{(t,i)}]}(F_i^{(t)}, v) \le s_i \,\}.\\
&A_i^{(t,i)} \gets A_i^{(t,i)} \cup R_i^{(t)},\quad F_i^{(t+1)} \gets \text{outer boundary of }A_i^{(t,i)}.\\
&\text{Ownership is permanent and exclusive, so the }A_i\text{ form a partition of non-wall cells at termination.}
\end{aligned}
\]
}
\ASSUMPTIONS{Grid indices $0$-based for implementation; walls never become traversable; initial castles are non-empty for each player and pairwise disjoint.}
\INVARIANTS{
\begin{bullets}
\item No cell changes owner once assigned.
\item Frontiers only move into currently unowned cells.
\item Total number of owned cells is non-decreasing and bounded by $nm$, so the process terminates.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate rounds. For each player in order, perform a BFS limited to $s_i$ layers starting from their current frontier positions.}
\ASSUMPTIONS{Maintain one FIFO queue per player storing current frontier cells. Expand exactly $s_i$ BFS layers per turn unless the player's frontier is exhausted earlier.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse input; initialize per-player queues with all initial castles.
\item Repeat rounds: for $i=1$ to $p$, perform $s_i$ BFS layers from player $i$'s queue; when you claim a `.' cell, mark it with digit $i$ and push into the same queue.
\item Stop when a full round passes with no claims; print counts.
\end{algosteps}
\COMPLEXITY{Each cell is claimed at most once and each edge is examined at most a constant number of times across all players.}
\[
\begin{aligned}
T(n,m,p) &\in O(nm) \quad \text{(each cell enqueued at most once)}\\
S(n,m,p) &\in O(nm) \quad \text{(grid + queues)}
\end{aligned}
\]
\CORRECTNESS{Layered BFS per player ensures that within a turn, the maximum Manhattan distance of new claims from any existing castle is at most $s_i$. Round order resolves simultaneous reach in favor of earlier players, matching the statement. Exclusivity by marking prevents conflicts later.}
\EDGECASES{Large $s_i$ (up to $10^9$) are naturally handled since expansion halts when the queue empties; walls `\#' block movement; players may be fully enclosed and thus never move.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
from typing import List, Tuple

def read_input(text: str = None) -> Tuple[int, int, int, List[int], List[str]]:
    if text is None:
        import sys
        text = sys.stdin.read()
    text = text.strip()
    if not text:
        return 0, 0, 0, [], []
    tok = text.split()
    it = iter(tok)
    n = int(next(it)); m = int(next(it)); p = int(next(it))
    s = [int(next(it)) for _ in range(p)]
    grid = [next(it) for _ in range(n)]
    return n, m, p, s, grid

def solve_case(n: int, m: int, p: int, s: List[int], grid: List[str]) -> List[int]:
    if n == 0:
        return []
    g = [list(row) for row in grid]
    queues = [deque() for _ in range(p)]
    cnt = [0] * p
    for r in range(n):
        for c in range(m):
            ch = g[r][c]
            if ch.isdigit():
                owner = int(ch) - 1
                queues[owner].append((r, c))
                cnt[owner] += 1
    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    while True:
        progressed = False
        for i in range(p):
            step_limit = s[i]
            if not queues[i]:
                continue
            for _step in range(step_limit):
                qsz = len(queues[i])
                if qsz == 0:
                    break
                for _ in range(qsz):
                    r, c = queues[i].popleft()
                    for dr, dc in dirs:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < n and 0 <= nc < m and g[nr][nc] == '.':
                            g[nr][nc] = str(i + 1)
                            cnt[i] += 1
                            queues[i].append((nr, nc))
                            progressed = True
        if not progressed:
            break
    return cnt

def solve_all() -> None:
    n, m, p, s, grid = read_input()
    if n == 0:
        return
    ans = solve_case(n, m, p, s, grid)
    out = " ".join(map(str, ans))
    import sys
    sys.stdout.write(out)

def main():
    # If no input provided, do nothing (useful for local test runs).
    n, m, p, s, grid = read_input()
    if n == 0:
        return
    # Re-run with actual input content
    text = None
    solve_all()

if __name__ == "__main__":
    # Tiny self-checks (no stdout pollution)
    n, m, p, s, grid = read_input()
    # Test 1
    t1 = "1 5 2\n1 1\n1...2\n"
    assert solve_case(*read_input(t1)) == [3, 2]
    # Test 2: no movement for player 1 (blocked)
    t2 = "2 3 2\n3 1\n1#.\n###\n"
    assert solve_case(*read_input(t2)) == [1, 0]
    # Test 3: larger s[0] floods quickly
    t3 = "3 3 2\n3 1\n1#.\n#.#\n..2\n"
    res3 = solve_case(*read_input(t3))
    assert sum(res3) == 7 and res3[0] >= res3[1]
    # Now run main on stdin if provided
    solve_all()
\end{minted}
\VALIDATION{Checked: (1) tie-breaking via turn order on a 1D line; (2) fully blocked player; (3) large $s_i$ with walls.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Keep the same per-player BFS but avoid repeated attribute lookups and branch mispredictions by hoisting constants and minimizing string operations; encode digits once and mutate the grid in-place.}
\ASSUMPTIONS{Queues per player; process at most $s_i$ full layers per turn; exit early when a player's queue empties.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute character tags for players to avoid conversion during expansion.
\item Use local variables for hot path items (grid, bounds, directions).
\item Same layered BFS loop; stop when a full global round yields no progress.
\end{algosteps}
\COMPLEXITY{Asymptotics unchanged, but constant factors improved by cutting conversions and repeated lookups.}
\[
\begin{aligned}
T(n,m,p) &\in O(nm) \text{ with lower constants},\quad S(n,m,p) \in O(nm).
\end{aligned}
\]
\CORRECTNESS{Semantics identical to baseline; only micro-optimizations.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque
from typing import List, Tuple

def read_input(text: str = None) -> Tuple[int, int, int, List[int], List[str]]:
    if text is None:
        import sys
        text = sys.stdin.read()
    text = text.strip()
    if not text:
        return 0, 0, 0, [], []
    tok = text.split()
    it = iter(tok)
    n = int(next(it)); m = int(next(it)); p = int(next(it))
    s = [int(next(it)) for _ in range(p)]
    grid = [next(it) for _ in range(n)]
    return n, m, p, s, grid

def solve_case(n: int, m: int, p: int, s: List[int], grid: List[str]) -> List[int]:
    if n == 0:
        return []
    g = [list(r) for r in grid]
    qs = [deque() for _ in range(p)]
    cnt = [0] * p
    tags = [str(i + 1) for i in range(p)]
    for r in range(n):
        row = g[r]
        for c in range(m):
            ch = row[c]
            if '1' <= ch <= '9':
                idx = ord(ch) - ord('1')
                qs[idx].append((r, c))
                cnt[idx] += 1
    nmax, mmax = n, m
    dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))
    while True:
        progressed = False
        for i in range(p):
            if not qs[i]:
                continue
            tag = tags[i]
            lim = s[i]
            for _ in range(lim):
                qsz = len(qs[i])
                if qsz == 0:
                    break
                for _ in range(qsz):
                    r, c = qs[i].popleft()
                    nr = r - 1; nc = c
                    if 0 <= nr < nmax and g[nr][nc] == '.':
                        g[nr][nc] = tag; cnt[i] += 1; qs[i].append((nr, nc)); progressed = True
                    nr = r + 1; nc = c
                    if 0 <= nr < nmax and g[nr][nc] == '.':
                        g[nr][nc] = tag; cnt[i] += 1; qs[i].append((nr, nc)); progressed = True
                    nr = r; nc = c - 1
                    if 0 <= nc < mmax and g[nr][nc] == '.':
                        g[nr][nc] = tag; cnt[i] += 1; qs[i].append((nr, nc)); progressed = True
                    nr = r; nc = c + 1
                    if 0 <= nc < mmax and g[nr][nc] == '.':
                        g[nr][nc] = tag; cnt[i] += 1; qs[i].append((nr, nc)); progressed = True
        if not progressed:
            break
    return cnt

def solve_all() -> None:
    n, m, p, s, grid = read_input()
    if n == 0:
        return
    ans = solve_case(n, m, p, s, grid)
    import sys
    sys.stdout.write(" ".join(map(str, ans)))

def main():
    n, m, p, s, grid = read_input()
    if n == 0:
        return
    solve_all()

if __name__ == "__main__":
    # Consistency checks
    assert solve_case(*read_input("1 5 2\n1 1\n1...2\n")) == [3, 2]
    assert solve_case(*read_input("2 2 2\n1 1\n1.\n.2\n")) in ([3, 1], [2, 2])  # depends on central tie
    # Sum of claims equals number of non-wall cells
    n, m, p, s, grid = read_input("2 3 2\n2 2\n1#.\n..2\n")
    res = solve_case(n, m, p, s, grid)
    free = sum(1 for r in grid for ch in r if ch != '#')
    assert sum(res) == free
    solve_all()
\end{minted}
\VALIDATION{Cross-checked that the sum of claimed cells equals the number of non-wall cells; spot-checked tie-breaking and blocked situations.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Rotate through players and perform at most $s_i$ BFS layers per player per round using a single queue per player. This is the standard accepted approach with $O(nm)$ work.}
\ASSUMPTIONS{Grid size up to $10^6$ cells; $p \le 9$; walls are immutable; initial castles are disjoint and non-empty.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a queue for each player with all of their castles; count them as owned.
\item Repeat rounds: for each player $i=1\ldots p$, expand exactly layer-by-layer up to $s_i$ levels, claiming adjacent empty cells and enqueuing them.
\item Terminate when a round produces no new cells; output per-player totals.
\end{algosteps}
\OPTIMALITY{Each cell is processed at most once (when it changes from `.' to a player's digit), so the algorithm is both time- and space-optimal up to constant factors for this model. Any solution must inspect all reachable empty cells, implying an $\Omega(nm)$ lower bound.}
\COMPLEXITY{Each edge is relaxed at most once per ownership change, yielding linear time.}
\[
\begin{aligned}
T(n,m,p) &\in \Theta(nm),\quad S(n,m,p) \in \Theta(nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import deque
from typing import List, Tuple

def read_input(text: str = None) -> Tuple[int, int, int, List[int], List[str]]:
    if text is None:
        import sys
        text = sys.stdin.read()
    text = text.strip()
    if not text:
        return 0, 0, 0, [], []
    tok = text.split()
    it = iter(tok)
    n = int(next(it)); m = int(next(it)); p = int(next(it))
    s = [int(next(it)) for _ in range(p)]
    grid = [next(it) for _ in range(n)]
    return n, m, p, s, grid

def solve_case(n: int, m: int, p: int, s: List[int], grid: List[str]) -> List[int]:
    if n == 0:
        return []
    g = [list(row) for row in grid]
    qs = [deque() for _ in range(p)]
    cnt = [0] * p
    # Initialize
    for r in range(n):
        for c in range(m):
            ch = g[r][c]
            if '1' <= ch <= '9':
                idx = ord(ch) - ord('1')
                qs[idx].append((r, c))
                cnt[idx] += 1
    # BFS per turn with per-player depth cap
    while True:
        progressed = False
        for i in range(p):
            if not qs[i]:
                continue
            cap = s[i]
            for _ in range(cap):
                qsz = len(qs[i])
                if qsz == 0:
                    break
                for _ in range(qsz):
                    r, c = qs[i].popleft()
                    # neighbors
                    if r > 0 and g[r - 1][c] == '.':
                        g[r - 1][c] = chr(ord('1') + i)
                        cnt[i] += 1
                        qs[i].append((r - 1, c))
                        progressed = True
                    if r + 1 < n and g[r + 1][c] == '.':
                        g[r + 1][c] = chr(ord('1') + i)
                        cnt[i] += 1
                        qs[i].append((r + 1, c))
                        progressed = True
                    if c > 0 and g[r][c - 1] == '.':
                        g[r][c - 1] = chr(ord('1') + i)
                        cnt[i] += 1
                        qs[i].append((r, c - 1))
                        progressed = True
                    if c + 1 < m and g[r][c + 1] == '.':
                        g[r][c + 1] = chr(ord('1') + i)
                        cnt[i] += 1
                        qs[i].append((r, c + 1))
                        progressed = True
        if not progressed:
            break
    return cnt

def solve_all() -> None:
    n, m, p, s, grid = read_input()
    if n == 0:
        return
    ans = solve_case(n, m, p, s, grid)
    import sys
    sys.stdout.write(" ".join(map(str, ans)))

def main():
    n, m, p, s, grid = read_input()
    if n == 0:
        return
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case(*read_input("1 5 2\n1 1\n1...2\n")) == [3, 2]
    assert sum(solve_case(*read_input("2 2 2\n10 10\n1.\n.2\n"))) == 4
    assert solve_case(*read_input("3 3 2\n2 1\n1#.\n.#.\n..2\n"))[0] >= 3
    solve_all()
\end{minted}
\VALIDATION{Three asserts: linear 1D tie-break, flood with large speeds summing to all non-wall cells, and a small walled grid where player 1 claims at least $3$ cells.}
\RESULT{Print the final controlled cell counts for players $1$ through $p$, space-separated.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test correctness on tiny grids, walls, and asymmetric speeds; verify that the sum of outputs equals the number of non-wall cells; property-check monotonicity: increasing some $s_i$ never decreases player $i$'s result.}
\LINE{CROSS-CHECKS}{Run the same inputs through Approach A, B, and C implementations on randomly generated small grids and compare outputs for equality.}
\LINE{EDGE-CASE GENERATOR}{Generate grids of size $1\times 1$, $1\times m$, $n\times 1$, all walls but initial castles, and cases where some players are fully enclosed.}
\begin{minted}{python}
import random
from collections import deque
from typing import List, Tuple

def gen_case(n: int, m: int, p: int, wall_prob: float = 0.1) -> Tuple[int, int, int, List[int], List[str]]:
    # Ensure at least one castle per player
    grid = [['.' for _ in range(m)] for _ in range(n)]
    # Place some walls
    for r in range(n):
        for c in range(m):
            if random.random() < wall_prob:
                grid[r][c] = '#'
    # Place one castle per player on empty cells
    empties = [(r, c) for r in range(n) for c in range(m) if grid[r][c] == '.']
    random.shuffle(empties)
    for i in range(p):
        if not empties:
            # carve a spot if needed
            r, c = random.randrange(n), random.randrange(m)
            grid[r][c] = '.'
            empties.append((r, c))
        r, c = empties.pop()
        grid[r][c] = str(i + 1)
    s = [random.randint(1, 5) for _ in range(p)]
    lines = [''.join(row) for row in grid]
    return n, m, p, s, lines

# Reference (Approach C)
def read_input(text: str = None):
    if text is None:
        import sys
        text = sys.stdin.read()
    text = text.strip()
    if not text:
        return 0, 0, 0, [], []
    tok = text.split()
    it = iter(tok)
    n = int(next(it)); m = int(next(it)); p = int(next(it))
    s = [int(next(it)) for _ in range(p)]
    grid = [next(it) for _ in range(n)]
    return n, m, p, s, grid

def solve_case_ref(n: int, m: int, p: int, s: List[int], grid: List[str]) -> List[int]:
    g = [list(row) for row in grid]
    qs = [deque() for _ in range(p)]
    cnt = [0] * p
    for r in range(n):
        for c in range(m):
            ch = g[r][c]
            if '1' <= ch <= '9':
                idx = ord(ch) - ord('1')
                qs[idx].append((r, c))
                cnt[idx] += 1
    while True:
        progressed = False
        for i in range(p):
            cap = s[i]
            for _ in range(cap):
                qsz = len(qs[i])
                if qsz == 0:
                    break
                for _ in range(qsz):
                    r, c = qs[i].popleft()
                    if r > 0 and g[r - 1][c] == '.':
                        g[r - 1][c] = chr(ord('1') + i); cnt[i] += 1; qs[i].append((r - 1, c)); progressed = True
                    if r + 1 < n and g[r + 1][c] == '.':
                        g[r + 1][c] = chr(ord('1') + i); cnt[i] += 1; qs[i].append((r + 1, c)); progressed = True
                    if c > 0 and g[r][c - 1] == '.':
                        g[r][c - 1] = chr(ord('1') + i); cnt[i] += 1; qs[i].append((r, c - 1)); progressed = True
                    if c + 1 < m and g[r][c + 1] == '.':
                        g[r][c + 1] = chr(ord('1') + i); cnt[i] += 1; qs[i].append((r, c + 1)); progressed = True
        if not progressed:
            break
    return cnt

# Cross-check random cases
for _ in range(50):
    n, m, p, s, grid = gen_case(5, 6, 3, wall_prob=0.2)
    res_ref = solve_case_ref(n, m, p, s, grid)
    # Compare with a second identical implementation to ensure determinism
    res_ref2 = solve_case_ref(n, m, p, s, grid)
    assert res_ref == res_ref2
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from collections import deque
from typing import List, Tuple

def read_input(text: str = None) -> Tuple[int, int, int, List[int], List[str]]:
    if text is None:
        import sys
        text = sys.stdin.read()
    text = text.strip()
    if not text:
        return 0, 0, 0, [], []
    tok = text.split()
    it = iter(tok)
    n = int(next(it)); m = int(next(it)); p = int(next(it))
    s = [int(next(it)) for _ in range(p)]
    grid = [next(it) for _ in range(n)]
    return n, m, p, s, grid

def solve_case(n: int, m: int, p: int, s: List[int], grid: List[str]) -> List[int]:
    if n == 0:
        return []
    g = [list(row) for row in grid]
    qs = [deque() for _ in range(p)]
    cnt = [0] * p
    for r in range(n):
        for c in range(m):
            ch = g[r][c]
            if '1' <= ch <= '9':
                idx = ord(ch) - ord('1')
                qs[idx].append((r, c))
                cnt[idx] += 1
    while True:
        progressed = False
        for i in range(p):
            cap = s[i]
            for _ in range(cap):
                qsz = len(qs[i])
                if qsz == 0:
                    break
                for _ in range(qsz):
                    r, c = qs[i].popleft()
                    if r > 0 and g[r - 1][c] == '.':
                        g[r - 1][c] = chr(ord('1') + i); cnt[i] += 1; qs[i].append((r - 1, c)); progressed = True
                    if r + 1 < n and g[r + 1][c] == '.':
                        g[r + 1][c] = chr(ord('1') + i); cnt[i] += 1; qs[i].append((r + 1, c)); progressed = True
                    if c > 0 and g[r][c - 1] == '.':
                        g[r][c - 1] = chr(ord('1') + i); cnt[i] += 1; qs[i].append((r, c - 1)); progressed = True
                    if c + 1 < m and g[r][c + 1] == '.':
                        g[r][c + 1] = chr(ord('1') + i); cnt[i] += 1; qs[i].append((r, c + 1)); progressed = True
        if not progressed:
            break
    return cnt

def solve_all() -> None:
    n, m, p, s, grid = read_input()
    if n == 0:
        return
    ans = solve_case(n, m, p, s, grid)
    import sys
    sys.stdout.write(" ".join(map(str, ans)))

def main():
    n, m, p, s, grid = read_input()
    if n == 0:
        return
    solve_all()

if __name__ == "__main__":
    # Minimal asserts
    assert solve_case(*read_input("1 5 2\n1 1\n1...2\n")) == [3, 2]
    assert sum(solve_case(*read_input("2 2 2\n5 5\n1.\n.2\n"))) == 4
    assert solve_case(*read_input("1 1 1\n100\n1\n")) == [1]
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Round-robin, per-player BFS limited to $s_i$ layers captures exactly the rules; each cell is claimed once.}
\WHY{This pattern of multi-source, turn-limited BFS appears in grid growth, contagion, and scheduling problems; mastering the layering trick is common in interviews and contests.}
\CHECKLIST{
\begin{bullets}
\item Initialize all player queues with all their castles.
\item For each player, process at most $s_i$ complete BFS layers.
\item Mark cells immediately upon claim to prevent double-claiming.
\item Repeat rounds until no player progresses.
\item Output per-player counts.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ or $m=1$ thin grids.
\item Players enclosed by walls cannot move.
\item Very large $s_i$ — treat as ``expand to exhaustion'' within a turn.
\item All cells already owned initially.
\item Disconnected open areas separated by walls.
\item Multiple players equidistant to a cell — earlier player in the turn order wins.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to expand by layers; expanding by raw queue size without capping per layer breaks the $s_i$ constraint.
\item Not marking cells upon enqueue may allow multiple enqueues and duplicate counting.
\item Off-by-one in converting digits to player indices.
\item Reading input incorrectly (mixing token and line parsing).
\item Using recursion for BFS risks stack issues; always use iterative queues.
\item Infinite loops if the ``progress in round'' condition is not tracked properly.
\end{bullets}
}
\FAILMODES{A naive global BFS ignoring per-turn caps will assign cells as if all players move infinitely fast each round; scanning grids repeatedly without queues is $O(nm)$ per round and can time out. The layered-queue approach avoids both issues.}
\ELI{Everyone grows their territory, but only a few steps per turn. Use one queue per player, take $s_i$ layers of steps on your turn, then let the next player go. Stop when nobody can move.}
\NotePages{3}

\end{document}