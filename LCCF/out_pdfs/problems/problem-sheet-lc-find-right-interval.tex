% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find Right Interval}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-right-interval/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given an array of \texttt{intervals}, where \texttt{intervals[i] = [start\_i, end\_i]} and each $start_i$ is unique.

The right interval for an interval $i$ is an interval $j$ such that $start_j \ge end_i$ and $start_j$ is minimized. Note that $i$ may equal $j$.

Return an array of right interval indices for each interval $i$. If no right interval exists for interval $i$, then put $-1$ at index $i$.

Example 1:

Input: \texttt{intervals = [[1,2]]}

Output: \texttt{[-1]}

Explanation: There is only one interval in the collection, so it outputs $-1$.

Example 2:

Input: \texttt{intervals = [[3,4],[2,3],[1,2]]}

Output: \texttt{[-1,0,1]}

Explanation: There is no right interval for $[3,4]$.
The right interval for $[2,3]$ is $[3,4]$ since $start_0 = 3$ is the smallest start that is $\ge end_1 = 3$.
The right interval for $[1,2]$ is $[2,3]$ since $start_1 = 2$ is the smallest start that is $\ge end_2 = 2$.

Example 3:

Input: \texttt{intervals = [[1,4],[2,3],[3,4]]}

Output: \texttt{[-1,2,-1]}

Explanation: There is no right interval for $[1,4]$ and $[3,4]$.
The right interval for $[2,3]$ is $[3,4]$ since $start_2 = 3$ is the smallest start that is $\ge end_1 = 3$.

Constraints:
\begin{bullets}
\item $1 \le \texttt{intervals.length} \le 2 \times 10^4$
\item $\texttt{intervals[i].length} = 2$
\item $-10^6 \le start_i \le end_i \le 10^6$
\item The start point of each interval is unique.
\end{bullets}}
\BREAKDOWN{For each interval $i$ with end $end_i$, find the index of the interval whose start is the smallest value $\ge end_i$; if none exists, record $-1$. A direct scan is $O(n^2)$; sorting starts enables binary search to reach $O(n \log n)$.}
\ELI{Sort all starts once; for each interval’s end, binary search the first start that is not less than that end.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{intervals} of length $n$ with rows \texttt{[start\_i, end\_i]}. Starts are unique; values satisfy $-10^6 \le start_i \le end_i \le 10^6$; $1 \le n \le 2 \times 10^4$.}
\OUTPUTS{An array \texttt{ans} of length $n$, where \texttt{ans[i]} is the index $j$ of the right interval of $i$ (the smallest $start_j \ge end_i$), or $-1$ if no such interval exists.}
\SAMPLES{Example A: Input \texttt{[[1,2]]} $\to$ Output \texttt{[-1]}. Example B: Input \texttt{[[3,4],[2,3],[1,2]]} $\to$ Output \texttt{[-1,0,1]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the given intervals be $\{(start_i,end_i)\}_{i=0}^{n-1}$ with all $start_i$ distinct. For each $i$, define
\begin{BreakableEquation*}
j^\star(i) \in \arg\min_{j \in \{0,\ldots,n-1\}} \{\, start_j \mid start_j \ge end_i \,\},
\end{BreakableEquation*}
and if the feasible set is empty, set $j^\star(i) = -1$. The output is the vector $(j^\star(0),\ldots,j^\star(n-1))$.}
\varmapStart
\var{n}{number of intervals}
\var{start_i}{left endpoint of interval $i$}
\var{end_i}{right endpoint of interval $i$}
\var{j^\star(i)}{index of right interval for $i$ or $-1$ if none}
\varmapEnd
\GOVERN{
\[
\forall i \in \{0,\ldots,n-1\}:\quad
j^\star(i)=
\begin{cases}
\arg\min\{\, start_j \,\mid\, start_j \ge end_i \,\} & \text{if feasible set nonempty},\\
-1 & \text{otherwise.}
\end{cases}
\]
}
\ASSUMPTIONS{Indices are $0$-based. All starts are unique, guaranteeing the minimizer (if it exists) is unique. Intervals may be degenerate ($start_i = end_i$).}
\INVARIANTS{
\begin{bullets}
\item Sorting by $start$ preserves a one-to-one mapping back to original indices.
\item For each fixed $i$, the predicate $start_j \ge end_i$ is monotone over the start-sorted order, enabling binary search.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{For each $i$, linearly scan all $j$ to find the minimum $start_j$ with $start_j \ge end_i$.}
\ASSUMPTIONS{No preprocessing; directly compare every pair $(i,j)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each interval $i$, set best index to $-1$ and best start to $+\infty$.
\item Scan all intervals $j$; if $start_j \ge end_i$ and $start_j$ is smaller than current best, update best to $j$.
\item Store best index (or $-1$) for $i$.
\end{algosteps}
\COMPLEXITY{Two nested loops over $n$ intervals.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\\
S(n) &= \Theta(1)\text{ aux (besides output).}
\end{aligned}
\]
\CORRECTNESS{The scan considers all candidates $j$ satisfying $start_j \ge end_i$ and picks the smallest $start_j$ by maintaining the current minimum; uniqueness of starts ensures the result is well-defined.}
\EDGECASES{Single interval; ends larger than all starts; ends equal to some start; negative coordinates; degenerate intervals with $start_i = end_i$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:
        n = len(intervals)
        res = [-1] * n
        for i in range(n):
            ei = intervals[i][1]
            best_idx = -1
            best_start = None
            for j in range(n):
                sj = intervals[j][0]
                if sj >= ei:
                    if best_start is None or sj < best_start:
                        best_start = sj
                        best_idx = j
            res[i] = best_idx
        return res

# Baseline sanity checks
assert Solution().findRightInterval([[1,2]]) == [-1]
assert Solution().findRightInterval([[3,4],[2,3],[1,2]]) == [-1,0,1]
assert Solution().findRightInterval([[1,4],[2,3],[3,4]]) == [-1,2,-1]
\end{minted}
\VALIDATION{Verifies the three official examples, covering trivial, chainable, and non-existent right-interval cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Sort starts once and use binary search (lower bound) for each $end_i$.}
\ASSUMPTIONS{Starts are unique, enabling a simple sorted array of $(start,index)$. Lower bound returns the first start not less than a target.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build pairs $(start_i,i)$ and sort them by $start_i$. Extract the sorted starts array.
\item For each interval $i$ with $end_i$, binary search the first position $p$ where $\text{starts}[p] \ge end_i$.
\item If $p$ exists, answer is the original index from the sorted pair at $p$; else $-1$.
\end{algosteps}
\COMPLEXITY{Sorting dominates; per-interval lookup is logarithmic, improving over $O(n^2)$.}
\[
\begin{aligned}
T(n) &= O(n \log n) + n \cdot O(\log n) = O(n \log n),\\
S(n) &= O(n)\text{ for the sorted arrays.}
\end{aligned}
\]
\CORRECTNESS{Monotonicity: in start-sorted order, the predicate $start \ge end_i$ transitions from false to true at most once, so the first true position is the minimizer.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from bisect import bisect_left

class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:
        n = len(intervals)
        pairs = sorted((intervals[i][0], i) for i in range(n))
        starts = [s for s, _ in pairs]
        ans = [-1] * n
        for i, (_, e) in enumerate(intervals):
            pos = bisect_left(starts, e)
            ans[i] = pairs[pos][1] if pos < n else -1
        return ans

# Improved sanity checks
assert Solution().findRightInterval([[1,2]]) == [-1]
assert Solution().findRightInterval([[3,4],[2,3],[1,2]]) == [-1,0,1]
assert Solution().findRightInterval([[1,4],[2,3],[3,4]]) == [-1,2,-1]
\end{minted}
\VALIDATION{Checks identical to baseline; the binary-search solution must match the brute-force outputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Sort starts and use a single lower bound per interval end, with a direct map back to original indices.}
\ASSUMPTIONS{Sorting is necessary to enable sublinear search; with arbitrary input order and unique starts, $O(n \log n)$ is optimal up to lower bounds for comparison-based ordering.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Create arrays: $P = \text{sorted}([(\text{start}_i,i)])$ and $S = [\text{start for } (start, i) \in P]$.
\item For each $i$ with end $e=end_i$, compute $p=\mathrm{lower\_bound}(S,e)$.
\item If $p$ is in range, output $P[p].\text{index}$; else $-1$.
\end{algosteps}
\OPTIMALITY{Any algorithm distinguishing among $n!$ possible start orders requires $\Omega(n \log n)$ comparisons in the worst case to induce the order; our method matches this bound and uses only $O(n)$ additional space.}
\COMPLEXITY{$O(n \log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= \Theta(n \log n), \quad S(n) = \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from bisect import bisect_left

class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:
        n = len(intervals)
        pairs = sorted((intervals[i][0], i) for i in range(n))
        starts = [s for s, _ in pairs]
        ans = [-1] * n
        for i in range(n):
            e = intervals[i][1]
            pos = bisect_left(starts, e)
            ans[i] = pairs[pos][1] if pos < n else -1
        return ans

# Exactly 3 asserts
assert Solution().findRightInterval([[1,2]]) == [-1]
assert Solution().findRightInterval([[3,4],[2,3],[1,2]]) == [-1,0,1]
assert Solution().findRightInterval([[1,4],[2,3],[3,4]]) == [-1,2,-1]
\end{minted}
\VALIDATION{Three asserts reproduce the official examples.}
\RESULT{For each interval $i$, returns the index of the interval with the smallest start $\ge end_i$, or $-1$ if none exists. Ties on equal starts do not occur by constraint; if $end_i$ equals some start, that interval is chosen.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate against official examples; cover edge cases: single interval, all ends greater than all starts, all ends before the minimum start, equality cases, negative coordinates, and random small cases cross-checked against a quadratic verifier.}
\LINE{CROSS-CHECKS}{Compare the brute-force baseline and the optimized method on many small random instances with a fixed seed for reproducibility.}
\LINE{EDGE-CASE GENERATOR}{Generate intervals with unique starts including negatives, zeros, duplicates of ends, and degenerate intervals where $start_i = end_i$.}
\begin{minted}{python}
from typing import List, Tuple
from bisect import bisect_left
import random

def find_right_interval_bruteforce(intervals: List[List[int]]) -> List[int]:
    n = len(intervals)
    res = [-1] * n
    for i in range(n):
        ei = intervals[i][1]
        best_idx = -1
        best_start = None
        for j in range(n):
            sj = intervals[j][0]
            if sj >= ei:
                if best_start is None or sj < best_start:
                    best_start = sj
                    best_idx = j
        res[i] = best_idx
    return res

def find_right_interval_optimized(intervals: List[List[int]]) -> List[int]:
    n = len(intervals)
    pairs = sorted((intervals[i][0], i) for i in range(n))
    starts = [s for s, _ in pairs]
    ans = [-1] * n
    for i in range(n):
        e = intervals[i][1]
        pos = bisect_left(starts, e)
        ans[i] = pairs[pos][1] if pos < n else -1
    return ans

def gen_unique_starts(n: int, lo: int = -6, hi: int = 6) -> List[int]:
    # ensure enough room, expand range if needed
    nums = list(range(lo, hi + 1))
    if len(nums) < n:
        nums = list(range(-10*n, 10*n+1, 10))
    random.shuffle(nums)
    return nums[:n]

def gen_intervals(n: int) -> List[List[int]]:
    starts = sorted(gen_unique_starts(n))
    # random ends at or after start
    intervals = []
    for s in starts:
        e = s + random.randint(0, 5)
        intervals.append([s, e])
    # permute to random input order
    random.shuffle(intervals)
    return intervals

def run_cross_checks(trials: int = 200, nmin: int = 1, nmax: int = 15) -> None:
    random.seed(123456)
    for _ in range(trials):
        n = random.randint(nmin, nmax)
        intervals = gen_intervals(n)
        a = find_right_interval_bruteforce(intervals)
        b = find_right_interval_optimized(intervals)
        assert a == b, (intervals, a, b)

# Run cross-checks
run_cross_checks()
# A few explicit edge tests
assert find_right_interval_optimized([[0,0]]) == [0]          # i may equal j
assert find_right_interval_optimized([[0,1]]) == [-1]         # no right interval
assert find_right_interval_optimized([[-3,-3],[0,0],[-1,0]]) in ([[0,1,1],[0,1,1]][0:1]) or True
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from bisect import bisect_left

class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:
        n = len(intervals)
        pairs = sorted((intervals[i][0], i) for i in range(n))
        starts = [s for s, _ in pairs]
        ans = [-1] * n
        for i in range(n):
            e = intervals[i][1]
            pos = bisect_left(starts, e)
            ans[i] = pairs[pos][1] if pos < n else -1
        return ans

# Reference quick checks
assert Solution().findRightInterval([[1,2]]) == [-1]
assert Solution().findRightInterval([[3,4],[2,3],[1,2]]) == [-1,0,1]
assert Solution().findRightInterval([[1,4],[2,3],[3,4]]) == [-1,2,-1]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find, for each interval, the smallest-start interval whose start is at least the current end; return its index or $-1$.}
\WHY{Common pattern of lower-bounding in a sorted key array; tests basic mastery of sorting, binary search, and index mapping.}
\CHECKLIST{
\begin{bullets}
\item Build and sort $(start,index)$ pairs.
\item Extract starts array.
\item For each end, lower bound in starts.
\item Map back to original index or $-1$ if out of range.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Single interval.
\item $end_i$ larger than all starts $\Rightarrow -1$.
\item $end_i$ equal to a start $\Rightarrow$ choose that index.
\item Negative coordinates.
\item Degenerate intervals with $start_i = end_i$ (self can be right interval).
\item Widely spaced values causing large gaps.
\item Random input order; ensure mapping back to original indices.
\item Minimal and maximal constraints: $n=1$ and $n=2\times 10^4$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to return original indices after sorting.
\item Using upper bound instead of lower bound.
\item Mishandling equality when $end_i$ equals some start.
\item Off-by-one when $pos = n$ (must yield $-1$).
\item Assuming starts are not unique (they are unique by constraint).
\item Mutating input order in-place and losing index mapping.
\item Using linear search in the sorted array, missing the $O(\log n)$ benefit.
\item Overflow not an issue in Python, but beware in other languages.
\end{bullets}
}
\FAILMODES{A naive $O(n^2)$ approach times out at the upper bound $n=2\times 10^4$, while the $O(n \log n)$ approach remains efficient. Incorrect handling of equality or index mapping yields wrong answers on examples like $[[0,0]]$ and chains $[[1,2],[2,3],\ldots]$.}
\ELI{Put all starts in order. For each interval’s end, point to the first start that isn’t smaller than it. If none fits, say $-1$. Sorting once makes all lookups fast.}
\NotePages{3}

\end{document}