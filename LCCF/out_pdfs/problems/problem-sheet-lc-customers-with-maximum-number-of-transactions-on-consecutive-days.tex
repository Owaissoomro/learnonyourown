% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Customers with Maximum Number of Transactions on Consecutive Days}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/customers-with-maximum-number-of-transactions-on-consecutive-days/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a multiset of transactions, each identified by a pair \texttt{(customer\_id, transaction\_date)}. For a customer, a \emph{consecutive-days streak} is a maximal sequence of calendar dates such that the customer made at least one transaction on each date in the sequence, and the dates are consecutive without gaps.

Compute, across all customers, the maximum streak length, and return all customers who achieve that maximum length together with that length.

Input format for this sheet (algorithmic version for testing): a list of pairs \texttt{[customer\_id, "YYYY-MM-DD"]}. Duplicates may exist for the same \texttt{customer\_id} and date, and multiple transactions on the same date count as one day toward the streak. The expected output is a list of pairs \texttt{[customer\_id, max\_streak]} for every customer whose longest consecutive-days streak equals the global maximum. Sort the output by \texttt{customer\_id} ascending. If there are no transactions, return an empty list.}
\BREAKDOWN{Group transactions by customer, deduplicate by date, sort dates, compute each customer's longest consecutive-days streak, find the global maximum, and output all customers matching it.}
\ELI{Find each customer's longest run of day-by-day activity, then report whoever has the longest run overall.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A Python list \texttt{transactions} of pairs \texttt{[customer\_id: int, date\_str: str]} where \texttt{date\_str} is an ISO date \texttt{"YYYY-MM-DD"}. Constraints: \texttt{1 \le customer\_id}, dates are valid Gregorian calendar dates, and the list length can be zero.}
\OUTPUTS{A Python list of pairs \texttt{[customer\_id: int, max\_streak: int]} for all customers whose longest consecutive-days streak equals the global maximum across customers. Sort the result by \texttt{customer\_id} ascending.}
\SAMPLES{Example 1:

Input: \texttt{[[1,"2023-01-01"], [1,"2023-01-02"], [2,"2023-01-10"]]}.

Customer 1 has a streak of 2; customer 2 has a streak of 1. Global maximum is 2. Output: \texttt{[[1,2]]}.

Example 2:

Input: \texttt{[[1,"2023-01-01"], [1,"2023-01-03"], [2,"2023-01-01"], [2,"2023-01-02"]]}.

Customer 1's best is 1; customer 2's best is 2. Output: \texttt{[[2,2]]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $C$ be the set of customers, $D \subset \mathbb{Z}$ be calendar dates mapped to integers via $\mathrm{ord}(\cdot)$. Let $T \subseteq C \times D$ with $(c,d) \in T$ iff customer $c$ has at least one transaction on date $d$. For $c \in C$, define $L(c)$ as the length of the longest interval $[a,b] \cap \mathbb{Z}$ such that $\{a,a+1,\ldots,b\} \subseteq \{d : (c,d) \in T\}$. The task is to output all $c$ with $L(c) = \max_{x \in C} L(x)$, together with that common value.}
\varmapStart
\var{C}{set of customer identifiers}
\var{D}{dates mapped to integer ordinals}
\var{T}{set of observed $(\text{customer}, \text{date})$ pairs, deduplicated by date}
\var{L(c)}{longest consecutive-days streak length for customer $c$}
\var{L^\ast}{global maximum $\max_{x \in C} L(x)$}
\varmapEnd
\GOVERN{
\[
  L(c) \;=\; \max\left\{\, (b-a+1) \;:\; a \le b,\; \{a,a+1,\ldots,b\} \subseteq \{d \in D \mid (c,d) \in T\} \,\right\},\quad
  L^\ast \;=\; \max_{c \in C} L(c).
\]
}
\ASSUMPTIONS{Dates are whole days; multiple transactions on the same date count once. Dates can be compared and differ by exactly $1$ for consecutive days via ordinal mapping.}
\INVARIANTS{For each customer, the set of dates is deduplicated; streaks are maximal intervals with day-difference $1$. Sorting by date preserves consecutiveness checks.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Sort unique transaction dates per customer and scan to find longest runs where adjacent dates differ by $1$.}
\ASSUMPTIONS{Input dates are valid ISO strings; convert to \texttt{datetime.date} then to ordinals for integer arithmetic.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group transactions by \texttt{customer\_id}. For each group, deduplicate dates.
\item Sort each customer's unique dates and scan, counting the current streak; reset when a gap appears; track the maximum.
\item Track the global maximum across customers; collect all customers achieving it; sort by \texttt{customer\_id}.
\end{algosteps}
\COMPLEXITY{With $n$ total transactions and $u$ total unique \texttt{(customer, date)} pairs: grouping and deduping is $O(n)$ expected; sorting per customer sums to $O(u \log u)$; scanning is $O(u)$. Memory $O(u)$.}
\[
\begin{aligned}
T(n) &\in O(n + u \log u), \\
S(n) &\in O(u).
\end{aligned}
\]
\CORRECTNESS{Every streak is contained within the sorted order; counting increases exactly when the next date is previous plus one; deduplication ensures multiple same-day transactions do not inflate the streak. Taking the maximum per customer and then across customers yields the desired output set.}
\EDGECASES{Empty input; all dates isolated (streak $=1$); ties between multiple customers; duplicate transactions on the same day; a single customer only.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from datetime import datetime
from collections import defaultdict
from typing import List, Tuple

class Solution:
    def customersWithMaxConsecutiveTransactions(self, transactions: List[List]) -> List[List[int]]:
        """
        transactions: list of [customer_id:int, date_str:"YYYY-MM-DD"]
        returns: list of [customer_id:int, max_streak:int] for customers with global max streak, sorted by id
        """
        # Group by customer -> set of unique dates (as ordinals)
        cust_dates = defaultdict(set)
        for cid, dstr in transactions:
            try:
                d = datetime.strptime(dstr, "%Y-%m-%d").date()
            except Exception as e:
                raise ValueError(f"Invalid date string: {dstr}") from e
            cust_dates[cid].add(d.toordinal())

        if not cust_dates:
            return []

        # Compute longest streak per customer
        best_per_cust: List[Tuple[int, int]] = []
        global_best = 0
        for cid, ordset in cust_dates.items():
            days = sorted(ordset)
            if not days:
                continue
            max_streak = 1
            cur = 1
            for i in range(1, len(days)):
                if days[i] == days[i-1] + 1:
                    cur += 1
                else:
                    if cur > max_streak:
                        max_streak = cur
                    cur = 1
            if cur > max_streak:
                max_streak = cur
            best_per_cust.append((cid, max_streak))
            if max_streak > global_best:
                global_best = max_streak

        # Collect customers achieving the global maximum
        ans = [[cid, streak] for (cid, streak) in best_per_cust if streak == global_best]
        ans.sort(key=lambda x: x[0])
        return ans


# ---- Baseline sanity checks ----
if __name__ == "__main__":
    sol = Solution()
    # Example 1
    tx1 = [[1,"2023-01-01"], [1,"2023-01-02"], [2,"2023-01-10"]]
    assert sol.customersWithMaxConsecutiveTransactions(tx1) == [[1,2]]
    # Example 2
    tx2 = [[1,"2023-01-01"], [1,"2023-01-03"], [2,"2023-01-01"], [2,"2023-01-02"]]
    assert sol.customersWithMaxConsecutiveTransactions(tx2) == [[2,2]]
    # Duplicates and ties
    tx3 = [
        [1,"2023-01-01"], [1,"2023-01-01"], [1,"2023-01-02"],
        [2,"2023-02-01"], [2,"2023-02-02"]
    ]
    assert sol.customersWithMaxConsecutiveTransactions(tx3) == [[1,2],[2,2]]
\end{minted}
\VALIDATION{Manual checks cover duplicates, ties, and gaps. Additional asserts confirm sorting and empty input behavior implicitly via logic.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Grouping by Difference Trick}
\WHICHFORMULA{Within a sorted list of ordinals $d_0,d_1,\ldots$, elements belong to the same consecutive run iff $d_i - i$ is constant. Grouping by this key yields run lengths directly.}
\ASSUMPTIONS{Dates are converted to ordinals; per-customer dates are deduplicated and sorted.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build per-customer sorted unique ordinals as before.
\item For each customer, scan indices $i$ and ordinals $d_i$, monitoring the key $k_i=d_i-i$; when the key changes, a run ends; update max.
\item Track the global maximum and collect all customers achieving it.
\end{algosteps}
\COMPLEXITY{Same $O(u \log u)$ asymptotics dominated by sorting; constant-factor improvement by simpler run detection.}
\[
\begin{aligned}
T(n) &\in O(n + u \log u), \\
S(n) &\in O(u).
\end{aligned}
\]
\CORRECTNESS{If dates increase by $1$ each step, then $d_i-i$ remains constant; any gap increases $d_i-i$, ending the run. Therefore run lengths counted per constant key equal consecutive-day streaks.}
\textbf{Code (Improved)}
\begin{minted}{python}
from datetime import datetime
from collections import defaultdict
from typing import List, Tuple

class Solution:
    def customersWithMaxConsecutiveTransactions(self, transactions: List[List]) -> List[List[int]]:
        # Group by customer -> set of unique date ordinals
        cust_dates = defaultdict(set)
        for cid, dstr in transactions:
            d = datetime.strptime(dstr, "%Y-%m-%d").date()
            cust_dates[cid].add(d.toordinal())

        if not cust_dates:
            return []

        best_per_cust: List[Tuple[int, int]] = []
        global_best = 0

        for cid, ordset in cust_dates.items():
            days = sorted(ordset)
            if not days:
                continue
            # Group by key = day - index
            max_run = 0
            prev_key = None
            cur_len = 0
            for i, day in enumerate(days):
                key = day - i
                if key == prev_key:
                    cur_len += 1
                else:
                    if prev_key is not None and cur_len > max_run:
                        max_run = cur_len
                    prev_key = key
                    cur_len = 1
            if cur_len > max_run:
                max_run = cur_len

            best_per_cust.append((cid, max_run))
            if max_run > global_best:
                global_best = max_run

        ans = [[cid, streak] for (cid, streak) in best_per_cust if streak == global_best]
        ans.sort(key=lambda x: x[0])
        return ans


# ---- Improved approach checks ----
if __name__ == "__main__":
    sol = Solution()
    # Consecutive run via difference trick
    tx = [[1,"2023-01-01"], [1,"2023-01-02"], [1,"2023-01-04"], [2,"2023-01-10"]]
    assert sol.customersWithMaxConsecutiveTransactions(tx) == [[1,2]]
    # Tie between customers
    tx_tie = [[1,"2023-01-01"], [1,"2023-01-02"], [2,"2023-02-01"], [2,"2023-02-02"]]
    assert sol.customersWithMaxConsecutiveTransactions(tx_tie) == [[1,2],[2,2]]
    # Empty input
    assert sol.customersWithMaxConsecutiveTransactions([]) == []
\end{minted}
\VALIDATION{Checked difference-key grouping on mixed gaps and ties; verified empty input returns empty list; ensured deterministic ordering of results.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single Pass per Customer After Sort}
\WHICHFORMULA{Sort unique dates per customer, then a linear pass computes the longest streak. This is asymptotically optimal given arbitrary date order.}
\ASSUMPTIONS{Sorting is required unless dates are pre-ordered; no external indices.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a map from \texttt{customer\_id} to sorted unique ordinals.
\item For each customer, scan once to compute $L(c)$.
\item Track $L^\ast$ and output all customers $c$ with $L(c)=L^\ast$, sorted by id.
\end{algosteps}
\OPTIMALITY{Any solution must inspect all distinct \texttt{(customer, date)} pairs. Without pre-sorted input per customer, $\Omega(u \log u)$ comparisons are necessary in the comparison model; the scan is linear, hence tight.}
\COMPLEXITY{$O(n + u \log u)$ time and $O(u)$ space, where $u$ is the number of unique \texttt{(customer, date)} pairs.}
\[
\begin{aligned}
T(n) &\in O(n + u \log u), \\
S(n) &\in O(u).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from datetime import datetime
from collections import defaultdict
from typing import List, Tuple

class Solution:
    def customersWithMaxConsecutiveTransactions(self, transactions: List[List]) -> List[List[int]]:
        """
        Returns [[customer_id, max_streak], ...] for customers achieving the global maximum
        of consecutive-day transaction streaks. Output sorted by customer_id.
        """
        # Map customer -> unique date ordinals
        cust_dates = defaultdict(set)
        for cid, dstr in transactions:
            d = datetime.strptime(dstr, "%Y-%m-%d").date()
            cust_dates[cid].add(d.toordinal())

        if not cust_dates:
            return []

        global_best = 0
        per = []
        for cid, ordset in cust_dates.items():
            days = sorted(ordset)
            if not days:
                continue
            best = 1
            cur = 1
            for i in range(1, len(days)):
                if days[i] == days[i-1] + 1:
                    cur += 1
                else:
                    if cur > best:
                        best = cur
                    cur = 1
            if cur > best:
                best = cur
            per.append((cid, best))
            if best > global_best:
                global_best = best

        res = [[cid, m] for cid, m in per if m == global_best]
        res.sort(key=lambda x: x[0])
        return res


# ---- Exactly 3 asserts (mini-tests) ----
if __name__ == "__main__":
    sol = Solution()
    assert sol.customersWithMaxConsecutiveTransactions(
        [[1,"2023-01-01"],[1,"2023-01-02"],[2,"2023-01-10"]]
    ) == [[1,2]]
    assert sol.customersWithMaxConsecutiveTransactions(
        [[1,"2023-01-01"],[1,"2023-01-01"],[1,"2023-01-02"],[2,"2023-01-02"]]
    ) == [[1,2]]
    assert sol.customersWithMaxConsecutiveTransactions([]) == []
\end{minted}
\VALIDATION{Three targeted asserts: basic longer streak win, duplicate-date handling, and empty input.}
\RESULT{Return all customers with the maximum consecutive-days streak and the shared maximum length, sorted by \texttt{customer\_id}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: empty input; single customer; duplicates on the same date; multiple streaks per customer; ties across customers; non-adjacent dates. Property: deduplicating per-day does not change longest run versus full multiset.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C on random small inputs: they must produce identical sorted outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate clustered dates with injected gaps; add random duplicates; vary number of customers; ensure boundary streaks at start/end of ranges.}
\begin{minted}{python}
from datetime import date, timedelta
import random

def gen_transactions(seed: int = 0, n_customers: int = 5, days: int = 20, dup_factor: int = 3):
    random.seed(seed)
    base = date(2023,1,1)
    tx = []
    for cid in range(1, n_customers+1):
        # choose some active days with clusters
        active = set()
        # create 2 clusters
        for _ in range(2):
            start = random.randrange(0, days-3)
            length = random.randrange(1, 5)
            for k in range(length):
                active.add(start+k)
        # add random isolated days
        for _ in range(random.randrange(0, 4)):
            active.add(random.randrange(0, days))
        # emit with random duplicates
        for d in sorted(active):
            for _ in range(random.randrange(1, dup_factor+1)):
                tx.append([cid, (base + timedelta(days=d)).isoformat()])
    random.shuffle(tx)
    return tx

# Cross-check A vs B vs C reusing their classes (redefined locally for isolation)
from collections import defaultdict
from datetime import datetime

class A:
    def customersWithMaxConsecutiveTransactions(self, transactions):
        cust_dates = defaultdict(set)
        for cid, dstr in transactions:
            cust_dates[cid].add(datetime.strptime(dstr, "%Y-%m-%d").date().toordinal())
        if not cust_dates: return []
        per, g = [], 0
        for cid, s in cust_dates.items():
            days = sorted(s)
            best = 1; cur = 1
            for i in range(1, len(days)):
                if days[i] == days[i-1] + 1: cur += 1
                else: best = max(best, cur); cur = 1
            best = max(best, cur)
            per.append((cid,best)); g = max(g, best)
        out = [[cid, m] for cid, m in per if m == g]; out.sort(key=lambda x:x[0]); return out

class B:
    def customersWithMaxConsecutiveTransactions(self, transactions):
        cust_dates = defaultdict(set)
        for cid, dstr in transactions:
            cust_dates[cid].add(datetime.strptime(dstr, "%Y-%m-%d").date().toordinal())
        if not cust_dates: return []
        per, g = [], 0
        for cid, s in cust_dates.items():
            days = sorted(s)
            max_run = 0; prev_key = None; cur = 0
            for i, day in enumerate(days):
                key = day - i
                if key == prev_key: cur += 1
                else:
                    if prev_key is not None: max_run = max(max_run, cur)
                    prev_key = key; cur = 1
            max_run = max(max_run, cur)
            per.append((cid, max_run)); g = max(g, max_run)
        out = [[cid, m] for cid, m in per if m == g]; out.sort(key=lambda x:x[0]); return out

class C:
    def customersWithMaxConsecutiveTransactions(self, transactions):
        # Same as final
        cust_dates = defaultdict(set)
        for cid, dstr in transactions:
            cust_dates[cid].add(datetime.strptime(dstr, "%Y-%m-%d").date().toordinal())
        if not cust_dates: return []
        per, g = [], 0
        for cid, s in cust_dates.items():
            days = sorted(s)
            best = 1; cur = 1
            for i in range(1, len(days)):
                if days[i] == days[i-1] + 1: cur += 1
                else: best = max(best, cur); cur = 1
            best = max(best, cur)
            per.append((cid, best)); g = max(g, best)
        out = [[cid, m] for cid, m in per if m == g]; out.sort(key=lambda x:x[0]); return out

if __name__ == "__main__":
    for seed in range(10):
        tx = gen_transactions(seed=seed)
        a = A().customersWithMaxConsecutiveTransactions(tx)
        b = B().customersWithMaxConsecutiveTransactions(tx)
        c = C().customersWithMaxConsecutiveTransactions(tx)
        assert a == b == c
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from datetime import datetime
from collections import defaultdict
from typing import List

class Solution:
    def customersWithMaxConsecutiveTransactions(self, transactions: List[List]) -> List[List[int]]:
        cust_dates = defaultdict(set)
        for cid, dstr in transactions:
            d = datetime.strptime(dstr, "%Y-%m-%d").date()
            cust_dates[cid].add(d.toordinal())

        if not cust_dates:
            return []

        per, g = [], 0
        for cid, ordset in cust_dates.items():
            days = sorted(ordset)
            best = 1 if days else 0
            cur = 1
            for i in range(1, len(days)):
                if days[i] == days[i-1] + 1:
                    cur += 1
                else:
                    if cur > best:
                        best = cur
                    cur = 1
            if cur > best:
                best = cur
            per.append((cid, best))
            if best > g:
                g = best

        res = [[cid, m] for cid, m in per if m == g]
        res.sort(key=lambda x: x[0])
        return res


# Final quick checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.customersWithMaxConsecutiveTransactions([]) == []
    assert sol.customersWithMaxConsecutiveTransactions([[5,"2024-05-01"]]) == [[5,1]]
    assert sol.customersWithMaxConsecutiveTransactions([[1,"2023-01-01"],[1,"2023-01-03"],[2,"2023-01-01"],[2,"2023-01-02"]]) == [[2,2]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute each customer's longest consecutive-day streak and return all customers achieving the global maximum.}
\WHY{This pattern shows up in analytics: activity streaks, retention, and engagement analysis; it tests grouping, deduplication, ordering, and off-by-one care.}
\CHECKLIST{%
\begin{bullets}
\item Deduplicate per \texttt{(customer, date)} before counting.
\item Convert dates reliably and compare by day ordinals.
\item Sort per-customer dates.
\item Scan and track current vs. best streak; update on boundary and at end.
\item Track global maximum and collect ties; sort result by \texttt{customer\_id}.
\end{bullets}}
\EDGECASES{%
\begin{bullets}
\item Empty transaction list.
\item All transactions on the same day.
\item Multiple transactions same day for same customer.
\item Multiple disjoint runs per customer.
\item Ties among customers for the maximum.
\item Single customer only.
\item Non-consecutive spaced dates.
\item Dates at month/year boundaries.
\item Unsorted input.
\item Very large number of duplicates for some days.
\end{bullets}}
\PITFALLS{%
\begin{bullets}
\item Forgetting to deduplicate by date per customer.
\item Off-by-one when resetting vs. finalizing the last run.
\item Sorting strings lexicographically instead of parsing dates.
\item Assuming input is pre-sorted.
\item Returning only one customer when multiple tie.
\item Not handling empty input and returning \texttt{[[,]]} malformed structures.
\item Integer overflow is not an issue in Python, but could be in other languages with ordinals.
\item Mixing timezone-aware datetimes with dates; use pure dates.
\end{bullets}}
\FAILMODES{%
\begin{bullets}
\item Counting transactions instead of unique days inflates streaks.
\item Treating gaps of more than one day as still consecutive due to string compare mistakes.
\item Not considering the last run after the loop.
\end{bullets}}
\ELI{Turn each customer's activity days into a sorted list of integers, count the longest run of +1 steps, then find who has the biggest run. Ties are allowed, and multiple transactions on the same day still count as one.}
\NotePages{3}

\end{document}