% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum LCM}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1765/M}}
\LINE{DIFFICULTY / RATING}{1000}
\STATEMENT{You are given an integer $n$.

Your task is to find two positive (greater than $0$) integers $a$ and $b$ such that $a+b=n$ and the least common multiple (LCM) of $a$ and $b$ is the minimum among all possible values of $a$ and $b$. If there are multiple answers, you can print any of them.

Input:
The first line contains a single integer $t$ ($1 \le t \le 100$) --- the number of test cases.

The first line of each test case contains a single integer $n$ ($2 \le n \le 10^9$).

Output:
For each test case, print two positive integers $a$ and $b$ --- the answer to the problem. If there are multiple answers, you can print any of them.

Note:
In the second example, there are $8$ possible pairs of $a$ and $b$:
- $a = 1$, $b = 8$, $\mathrm{LCM}(1, 8) = 8$;
- $a = 2$, $b = 7$, $\mathrm{LCM}(2, 7) = 14$;
- $a = 3$, $b = 6$, $\mathrm{LCM}(3, 6) = 6$;
- $a = 4$, $b = 5$, $\mathrm{LCM}(4, 5) = 20$;
- $a = 5$, $b = 4$, $\mathrm{LCM}(5, 4) = 20$;
- $a = 6$, $b = 3$, $\mathrm{LCM}(6, 3) = 6$;
- $a = 7$, $b = 2$, $\mathrm{LCM}(7, 2) = 14$;
- $a = 8$, $b = 1$, $\mathrm{LCM}(8, 1) = 8$.

In the third example, there are $5$ possible pairs of $a$ and $b$:
- $a = 1$, $b = 4$, $\mathrm{LCM}(1, 4) = 4$;
- $a = 2$, $b = 3$, $\mathrm{LCM}(2, 3) = 6$;
- $a = 3$, $b = 2$, $\mathrm{LCM}(3, 2) = 6$;
- $a = 4$, $b = 1$, $\mathrm{LCM}(4, 1) = 4$.}
\BREAKDOWN{We need to minimize $\mathrm{lcm}(a,b)$ subject to $a+b=n$ and $a,b \in \mathbb{Z}_{>0}$. Derive a structural condition for optimal pairs and produce them efficiently for up to $t \le 100$ cases with $n \le 10^9$.}
\ELI{Split $n$ into two parts so that they share the largest possible common divisor; for even $n$ take halves, for odd $n$ take $a$ as the largest proper divisor of $n$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $t$ with $1 \le t \le 100$. Then $t$ lines, each with an integer $n$ where $2 \le n \le 10^9$.}
\OUTPUTS{For each test case, print two positive integers $a$ and $b$ such that $a+b=n$ and $\mathrm{lcm}(a,b)$ is minimized. Any optimal pair is acceptable.}
\SAMPLES{Example 1: input $t=3$ with $n \in \{2,3,4\}$ could yield outputs: $(1,1)$, $(1,2)$, $(2,2)$. Example 2: for $n=9$, valid output is $(3,6)$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n \in \mathbb{Z}_{\ge 2}$, choose integers $a,b \ge 1$ with $a+b=n$ to minimize $\mathrm{lcm}(a,b)$.}
\varmapStart
\var{n}{given sum}
\var{a,b}{positive integers with $a+b=n$}
\var{g}{greatest common divisor $g=\gcd(a,b)$}
\var{p}{smallest prime factor of $n$ (for odd $n$)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\mathrm{lcm}(a,b) = \frac{ab}{\gcd(a,b)},\quad b=n-a,\quad \gcd(a,n-a)=\gcd(a,n).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Standard integer arithmetic; $a,b>0$; $n \ge 2$.}
\INVARIANTS{For fixed $n$, maximizing $\gcd(a,n)$ minimizes $\mathrm{lcm}(a,n-a) = \dfrac{a(n-a)}{\gcd(a,n)}$. For even $n$, $a=b=\tfrac{n}{2}$ achieves $\gcd(a,b)=\tfrac{n}{2}$. For odd $n$, choosing $a$ as the largest proper divisor of $n$ maximizes $\gcd(a,n)=a$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all splits $a \in [1,n-1]$, $b=n-a$, compute $\mathrm{lcm}(a,b)=ab/\gcd(a,b)$, and take the minimum.}
\ASSUMPTIONS{Direct iteration is feasible only for small $n$; serves as a correctness oracle for testing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For $a$ from $1$ to $n-1$, let $b=n-a$.
\item Compute $g=\gcd(a,b)$ and $L=\dfrac{ab}{g}$.
\item Track the pair with the smallest $L$; output any minimizer.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(n\log n)$ using Euclid for each $\gcd$; space $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= \sum_{a=1}^{n-1} O(\log n) = O(n\log n).
\end{aligned}
\]
\CORRECTNESS{All feasible splits are examined; the minimum LCM among them is returned by definition.}
\EDGECASES{$n=2$ yields $(1,1)$. Symmetry $(a,b)$ and $(b,a)$ is benign.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from math import gcd

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return t, ns

def solve_case(n: int):
    # Brute force: try all a in [1..n-1]
    best_lcm = None
    best_pair = (1, n - 1)
    for a in range(1, n):
        b = n - a
        g = gcd(a, b)
        L = (a // g) * b
        if best_lcm is None or L < best_lcm:
            best_lcm = L
            best_pair = (a, b)
    return best_pair

def solve_all():
    t, ns = read_input()
    out_lines = []
    for n in ns:
        a, b = solve_case(n)
        out_lines.append(f"{a} {b}")
    sys.stdout.write("\n".join(out_lines))

def _brutal_check():
    # Small sanity checks
    def lcm(x, y): return x // gcd(x, y) * y
    assert solve_case(2) in {(1, 1)}
    a, b = solve_case(4)
    assert a + b == 4 and lcm(a, b) == 2
    a, b = solve_case(9)
    assert a + b == 9 and lcm(a, b) == 6

if __name__ == "__main__":
    _brutal_check()
    solve_all()
\end{minted}
\VALIDATION{Cross-checks on $n \in \{2,4,9\}$ included via asserts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Use structure: maximize common divisor}
\WHICHFORMULA{We want to maximize $\gcd(a,n)$, since $\mathrm{lcm}(a,n-a)=\dfrac{a(n-a)}{\gcd(a,n)}$. The best for even $n$ is $a=b=\tfrac{n}{2}$. For odd $n$, set $a$ to the largest proper divisor of $n$, obtainable via its smallest prime factor $p$, yielding $a=\tfrac{n}{p}$, $b=n-a$.}
\ASSUMPTIONS{Prime factor search up to $\sqrt{n}$ suffices to find the smallest prime factor $p$ or detect primality.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n$ is even, return $(\tfrac{n}{2}, \tfrac{n}{2})$.
\item Else, find the smallest divisor $p>1$ of $n$ by trial division up to $\lfloor\sqrt{n}\rfloor$; if none, $p=n$ (prime).
\item Set $a=\tfrac{n}{p}$ (largest proper divisor), $b=n-a$; output $(a,b)$.
\end{algosteps}
\COMPLEXITY{Per test: $O(1)$ for even, $O(\sqrt{n})$ for odd; space $O(1)$. This beats the $O(n\log n)$ brute force.}
\[
\begin{aligned}
T(n) &= 
\begin{cases}
O(1), & n \text{ even},\\
O(\sqrt{n}), & n \text{ odd}.
\end{cases}
\end{aligned}
\]
\CORRECTNESS{If $a$ divides $n$, then $\gcd(a,n-a)=\gcd(a,n)=a$, so $\mathrm{lcm}(a,n-a)=n-a$. Minimizing this is equivalent to maximizing $a$, hence take the largest proper divisor. For even $n$, halves share $\gcd=\tfrac{n}{2}$, the maximum possible, giving the minimum LCM.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from math import gcd, isqrt

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return t, ns

def smallest_prime_factor(n: int) -> int:
    if n % 2 == 0:
        return 2
    f = 3
    lim = isqrt(n)
    while f <= lim:
        if n % f == 0:
            return f
        f += 2
    return n  # n is prime

def solve_case(n: int):
    if n % 2 == 0:
        return (n // 2, n // 2)
    p = smallest_prime_factor(n)
    a = n // p  # largest proper divisor
    b = n - a
    return (a, b)

def solve_all():
    t, ns = read_input()
    out_lines = []
    for n in ns:
        a, b = solve_case(n)
        out_lines.append(f"{a} {b}")
    sys.stdout.write("\n".join(out_lines))

def _sanity():
    def lcm(x, y): return x // gcd(x, y) * y
    # Check even n
    for n in [2, 4, 10, 100]:
        a, b = solve_case(n)
        assert a == b == n // 2
    # Check odd n against brute for small values
    for n in range(3, 60, 2):
        # brute
        best = None
        best_pair = None
        for a in range(1, n):
            b = n - a
            val = lcm(a, b)
            if best is None or val < best:
                best = val
                best_pair = (a, b)
        a2, b2 = solve_case(n)
        assert lcm(a2, b2) == best

if __name__ == "__main__":
    _sanity()
    solve_all()
\end{minted}
\VALIDATION{Asserts verify: halves for even $n$; for odd $n<60$, improved matches brute minimum LCM.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Halves if even; otherwise use smallest prime factor}
\WHICHFORMULA{Compute the optimal pair by:
- If $n$ even: $(\tfrac{n}{2},\tfrac{n}{2})$.
- If $n$ odd: let $p$ be the smallest prime factor of $n$; output $(\tfrac{n}{p}, n-\tfrac{n}{p})$.}
\ASSUMPTIONS{Trial division up to $\sqrt{n}$ suffices for $n \le 10^9$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n \bmod 2 = 0$, return $(n/2, n/2)$.
\item Else, find $p=\min\{d>1 : d \mid n\}$ by trial division up to $\lfloor\sqrt{n}\rfloor$.
\item Return $a=n/p$, $b=n-a$.
\end{algosteps}
\OPTIMALITY{For $n$ even, $\gcd(a,b) \le \tfrac{n}{2}$ for any $a+b=n$, and halves attain this upper bound, minimizing $ab/\gcd(a,b)$. For $n$ odd, restricting to divisors $a \mid n$ gives $\mathrm{lcm}(a,n-a)=n-a$; minimizing this requires maximizing $a$, i.e., $a$ equals the largest proper divisor, which is $n/p$ where $p$ is the smallest prime factor. Any nondivisor $a$ has $\gcd(a,n) < a$ and cannot yield a smaller LCM.}
\COMPLEXITY{Per test $O(1)$ for even, $O(\sqrt{n})$ for odd; memory $O(1)$.}
\[
\begin{aligned}
T(n) &= O\big(\mathbf{1}_{\{2\mid n\}} + \mathbf{1}_{\{2\nmid n\}}\sqrt{n}\big).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from math import gcd, isqrt

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return t, ns

def smallest_prime_factor(n: int) -> int:
    if n % 2 == 0:
        return 2
    f = 3
    lim = isqrt(n)
    while f <= lim:
        if n % f == 0:
            return f
        f += 2
    return n

def solve_case(n: int):
    if n % 2 == 0:
        return (n // 2, n // 2)
    p = smallest_prime_factor(n)
    a = n // p
    b = n - a
    return (a, b)

def solve_all():
    t, ns = read_input()
    out_lines = []
    for n in ns:
        a, b = solve_case(n)
        out_lines.append(f"{a} {b}")
    sys.stdout.write("\n".join(out_lines))

def _tests():
    # Exactly 3 asserts / mini-tests
    def lcm(x, y): return x // gcd(x, y) * y
    assert solve_case(2) == (1, 1)
    assert solve_case(10) == (5, 5)
    a, b = solve_case(21)
    assert a + b == 21 and lcm(a, b) == 14

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\VALIDATION{Asserts: $n=2 \to (1,1)$, $n=10 \to (5,5)$, and $n=21 \to$ LCM $14$.}
\RESULT{For each test case, print $a$ and $b$ as above; any optimal pair is accepted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the solver on crafted cases: small $n$ cross-checked with brute force; even/odd boundaries; primes vs. composites; powers of primes; products of two primes.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach B/C against Approach A for all $n \le 200$. Ensure equal minimal LCMs.}
\LINE{EDGE-CASE GENERATOR}{Generate primes near powers of two, large odd primes $<10^9$, and even numbers, to stress both branches and factor search.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from math import gcd, isqrt

def brute_min_pair(n):
    best = None
    best_pair = None
    for a in range(1, n):
        b = n - a
        val = (a // gcd(a, b)) * b
        if best is None or val < best:
            best = val
            best_pair = (a, b)
    return best_pair, best

def spf(n):
    if n % 2 == 0:
        return 2
    f, lim = 3, isqrt(n)
    while f <= lim:
        if n % f == 0:
            return f
        f += 2
    return n

def fast_pair(n):
    if n % 2 == 0:
        return (n // 2, n // 2)
    p = spf(n)
    a = n // p
    return (a, n - a)

def lcm(a, b): return a // gcd(a, b) * b

def self_test():
    # Cross-check for small n
    for n in range(2, 201):
        (a1, b1), L1 = brute_min_pair(n)
        a2, b2 = fast_pair(n)
        assert lcm(a2, b2) == L1
    # Targeted cases
    for n in [2, 3, 5, 9, 15, 27, 49, 77, 121, 99991]:
        (a1, b1), L1 = brute_min_pair(n if n < 1000 else 99)  # keep brute small
        a2, b2 = fast_pair(n)
        # For large n, just structural checks
        assert a2 + b2 == n
    print("All tests passed.")

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from math import gcd, isqrt

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    t = int(next(it))
    ns = [int(next(it)) for _ in range(t)]
    return t, ns

def smallest_prime_factor(n: int) -> int:
    if n % 2 == 0:
        return 2
    f = 3
    lim = isqrt(n)
    while f <= lim:
        if n % f == 0:
            return f
        f += 2
    return n

def solve_case(n: int):
    if n % 2 == 0:
        return (n // 2, n // 2)
    p = smallest_prime_factor(n)
    a = n // p
    b = n - a
    return (a, b)

def solve_all():
    t, ns = read_input()
    out_lines = []
    for n in ns:
        a, b = solve_case(n)
        out_lines.append(f"{a} {b}")
    sys.stdout.write("\n".join(out_lines))

def _asserts():
    def lcm(x, y): return x // gcd(x, y) * y
    # Tiny certs
    assert solve_case(2) == (1, 1)
    assert solve_case(4) == (2, 2)
    a, b = solve_case(9)
    assert a + b == 9 and lcm(a, b) == 6

if __name__ == "__main__":
    _asserts()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize $\mathrm{lcm}(a,b)$ under $a+b=n$ by maximizing their $\gcd$.}
\WHY{This pattern recurs in split/partition problems where co-primality vs. shared factors drives the objective.}
\CHECKLIST{%
- Check parity of $n$.
- If even, answer is $(\tfrac{n}{2},\tfrac{n}{2})$.
- If odd, find smallest prime factor $p$; output $(\tfrac{n}{p}, n-\tfrac{n}{p})$.
- Validate $a+b=n$ and positivity.
}
\EDGECASES{%
- $n=2 \to (1,1)$.
- $n$ prime odd $\to (1,n-1)$.
- $n$ power of $2 \to (\tfrac{n}{2},\tfrac{n}{2})$.
- $n$ odd with small factor $3 \to (n/3, 2n/3)$.
- $n$ odd square (e.g., $9 \to (3,6)$).
- $n$ product of two close primes (ensure $\sqrt{n}$ loop finds the smaller).
- Very large $n$ near $10^9$ (runtime of trial division).
- Ensure integer division, not float.
}
\PITFALLS{%
- Forgetting the even case shortcut.
- Using $\gcd(a,b)$ instead of $\gcd(a,n)$ identity for $b=n-a$.
- Overflow if computing $ab$ before dividing by $\gcd$ (use $(a//g)*b$).
- Incorrect loop bound in trial division (should be $\le \sqrt{n}$).
- Not handling prime $n$ (then $p=n$, $a=1$).
- Printing in wrong order or not ensuring $a,b>0$.
- Using slow brute force for large $n$.
- Mishandling whitespace in IO.
}
\FAILMODES{Brute force times out for $n$ near $10^9$. The proposed method uses at most $\sqrt{n}$ checks for odd $n$ and constant time for even $n$, passing comfortably.}
\ELI{To minimize the LCM, make the two numbers share as big a common divisor as possible. Splitting an even $n$ in half is best. For odd $n$, take the largest divisor you can for one side; the other is the remainder.}
\NotePages{3}

\end{document}