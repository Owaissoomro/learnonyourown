% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tournament-graph}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/323/B}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{In this problem you have to build a tournament graph, consisting of $n$ vertices, such that for any oriented pair of vertices $(v,u)$ ($v \ne u$) there exists a path from vertex $v$ to vertex $u$ consisting of no more than two edges.

A directed graph without self-loops is a tournament if there is exactly one edge between any two distinct vertices (in one out of two possible directions).

Input:
The first line contains an integer $n$ ($3 \le n \le 1000$), the number of the graph's vertices.

Output:
Print $-1$ if there is no graph satisfying the described conditions.

Otherwise, print $n$ lines with $n$ integers in each. The numbers should be separated with spaces. That is, the adjacency matrix $a$ of the found tournament. Consider the graph vertices to be numbered with integers from $1$ to $n$. Then $a_{v,u} = 0$ if there is no edge from $v$ to $u$, and $a_{v,u} = 1$ if there is one.

As the output graph has to be a tournament, the following equalities must be satisfied:
\begin{bullets}
\item $a_{v,u} + a_{u,v} = 1$ for each $v,u$ ($1 \le v,u \le n$; $v \ne u$);
\item $a_{v,v} = 0$ for each $v$ ($1 \le v \le n$).
\end{bullets}}
\BREAKDOWN{Construct a tournament on $n$ vertices with directed diameter at most $2$ (every ordered pair has a directed path of length $\le 2$), or report impossibility. Provide a concrete, efficient construction with proof.}
\ELI{Use a circular round-robin orientation for odd $n$, and for even $n \ne 4$ attach one extra vertex to an odd circular core in an alternating way so every pair connects within two steps; $n=4$ is the only impossible case.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $n$ with $3 \le n \le 1000$.}
\OUTPUTS{Either a single line containing $-1$ if no such tournament exists, or an $n \times n$ adjacency matrix of $0/1$ values separated by spaces, satisfying $a_{v,v}=0$ and $a_{v,u}+a_{u,v}=1$ for all $v \ne u$.}
\SAMPLES{Example 1:
\begin{itemize}
\item Input: 3
\item One valid output matrix:
\[
\begin{bmatrix}
0 & 1 & 0\\
0 & 0 & 1\\
1 & 0 & 0
\end{bmatrix}
\]
\end{itemize}
Example 2:
\begin{itemize}
\item Input: 4
\item Output: $-1$
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{0,1,\ldots,n-1\}$. A tournament is a directed complete graph on $V$ with no self-loops. We seek an orientation function $a:V \times V \to \{0,1\}$ with $a(v,v)=0$, $a(v,u)+a(u,v)=1$ for $v \ne u$, and for all ordered pairs $(v,u)$ there exists a directed walk $v \to x \to u$ where the walk length is at most $2$ (possibly $x=u$ for length $1$).}
\varmapStart
\var{n}{number of vertices}
\var{a_{v,u}}{adjacency indicator: $1$ iff edge $v\to u$}
\var{k}{helper: $\lfloor (n-1)/2 \rfloor$}
\var{d}{cyclic distance $(u-v)\bmod n$}
\var{m}{helper $m=n-1$ for even-$n$ construction}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Tournament constraints: } && a_{v,v}=0,\quad a_{v,u}+a_{u,v}=1 \quad (\forall v\ne u).\\
&\text{Diameter-2 requirement: } && \forall v\ne u\ \exists x\in V:\ a_{v,x}=1 \land a_{x,u}=1.\\
\end{aligned}
\]
}
\ASSUMPTIONS{Vertices are indexed modulo $n$ for circular constructions. All arithmetic on indices is taken modulo $n$ unless stated otherwise.}
\INVARIANTS{
\begin{itemize}
\item For odd $n$, the circular orientation with $a_{v,u}=1$ iff $1\le (u-v)\bmod n \le \tfrac{n-1}{2}$ is a tournament and each ordered pair has distance $\le 2$.
\item For even $n\ne 4$, an odd circular core on $m=n-1$ vertices augmented by one vertex with alternating parity attachments yields a tournament of diameter $\le 2$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Model as a search over orientations of $\binom{n}{2}$ edges; check tournament constraints and all-pairs reachability within $\le 2$ hops.}
\ASSUMPTIONS{Feasible only for very small $n$ (e.g., $n\le 7$) due to exponential branching.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate orientations for each unordered pair $\{u,v\}$.
\item Discard partial orientations violating $a_{u,v}+a_{v,u}=1$.
\item When complete, verify diameter $\le 2$ by squaring the adjacency matrix or BFS from each node.
\end{algosteps}
\COMPLEXITY{Exponential in $n$; $T(n)=2^{\binom{n}{2}}$ in the worst case; $S(n)=O(n^2)$.}
\[
\begin{aligned}
T(n) &= O\!\left(2^{\binom{n}{2}}\right),\quad
S(n) = O(n^2).
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration guarantees that if a solution exists it will be found; verification ensures the diameter-2 property.}
\EDGECASES{Smallest $n=3$ must succeed; $n=4$ should be rejected.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
import sys
from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def is_diameter_leq_2(adj):
    n = len(adj)
    # compute reachability in <=2 steps: R = A or A^2
    # We'll do a BFS limited to depth 2 for clarity.
    for s in range(n):
        seen = [False]*n
        seen[s] = True
        q = deque([(s, 0)])
        while q:
            v, d = q.popleft()
            if d == 2: 
                continue
            for u in range(n):
                if adj[v][u] and not seen[u]:
                    seen[u] = True
                    q.append((u, d+1))
        for t in range(n):
            if s == t: 
                continue
            if not seen[t]:
                return False
    return True

def brute_construct(n):
    # Only feasible for n<=7. Return None if not found.
    if n > 7:
        return None
    m = n*(n-1)//2
    pairs = []
    for i in range(n):
        for j in range(i+1, n):
            pairs.append((i, j))
    total = 1 << m
    for mask in range(total):
        adj = [[0]*n for _ in range(n)]
        ok = True
        for b, (i, j) in enumerate(pairs):
            if (mask >> b) & 1:
                adj[i][j] = 1
            else:
                adj[j][i] = 1
        # check tournament constraints (self loops 0 implied)
        # verify diameter
        if is_diameter_leq_2(adj):
            return adj
    return None

def solve_case(n):
    if n == 4:
        return None
    if n <= 7:
        return brute_construct(n)
    # fall back to constructive in later approaches; here baseline returns None to indicate not solved
    return None

def print_answer(adj):
    if adj is None:
        print(-1)
        return
    n = len(adj)
    for i in range(n):
        print(" ".join(str(adj[i][j]) for j in range(n)))

def main():
    n = read_input()
    ans = solve_case(n)
    if ans is None:
        # For baseline, if not solved (large n), print -1 conservatively
        # Later approaches provide a full constructive solution.
        if n == 4:
            print(-1)
        else:
            # Try small n brute force as last resort
            bf = brute_construct(n)
            if bf is None:
                print(-1)
            else:
                print_answer(bf)
    else:
        print_answer(ans)

# Lightweight asserts (do not print)
def _tests():
    for n in range(3, 8):
        adj = brute_construct(n)
        if n == 4:
            assert adj is None
        else:
            assert adj is not None
            assert is_diameter_leq_2(adj)

if __name__ == "__main__":
    # Run quick internal tests (small n), then run main
    _tests()
    main()
\end{minted}
\VALIDATION{Verified by brute force for $n=3,5,6,7$ that a valid tournament exists; confirmed impossibility for $n=4$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Circular Construction for Odd $n$}
\WHICHFORMULA{Use the standard round-robin (circulant) tournament on a cycle: for odd $n=2k+1$, direct edges forward to the next $k$ vertices.}
\ASSUMPTIONS{Indices are modulo $n$. For odd $n$, this construction is $k$-regular and symmetric.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n$ is odd, set $k=\tfrac{n-1}{2}$.
\item For each vertex $i$, and each offset $d\in\{1,\ldots,k\}$, add edge $i\to (i+d)\bmod n$.
\item Otherwise (even $n$), defer to Approach C.
\end{algosteps}
\COMPLEXITY{$O(n^2)$ time, $O(n^2)$ space to emit the matrix.}
\[
\begin{aligned}
T(n) &= \Theta(n\cdot k)=\Theta(n^2),\quad S(n)=\Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{For odd $n=2k+1$: for any ordered pair $(i,j)$, let $d=(j-i)\bmod n$. If $1\le d\le k$, we have a direct edge. If $k< d \le 2k$, set $t=d-k$; then $1\le t\le k$ and $i\to i+t$ is an edge, and $(i+t)\to (i+d)$ has offset $k$, which is included, yielding a 2-step path.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def construct_odd(n):
    assert n % 2 == 1
    k = (n - 1) // 2
    a = [[0]*n for _ in range(n)]
    for i in range(n):
        for d in range(1, k+1):
            j = (i + d) % n
            a[i][j] = 1
            a[j][i] = 0
    return a

def solve_case(n):
    if n == 4:
        return None
    if n % 2 == 1:
        return construct_odd(n)
    return None  # defer to optimal approach

def main():
    n = read_input()
    ans = solve_case(n)
    if ans is None:
        print(-1)
    else:
        for i in range(n):
            print(" ".join(str(ans[i][j]) for j in range(n)))

# asserts
def _check_tournament(a):
    n = len(a)
    for i in range(n):
        assert a[i][i] == 0
    for i in range(n):
        for j in range(n):
            if i == j: 
                continue
            assert a[i][j] + a[j][i] == 1

def _tests():
    for n in [3,5,7,9]:
        a = construct_odd(n)
        _check_tournament(a)
        # quick reachability <=2 via adjacency square
        n2 = len(a)
        # compute A or A^2
        reach = [[a[i][j] for j in range(n2)] for i in range(n2)]
        # add length-2 paths
        for i in range(n2):
            for j in range(n2):
                if reach[i][j] == 1:
                    continue
                # check any k: i->k and k->j
                ok = 0
                for k in range(n2):
                    if a[i][k] and a[k][j]:
                        ok = 1
                        break
                reach[i][j] = ok
        for i in range(n2):
            for j in range(n2):
                if i == j: 
                    continue
                assert reach[i][j] == 1

if __name__ == "__main__":
    _tests()
    main()
\end{minted}
\VALIDATION{Asserts verify the tournament property and 2-step reachability for several odd $n$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Full Construction for All $n$ Except $n=4$}
\WHICHFORMULA{Combine two constructions:
\begin{itemize}
\item For odd $n$, use the circulant tournament: $i\to j$ iff $1\le (j-i)\bmod n \le \tfrac{n-1}{2}$.
\item For even $n\ge 6$, build the odd circulant on $m=n-1$ vertices, then add vertex $m$ and set $j\to m$ for even $j$, and $m\to j$ for odd $j$.
\end{itemize}}
\ASSUMPTIONS{Vertices are labeled $0,\ldots,n-1$. For $n=4$, no solution exists (can be shown by case analysis).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n=4$, print $-1$.
\item If $n$ is odd, output the odd circulant tournament.
\item Else ($n$ even, so $n\ge 6$): let $m=n-1$.
\item Build the odd circulant tournament on vertices $0,\ldots,m-1$.
\item Add vertex $m$ and direct $j\to m$ for even $j$; direct $m\to j$ for odd $j$.
\item Output the resulting $n\times n$ matrix.
\end{algosteps}
\OPTIMALITY{Time-optimal up to constants for printing the full matrix; existence is tight with the single forbidden case $n=4$.}
\COMPLEXITY{$T(n)=\Theta(n^2)$, $S(n)=\Theta(n^2)$ to materialize and print the matrix.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \quad S(n)=\Theta(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys
from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def construct_odd(n):
    assert n % 2 == 1
    k = (n - 1) // 2
    a = [[0]*n for _ in range(n)]
    for i in range(n):
        for d in range(1, k+1):
            j = (i + d) % n
            a[i][j] = 1
            a[j][i] = 0
    return a

def construct_even(n):
    # n is even and n != 4
    assert n % 2 == 0 and n != 4
    m = n - 1
    a = [[0]*n for _ in range(n)]
    # build odd circulant on 0..m-1
    k = (m - 1) // 2  # = (n-2)//2
    for i in range(m):
        for d in range(1, k+1):
            j = (i + d) % m
            a[i][j] = 1
            a[j][i] = 0
    # connect vertex m by parity: even -> m, m -> odd
    for j in range(m):
        if j % 2 == 0:
            a[j][m] = 1
            a[m][j] = 0
        else:
            a[m][j] = 1
            a[j][m] = 0
    return a

def solve_case(n):
    if n == 4:
        return None
    if n % 2 == 1:
        return construct_odd(n)
    else:
        return construct_even(n)

def print_answer(adj):
    if adj is None:
        print(-1)
        return
    n = len(adj)
    for i in range(n):
        print(" ".join(str(adj[i][j]) for j in range(n)))

# Utilities for validation
def is_tournament(a):
    n = len(a)
    for i in range(n):
        if a[i][i] != 0:
            return False
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            if a[i][j] + a[j][i] != 1:
                return False
    return True

def diameter_leq_2(a):
    n = len(a)
    # check reachability within 2 steps
    for s in range(n):
        seen = [False]*n
        seen[s] = True
        # 1-step
        for v in range(n):
            if a[s][v]:
                seen[v] = True
        # 2-step
        for mid in range(n):
            if a[s][mid]:
                row = a[mid]
                for t in range(n):
                    if row[t]:
                        seen[t] = True
        for t in range(n):
            if s == t: 
                continue
            if not seen[t]:
                return False
    return True

def main():
    n = read_input()
    adj = solve_case(n)
    print_answer(adj)

# Exact 3 asserts or I/O mini-tests
def _tests():
    # 1) n=4 impossible
    assert solve_case(4) is None
    # 2) odd n=7 works
    adj7 = solve_case(7); assert is_tournament(adj7) and diameter_leq_2(adj7)
    # 3) even n=10 works
    adj10 = solve_case(10); assert is_tournament(adj10) and diameter_leq_2(adj10)

if __name__ == "__main__":
    _tests()
    main()
\end{minted}
\VALIDATION{Three asserts: $n=4$ returns $-1$; $n=7$ and $n=10$ produce valid tournaments of directed diameter $\le 2$.}
\RESULT{Outputs a valid tournament of directed diameter at most $2$ for all $n$ except $n=4$, where $-1$ is printed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the constructor on a range of $n$ including boundary cases: $n=3,5,6,7,8,9,10,999,1000$ for tournament property and diameter $\le 2$.}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches B and C on odd $n$; validate Approach C on even $n$ by explicit reachability checks.}
\LINE{EDGE-CASE GENERATOR}{Generate small $n$ and systematically verify existence or impossibility ($n=4$).}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from collections import deque

def verify(adj):
    assert is_tournament(adj)
    assert diameter_leq_2(adj)

def demo():
    for n in [3,5,6,7,8,9,10]:
        adj = solve_case(n)
        assert adj is not None
        verify(adj)
    assert solve_case(4) is None

if __name__ == "__main__":
    # Do not run to avoid duplicate work; reference only.
    pass
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def construct_odd(n):
    k = (n - 1) // 2
    a = [[0]*n for _ in range(n)]
    for i in range(n):
        for d in range(1, k+1):
            j = (i + d) % n
            a[i][j] = 1
            a[j][i] = 0
    return a

def construct_even(n):
    m = n - 1
    a = [[0]*n for _ in range(n)]
    k = (m - 1) // 2
    for i in range(m):
        for d in range(1, k+1):
            j = (i + d) % m
            a[i][j] = 1
            a[j][i] = 0
    for j in range(m):
        if j % 2 == 0:
            a[j][m] = 1
            a[m][j] = 0
        else:
            a[m][j] = 1
            a[j][m] = 0
    return a

def solve_case(n):
    if n == 4:
        return None
    if n % 2 == 1:
        return construct_odd(n)
    return construct_even(n)

def main():
    n = read_input()
    adj = solve_case(n)
    if adj is None:
        print(-1)
    else:
        for i in range(n):
            print(" ".join(str(adj[i][j]) for j in range(n)))

# quick sanity asserts
if __name__ == "__main__":
    assert solve_case(4) is None
    for n in [3,5,6,7,8,9,10]:
        assert solve_case(n) is not None
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Construct a tournament with directed diameter $\le 2$: odd $n$ via circulant; even $n\ne 4$ by adding one vertex with alternating parity connections to an odd circulant core.}
\WHY{This appears in constructive graph problems and tests knowledge of round-robin/circulant designs and diameter arguments.}
\CHECKLIST{
\begin{itemize}
\item If $n=4$, print $-1$.
\item If $n$ odd, use circulant with forward edges to next $(n-1)/2$ vertices.
\item If $n$ even, build odd core on $n-1$ and connect the last vertex: even $\to$ last, last $\to$ odd.
\item Verify $a_{v,v}=0$ and $a_{v,u}+a_{u,v}=1$.
\item Ensure all pairs have a path of length $\le 2$.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item $n=3$: minimal nontrivial tournament; works.
\item $n=4$: impossible; must output $-1$.
\item $n=6$: first even feasible case; parity attachment must be correct.
\item Large $n=1000$: ensure $O(n^2)$ print, no timeouts.
\item Self-loops must be zero.
\item No spaces/formatting errors per row.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Mishandling modulo indices when constructing circulant.
\item Forgetting to set both directions consistently (risking non-tournament).
\item For even $n$, using a symmetric tie-break on antipodal pairs can fail; prefer the odd-core + parity attachment method.
\item Off-by-one in parity classification of vertices when attaching the last vertex.
\item Accidentally leaving diagonal entries as $1$.
\item Printing extra spaces or missing line breaks.
\end{itemize}}
\FAILMODES{Naive even-$n$ circulant with arbitrary antipodal tie-break may break the 2-step reachability for some pairs; the presented parity-attachment to an odd core avoids this.}
\ELI{Think of players around a circle. For odd counts, each player plays the next half clockwise and can reach any other in at most two passes. For even counts, seat one extra ``referee'' connected to evens one way and odds the other; the immediate neighbors bridge the two-step paths.}
\NotePages{3}

\end{document}