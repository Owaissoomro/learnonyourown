% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Number of Transactions per Visit}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/number-of-transactions-per-visit/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given two relations:
\begin{bullets}
\item \texttt{Visits}(\texttt{user\_id} INT, \texttt{visit\_date} DATE) — each row denotes that user \texttt{user\_id} visited the app on \texttt{visit\_date}. A user may have multiple visits across dates; treat each row as one visit.
\item \texttt{Transactions}(\texttt{user\_id} INT, \texttt{transaction\_date} DATE, \texttt{amount} INT) — each row denotes a transaction made by user \texttt{user\_id} on \texttt{transaction\_date}. There may be multiple transactions per user per date.
\end{bullets}
For each visit row $v \in \texttt{Visits}$, define
\begin{BreakableEquation*}
c(v) \coloneqq \#\{\, t \in \texttt{Transactions} : t.\texttt{user\_id} = v.\texttt{user\_id} \ \land\ t.\texttt{transaction\_date} = v.\texttt{visit\_date} \,\}.
\end{BreakableEquation*}
Return a two-column result with schema \texttt{(transactions\_count, visits\_count)} such that, for every nonnegative integer $k$ that occurs among $\{c(v)\}$, the row $(k, \#\{v \in \texttt{Visits} : c(v) = k\})$ appears. Order the output by \texttt{transactions\_count} ascending.}
\BREAKDOWN{Compute the number of same-day transactions per visit, then group by that count to produce a histogram of visits per count.}
\ELI{Count, for each visit, how many same-day transactions that user made, then tally how many visits had 0, 1, 2, \ldots\ transactions.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{For executable examples in this sheet, model the relations as Python lists:
\begin{bullets}
\item \texttt{visits}: list of tuples \texttt{(user\_id: int, visit\_date: str)} where dates are \texttt{"YYYY-MM-DD"}.
\item \texttt{transactions}: list of tuples \texttt{(user\_id: int, transaction\_date: str, amount: int)}.
\end{bullets}
Values are arbitrary integers; dates compare by exact string equality.}
\OUTPUTS{A list of pairs \texttt{[transactions\_count, visits\_count]}, sorted by \texttt{transactions\_count} ascending. Each visit contributes exactly one to exactly one \texttt{visits\_count}.}
\SAMPLES{Example 1:
\begin{bullets}
\item \texttt{visits} = [(1, "2020-01-01"), (2, "2020-01-01"), (1, "2020-01-02")]
\item \texttt{transactions} = [(1, "2020-01-01", 5), (1, "2020-01-01", 7), (2, "2020-01-03", 2)]
\item Per-visit counts: user 1 on 2020-01-01 has 2; user 2 on 2020-01-01 has 0; user 1 on 2020-01-02 has 0. Histogram: \texttt{[[0, 2], [2, 1]]}.
\end{bullets}
Example 2:
\begin{bullets}
\item \texttt{visits} = [(1, "2020-02-01"), (1, "2020-02-01")]
\item \texttt{transactions} = [(1, "2020-02-01", 10)]
\item Each of the two visits has count 1. Histogram: \texttt{[[1, 2]]}.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V$ be the multiset of visit events $(u,d)$ from \texttt{Visits}, and let $T$ be the multiset of transaction events $(u,d,a)$ from \texttt{Transactions}. For $v=(u,d)\in V$, define $c(v)=\#\{(u',d',a)\in T: u'=u \land d'=d\}$. The output is the multiset histogram $H=\{(k, \#\{v\in V: c(v)=k\})\}$ sorted by $k$.}
\varmapStart
\var{V}{multiset of visits $(u,d)$}
\var{T}{multiset of transactions $(u,d,a)$}
\var{c(v)}{same-day transaction count for visit $v$}
\var{H}{histogram pairs $(k, \text{visits with }c(v)=k)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
c(u,d) &= \#\{(u',d',a)\in T: u'=u \land d'=d\},\\
H &= \bigl\{(k, \#\{(u,d)\in V: c(u,d)=k\})\bigr\}.
\end{aligned}
\]
}
\ASSUMPTIONS{String dates are comparable by equality; no need for calendar arithmetic. A visit is a single row; duplicate rows are distinct visits.}
\INVARIANTS{
\begin{bullets}
\item $\sum_{(k,x)\in H} x = |V|$ — each visit contributes to exactly one bucket.
\item $k\ge 0$ for all $(k,x)\in H$ — counts are nonnegative integers.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly evaluate $c(u,d)$ by scanning all transactions for each visit, then tally counts into a histogram.}
\ASSUMPTIONS{Data volumes are small; an $O(|V|\cdot|T|)$ nested loop is acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an empty dictionary \texttt{hist} from count $\to$ frequency.
\item For each visit $(u,d)$ in \texttt{visits}, scan all transactions to count those with $(u',d')=(u,d)$; increment \texttt{hist[count]}.
\item Emit sorted pairs $[k, \texttt{hist}[k]]$ by increasing $k$.
\end{algosteps}
\COMPLEXITY{$T(n)=O(|V|\cdot|T|)$, $S(n)=O(U)$ where $U$ is the number of distinct counts observed (at most $|T|$ and typically much smaller).}
\[
\begin{aligned}
T(|V|,|T|) &= \sum_{v\in V} O(|T|) \\
           &= O(|V|\cdot|T|).
\end{aligned}
\]
\CORRECTNESS{Every visit counts matching transactions by equality on both user and date. The histogram invariant ensures each visit contributes once.}
\EDGECASES{Users with no transactions; dates with no transactions; multiple visits on the same date by the same user; large counts; empty inputs.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import defaultdict
from typing import List, Tuple, Dict

class Solution:
    def numberOfTransactionsPerVisit(self, visits: List[Tuple[int, str]], transactions: List[Tuple[int, str, int]]) -> List[List[int]]:
        hist: Dict[int, int] = defaultdict(int)
        # For each visit, brute-force count matching transactions
        for (u, d) in visits:
            cnt = 0
            for (uu, dd, a) in transactions:
                if uu == u and dd == d:
                    cnt += 1
            hist[cnt] += 1
        # Build sorted output
        out = [[k, hist[k]] for k in sorted(hist.keys())]
        return out

# Baseline asserts
_sol = Solution()
assert _sol.numberOfTransactionsPerVisit(
    visits=[(1, "2020-01-01"), (2, "2020-01-01"), (1, "2020-01-02")],
    transactions=[(1, "2020-01-01", 5), (1, "2020-01-01", 7), (2, "2020-01-03", 2)]
) == [[0, 2], [2, 1]]

assert _sol.numberOfTransactionsPerVisit(
    visits=[(1, "2020-02-01"), (1, "2020-02-01")],
    transactions=[(1, "2020-02-01", 10)]
) == [[1, 2]]
\end{minted}
\VALIDATION{Checked two scenarios: mixed 0/2 counts; duplicated visits producing a single bucket with count 1.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pre-aggregation}
\WHICHFORMULA{Pre-aggregate transactions by key $(\texttt{user\_id}, \texttt{date})$ into a dictionary for $O(1)$ lookups, then one pass over visits to tally the histogram.}
\ASSUMPTIONS{Hash maps are $O(1)$ expected time; memory for a map of unique $(u,d)$ pairs in \texttt{transactions}.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build \texttt{tx\_count[(u,d)] = number of transactions} by one pass over \texttt{transactions}.
\item For each visit $(u,d)$, let \texttt{cnt = tx\_count.get((u,d), 0)} and increment \texttt{hist[cnt]}.
\item Emit sorted histogram pairs.
\end{algosteps}
\COMPLEXITY{Build map in $O(|T|)$; tally visits in $O(|V|)$; total $O(|V|+|T|)$ time and $O(M)$ space where $M$ is distinct $(u,d)$ in \texttt{transactions}.}
\[
\begin{aligned}
T(|V|,|T|) &= O(|T|) + O(|V|), \quad S = O(M).
\end{aligned}
\]
\CORRECTNESS{For any $(u,d)$, the pre-aggregated count equals the number of matching transactions. Each visit reads the exact count and contributes to one bucket.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import defaultdict
from typing import List, Tuple, Dict

class Solution:
    def numberOfTransactionsPerVisit(self, visits: List[Tuple[int, str]], transactions: List[Tuple[int, str, int]]) -> List[List[int]]:
        # Pre-aggregate transactions by (user, date)
        tx_count: Dict[Tuple[int, str], int] = defaultdict(int)
        for (u, d, a) in transactions:
            tx_count[(u, d)] += 1
        # Build histogram over visits
        hist: Dict[int, int] = defaultdict(int)
        for (u, d) in visits:
            cnt = tx_count.get((u, d), 0)
            hist[cnt] += 1
        return [[k, hist[k]] for k in sorted(hist.keys())]

# Improved asserts (same API)
_sol = Solution()
assert _sol.numberOfTransactionsPerVisit(
    visits=[(1, "2020-01-01"), (2, "2020-01-01"), (1, "2020-01-02")],
    transactions=[(1, "2020-01-01", 5), (1, "2020-01-01", 7), (2, "2020-01-03", 2)]
) == [[0, 2], [2, 1]]

# Edge: empty inputs
assert _sol.numberOfTransactionsPerVisit(visits=[], transactions=[]) == []
\end{minted}
\VALIDATION{Validated mixed counts and empty-input behavior; histogram keys are sorted ascending.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Either pre-aggregate with a hash map ($O(|V|+|T|)$) or sort both relations and sweep ($O((|V|+|T|)\log(|V|+|T|))$). The linear-time pre-aggregation is optimal in the comparison model up to constants.}
\ASSUMPTIONS{Hashing with expected $O(1)$ operations; the output histogram must list only observed counts, sorted ascending.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pre-aggregate \texttt{transactions} by $(u,d)$ into \texttt{tx\_count}.
\item One pass over \texttt{visits} to accumulate \texttt{hist[cnt]}.
\item Emit sorted histogram pairs.
\end{algosteps}
\OPTIMALITY{Any solution must inspect all input rows, implying an $\Omega(|V|+|T|)$ lower bound. The hash pre-aggregation achieves $O(|V|+|T|)$ expected time, matching this bound.}
\COMPLEXITY{$T(n)=O(|V|+|T|)$, $S(n)=O(M)$ where $M$ is the number of distinct $(u,d)$ in \texttt{transactions}.}
\[
\begin{aligned}
T(|V|,|T|) &= O(|T|) + O(|V|),\quad S = O(M).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import defaultdict
from typing import List, Tuple, Dict

class Solution:
    def numberOfTransactionsPerVisit(self, visits: List[Tuple[int, str]], transactions: List[Tuple[int, str, int]]) -> List[List[int]]:
        # Pre-aggregate transactions by (user_id, date)
        tx_count: Dict[Tuple[int, str], int] = defaultdict(int)
        for u, d, amount in transactions:
            tx_count[(u, d)] += 1
        # Histogram of counts across visits
        hist: Dict[int, int] = defaultdict(int)
        for u, d in visits:
            hist[tx_count.get((u, d), 0)] += 1
        return [[k, hist[k]] for k in sorted(hist.keys())]

# Exactly 3 asserts
_sol = Solution()
assert _sol.numberOfTransactionsPerVisit(
    visits=[(1, "2020-01-01"), (2, "2020-01-01"), (1, "2020-01-02")],
    transactions=[(1, "2020-01-01", 5), (1, "2020-01-01", 7), (2, "2020-01-03", 2)]
) == [[0, 2], [2, 1]]
assert _sol.numberOfTransactionsPerVisit(
    visits=[(1, "2020-02-01"), (1, "2020-02-01")],
    transactions=[(1, "2020-02-01", 10), (1, "2020-02-02", 1)]
) == [[1, 2]]
assert _sol.numberOfTransactionsPerVisit(
    visits=[(3, "2021-05-05")],
    transactions=[]
) == [[0, 1]]
\end{minted}
\VALIDATION{Three asserts cover mixed counts, duplicate visits on a date, and no transactions.}
\RESULT{Return pairs \texttt{[transactions\_count, visits\_count]} for each observed count, sorted by \texttt{transactions\_count} ascending; visits with no same-day transactions contribute to count 0.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests over small crafted cases:
\begin{bullets}
\item Mixed buckets including zeros.
\item Duplicate visits for the same user and date.
\item No transactions; no visits; disjoint dates; large counts for a single date.
\end{bullets}}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved vs Final on random tiny datasets to ensure identical histograms.}
\LINE{EDGE-CASE GENERATOR}{Generate users, dates, and random numbers of transactions per date; ensure inclusion of dates with zero transactions to exercise the 0-bucket.}
\begin{minted}{python}
import random
from collections import defaultdict
from typing import List, Tuple

def gen_case(n_users: int, n_dates: int, n_visits: int, max_tx_per_key: int, seed: int = 0):
    rng = random.Random(seed)
    users = list(range(1, n_users + 1))
    dates = [f"2020-01-{i:02d}" for i in range(1, n_dates + 1)]
    # Random transactions per (u,d)
    transactions: List[Tuple[int, str, int]] = []
    for u in users:
        for d in dates:
            k = rng.randint(0, max_tx_per_key)
            for _ in range(k):
                transactions.append((u, d, rng.randint(1, 100)))
    # Random visits
    visits: List[Tuple[int, str]] = []
    for _ in range(n_visits):
        visits.append((rng.choice(users), rng.choice(dates)))
    return visits, transactions

# Cross-check A vs B vs C
class A:
    def numberOfTransactionsPerVisit(self, visits, transactions):
        from collections import defaultdict
        hist = defaultdict(int)
        for (u, d) in visits:
            cnt = 0
            for (uu, dd, a) in transactions:
                if uu == u and dd == d:
                    cnt += 1
            hist[cnt] += 1
        return [[k, hist[k]] for k in sorted(hist.keys())]

class B:
    def numberOfTransactionsPerVisit(self, visits, transactions):
        from collections import defaultdict
        tx = defaultdict(int)
        for (u, d, a) in transactions:
            tx[(u, d)] += 1
        hist = defaultdict(int)
        for (u, d) in visits:
            hist[tx.get((u, d), 0)] += 1
        return [[k, hist[k]] for k in sorted(hist.keys())]

class C:
    def numberOfTransactionsPerVisit(self, visits, transactions):
        from collections import defaultdict
        tx = defaultdict(int)
        for (u, d, a) in transactions:
            tx[(u, d)] += 1
        hist = defaultdict(int)
        for (u, d) in visits:
            hist[tx.get((u, d), 0)] += 1
        return [[k, hist[k]] for k in sorted(hist.keys())]

if __name__ == "__main__":
    for seed in range(5):
        visits, transactions = gen_case(3, 4, 20, 3, seed)
        outA = A().numberOfTransactionsPerVisit(visits, transactions)
        outB = B().numberOfTransactionsPerVisit(visits, transactions)
        outC = C().numberOfTransactionsPerVisit(visits, transactions)
        assert outA == outB == outC
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from collections import defaultdict
from typing import List, Tuple, Dict

class Solution:
    def numberOfTransactionsPerVisit(self, visits: List[Tuple[int, str]], transactions: List[Tuple[int, str, int]]) -> List[List[int]]:
        # Map (user_id, date) -> number of transactions on that date
        tx_count: Dict[Tuple[int, str], int] = defaultdict(int)
        for u, d, amount in transactions:
            tx_count[(u, d)] += 1
        # Histogram over visits
        hist: Dict[int, int] = defaultdict(int)
        for u, d in visits:
            hist[tx_count.get((u, d), 0)] += 1
        return [[k, hist[k]] for k in sorted(hist.keys())]

# Sanity tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.numberOfTransactionsPerVisit(
        visits=[(1, "2020-01-01"), (2, "2020-01-01"), (1, "2020-01-02")],
        transactions=[(1, "2020-01-01", 5), (1, "2020-01-01", 7), (2, "2020-01-03", 2)]
    ) == [[0, 2], [2, 1]]
    assert sol.numberOfTransactionsPerVisit(visits=[], transactions=[]) == []
    assert sol.numberOfTransactionsPerVisit(
        visits=[(9, "2020-03-03"), (9, "2020-03-03")],
        transactions=[(9, "2020-03-03", 1), (9, "2020-03-04", 2)]
    ) == [[1, 2]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute a histogram of same-day transaction counts per visit.}
\WHY{Common SQL interview pattern: join-on-date-and-user, aggregate, and histogram the counts.}
\CHECKLIST{
\begin{bullets}
\item Define the per-visit count key as $(\texttt{user\_id}, \texttt{date})$.
\item Pre-aggregate transactions by that key.
\item Tally visits into a histogram.
\item Sort by \texttt{transactions\_count} ascending.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item No transactions at all $\Rightarrow$ all visits are in bucket 0.
\item Users with transactions on other dates only.
\item Multiple visits for the same user and date.
\item Large counts for a single $(u,d)$.
\item Empty \texttt{visits} relation $\Rightarrow$ empty output.
\item Transactions for users who never visit on those dates.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Joining on user but forgetting to join on date.
\item Dropping visits with zero matches (must keep and count as 0).
\item Not grouping by the count when building the histogram.
\item Emitting unsorted histogram keys.
\item Double-counting visits due to duplicate joins.
\item Treating dates as ranges instead of equality.
\end{bullets}}
\FAILMODES{A naive inner join without preserving zero-match visits will miss the 0 bucket; left join or pre-aggregation with default 0 avoids this.}
\ELI{First count how many transactions each user did on each date. Then, for every visit, look up that number and tally how many visits had 0, 1, 2, \ldots\ transactions.}
\NotePages{3}

\end{document}