% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Remove Max Number of Edges to Keep Graph Fully Traversable}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Alice and Bob have an undirected graph of \texttt{n} nodes and three types of edges:
\begin{itemize}
\item Type 1: Can be traversed by Alice only.
\item Type 2: Can be traversed by Bob only.
\item Type 3: Can be traversed by both Alice and Bob.
\end{itemize}
Given an array \texttt{edges} where \texttt{edges[i] = [type\_i, u\_i, v\_i]} represents a bidirectional edge of type \texttt{type\_i} between nodes \texttt{u\_i} and \texttt{v\_i}, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes. Return \emph{the maximum number of edges you can remove, or return} \texttt{-1} \emph{if Alice and Bob cannot fully traverse the graph.}

\textbf{Example 1:}
\begin{itemize}
\item \textbf{Input:} \texttt{n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]}
\item \textbf{Output:} \texttt{2}
\item \textbf{Explanation:} If we remove the 2 edges \texttt{[1,1,2]} and \texttt{[1,1,3]}. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.
\end{itemize}

\textbf{Example 2:}
\begin{itemize}
\item \textbf{Input:} \texttt{n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]}
\item \textbf{Output:} \texttt{0}
\item \textbf{Explanation:} Notice that removing any edge will not make the graph fully traversable by Alice and Bob.
\end{itemize}

\textbf{Example 3:}
\begin{itemize}
\item \textbf{Input:} \texttt{n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]}
\item \textbf{Output:} \texttt{-1}
\item \textbf{Explanation:} In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it is impossible to make the graph fully traversable.
\end{itemize}

\textbf{Constraints:}
\begin{itemize}
\item $1 \le n \le 10^5$
\item $1 \le \lvert\texttt{edges}\rvert \le \min\!\bigl(10^5,\, \tfrac{3\,n\,(n-1)}{2}\bigr)$
\item $\texttt{edges[i].length} = 3$
\item $1 \le \texttt{type\_i} \le 3$
\item $1 \le \texttt{u\_i} < \texttt{v\_i} \le n$
\item All tuples $(\texttt{type\_i}, \texttt{u\_i}, \texttt{v\_i})$ are distinct.
\end{itemize}}
\BREAKDOWN{Use disjoint-set union (DSU) to build connectivity. Process shared edges (type 3) first to maximize reuse for both players, then player-specific edges. Count how many edges are actually needed for connectivity and subtract from total.}
\ELI{First use edges usable by both to glue as much of the graph together as possible, then finish connecting for Alice and Bob separately; everything unused is removable.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{On LeetCode:
\begin{itemize}
\item Integer $n$ with $1 \le n \le 10^5$.
\item List \texttt{edges} of length $m$, where each item is a triple \texttt{[type, u, v]} with $1 \le \texttt{type} \le 3$ and $1 \le u < v \le n$.
\end{itemize}}
\OUTPUTS{Return an integer: the maximum number of edges removable so that both Alice and Bob can still traverse all nodes; return $-1$ if either cannot be fully connected.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{n = 4}, \texttt{edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]} $\rightarrow$ Output: \texttt{2}.
\item Input: \texttt{n = 4}, \texttt{edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]} $\rightarrow$ Output: \texttt{0}.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V = \{1,\ldots,n\}$ and $E \subseteq \binom{V}{2} \times \{1,2,3\}$. We pick a subset $E' \subseteq E$ to keep. Define graphs $G_A = (V, E'_A)$ and $G_B = (V, E'_B)$ where $E'_A$ includes all edges in $E'$ of type 1 or 3, and $E'_B$ includes all edges in $E'$ of type 2 or 3. We require both $G_A$ and $G_B$ to be connected. Maximize $\lvert E \rvert - \lvert E' \rvert$.}
\varmapStart
\var{n}{number of nodes}
\var{m}{number of edges}
\var{E_1,E_2,E_3}{type-1, type-2, and type-3 edge sets}
\var{c_A,c_B}{number of connected components in Alice's and Bob's graphs}
\var{u(e),v(e)}{endpoints of edge $e$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Connectivity constraints: } c_A(E') = c_B(E') = 1.\\
&\text{Objective: maximize } \lvert E \rvert - \lvert E' \rvert \iff \text{minimize } \lvert E' \rvert.\\
&\text{Key structure: Use DSU; process } E_3 \text{ first, then } E_1 \text{ and } E_2.
\end{aligned}
\]
}
\ASSUMPTIONS{Nodes are labeled $1$-indexed. No parallel edges of identical triple; input is valid per constraints.}
\INVARIANTS{
\begin{itemize}
\item DSU maintains a partition of $V$; union operations never increase the component count.
\item Processing type 3 edges first maximizes shared connectivity, never hurts feasibility.
\item The number of kept edges equals unions that actually merge components across the two DSUs (counted once for type 3).
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use two DSUs (Alice and Bob). Try to apply all type 3 edges to both DSUs to create connectivity wherever possible, counting a type 3 edge as used if it merges in at least one DSU. Then apply type 1 for Alice and type 2 for Bob.}
\ASSUMPTIONS{We can count a kept edge when it reduces components in either relevant DSU; if neither DSU needs it, it is redundant and removable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize two DSUs, each with $n$ singleton sets.
\item Process all type 3 edges; attempt union in both DSUs; count the edge as used if it merges in at least one DSU.
\item Process type 1 on Alice-DSU and type 2 on Bob-DSU; count unions that merge.
\item If either DSU ends with more than one component, return $-1$; else return $m - \text{used}$.
\end{algosteps}
\COMPLEXITY{With union-by-rank and path compression, each union/find runs in $\alpha(n)$ amortized. Sorting/grouping edges by type is $O(m)$ if single pass.
\[
\begin{aligned}
T(n,m) &= O(m\,\alpha(n)),\\
S(n) &= O(n).
\end{aligned}
\]
}
\CORRECTNESS{Type 3 edges are attempted first to maximize shared connectivity. Counting an edge as used only if it merges components ensures we keep a minimal spanning set per player. Final connectivity checks guarantee feasibility.}
\EDGECASES{No edges; $n=1$; edges only of one type; already fully connected; duplicates that are non-merging.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n + 1))
        self.r = [0] * (n + 1)
        self.comp = n

    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x

    def union(self, a: int, b: int) -> bool:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        self.comp -= 1
        return True

class Solution:
    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
        # Two DSUs; process type 3 first
        A = DSU(n)
        B = DSU(n)
        used = 0

        # Type 3
        for t, u, v in edges:
            if t == 3:
                mergedA = A.union(u, v)
                mergedB = B.union(u, v)
                if mergedA or mergedB:
                    used += 1

        # Type 1 for Alice, Type 2 for Bob
        for t, u, v in edges:
            if t == 1:
                if A.union(u, v):
                    used += 1
            elif t == 2:
                if B.union(u, v):
                    used += 1

        if A.comp != 1 or B.comp != 1:
            return -1
        return len(edges) - used

# Basic asserts (samples + tiny)
if __name__ == "__main__":
    s = Solution()
    assert s.maxNumEdgesToRemove(4, [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]) == 2
    assert s.maxNumEdgesToRemove(4, [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]) == 0
    assert s.maxNumEdgesToRemove(4, [[3,2,3],[1,1,2],[2,3,4]]) == -1
    assert s.maxNumEdgesToRemove(1, []) == 0
\end{minted}
\VALIDATION{Checked against the three given samples; also $n=1$ with no edges returns $0$ correctly.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use a shared DSU to process type 3 edges once, then clone DSU state to Alice and Bob to avoid double work and ensure each type 3 edge is counted at most once.}
\ASSUMPTIONS{Cloning DSU arrays is $O(n)$, but done once. Union-by-rank with path compression applies.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build DSU \texttt{both}; process type 3 edges; count merges as kept.
\item Clone \texttt{both} into \texttt{alice} and \texttt{bob}.
\item Process type 1 edges on \texttt{alice} and type 2 edges on \texttt{bob}, counting merges.
\item If either DSU has more than one component, return $-1$; else return $m - \text{used}$.
\end{algosteps}
\COMPLEXITY{Same asymptotic: $O(m\,\alpha(n))$ time and $O(n)$ space; minimal constant factors when counting type 3 edges once. 
\begin{BreakableEquation*}
T(n,m) = O(m\,\alpha(n)),\quad S(n) = O(n).
\end{BreakableEquation*}
}
\CORRECTNESS{Type 3 edges form a common backbone used by both; cloning preserves this. Any further needed connections are achieved via type 1 or 2 edges independently.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import copy

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n + 1))
        self.r = [0] * (n + 1)
        self.comp = n

    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x

    def union(self, a: int, b: int) -> bool:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        self.comp -= 1
        return True

    def clone(self):
        c = DSU(0)
        c.p = self.p[:]
        c.r = self.r[:]
        c.comp = self.comp
        return c

class Solution:
    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
        both = DSU(n)
        used = 0

        # process type 3 edges
        for t, u, v in edges:
            if t == 3:
                if both.union(u, v):
                    used += 1

        alice = both.clone()
        bob = both.clone()

        # process type 1 and type 2
        for t, u, v in edges:
            if t == 1:
                if alice.union(u, v):
                    used += 1
            elif t == 2:
                if bob.union(u, v):
                    used += 1

        if alice.comp != 1 or bob.comp != 1:
            return -1
        return len(edges) - used

# Tests
if __name__ == "__main__":
    s = Solution()
    assert s.maxNumEdgesToRemove(4, [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]) == 2
    assert s.maxNumEdgesToRemove(4, [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]) == 0
    assert s.maxNumEdgesToRemove(4, [[3,2,3],[1,1,2],[2,3,4]]) == -1
\end{minted}
\VALIDATION{Validated on the provided samples; shared DSU ensures each type 3 edge is counted at most once.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Greedy via DSU: process type 3 first to maximize sharing, then types 1 and 2. This yields a minimum kept-edge set consistent with both connectivity constraints, maximizing removable edges.}
\ASSUMPTIONS{Graph undirected; DSU supports near-constant time merges; edges are processed in linear scan by type.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize DSU \texttt{both} with $n$ components. For all edges with $t=3$, union and count merges.
\item Clone \texttt{both} into \texttt{alice}, \texttt{bob}.
\item For $t=1$ edges, union in \texttt{alice}; for $t=2$, union in \texttt{bob}; count merges.
\item If either \texttt{alice.comp} or \texttt{bob.comp} $\ne 1$, return $-1$; else return $m - \text{used}$.
\end{algosteps}
\OPTIMALITY{Any solution must connect both players. Using all useful type 3 edges first is a matroid-style greedy choice: it never reduces feasibility and can only save player-specific edges. Thus it minimizes the number of kept edges; the complement is maximally removable.}
\COMPLEXITY{Each edge participates in at most one union per relevant DSU.
\begin{BreakableEquation*}
T(n,m) = O(m\,\alpha(n)),\quad S(n) = O(n).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n + 1))
        self.r = [0] * (n + 1)
        self.comp = n

    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x

    def union(self, a: int, b: int) -> bool:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        self.comp -= 1
        return True

    def clone(self):
        c = DSU(0)
        c.p = self.p[:]
        c.r = self.r[:]
        c.comp = self.comp
        return c

class Solution:
    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
        both = DSU(n)
        used = 0

        # Shared edges first
        for t, u, v in edges:
            if t == 3 and both.union(u, v):
                used += 1

        alice = both.clone()
        bob = both.clone()

        # Player-specific edges
        for t, u, v in edges:
            if t == 1 and alice.union(u, v):
                used += 1
            elif t == 2 and bob.union(u, v):
                used += 1

        # Connectivity check
        if alice.comp != 1 or bob.comp != 1:
            return -1
        return len(edges) - used

if __name__ == "__main__":
    s = Solution()
    # Exactly 3 asserts
    assert s.maxNumEdgesToRemove(4, [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]) == 2
    assert s.maxNumEdgesToRemove(4, [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]) == 0
    assert s.maxNumEdgesToRemove(4, [[3,2,3],[1,1,2],[2,3,4]]) == -1
\end{minted}
\VALIDATION{Three asserts cover two feasible instances and one infeasible instance; they match the official examples.}
\RESULT{Return the maximum number of removable edges; if either Alice or Bob cannot be fully connected, return $-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on samples; random small graphs cross-checked by comparing the number of connected components after applying the algorithm; adversarial cases with many redundant edges.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C on small $n \le 6$ with random edges; they should agree.}
\LINE{EDGE-CASE GENERATOR}{Generate cases with: $n=1$; only type 3 edges; only type 1 or only type 2 edges; chains vs stars; dense graphs with many redundant edges.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_chain(n: int) -> Tuple[int, List[List[int]]]:
    edges = []
    for i in range(1, n):
        edges.append([3, i, i+1])
    return n, edges

def gen_dense_with_redundant(n: int, seed: int = 0) -> Tuple[int, List[List[int]]]:
    random.seed(seed)
    edges = []
    # Ensure connectivity with type 3 tree
    for i in range(2, n+1):
        edges.append([3, random.randint(1, i-1), i])
    # Add redundant edges of random types
    for u in range(1, n+1):
        for v in range(u+1, n+1):
            if random.random() < 0.2:
                t = random.choice([1,2,3])
                edges.append([t, u, v])
    # Deduplicate
    seen = set()
    uniq = []
    for t,u,v in edges:
        key = (t, min(u,v), max(u,v))
        if key not in seen:
            seen.add(key)
            uniq.append([t,u,v])
    return n, uniq

# Quick cross-check using the final Solution
class Solution:
    # same as final
    def __init__(self): pass
    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
        class DSU:
            def __init__(self, n: int):
                self.p = list(range(n + 1))
                self.r = [0] * (n + 1)
                self.comp = n
            def find(self, x: int) -> int:
                while self.p[x] != x:
                    self.p[x] = self.p[self.p[x]]
                    x = self.p[x]
                return x
            def union(self, a: int, b: int) -> bool:
                ra, rb = self.find(a), self.find(b)
                if ra == rb:
                    return False
                if self.r[ra] < self.r[rb]:
                    ra, rb = rb, ra
                self.p[rb] = ra
                if self.r[ra] == self.r[rb]:
                    self.r[ra] += 1
                self.comp -= 1
                return True
            def clone(self):
                c = DSU(0)
                c.p = self.p[:]
                c.r = self.r[:]
                c.comp = self.comp
                return c
        both = DSU(n); used = 0
        for t,u,v in edges:
            if t == 3 and both.union(u,v):
                used += 1
        alice = both.clone(); bob = both.clone()
        for t,u,v in edges:
            if t == 1 and alice.union(u,v): used += 1
            elif t == 2 and bob.union(u,v): used += 1
        if alice.comp != 1 or bob.comp != 1: return -1
        return len(edges) - used

if __name__ == "__main__":
    s = Solution()
    n, e = gen_chain(5)
    assert s.maxNumEdgesToRemove(n, e) == 0
    n, e = gen_dense_with_redundant(6, seed=42)
    # just ensure it runs and returns an int in valid range
    ans = s.maxNumEdgesToRemove(n, e)
    assert isinstance(ans, int)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n + 1))
        self.r = [0] * (n + 1)
        self.comp = n

    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x

    def union(self, a: int, b: int) -> bool:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        self.comp -= 1
        return True

    def clone(self):
        c = DSU(0)
        c.p = self.p[:]
        c.r = self.r[:]
        c.comp = self.comp
        return c

class Solution:
    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
        both = DSU(n)
        used = 0
        for t, u, v in edges:
            if t == 3 and both.union(u, v):
                used += 1
        alice = both.clone()
        bob = both.clone()
        for t, u, v in edges:
            if t == 1 and alice.union(u, v):
                used += 1
            elif t == 2 and bob.union(u, v):
                used += 1
        if alice.comp != 1 or bob.comp != 1:
            return -1
        return len(edges) - used

# Self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.maxNumEdgesToRemove(4, [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]) == 2
    assert s.maxNumEdgesToRemove(4, [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]) == 0
    assert s.maxNumEdgesToRemove(4, [[3,2,3],[1,1,2],[2,3,4]]) == -1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize removable edges while preserving full connectivity for both Alice and Bob by greedily using type 3 edges first then player-specific edges via DSU.}
\WHY{Common in interviews to assess DSU mastery, greedy proof intuition, and multi-constraint connectivity reasoning.}
\CHECKLIST{
\begin{itemize}
\item Group edges by type; process type 3 first.
\item Maintain DSU component counts.
\item Count an edge as used if and only if it merges components.
\item Clone shared DSU state for Alice/Bob.
\item Final connectivity check for both.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item $n=1$ (answer $0$).
\item Only type 1 or only type 2 edges (likely $-1$ unless $n=1$).
\item No type 3 edges but both players independently connected.
\item Many redundant edges connecting already-joined nodes.
\item Duplicate endpoints across different types.
\item Large $n$ with long chains vs dense graphs.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Counting a type 3 edge twice.
\item Processing type 1/2 before type 3 reduces reuse and may undercount removals.
\item Off-by-one with 1-indexed nodes in DSU arrays.
\item Forgetting path compression/rank causing TLE on large inputs.
\item Not checking final connectivity for both players.
\item Mutating DSU when cloning incorrectly (shallow vs deep copy).
\end{itemize}}
\FAILMODES{Approaches that do not prioritize type 3 edges can keep extra player-specific edges unnecessarily, failing to maximize removals. Without DSU, naive BFS per edge can be $O(nm)$ and too slow.}
\ELI{Glue as much as possible using the edges both can walk, then finish the job separately for Alice and Bob. Anything that did not help connect new pieces is safe to remove.}
\NotePages{3}

\end{document}