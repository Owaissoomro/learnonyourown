% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Problem from Red Panda}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1188/E}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{At Moscow Workshops ICPC team gets a balloon for each problem they solved first. Team MSU Red Panda got so many balloons that they did not know how to spend them. So they came up with a problem with them.

There are several balloons, not more than $10^6$ in total, each one is colored in one of $k$ colors. We can perform the following operation: choose $k-1$ balloons such that they are of $k-1$ different colors, and recolor them all into remaining color. We can perform this operation any finite number of times (for example, we can only perform the operation if there are at least $k-1$ different colors among current balls).

How many different balloon configurations can we get? Only number of balloons of each color matters, configurations differing only by the order of balloons are counted as equal. As this number can be very large, output it modulo $998{,}244{,}353$.

Input:
The first line contains a single integer $k$ ($2 \le k \le 10^5$) — the number of colors.

The second line contains $k$ integers $a_1, a_2, \ldots, a_k$ ($0 \le a_i$) — initial configuration of balloons. $a_i$ is number of balloons of color $i$. The total number of balloons does not exceed $10^6$. In other words,
\begin{BreakableEquation*}
a_1 + a_2 + a_3 + \ldots + a_k \le 10^6.
\end{BreakableEquation*}

Output:
Output number of possible configurations modulo $998{,}244{,}353$.

Note:
In the first example, there are $3$ configurations we can get: $[0, 1, 2]$, $[2, 0, 1]$, $[1, 2, 0]$.

In the second example, we can apply the operation not more than once, and possible configurations are: $[1, 1, 1, 1]$, $[0, 0, 0, 4]$, $[0, 0, 4, 0]$, $[0, 4, 0, 0]$, $[4, 0, 0, 0]$.

In the third example, we cannot apply any operations, so the only achievable configuration is the starting one.}
\BREAKDOWN{Model the operation as a linear transformation on counts, find invariants and congruence conditions, and count feasible nonnegative integer solutions that satisfy residue constraints; then optimize the counting to run in $O(k \log k + n/k)$ time.}
\ELI{All colors either drop by one or one color gains $k-1$; this enforces a simple modular pattern for each color's count, so we count compositions of $n$ that fit those residues.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integer $k$ with $2 \le k \le 10^5$.
- Sequence $(a_1,\ldots,a_k)$ with $a_i \ge 0$ and $\sum_i a_i = n \le 10^6$.}
\OUTPUTS{One integer: number of reachable configurations modulo $998{,}244{,}353$. A configuration is a $k$-tuple of nonnegative counts summing to $n$.}
\SAMPLES{Examples (conceptual, matching the note):
- $k=3$, $a=[0,1,2] \Rightarrow 3$.
- $k=4$, $a=[1,1,1,1] \Rightarrow 5$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the state be $a=(a_1,\ldots,a_k)\in\mathbb{Z}_{\ge 0}^k$ with $\sum a_i=n$. An operation chooses a target color $t$ and does $a_t \gets a_t+(k-1)$ and for all $i\ne t$ does $a_i\gets a_i-1$ (only allowed if $a_i\ge 1$ for all $i\ne t$).}
\varmapStart
\var{n}{total balloons $\sum_i a_i$ (invariant)}
\var{k}{number of colors}
\var{b}{a reachable configuration}
\var{x_i}{number of operations that targeted color $i$}
\var{m}{total number of operations $m=\sum_i x_i$}
\var{r}{a residue shift in $\{0,\ldots,k-1\}$}
\var{S(r)}{sum of residues $\sum_i ((a_i-r)\bmod k)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Operation effect:}\quad b_i \;=\; a_i + k x_i - m, \quad m=\sum_{i=1}^k x_i, \; x_i\in\mathbb{Z}_{\ge 0}.\\
&\text{Residues:}\quad b_i \equiv a_i - m \pmod{k} \ \ \forall i.\\
&\text{Counting with fixed }r:\ c_i(r)=(a_i-r)\bmod k\in\{0,\ldots,k-1\},\ \ b_i=c_i(r)+k t_i, \ t_i\in\mathbb{Z}_{\ge 0},\\
&\sum_i b_i = n \iff \sum_i t_i = \dfrac{n-\sum_i c_i(r)}{k} = \dfrac{n - S(r)}{k}.
\end{aligned}
\]
}
\ASSUMPTIONS{Treat residues in $\{0,\ldots,k-1\}$. We assume the residue-class characterization governs reachability and count configurations $b$ satisfying the modular constraints and nonnegativity.}
\INVARIANTS{
- $\sum_i a_i=n$ stays constant.\\
- For any step, all non-target colors decrease by $1$; the target increases by $k-1$. Hence $b_i\equiv a_i-m\pmod{k}$ for a common $m$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{State-space BFS over $k$-tuples summing to $n$ by applying all valid operations until no new states appear.}
\ASSUMPTIONS{Feasible only for tiny $n$ (e.g., $n\le 18$) due to combinatorial explosion.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Start from initial $a$; push into a queue and visited set.
\item Pop a state; for each target $t$ allowed (i.e., all other colors positive), create the next state and enqueue if unseen.
\item Count visited states.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ in worst case; space also exponential. Practical only as a validator on very small instances.}
\[
\begin{aligned}
T(n) &\approx O(\text{number of reachable states}) \\
S(n) &\approx O(\text{number of reachable states})
\end{aligned}
\]
\CORRECTNESS{Exact exploration of the transition graph from the initial node.}
\EDGECASES{All-zero vector; already with $\ge 2$ zeros (no moves); $k=2$ (always can move if any ball exists).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque
from math import comb

MOD = 998244353

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return None
    k = it[0]
    a = it[1:1+k]
    return k, a

def solve_case_bfs(k, a):
    n = sum(a)
    start = tuple(a)
    seen = {start}
    q = deque([start])
    while q:
        cur = q.popleft()
        # Try each target t
        for t in range(k):
            ok = True
            for i in range(k):
                if i == t:
                    continue
                if cur[i] == 0:
                    ok = False
                    break
            if not ok:
                continue
            nxt = list(cur)
            for i in range(k):
                if i == t:
                    nxt[i] += (k - 1)
                else:
                    nxt[i] -= 1
            nxt = tuple(nxt)
            if min(nxt) < 0 or sum(nxt) != n:
                continue
            if nxt not in seen:
                seen.add(nxt)
                q.append(nxt)
    return len(seen) % MOD

def solve_all_bfs():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    k, a = parsed
    print(solve_case_bfs(k, a))

def _tests_baseline():
    # Tiny validations (BFS feasible)
    assert solve_case_bfs(3, [0,1,2]) == 3
    assert solve_case_bfs(4, [1,1,1,1]) == 5
    assert solve_case_bfs(3, [3,0,0]) == 1
    # k=2 small cases: all distributions reachable
    assert solve_case_bfs(2, [2,1]) == 4  # [3,0],[2,1],[1,2],[0,3]

if __name__ == "__main__":
    # If no stdin, run tests; else solve once.
    data = sys.stdin.read()
    if not data.strip():
        _tests_baseline()
    else:
        sys.stdout.write(str(solve_case_bfs(*read_input(data))) + ("\n" if sys.stdout.isatty() else ""))
\end{minted}
\VALIDATION{BFS cross-checks on small $n$ as in asserts; handles $k=2$ and early-stopping cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Residue-Class Counting (Naive S(r))}
\WHICHFORMULA{Count solutions $b$ with $b_i\equiv (a_i-r)\bmod k$ for a common $r$, via stars-and-bars on $t_i$ with sum $(n-S(r))/k$. Compute $S(r)$ naively in $O(k)$ per $r$.}
\ASSUMPTIONS{Mathematical reduction to residue constraints; straightforward but $O(k^2)$ time over all $r$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $r\in[0,k-1]$, compute $c_i=(a_i-r)\bmod k$ and $S(r)=\sum c_i$ in $O(k)$.
\item If $n\ge S(r)$, add $\binom{(n-S(r))/k + k - 1}{k-1}$.
\item Sum over $r$ modulo $998{,}244{,}353$.
\end{algosteps}
\COMPLEXITY{$O(k^2)$ time, $O(1)$ extra space besides factorials. Suitable for medium $k$ only.}
\[
\begin{aligned}
T(k) &= O(k^2) + O(F) \quad \text{(precompute factorials $F \approx n/k + k$)} \\
\end{aligned}
\]
\CORRECTNESS{Counts all nonnegative integer vectors with the prescribed residues (per the model).}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

MOD = 998244353

def mod_pow(a, e, mod=MOD):
    r = 1
    while e:
        if e & 1:
            r = r * a % mod
        a = a * a % mod
        e >>= 1
    return r

def precompute_fact(limit):
    fact = [1] * (limit + 1)
    invfact = [1] * (limit + 1)
    for i in range(1, limit + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[limit] = mod_pow(fact[limit], MOD - 2)
    for i in range(limit, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def nCk(n, k, fact, invfact):
    if n < 0 or k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return None
    k = it[0]
    a = it[1:1+k]
    return k, a

def solve_case_naive(k, a):
    n = sum(a)
    # Upper bound for m = (n - S(r))/k
    lim = n // k + k + 5
    fact, invfact = precompute_fact(lim + k + 5)
    ans = 0
    for r in range(k):
        S = 0
        for x in a:
            ci = (x - r) % k
            S += ci
        if n >= S:
            m = (n - S) // k
            ans = (ans + nCk(m + k - 1, k - 1, fact, invfact)) % MOD
    return ans

def solve_all_naive():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    k, a = parsed
    print(solve_case_naive(k, a))

def _tests_naive():
    assert solve_case_naive(3, [0,1,2]) == 3
    assert solve_case_naive(4, [1,1,1,1]) == 5
    # k=2: any split is reachable in this counting; yields n+1
    assert solve_case_naive(2, [5,2]) == 8
    assert solve_case_naive(2, [0,0]) == 1

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _tests_naive()
    else:
        sys.stdout.write(str(solve_case_naive(*read_input(data))) + ("\n" if sys.stdout.isatty() else ""))
\end{minted}
\VALIDATION{Matches small examples; for $k=2$ yields $n+1$ as expected.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Residue-Class Counting with Linear S(r) via Histogram}
\WHICHFORMULA{Compute $S(r)=\sum_i ((a_i-r)\bmod k)$ for all $r$ in total $O(k)$ after building the histogram of remainders $a_i \bmod k$. Then use stars-and-bars to sum binomials.}
\ASSUMPTIONS{All factorials up to $\lfloor n/k \rfloor + k + O(1)$ fit in memory; $n\le 10^6$ and $k\le 10^5$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute remainders $r_i=a_i\bmod k$ and frequency array $\text{freq}[0..k-1]$; let $S(0)=\sum r_i$.
\item For $r=0..k-1$:
  - If $n\ge S(r)$, add $\binom{(n-S(r))/k + k - 1}{k-1}$ to the answer.
  - Update $S(r+1)=S(r) - k + k \cdot \text{freq}[r]$ for next $r$.
\item Output sum modulo $998{,}244{,}353$.
\end{algosteps}
\OPTIMALITY{Sorting is unnecessary; the histogram gives $O(k)$ update per all $r$. Precomputation of factorials is $O(n/k + k) \le O(n + k)$. This meets the input bounds comfortably.}
\COMPLEXITY{Time $O(k + L)$ where $L$ is factorial precompute length; space $O(k + L)$.}
\[
\begin{aligned}
T &\in O\!\left(k + \left\lfloor \frac{n}{k}\right\rfloor + k\right) = O\!\left(k + \frac{n}{k}\right), \\
S &\in O\!\left(k + \left\lfloor \frac{n}{k}\right\rfloor\right).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

MOD = 998244353

def mod_pow(a, e, mod=MOD):
    r = 1
    while e:
        if e & 1:
            r = r * a % mod
        a = a * a % mod
        e >>= 1
    return r

def precompute_fact(limit):
    fact = [1] * (limit + 1)
    invfact = [1] * (limit + 1)
    for i in range(1, limit + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[limit] = mod_pow(fact[limit], MOD - 2)
    for i in range(limit, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def nCk(n, k, fact, invfact):
    if n < 0 or k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return None
    k = it[0]
    a = it[1:1+k]
    return k, a

def solve_case(k, a):
    n = sum(a)
    # freq of remainders
    freq = [0] * k
    rem_sum = 0
    for x in a:
        r = x % k
        freq[r] += 1
        rem_sum += r
    # Precompute factorials up to maximum needed nCk argument:
    # m = (n - S(r)) // k in [0, n//k]; choose m + k - 1
    limit = n // k + k + 5
    fact, invfact = precompute_fact(limit + k + 5)

    ans = 0
    S = rem_sum
    for r in range(k):
        if n >= S:
            m = (n - S) // k
            ans = (ans + nCk(m + k - 1, k - 1, fact, invfact)) % MOD
        if r + 1 < k:
            S = S - k + k * freq[r]
    return ans

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    k, a = parsed
    print(solve_case(k, a))

def _tests_final():
    assert solve_case(3, [0,1,2]) == 3
    assert solve_case(4, [1,1,1,1]) == 5
    # k=2: any split is counted; yields n+1
    assert solve_case(2, [5,2]) == 8

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _tests_final()
    else:
        sys.stdout.write(str(solve_case(*read_input(data))) + ("\n" if sys.stdout.isatty() else ""))
\end{minted}
\VALIDATION{Exactly 3 asserts:
- $k=3$, $[0,1,2]\Rightarrow 3$.
- $k=4$, $[1,1,1,1]\Rightarrow 5$.
- $k=2$, $[5,2]$ (sum $7$) gives $8=n+1$.}
\RESULT{Sum over residue shifts $r$ of the number of $k$-tuples with $b_i\equiv (a_i-r)\bmod k$ and $\sum b_i=n$, computed as stars-and-bars.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit asserts on hand-crafted cases; randomized spot-checks for $k=2$; structural checks for boundary $n=0$.}
\LINE{CROSS-CHECKS}{Compare Approach B vs C on small random instances offline; both implement the same counting but with different $S(r)$ computation.}
\LINE{EDGE-CASE GENERATOR}{Generate small $k$ and small $n$ vectors to ensure modular sums and nonnegativity hold; verify $k=2$ gives $n+1$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_small(k, n):
    # Deterministic: split n into k parts skewed
    a = [0] * k
    for i in range(n):
        a[i % k] += 1
    return a

def reference_solution(k, a):
    # Uses the optimal solver from Approach C
    from math import isfinite
    return solve_case(k, a)

def run_suite():
    # Boundaries
    for k in [2,3,5]:
        a = [0]*k
        assert reference_solution(k, a) >= 1
    # k=2 sweep
    for n in range(0, 12):
        for x in range(n+1):
            k=2
            a=[x, n-x]
            assert reference_solution(k, a) == n+1

if __name__ == "__main__":
    run_suite()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

MOD = 998244353

def mod_pow(a, e, mod=MOD):
    r = 1
    while e:
        if e & 1:
            r = r * a % mod
        a = a * a % mod
        e >>= 1
    return r

def precompute_fact(limit):
    fact = [1] * (limit + 1)
    invfact = [1] * (limit + 1)
    for i in range(1, limit + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[limit] = mod_pow(fact[limit], MOD - 2)
    for i in range(limit, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def nCk(n, k, fact, invfact):
    if n < 0 or k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return None
    k = it[0]
    a = it[1:1+k]
    return k, a

def solve_case(k, a):
    n = sum(a)
    freq = [0] * k
    rem_sum = 0
    for x in a:
        r = x % k
        freq[r] += 1
        rem_sum += r
    limit = n // k + k + 5
    fact, invfact = precompute_fact(limit + k + 5)
    ans = 0
    S = rem_sum
    for r in range(k):
        if n >= S:
            m = (n - S) // k
            ans = (ans + nCk(m + k - 1, k - 1, fact, invfact)) % MOD
        if r + 1 < k:
            S = S - k + k * freq[r]
    return ans

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    k, a = parsed
    print(solve_case(k, a))

def _tests():
    assert solve_case(3, [0,1,2]) == 3
    assert solve_case(4, [1,1,1,1]) == 5
    assert solve_case(2, [5,2]) == 8

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _tests()
    else:
        sys.stdout.write(str(solve_case(*read_input(data))) + ("\n" if sys.stdout.isatty() else ""))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce moves to congruence conditions per color, then count compositions with fixed residues via stars-and-bars, summing over shifts.}
\WHY{Modular-invariant counting appears often in algebraic combinatorics and constructive process problems.}
\CHECKLIST{
- Compute remainders $a_i \bmod k$ and their histogram.
- Initialize $S(0)=\sum (a_i\bmod k)$.
- Iterate $r=0..k-1$, update $S$ in $O(1)$ using the histogram.
- For valid $S$, add $\binom{(n-S)/k + k - 1}{k-1}$ mod $998{,}244{,}353$.
- Precompute factorials once up to needed limit.}
\EDGECASES{
- $n=0$ (only the initial configuration).
- $k=2$ (answer simplifies to $n+1$).
- Many $a_i$ divisible by $k$ (large jumps in $S(r)$).
- Very large $k$ near $10^5$ with small $n$.
- $n < S(r)$ for many $r$ (skip safely).
- All $a_i$ equal.}
\PITFALLS{
- Forgetting to mod $998{,}244{,}353$ at each addition.
- Off-by-one in factorial precompute bounds.
- Miscomputing $S(r+1)$ update: it is $S - k + k \cdot \text{freq}[r]$.
- Using slow $O(k^2)$ $S(r)$ in final solution.
- Integer division when $n < S(r)$ should be skipped.
- Not handling $k=2$ corner correctly when testing.}
\FAILMODES{Naive BFS explodes beyond tiny $n$; naive $O(k^2)$ residue sum times out for $k=10^5$. The optimized histogram update prevents $O(k^2)$ blow-up.}
\ELI{Each move keeps total balls but changes residues in a structured way. By fixing the residue shift, the problem reduces to counting how to allocate blocks of size $k$ among colors so that the small leftover residues add up correctly.}
\NotePages{3}

\end{document}