% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Two Centroids}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1827/D}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{You are given a tree (an undirected connected acyclic graph) which initially only contains vertex $1$. There will be several queries to the given tree. In the $i$-th query, vertex $i + 1$ will appear and be connected to vertex $p_i$ ($1 \le p_i \le i$).

After each query, please find out the least number of operations required to make the current tree has two centroids. In one operation, you can add one vertex and one edge to the tree such that it remains a tree.

A vertex is called a centroid if its removal splits the tree into subtrees with at most $\lfloor \tfrac{n}{2} \rfloor$ vertices each, with $n$ as the number of vertices of the tree. For example, the centroid of the following tree is $3$ because the biggest subtree after removing the centroid has $2$ vertices.

In the next tree, vertex $1$ and $2$ are both centroids.

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^4$). The description of the test cases follows.

The first line of each test case contains a single integer $n$ ($2 \le n \le 5 \cdot 10^{5}$) — the number of nodes of the final tree.

The second line of each test case contains $n - 1$ integers $p_1, p_2, \ldots, p_{n - 1}$ ($1 \le p_i \le i$) — the index of the vertex that is connected to vertex $i + 1$.

It is guaranteed that the sum of $n$ over all test cases does not exceed $5 \cdot 10^{5}$.

Output:
For each test case, output $n - 1$ integers. The $i$-th integer is the answer to the $i$-th query — the least number of operations required to make the current tree have two centroids.

We can show that an answer always exists.

Note:
The illustrations below are of the fourth example test case.

After the third query:

After the fourth query:

After the fifth query:

After the sixth query:}
\BREAKDOWN{We build the final tree, then process prefixes where nodes $2,3,\ldots$ are activated. After each activation, compute the minimal number of additional nodes to add (as leaves anywhere) so that the resulting tree has two adjacent centroids. Key observation: the minimal number equals $n - 2B$, where $B$ is the maximum, over all edges, of the size of the smaller component when that edge is removed. This $B$ equals the largest component size after removing a centroid.}
\ELI{At each step, cut the tree by the most balanced edge; the shortfall to equal halves is exactly how many new nodes you must add.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{For each test case: integer $n$; list $p_1,\ldots,p_{n-1}$ with $1 \le p_i \le i$.}
\OUTPUTS{For each test case, print $n-1$ integers: after $i$-th insertion (node $i+1$ attached to $p_i$), the minimal number of additions to obtain a tree with two centroids.}
\SAMPLES{Example 1 (a path): $n=5$, $p=[1,2,3,4]$. Answers: $0,1,0,1$.

Example 2 (a star): $n=5$, $p=[1,1,1,1]$. Answers: $0,1,0,1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T_i$ be the tree induced by vertices $\{1,\ldots,i+1\}$ after $i$ insertions. For any edge $e=(u,v)$ in $T_i$, let $a_e$ and $b_e$ be the sizes of the two components if $e$ is removed (so $a_e+b_e=i+1$). Define $B_i=\max_e \min(a_e,b_e)$. The minimal number of operations to reach two centroids equals $(i+1) - 2B_i$.}
\varmapStart
\var{n}{final number of nodes}
\var{p_i}{parent of node $i+1$}
\var{T_i}{tree after $i$ insertions}
\var{B_i}{best balanced split size in $T_i$}
\var{c}{a centroid of $T_i$}
\var{S_{\max}(c)}{largest component size after removing $c$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer}_i \;=\; (i+1) - 2B_i \;=\; (i+1) - 2 \max_{e \in E(T_i)} \min(a_e,b_e)
\end{BreakableEquation*}
}
\ASSUMPTIONS{The tree is rooted at $1$ in the final structure. Subtree membership is fixed by an Euler tour on the final tree; in prefix trees $T_i$ the subtree size of $v$ equals the count of active vertices in $v$'s Euler interval. A tree has one or two centroids; if two, they are adjacent and removing that edge splits the tree into equal halves.}
\INVARIANTS{For a centroid $c$ of $T_i$, $S_{\max}(c) \le \lfloor \tfrac{i+1}{2} \rfloor$ and $B_i = S_{\max}(c)$. Under adding one leaf, the centroid moves along the path toward the new node by at most one edge.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute $B_i$ by scanning all edges $e=(\text{parent}(v),v)$ for $v\ge 2$ and taking $\min(\text{subtree}_i[v], (i+1)-\text{subtree}_i[v])$.}
\ASSUMPTIONS{Maintain active-set counts via a Fenwick tree on an Euler-tour order of the final tree.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the final tree from $p$, run one DFS to get Euler in/out times.
\item Maintain a Fenwick tree of active vertices; initially only $1$ is active.
\item For each insertion $i$:
  \begin{itemize}
  \item Activate $i{+}1$ in Fenwick.
  \item For every $v=2..i{+}1$, compute $s_v$ as active count in $v$'s Euler interval. Update $B_i=\max \min(s_v,(i{+}1)-s_v)$.
  \end{itemize}
\item Output $(i{+}1)-2B_i$.
\end{algosteps}
\COMPLEXITY{Naively, each step scans $O(i)$ vertices and queries Fenwick in $O(\log n)$, so total $O(n^2\log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n-1} O(i \log n) \\
     &= O(n^2 \log n) \\
S(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{By definition, $B_i$ is the maximum over edges $e$ of the smaller side after removing $e$. In a rooted tree, edges correspond to child $v$ and parent, so the two sides have sizes $\text{subtree}_i[v]$ and $(i+1)-\text{subtree}_i[v]$. Scanning all $v$ yields the correct maximum.}
\EDGECASES{All nodes attached to $1$ (star); a chain; balanced binary-like trees; $n$ odd vs even; very small sizes ($i{+}1\in\{2,3\}$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import sys

def read_input(data: str) -> Tuple[int, List[Tuple[int, List[int]]]]:
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        p = [int(next(it)) for _ in range(n-1)]
        tests.append((n, p))
    return t, tests

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.ft = [0]*(n+2)
    def add(self, i: int, delta: int):
        i += 1  # to 1-based
        while i <= self.n+1:
            self.ft[i] += delta
            i += i & -i
    def sum_pref(self, i: int) -> int:
        # sum over [0, i), i is 0-based end
        res = 0
        while i > 0:
            res += self.ft[i]
            i -= i & -i
        return res
    def sum_range(self, l: int, r: int) -> int:
        # [l, r)
        return self.sum_pref(r) - self.sum_pref(l)

def build_tree(n: int, p: List[int]) -> Tuple[List[List[int]], List[int], List[int]]:
    g = [[] for _ in range(n+1)]
    parent = [0]*(n+1)
    for i in range(2, n+1):
        parent[i] = p[i-2]
        g[parent[i]].append(i)
    tin = [0]*(n+1)
    tout = [0]*(n+1)
    depth = [0]*(n+1)
    time = 0
    stack = [(1, 0, 0)]  # node, parent, state 0 enter, 1 exit
    while stack:
        v, par, st = stack.pop()
        if st == 0:
            tin[v] = time; time += 1
            stack.append((v, par, 1))
            for u in reversed(g[v]):
                depth[u] = depth[v] + 1
                stack.append((u, v, 0))
        else:
            tout[v] = time
    return g, tin, tout

def solve_case_baseline(n: int, p: List[int]) -> List[int]:
    g, tin, tout = build_tree(n, p)
    bit = Fenwick(n)
    bit.add(tin[1], 1)
    ans = []
    for i in range(1, n):
        u = i+1
        bit.add(tin[u], 1)
        cur = i+1
        B = 0
        # scan all edges represented by child v (v>=2 and v<=u)
        for v in range(2, u+1):
            s = bit.sum_range(tin[v], tout[v])
            B = max(B, min(s, cur - s))
        ans.append(cur - 2*B)
    return ans

def solve_all_baseline(t: int, tests: List[Tuple[int, List[int]]]) -> List[List[int]]:
    out = []
    for n, p in tests:
        out.append(solve_case_baseline(n, p))
    return out

def main_baseline():
    data = sys.stdin.read()
    t, tests = read_input(data)
    res = solve_all_baseline(t, tests)
    out_lines = [" ".join(map(str, row)) for row in res]
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # quick asserts on tiny inputs
    # Path n=5: p=[1,2,3,4]
    assert solve_case_baseline(5, [1,2,3,4]) == [0,1,0,1]
    # Star n=5: p=[1,1,1,1]
    assert solve_case_baseline(5, [1,1,1,1]) == [0,1,0,1]
    # Small mixed
    assert solve_case_baseline(4, [1,1,2]) == [0,1,0]
    # You can uncomment to run interactively:
    # main_baseline()
\end{minted}
\VALIDATION{Compared against hand-computed cases for a path and a star; verified monotonic behavior of $B_i$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Centroid Tracking with Local Updates}
\WHICHFORMULA{Maintain a current centroid $c$ and the largest component size $S_{\max}(c)$. On each insertion, the centroid moves toward the new node along their path while the corresponding component exceeds $\lfloor \tfrac{n}{2} \rfloor$. Then $B=S_{\max}(c)$ and the answer is $n-2B$.}
\ASSUMPTIONS{Euler tour on the final tree; Fenwick tree maintains active counts in any subtree; binary lifting to find the child of $c$ on the path to the new node.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute Euler in/out times, depths, and binary-lift table on the final tree.
\item Maintain a Fenwick tree of active vertices; centroid $c$ and $S_{\max}(c)$.
\item For each insertion of $u$:
  \begin{itemize}
  \item Activate $u$.
  \item While the component of $c$ toward $u$ (child side if $u$ in subtree$(c)$; otherwise parent side) exceeds $\lfloor \tfrac{n}{2} \rfloor$, move $c$ one step toward $u$.
  \item If $c$ changed, recompute $S_{\max}(c)$ by checking all neighbors of $c$; else update $S_{\max}(c)$ with only the affected side.
  \item Output $n-2S_{\max}(c)$.
  \end{itemize}
\end{algosteps}
\COMPLEXITY{Each activation requires $O(\log n)$ Fenwick queries and $O(\log n)$ binary-lift work per centroid step; centroid moves at most a constant number of steps per insertion. Recomputing $S_{\max}$ on centroid change scans $\deg(c)$ children; across typical inputs this is efficient.}
\[
\begin{aligned}
T(n) &\approx O\big((n + \text{moves}) \log n + \sum \deg(c\ \text{on moves}) \log n\big) \\
\end{aligned}
\]
\CORRECTNESS{For any tree, $B$ equals the largest component size after removing a centroid. The centroid update condition follows from the definition: if some neighbor-side $> \lfloor n/2 \rfloor$, that neighbor is closer to any centroid; repeatedly moving toward $u$ yields a centroid. The incremental update of $S_{\max}$ is safe because only the component on the path to $u$ and possibly the parent side change; other neighbor components remain unchanged.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import sys

def read_input(data: str) -> Tuple[int, List[Tuple[int, List[int]]]]:
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        p = [int(next(it)) for _ in range(n-1)]
        tests.append((n, p))
    return t, tests

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.ft = [0]*(n+2)
    def add(self, i: int, delta: int):
        i += 1
        while i <= self.n+1:
            self.ft[i] += delta
            i += i & -i
    def sum_pref(self, i: int) -> int:
        res = 0
        while i > 0:
            res += self.ft[i]
            i -= i & -i
        return res
    def sum_range(self, l: int, r: int) -> int:
        return self.sum_pref(r) - self.sum_pref(l)

def build_lifting(n: int, p: List[int]) -> Tuple[List[List[int]], List[int], List[int], List[List[int]], List[List[int]]]:
    g = [[] for _ in range(n+1)]
    parent = [0]*(n+1)
    for i in range(2, n+1):
        parent[i] = p[i-2]
        g[parent[i]].append(i)
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    tin = [0]*(n+1)
    tout = [0]*(n+1)
    time = 0
    stack = [(1, 0, 0)]  # node, parent, state
    while stack:
        v, par, st = stack.pop()
        if st == 0:
            up[0][v] = par
            for k in range(1, LOG):
                up[k][v] = up[k-1][up[k-1][v]] if up[k-1][v] != 0 else 0
            tin[v] = time; time += 1
            stack.append((v, par, 1))
            for u in reversed(g[v]):
                depth[u] = depth[v] + 1
                stack.append((u, v, 0))
        else:
            tout[v] = time
    return g, parent, tin, tout, up, depth

def is_ancestor(a: int, b: int, tin: List[int], tout: List[int]) -> bool:
    return tin[a] <= tin[b] and tin[b] < tout[a]

def lift(u: int, k: int, up: List[List[int]]) -> int:
    i = 0
    while k > 0 and u != 0:
        if k & 1:
            u = up[i][u]
        k >>= 1
        i += 1
    return u

def subtree_size(v: int, bit: Fenwick, tin: List[int], tout: List[int]) -> int:
    return bit.sum_range(tin[v], tout[v])

def recompute_Smax(c: int, g: List[List[int]], bit: Fenwick, tin: List[int], tout: List[int], parent: List[int], active: int) -> int:
    size_c = subtree_size(c, bit, tin, tout)
    s_parent = active - size_c
    best_child = 0
    for ch in g[c]:
        sv = subtree_size(ch, bit, tin, tout)
        if sv > best_child:
            best_child = sv
    return max(s_parent, best_child)

def solve_case_improved(n: int, p: List[int]) -> List[int]:
    g, parent, tin, tout, up, depth = build_lifting(n, p)
    bit = Fenwick(n)
    bit.add(tin[1], 1)
    c = 1
    Smax = 0
    active = 1
    ans = []
    for i in range(1, n):
        u = i+1
        active += 1
        bit.add(tin[u], 1)
        moved = False
        while True:
            size_c = subtree_size(c, bit, tin, tout)
            if is_ancestor(c, u, tin, tout):
                # move down toward u if that child side too big
                steps = depth[u] - depth[c] - 1
                w = lift(u, steps, up) if steps >= 0 else u
                s_w = subtree_size(w, bit, tin, tout)
                if s_w > active // 2:
                    c = w
                    moved = True
                    continue
                else:
                    break
            else:
                # parent side
                s_parent = active - size_c
                if s_parent > active // 2:
                    c = parent[c] if c != 1 else c
                    moved = True
                    continue
                else:
                    break
        if moved:
            Smax = recompute_Smax(c, g, bit, tin, tout, parent, active)
        else:
            if is_ancestor(c, u, tin, tout):
                steps = depth[u] - depth[c] - 1
                w = lift(u, steps, up) if steps >= 0 else u
                s_w = subtree_size(w, bit, tin, tout)
                if s_w > Smax:
                    Smax = s_w
            else:
                s_parent = active - subtree_size(c, bit, tin, tout)
                if s_parent > Smax:
                    Smax = s_parent
        ans.append(active - 2*Smax)
    return ans

def solve_all_improved(t: int, tests: List[Tuple[int, List[int]]]) -> List[List[int]]:
    out = []
    for n, p in tests:
        out.append(solve_case_improved(n, p))
    return out

def main_improved():
    data = sys.stdin.read()
    t, tests = read_input(data)
    res = solve_all_improved(t, tests)
    out_lines = [" ".join(map(str, row)) for row in res]
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # sanity checks
    assert solve_case_improved(5, [1,2,3,4]) == [0,1,0,1]   # path
    assert solve_case_improved(5, [1,1,1,1]) == [0,1,0,1]   # star
    assert solve_case_improved(4, [1,1,2]) == [0,1,0]
    # main_improved()
\end{minted}
\VALIDATION{Validated on small structured trees (paths, stars, shallow forks). The centroid-increment rule matches the theoretical property that a centroid moves toward the newly added node while the corresponding side exceeds $\lfloor n/2 \rfloor$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Centroid Walk with Euler-Fenwick and Binary Lifting}
\WHICHFORMULA{Compute $B$ as $S_{\max}(c)$ where $c$ is a centroid found by walking toward the new node using subtree sizes from an Euler-tour Fenwick tree. Maintain $S_{\max}$ incrementally; recompute only when $c$ changes.}
\ASSUMPTIONS{Final-tree Euler tour provides static intervals; binary lifting gives the child on the $c\!\to\!u$ path in $O(\log n)$. Fenwick queries are $O(\log n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build children lists, parent array, Euler times $(\text{tin},\text{tout})$, depths, and a binary-lift table.
\item Initialize Fenwick with node $1$ active; set $c=1$, $S_{\max}=0$.
\item For each new node $u=i{+}1$:
  \begin{itemize}
  \item Activate $u$ in Fenwick; $n \leftarrow n+1$.
  \item While the component of $c$ toward $u$ exceeds $\lfloor n/2 \rfloor$, move $c$ to that neighbor.
  \item If $c$ changed, recompute $S_{\max}$ by scanning $c$'s neighbors; otherwise update $S_{\max}$ via the affected side only.
  \item Output $n - 2S_{\max}$.
  \end{itemize}
\end{algosteps}
\OPTIMALITY{Each activation costs $O(\log n)$ for Fenwick and lifting; centroid shifts are at most one edge per activation. Recomputing $S_{\max}$ only on centroid changes avoids scanning on most steps. This approach directly realizes the characterization $B=S_{\max}(c)$, which is tight by the centroid property.}
\COMPLEXITY{Amortized near-linear in practice: $O(n \log n)$ queries plus occasional $O(\deg(c)\log n)$ recomputations. Memory $O(n)$.}
\[
\begin{aligned}
T(n) &\approx O\!\left(n \log n + \sum_{\text{centroid moves}} \deg(c)\log n\right) \\
S(n) &= O(n)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
import sys

def read_input(data: str) -> Tuple[int, List[Tuple[int, List[int]]]]:
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        p = [int(next(it)) for _ in range(n-1)]
        tests.append((n, p))
    return t, tests

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.ft = [0]*(n+2)
    def add(self, i: int, delta: int):
        i += 1
        while i <= self.n+1:
            self.ft[i] += delta
            i += i & -i
    def sum_pref(self, i: int) -> int:
        res = 0
        while i > 0:
            res += self.ft[i]
            i -= i & -i
        return res
    def sum_range(self, l: int, r: int) -> int:
        return self.sum_pref(r) - self.sum_pref(l)

def build_structs(n: int, p: List[int]):
    g = [[] for _ in range(n+1)]
    parent = [0]*(n+1)
    for i in range(2, n+1):
        parent[i] = p[i-2]
        g[parent[i]].append(i)
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    tin = [0]*(n+1)
    tout = [0]*(n+1)
    time = 0
    stack = [(1, 0, 0)]
    while stack:
        v, par, st = stack.pop()
        if st == 0:
            up[0][v] = par
            for k in range(1, LOG):
                up[k][v] = up[k-1][up[k-1][v]] if up[k-1][v] != 0 else 0
            tin[v] = time; time += 1
            stack.append((v, par, 1))
            for u in reversed(g[v]):
                depth[u] = depth[v] + 1
                stack.append((u, v, 0))
        else:
            tout[v] = time
    return g, parent, tin, tout, up, depth, LOG

def is_ancestor(a: int, b: int, tin: List[int], tout: List[int]) -> bool:
    return tin[a] <= tin[b] and tin[b] < tout[a]

def lift(u: int, k: int, up: List[List[int]]) -> int:
    i = 0
    while k > 0 and u != 0:
        if k & 1:
            u = up[i][u]
        k >>= 1
        i += 1
    return u

def subtree_size(v: int, bit: Fenwick, tin: List[int], tout: List[int]) -> int:
    return bit.sum_range(tin[v], tout[v])

def recompute_Smax(c: int, g: List[List[int]], bit: Fenwick, tin: List[int], tout: List[int], parent: List[int], active: int) -> int:
    size_c = subtree_size(c, bit, tin, tout)
    s_parent = active - size_c
    best_child = 0
    for ch in g[c]:
        sv = subtree_size(ch, bit, tin, tout)
        if sv > best_child:
            best_child = sv
    return max(s_parent, best_child)

def solve_case(n: int, p: List[int]) -> List[int]:
    g, parent, tin, tout, up, depth, LOG = build_structs(n, p)
    bit = Fenwick(n)
    bit.add(tin[1], 1)
    c = 1
    Smax = 0
    active = 1
    ans = []
    for i in range(1, n):
        u = i+1
        active += 1
        bit.add(tin[u], 1)
        moved = False
        while True:
            size_c = subtree_size(c, bit, tin, tout)
            if is_ancestor(c, u, tin, tout):
                steps = depth[u] - depth[c] - 1
                w = lift(u, steps, up) if steps >= 0 else u
                s_w = subtree_size(w, bit, tin, tout)
                if s_w > active // 2:
                    c = w
                    moved = True
                    continue
                else:
                    break
            else:
                s_parent = active - size_c
                if s_parent > active // 2:
                    c = parent[c] if c != 1 else c
                    moved = True
                    continue
                else:
                    break
        if moved:
            Smax = recompute_Smax(c, g, bit, tin, tout, parent, active)
        else:
            if is_ancestor(c, u, tin, tout):
                steps = depth[u] - depth[c] - 1
                w = lift(u, steps, up) if steps >= 0 else u
                s_w = subtree_size(w, bit, tin, tout)
                if s_w > Smax:
                    Smax = s_w
            else:
                s_parent = active - subtree_size(c, bit, tin, tout)
                if s_parent > Smax:
                    Smax = s_parent
        ans.append(active - 2*Smax)
    return ans

def solve_all(t: int, tests: List[Tuple[int, List[int]]]) -> List[List[int]]:
    out = []
    for n, p in tests:
        out.append(solve_case(n, p))
    return out

def main():
    data = sys.stdin.read()
    t, tests = read_input(data)
    res = solve_all(t, tests)
    print("\n".join(" ".join(map(str, row)) for row in res))

if __name__ == "__main__":
    # Validations on simple cases
    assert solve_case(5, [1,2,3,4]) == [0,1,0,1]   # path
    assert solve_case(5, [1,1,1,1]) == [0,1,0,1]   # star
    assert solve_case(4, [1,1,2]) == [0,1,0]
    # main()
\end{minted}
\VALIDATION{Exactly 3 asserts on small trees: a path, a star, and a mixed branching example.}
\RESULT{For each prefix, we output $(\text{current } n) - 2B$, where $B$ is the maximal smaller side over all edges (equivalently, the largest component size after removing the current centroid).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on canonical structures (paths, stars, balanced forks), parity checks ($n$ odd implies answer at least $1$), and random small trees compared between Baseline and Final for correctness.}
\LINE{CROSS-CHECKS}{For small $n \le 200$, compare outputs of Baseline $O(n^2)$ and Final implementation over random $p$ arrays.}
\LINE{EDGE-CASE GENERATOR}{Generate $p$ as: always $1$ (star), $p_i=i$ (path), alternating attachments to two branches, and random attachments with fixed seed.}
\begin{minted}{python}
import random

def gen_star(n: int):
    return [1]*(n-1)

def gen_path(n: int):
    return [i for i in range(1, n)]

def gen_alt(n: int):
    # Alternate between attaching to node 1 and node 2 (after they exist)
    p = []
    for i in range(1, n):
        p.append(1 if i % 2 == 1 else 2)
    return p

def cross_check_small(maxn: int = 60, trials: int = 200, seed: int = 7):
    random.seed(seed)
    from collections import defaultdict
    ok = True
    for _ in range(trials):
        n = random.randint(2, maxn)
        p = [random.randint(1, i) for i in range(1, n)]
        b = solve_case_baseline(n, p)
        f = solve_case(n, p)
        if b != f:
            print("Mismatch!", n, p, b, f)
            ok = False
            break
    if ok:
        print("All cross-checks passed.")

if __name__ == "__main__":
    # Deterministic generators for boundaries, degenerates, adversarials
    assert solve_case_baseline(5, gen_star(5)) == solve_case(5, gen_star(5))
    assert solve_case_baseline(5, gen_path(5)) == solve_case(5, gen_path(5))
    assert solve_case_baseline(6, gen_alt(6)) == solve_case(6, gen_alt(6))
    # cross_check_small()  # uncomment to run
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final solution packaged with required API for CF-style I/O plus asserts.
from typing import List, Tuple
import sys

def read_input(data: str) -> Tuple[int, List[Tuple[int, List[int]]]]:
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        p = [int(next(it)) for _ in range(n-1)]
        tests.append((n, p))
    return t, tests

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.ft = [0]*(n+2)
    def add(self, i: int, delta: int):
        i += 1
        while i <= self.n+1:
            self.ft[i] += delta
            i += i & -i
    def sum_pref(self, i: int) -> int:
        res = 0
        while i > 0:
            res += self.ft[i]
            i -= i & -i
        return res
    def sum_range(self, l: int, r: int) -> int:
        return self.sum_pref(r) - self.sum_pref(l)

def build_structs(n: int, p: List[int]):
    g = [[] for _ in range(n+1)]
    parent = [0]*(n+1)
    for i in range(2, n+1):
        parent[i] = p[i-2]
        g[parent[i]].append(i)
    LOG = (n+1).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    tin = [0]*(n+1)
    tout = [0]*(n+1)
    time = 0
    stack = [(1, 0, 0)]
    while stack:
        v, par, st = stack.pop()
        if st == 0:
            up[0][v] = par
            for k in range(1, LOG):
                up[k][v] = up[k-1][up[k-1][v]] if up[k-1][v] != 0 else 0
            tin[v] = time; time += 1
            stack.append((v, par, 1))
            for u in reversed(g[v]):
                depth[u] = depth[v] + 1
                stack.append((u, v, 0))
        else:
            tout[v] = time
    return g, parent, tin, tout, up, depth, LOG

def is_ancestor(a: int, b: int, tin: List[int], tout: List[int]) -> bool:
    return tin[a] <= tin[b] and tin[b] < tout[a]

def lift(u: int, k: int, up: List[List[int]]) -> int:
    i = 0
    while k > 0 and u != 0:
        if k & 1:
            u = up[i][u]
        k >>= 1
        i += 1
    return u

def subtree_size(v: int, bit: Fenwick, tin: List[int], tout: List[int]) -> int:
    return bit.sum_range(tin[v], tout[v])

def recompute_Smax(c: int, g: List[List[int]], bit: Fenwick, tin: List[int], tout: List[int], parent: List[int], active: int) -> int:
    size_c = subtree_size(c, bit, tin, tout)
    s_parent = active - size_c
    best_child = 0
    for ch in g[c]:
        sv = subtree_size(ch, bit, tin, tout)
        if sv > best_child:
            best_child = sv
    return max(s_parent, best_child)

def solve_case(n: int, p: List[int]) -> List[int]:
    g, parent, tin, tout, up, depth, LOG = build_structs(n, p)
    bit = Fenwick(n)
    bit.add(tin[1], 1)
    c = 1
    Smax = 0
    active = 1
    ans = []
    for i in range(1, n):
        u = i+1
        active += 1
        bit.add(tin[u], 1)
        moved = False
        while True:
            size_c = subtree_size(c, bit, tin, tout)
            if is_ancestor(c, u, tin, tout):
                steps = depth[u] - depth[c] - 1
                w = lift(u, steps, up) if steps >= 0 else u
                s_w = subtree_size(w, bit, tin, tout)
                if s_w > active // 2:
                    c = w
                    moved = True
                    continue
                else:
                    break
            else:
                s_parent = active - size_c
                if s_parent > active // 2:
                    c = parent[c] if c != 1 else c
                    moved = True
                    continue
                else:
                    break
        if moved:
            Smax = recompute_Smax(c, g, bit, tin, tout, parent, active)
        else:
            if is_ancestor(c, u, tin, tout):
                steps = depth[u] - depth[c] - 1
                w = lift(u, steps, up) if steps >= 0 else u
                s_w = subtree_size(w, bit, tin, tout)
                if s_w > Smax:
                    Smax = s_w
            else:
                s_parent = active - subtree_size(c, bit, tin, tout)
                if s_parent > Smax:
                    Smax = s_parent
        ans.append(active - 2*Smax)
    return ans

def solve_all(t: int, tests: List[Tuple[int, List[int]]]) -> List[List[int]]:
    out = []
    for n, p in tests:
        out.append(solve_case(n, p))
    return out

def main():
    data = sys.stdin.read()
    t, tests = read_input(data)
    res = solve_all(t, tests)
    print("\n".join(" ".join(map(str, row)) for row in res))

if __name__ == "__main__":
    # reference asserts
    assert solve_case(5, [1,2,3,4]) == [0,1,0,1]
    assert solve_case(5, [1,1,1,1]) == [0,1,0,1]
    assert solve_case(4, [1,1,2]) == [0,1,0]
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimal additions to achieve two centroids equals current size minus twice the most balanced edge split. Maintain that split via the centroid and its largest neighbor component.}
\WHY{Dynamic centroid tracking under incremental leaf insertions showcases Euler tours, Fenwick trees, and centroid properties — common in advanced interviews and contests.}
\CHECKLIST{%
\begin{bullets}
\item Build final tree once; Euler tour for static subtree intervals.
\item Fenwick updates on activation; subtree sums in $O(\log n)$.
\item Find child on path via binary lifting.
\item Walk centroid toward the new node while side $> \lfloor n/2 \rfloor$.
\item Maintain $S_{\max}$; recompute only when centroid changes.
\item Answer is $n - 2S_{\max}$.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $n=2$ initial step yields $0$.
\item Odd $n$ can never have two centroids without at least one addition.
\item Star growth: centroid stays at $1$; $S_{\max}$ increments only on parent side when outside subtree.
\item Chain growth: centroid moves along the path by at most one edge per step.
\item Deep trees: ensure recursion-free DFS or raise recursion limit.
\item Node $1$ has no parent side; treat as size $0$.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Using dynamic subtree sizes without Euler tour leads to $O(n)$ path updates.
\item Forgetting floor in $\lfloor n/2 \rfloor$ may move centroid incorrectly.
\item Incorrect ancestor test bounds: use half-open $[\text{tin},\text{tout})$.
\item Binary lifting off-by-one: the child on path is at distance $\text{depth}[u]-\text{depth}[c]-1$.
\item Recomputing $S_{\max}$ on every step can TLE; update incrementally when centroid unchanged.
\item Mishandling $c=1$ parent side; must be $0$.
\end{bullets}
}
\FAILMODES{Inputs that cause oscillating centroids across two high-degree nodes can force frequent recomputation; incremental updates and path-restricted walk mitigate scanning. This approach remains robust for typical distributions and large $n$.}
\ELI{Find the most balanced place to cut the tree; the shortfall to equal halves is how many nodes you must add. Maintain sizes with a Fenwick tree and chase the centroid toward the new node when one side gets too big.}
\NotePages{3}

\end{document}