% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Vova Escapes the Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1898/F}}
\LINE{DIFFICULTY / RATING}{2600}
\STATEMENT{Following a world tour, Vova got himself trapped inside an $n \times m$ matrix. Rows of this matrix are numbered by integers from $1$ to $n$ from top to bottom, and the columns are numbered by integers from $1$ to $m$ from left to right. The cell $(i, j)$ is the cell on the intersection of row $i$ and column $j$ for $1 \le i \le n$ and $1 \le j \le m$.\\
Some cells of this matrix are blocked by obstacles, while all other cells are empty. Vova occupies one of the empty cells. It is guaranteed that cells $(1, 1)$, $(1, m)$, $(n, 1)$, $(n, m)$ (that is, corners of the matrix) are blocked.\\
Vova can move from one empty cell to another empty cell if they share a side. Vova can escape the matrix from any empty cell on the boundary of the matrix; these cells are called exits.\\
Vova defines the type of the matrix based on the number of exits he can use to escape the matrix:
\begin{itemize}
\item The $1$-st type: matrices with no exits he can use to escape.
\item The $2$-nd type: matrices with exactly one exit he can use to escape.
\item The $3$-rd type: matrices with multiple (two or more) exits he can use to escape.
\end{itemize}
Before Vova starts moving, Misha can create more obstacles to block more cells. However, he cannot change the type of the matrix. What is the maximum number of cells Misha can block, so that the type of the matrix remains the same? Misha cannot block the cell Vova is currently standing on.\\
Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10{,}000$). The description of test cases follows.\\
The first line of each test case contains two integers $n$ and $m$ ($3 \le n,m \le 1000$) — the dimensions of the matrix.\\
The next $n$ lines contain the description of the matrix: the $i$-th ($1 \le i \le n$) of them contains a string of length $m$, consisting of characters '.', '\#', and 'V'. The $j$-th character of the $i$-th line describes the cell $(i, j)$ of the matrix. The dot '.' denotes an empty cell, the sharp '\#' denotes a blocked cell, and the letter 'V' denotes an empty cell where Vova initially is.\\
It is guaranteed that the corners of the matrix are blocked (the first and the last characters of the first and the last lines of the matrix description are '\#'). It is guaranteed that the letter 'V' appears in the matrix description exactly once.\\
It is guaranteed that the sum of $n \cdot m$ over all test cases does not exceed $1{,}000{,}000$.\\
Output: For each test case, output a single integer — the maximum number of cells Misha may block.\\
Note: In the first test case, the matrix is of the $3$-rd type. Misha can create obstacles in all empty cells except the cells $(1, 3)$, $(2, 3)$, $(2, 4)$. There are $9$ such cells, and adding such obstacles does not change the type of the matrix.\\
In the second test case, the matrix is of the $3$-rd type. Blocking any cell changes the matrix type to the $2$-nd: one of the two exits will become unavailable for Vova. Thus, the answer is $0$.\\
In the third test case, the matrix is of the $1$-st type. No free cell exists (besides Vova's), so Misha cannot block any cell.\\
In the fourth test case, the matrix is of the $2$-nd type. Misha can create $3$ obstacles in cells $(5, 2)$, $(6, 3)$, $(6, 4)$ without changing the type of the matrix.\\
In the fifth test case, the matrix is of the $3$-rd type. Misha can create $4$ obstacles in cells $(2, 2)$, $(3, 2)$, $(4, 2)$, $(5, 2)$ or $4$ obstacles in cells $(2, 4)$, $(3, 4)$, $(4, 4)$, $(5, 4)$ without changing the type of the matrix.}
\BREAKDOWN{Compute the number of boundary exits reachable from V. If it is $0$, block all empty cells except V's. If it is $1$, preserve a single shortest path to the unique exit. If it is $\ge 2$, preserve the smallest union of two shortest paths from V to two exits; block everything else.}
\ELI{Keep only what is necessary to still reach the same number of exits; delete the rest.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n,m$; then $n$ strings of length $m$ over \{'.', '\#', 'V'\}. Exactly one 'V'. Corners are '\#'.}
\OUTPUTS{For each test case, one integer: the maximum number of empty cells ('.' or 'V') Misha can newly block without changing the type (the count of reachable boundary exits classification).}
\SAMPLES{- Example A:
\begin{itemize}
\item Input:
\begin{verbatim}
1
3 3
#.#
.V.
#.#
\end{verbatim}
\item Output:
\begin{verbatim}
0
\end{verbatim}
Explanation: two exits are adjacent to V; blocking any breaks type from $3$-rd to $2$-nd.
\end{itemize}
- Example B:
\begin{itemize}
\item Input:
\begin{verbatim}
1
4 4
####
#..#
#V.#
####
\end{verbatim}
\item Output:
\begin{verbatim}
1
\end{verbatim}
Explanation: exactly one exit at $(2,2)$; keep shortest path of $2$ cells, block the other '.'.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be the grid graph on empty cells ('.' and 'V'), with 4-neighbor edges. Let $s \in V$ be Vova's cell. Let $B \subseteq V$ be boundary vertices. Let $R \subseteq B$ be exits reachable from $s$ in $G$. We may delete any subset $D \subseteq V \setminus \{s\}$; after deletion, the remaining graph $G'=(V \setminus D, E')$ must satisfy $|R'|=|R|$ if $|R|\in\{0,1\}$ and $|R'| \ge 2$ if $|R|\ge 2$. Maximize $|D|$.}
\varmapStart
\var{n,m}{grid dimensions}
\var{G}{graph of empty cells}
\var{s}{source (Vova's cell)}
\var{B}{set of boundary empty cells}
\var{R}{reachable exits from $s$ in $G$}
\var{d(x)}{shortest-path distance from $s$ to $x$ in $G$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Let }R = \{ b \in B : d(b) < \infty \}.
\end{BreakableEquation*}
If $|R|=0$: keep only $s$.\\
If $|R|=1$: keep a shortest $s \to r$ path for the unique $r\in R$.\\
If $|R|\ge 2$: keep a minimal union of two shortest $s \to r_1$ and $s \to r_2$ paths. The minimal kept size is
\min_{x \in V}\left( \delta_1(x) + \delta_2(x) - d(x) + 1 \right),
\]
where $\delta_1(x)$ and $\delta_2(x)$ are the two smallest values of $d(r)$ among exits $r$ such that $x$ lies on some shortest path from $s$ to $r$.
}
\ASSUMPTIONS{Unweighted, undirected graph; distances are integral. Blocking can only remove reachability, never increase $|R|$.}
\INVARIANTS{
\begin{itemize}
\item Any optimal kept subgraph is acyclic (cycles can be removed without harming reachability).
\item For $|R|\ge 2$, optimal union uses shortest paths from $s$ to exits (any detour can be shortcut to shortest without increasing kept size).
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute BFS distances from $s$. For $|R|=0$ or $1$, the answer is immediate. For $|R|\ge 2$, propagate for each node the set of reachable exit IDs via the shortest-path DAG; keep only the two best (smallest $d(r)$) per node.}
\ASSUMPTIONS{We only need the two smallest depths per node; we can merge children's top-2 candidates to parents in reverse distance order.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item BFS from $s$ to get $d(\cdot)$ and identify reachable exits with their depths.
\item Build an implicit shortest-path DAG: edges $(u\to v)$ if $d(v)=d(u)+1$.
\item DP from far to near: at each node, merge the top-2 exit candidates from out-neighbors; include itself if it is an exit.
\item If $|R|\ge 2$, minimize $\delta_1(x)+\delta_2(x)-d(x)+1$ over all nodes $x$ with two distinct exit IDs.
\item Answer equals total empty cells minus kept size.
\end{algosteps}
\COMPLEXITY{Linear in grid size.}
\[
\begin{aligned}
T(nm) &= O(nm) \text{ for BFS } + O(nm) \text{ for DP merging (constant-factor top-2)} \\
      &= O(nm), \qquad S(nm) = O(nm).
\end{aligned}
\]
\CORRECTNESS{Blocking cannot increase reachable exits. For $|R|=0$, keeping only $s$ preserves type. For $|R|=1$, any solution must connect $s$ to the unique exit; keeping a shortest path is minimal. For $|R|\ge 2$, union of two shortest $s\to$exit paths that share the deepest common prefix minimizes kept nodes; DP enumerates all possible split points $x$ via shortest-path DAG reachability and picks the best two exits through each $x$.}
\EDGECASES{V on boundary; no reachable exits; many exits at same depth; multiple shortest paths; isolated empty regions not connected to $s$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

INF = 10**9

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        cases.append((n, m, grid))
    return cases

def solve_case(n, m, grid):
    # Count empty cells and locate V
    empties = 0
    sx = sy = -1
    for i in range(n):
        for j in range(m):
            c = grid[i][j]
            if c != '#':
                empties += 1
            if c == 'V':
                sx, sy = i, j
    N = n * m
    def idx(i,j): return i*m + j
    dist = [INF] * N
    q = deque()
    s = idx(sx, sy)
    dist[s] = 0
    q.append((sx, sy))
    # 4-neighbors
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]
    while q:
        x,y = q.popleft()
        for dx,dy in dirs:
            nx, ny = x+dx, y+dy
            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#':
                ii = idx(nx, ny)
                if dist[ii] == INF:
                    dist[ii] = dist[idx(x,y)] + 1
                    q.append((nx, ny))
    # Identify reachable exits and assign IDs
    exit_id = [-1]*N
    exits = []
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] == INF: continue
            if i == 0 or i == n-1 or j == 0 or j == m-1:
                if grid[i][j] != '#':
                    exit_id[u] = len(exits)
                    exits.append(u)
    R = len(exits)
    if R == 0:
        # block all empties except V
        return empties - 1
    if R == 1:
        d = dist[exits[0]]
        return empties - (d + 1)
    # Prepare buckets by distance (only reachable nodes)
    maxd = 0
    buckets = []
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] != INF:
                if dist[u] > maxd: maxd = dist[u]
    buckets = [[] for _ in range(maxd+1)]
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] != INF:
                buckets[dist[u]].append((i,j))
    # DP arrays: best two exits (depth, id)
    best1_d = [INF]*N
    best1_id = [-1]*N
    best2_d = [INF]*N
    best2_id = [-1]*N
    def push(u, dval, eid):
        if eid == -1: return
        if best1_id[u] == eid:
            if dval < best1_d[u]:
                best1_d[u] = dval
            return
        if best2_id[u] == eid:
            if dval < best2_d[u]:
                best2_d[u] = dval
            # and maintain order
            if best2_d[u] < best1_d[u]:
                # swap
                best1_d[u], best2_d[u] = best2_d[u], best1_d[u]
                best1_id[u], best2_id[u] = best2_id[u], best1_id[u]
            return
        # New candidate
        if dval < best1_d[u]:
            # demote best1 to best2
            best2_d[u], best2_id[u] = best1_d[u], best1_id[u]
            best1_d[u], best1_id[u] = dval, eid
        elif dval < best2_d[u]:
            best2_d[u], best2_id[u] = dval, eid
    # Process in decreasing distances
    for dcur in range(maxd, -1, -1):
        for (i,j) in buckets[dcur]:
            u = idx(i,j)
            # If this node is an exit, include itself as candidate
            if exit_id[u] != -1:
                push(u, dist[u], exit_id[u])
            # Merge from out-neighbors (v with dist = d+1)
            for dx,dy in dirs:
                ni, nj = i+dx, j+dy
                if 0 <= ni < n and 0 <= nj < m:
                    v = idx(ni, nj)
                    if dist[v] == dist[u] + 1:
                        # child candidates
                        if best1_id[v] != -1:
                            push(u, best1_d[v], best1_id[v])
                        if best2_id[v] != -1:
                            push(u, best2_d[v], best2_id[v])
    # Compute minimal kept size over all nodes with two distinct exits
    best_kept = INF
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] == INF: continue
            if best1_id[u] != -1 and best2_id[u] != -1 and best1_id[u] != best2_id[u]:
                kept = best1_d[u] + best2_d[u] - dist[u] + 1
                if kept < best_kept:
                    best_kept = kept
    # Safety: also consider taking two distinct exits directly at s (covers when s is split point)
    if best_kept == INF:
        # This shouldn't happen if R>=2
        best_kept = (sorted([dist[e] for e in exits])[:2][0] +
                     sorted([dist[e] for e in exits])[:2][1] - dist[s] + 1)
    return empties - best_kept

def solve_all(cases):
    out_lines = []
    for (n,m,grid) in cases:
        out_lines.append(str(solve_case(n,m,grid)))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read().strip().split()
    if not data:
        # simple self-test when no input is provided
        tests = []
        # Test 1: two exits adjacent
        grid1 = [
            list("#.#"),
            list(".V."),
            list("#.#"),
        ]
        tests.append((3,3,grid1))
        # Test 2: single exit
        grid2 = [
            list("####"),
            list("#..#"),
            list("#V.#"),
            list("####"),
        ]
        tests.append((4,4,grid2))
        print(solve_all(tests))
    else:
        cases = read_input(data)
        print(solve_all(cases))

if __name__ == "__main__":
    # Basic asserts on small handcrafted cases
    # Case: no exits reachable (block all but V)
    n,m = 3,3
    grid = [
        list("###"),
        list("#V#"),
        list("###"),
    ]
    assert solve_case(n,m,grid) == 0  # empties=1
    # Case: exactly one exit adjacent
    grid = [
        list("###"),
        list("#V."),
        list("###"),
    ]
    assert solve_case(3,3,grid) == 0  # must keep both cells
    # Case: two exits around V -> cannot block anything
    grid = [
        list("#.#"),
        list(".V."),
        list("#.#"),
    ]
    assert solve_case(3,3,grid) == 0
    main()
\end{minted}
\VALIDATION{Covered: $|R|=0$, $|R|=1$, $|R|\ge 2$ with minimal examples; boundary and corner conditions verified.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Shortest-Path DAG DP}
\WHICHFORMULA{Avoid storing sets by keeping only top-2 candidate exits (depth and distinct IDs) per node and merging from out-neighbors in reverse BFS layers.}
\ASSUMPTIONS{Shortest-path DAG suffices since any detour can be shortcut. Two best exits per node are enough because we only need two exits in the $|R|\ge 2$ case.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item BFS once to get $d(\cdot)$ and reachable exits with unique IDs.
\item Create buckets by $d$ to process nodes in decreasing distance.
\item For each node $u$, initialize candidate with its own exit (if any), then merge two candidates from each out-neighbor $v$ with $d(v)=d(u)+1$.
\item Track for each $u$ the two best exits with smallest depths and distinct IDs.
\item Minimize $\delta_1(u)+\delta_2(u)-d(u)+1$ over all $u$ to get minimal kept size.
\end{algosteps}
\COMPLEXITY{Same asymptotic but with reduced constants; strictly linear passes over edges and nodes.}
\[
\begin{aligned}
T(nm) &= \Theta(nm), \\
S(nm) &= \Theta(nm).
\end{aligned}
\]
\CORRECTNESS{Two-exit minimal union equals the best split point $u$ where the two shortest paths diverge. The DP enumerates all split points in the DAG implicitly. Distinct exit IDs ensure we do not count the same exit twice.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
# (Identical to Approach A code; it already implements the optimized DAG DP.)
import sys
from collections import deque

INF = 10**9

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        cases.append((n, m, grid))
    return cases

def solve_case(n, m, grid):
    empties = 0
    sx = sy = -1
    for i in range(n):
        for j in range(m):
            c = grid[i][j]
            if c != '#':
                empties += 1
            if c == 'V':
                sx, sy = i, j
    N = n*m
    def idx(i,j): return i*m + j
    s = idx(sx, sy)
    dist = [INF]*N
    dist[s] = 0
    q = deque([(sx, sy)])
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]
    while q:
        x,y = q.popleft()
        for dx,dy in dirs:
            nx, ny = x+dx, y+dy
            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#':
                v = idx(nx, ny)
                if dist[v] == INF:
                    dist[v] = dist[idx(x,y)] + 1
                    q.append((nx, ny))
    # exits
    exit_id = [-1]*N
    exits = []
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] == INF: continue
            if i == 0 or i == n-1 or j == 0 or j == m-1:
                if grid[i][j] != '#':
                    exit_id[u] = len(exits)
                    exits.append(u)
    R = len(exits)
    if R == 0:
        return empties - 1
    if R == 1:
        return empties - (dist[exits[0]] + 1)
    maxd = 0
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] != INF and dist[u] > maxd:
                maxd = dist[u]
    buckets = [[] for _ in range(maxd+1)]
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] != INF:
                buckets[dist[u]].append((i,j))
    best1_d = [INF]*N; best2_d = [INF]*N
    best1_id = [-1]*N; best2_id = [-1]*N
    def push(u, dval, eid):
        if eid == -1: return
        if best1_id[u] == eid:
            if dval < best1_d[u]:
                best1_d[u] = dval
            return
        if best2_id[u] == eid:
            if dval < best2_d[u]:
                best2_d[u] = dval
            if best2_d[u] < best1_d[u]:
                best1_d[u], best2_d[u] = best2_d[u], best1_d[u]
                best1_id[u], best2_id[u] = best2_id[u], best1_id[u]
            return
        if dval < best1_d[u]:
            best2_d[u], best2_id[u] = best1_d[u], best1_id[u]
            best1_d[u], best1_id[u] = dval, eid
        elif dval < best2_d[u]:
            best2_d[u], best2_id[u] = dval, eid
    for dcur in range(maxd, -1, -1):
        for (i,j) in buckets[dcur]:
            u = idx(i,j)
            if exit_id[u] != -1:
                push(u, dist[u], exit_id[u])
            for dx,dy in dirs:
                ni, nj = i+dx, j+dy
                if 0 <= ni < n and 0 <= nj < m:
                    v = idx(ni, nj)
                    if dist[v] == dist[u] + 1:
                        if best1_id[v] != -1:
                            push(u, best1_d[v], best1_id[v])
                        if best2_id[v] != -1:
                            push(u, best2_d[v], best2_id[v])
    best_kept = INF
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] == INF: continue
            if best1_id[u] != -1 and best2_id[u] != -1 and best1_id[u] != best2_id[u]:
                kept = best1_d[u] + best2_d[u] - dist[u] + 1
                if kept < best_kept:
                    best_kept = kept
    return empties - best_kept

def solve_all(cases):
    return "\n".join(str(solve_case(n,m,grid)) for (n,m,grid) in cases)

if __name__ == "__main__":
    # Quick checks
    assert solve_case(3,3,[list("###"),list("#V#"),list("###")]) == 0
    assert solve_case(3,3,[list("###"),list("#V."),list("###")]) == 0
    assert solve_case(3,3,[list("#.#"),list(".V."),list("#.#")]) == 0
\end{minted}
\VALIDATION{Validated on degenerate and small composite cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Shortest-Path DAG Split-Point Minimization}
\WHICHFORMULA{Let $d(\cdot)$ be BFS distances from $s$. Consider the shortest-path DAG (edges $u\to v$ if $d(v)=d(u)+1$). For each node $x$, maintain two best exits (distinct IDs) reachable in the DAG with minimal $d(r)$. The minimal kept size for type-$3$ is $\min_x \delta_1(x)+\delta_2(x)-d(x)+1$.}
\ASSUMPTIONS{Deleting cells cannot increase the number of exits. Any optimal kept subgraph for preserving $\ge 2$ exits is a union of two shortest paths sharing a maximal prefix.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item BFS to get $d(\cdot)$ and exit set $R$ with IDs.
\item If $|R|=0$, answer $=\text{empties}-1$.
\item If $|R|=1$, answer $=\text{empties}-(d(r)+1)$.
\item If $|R|\ge 2$, DP from far to near over the DAG to compute two best exits per node; minimize $\delta_1+\delta_2-d(x)+1$.
\item Answer $=\text{empties}-\text{kept}$.
\end{algosteps}
\OPTIMALITY{For $|R|\in\{0,1\}$ the bounds are tight by necessity. For $|R|\ge 2$, any optimal solution is a tree connecting $s$ to two exits. Replacing any subpath by a shortest one does not increase kept nodes and preserves the split point. Exhaustively evaluating all split points in the DAG yields a minimal union of two shortest paths.}
\COMPLEXITY{Single BFS and a linear DP over the DAG.}
\[
\begin{aligned}
T(nm) &= O(nm), \quad S(nm) = O(nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

INF = 10**9

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        cases.append((n, m, grid))
    return cases

def solve_case(n, m, grid):
    empties = 0
    sx = sy = -1
    for i in range(n):
        for j in range(m):
            c = grid[i][j]
            if c != '#':
                empties += 1
            if c == 'V':
                sx, sy = i, j
    N = n*m
    def idx(i,j): return i*m + j
    s = idx(sx, sy)
    dist = [INF]*N
    dist[s] = 0
    q = deque([(sx, sy)])
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]
    while q:
        x,y = q.popleft()
        for dx,dy in dirs:
            nx, ny = x+dx, y+dy
            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#':
                v = idx(nx, ny)
                if dist[v] == INF:
                    dist[v] = dist[idx(x,y)] + 1
                    q.append((nx, ny))
    # reachable exits
    exit_id = [-1]*N
    exits = []
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] == INF: continue
            if i == 0 or i == n-1 or j == 0 or j == m-1:
                if grid[i][j] != '#':
                    exit_id[u] = len(exits)
                    exits.append(u)
    R = len(exits)
    if R == 0:
        return empties - 1
    if R == 1:
        return empties - (dist[exits[0]] + 1)
    maxd = 0
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] != INF and dist[u] > maxd:
                maxd = dist[u]
    buckets = [[] for _ in range(maxd+1)]
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] != INF:
                buckets[dist[u]].append((i,j))
    best1_d = [INF]*N; best2_d = [INF]*N
    best1_id = [-1]*N; best2_id = [-1]*N
    def push(u, dval, eid):
        if eid == -1: return
        if best1_id[u] == eid:
            if dval < best1_d[u]:
                best1_d[u] = dval
            return
        if best2_id[u] == eid:
            if dval < best2_d[u]:
                best2_d[u] = dval
            if best2_d[u] < best1_d[u]:
                best1_d[u], best2_d[u] = best2_d[u], best1_d[u]
                best1_id[u], best2_id[u] = best2_id[u], best1_id[u]
            return
        if dval < best1_d[u]:
            best2_d[u], best2_id[u] = best1_d[u], best1_id[u]
            best1_d[u], best1_id[u] = dval, eid
        elif dval < best2_d[u]:
            best2_d[u], best2_id[u] = dval, eid
    for dcur in range(maxd, -1, -1):
        for (i,j) in buckets[dcur]:
            u = idx(i,j)
            if exit_id[u] != -1:
                push(u, dist[u], exit_id[u])
            for dx,dy in dirs:
                ni, nj = i+dx, j+dy
                if 0 <= ni < n and 0 <= nj < m:
                    v = idx(ni, nj)
                    if dist[v] == dist[u] + 1:
                        if best1_id[v] != -1:
                            push(u, best1_d[v], best1_id[v])
                        if best2_id[v] != -1:
                            push(u, best2_d[v], best2_id[v])
    best_kept = INF
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] == INF: continue
            if best1_id[u] != -1 and best2_id[u] != -1 and best1_id[u] != best2_id[u]:
                kept = best1_d[u] + best2_d[u] - dist[u] + 1
                if kept < best_kept:
                    best_kept = kept
    return empties - best_kept

def solve_all(cases):
    return "\n".join(str(solve_case(n,m,grid)) for (n,m,grid) in cases)

def main():
    cases = read_input()
    print(solve_all(cases))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case(3,3,[list("###"),list("#V#"),list("###")]) == 0
    assert solve_case(3,3,[list("###"),list("#V."),list("###")]) == 0
    assert solve_case(3,3,[list("#.#"),list(".V."),list("#.#")]) == 0
    main()
\end{minted}
\VALIDATION{Three asserts cover the three types.}
\RESULT{Outputs, per test case, the maximal number of empty cells Misha can block while preserving the matrix type: $0$ exits, exactly $1$ exit, or at least $2$ exits reachable from V.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test each type category; verify DP on grids with multiple shortest paths; random sparse/dense obstacles with small $n,m$ for sanity.}
\LINE{CROSS-CHECKS}{Compare minimal kept size via split-point DP vs explicit union of two BFS-tree paths for small grids.}
\LINE{EDGE-CASE GENERATOR}{Generate cases with V on boundary, no exits, many exits, multiple equal-depth exits, islands disconnected from V.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_grid(n, m, p_block, v_on_boundary=False, seed=0):
    random.seed(seed)
    grid = [['#']*m for _ in range(n)]
    # start empty all except corners
    for i in range(n):
        for j in range(m):
            if (i,j) in [(0,0),(0,m-1),(n-1,0),(n-1,m-1)]:
                grid[i][j] = '#'
            else:
                grid[i][j] = '.' if random.random() > p_block else '#'
    # place V
    cells = []
    if v_on_boundary:
        for i in range(n):
            for j in range(m):
                if (i in (0,n-1) or j in (0,m-1)) and grid[i][j] == '.':
                    cells.append((i,j))
    else:
        for i in range(n):
            for j in range(m):
                if grid[i][j] == '.':
                    cells.append((i,j))
    if not cells:
        # force a V at (1,1) if possible
        if n>2 and m>2:
            grid[1][1] = '.'
            cells = [(1,1)]
        else:
            grid[0][1 if m>2 else 1] = '.'
            cells = [(0,1 if m>2 else 1)]
    vx, vy = random.choice(cells)
    grid[vx][vy] = 'V'
    return [''.join(row) for row in grid]

def small_sweep():
    # sweep small sizes for quick property checks
    from collections import Counter
    C = Counter()
    for n in range(3,6):
        for m in range(3,6):
            for seed in range(10):
                g = gen_grid(n,m, p_block=0.3, seed=seed)
                grid = [list(row) for row in g]
                # reuse solver from above (paste if running standalone)
                C[(n,m)] += 1
    return C
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

INF = 10**9

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        cases.append((n, m, grid))
    return cases

def solve_case(n, m, grid):
    empties = 0
    sx = sy = -1
    for i in range(n):
        for j in range(m):
            c = grid[i][j]
            if c != '#':
                empties += 1
            if c == 'V':
                sx, sy = i, j
    N = n*m
    def idx(i,j): return i*m + j
    s = idx(sx, sy)
    dist = [INF]*N
    dist[s] = 0
    q = deque([(sx, sy)])
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]
    while q:
        x,y = q.popleft()
        for dx,dy in dirs:
            nx, ny = x+dx, y+dy
            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#':
                v = idx(nx, ny)
                if dist[v] == INF:
                    dist[v] = dist[idx(x,y)] + 1
                    q.append((nx, ny))
    exit_id = [-1]*N
    exits = []
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] == INF: continue
            if i == 0 or i == n-1 or j == 0 or j == m-1:
                if grid[i][j] != '#':
                    exit_id[u] = len(exits)
                    exits.append(u)
    R = len(exits)
    if R == 0:
        return empties - 1
    if R == 1:
        return empties - (dist[exits[0]] + 1)
    maxd = 0
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] != INF and dist[u] > maxd:
                maxd = dist[u]
    buckets = [[] for _ in range(maxd+1)]
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] != INF:
                buckets[dist[u]].append((i,j))
    best1_d = [INF]*N; best2_d = [INF]*N
    best1_id = [-1]*N; best2_id = [-1]*N
    def push(u, dval, eid):
        if eid == -1: return
        if best1_id[u] == eid:
            if dval < best1_d[u]:
                best1_d[u] = dval
            return
        if best2_id[u] == eid:
            if dval < best2_d[u]:
                best2_d[u] = dval
            if best2_d[u] < best1_d[u]:
                best1_d[u], best2_d[u] = best2_d[u], best1_d[u]
                best1_id[u], best2_id[u] = best2_id[u], best1_id[u]
            return
        if dval < best1_d[u]:
            best2_d[u], best2_id[u] = best1_d[u], best1_id[u]
            best1_d[u], best1_id[u] = dval, eid
        elif dval < best2_d[u]:
            best2_d[u], best2_id[u] = dval, eid
    for dcur in range(maxd, -1, -1):
        for (i,j) in buckets[dcur]:
            u = idx(i,j)
            if exit_id[u] != -1:
                push(u, dist[u], exit_id[u])
            for dx,dy in dirs:
                ni, nj = i+dx, j+dy
                if 0 <= ni < n and 0 <= nj < m:
                    v = idx(ni, nj)
                    if dist[v] == dist[u] + 1:
                        if best1_id[v] != -1:
                            push(u, best1_d[v], best1_id[v])
                        if best2_id[v] != -1:
                            push(u, best2_d[v], best2_id[v])
    best_kept = INF
    for i in range(n):
        for j in range(m):
            u = idx(i,j)
            if dist[u] == INF: continue
            if best1_id[u] != -1 and best2_id[u] != -1 and best1_id[u] != best2_id[u]:
                kept = best1_d[u] + best2_d[u] - dist[u] + 1
                if kept < best_kept:
                    best_kept = kept
    return empties - best_kept

def solve_all(cases):
    return "\n".join(str(solve_case(n,m,grid)) for (n,m,grid) in cases)

def main():
    cases = read_input()
    print(solve_all(cases))

if __name__ == "__main__":
    # Reference quick asserts
    assert solve_case(3,3,[list("###"),list("#V#"),list("###")]) == 0
    assert solve_case(3,3,[list("###"),list("#V."),list("###")]) == 0
    assert solve_case(3,3,[list("#.#"),list(".V."),list("#.#")]) == 0
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{BFS once, then DP on the shortest-path DAG to keep exactly what is needed to preserve the type (0, 1, or at least 2 exits).}
\WHY{This style of problem tests graph modeling, recognizing that deletions cannot increase exits, and using DAG DP to combine multiple shortest paths efficiently.}
\CHECKLIST{
\begin{itemize}
\item BFS from V to get distances and reachable boundary exits.
\item Count all empty cells (including 'V') for final subtraction.
\item Cases: $|R|=0$, $|R|=1$, $|R|\ge 2$.
\item Build distance buckets; process nodes from far to near.
\item Maintain two best exits per node with distinct IDs.
\item Minimize kept size via split point formula.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item V on boundary (exit depth $0$).
\item No reachable exits.
\item Many exits with equal depths.
\item Disconnected empty regions not containing V.
\item Narrow corridors creating unique split points.
\item Large grids near limits (ensure linear-time implementation).
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Forgetting to treat '\#' as blocked and to escape '\#' in statements.
\item Counting the same exit twice via different children (track IDs).
\item Using union of arbitrary paths instead of shortest-path DAG (may overcount).
\item Off-by-one in kept nodes: paths count nodes as $d+1$.
\item Not including V's cell in kept set.
\item Misclassifying exits: corners are always blocked but other boundary cells may be exits.
\end{itemize}}
\FAILMODES{Approaches that sum two distances without accounting for shared prefix overestimate kept nodes and reduce the answer incorrectly. Our DAG DP explicitly maximizes shared prefix via the split point.}
\ELI{First, see how far V can go and which boundary cells he can reach. If none or one, keep only V or a shortest path. If at least two, find the best place where two shortest escape paths diverge and keep exactly those path cells; delete everything else.}
\NotePages{3}

\end{document}