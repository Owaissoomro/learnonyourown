% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximize the Largest Component (Hard Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1985/H2}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{Easy and hard versions are actually different problems, so read statements of both problems completely and carefully. The only difference between the two versions is the operation.

Alex has a grid with $n$ rows and $m$ columns consisting of '.' and '\#' characters. A set of '\#' cells forms a connected component if from any cell in this set, it is possible to reach any other cell in this set by only moving to another cell in the set that shares a common side. The size of a connected component is the number of cells in the set.

In one operation, Alex selects any row $r$ ($1 \le r \le n$) and any column $c$ ($1 \le c \le m$), then sets every cell in row $r$ and column $c$ to be '\#'. Help Alex find the maximum possible size of the largest connected component of '\#' cells that he can achieve after performing the operation at most once.

Input:
The first line of the input contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases.

The first line of each test case contains two integers $n$ and $m$ ($1 \le n \cdot m \le 10^6$) — the number of rows and columns of the grid.

The next $n$ lines each contain $m$ characters. Each character is either '.' or '\#'.

It is guaranteed that the sum of $n \cdot m$ over all test cases does not exceed $10^6$.

Output:
For each test case, output a single integer — the maximum possible size of a connected component of '\#' cells that Alex can achieve.

Note:
In the fourth test case, it is optimal for Alex to set all cells in row $4$ and column $2$ to be '\#'. Doing so will lead to the largest connected component of '\#' having a size of $16$.

In the fifth test case, it is optimal for Alex to set all cells in row $2$ and column $4$ to be '\#'. Doing so will lead to the largest connected component of '\#' having a size of $22$.}
\BREAKDOWN{Compute, for each choice of a row $r$ and a column $c$, the size of the union of: the filled band (row $r$ and column $c$) and all initial '\#' components that touch that band. Maximize over all pairs. Precompute initial connected components to aggregate sizes efficiently.}
\ELI{Turning a whole row and a whole column into '\#' creates a plus sign that glues together all nearby '\#' blobs; count how big that glued blob can get.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases:
- $t$: integer, number of test cases, $1 \le t \le 10^4$.
- For each test: integers $n, m$ with $1 \le n \cdot m \le 10^6$.
- Grid of $n$ strings of length $m$, characters in $\{'.', '\#'\}$.
The sum of $n \cdot m$ over all tests is $\le 10^6$.}
\OUTPUTS{For each test case, a single integer: the maximum possible size of the largest connected component of '\#' cells after performing the operation at most once.}
\SAMPLES{Example 1:
- Input:
t=1; $n=1$, $m=3$; grid: .\#.
- One optimal operation is $r=1, c=2$, resulting in final answer $3$.

Example 2:
- Input:
t=1; $n=2$, $m=2$; grid:
.\\
.\#\\
- Optimal operation $r=2, c=1$ yields all four '\#' connected, answer $4$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G \subseteq [n] \times [m]$ be the set of initial '\#' cells. Let $\mathcal{C} = \{C_1,\ldots,C_k\}$ be the 4-connected components of $G$ with sizes $s_i = |C_i|$. For a choice $(r,c)$, define the ``band'' $B(r,c) = (\{r\} \times [m]) \cup ([n] \times \{c\})$. After the operation, the largest connected component contains the union of:
- $B(r,c)$, and
- all components $C_i$ that are 4-adjacent to $B(r,c)$ (i.e., $C_i$ has a cell sharing a side with some cell of $B(r,c)$ or lies on $B(r,c)$).}
\varmapStart
\var{n,m}{grid dimensions}
\var{G}{initial '\#' set}
\var{\mathcal{C}}{components of $G$}
\var{s_i}{size of component $C_i$}
\var{R_i=[r_i^{\min},r_i^{\max}],~C_i=[c_i^{\min},c_i^{\max}]}{row/column spans of $C_i$}
\var{r,c}{chosen row and column}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{A component } C_i \text{ is activated by } (r,c)
&\iff r \in [r_i^{\min}-1,r_i^{\max}+1] \ \text{ or }\ c \in [c_i^{\min}-1,c_i^{\max}+1],\\
\text{band\_dots}(r,c) &= \#\{\text{'.' in row } r\} + \#\{\text{'.' in column } c\} - \mathbf{1}[\text{grid}[r,c] = '.'],\\
F(r,c) &= \sum_{i : r \in [r_i^{\min}-1,r_i^{\max}+1]} s_i + \sum_{i : c \in [c_i^{\min}-1,c_i^{\max}+1]} s_i \\
&\quad - \sum_{i : r \in [r_i^{\min}-1,r_i^{\max}+1],\ c \in [c_i^{\min}-1,c_i^{\max}+1]} s_i \\
&\quad + \text{band\_dots}(r,c),\\
\text{Answer} &= \max_{1 \le r \le n,\, 1 \le c \le m} F(r,c).
\end{aligned}
\]
}
\ASSUMPTIONS{Components are 4-connected; projections of a connected component onto row and column axes are contiguous intervals. Indexing is $1$-based conceptually; implementation may use $0$-based.}
\INVARIANTS{Activation criterion uses expanded intervals $[r_i^{\min}-1,r_i^{\max}+1]$, $[c_i^{\min}-1,c_i^{\max}+1]$. The ``band\_dots'' counts only new cells turned into '\#', disjoint from initial components.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the operation for each pair $(r,c)$ and compute the largest connected '\#' component by BFS/DFS.}
\ASSUMPTIONS{Works only for very small $n \cdot m$ due to $O(nm)$ simulations each costing $O(nm)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $(r,c)$, clone the grid; set row $r$ and column $c$ to '\#'.
\item Run BFS/DFS to find the size of the largest connected '\#' component.
\item Track the maximum over all $(r,c)$.
\end{algosteps}
\COMPLEXITY{Brute force over all pairs and full BFS per pair.}
\[
\begin{aligned}
T(n,m) &= O\big((n m) \cdot (n m)\big) = O(n^2 m^2),\\
S(n,m) &= O(n m).
\end{aligned}
\]
\CORRECTNESS{By construction, it enumerates all possible operations and computes the exact largest component after each operation.}
\EDGECASES{All '.'; all '\#'; single cell; single row/column; non-rectangular blobs.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        tests.append((n, m, grid))
    return tests

def largest_component_after_op_bruteforce(n, m, grid):
    def bfs_max(g):
        seen = [[False]*m for _ in range(n)]
        best = 0
        for i in range(n):
            for j in range(m):
                if g[i][j] == '#' and not seen[i][j]:
                    q = deque([(i, j)])
                    seen[i][j] = True
                    sz = 0
                    while q:
                        x, y = q.popleft()
                        sz += 1
                        for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):
                            nx, ny = x+dx, y+dy
                            if 0 <= nx < n and 0 <= ny < m and g[nx][ny] == '#' and not seen[nx][ny]:
                                seen[nx][ny] = True
                                q.append((nx, ny))
                    best = max(best, sz)
        return best

    ans = 0
    for r in range(n):
        for c in range(m):
            g = [row[:] for row in grid]
            for j in range(m):
                g[r][j] = '#'
            for i in range(n):
                g[i][c] = '#'
            ans = max(ans, bfs_max(g))
    return ans

def solve_case_baseline(n, m, grid):
    return largest_component_after_op_bruteforce(n, m, grid)

def solve_all_baseline():
    tests = read_input()
    out_lines = []
    for (n, m, grid) in tests:
        out_lines.append(str(solve_case_baseline(n, m, grid)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Tiny sanity tests for the baseline
    tests = [
        (1, 1, [['.']], 1),
        (1, 1, [['#']], 1),
        (2, 2, [['.', '#'], ['#', '.']], 4),
    ]
    for n, m, g, exp in tests:
        got = solve_case_baseline(n, m, [row[:] for row in g])
        assert got == exp, (got, exp)
\end{minted}
\VALIDATION{Validated on tiny cases: single cell empty/full; 2x2 anti-diagonal pattern connects to 4.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Precompute Components; Per-Pair Set Union}
\WHICHFORMULA{Compute connected components and their sizes; for each $(r,c)$ aggregate sizes of components touching rows $r-1,r,r+1$ or columns $c-1,c,c+1$ using hash sets to avoid double counting.}
\ASSUMPTIONS{Distinct component IDs; hash-based deduplication per pair.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute component ID grid and for each component its size.
\item For each row $r$, store the set of component IDs seen in rows $r-1,r,r+1$.
\item For each column $c$, store the set of component IDs seen in columns $c-1,c,c+1$.
\item For each $(r,c)$, union the two sets, sum sizes, and add the number of '.' in the band.
\end{algosteps}
\COMPLEXITY{Beats brute force only when per-row/col sets are small; worst-case can still be large.}
\[
\begin{aligned}
T(n,m) &\approx O(n m) \text{ for components } + \sum_{r,c} (|R_r| + |C_c|),\\
S(n,m) &\approx O(n m) \text{ for grids and sets.}
\end{aligned}
\]
\CORRECTNESS{Union of components adjacent to the band matches the definition; deduplication prevents double-counting.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque, defaultdict
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        tests.append((n, m, grid))
    return tests

def components_with_ids(n, m, grid):
    comp = [[-1]*m for _ in range(n)]
    sizes = []
    q = deque()
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '#' and comp[i][j] == -1:
                cid = len(sizes)
                comp[i][j] = cid
                q.append((i, j))
                sz = 0
                while q:
                    x, y = q.popleft()
                    sz += 1
                    for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):
                        nx, ny = x+dx, y+dy
                        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '#' and comp[nx][ny] == -1:
                            comp[nx][ny] = cid
                            q.append((nx, ny))
                sizes.append(sz)
    return comp, sizes

def solve_case_improved(n, m, grid):
    comp, sizes = components_with_ids(n, m, grid)
    k = len(sizes)
    row_sets = [set() for _ in range(n)]
    col_sets = [set() for _ in range(m)]
    for i in range(n):
        for j in range(m):
            if comp[i][j] != -1:
                for di in (-1, 0, 1):
                    ri = i + di
                    if 0 <= ri < n:
                        row_sets[ri].add(comp[i][j])
                for dj in (-1, 0, 1):
                    cj = j + dj
                    if 0 <= cj < m:
                        col_sets[cj].add(comp[i][j])
    size_of = sizes
    dot_row = [row.count('.') for row in grid]
    dot_col = [sum(1 for i in range(n) if grid[i][j] == '.') for j in range(m)]
    ans = 0
    for r in range(n):
        sum_r = sum(size_of[cid] for cid in row_sets[r])
        for c in range(m):
            sum_c = sum(size_of[cid] for cid in col_sets[c])
            inter = 0
            if len(row_sets[r]) < len(col_sets[c]):
                for cid in row_sets[r]:
                    if cid in col_sets[c]:
                        inter += size_of[cid]
            else:
                for cid in col_sets[c]:
                    if cid in row_sets[r]:
                        inter += size_of[cid]
            band_dots = dot_row[r] + dot_col[c] - (1 if grid[r][c] == '.' else 0)
            ans = max(ans, sum_r + sum_c - inter + band_dots)
    return ans

def solve_all_improved():
    tests = read_input()
    out_lines = []
    for (n, m, grid) in tests:
        out_lines.append(str(solve_case_improved(n, m, grid)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Small validation
    n, m, g = 1, 1, [['.']]
    assert solve_case_improved(n, m, g) == 1
    n, m, g = 1, 1, [['#']]
    assert solve_case_improved(n, m, g) == 1
    n, m, g = 2, 2, [['.', '#'], ['#', '.']]
    assert solve_case_improved(n, m, g) == 4
\end{minted}
\VALIDATION{Cross-check on tiny cases against baseline; both return 1, 1, and 4 respectively.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Component Intervals + 1D/2D Difference via Row Sweep}
\WHICHFORMULA{Use the identity
$F(r,c) = \underbrace{\text{rowSum}[r]}_{\sum s_i : r \in [r_i^{\min}-1,r_i^{\max}+1]} + \underbrace{\text{colSum}[c]}_{\sum s_i : c \in [c_i^{\min}-1,c_i^{\max}+1]} - \underbrace{\text{inter}[r,c]}_{\sum s_i : r,c \in \text{expanded rect of } C_i} + \text{band\_dots}(r,c)$.
Compute:
- rowSum via 1D difference over expanded row intervals,
- colSum via 1D difference over expanded column intervals,
- inter via a row sweep maintaining a column difference array with add/remove rectangle events.}
\ASSUMPTIONS{Projections of 4-connected components on rows and columns are contiguous intervals; expanded intervals clamp to grid boundaries.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute connected components, their sizes $s_i$, and spans $[r_i^{\min},r_i^{\max}]$, $[c_i^{\min},c_i^{\max}]$ via BFS/DFS.
\item For each component, expand by $1$ in both directions and clamp: $rL=\max(0,r_i^{\min}-1)$, $rR=\min(n-1,r_i^{\max}+1)$, likewise $cL,cR$.
\item 1D rowSum: range-add $s_i$ on $[rL,rR]$; prefix to get rowSum[$r$]. Similarly colSum on $[cL,cR]$.
\item Prepare row-sweep events: at $r=rL$ add interval $[cL,cR]$ with weight $s_i$; at $r=rR+1$ remove it.
\item Sweep rows. Maintain a column difference array; apply starts/ends at each row; prefix across columns to get inter[$r,c$] on the fly; compute $F(r,c)$ and take maximum.
\end{algosteps}
\OPTIMALITY{Each component is counted iff it touches the filled band; double counts across row/column are subtracted exactly by the rectangle coverage at $(r,c)$. The sweep achieves $O(nm)$ total time over the grid plus linear event processing, which is optimal up to constants under the input bound.}
\COMPLEXITY{Linear in grid size plus number of components.}
\[
\begin{aligned}
T(n,m) &= O(n m) \text{ (BFS)} + O(k) \text{ (events)} + O(n m) \text{ (row sweep)} = O(n m),\\
S(n,m) &= O(n m) \text{ for grids} + O(k) \text{ for component metadata}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).decode()) for _ in range(n)]
        tests.append((n, m, grid))
    return tests

def compute_components(n, m, grid):
    comp_id = [[-1]*m for _ in range(n)]
    sizes = []
    minr = []
    maxr = []
    minc = []
    maxc = []
    q = deque()
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '#' and comp_id[i][j] == -1:
                cid = len(sizes)
                comp_id[i][j] = cid
                q.append((i, j))
                sz = 0
                rmin = i; rmax = i; cmin = j; cmax = j
                while q:
                    x, y = q.popleft()
                    sz += 1
                    if x < rmin: rmin = x
                    if x > rmax: rmax = x
                    if y < cmin: cmin = y
                    if y > cmax: cmax = y
                    for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):
                        nx, ny = x+dx, y+dy
                        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '#' and comp_id[nx][ny] == -1:
                            comp_id[nx][ny] = cid
                            q.append((nx, ny))
                sizes.append(sz)
                minr.append(rmin); maxr.append(rmax)
                minc.append(cmin); maxc.append(cmax)
    return sizes, minr, maxr, minc, maxc

def solve_case(n, m, grid):
    sizes, minr, maxr, minc, maxc = compute_components(n, m, grid)
    k = len(sizes)

    # Precompute dot counts
    dot_row = [row.count('.') for row in grid]
    dot_col = [sum(1 for i in range(n) if grid[i][j] == '.') for j in range(m)]

    # 1D rowSum via difference
    row_diff = [0]*(n+1)
    # 1D colSum via difference
    col_diff = [0]*(m+1)

    # Row-sweep events for inter[r][c]
    starts = [[] for _ in range(n)]
    ends = [[] for _ in range(n+1)]  # removal at rR+1

    for i in range(k):
        rL = minr[i]-1
        rR = maxr[i]+1
        cL = minc[i]-1
        cR = maxc[i]+1
        if rL < 0: rL = 0
        if rR >= n: rR = n-1
        if cL < 0: cL = 0
        if cR >= m: cR = m-1

        w = sizes[i]
        row_diff[rL] += w
        row_diff[rR+1] -= w if rR+1 <= n-1 else 0  # guard; we sized n+1 so direct safe
        # Actually simpler:
        # If rR+1 <= n, we can do row_diff[rR+1] -= w
        if rR+1 <= n:
            row_diff[rR+1] -= w

        col_diff[cL] += w
        if cR+1 <= m:
            col_diff[cR+1] -= w

        starts[rL].append((cL, cR, w))
        if rR+1 <= n-1:
            ends[rR+1].append((cL, cR, w))

    # Fix diff boundaries (ensure no out-of-range ops above left residuals)
    # Compute rowSum and colSum
    row_sum = [0]*n
    run = 0
    for r in range(n):
        run += row_diff[r]
        row_sum[r] = run
    col_sum = [0]*m
    run = 0
    for c in range(m):
        run += col_diff[c]
        col_sum[c] = run

    # Sweep rows to compute inter[r][c] and final best
    col_diff_active = [0]*(m+1)
    ans = 0
    for r in range(n):
        # apply start events
        for (cL, cR, w) in starts[r]:
            col_diff_active[cL] += w
            if cR+1 <= m-1:
                col_diff_active[cR+1] -= w
        # apply end events
        for (cL, cR, w) in ends[r]:
            col_diff_active[cL] -= w
            if cR+1 <= m-1:
                col_diff_active[cR+1] += w
        # compute inter on the fly
        acc = 0
        row_contrib = row_sum[r]
        band_row_dots = dot_row[r]
        gr = grid[r]
        for c in range(m):
            acc += col_diff_active[c]
            inter = acc
            val = row_contrib + col_sum[c] - inter
            # add band dots
            val += band_row_dots + dot_col[c] - (1 if gr[c] == '.' else 0)
            if val > ans:
                ans = val
    return ans

def solve_all():
    tests = read_input()
    out_lines = []
    for (n, m, grid) in tests:
        out_lines.append(str(solve_case(n, m, grid)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Exactly 3 asserts (mini-tests)
    assert solve_case(1, 1, [['.']]) == 1
    assert solve_case(1, 1, [['#']]) == 1
    assert solve_case(2, 2, [['.', '#'], ['#', '.']]) == 4
\end{minted}
\VALIDATION{Asserts: (1) single '.', result $1$; (2) single '\#', result $1$; (3) 2x2 anti-diagonal, result $4$.}
\RESULT{The printed integer per test case is the maximum achievable size of the largest 4-connected '\#' component after optionally applying one operation (choosing any row and any column to fill with '\#').}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on degenerate grids (all '.', all '\#'), tiny random grids, and patterned cases (checkerboard, stripes). Cross-verify approaches A, B, C on small sizes.}
\LINE{CROSS-CHECKS}{For $n,m \le 5$, enumerate all $(r,c)$ with Approach A and compare to Approach C results; they must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate random $n,m \in [1,5]$, fill grid with Bernoulli($p$) for '\#' with $p \in \{0.0,0.2,0.5,0.8,1.0\}$, validate.}
\begin{minted}{python}
import random
from collections import deque

def gen_grid(n, m, p):
    return [['#' if random.random() < p else '.' for _ in range(m)] for _ in range(n)]

def brute(n, m, grid):
    def bfs_max(g):
        seen = [[False]*m for _ in range(n)]
        best = 0
        for i in range(n):
            for j in range(m):
                if g[i][j] == '#' and not seen[i][j]:
                    q = deque([(i, j)])
                    seen[i][j] = True
                    sz = 0
                    while q:
                        x, y = q.popleft()
                        sz += 1
                        for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):
                            nx, ny = x+dx, y+dy
                            if 0 <= nx < n and 0 <= ny < m and g[nx][ny] == '#' and not seen[nx][ny]:
                                seen[nx][ny] = True
                                q.append((nx, ny))
                    best = max(best, sz)
        return best
    ans = 0
    for r in range(n):
        for c in range(m):
            g = [row[:] for row in grid]
            for j in range(m):
                g[r][j] = '#'
            for i in range(n):
                g[i][c] = '#'
            ans = max(ans, bfs_max(g))
    return ans

def test_cross_small(trials=200):
    for _ in range(trials):
        n = random.randint(1, 4)
        m = random.randint(1, 4)
        p = random.choice([0.0, 0.2, 0.5, 0.8, 1.0])
        g = gen_grid(n, m, p)
        assert brute(n, m, g) == solve_case(n, m, [row[:] for row in g])

if __name__ == "__main__":
    # Run small randomized cross-checks
    test_cross_small(50)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final solver using component intervals + row sweep
from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).decode()) for _ in range(n)]
        tests.append((n, m, grid))
    return tests

def compute_components(n, m, grid):
    comp_id = [[-1]*m for _ in range(n)]
    sizes = []
    minr = []
    maxr = []
    minc = []
    maxc = []
    q = deque()
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '#' and comp_id[i][j] == -1:
                cid = len(sizes)
                comp_id[i][j] = cid
                q.append((i, j))
                sz = 0
                rmin = i; rmax = i; cmin = j; cmax = j
                while q:
                    x, y = q.popleft()
                    sz += 1
                    if x < rmin: rmin = x
                    if x > rmax: rmax = x
                    if y < cmin: cmin = y
                    if y > cmax: cmax = y
                    for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):
                        nx, ny = x+dx, y+dy
                        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '#' and comp_id[nx][ny] == -1:
                            comp_id[nx][ny] = cid
                            q.append((nx, ny))
                sizes.append(sz)
                minr.append(rmin); maxr.append(rmax)
                minc.append(cmin); maxc.append(cmax)
    return sizes, minr, maxr, minc, maxc

def solve_case(n, m, grid):
    sizes, minr, maxr, minc, maxc = compute_components(n, m, grid)
    k = len(sizes)

    dot_row = [row.count('.') for row in grid]
    dot_col = [sum(1 for i in range(n) if grid[i][j] == '.') for j in range(m)]

    row_diff = [0]*(n+1)
    col_diff = [0]*(m+1)
    starts = [[] for _ in range(n)]
    ends = [[] for _ in range(n+1)]

    for i in range(k):
        rL = minr[i]-1
        rR = maxr[i]+1
        cL = minc[i]-1
        cR = maxc[i]+1
        if rL < 0: rL = 0
        if rR >= n: rR = n-1
        if cL < 0: cL = 0
        if cR >= m: cR = m-1
        w = sizes[i]
        row_diff[rL] += w
        row_diff[rR+1] -= w
        col_diff[cL] += w
        col_diff[cR+1] -= w
        starts[rL].append((cL, cR, w))
        ends[rR+1].append((cL, cR, w))

    # Prefix to get rowSum and colSum
    row_sum = [0]*n
    run = 0
    for r in range(n):
        run += row_diff[r]
        row_sum[r] = run
    col_sum = [0]*m
    run = 0
    for c in range(m):
        run += col_diff[c]
        col_sum[c] = run

    col_diff_active = [0]*(m+1)
    ans = 0
    for r in range(n):
        for (cL, cR, w) in starts[r]:
            col_diff_active[cL] += w
            col_diff_active[cR+1] -= w
        for (cL, cR, w) in ends[r]:
            col_diff_active[cL] -= w
            col_diff_active[cR+1] += w
        acc = 0
        row_contrib = row_sum[r]
        band_row_dots = dot_row[r]
        gr = grid[r]
        for c in range(m):
            acc += col_diff_active[c]
            inter = acc
            val = row_contrib + col_sum[c] - inter
            val += band_row_dots + dot_col[c] - (1 if gr[c] == '.' else 0)
            if val > ans:
                ans = val
    return ans

def solve_all():
    tests = read_input()
    out_lines = []
    for (n, m, grid) in tests:
        out_lines.append(str(solve_case(n, m, grid)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Final sanity asserts
    assert solve_case(1, 1, [['.']]) == 1
    assert solve_case(1, 1, [['#']]) == 1
    assert solve_case(2, 2, [['.', '#'], ['#', '.']]) == 4
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Glue all initially existing '\#' components that touch the filled row or column; add newly filled '.' cells in the band; maximize over $(r,c)$.}
\WHY{Combines flood-fill, interval reasoning, and difference-array sweeps; a classic pattern for grid + union-of-rectangles aggregates.}
\CHECKLIST{
\begin{bullets}
\item Compute components, sizes, and row/col spans.
\item Build expanded intervals (clamped).
\item 1D differences for rowSum, colSum.
\item Row sweep with column difference for inter.
\item Add band '.' counts and take max.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All '.' grid: answer $m + n - 1$.
\item All '\#': answer $n \times m$.
\item Single row or single column.
\item Components touching exactly one side of the band (only row or only column).
\item Sparse isolated single-cell components (many small rectangles).
\item Large blob with tiny satellites near the band.
\item Intersection cell '.' vs '\#' handling in band dots.
\item Boundaries: $r=1$ or $r=n$, $c=1$ or $c=m$ (clamping expanded intervals).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to clamp expanded intervals to $[0,n-1]$ or $[0,m-1]$.
\item Double-counting components that touch both row and column (missing inter subtraction).
\item Miscounting band '.' intersection at $(r,c)$.
\item Using bounding boxes without ensuring connectivity (here valid due to contiguity of projections).
\item Memory blow-ups with naive 2D arrays; prefer row sweep with 1D column diff.
\item Off-by-one with difference arrays at $rR+1$, $cR+1$.
\end{bullets}
}
\FAILMODES{Naive set-union per pair can time out when per-row/col sets are large. Full 2D difference array of size $(n+1)\times(m+1)$ can exhaust memory; the row sweep avoids this.}
\ELI{Think of each '\#' blob as casting a ``shadow'' on rows and columns when you expand by one. The band at $(r,c)$ activates blobs whose shadows cover $r$ or $c$; subtract blobs counted twice, and add the brand-new '#' cells in the cross.}
\NotePages{3}

\end{document}