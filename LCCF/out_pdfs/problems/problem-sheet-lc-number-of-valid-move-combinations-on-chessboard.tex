% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Number of Valid Move Combinations On Chessboard}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/number-of-valid-move-combinations-on-chessboard/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{There is an $8\times 8$ chessboard containing $n$ pieces (rooks, queens, or bishops). You are given a string array ``pieces'' of length $n$, where ``pieces[i]'' describes the type (rook, queen, or bishop) of the $i$th piece. In addition, you are given a 2D integer array ``positions'' also of length $n$, where ``positions[i] = [r_i, c_i]'' indicates that the $i$th piece is currently at the \textbf{1-based} coordinate $(r_i, c_i)$ on the chessboard.

When making a move for a piece, you choose a destination square that the piece will travel toward and stop on.
\begin{bullets}
\item A rook can only travel \textbf{horizontally or vertically} from $(r,c)$ to the direction of $(r+1,c)$, $(r-1,c)$, $(r,c+1)$, or $(r,c-1)$.
\item A queen can only travel \textbf{horizontally, vertically, or diagonally} from $(r,c)$ to the direction of $(r+1,c)$, $(r-1,c)$, $(r,c+1)$, $(r,c-1)$, $(r+1,c+1)$, $(r+1,c-1)$, $(r-1,c+1)$, $(r-1,c-1)$.
\item A bishop can only travel \textbf{diagonally} from $(r,c)$ to the direction of $(r+1,c+1)$, $(r+1,c-1)$, $(r-1,c+1)$, $(r-1,c-1)$.
\end{bullets}

You must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the $0$th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square. Return the number of valid move combinations.

Notes:
\begin{bullets}
\item No two pieces will start in the same square.
\item You may choose the square a piece is already on as its destination.
\item If two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second.
\end{bullets}

Examples:

Input: pieces $=$ [``rook''], positions $=$ [[1,1]]. Output: $15$.

Input: pieces $=$ [``queen''], positions $=$ [[1,1]]. Output: $22$.

Input: pieces $=$ [``bishop''], positions $=$ [[4,3]]. Output: $12$.

Constraints:
\begin{bullets}
\item $n == \text{pieces.length}$
\item $n == \text{positions.length}$
\item $1 \le n \le 4$
\item ``pieces'' only contains the strings ``rook'', ``queen'', and ``bishop''.
\item There will be at most one queen on the chessboard.
\item $1 \le r_i, c_i \le 8$
\item Each ``positions[i]'' is distinct.
\end{bullets}
}
\BREAKDOWN{Enumerate a destination square for each piece along valid rays (including staying put). For a chosen set of destinations, simulate synchronous motion in unit steps and check that no two pieces share a square at the same time for any $t$. Count all combinations that remain collision-free.}
\ELI{Pick a legal straight-line destination for each piece, then play the moves in lockstep and reject any plan where two pieces ever land on the same square at the same second.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode method signature: Solution.countCombinations(self, pieces: List[str], positions: List[List[int]]) $\to$ int. Valid types: piece types are in $\{\text{``rook''}, \text{``bishop''}, \text{``queen''}\}$; positions are 1-based coordinates in $[1,8]$.}
\OUTPUTS{Return a single integer: the number of valid simultaneous move combinations satisfying the rules.}
\SAMPLES{
Example 1: pieces $=$ [``rook''], positions $=$ [[1,1]] $\Rightarrow 15$.

Example 2: pieces $=$ [``queen''], positions $=$ [[1,1]] $\Rightarrow 22$.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the board be $B=\{1,\ldots,8\}\times\{1,\ldots,8\}$. For each piece $i\in\{1,\ldots,n\}$ with start $s_i\in B$, choose a destination $d_i\in B$ such that $d_i$ lies on one of the allowed rays from $s_i$ for its type (or $d_i=s_i$). For each integer time $t\ge 0$, position evolves as $p_i(t)=s_i + u_i\cdot \min(t, \ell_i)$, where $u_i\in\{-1,0,1\}^2$ is the unit step along the chosen ray and $\ell_i$ is the number of steps from $s_i$ to $d_i$. Validity requires pairwise distinctness of positions at every time.}
\varmapStart
\var{s_i}{start square of piece $i$}
\var{d_i}{destination square of piece $i$}
\var{u_i}{direction unit vector along a valid ray for piece $i$ (or $(0,0)$)}
\var{\ell_i}{number of unit steps from $s_i$ to $d_i$}
\var{p_i(t)}{position of piece $i$ at time $t$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i\ne j,\ \forall t\in\{0,1,\ldots,7\}:\quad p_i(t)\ne p_j(t),
\end{BreakableEquation*}
\begin{BreakableEquation*}
p_i(t) = s_i + u_i\cdot \min(t,\ell_i),\quad \ell_i=\max(|d_i^r-s_i^r|,|d_i^c-s_i^c|).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Discrete time, unit-speed motion; once a piece reaches $d_i$, it remains there. Time horizon $t\in[0,7]$ suffices since the maximum path length on an $8\times 8$ board is $7$.}
\INVARIANTS{
\begin{bullets}
\item If two pieces move along the same ray with the same direction, their separation is constant; they never collide.
\item Swapping adjacent squares in one step is allowed because positions at integer times are distinct.
\item If a piece sits at its destination from time $t_0$ onward, any later traversal through that square at time $t\ge t_0$ by another piece causes a collision and invalidates the plan.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all legal destinations for each piece; for each cartesian product of destinations, simulate positions $p_i(t)$ for $t=0,\ldots,T$ where $T\le 7$, and test pairwise distinctness at each $t$.}
\ASSUMPTIONS{No blocking except simultaneous occupancy; legal moves are straight rays per piece type; staying in place is allowed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each piece, generate all destinations along valid rays within the board, plus the start square.
\item For each combination of one destination per piece, compute direction unit vectors and lengths.
\item Simulate for $t=0,\ldots,\max\ell_i$ (or $0,\ldots,7$) and check that positions are all distinct; if so, count it.
\end{algosteps}
\COMPLEXITY{Let $b_i$ be the number of destinations of piece $i$ (including staying). Then enumeration is $\prod_i b_i$ and each check costs $O(7\cdot n)$ to form sets and compare sizes. For $n\le 4$ and $b_i\le 28$, worst-case is well under a few million operations.}
\[
\begin{aligned}
T(n) &\in O\!\left(\Bigl(\prod_{i=1}^n b_i\Bigr)\cdot 7 \cdot n\right),\quad S(n)\in O(n). \\
\end{aligned}
\]
\CORRECTNESS{Every legal destination set is considered. The simulation exactly follows the discrete-time rule and rejects if and only if two positions coincide at some integer second.}
\EDGECASES{Single piece; destinations identical for multiple pieces (rejected); swapping adjacent squares; arriving earlier and waiting at destination while others move.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import itertools

class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        # Directions per piece
        DIRS = {
            "rook": [(-1,0),(1,0),(0,-1),(0,1)],
            "bishop": [(-1,-1),(-1,1),(1,-1),(1,1)],
            "queen": [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)],
        }
        n = len(pieces)

        def inb(r: int, c: int) -> bool:
            return 1 <= r <= 8 and 1 <= c <= 8

        # For each piece, precompute all possible destinations (including staying)
        cand = []
        for (ptype, (r, c)) in zip(pieces, positions):
            opts = [(r, c)]  # staying
            for dr, dc in DIRS[ptype]:
                rr, cc = r + dr, c + dc
                while inb(rr, cc):
                    opts.append((rr, cc))
                    rr += dr
                    cc += dc
            cand.append(opts)

        # Helper to compute unit step and distance
        def step_and_dist(s: Tuple[int,int], d: Tuple[int,int]) -> Tuple[int,int,int]:
            sr, sc = s; dr, dc = d
            vr, vc = dr - sr, dc - sc
            if vr == 0 and vc == 0:
                return (0, 0, 0)
            ur = 0 if vr == 0 else (1 if vr > 0 else -1)
            uc = 0 if vc == 0 else (1 if vc > 0 else -1)
            dist = max(abs(vr), abs(vc))
            return (ur, uc, dist)

        # Simulate and count
        ans = 0
        for choice in itertools.product(*cand):
            # Precompute motion parameters
            steps = []
            for s, d in zip(positions, choice):
                ur, uc, dist = step_and_dist((s[0], s[1]), (d[0], d[1]))
                steps.append((ur, uc, dist, s[0], s[1]))
            T = 7  # sufficient time horizon
            ok = True
            for t in range(0, T + 1):
                seen = set()
                for (ur, uc, dist, sr, sc) in steps:
                    k = t if t <= dist else dist
                    rr = sr + ur * k
                    cc = sc + uc * k
                    if (rr, cc) in seen:
                        ok = False
                        break
                    seen.add((rr, cc))
                if not ok:
                    break
            if ok:
                ans += 1
        return ans

# Basic asserts (from the prompt and easy centers)
sol = Solution()
assert sol.countCombinations(["rook"], [[1,1]]) == 15
assert sol.countCombinations(["queen"], [[1,1]]) == 22
assert sol.countCombinations(["bishop"], [[4,3]]) == 12
assert sol.countCombinations(["queen"], [[4,4]]) == 28
assert sol.countCombinations(["bishop"], [[4,4]]) == 14
\end{minted}
\VALIDATION{Checked the three official examples and sanity checks for single-piece counts: rook always $15$ including staying; queen at center is $28$; bishop at $(4,4)$ is $14$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{DFS with Timeline Occupancy Pruning}
\WHICHFORMULA{Instead of checking all full products, do a DFS over pieces. For each candidate path, check per-time occupancy against a global timeline map to prune early when any collision appears.}
\ASSUMPTIONS{Time horizon fixed to $0..7$; precompute, for each piece and each destination, the full per-time path clamped after arrival.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute, for each piece, a list of candidate per-time paths $P[t]$ of length $8$ ($t=0,\ldots,7$), staying at destination after arrival.
\item DFS over pieces $i=0\ldots n-1$:
  at depth $i$, try each candidate path; if for any $t$ the square is already occupied at time $t$, prune.
\item Upon placing all $n$ paths without conflict, increment the answer.
\end{algosteps}
\COMPLEXITY{Same worst-case bound as brute force, but strong average pruning since most conflicts are detected early at shallow depths.}
\[
\begin{aligned}
T(n) &\le \sum_{\text{partial choices}} \mathbf{1}[\text{no conflict so far}] \\
\end{aligned}
\]
\CORRECTNESS{Per-time occupancy ensures exactly the same collision criterion as the simulation; pruning cannot discard valid completions because it only rejects on actual conflicts at some time $t$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        DIRS = {
            "rook": [(-1,0),(1,0),(0,-1),(0,1)],
            "bishop": [(-1,-1),(-1,1),(1,-1),(1,1)],
            "queen": [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)],
        }
        n = len(pieces)

        def inb(r: int, c: int) -> bool:
            return 1 <= r <= 8 and 1 <= c <= 8

        # Precompute for each piece all candidate per-time paths P[t] for t=0..7
        candidates: List[List[List[Tuple[int,int]]]] = []
        for (ptype, (r, c)) in zip(pieces, positions):
            plist: List[List[Tuple[int,int]]] = []
            # staying
            stay = [(r, c)] * 8
            plist.append(stay)
            # rays
            for dr, dc in DIRS[ptype]:
                rr, cc = r + dr, c + dc
                steps = 1
                while inb(rr, cc):
                    path = []
                    for t in range(8):
                        k = t if t <= steps else steps
                        pr = r + dr * k
                        pc = c + dc * k
                        path.append((pr, pc))
                    plist.append(path)
                    rr += dr; cc += dc; steps += 1
            candidates.append(plist)

        # DFS with timeline occupancy
        occ = [set() for _ in range(8)]
        ans = 0

        def dfs(i: int) -> None:
            nonlocal ans
            if i == n:
                ans += 1
                return
            for path in candidates[i]:
                # fast prune if any time collides
                bad = False
                for t in range(8):
                    if path[t] in occ[t]:
                        bad = True
                        break
                if bad:
                    continue
                # place
                for t in range(8):
                    occ[t].add(path[t])
                dfs(i + 1)
                # unplace
                for t in range(8):
                    occ[t].remove(path[t])

        dfs(0)
        return ans

# Asserts: examples and sanity
sol = Solution()
assert sol.countCombinations(["rook"], [[1,1]]) == 15
assert sol.countCombinations(["queen"], [[1,1]]) == 22
assert sol.countCombinations(["bishop"], [[4,3]]) == 12
assert sol.countCombinations(["queen"], [[4,4]]) == 28
assert sol.countCombinations(["bishop"], [[4,4]]) == 14
\end{minted}
\VALIDATION{Matches baseline results on examples; pruning keeps the search small for $n\le 4$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Canonical DFS with Precomputed Paths and Per-Time Hashing}
\WHICHFORMULA{Use the $0..7$ timeline occupancy hash plus piece ordering that improves pruning (e.g., sort by number of candidate paths descending). This is effectively optimal for the given constraints.}
\ASSUMPTIONS{Finite horizon $8$ timestamps; motion clamped after arrival; sort pieces to prune early.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each piece, build all candidate paths of length $8$ as in Approach B.
\item Sort pieces by descending number of candidates to maximize early pruning.
\item DFS with an array of $8$ hash-sets storing occupied squares at each time; place paths greedily if no per-time conflict.
\end{algosteps}
\OPTIMALITY{Given $n\le 4$ and a maximum of $28$ destinations per queen, the state space is tiny. The per-time hashing converts collision checks to $O(1)$ average per time step, and sorting yields strong early cuts. Any asymptotically faster method is unnecessary and unlikely given the small constants.}
\COMPLEXITY{Identical big-O to Approach B, but with improved constants thanks to ordering.}
\[
\begin{aligned}
T(n) &\approx \text{pruned product of branching factors} \\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        DIRS = {
            "rook": [(-1,0),(1,0),(0,-1),(0,1)],
            "bishop": [(-1,-1),(-1,1),(1,-1),(1,1)],
            "queen": [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)],
        }

        def inb(r: int, c: int) -> bool:
            return 1 <= r <= 8 and 1 <= c <= 8

        n = len(pieces)
        items = list(zip(pieces, positions))

        # Build candidates per piece: list of paths[t] for t=0..7
        def build_paths(ptype: str, r: int, c: int) -> List[List[Tuple[int,int]]]:
            plist: List[List[Tuple[int,int]]] = []
            # stay
            plist.append([(r, c)] * 8)
            for dr, dc in DIRS[ptype]:
                rr, cc = r + dr, c + dc
                steps = 1
                while inb(rr, cc):
                    path = []
                    for t in range(8):
                        k = t if t <= steps else steps
                        path.append((r + dr * k, c + dc * k))
                    plist.append(path)
                    rr += dr; cc += dc; steps += 1
            return plist

        cands = [build_paths(pt, pos[0], pos[1]) for pt, pos in items]

        # Order pieces by descending branching to prune earlier
        order = sorted(range(n), key=lambda i: -len(cands[i]))
        cands = [cands[i] for i in order]

        occ = [set() for _ in range(8)]
        ans = 0

        def dfs(idx: int) -> None:
            nonlocal ans
            if idx == len(cands):
                ans += 1
                return
            for path in cands[idx]:
                # conflict check
                for t in range(8):
                    if path[t] in occ[t]:
                        break
                else:
                    for t in range(8):
                        occ[t].add(path[t])
                    dfs(idx + 1)
                    for t in range(8):
                        occ[t].remove(path[t])

        dfs(0)
        return ans

# Exact asserts (three required)
sol = Solution()
assert sol.countCombinations(["rook"], [[1,1]]) == 15
assert sol.countCombinations(["queen"], [[1,1]]) == 22
assert sol.countCombinations(["bishop"], [[4,3]]) == 12
\end{minted}
\VALIDATION{Three exact example assertions pass.}
\RESULT{Returns the exact count of valid simultaneous move plans over all legal destinations, rejecting any plan with a same-time collision.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test single-piece cases to match ray counts (rook $15$, bishop center $14$, queen corner $22$, queen center $28$). Then test small multi-piece scenarios including adjacent swaps and potential waiting conflicts.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved vs Final on random seeds of $n\le 3$ by asserting equal counts for identical inputs.}
\LINE{EDGE-CASE GENERATOR}{Generate random pieces, ensure distinct starts, include type variety; cover corners, edges, and center.}
\begin{minted}{python}
from typing import List, Tuple
import random

def gen_positions(n: int) -> List[List[int]]:
    used = set()
    res = []
    while len(res) < n:
        r, c = random.randint(1,8), random.randint(1,8)
        if (r,c) not in used:
            used.add((r,c))
            res.append([r,c])
    return res

def gen_pieces(n: int) -> List[str]:
    kinds = ["rook","bishop","queen"]
    # ensure at most one queen
    arr = []
    q_used = False
    for _ in range(n):
        k = random.choice(kinds)
        if k == "queen":
            if q_used:
                k = random.choice(["rook","bishop"])
            else:
                q_used = True
        arr.append(k)
    return arr
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        DIRS = {
            "rook": [(-1,0),(1,0),(0,-1),(0,1)],
            "bishop": [(-1,-1),(-1,1),(1,-1),(1,1)],
            "queen": [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)],
        }

        def inb(r: int, c: int) -> bool:
            return 1 <= r <= 8 and 1 <= c <= 8

        # Build candidate paths (t=0..7) for a piece at (r,c) with type ptype
        def build_paths(ptype: str, r: int, c: int):
            plist = []
            # stay put
            plist.append([(r, c)] * 8)
            for dr, dc in DIRS[ptype]:
                rr, cc = r + dr, c + dc
                steps = 1
                while inb(rr, cc):
                    path = []
                    for t in range(8):
                        k = t if t <= steps else steps
                        path.append((r + dr * k, c + dc * k))
                    plist.append(path)
                    rr += dr; cc += dc; steps += 1
            return plist

        n = len(pieces)
        cands = [build_paths(pt, pos[0], pos[1]) for pt, pos in zip(pieces, positions)]
        # Sort pieces by descending branching factor for better pruning
        order = sorted(range(n), key=lambda i: -len(cands[i]))
        cands = [cands[i] for i in order]

        occ = [set() for _ in range(8)]
        ans = 0

        def dfs(i: int) -> None:
            nonlocal ans
            if i == len(cands):
                ans += 1
                return
            for path in cands[i]:
                for t in range(8):
                    if path[t] in occ[t]:
                        break
                else:
                    for t in range(8):
                        occ[t].add(path[t])
                    dfs(i + 1)
                    for t in range(8):
                        occ[t].remove(path[t])

        dfs(0)
        return ans

# Reference asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.countCombinations(["rook"], [[1,1]]) == 15
    assert sol.countCombinations(["queen"], [[1,1]]) == 22
    assert sol.countCombinations(["bishop"], [[4,3]]) == 12
    assert sol.countCombinations(["queen"], [[4,4]]) == 28
    assert sol.countCombinations(["bishop"], [[4,4]]) == 14
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count destination assignments such that synchronous unit-step motion never causes a same-time collision at any second.}
\WHY{Combining continuous-looking motion with discrete-time collisions appears in scheduling and simulation questions; pruning via time-indexed occupancy is a common interview pattern.}
\CHECKLIST{
\begin{bullets}
\item Generate all legal ray destinations plus staying.
\item Fix time horizon to $0..7$ and clamp paths after arrival.
\item Use per-time occupancy sets to detect collisions.
\item Consider simultaneous swaps as valid (no same-time overlap).
\item Sort pieces by branching factor to prune early.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Single piece: answer equals number of reachable squares including staying.
\item Two adjacent pieces swapping in one second.
\item Two pieces sharing the same destination (must be rejected).
\item One piece waits at start while another passes through that square later (collision).
\item Longest rays from corners (ensure horizon $7$ covers all).
\item Queen moving diagonally vs. orthogonally; distance calculation correctness.
\item Pieces moving in parallel never collide; ensure no false positives.
\item Pieces reaching destination early and then sitting indefinitely.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to include the ``stay'' option.
\item Using Manhattan distance for diagonals (use $\max(|\Delta r|,|\Delta c|)$).
\item Simulating beyond necessary horizon or too short a horizon.
\item Not clamping position after arrival, causing phantom movement.
\item Mixing 0-based and 1-based board coordinates.
\item Reusing mutable sets without undo in DFS (must unplace).
\item Duplicating queen directions or omitting one diagonal.
\item Treating swap as collision (it is not a collision at integer times).
\end{bullets}
}
\FAILMODES{Brute force without pruning may still pass here but is conceptually weaker; naive pairwise continuous-time reasoning is error-prone. The timeline-hash DFS robustly handles all interactions.}
\ELI{Pick where each piece wants to end up, move everyone one square per second towards that square, and make sure no two pieces are ever on the same square at the same second. Count every choice that satisfies this rule.}
\NotePages{3}

\end{document}