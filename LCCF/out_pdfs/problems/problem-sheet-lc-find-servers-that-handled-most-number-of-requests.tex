% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find Servers That Handled Most Number of Requests}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You have \texttt{k} servers numbered from \texttt{0} to \texttt{k-1} that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but \textbf{cannot handle more than one request at a time}. The requests are assigned to servers according to a specific algorithm:
\begin{bullets}
\item The \texttt{i}-th (0-indexed) request arrives.
\item If all servers are busy, the request is dropped (not handled at all).
\item If the \texttt{(i \% k)}-th server is available, assign the request to that server.
\item Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from \texttt{0} if necessary). For example, if the \texttt{i}-th server is busy, try to assign the request to the \texttt{(i+1)}-th server, then the \texttt{(i+2)}-th server, and so on.
\end{bullets}
You are given a \textbf{strictly increasing} array \texttt{arrival} of positive integers, where \texttt{arrival[i]} represents the arrival time of the \texttt{i}-th request, and another array \texttt{load}, where \texttt{load[i]} represents the load of the \texttt{i}-th request (the time it takes to complete). Your goal is to find the \textbf{busiest server(s)}. A server is considered \textbf{busiest} if it handled the most number of requests successfully among all the servers. Return a list containing the IDs (0-indexed) of the \textbf{busiest server(s)}. You may return the IDs in any order.

\textbf{Example 1:}

\textbf{Input:} \texttt{k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3]}

\textbf{Output:} \texttt{[1]}

\textbf{Explanation:} All of the servers start out available. The first 3 requests are handled by the first 3 servers in order. Request 3 comes in. Server 0 is busy, so it is assigned to the next available server, which is 1. Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped. Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.

\textbf{Example 2:}

\textbf{Input:} \texttt{k = 3, arrival = [1,2,3,4], load = [1,2,1,2]}

\textbf{Output:} \texttt{[0]}

\textbf{Explanation:} The first 3 requests are handled by first 3 servers. Request 3 comes in. It is handled by server 0 since the server is available. Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.

\textbf{Example 3:}

\textbf{Input:} \texttt{k = 3, arrival = [1,2,3], load = [10,12,11]}

\textbf{Output:} \texttt{[0,1,2]}

\textbf{Explanation:} Each server handles a single request, so they are all considered the busiest.

\textbf{Constraints:}
\begin{bullets}
\item \texttt{1 \le k \le }$10^5$
\item \texttt{1 \le arrival.length, load.length \le }$10^5$
\item \texttt{arrival.length == load.length}
\item \texttt{1 \le arrival[i], load[i] \le }$10^9$
\item \texttt{arrival} is \textbf{strictly increasing}.
\end{bullets}}
\BREAKDOWN{Simulate the arrivals in order, releasing servers whose jobs have finished, then assign each incoming request to the smallest-index available server at or after \texttt{i \% k}, wrapping around. Count handled requests per server and return those with maximum count.}
\ELI{Keep track of free servers and busy servers by time; for each request, free finished servers, pick the next suitable free server in round-robin order, and count assignments.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers \texttt{k}; arrays \texttt{arrival}, \texttt{load} of equal length \texttt{n}. Valid ranges: \texttt{1 \le k \le }$10^5$, \texttt{1 \le n \le }$10^5$, \texttt{arrival} strictly increasing, values up to $10^9$.}
\OUTPUTS{A list of 0-indexed server IDs achieving the maximum number of handled requests; order does not matter.}
\SAMPLES{
\begin{bullets}
\item \texttt{k=3, arrival=[1,2,3,4,5], load=[5,2,3,3,3]} $\to$ \texttt{[1]}
\item \texttt{k=3, arrival=[1,2,3], load=[10,12,11]} $\to$ \texttt{[0,1,2]}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $S=\{0,1,\ldots,k-1\}$ be server indices. For each request $i\in\{0,\ldots,n-1\}$ arriving at time $a_i$ with load $l_i$, if there exists an available server $s$ at $a_i$, choose $s$ to be the minimum in the cyclic order starting from $i\bmod k$: that is, minimize $(s - (i\bmod k)) \bmod k$ subject to $s$ available. Assign $i$ to $s$ and mark it busy on $[a_i, a_i+l_i)$. If no server is available, drop $i$. Let $c_s$ be the number of requests assigned to $s$. Output $\{s\in S: c_s=\max_{t\in S} c_t\}$.}
\varmapStart
\var{k}{number of servers}
\var{n}{number of requests}
\var{a_i}{arrival time of request $i$}
\var{l_i}{processing time of request $i$}
\var{c_s}{count of requests handled by server $s$}
\var{B(t)}{set of busy servers at time $t$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{avail}(t) &= S \setminus B(t),\\
\text{choose}(i) &= 
\begin{cases}
\arg\min\limits_{s\in \text{avail}(a_i)} \big((s - (i\bmod k)) \bmod k\big), & \text{if } \text{avail}(a_i)\neq\varnothing,\\
\text{drop}, & \text{otherwise},
\end{cases}\\
B(t) &= \{\,s \mid \exists\ i \text{ assigned to } s \text{ with } t \in [a_i, a_i+l_i)\,\},\\
c_s &= \#\{\,i \mid \text{choose}(i)=s\,\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Arrival times are strictly increasing so at most one event per time instant. Each server processes at most one request at a time; processing intervals are half-open $[a_i,a_i+l_i)$.}
\INVARIANTS{
\begin{bullets}
\item At any time $t$, $B(t)$ and $\text{avail}(t)$ partition $S$.
\item When handling request $i$, all servers with end time $\le a_i$ are freed before assignment.
\item The cyclic order ensures fairness relative to $i\bmod k$ without violating availability.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate time in increasing arrival order; to assign request $i$, linearly probe servers starting from $i\bmod k$ to find the first available one.}
\ASSUMPTIONS{Maintain per-server next-free time; free a server when its next-free time $\le a_i$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize arrays: \texttt{next\_free[s]=0} and \texttt{count[s]=0} for all servers \texttt{s}.
\item For each request \texttt{i} in order:
\begin{bullets}
\item Find the first server \texttt{s} among \texttt{k} candidates in cyclic order starting at \texttt{i \% k} with \texttt{next\_free[s] \le arrival[i]}.
\item If found, assign: set \texttt{next\_free[s]=arrival[i]+load[i]} and increment \texttt{count[s]}.
\item Else, drop the request.
\end{bullets}
\item Return all servers with maximal \texttt{count}.
\end{algosteps}
\COMPLEXITY{Worst case, each of $n$ requests scans up to $k$ servers: $T(n)=\mathcal{O}(nk)$, $S(n)=\mathcal{O}(k)$.}
\[
\begin{aligned}
T(n) &= \sum_{i=0}^{n-1} \mathcal{O}(k) \\
     &= \mathcal{O}(nk).
\end{aligned}
\]
\CORRECTNESS{Linear probing in cyclic order exactly matches the specified assignment rule; the next-free times encode availability at each arrival.}
\EDGECASES{All servers busy (drops), all servers idle, single server, large loads, immediate reassignments when a server becomes free exactly at arrival time.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        n = len(arrival)
        next_free = [0] * k
        count = [0] * k
        for i in range(n):
            t = arrival[i]
            start = i % k
            chosen = -1
            for step in range(k):
                s = (start + step) % k
                if next_free[s] <= t:
                    chosen = s
                    break
            if chosen != -1:
                next_free[chosen] = t + load[i]
                count[chosen] += 1
        maxc = max(count) if k > 0 else 0
        return [i for i, c in enumerate(count) if c == maxc]

# Tiny self-checks (baseline is correct but not optimized)
if __name__ == "__main__":
    sol = Solution()
    assert sol.busiestServers(3, [1,2,3,4,5], [5,2,3,3,3]) == [1]
    assert sol.busiestServers(3, [1,2,3,4], [1,2,1,2]) == [0]
    out = sol.busiestServers(3, [1,2,3], [10,12,11])
    assert sorted(out) == [0,1,2]
\end{minted}
\VALIDATION{Checked the three examples. Also validate equality-at-boundary: server is free exactly at \texttt{arrival[i]} so it can take the request.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Heaps with Cyclic Order via Virtual Indices}
\WHICHFORMULA{Use two heaps: a min-heap of busy servers by finish time to release them on arrival, and a min-heap of available servers keyed by \emph{virtual indices} that realize cyclic order with wrap-around in $\mathcal{O}(\log k)$.}
\ASSUMPTIONS{Virtual index technique: maintain a heap \texttt{avail} of integers; initially push \texttt{0..k-1}. For request \texttt{i}, let \texttt{t = i \% k}. Rotate by moving all \texttt{x < t} to \texttt{x + k}. Pop smallest \texttt{x}, assign server \texttt{s = x \% k}.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain \texttt{busy} as a min-heap of pairs \texttt{(finish\_time, server)}.
\item Maintain \texttt{avail} as a min-heap of integers; initially \texttt{0,1,\ldots,k-1}.
\item For each request \texttt{i}:
\begin{bullets}
\item Free all servers in \texttt{busy} with \texttt{finish\_time \le arrival[i]} by pushing their server index back into \texttt{avail}.
\item Let \texttt{t = i \% k}. While \texttt{avail} not empty and \texttt{avail[0] < t}, pop \texttt{x} and push \texttt{x + k}.
\item If \texttt{avail} empty, drop the request; else pop \texttt{x}, set \texttt{s = x \% k}, assign and push \texttt{(arrival[i]+load[i], s)} into \texttt{busy}, increment \texttt{count[s]}.
\end{bullets}
\item Return servers with maximal counts.
\end{algosteps}
\COMPLEXITY{Each request does a constant number of heap operations; each server index increases by at most $k$ per rotation step and is pushed/popped $\mathcal{O}(1)$ amortized per assignment or release. Thus $T(n)=\mathcal{O}(n\log k)$, $S(n)=\mathcal{O}(k)$.}
\[
\begin{aligned}
T(n) &= \mathcal{O}\Big(n \log k + \text{releases}\cdot \log k + \text{rotations}\cdot \log k\Big) = \mathcal{O}(n\log k).
\end{aligned}
\]
\CORRECTNESS{At each arrival, after releasing finished servers, the rotation makes all available indices $\ge t$; the minimum then corresponds to the first available server in cyclic order starting at $t$. Taking $x \bmod k$ yields the true server ID.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        n = len(arrival)
        # avail stores "virtual indices"; start with 0..k-1
        avail = list(range(k))
        heapq.heapify(avail)
        # busy stores (end_time, server_id)
        busy = []
        count = [0] * k

        for i in range(n):
            t = arrival[i]
            # Release all servers that have finished by time t
            while busy and busy[0][0] <= t:
                end, s = heapq.heappop(busy)
                heapq.heappush(avail, s)
            # Rotate avail so that all entries are >= i % k
            threshold = i % k
            while avail and avail[0] < threshold:
                x = heapq.heappop(avail)
                heapq.heappush(avail, x + k)
            if not avail:
                # drop
                continue
            x = heapq.heappop(avail)
            s = x % k
            count[s] += 1
            heapq.heappush(busy, (t + load[i], s))

        maxc = max(count) if k > 0 else 0
        return [i for i, c in enumerate(count) if c == maxc]

# Self-checks (matches LC examples)
if __name__ == "__main__":
    sol = Solution()
    assert sol.busiestServers(3, [1,2,3,4,5], [5,2,3,3,3]) == [1]
    assert sol.busiestServers(3, [1,2,3,4], [1,2,1,2]) == [0]
    assert sorted(sol.busiestServers(3, [1,2,3], [10,12,11])) == [0,1,2]
    # Edge: single server, drops when busy
    assert sol.busiestServers(1, [1,2,3], [2,2,2]) == [0]
\end{minted}
\VALIDATION{Validated on the three provided examples and a single-server edge case that forces drops.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Busy-Heap + Virtual-Index Available Heap}
\WHICHFORMULA{Same as Approach B; this is asymptotically optimal under comparison-based scheduling due to the need to free finished servers and choose the next cyclic minimum among available ones.}
\ASSUMPTIONS{Heaps are standard binary heaps; arrivals are strictly increasing so releases are monotone in time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep min-heap \texttt{busy} keyed by finish time to release servers.
\item Keep min-heap \texttt{avail} of virtual indices. Rotate before assigning each request with threshold \texttt{i \% k}.
\item Assign to \texttt{pop(avail) \% k}; push its new finish into \texttt{busy}; count the assignment.
\end{algosteps}
\OPTIMALITY{Any algorithm must determine which busy servers are finished by each arrival and must select the smallest available index in cyclic order. Maintaining both sets with heaps gives $\mathcal{O}(\log k)$ per event, which is tight up to logarithmic factors without specialized tree structures.}
\COMPLEXITY{$T(n)=\mathcal{O}(n\log k)$, $S(n)=\mathcal{O}(k)$.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(n\log k), \qquad S(n)=\mathcal{O}(k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        n = len(arrival)
        avail = list(range(k))           # virtual indices heap
        heapq.heapify(avail)
        busy: List[tuple[int,int]] = []  # (end_time, server_id)
        count = [0] * k

        for i, t in enumerate(arrival):
            # Release finished servers
            while busy and busy[0][0] <= t:
                end, s = heapq.heappop(busy)
                heapq.heappush(avail, s)
            # Rotate for cyclic order starting at i % k
            threshold = i % k
            while avail and avail[0] < threshold:
                heapq.heappush(avail, heapq.heappop(avail) + k)
            if not avail:
                continue  # drop
            x = heapq.heappop(avail)
            s = x % k
            count[s] += 1
            heapq.heappush(busy, (t + load[i], s))

        maxc = max(count) if k > 0 else 0
        return [i for i, c in enumerate(count) if c == maxc]

if __name__ == "__main__":
    sol = Solution()
    # 1) Given examples
    assert sol.busiestServers(3, [1,2,3,4,5], [5,2,3,3,3]) == [1]
    assert sol.busiestServers(3, [1,2,3,4], [1,2,1,2]) == [0]
    assert sorted(sol.busiestServers(3, [1,2,3], [10,12,11])) == [0,1,2]
\end{minted}
\VALIDATION{Three asserts cover typical flows: wrap-around assignment, immediate reuse, and uniform handling.}
\RESULT{Return all server IDs with maximal handled-request count; any order is acceptable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test core logic on examples; property checks: counts sum equals number of handled requests; no assignment when all are busy; boundary where a server frees exactly at arrival.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline (A) vs Optimal (C) on small random inputs to ensure agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate small \texttt{k} and short increasing \texttt{arrival} with random \texttt{load}, including ties where \texttt{next\_free == arrival[i]}.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random
import heapq

def gen_cases(seed: int = 7) -> List[Tuple[int, List[int], List[int]]]:
    random.seed(seed)
    cases = []
    # Basic
    cases.append((3, [1,2,3,4,5], [5,2,3,3,3]))
    cases.append((3, [1,2,3,4], [1,2,1,2]))
    cases.append((3, [1,2,3], [10,12,11]))
    # Single server stress
    cases.append((1, [1,2,3,4,5], [1,1,1,1,1]))
    # Crafted boundary: frees exactly at arrival
    cases.append((2, [1,3,5,7], [2,2,2,2]))
    # Small randoms
    for n in range(2, 8):
        k = random.randint(1, 5)
        arrival = []
        t = 0
        for _ in range(n):
            t += random.randint(1, 3)
            arrival.append(t)
        load = [random.randint(1, 3) for _ in range(n)]
        cases.append((k, arrival, load))
    return cases

class Baseline:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        next_free = [0] * k
        count = [0] * k
        for i, t in enumerate(arrival):
            start = i % k
            chosen = -1
            for step in range(k):
                s = (start + step) % k
                if next_free[s] <= t:
                    chosen = s
                    break
            if chosen != -1:
                next_free[chosen] = t + load[i]
                count[chosen] += 1
        maxc = max(count) if k > 0 else 0
        return [i for i, c in enumerate(count) if c == maxc]

class Optimal:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        avail = list(range(k))
        heapq.heapify(avail)
        busy = []
        count = [0] * k
        for i, t in enumerate(arrival):
            while busy and busy[0][0] <= t:
                _, s = heapq.heappop(busy)
                heapq.heappush(avail, s)
            thr = i % k
            while avail and avail[0] < thr:
                heapq.heappush(avail, heapq.heappop(avail) + k)
            if not avail:
                continue
            x = heapq.heappop(avail)
            s = x % k
            count[s] += 1
            heapq.heappush(busy, (t + load[i], s))
        maxc = max(count) if k > 0 else 0
        return [i for i, c in enumerate(count) if c == maxc]

def cross_check():
    base = Baseline()
    opt = Optimal()
    for k, arr, ld in gen_cases():
        b = sorted(base.busiestServers(k, arr, ld))
        o = sorted(opt.busiestServers(k, arr, ld))
        assert b == o, (k, arr, ld, b, o)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        """
        Optimal solution: O(n log k) using:
        - busy: min-heap of (end_time, server)
        - avail: min-heap of virtual indices with rotation at threshold i % k
        """
        n = len(arrival)
        avail = list(range(k))
        heapq.heapify(avail)
        busy: List[tuple[int,int]] = []
        count = [0] * k

        for i, t in enumerate(arrival):
            # Release finished servers
            while busy and busy[0][0] <= t:
                _, s = heapq.heappop(busy)
                heapq.heappush(avail, s)
            # Rotate available to respect cyclic start at i % k
            thr = i % k
            while avail and avail[0] < thr:
                heapq.heappush(avail, heapq.heappop(avail) + k)
            # Assign if possible
            if avail:
                x = heapq.heappop(avail)
                s = x % k
                count[s] += 1
                heapq.heappush(busy, (t + load[i], s))
            # else: drop

        maxc = max(count) if k > 0 else 0
        return [i for i, c in enumerate(count) if c == maxc]

if __name__ == "__main__":
    sol = Solution()
    assert sol.busiestServers(3, [1,2,3,4,5], [5,2,3,3,3]) == [1]
    assert sol.busiestServers(3, [1,2,3,4], [1,2,1,2]) == [0]
    assert sorted(sol.busiestServers(3, [1,2,3], [10,12,11])) == [0,1,2]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Release finished servers by arrival time, then pick the first available server at or after \texttt{i \% k} with wrap-around; count assignments and return the max.}
\WHY{Combines event simulation with ordered selection under a cyclic key, a common pattern in scheduling and load-balancing interview problems.}
\CHECKLIST{
\begin{bullets}
\item Free all \texttt{finish\_time \le arrival[i]} before assignment.
\item Compute \texttt{t = i \% k}.
\item Rotate available heap by pushing \texttt{x + k} while \texttt{x < t}.
\item Assign to \texttt{pop(avail) \% k}, push finish into \texttt{busy}.
\item Maintain counts; return all with maximum.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All servers busy at arrival (request dropped).
\item Server becomes free exactly at arrival (\texttt{<=} comparison).
\item \texttt{k=1}.
\item Long loads that span many arrivals.
\item Many simultaneous releases before an arrival.
\item No request handled (all dropped) $\Rightarrow$ return all servers with count 0.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using \texttt{<} instead of \texttt{<=} when freeing busy servers.
\item Forgetting to rotate \texttt{avail} per request against \texttt{i \% k}.
\item Pushing adjusted index back to \texttt{busy} instead of true server ID.
\item Overflow not an issue in Python, but in other languages ensure times fit in 64-bit.
\item Not handling wrap-around correctly if using arrays without the heap rotation trick.
\item Mutating heaps while iterating without heap operations.
\end{bullets}
}
\FAILMODES{A naive linear scan per request can be $\mathcal{O}(nk)$ and time out for $n,k$ up to $10^5$. The heap-based solution remains $\mathcal{O}(n\log k)$.}
\ELI{Think of a line of free servers that you slide so the line starts at \texttt{i \% k}. If the first few servers are before the start, move them to the end. Then pick the first in line, mark it busy until it finishes, and repeat.}
\NotePages{3}

\end{document}