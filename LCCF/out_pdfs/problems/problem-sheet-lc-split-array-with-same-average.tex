% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Split Array With Same Average}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/split-array-with-same-average/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an integer array \texttt{nums}. You should move each element of \texttt{nums} into one of the two arrays \texttt{A} and \texttt{B} such that \texttt{A} and \texttt{B} are non-empty, and \texttt{average(A)} == \texttt{average(B)}. Return \texttt{true} if it is possible to achieve that and \texttt{false} otherwise.

\textbf{Note} that for an array \texttt{arr}, \texttt{average(arr)} is the sum of all the elements of \texttt{arr} over the length of \texttt{arr}.

Example 1:

Input: \texttt{nums = [1,2,3,4,5,6,7,8]} \quad Output: \texttt{true}

Explanation: We can split the array into \texttt{[1,4,5,8]} and \texttt{[2,3,6,7]}, and both of them have an average of 4.5.

Example 2:

Input: \texttt{nums = [3,1]} \quad Output: \texttt{false}

Constraints:
\begin{bullets}
\item \texttt{1 \le nums.length \le 30}
\item \texttt{0 \le nums[i] \le } $10^4$
\end{bullets}}
\BREAKDOWN{Rephrase as finding a non-empty proper subset whose average equals the array average. Reduce to a subset-sum with a rational target by cross-multiplying to integers, then solve via search/DP with pruning.}
\ELI{We want to pick some numbers so their average equals the whole array's average; check if some non-empty group achieves the right total sum for its size.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single array \texttt{nums} of integers.
\begin{bullets}
\item Length \(n\) with \(1 \le n \le 30\).
\item Values satisfy \(0 \le \texttt{nums[i]} \le 10^4\).
\end{bullets}}
\OUTPUTS{Boolean: \texttt{true} if there exists a non-empty proper subset whose average equals the array average; otherwise \texttt{false}.}
\SAMPLES{Examples (LC style):
\begin{bullets}
\item \texttt{nums = [1,2,3,4,5,6,7,8]} \(\to\) \texttt{true}.
\item \texttt{nums = [3,1]} \(\to\) \texttt{false}.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let \(n = |\texttt{nums}|\), \(S = \sum_{i=1}^{n} \texttt{nums}_i\). We seek a non-empty proper subset \(I \subset \{1,\ldots,n\}\) with \(1 \le |I| \le n-1\) such that the average of \(\{\texttt{nums}_i : i \in I\}\) equals the average of the whole array.}
\varmapStart
\var{n}{array length}
\var{S}{total sum \(\sum_i \texttt{nums}_i\)}
\var{I}{index subset chosen for the first group}
\var{k}{subset size \(|I|\)}
\var{T}{target sum for size \(k\), \(T = \dfrac{kS}{n}\)}
\var{b_i}{transformed value \(b_i = n\cdot \texttt{nums}_i - S\)}
\varmapEnd
\GOVERN{
\[
\exists I \subset \{1,\ldots,n\} \text{ with } 1 \le |I| \le n-1 \;\; \text{s.t.} \;\; \frac{\sum_{i \in I}\texttt{nums}_i}{|I|} = \frac{S}{n}
\iff
n \cdot \sum_{i \in I}\texttt{nums}_i = S \cdot |I|.
\]
Equivalently, with \(b_i = n \cdot \texttt{nums}_i - S\), we need \(\sum_{i \in I} b_i = 0\) and \(1 \le |I| \le n-1\).
}
\ASSUMPTIONS{Indices are \(1\)-based in math. Arrays contain integers; averages can be rational. Both groups must be non-empty, so \(1 \le |I| \le n-1\).}
\INVARIANTS{
\begin{bullets}
\item \(\sum_{i=1}^{n} b_i = 0\) by construction.
\item If \(\sum_{i \in I} b_i = 0\), then also \(\sum_{i \notin I} b_i = 0\).
\item A necessary condition: \(\exists k \in \{1,\ldots,n-1\}\) with \((kS) \bmod n = 0\).
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly test all subset sizes \(k \in [1,n-1]\) and check whether any subset of size \(k\) sums to \(T = \tfrac{kS}{n}\) (only when \(kS \equiv 0 \pmod{n}\)).}
\ASSUMPTIONS{Use combinatorial enumeration via \texttt{itertools.combinations}; feasible only for small \(n\) (illustrative baseline).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute \(n\) and \(S\).
\item For each \(k=1,\ldots,n-1\), if \((kS) \bmod n \ne 0\) skip; else set \(T = (kS)/n\).
\item Enumerate all size-\(k\) subsets and test if any has sum \(T\); if yes, return \texttt{True}. If none for all \(k\), return \texttt{False}.
\end{algosteps}
\COMPLEXITY{Worst-case time \(T(n) = \sum_{k=1}^{n-1} \binom{n}{k} = 2^n - 2\); space \(S(n) = O(n)\) for recursion/iteration state.}
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n-1} \binom{n}{k} = 2^n - 2 \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{By exhaustive enumeration, the algorithm checks every non-empty proper subset whose average could match; if any meets the governing equation \(n \cdot \text{sum} = S \cdot k\), it returns \texttt{True}.}
\EDGECASES{All equal elements; \(n=1\) (immediately \texttt{False}); cases with no feasible \(k\) by congruence check.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
import itertools

class Solution:
    def splitArraySameAverage(self, nums: List[int]) -> bool:
        n = len(nums)
        if n <= 1:
            return False
        total = sum(nums)
        # Necessary condition: some k gives integer target
        if not any((k * total) % n == 0 for k in range(1, n)):
            return False
        nums_sorted = sorted(nums)
        for k in range(1, n):
            target_mul = k * total
            if target_mul % n != 0:
                continue
            target = target_mul // n
            # Enumerate all size-k subsets (baseline; exponential)
            for comb in itertools.combinations(nums_sorted, k):
                if sum(comb) == target:
                    return True
        return False

# Baseline sanity checks (small inputs to keep runtime tiny)
s = Solution()
assert s.splitArraySameAverage([1,2,3,4,5,6,7,8]) is True
assert s.splitArraySameAverage([3,1]) is False
assert s.splitArraySameAverage([5,5]) is True  # [5] vs [5]
\end{minted}
\VALIDATION{Checked on the two examples and a trivial equal-pair case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Average-Centered DP by Subset Size (limit to half)}
\WHICHFORMULA{Transform \(b_i = n\cdot \texttt{nums}_i - S\). We seek a non-empty subset with sum \(0\). It suffices to check subset sizes up to \(\lfloor n/2 \rfloor\) because complements mirror zero-sum subsets. Maintain DP sets \(\text{dp}[k]\) of achievable sums using exactly \(k\) elements.}
\ASSUMPTIONS{Use the necessary congruence check to quickly rule out impossible cases. Limit \(k\) to \(\le \lfloor n/2 \rfloor\) to reduce state and prevent the all-elements case.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute \(n\), \(S\); if no \(k \in [1,n-1]\) has \((kS) \bmod n = 0\), return \texttt{False}.
\item Build \(b_i = n\cdot \texttt{nums}_i - S\).
\item Initialize \(\text{dp}[0]=\{0\}\), and for each \(v\) in \(b\), update \(\text{dp}[k] \leftarrow \text{dp}[k] \cup \{u+v : u \in \text{dp}[k-1]\}\) for \(k\) descending to \(1\) up to \(\lfloor n/2 \rfloor\).
\item If \(0 \in \text{dp}[k]\) for any \(k \in [1,\lfloor n/2 \rfloor]\), return \texttt{True}; else \texttt{False}.
\end{algosteps}
\COMPLEXITY{Let \(K = \lfloor n/2 \rfloor\). Each of \(n\) numbers updates at most \(K\) sets; each set holds distinct sums seen so far. In practice, with \(n \le 30\), the total number of tracked sums remains manageable. Space is the total size of all sets.}
\[
\begin{aligned}
T(n) &\approx O\!\left(n \cdot K \cdot W\right), \text{ where } W \text{ is the typical set size per } k, \\
S(n) &\approx O\!\left(\sum_{k=0}^{K} |\text{dp}[k]|\right).
\end{aligned}
\]
\CORRECTNESS{Zero-sum in transformed space is equivalent to equal averages. Restricting to \(k \le \lfloor n/2 \rfloor\) avoids the trivial full-set zero-sum and is complete since complements mirror zero-sum subsets.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def splitArraySameAverage(self, nums: List[int]) -> bool:
        n = len(nums)
        if n <= 1:
            return False
        s = sum(nums)
        # Quick necessary condition filter
        if not any((k * s) % n == 0 for k in range(1, n)):
            return False

        # Transform to centered integers
        b = [x * n - s for x in nums]

        # DP by subset size up to n//2 (avoid using all n elements)
        K = n // 2
        dp = [set() for _ in range(K + 1)]
        dp[0].add(0)

        for v in b:
            # Descend to avoid double-using v in the same round
            for k in range(min(K, len(nums)), 0, -1):
                if dp[k-1]:
                    for u in dp[k-1]:
                        new_sum = u + v
                        if new_sum == 0:
                            return True
                        dp[k].add(new_sum)

        return False

# Improved approach sanity checks
s = Solution()
assert s.splitArraySameAverage([1,2,3,4,5,6,7,8]) is True
assert s.splitArraySameAverage([3,1]) is False
assert s.splitArraySameAverage([2,0,5,6,16,12,15,12,4]) is True  # known LC case
\end{minted}
\VALIDATION{Validated on examples and a known positive case from problem discussions.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Meet-in-the-Middle with Size-Indexed Sum Sets}
\WHICHFORMULA{Split the array into two halves. For each half, compute all subset-sums grouped by subset size. For each feasible total size \(k\) with integer target \(T=\tfrac{kS}{n}\), check whether there exists a left size \(k_\ell\) and right size \(k_r=k-k_\ell\) whose sums add to \(T\). Also check the halves individually for direct hits.}
\ASSUMPTIONS{Use the necessary congruence check; ensure both groups are non-empty by restricting \(1 \le k \le n-1\). Avoid the trivial full-set selection by only considering \(k \le n-1\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute \(n\), \(S\); if no \(k \in [1,n-1]\) satisfies \((kS) \bmod n = 0\), return \texttt{False}.
\item Split \(\texttt{nums}\) into left and right halves of sizes \(m\) and \(n-m\).
\item For each half, build arrays \(\text{SumsLeft}[k]\), \(\text{SumsRight}[k]\) collecting all subset sums of size \(k\).
\item If any \(\text{SumsLeft}[k]\) (or \(\text{SumsRight}[k]\)) contains \(T=\tfrac{kS}{n}\), return \texttt{True}.
\item For each feasible \(k\), iterate \(k_\ell\) in its valid range and test whether there exists \(x \in \text{SumsLeft}[k_\ell]\) with \(T-x \in \text{SumsRight}[k-k_\ell]\). If any hit, return \texttt{True}.
\item Otherwise, return \texttt{False}.
\end{algosteps}
\OPTIMALITY{Meet-in-the-middle reduces the exponential factor from \(2^n\) to approximately \(2^{n/2}\) per side, with efficient set lookups. This is essentially optimal for NP-hard subset-style searches under typical assumptions.}
\COMPLEXITY{Let \(m=\lfloor n/2 \rfloor\).
\[
\begin{aligned}
T(n) &\approx O\!\left(2^m + 2^{n-m} + \sum_{k=1}^{n-1} \min\!\left(|\text{SumsLeft}[\le k]|, |\text{SumsRight}[\le k]|\right)\right), \\
S(n) &\approx O\!\left(\sum_{k} |\text{SumsLeft}[k]| + \sum_{k} |\text{SumsRight}[k]|\right) \le O(2^{n/2}).
\end{aligned}
\]}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from collections import defaultdict

class Solution:
    def splitArraySameAverage(self, nums: List[int]) -> bool:
        n = len(nums)
        if n <= 1:
            return False
        s = sum(nums)

        # Necessary condition: some k yields integer target
        if not any((k * s) % n == 0 for k in range(1, n)):
            return False

        nums.sort()
        m = n // 2
        left = nums[:m]
        right = nums[m:]

        # Build size-indexed subset sum sets for left half
        sumsL = [set() for _ in range(m + 1)]
        sumsL[0].add(0)
        for x in left:
            for k in range(m - 1, -1, -1):
                for t in list(sumsL[k]):
                    sumsL[k + 1].add(t + x)

        # Quick direct check on left alone
        for k in range(1, m + 1):
            target_mul = k * s
            if target_mul % n == 0:
                target = target_mul // n
                if target in sumsL[k]:
                    return True

        # Build size-indexed subset sum sets for right half
        rlen = n - m
        sumsR = [set() for _ in range(rlen + 1)]
        sumsR[0].add(0)
        for x in right:
            for k in range(rlen - 1, -1, -1):
                for t in list(sumsR[k]):
                    sumsR[k + 1].add(t + x)

        # Quick direct check on right alone
        for k in range(1, rlen + 1):
            target_mul = k * s
            if target_mul % n == 0:
                target = target_mul // n
                if target in sumsR[k]:
                    return True

        # Combine: for each feasible total size k, try splits between halves
        for k in range(1, n):
            target_mul = k * s
            if target_mul % n != 0:
                continue
            target = target_mul // n

            minL = max(0, k - rlen)
            maxL = min(k, m)
            # Iterate the side with fewer candidates to reduce work
            for kL in range(minL, maxL + 1):
                kR = k - kL
                if not sumsL[kL] or not sumsR[kR]:
                    continue
                # Probe via iterating the smaller set
                if len(sumsL[kL]) <= len(sumsR[kR]):
                    for x in sumsL[kL]:
                        if (target - x) in sumsR[kR]:
                            return True
                else:
                    for y in sumsR[kR]:
                        if (target - y) in sumsL[kL]:
                            return True

        return False

# Final approach validation
s = Solution()
assert s.splitArraySameAverage([1,2,3,4,5,6,7,8]) is True
assert s.splitArraySameAverage([3,1]) is False
# Additional tricky cases
assert s.splitArraySameAverage([5,5]) is True
\end{minted}
\VALIDATION{Three asserts: the two examples and an equal-pair case, matching expected outcomes.}
\RESULT{Return \texttt{True} iff a non-empty proper subset achieves the same average as the whole array; complement implicitly forms the other non-empty group.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test on examples; random small arrays for cross-check; edge arrays (all equal, strictly increasing, with zeros).}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Final on small \(n\) (e.g., \(n \le 10\)) to ensure consistency.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with all equal elements, arrays with one element far larger, and cases where the necessary congruence filter fails.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_equal(n: int, v: int) -> List[int]:
    return [v] * n

def gen_increasing(n: int, start: int = 0) -> List[int]:
    return [start + i for i in range(n)]

def gen_with_zeros(n: int, maxv: int = 10) -> List[int]:
    arr = [0] * (n // 3) + [random.randint(1, maxv) for _ in range(n - n // 3)]
    random.shuffle(arr)
    return arr

def congruence_impossible(n: int, maxv: int = 20) -> List[int]:
    # Try to find an array whose sum has no k with (k*S) % n == 0 (rare but possible for small n)
    # Fall back to random if not found quickly.
    for _ in range(5000):
        arr = [random.randint(0, maxv) for _ in range(n)]
        s = sum(arr)
        if all((k * s) % n != 0 for k in range(1, n)):
            return arr
    return [random.randint(0, maxv) for _ in range(n)]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def splitArraySameAverage(self, nums: List[int]) -> bool:
        n = len(nums)
        if n <= 1:
            return False
        s = sum(nums)
        # Necessary condition: avoid heavy work when impossible
        if not any((k * s) % n == 0 for k in range(1, n)):
            return False

        nums.sort()
        m = n // 2
        left = nums[:m]
        right = nums[m:]

        # Build size-indexed sum sets for left half
        sumsL = [set() for _ in range(m + 1)]
        sumsL[0].add(0)
        for x in left:
            for k in range(m - 1, -1, -1):
                for t in list(sumsL[k]):
                    sumsL[k + 1].add(t + x)

        # Direct check: left alone
        for k in range(1, m + 1):
            tm = k * s
            if tm % n == 0 and (tm // n) in sumsL[k]:
                return True

        # Build for right half
        rlen = n - m
        sumsR = [set() for _ in range(rlen + 1)]
        sumsR[0].add(0)
        for x in right:
            for k in range(rlen - 1, -1, -1):
                for t in list(sumsR[k]):
                    sumsR[k + 1].add(t + x)

        # Direct check: right alone
        for k in range(1, rlen + 1):
            tm = k * s
            if tm % n == 0 and (tm // n) in sumsR[k]:
                return True

        # Combine both halves
        for k in range(1, n):
            tm = k * s
            if tm % n != 0:
                continue
            target = tm // n
            minL = max(0, k - rlen)
            maxL = min(k, m)
            for kL in range(minL, maxL + 1):
                kR = k - kL
                if not sumsL[kL] or not sumsR[kR]:
                    continue
                if len(sumsL[kL]) <= len(sumsR[kR]):
                    for x in sumsL[kL]:
                        if (target - x) in sumsR[kR]:
                            return True
                else:
                    for y in sumsR[kR]:
                        if (target - y) in sumsL[kL]:
                            return True

        return False

# Reference asserts
s = Solution()
assert s.splitArraySameAverage([1,2,3,4,5,6,7,8]) is True
assert s.splitArraySameAverage([3,1]) is False
assert s.splitArraySameAverage([2,0,5,6,16,12,15,12,4]) is True
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find a non-empty proper subset whose average equals the array average; equivalently, solve a size-aware subset-sum.}
\WHY{A classic equal-average partition appears in interviews to test reductions, necessary-condition filters, and meet-in-the-middle or DP craftsmanship.}
\CHECKLIST{
\begin{bullets}
\item Compute \(n\), \(S\); apply the necessary congruence filter.
\item Choose a strategy: DP with transformed values or meet-in-the-middle.
\item Enforce non-empty and not-all-elements constraints.
\item Use size-indexed sums or \(k \le n-1\) to avoid trivial full-set.
\item Optimize iteration by probing the smaller set.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item \(n=1 \Rightarrow\) \texttt{False}.
\item All elements equal \(\Rightarrow\) \texttt{True} (pick any single element).
\item No feasible \(k\) by congruence \(\Rightarrow\) \texttt{False}.
\item Presence of zeros and large values.
\item Highly skewed sums where only one specific \(k\) can work.
\item Cases where only a subset in one half already matches.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting the necessary condition check leads to timeouts.
\item Allowing the all-elements subset when using transformed zero-sum.
\item Updating DP in ascending \(k\) order (double-using the same item).
\item Not sorting and missing simple pruning opportunities.
\item Using floating-point averages; must stay in integers.
\item Memory blowup if not grouping sums by size in meet-in-the-middle.
\end{bullets}}
\FAILMODES{Brute-force fails for \(n=30\). Plain sum DP over raw values can be too large. The provided meet-in-the-middle solution survives by splitting and using set lookups with strict size accounting.}
\ELI{Turn the average condition into an integer subset-sum. If any group of \(k\) numbers sums to exactly \(k\cdot S/n\), the split works. We either DP on centered values or split the array and combine subset sums from both halves efficiently.}
\NotePages{3}

\end{document}