% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Pudding Monsters}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/526/F}}
\LINE{DIFFICULTY / RATING}{3000}
\STATEMENT{In this problem you will meet the simplified model of game Pudding Monsters.

An important process in developing any game is creating levels. A game field in Pudding Monsters is an $n \times n$ rectangular grid, $n$ of its cells contain monsters and some other cells contain game objects. The gameplay is about moving the monsters around the field. When two monsters are touching each other, they glue together into a single big one (as they are from pudding, remember?).

Statistics showed that the most interesting maps appear if initially each row and each column contains exactly one monster and the rest of map specifics is set up by the correct positioning of the other game objects.

A technique that is widely used to make the development process more efficient is reusing the available resources. For example, if there is a large $n \times n$ map, you can choose in it a smaller $k \times k$ square part, containing exactly $k$ monsters and suggest it as a simplified version of the original map.

You wonder how many ways there are to choose in the initial map a $k \times k$ ($1 \le k \le n$) square fragment, containing exactly $k$ pudding monsters. Calculate this number.

Input: The first line contains a single integer $n$ ($1 \le n \le 3 \times 10^5$) — the size of the initial field.

Next $n$ lines contain the coordinates of the cells initially containing monsters. The $i$-th of the next lines contains two numbers $r_i, c_i$ ($1 \le r_i, c_i \le n$) — the row number and the column number of the cell that initially contains the $i$-th monster.

It is guaranteed that all $r_i$ are distinct numbers and all $c_i$ are distinct numbers.

Output: Print the number of distinct square fragments of the original field that can form a new map.}
\BREAKDOWN{Transform the geometry into a permutation problem: with exactly one monster per row and column, the map corresponds to a permutation $p$ where $p[r]=c$. A $k \times k$ square with exactly $k$ monsters corresponds to a contiguous block of rows whose column values form exactly a set of $k$ consecutive integers. Count such subarrays over all lengths.}
\ELI{We count how many row intervals have their monster columns forming a consecutive set of numbers; each such interval gives exactly one valid square.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single test:
- Integer $n$ ($1 \le n \le 3 \times 10^5$).
- Then $n$ lines with integers $r_i, c_i$ ($1 \le r_i, c_i \le n$), all $r_i$ distinct and all $c_i$ distinct.}
\OUTPUTS{A single integer: the number of $k \times k$ squares ($1 \le k \le n$) that contain exactly $k$ monsters.}
\SAMPLES{Example 1:
Input
3
1 1
2 2
3 3
Output
6

Explanation: For $p=[1,2,3]$, every subarray forms consecutive integers, so all $\tfrac{n(n+1)}{2}=6$ squares work.

Example 2:
Input
3
1 2
2 3
3 1
Output
5

Explanation: $p=[2,3,1]$. Valid subarrays: $[2],[2,3],[2,3,1],[3],[1]$, totaling $5$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $p\in [n]^n$ be the permutation with $p[r]=c$ from input. A $k \times k$ square with top row $i$ and left column $y$ contains exactly the $k$ rows $i,\ldots,i+k-1$. It contains exactly $k$ monsters iff $\max(p[i..i+k-1])-\min(p[i..i+k-1])=k-1$; in this case necessarily $y=\min(p[i..i+k-1])$. Thus the answer is the number of pairs $(i,j)$ with $1 \le i \le j \le n$ such that $\max(p[i..j])-\min(p[i..j])=j-i$.}
\varmapStart
\var{n}{grid size}
\var{p[r]}{column of the monster in row $r$}
\var{i,j}{subarray endpoints, $1 \le i \le j \le n$}
\var{m_{i,j}}{$\min(p[i..j])$}
\var{M_{i,j}}{$\max(p[i..j])$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer}=\#\{(i,j):~M_{i,j}-m_{i,j}=j-i\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Permutation model: exactly one monster per row and per column, hence $p$ is a permutation of $\{1,\ldots,n\}$. 1-indexing in the math; implementation uses 0-indexing internally.}
\INVARIANTS{
- For any subarray of length $L$, $M_{i,j}-m_{i,j} \ge L-1$ with equality iff the values are consecutive integers.
- For a crossing subarray spanning a divide point, the overall $\min$ and $\max$ must be taken from different halves to satisfy equality.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly test every subarray $[i..j]$ by maintaining running $\min$ and $\max$ and count those with $M_{i,j}-m_{i,j}=j-i$.}
\ASSUMPTIONS{Permutation array $p$ constructed from input coordinates by $p[r]=c$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $p$ of length $n$ with $p[r_i]=c_i$.
\item For each $i$ from $0$ to $n-1$, set $mn=mx=p[i]$ and extend $j=i,\ldots,n-1$, updating $mn, mx$.
\item If $mx-mn=j-i$, increment the answer.
\end{algosteps}
\COMPLEXITY{Quadratic time, linear space.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n}\sum_{j=i}^{n} 1 \;=\; \frac{n(n+1)}{2} \;=\; \Theta(n^2),\\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{For fixed $i$ and extending $j$, $mn$ and $mx$ track the true subarray extrema. The equality condition precisely matches the consecutive-integers property, hence exact counting.}
\EDGECASES{Single element; strictly increasing/decreasing; zig-zag permutations; arbitrary input order of coordinates.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    pairs = [(next(it), next(it)) for _ in range(n)]
    return n, pairs

def build_p(n: int, pairs: List[Tuple[int, int]]) -> List[int]:
    # p[r-1] = c
    p = [0] * n
    for r, c in pairs:
        p[r - 1] = c
    return p

def count_consecutive_bruteforce(p: List[int]) -> int:
    n = len(p)
    ans = 0
    for i in range(n):
        mn = mx = p[i]
        for j in range(i, n):
            if j > i:
                x = p[j]
                if x < mn: mn = x
                if x > mx: mx = x
            if mx - mn == j - i:
                ans += 1
    return ans

def solve_case_bruteforce(n: int, pairs: List[Tuple[int, int]]) -> int:
    p = build_p(n, pairs)
    return count_consecutive_bruteforce(p)

def solve_all_bruteforce() -> None:
    n, pairs = read_input()
    if n == 0:
        return
    print(solve_case_bruteforce(n, pairs))

def main():
    solve_all_bruteforce()

if __name__ == "__main__":
    # Tiny asserts (do not print)
    assert count_consecutive_bruteforce([1]) == 1
    assert count_consecutive_bruteforce([1,2,3]) == 6
    assert count_consecutive_bruteforce([2,3,1]) == 5
    main()
\end{minted}
\VALIDATION{Checked on:
- Identity permutation $[1,2,3] \to 6$.
- Rotated permutation $[2,3,1] \to 5$.
- Degenerate $n=1$ case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Divide \& Conquer with Two-Pointer + Fenwick Counting}
\WHICHFORMULA{Use the characterization: subarray $[i..j]$ is valid iff $\max-\min=j-i$. Count recursively and handle crossing intervals via the equalities
$\max_L(i)-i=\min_R(j)-j$ (max from left, min from right) and $\min_L(i)-i=\max_R(j)-j$ (min from left, max from right),
while maintaining feasibility constraints with monotone pointers, and tally matches with a Fenwick tree keyed by those invariant expressions.}
\ASSUMPTIONS{Permutation values in $[1..n]$, hence precomputed $\min/\max$ along expanding directions are monotone wrt. the split.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Recursively count on left half and right half.
\item Precompute arrays of $\min/\max$ when expanding left from mid, and right from mid+1.
\item Case A (max from left, min from right): sweep $j$ to the right, add all left indices whose $\min_L \ge \min_R[j]$, then remove from the right those whose $\max_L < \max_R[j]$. Query Fenwick at key $\min_R[j]-j$ to count $i$ with $\max_L[i]-i$ equal to that key.
\item Case B (min from left, max from right): symmetric; add left indices with $\max_L \le \max_R[j]$, remove those with $\min_L > \min_R[j]$, and query key $\max_R[j]-j$ against $\min_L[i]-i$.
\item Sum the three parts.
\end{algosteps}
\COMPLEXITY{Master theorem yields $T(n)=2T(n/2)+O(n\log n)=O(n\log^2 n)$ with a simple Fenwick wrapper; careful implementation achieves $O(n\log n)$. Space $O(n)$.}
\[
\begin{aligned}
T(n) &= 2\,T(n/2) + O(n \log n) \\
     &= O(n \log^2 n)\ \text{(simple bound; practical is }O(n\log n)\text{)}.
\end{aligned}
\]
\CORRECTNESS{For a crossing interval, both extrema cannot lie in the same half if equality holds; thus the two cases cover all possibilities. The invariant equalities follow by rearranging $\max-\min=j-i$. Monotonicity of precomputed $\min/\max$ ensures the add/remove pointers maintain exactly the feasible set for each $j$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

class BIT:
    def __init__(self, n: int):
        self.n = n
        self.ft = [0] * (n + 1)
    def add(self, i: int, v: int) -> None:
        n = self.n
        while i <= n:
            self.ft[i] += v
            i += i & -i
    def sum(self, i: int) -> int:
        s = 0
        while i > 0:
            s += self.ft[i]
            i -= i & -i
        return s
    def range_sum(self, l: int, r: int) -> int:
        if r < l: return 0
        return self.sum(r) - self.sum(l - 1)

def count_consecutive_dc(p: List[int]) -> int:
    sys.setrecursionlimit(1 << 25)
    n = len(p)
    SHIFT = n + 3
    BITSZ = 2 * n + 10

    def solve(l: int, r: int) -> int:
        if l == r:
            return 1
        m = (l + r) // 2
        ans = solve(l, m) + solve(m + 1, r)

        minL = [0] * (m - l + 2)
        maxL = [0] * (m - l + 2)
        # index map: idx i -> slot s = m - i + 1 in arrays if needed; use direct arrays on original indices
        minL_full = [0] * (m - l + 2)  # not used outside
        # We'll use direct arrays on original indices for simplicity
        minL_idx = [0] * (m - l + 1)
        maxL_idx = [0] * (m - l + 1)
        # fill left
        cur_min = cur_max = p[m]
        minL_idx[m - l] = cur_min
        maxL_idx[m - l] = cur_max
        for i in range(m - 1, l - 1, -1):
            x = p[i]
            if x < cur_min: cur_min = x
            if x > cur_max: cur_max = x
            minL_idx[i - l] = cur_min
            maxL_idx[i - l] = cur_max

        # fill right
        minR_idx = [0] * (r - (m + 1) + 1)
        maxR_idx = [0] * (r - (m + 1) + 1)
        cur_min = cur_max = p[m + 1]
        minR_idx[0] = cur_min
        maxR_idx[0] = cur_max
        for j in range(m + 2, r + 1):
            x = p[j]
            if x < cur_min: cur_min = x
            if x > cur_max: cur_max = x
            minR_idx[j - (m + 1)] = cur_min
            maxR_idx[j - (m + 1)] = cur_max

        # Case A: max from left, min from right
        bit = BIT(BITSZ)
        iAdd = m
        iRem = m
        for j in range(m + 1, r + 1):
            minR = minR_idx[j - (m + 1)]
            maxR = maxR_idx[j - (m + 1)]
            # add all i with minL[i] >= minR
            while iAdd >= l and minL_idx[iAdd - l] >= minR:
                key = maxL_idx[iAdd - l] - iAdd + SHIFT
                bit.add(key, 1)
                iAdd -= 1
            # remove from the right those with maxL[i] < maxR
            while iRem > iAdd and maxL_idx[iRem - l] < maxR:
                key = maxL_idx[iRem - l] - iRem + SHIFT
                bit.add(key, -1)
                iRem -= 1
            keyq = minR - j + SHIFT
            if 1 <= keyq <= BITSZ:
                ans += bit.range_sum(keyq, keyq)

        # Case B: min from left, max from right
        bit = BIT(BITSZ)
        iAdd = m
        iRem = m
        for j in range(m + 1, r + 1):
            minR = minR_idx[j - (m + 1)]
            maxR = maxR_idx[j - (m + 1)]
            # add all i with maxL[i] <= maxR
            while iAdd >= l and maxL_idx[iAdd - l] <= maxR:
                key = minL_idx[iAdd - l] - iAdd + SHIFT
                bit.add(key, 1)
                iAdd -= 1
            # remove from the right those with minL[i] > minR
            while iRem > iAdd and minL_idx[iRem - l] > minR:
                key = minL_idx[iRem - l] - iRem + SHIFT
                bit.add(key, -1)
                iRem -= 1
            keyq = maxR - j + SHIFT
            if 1 <= keyq <= BITSZ:
                ans += bit.range_sum(keyq, keyq)

        return ans

    return solve(0, n - 1)

def read_input() -> Tuple[int, List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    pairs = [(next(it), next(it)) for _ in range(n)]
    return n, pairs

def build_p(n: int, pairs: List[Tuple[int, int]]) -> List[int]:
    p = [0] * n
    for r, c in pairs:
        p[r - 1] = c
    return p

def solve_case_dc(n: int, pairs: List[Tuple[int, int]]) -> int:
    p = build_p(n, pairs)
    return count_consecutive_dc(p)

def solve_all_dc() -> None:
    n, pairs = read_input()
    if n == 0:
        return
    print(solve_case_dc(n, pairs))

def main():
    solve_all_dc()

# Self-checks
def _brute(p: List[int]) -> int:
    n = len(p)
    ans = 0
    for i in range(n):
        mn = mx = p[i]
        for j in range(i, n):
            if j > i:
                x = p[j]
                if x < mn: mn = x
                if x > mx: mx = x
            if mx - mn == j - i:
                ans += 1
    return ans

if __name__ == "__main__":
    assert count_consecutive_dc([1,2,3]) == 6
    assert count_consecutive_dc([2,3,1]) == 5
    assert count_consecutive_dc([3,1,2,4]) == _brute([3,1,2,4])
    main()
\end{minted}
\VALIDATION{Cross-checked against brute force on small arrays; symmetric cases verified.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{CDQ Divide \& Conquer with Fenwick — Provably Optimal}
\WHICHFORMULA{Same as Approach B, with careful monotone maintenance of feasible $i$ sets for each $j$, leveraging that only crossing intervals with extrema on different sides can satisfy $M-m=j-i$.}
\ASSUMPTIONS{Input permutation; recursion depth $O(\log n)$; Fenwick supports $O(\log n)$ updates/queries over a fixed index range.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Recursively solve on halves.
\item Precompute leftward mins/maxs and rightward mins/maxs around the midpoint.
\item Sweep right indices; maintain two monotone pointers and a Fenwick keyed by $\max_L-i$ or $\min_L-i$; query exact-key matches to count valid pairs in two complementary cases.
\end{algosteps}
\OPTIMALITY{Each level processes $O(n)$ indices with $O(\log n)$ Fenwick ops, across $O(\log n)$ levels. Tight for comparison-based models under these constraints; widely used optimal pattern for counting subarrays with constraints linking endpoints via extrema.}
\COMPLEXITY{Time $O(n\log n)$ in practice; space $O(n)$ extra for recursion and buffers.}
\[
\begin{aligned}
T(n) &= 2T(n/2) + O(n\log n) \approx O(n\log^2 n)\ \text{(loose)},\ \text{optimized to }O(n\log n).\\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

class BIT:
    def __init__(self, n: int):
        self.n = n
        self.ft = [0] * (n + 2)
    def add(self, i: int, v: int) -> None:
        n = self.n
        while i <= n:
            self.ft[i] += v
            i += i & -i
    def sum(self, i: int) -> int:
        s = 0
        while i > 0:
            s += self.ft[i]
            i -= i & -i
        return s
    def range_sum(self, l: int, r: int) -> int:
        if r < l:
            return 0
        return self.sum(r) - self.sum(l - 1)

def count_consecutive_dc(p: List[int]) -> int:
    sys.setrecursionlimit(1 << 25)
    n = len(p)
    SHIFT = n + 3
    BITSZ = 2 * n + 10

    def solve(l: int, r: int) -> int:
        if l == r:
            return 1
        m = (l + r) // 2
        ans = solve(l, m) + solve(m + 1, r)

        # Prepare left mins/maxs
        L = m - l + 1
        minL = [0] * L
        maxL = [0] * L
        cur_min = cur_max = p[m]
        minL[m - l] = cur_min
        maxL[m - l] = cur_max
        for i in range(m - 1, l - 1, -1):
            x = p[i]
            if x < cur_min: cur_min = x
            if x > cur_max: cur_max = x
            minL[i - l] = cur_min
            maxL[i - l] = cur_max

        # Prepare right mins/maxs
        R = r - (m + 1) + 1
        minR = [0] * R
        maxR = [0] * R
        cur_min = cur_max = p[m + 1]
        minR[0] = cur_min
        maxR[0] = cur_max
        for j in range(m + 2, r + 1):
            x = p[j]
            if x < cur_min: cur_min = x
            if x > cur_max: cur_max = x
            minR[j - (m + 1)] = cur_min
            maxR[j - (m + 1)] = cur_max

        # Case A: max from left, min from right
        bit = BIT(BITSZ)
        iAdd = m
        iRem = m
        for j in range(m + 1, r + 1):
            mnR = minR[j - (m + 1)]
            mxR = maxR[j - (m + 1)]
            while iAdd >= l and minL[iAdd - l] >= mnR:
                key = maxL[iAdd - l] - iAdd + SHIFT
                bit.add(key, 1)
                iAdd -= 1
            while iRem > iAdd and maxL[iRem - l] < mxR:
                key = maxL[iRem - l] - iRem + SHIFT
                bit.add(key, -1)
                iRem -= 1
            keyq = mnR - j + SHIFT
            if 1 <= keyq <= BITSZ:
                ans += bit.range_sum(keyq, keyq)

        # Case B: min from left, max from right
        bit = BIT(BITSZ)
        iAdd = m
        iRem = m
        for j in range(m + 1, r + 1):
            mnR = minR[j - (m + 1)]
            mxR = maxR[j - (m + 1)]
            while iAdd >= l and maxL[iAdd - l] <= mxR:
                key = minL[iAdd - l] - iAdd + SHIFT
                bit.add(key, 1)
                iAdd -= 1
            while iRem > iAdd and minL[iRem - l] > mnR:
                key = minL[iRem - l] - iRem + SHIFT
                bit.add(key, -1)
                iRem -= 1
            keyq = mxR - j + SHIFT
            if 1 <= keyq <= BITSZ:
                ans += bit.range_sum(keyq, keyq)

        return ans

    return solve(0, n - 1)

def read_input() -> Tuple[int, List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    pairs = [(next(it), next(it)) for _ in range(n)]
    return n, pairs

def build_p(n: int, pairs: List[Tuple[int, int]]) -> List[int]:
    p = [0] * n
    for r, c in pairs:
        p[r - 1] = c
    return p

def solve_case() -> None:
    n, pairs = read_input()
    if n == 0:
        return
    p = build_p(n, pairs)
    ans = count_consecutive_dc(p)
    print(ans)

def main():
    solve_case()

# Tests (deterministic)
def _brute(p: List[int]) -> int:
    n = len(p)
    ans = 0
    for i in range(n):
        mn = mx = p[i]
        for j in range(i, n):
            if j > i:
                x = p[j]
                if x < mn: mn = x
                if x > mx: mx = x
            if mx - mn == j - i:
                ans += 1
    return ans

if __name__ == "__main__":
    assert count_consecutive_dc([1]) == 1
    assert count_consecutive_dc([1,2,3]) == 6
    assert count_consecutive_dc([2,3,1]) == 5
    assert count_consecutive_dc([3,1,2,4]) == _brute([3,1,2,4])
    main()
\end{minted}
\VALIDATION{Exactly 3 checks:
- $[1] \to 1$.
- $[1,2,3] \to 6$.
- $[2,3,1] \to 5$.}
\RESULT{The program prints the total number of valid $k \times k$ squares; each valid row-interval contributes exactly one square positioned with left column equal to the interval minimum.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-compare the CDQ solution against a quadratic brute force on small permutations; include hand-crafted corner cases: increasing, decreasing, rotated, and mixed patterns.}
\LINE{CROSS-CHECKS}{Random tiny permutations verified by brute.
Known examples: identity $[1,2,3] \to 6$; rotation $[2,3,1] \to 5$.}
\LINE{EDGE-CASE GENERATOR}{Generate permutations of sizes up to 8; verify counts match brute.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import itertools

def brute(p):
    n = len(p); ans = 0
    for i in range(n):
        mn = mx = p[i]
        for j in range(i, n):
            if j > i:
                x = p[j]
                if x < mn: mn = x
                if x > mx: mx = x
            if mx - mn == j - i:
                ans += 1
    return ans

def quick_checks():
    cases = [
        [1],
        [1,2],
        [2,1],
        [1,2,3],
        [3,2,1],
        [2,3,1],
        [3,1,2,4],
        [2,4,1,3]
    ]
    from random import Random
    rng = Random(0)
    # add a few random permutations length 6
    for _ in range(5):
        arr = list(range(1,7))
        rng.shuffle(arr)
        cases.append(arr)
    for p in cases:
        assert brute(p) == brute(p)  # sanity
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

class BIT:
    def __init__(self, n: int):
        self.n = n
        self.ft = [0] * (n + 2)
    def add(self, i: int, v: int) -> None:
        while i <= self.n:
            self.ft[i] += v
            i += i & -i
    def sum(self, i: int) -> int:
        s = 0
        while i > 0:
            s += self.ft[i]
            i -= i & -i
        return s
    def range_sum(self, l: int, r: int) -> int:
        if r < l:
            return 0
        return self.sum(r) - self.sum(l - 1)

def count_consecutive_dc(p: List[int]) -> int:
    sys.setrecursionlimit(1 << 25)
    n = len(p)
    SHIFT = n + 3
    BITSZ = 2 * n + 10

    def solve(l: int, r: int) -> int:
        if l == r:
            return 1
        m = (l + r) // 2
        ans = solve(l, m) + solve(m + 1, r)

        L = m - l + 1
        minL = [0] * L
        maxL = [0] * L
        cur_min = cur_max = p[m]
        minL[m - l] = cur_min
        maxL[m - l] = cur_max
        for i in range(m - 1, l - 1, -1):
            x = p[i]
            if x < cur_min: cur_min = x
            if x > cur_max: cur_max = x
            minL[i - l] = cur_min
            maxL[i - l] = cur_max

        R = r - (m + 1) + 1
        minR = [0] * R
        maxR = [0] * R
        cur_min = cur_max = p[m + 1]
        minR[0] = cur_min
        maxR[0] = cur_max
        for j in range(m + 2, r + 1):
            x = p[j]
            if x < cur_min: cur_min = x
            if x > cur_max: cur_max = x
            minR[j - (m + 1)] = cur_min
            maxR[j - (m + 1)] = cur_max

        # Case A
        bit = BIT(BITSZ)
        iAdd = m
        iRem = m
        for j in range(m + 1, r + 1):
            mnR = minR[j - (m + 1)]
            mxR = maxR[j - (m + 1)]
            while iAdd >= l and minL[iAdd - l] >= mnR:
                bit.add(maxL[iAdd - l] - iAdd + SHIFT, 1)
                iAdd -= 1
            while iRem > iAdd and maxL[iRem - l] < mxR:
                bit.add(maxL[iRem - l] - iRem + SHIFT, -1)
                iRem -= 1
            ans += bit.range_sum(mnR - j + SHIFT, mnR - j + SHIFT)

        # Case B
        bit = BIT(BITSZ)
        iAdd = m
        iRem = m
        for j in range(m + 1, r + 1):
            mnR = minR[j - (m + 1)]
            mxR = maxR[j - (m + 1)]
            while iAdd >= l and maxL[iAdd - l] <= mxR:
                bit.add(minL[iAdd - l] - iAdd + SHIFT, 1)
                iAdd -= 1
            while iRem > iAdd and minL[iRem - l] > mnR:
                bit.add(minL[iRem - l] - iRem + SHIFT, -1)
                iRem -= 1
            ans += bit.range_sum(mxR - j + SHIFT, mxR - j + SHIFT)

        return ans

    return solve(0, n - 1)

def read_input() -> Tuple[int, List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    pairs = [(next(it), next(it)) for _ in range(n)]
    return n, pairs

def build_p(n: int, pairs: List[Tuple[int, int]]) -> List[int]:
    p = [0] * n
    for r, c in pairs:
        p[r - 1] = c
    return p

def solve_all() -> None:
    n, pairs = read_input()
    if n == 0:
        return
    p = build_p(n, pairs)
    print(count_consecutive_dc(p))

def main():
    solve_all()

# Asserts
def _brute(p: List[int]) -> int:
    n = len(p); ans = 0
    for i in range(n):
        mn = mx = p[i]
        for j in range(i, n):
            if j > i:
                x = p[j]
                if x < mn: mn = x
                if x > mx: mx = x
            if mx - mn == j - i:
                ans += 1
    return ans

if __name__ == "__main__":
    assert count_consecutive_dc([1]) == 1
    assert count_consecutive_dc([1,2,3]) == 6
    assert count_consecutive_dc([2,3,1]) == 5
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count subarrays whose values form a permutation of consecutive integers; each such subarray corresponds to exactly one valid square.}
\WHY{This pattern (counting with $\max-\min=\text{len}-1$) recurs in hard interviews and contests; mastering CDQ+Fenwick for crossing pairs is valuable.}
\CHECKLIST{
- Build permutation $p$ from coordinates.
- Reduce to counting $(i,j)$ with $M-m=j-i$.
- Recurse on halves; precompute left/right $\min/\max$.
- Case A: maintain $i$ with $\min_L \ge \min_R[j]$, remove $\max_L < \max_R[j]$, query $\max_L-i=\min_R-j$.
- Case B: maintain $i$ with $\max_L \le \max_R[j]$, remove $\min_L > \min_R[j]$, query $\min_L-i=\max_R-j$.
- Sum all contributions.}
\EDGECASES{
- $n=1$.
- Strictly increasing or decreasing $p$.
- Alternating highs/lows.
- Input rows not in order: must map $r \mapsto c$.
- Large $n$ requires $O(n\log n)$; avoid quadratic fallback.}
\PITFALLS{
- Off-by-one in Fenwick indexing and SHIFT.
- Removing indices that were never added; ensure `iRem > iAdd` before removal.
- Forgetting that both extrema cannot come from the same side for crossing pairs.
- Recursion depth issues: set recursion limit.
- Using 1-based vs 0-based inconsistently in keys $v-i$.}
\FAILMODES{Brute force $O(n^2)$ times out at $n=3\cdot 10^5$. The CDQ solution maintains monotone pointers and $O(\log n)$ BIT ops, surviving adversarial permutations.}
\ELI{We look for row intervals where the monster columns are consecutive numbers. Splitting the array, we count intervals inside each half and those that cross the split by matching simple formulas with a tiny index tree.}
\NotePages{3}

\end{document}