% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Challenge Pennants}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/630/G}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Because of budget cuts one IT company established new non-financial reward system instead of bonuses.

Two kinds of actions are rewarded: fixing critical bugs and suggesting new interesting features. A man who fixed a critical bug gets ``I fixed a critical bug'' pennant on his table. A man who suggested a new interesting feature gets ``I suggested a new feature'' pennant on his table.

Because of the limited budget of the new reward system only 5 ``I fixed a critical bug'' pennants and 3 ``I suggested a new feature'' pennants were bought.

In order to use these pennants for a long time they were made challenge ones. When a man fixes a new critical bug one of the earlier awarded ``I fixed a critical bug'' pennants is passed on to his table. When a man suggests a new interesting feature one of the earlier awarded ``I suggested a new feature'' pennants is passed on to his table.

One man can have several pennants of one type and of course he can have pennants of both types on his table. There are n tables in the IT company. Find the number of ways to place the pennants on these tables given that each pennant is situated on one of the tables and each table is big enough to contain any number of pennants.

Input:
The only line of the input contains one integer n ($1 \le n \le 500$) — the number of tables in the IT company.

Output:
Output one integer — the amount of ways to place the pennants on n tables.}
\BREAKDOWN{There are two independent collections of identical items: 5 bug pennants and 3 feature pennants. Tables are distinct. Count ways to distribute 5 identical items among n bins and multiply by the number of ways to distribute 3 identical items among the same n bins.}
\ELI{It is stars and bars twice: ways $=$ $\binom{n+4}{5}\times\binom{n+2}{3}$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $n$ with $1 \le n \le 500$.}
\OUTPUTS{A single integer: the number of distinct placements of 5 identical ``bug'' pennants and 3 identical ``feature'' pennants over $n$ distinct tables.}
\SAMPLES{Example 1

Input
1

Output
1

Example 2

Input
2

Output
24

Explanation for $n=2$: distribute 5 identical items over 2 tables in $\binom{6}{5}=6$ ways and 3 identical items in $\binom{4}{3}=4$ ways; total $6 \times 4=24$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the $n$ tables be labeled $1,\ldots,n$. For bug pennants, let $x_i \in \mathbb{Z}_{\ge 0}$ be the count on table $i$ with $\sum_{i=1}^n x_i = 5$. For feature pennants, let $y_i \in \mathbb{Z}_{\ge 0}$ be the count on table $i$ with $\sum_{i=1}^n y_i = 3$. Distributions for the two types are independent; the total number of placements equals the product of the two counts.}
\varmapStart
\var{x_i}{number of bug pennants on table $i$}
\var{y_i}{number of feature pennants on table $i$}
\var{n}{number of tables}
\varmapEnd
\GOVERN{
\[
\text{ways}(n)
= \#\{(x_1,\ldots,x_n)\in\mathbb{Z}_{\ge 0}^n:\sum x_i=5\}\cdot
  \#\{(y_1,\ldots,y_n)\in\mathbb{Z}_{\ge 0}^n:\sum y_i=3\}
= \binom{n+4}{5}\binom{n+2}{3}.
\]
}
\ASSUMPTIONS{Tables are distinguishable; pennants of the same type are indistinguishable; all pennants are placed; capacities are unbounded.}
\INVARIANTS{(i) Nonnegativity: $x_i,y_i\ge 0$. (ii) Conservation: $\sum x_i=5$, $\sum y_i=3$. (iii) Independence: choices for $x$ and $y$ multiply.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Dynamic programming over the number of tables for a fixed total count $m$ computes $\#\{(z_1,\ldots,z_n):\sum z_i=m\}$ in $O(nm^2)$ via the standard stars-and-bars DP recurrence.}
\ASSUMPTIONS{Use two small DPs independently for $m=5$ and $m=3$ and multiply the results.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dp[0]=1$, $dp[s>0]=0$ to represent 0 tables.
\item For each of $n$ tables, update $dp^{\text{new}}[s]=\sum_{t=0}^s dp[s-t]$ using prefix sums.
\item Return $dp[5]\times dp'[3]$ for the two independent runs ($m=5$ and $m=3$).
\end{algosteps}
\COMPLEXITY{With $m\in\{3,5\}$ constants, $T(n)=O(nm^2)=O(n)$ and $S(n)=O(m)=O(1)$.}
\[
\begin{aligned}
T(n) &= 2\cdot \sum_{i=1}^{n}\Theta(m^2) = \Theta(nm^2) \\
     &= \Theta(n)\ \text{since }m\le 5\text{ is constant.}
\end{aligned}
\]
\CORRECTNESS{By construction, when adding a table, the new total $s$ on the first $i$ tables is the sum over all ways the $i$-th table takes $t\in[0,s]$ items and the previous $i-1$ tables take $s-t$ items. Independence across types justifies the product.}
\EDGECASES{$n=1$ (all pennants on the unique table), large $n$ (combinatorial numbers still finite), and $n$ near 500 (linear time).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input() -> int:
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def count_weak_compositions(n: int, m: int) -> int:
    # Number of weak compositions of m into n parts.
    # DP over tables; dp[s] = ways to distribute s using processed tables.
    dp = [0] * (m + 1)
    dp[0] = 1  # 0 tables handled so far: only sum=0 possible
    for _ in range(n):
        new = [0] * (m + 1)
        run = 0
        for s in range(0, m + 1):
            run += dp[s]
            new[s] = run
        dp = new
    return dp[m]

def solve_case(n: int) -> int:
    return count_weak_compositions(n, 5) * count_weak_compositions(n, 3)

def solve_all() -> None:
    n = read_input()
    print(solve_case(n))

def _self_test():
    # Tiny spot-checks against the closed-form C(n+4,5)*C(n+2,3)
    import math
    def C(a, b):
        if b < 0 or b > a: return 0
        b = min(b, a - b)
        r = 1
        for i in range(1, b + 1):
            r = r * (a - b + i) // i
        return r
    for n in range(1, 8):
        expected = C(n + 4, 5) * C(n + 2, 3)
        got = solve_case(n)
        assert got == expected, (n, got, expected)
    # Specific values
    assert solve_case(1) == 1
    assert solve_case(2) == 24
    assert solve_case(3) == 210

if __name__ == "__main__":
    if sys.argv[-1] == "_test":
        _self_test()
    else:
        solve_all()
\end{minted}
\VALIDATION{Checked $n\in\{1,2,3,\ldots,7\}$ against the closed form. Specific asserts for $n=1,2,3$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Closed-Form via Binomial Coefficients}
\WHICHFORMULA{Use stars and bars directly: $\#=\binom{n+4}{5}\binom{n+2}{3}$, computed with a stable multiplicative routine for $\binom{\cdot}{\cdot}$.}
\ASSUMPTIONS{Python integers are arbitrary precision; multiplicative computation guarantees exact division at each step.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Implement $\mathrm{C}(a,b)$ with $b=\min(b,a-b)$ and loop $i=1..b$: $res=res\cdot(a-b+i)/i$ using integer division.
\item Compute $ans=\mathrm{C}(n+4,5)\times\mathrm{C}(n+2,3)$.
\item Print $ans$.
\end{algosteps}
\COMPLEXITY{Each binomial costs $O(k)$ with $k\in\{3,5\}$, so $T(n)=O(1)$ arithmetic; $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= O(5+3) = O(1).
\end{aligned}
\]
\CORRECTNESS{Stars-and-bars gives the exact counts; multiplicative binomial computation is exact since the intermediate result is always divisible by $i$ in step $i$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input() -> int:
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def nCk(n: int, k: int) -> int:
    if k < 0 or k > n:
        return 0
    k = min(k, n - k)
    res = 1
    for i in range(1, k + 1):
        res = res * (n - k + i) // i
    return res

def solve_case(n: int) -> int:
    return nCk(n + 4, 5) * nCk(n + 2, 3)

def solve_all() -> None:
    n = read_input()
    print(solve_case(n))

def _self_test():
    # Spot-check against small-n manual expectations
    assert solve_case(1) == 1
    assert solve_case(2) == 24
    assert solve_case(3) == 210
    # Random small checks via DP cross-check
    def count_dp(n: int, m: int) -> int:
        dp = [0] * (m + 1)
        dp[0] = 1
        for _ in range(n):
            new = [0] * (m + 1)
            run = 0
            for s in range(m + 1):
                run += dp[s]
                new[s] = run
            dp = new
        return dp[m]
    for n in range(1, 20):
        assert solve_case(n) == count_dp(n, 5) * count_dp(n, 3)

if __name__ == "__main__":
    if sys.argv[-1] == "_test":
        _self_test()
    else:
        solve_all()
\end{minted}
\VALIDATION{Cross-checked against DP counts for $n\le 19$ and exact asserts for $n=1,2,3$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Closed Form via Rising Factorials}
\WHICHFORMULA{Exploit $\binom{n+4}{5}=\dfrac{n(n+1)(n+2)(n+3)(n+4)}{120}$ and $\binom{n+2}{3}=\dfrac{n(n+1)(n+2)}{6}$, then multiply.}
\ASSUMPTIONS{Valid for all integers $n\ge 1$; integer divisions are exact.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $b = n(n+1)(n+2)(n+3)(n+4)/120$.
\item Compute $f = n(n+1)(n+2)/6$.
\item Output $b \times f$.
\end{algosteps}
\OPTIMALITY{Uses a constant number of integer operations independent of $n$; this is optimal for this input size.}
\COMPLEXITY{$T(n)=O(1)$, $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input() -> int:
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def solve_case(n: int) -> int:
    # Using closed forms: C(n+4,5) and C(n+2,3)
    bugs = n * (n + 1) * (n + 2) * (n + 3) * (n + 4) // 120
    feats = n * (n + 1) * (n + 2) // 6
    return bugs * feats

def solve_all() -> None:
    n = read_input()
    print(solve_case(n))

def _self_test():
    # Exact checks
    assert solve_case(1) == 1
    assert solve_case(2) == 24
    assert solve_case(3) == 210
    # Cross-check against multiplicative nCk
    def nCk(n: int, k: int) -> int:
        if k < 0 or k > n:
            return 0
        k = min(k, n - k)
        res = 1
        for i in range(1, k + 1):
            res = res * (n - k + i) // i
        return res
    for n in range(1, 40):
        expect = nCk(n + 4, 5) * nCk(n + 2, 3)
        assert solve_case(n) == expect

if __name__ == "__main__":
    if sys.argv[-1] == "_test":
        _self_test()
    else:
        solve_all()
\end{minted}
\VALIDATION{Three direct asserts and a loop cross-checking $n=1..39$ against the multiplicative binomial routine.}
\RESULT{Print a single integer equal to $\binom{n+4}{5}\binom{n+2}{3}$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test closed-form computation against an $O(n)$ DP for $m\in\{3,5\}$ over small $n$; spot-check known small answers; property test monotonic growth in $n$.}
\LINE{CROSS-CHECKS}{Compare Approach A DP vs Approach B binomials vs Approach C closed form for random $n$ in a small range.}
\LINE{EDGE-CASE GENERATOR}{Generate $n\in\{1,2,3,10,100,500\}$ to cover smallest, small, medium, and the upper bound.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_ns():
    return [1, 2, 3, 4, 5, 10, 50, 100, 250, 500]

def count_dp(n: int, m: int) -> int:
    dp = [0] * (m + 1)
    dp[0] = 1
    for _ in range(n):
        new = [0] * (m + 1)
        run = 0
        for s in range(m + 1):
            run += dp[s]
            new[s] = run
        dp = new
    return dp[m]

def closed_form(n: int) -> int:
    bugs = n * (n + 1) * (n + 2) * (n + 3) * (n + 4) // 120
    feats = n * (n + 1) * (n + 2) // 6
    return bugs * feats

def reference_check():
    # Cross-check DP and closed form for a curated set of n's
    for n in gen_ns():
        dp_val = count_dp(n, 5) * count_dp(n, 3)
        cf_val = closed_form(n)
        assert dp_val == cf_val, (n, dp_val, cf_val)

if __name__ == "__main__":
    reference_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input() -> int:
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def solve_case(n: int) -> int:
    bugs = n * (n + 1) * (n + 2) * (n + 3) * (n + 4) // 120
    feats = n * (n + 1) * (n + 2) // 6
    return bugs * feats

def solve_all() -> None:
    n = read_input()
    print(solve_case(n))

def _self_test():
    assert solve_case(1) == 1
    assert solve_case(2) == 24
    assert solve_case(3) == 210

if __name__ == "__main__":
    if sys.argv[-1] == "_test":
        _self_test()
    else:
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count placements of two independent sets of identical items across $n$ distinct bins.}
\WHY{Classic stars-and-bars appears frequently in counting/probability and combinatorics-heavy interviews.}
\CHECKLIST{
\begin{bullets}
\item Identify indistinguishability within each type.
\item Confirm bins (tables) are distinguishable.
\item Apply stars-and-bars separately to totals 5 and 3.
\item Multiply the independent counts.
\item Compute binomials stably (avoid floating point).
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$: exactly one placement.
\item $n=2$: quick mental check $6\times 4=24$.
\item Large $n$ near $500$: ensure integer arithmetic.
\item Conceptual edge: zero of a type on a table is allowed.
\item No empty-table restriction; tables may receive zero pennants.
\item Independence: presence of one type does not affect the other.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Miscounting by treating pennants as distinct.
\item Forgetting to multiply the two independent counts.
\item Off-by-one in stars-and-bars: use $n+m-1$ over $m$.
\item Using floating point binomials leading to rounding errors.
\item Integer division order: ensure exact divisibility at each step.
\item Overflow in fixed-width languages (not an issue in Python).
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item Brute-forcing distributions across $n$ tables (exponential) is infeasible in general; here $m$ is small but principle matters.
\item Incorrectly assuming tables are indistinguishable would undercount.
\end{bullets}
}
\ELI{We split 5 identical bug flags among $n$ labeled tables and 3 identical feature flags among the same tables. Each split count is a stars-and-bars binomial, and the two choices are independent, so we multiply them.}
\NotePages{3}

\end{document}