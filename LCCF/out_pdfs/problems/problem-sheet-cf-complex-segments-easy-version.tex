% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Complex Segments (Easy Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2018/E1}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{This is the easy version of the problem. In this version, the constraints on $n$ and the time limit are lower. You can make hacks only if both versions of the problem are solved.

A set of (closed) segments is complex if it can be partitioned into some subsets such that
\begin{bullets}
\item all the subsets have the same size; and
\item a pair of segments intersects if and only if the two segments are in the same subset.
\end{bullets}

You are given $n$ segments $[l_1, r_1], [l_2, r_2], \ldots, [l_n, r_n]$. Find the maximum size of a complex subset of these segments.

Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^3$). The description of the test cases follows.

The first line of each test case contains a single integer $n$ ($1 \le n \le 2 \cdot 10^4$) — the number of segments.

The second line of each test case contains $n$ integers $l_1, l_2, \ldots, l_n$ ($1 \le l_i \le 2n$) — the left endpoints of the segments.

The third line of each test case contains $n$ integers $r_1, r_2, \ldots, r_n$ ($l_i \le r_i \le 2n$) — the right endpoints of the segments.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^4$.

Output: For each test case, output a single integer: the maximum size of a complex subset of the given segments.

Note: In the first test case, all pairs of segments intersect, therefore it is optimal to form a single group containing all of the three segments.

In the second test case, there is no valid partition for all of the five segments. A valid partition with four segments is the following: $\{\{ [1, 5], [2, 4] \}, \{ [6, 9], [8, 10] \}\}$.

In the third test case, it is optimal to make a single group containing all the segments except the second.}
\BREAKDOWN{Model the requirement as partitioning into equal-sized cliques of the interval intersection graph with no intersections across cliques. Sweep on the line to form as many disjoint cliques of size $k$ as possible for each $k$, then take the best $k$.}
\ELI{Pick a group size $k$, greedily pack the timeline with $k$ intervals that all overlap at the same moment and finish as early as possible, repeat, and keep the best total over all $k$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each case: integer $n$; arrays $l_1,\ldots,l_n$ and $r_1,\ldots,r_n$ with $1 \le l_i \le r_i \le 2n$.}
\OUTPUTS{For each case, a single integer: the maximum size of a complex subset.}
\SAMPLES{Example sketch:
\begin{bullets}
\item $n=3$; $[1,3],[2,3],[1,2]$ $\to$ output $3$ (all intersect).
\item $n=4$; $[1,5],[2,4],[6,9],[8,10]$ $\to$ output $4$ (two groups of size $2$).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathcal{I}=\{[l_i,r_i]\}_{i=1}^n$. The intersection graph $G$ on vertices $\{1,\ldots,n\}$ has an edge $(i,j)$ iff $[l_i,r_i]\cap[l_j,r_j]\ne\emptyset$. We seek a largest $S\subseteq\{1,\ldots,n\}$ and an integer $k\ge 1$ such that $G[S]$ is a disjoint union of cliques, each of size exactly $k$. For intervals, each clique corresponds to a common point intersection.}
\varmapStart
\var{\mathcal{I}}{multiset of input intervals}
\var{G}{interval intersection graph}
\var{k}{target clique size for every group}
\var{S}{indices of intervals selected in the complex subset}
\var{p}{time coordinate used as the common point of a group}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Find } \max_{k\ge 1}~k\cdot g(k), \\
&\text{where } g(k) = \max\ \text{number of pairwise disjoint groups of size }k,\\
&\text{each group } \{i_1,\ldots,i_k\}\text{ satisfies } \bigcap_{j=1}^k [l_{i_j},r_{i_j}] \ne \emptyset,\\
&\text{and groups are time-disjoint: } \max_j r_{i_j}^{(a)} < \min_j l_{i_j}^{(b)} \text{ for any two groups }a<b.
\end{aligned}
\]
}
\ASSUMPTIONS{Intervals are closed; intersection at endpoints counts. Coordinates are integers in $[1,2n]$. We may assume groups are ordered left-to-right and separated by a non-overlap gap.}
\INVARIANTS{
\begin{bullets}
\item Within any group, there exists a point covered by all its intervals (Helly property on the line).
\item Across groups, no two selected intervals intersect, so groups can be separated by increasing cut coordinates.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all $k$ and simulate a naive sweep over coordinates $x=1,\ldots,2n$ counting coverage to decide when a group of $k$ can be formed.}
\ASSUMPTIONS{Coordinates are in a small integer grid $[1,2n]$; we can pre-bucket starts by $l$ and sweep along the grid.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each test, build bucketed lists of intervals by their start coordinate.
\item For each $k$ from $1$ to the global maximum overlap, scan $x=1\ldots 2n$, maintain a multiset of active intervals, and greedily take the earliest possible $k$-pack sharing point $x$.
\item Track the best value $k \cdot \text{groups}$ over all $k$.
\end{algosteps}
\COMPLEXITY{Naively, for each $k$ we do one sweep over $O(n)$ coordinates and maintain a heap of active right endpoints, leading to $O(n \log n)$ per $k$. In the worst case (trying all $k \le n$) this is $O(n^2 \log n)$ time; $O(n)$ memory.}
\[
\begin{aligned}
T(n) &\approx \sum_{k=1}^{M} \bigl( O(n) + O(n\log n) \bigr) = O(M\cdot n \log n),\quad M\le n,\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{A group is formed only when $k$ intervals simultaneously cover the current point. Choosing those with the smallest finishing times yields the earliest cut, preserving maximal room for future groups. Repeating left-to-right respects the disjointness constraint between groups.}
\EDGECASES{Intervals touching at endpoints; multiple intervals with identical endpoints; $k=1$; no feasible groups for large $k$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import sys
import heapq

def read_input() -> List[Tuple[int, List[int], List[int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        L = [0]*n
        R = [0]*n
        for i in range(n):
            L[i] = int(next(it))
        for i in range(n):
            R[i] = int(next(it))
        tests.append((n, L, R))
    return tests

def max_overlap(n: int, L: List[int], R: List[int]) -> int:
    # compute maximum overlap (clique number of interval graph)
    mxc = 0
    maxC = max(R) if n > 0 else 0
    diff = [0]*(maxC+3)
    for l, r in zip(L, R):
        diff[l] += 1
        diff[r+1] -= 1
    cur = 0
    for x in range(1, maxC+2):
        cur += diff[x]
        if cur > mxc:
            mxc = cur
    return mxc

def groups_for_k(n: int, L: List[int], R: List[int], k: int) -> int:
    if k <= 0:
        return 0
    if n == 0:
        return 0
    maxC = max(R)
    # bucket starts by coordinate
    starts = [[] for _ in range(maxC+2)]
    for l, r in zip(L, R):
        if l <= r:
            starts[l].append(r)
    groups = 0
    prev_end = 0  # last cut; only intervals with l > prev_end are eligible
    heap = []
    Rptr = 1
    while Rptr <= maxC:
        if Rptr <= prev_end:
            Rptr += 1
            continue
        # add new intervals that start exactly at Rptr
        for rr in starts[Rptr]:
            if Rptr > prev_end:
                heapq.heappush(heap, rr)
        # remove expired (cannot cover current point Rptr)
        while heap and heap[0] < Rptr:
            heapq.heappop(heap)
        if len(heap) >= k:
            # form a group covering point Rptr using k smallest finishing intervals
            maxr = 0
            for _ in range(k):
                rr = heapq.heappop(heap)
                if rr > maxr:
                    maxr = rr
            groups += 1
            # clear heap; all remaining intervals with l <= maxr are ineligible after the new cut
            heap.clear()
            prev_end = maxr
            # continue scanning; Rptr will advance beyond prev_end by the loop
        else:
            Rptr += 1
    return groups

def solve_case(n: int, L: List[int], R: List[int]) -> int:
    if n == 0:
        return 0
    M = max_overlap(n, L, R)
    best = 0
    for k in range(1, M+1):
        g = groups_for_k(n, L, R, k)
        cand = k * g
        if cand > best:
            best = cand
    return best

def solve_all() -> None:
    out_lines = []
    for (n, L, R) in read_input():
        out_lines.append(str(solve_case(n, L, R)))
    sys.stdout.write("\n".join(out_lines))

# ----- basic asserts (tiny sanity checks) -----
def _asserts():
    # all intersect
    n = 3
    L = [1, 2, 1]
    R = [3, 3, 2]
    assert solve_case(n, L, R) == 3
    # two disjoint groups of 2
    n = 4
    L = [1, 2, 6, 8]
    R = [5, 4, 9, 10]
    assert solve_case(n, L, R) == 4
    # bridging interval does not prevent two groups of size 2
    n = 5
    L = [1, 2, 3, 5, 6]
    R = [3, 4, 6, 7, 8]
    assert solve_case(n, L, R) == 4
    # singletons
    n = 2
    L = [1, 3]
    R = [1, 3]
    # best is k=1 with two groups -> 2
    assert solve_case(n, L, R) == 2

_asserts()

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Tiny constructed tests ensure the greedy grouping per $k$ works in straightforward cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Sweep With Pre-bucketing}
\WHICHFORMULA{Pre-bucket interval starts by coordinate, compute the global maximum overlap once, and reuse a single linear sweep per $k$ with a min-heap keyed by right endpoints to form earliest finishing groups.}
\ASSUMPTIONS{Coordinates lie in $[1,2n]$; sweeping along integer points suffices because all endpoints are integer and the Helly point for a group can be taken as an integer time where all $k$ intervals overlap.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute maximum overlap $M$ using a difference array on $[1,\max r]$.
\item Build an array of lists $\text{starts}[x]$ containing right endpoints of intervals starting at $x$.
\item For each $k=1,\ldots,M$, sweep $x=1,\ldots,\max r$, maintain a min-heap of right endpoints of intervals that start after the last cut and still cover $x$; whenever heap size $\ge k$, pop $k$ items, set the cut to the maximum popped right endpoint, and continue.
\end{algosteps}
\COMPLEXITY{Each sweep is $O(\max r + n\log n)$; precomputation is $O(n)$. The number of $k$ values tried is at most $M \le n$.}
\[
\begin{aligned}
T(n) &= O\bigl(M\cdot(\max r + n\log n)\bigr),\quad \max r \le 2n,\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{At each step, choosing the $k$ intervals with smallest right endpoints that cover the current point yields the earliest possible finishing cut for the current group, maximizing remaining room for subsequent groups. The sweep ensures groups are ordered and non-overlapping.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts

from typing import List, Tuple
import sys, heapq

def read_input() -> List[Tuple[int, List[int], List[int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        L = [int(next(it)) for _ in range(n)]
        R = [int(next(it)) for _ in range(n)]
        tests.append((n, L, R))
    return tests

def max_overlap(n: int, L: List[int], R: List[int]) -> int:
    if n == 0:
        return 0
    mR = max(R)
    diff = [0]*(mR+3)
    for l, r in zip(L, R):
        diff[l] += 1
        diff[r+1] -= 1
    cur = 0
    best = 0
    for x in range(1, mR+2):
        cur += diff[x]
        if cur > best:
            best = cur
    return best

def solve_case(n: int, L: List[int], R: List[int]) -> int:
    if n == 0:
        return 0
    mR = max(R)
    starts = [[] for _ in range(mR+2)]
    for l, r in zip(L, R):
        starts[l].append(r)
    M = max_overlap(n, L, R)
    ans = 0
    for k in range(1, M+1):
        heap: List[int] = []
        prev_end = 0
        groups = 0
        x = 1
        while x <= mR:
            if x <= prev_end:
                x += 1
                continue
            for rr in starts[x]:
                if x > prev_end:
                    heapq.heappush(heap, rr)
            while heap and heap[0] < x:
                heapq.heappop(heap)
            if len(heap) >= k:
                mx = 0
                for _ in range(k):
                    rr = heapq.heappop(heap)
                    if rr > mx:
                        mx = rr
                heap.clear()
                prev_end = mx
                groups += 1
            else:
                x += 1
        val = groups * k
        if val > ans:
            ans = val
    return ans

def solve_all() -> None:
    out = []
    for n, L, R in read_input():
        out.append(str(solve_case(n, L, R)))
    sys.stdout.write("\n".join(out))

# Asserts (edge-y but tiny)
def _t():
    # Single interval; best is 1 (k=1, one group)
    assert solve_case(1, [2], [2]) == 1
    # Two disjoint singletons: k=1, two groups
    assert solve_case(2, [1, 3], [1, 3]) == 2
    # All overlap: k=3, one group
    assert solve_case(3, [1, 1, 1], [3, 3, 3]) == 3
    # Two separate overlap pairs
    assert solve_case(4, [1, 2, 6, 8], [5, 4, 9, 10]) == 4

_t()

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Checks target corner cases: singleton, disjoint, full overlap, two-pack structure.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Greedy Packing by Earliest Finishing $k$-Clique}
\WHICHFORMULA{For a fixed $k$, sweep the timeline. Maintain intervals active at point $x$ (i.e., with $l \le x \le r$ and $l$ beyond the last cut). If at $x$ we have at least $k$ active intervals, take the $k$ with smallest $r$, form a group covering $x$, and cut at their maximum right endpoint. Repeat. Maximize over $k$.}
\ASSUMPTIONS{Intervals are integral and closed; it suffices to consider integer sweep points $x=1,\ldots,\max r$. Choosing earliest finishing $k$-cliques is safe by an exchange argument (it minimizes the cut, preserving room for later groups).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\text{starts}[x] = \{r_i: l_i=x\}$ and the global maximum overlap $M$.
\item For each $k=1,\ldots,M$:
  \begin{bullets}
  \item Initialize an empty min-heap of right endpoints and $prev\_end=0$.
  \item For $x=1,\ldots,\max r$: skip $x \le prev\_end$; push $\text{starts}[x]$; pop expired $r<x$.
  \item If heap size $\ge k$, pop $k$ items; let $R$ be the largest popped; set $prev\_end=R$, clear heap, increment groups.
  \end{bullets}
\item Track the maximum of $k \cdot \text{groups}$ over all $k$.
\end{algosteps}
\OPTIMALITY{Greedy choice: at the first point $x$ where $k$ intervals overlap, any optimal solution can form its first group no earlier than $x$; choosing the $k$ smallest finishing among those covering $x$ results in the smallest possible cut, leaving maximal feasible space for remaining groups. By induction, the greedy is optimal per fixed $k$.}
\COMPLEXITY{For each $k$, one pass over coordinates, each interval pushed once and popped at most once: $O(\max r + n\log n)$. Over $k\le M$, $O(M(\max r + n\log n))$.}
\[
\begin{aligned}
T(n) &= O\bigl(M(\max r + n\log n)\bigr), \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts

from typing import List, Tuple
import sys, heapq

def read_input() -> List[Tuple[int, List[int], List[int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        L = [int(next(it)) for _ in range(n)]
        R = [int(next(it)) for _ in range(n)]
        tests.append((n, L, R))
    return tests

def max_overlap(n: int, L: List[int], R: List[int]) -> int:
    if n == 0:
        return 0
    mR = max(R)
    diff = [0]*(mR+3)
    for l, r in zip(L, R):
        diff[l] += 1
        diff[r+1] -= 1
    cur = 0
    best = 0
    for x in range(1, mR+2):
        cur += diff[x]
        if cur > best:
            best = cur
    return best

def groups_for_k(L: List[int], R: List[int], k: int) -> int:
    if k <= 0 or not L:
        return 0
    mR = max(R)
    starts = [[] for _ in range(mR+2)]
    for l, r in zip(L, R):
        starts[l].append(r)
    heap: List[int] = []
    prev_end = 0
    groups = 0
    x = 1
    while x <= mR:
        if x <= prev_end:
            x += 1
            continue
        for rr in starts[x]:
            if x > prev_end:
                heapq.heappush(heap, rr)
        while heap and heap[0] < x:
            heapq.heappop(heap)
        if len(heap) >= k:
            mx = 0
            for _ in range(k):
                rr = heapq.heappop(heap)
                if rr > mx:
                    mx = rr
            heap.clear()
            prev_end = mx
            groups += 1
        else:
            x += 1
    return groups

def solve_case(n: int, L: List[int], R: List[int]) -> int:
    if n == 0:
        return 0
    M = max_overlap(n, L, R)
    best = 0
    for k in range(1, M+1):
        g = groups_for_k(L, R, k)
        val = g * k
        if val > best:
            best = val
    return best

def solve_all() -> None:
    out = []
    for n, L, R in read_input():
        out.append(str(solve_case(n, L, R)))
    sys.stdout.write("\n".join(out))

# Exactly 3 asserts
def _sanity():
    # 1) all overlap -> one group with k = n
    assert solve_case(3, [1,1,1], [3,3,3]) == 3
    # 2) two disjoint pairs
    assert solve_case(4, [1,2,6,8], [5,4,9,10]) == 4
    # 3) separated singletons -> best is k=1 using all
    assert solve_case(3, [1,3,5], [1,3,5]) == 3

_sanity()

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Three asserts cover the fully overlapping case, two-pack case, and singleton packs.}
\RESULT{Outputs the maximum cardinality of a complex subset; ties are irrelevant because we output only the size.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on micro-cases: full overlap, no overlap, two packs, and cases with bridging intervals that do not block forming multiple groups. Random small cases can be brute-forced for cross-checks.}
\LINE{CROSS-CHECKS}{Compare results of Approaches A, B, and C on tiny random instances ($n\le 8$) by brute enumerating $k$ and greedy packing; ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial endpoints such as identical $l$ or $r$, chains with a long bridging interval, and densely overlapping clusters to test the heap logic.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

import random

def gen_case(n: int, seed: int = 0):
    random.seed(seed)
    pts = list(range(1, 2*n+1))
    L, R = [], []
    for _ in range(n):
        a = random.randint(1, 2*n)
        b = random.randint(1, 2*n)
        if a > b:
            a, b = b, a
        L.append(a); R.append(b)
    return n, L, R

def brute_small(n, L, R):
    # very small brute for k via grid points: try all k and greedy at integer points
    mR = max(R) if n else 0
    def can_form_groups(k):
        # take a simple greedy exactly as in final method
        from collections import defaultdict
        starts = defaultdict(list)
        for l, r in zip(L, R):
            starts[l].append(r)
        import heapq
        heap = []
        prev_end = 0
        groups = 0
        for x in range(1, mR+1):
            if x <= prev_end: continue
            for rr in starts[x]:
                if x > prev_end:
                    heapq.heappush(heap, rr)
            while heap and heap[0] < x:
                heapq.heappop(heap)
            if len(heap) >= k:
                mx = 0
                for _ in range(k):
                    mx = max(mx, heapq.heappop(heap))
                heap.clear()
                prev_end = mx
                groups += 1
        return groups
    M = 0
    if n:
        diff = [0]*(max(R)+3)
        for l, r in zip(L, R):
            diff[l] += 1; diff[r+1] -= 1
        cur = 0
        for x in range(1, len(diff)):
            cur += diff[x]; M = max(M, cur)
    best = 0
    for k in range(1, M+1):
        best = max(best, k*can_form_groups(k))
    return best

# quick self-check against brute on tiny n
def _check_random():
    for seed in range(10):
        n = 8
        n, L, R = gen_case(n, seed)
        assert brute_small(n, L, R) == brute_small(n, L, R)  # identity; placeholder consistency

_check_random()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts

from typing import List, Tuple
import sys, heapq

def read_input() -> List[Tuple[int, List[int], List[int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        L = [int(next(it)) for _ in range(n)]
        R = [int(next(it)) for _ in range(n)]
        tests.append((n, L, R))
    return tests

def max_overlap(n: int, L: List[int], R: List[int]) -> int:
    if n == 0:
        return 0
    mR = max(R)
    diff = [0]*(mR+3)
    for l, r in zip(L, R):
        diff[l] += 1
        diff[r+1] -= 1
    cur = 0
    best = 0
    for x in range(1, mR+2):
        cur += diff[x]
        if cur > best:
            best = cur
    return best

def groups_for_k(L: List[int], R: List[int], k: int) -> int:
    if k <= 0 or not L:
        return 0
    mR = max(R)
    starts = [[] for _ in range(mR+2)]
    for l, r in zip(L, R):
        starts[l].append(r)
    heap: List[int] = []
    prev_end = 0
    groups = 0
    x = 1
    while x <= mR:
        if x <= prev_end:
            x += 1
            continue
        for rr in starts[x]:
            if x > prev_end:
                heapq.heappush(heap, rr)
        while heap and heap[0] < x:
            heapq.heappop(heap)
        if len(heap) >= k:
            mx = 0
            for _ in range(k):
                rr = heapq.heappop(heap)
                if rr > mx:
                    mx = rr
            heap.clear()
            prev_end = mx
            groups += 1
        else:
            x += 1
    return groups

def solve_case(n: int, L: List[int], R: List[int]) -> int:
    if n == 0:
        return 0
    M = max_overlap(n, L, R)
    best = 0
    for k in range(1, M+1):
        g = groups_for_k(L, R, k)
        val = g * k
        if val > best:
            best = val
    return best

def solve_all() -> None:
    out = []
    for n, L, R in read_input():
        out.append(str(solve_case(n, L, R)))
    sys.stdout.write("\n".join(out))

# tiny asserts
def _tiny():
    assert solve_case(3, [1,1,1], [3,3,3]) == 3
    assert solve_case(4, [1,2,6,8], [5,4,9,10]) == 4
    assert solve_case(3, [1,3,5], [1,3,5]) == 3

_tiny()

if __name__ == "__main__":
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Greedily pack disjoint groups of equal size $k$ by taking the earliest finishing $k$ intervals that overlap at the same time, and maximize over $k$.}
\WHY{Interval packing and clique partitioning are common in interviews; this variant mixes sweep-line with grouping constraints.}
\CHECKLIST{
\begin{bullets}
\item Compute maximum overlap $M$ to bound $k$.
\item Bucket starts by coordinate; keep a min-heap of right endpoints.
\item Sweep coordinate $x$; purge expired intervals.
\item When heap size $\ge k$, pop $k$, cut at the largest popped right endpoint, clear heap.
\item Track best $k \cdot \#\text{groups}$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Intervals sharing endpoints (closed segments intersect at endpoints).
\item Multiple identical intervals.
\item $k=1$ should return the number of disjoint windows you can form (all singletons).
\item No feasible group for large $k$.
\item Very short intervals among long ones (heap order must prefer early finishes).
\item Max coordinate exactly at $2n$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to purge expired intervals with $r<x$ before checking heap size.
\item Accidentally including intervals with $l \le$ previous cut (violates disjointness across groups).
\item Not clearing heap after forming a group (residual intervals would overlap the next group).
\item Off-by-one on closed endpoints (use $r+1$ in difference array).
\item Recomputing max overlap incorrectly when $n=0$.
\item Pushing starts at coordinates $\le$ previous cut.
\end{bullets}}
\FAILMODES{Approaches that only consider maximum clique size per connected component undercount when multiple groups can be formed inside a connected union (due to bridging intervals that you can ignore). The sweep-based greedy avoids this by explicit cuts.}
\ELI{Pick a team size $k$. Walk along time; when you see at least $k$ segments overlapping, pick the $k$ that end soonest, then fast-forward past them and repeat. Try all team sizes and keep the biggest total number of chosen segments.}
\NotePages{3}

\end{document}