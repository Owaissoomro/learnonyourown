% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Number of Bit Changes to Make Two Integers Equal}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/number-of-bit-changes-to-make-two-integers-equal/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given two positive integers $n$ and $k$. You can choose any bit in the binary representation of $n$ that is equal to $1$ and change it to $0$. Return the number of changes needed to make $n$ equal to $k$. If it is impossible, return $-1$.

Example 1:

Input: $n=13$, $k=4$

Output: $2$

Explanation: Initially, the binary representations of $n$ and $k$ are $n=(1101)_2$ and $k=(0100)_2$. We can change the first and fourth bits of $n$ from $1$ to $0$. The resulting integer is $n=(0100)_2=k$.

Example 2:

Input: $n=21$, $k=21$

Output: $0$

Explanation: $n$ and $k$ are already equal, so no changes are needed.

Example 3:

Input: $n=14$, $k=13$

Output: $-1$

Explanation: It is not possible to make $n$ equal to $k$ because some bit where $k$ has $1$ is $0$ in $n$.

Constraints: $1 \le n,k \le 10^6$.}
\BREAKDOWN{We can only flip $1 \to 0$ bits in $n$. Therefore $k$ must be a bitwise subset of $n$; otherwise it is impossible. If feasible, the minimum number of changes equals the count of $1$-bits in $n$ that are $0$ in $k$.}
\ELI{You can only turn off lamps that are on; you need $k$'s on-lamps to already be on in $n$, and the answer is how many extra on-lamps $n$ has to turn off.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n$ and $k$ with $1 \le n,k \le 10^6$.}
\OUTPUTS{Return an integer: the minimum number of $1 \to 0$ bit changes to transform $n$ into $k$ if possible; otherwise return $-1$.}
\SAMPLES{Example A: $n=13$, $k=4$ $\to 2$. Example B: $n=14$, $k=13$ $\to -1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the binary expansions be $n=\sum_{i \ge 0} n_i 2^i$ and $k=\sum_{i \ge 0} k_i 2^i$ with $n_i,k_i \in \{0,1\}$. An operation chooses an index $i$ with $n_i=1$ and sets it to $0$. We seek the minimum number of operations to obtain $n'=k$.}
\varmapStart
\var{n}{source integer}
\var{k}{target integer}
\var{n_i}{bit $i$ of $n$}
\var{k_i}{bit $i$ of $k$}
\var{\operatorname{popcount}(x)}{number of $1$-bits in $x$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Feasibility: } \forall i,\; k_i \le n_i \iff (k \mathbin{\&} \lnot n)=0.
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Minimum changes (if feasible): } \sum_{i \ge 0} \mathbf{1}\{n_i=1 \land k_i=0\} = \operatorname{popcount}(n \mathbin{\&} \lnot k) = \operatorname{popcount}(n)-\operatorname{popcount}(k).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Bit indexing is from least significant bit at $i=0$. Only $1 \to 0$ flips are allowed; no $0 \to 1$ flips. All arithmetic is on nonnegative integers.}
\INVARIANTS{The set of indices where the current value has $1$-bits is monotonically nonincreasing under allowed operations. If any $k_i=1$ with $n_i=0$ initially, it is impossible at once.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compare $n$ and $k$ bit by bit from least significant to most significant. If at any bit $k$ requires a $1$ where $n$ has $0$, return $-1$. Otherwise count positions where $n$ has $1$ and $k$ has $0$.}
\ASSUMPTIONS{We iterate up to $\lfloor \log_2(\max(n,k)) \rfloor + 1$ bits, which is small under the constraints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $ans \gets 0$.
\item For each bit while $n>0$ or $k>0$: let $a=n \bmod 2$, $b=k \bmod 2$.
\item If $b=1$ and $a=0$, return $-1$; else if $a=1$ and $b=0$, increment $ans$.
\item Set $n \gets \lfloor n/2 \rfloor$, $k \gets \lfloor k/2 \rfloor$ and repeat.
\item Return $ans$.
\end{algosteps}
\COMPLEXITY{The loop examines each bit once.}
\[
\begin{aligned}
T(n,k) &= O\!\left(\log_2(\max(n,k))+1\right),\\
S(n,k) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Every allowed operation clears a $1$ in $n$; therefore all bits with $k_i=1$ must already be $1$ in $n$. Counting $n_i=1,k_i=0$ gives the exact number of necessary clears; no other changes are needed.}
\EDGECASES{Equal numbers ($n=k$) yield $0$. If $k$ has a $1$ beyond the highest $1$ of $n$, it is immediately impossible.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution_A:
    def minChanges(self, n: int, k: int) -> int:
        ans = 0
        nn, kk = n, k
        while nn > 0 or kk > 0:
            a = nn & 1
            b = kk & 1
            if b == 1 and a == 0:
                return -1
            if a == 1 and b == 0:
                ans += 1
            nn >>= 1
            kk >>= 1
        return ans

# Basic asserts for the baseline approach
if __name__ == "__main__":
    A = Solution_A()
    assert A.minChanges(13, 4) == 2
    assert A.minChanges(21, 21) == 0
    assert A.minChanges(14, 13) == -1
\end{minted}
\VALIDATION{Checked the three examples; also quick check: n=1, k=0 returns 1; n=1, k=2 returns -1.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Bitwise Test + Popcount}
\WHICHFORMULA{Use feasibility test $(k \mathbin{\&} \lnot n)=0$. If feasible, answer is $\operatorname{popcount}(n \mathbin{\&} \lnot k)$. Python's \texttt{int.bit_count()} gives constant-time popcount on machine word size.}
\ASSUMPTIONS{Standard integer bit operations; popcount has $O(1)$ on typical CPython per call with small integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $(k \mathbin{\&} \lnot n) \ne 0$, return $-1$.
\item Return $(n \mathbin{\&} \lnot k).\texttt{bit_count()}$.
\end{algosteps}
\COMPLEXITY{Single-time bitwise ops and popcount.}
\[
\begin{aligned}
T(n,k) &= O(1)\ \text{on fixed word size (or }O(\log n)\text{ in bit length model}),\\
S(n,k) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Feasibility condition is exactly $k_i \le n_i$ for all $i$. The number of required clears is the count of positions with $n_i=1$ and $k_i=0$, i.e., $\operatorname{popcount}(n \mathbin{\&} \lnot k)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution_B:
    def minChanges(self, n: int, k: int) -> int:
        # Impossible if k has any 1 where n has 0
        if (k & ~n) != 0:
            return -1
        # Count 1-bits in n that are 0 in k
        return (n & ~k).bit_count()

# Asserts for improved approach
if __name__ == "__main__":
    B = Solution_B()
    assert B.minChanges(13, 4) == 2
    assert B.minChanges(21, 21) == 0
    assert B.minChanges(14, 13) == -1
    # extra checks
    assert B.minChanges(1, 0) == 1
    assert B.minChanges(8, 8) == 0
\end{minted}
\VALIDATION{Edge checks confirm: when $k$ has a $1$ not present in $n$ (e.g., $n=1,k=2$), it returns $-1$; when $k$ equals $n$, it returns $0$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Closed-Form Using Popcounts}
\WHICHFORMULA{Return $-1$ if $(k \mathbin{\&} \lnot n) \ne 0$; else return $\operatorname{popcount}(n)-\operatorname{popcount}(k)$, which equals $\operatorname{popcount}(n \mathbin{\&} \lnot k)$.}
\ASSUMPTIONS{Same as Approach B; uses identity $\operatorname{popcount}(x \mathbin{\&} \lnot y)=\operatorname{popcount}(x)-\operatorname{popcount}(x \mathbin{\&} y)$ and feasibility $k \subseteq n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $(k \mathbin{\&} \lnot n) \ne 0$, return $-1$.
\item Return $n.\texttt{bit_count()} - k.\texttt{bit_count()}$.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must at least inspect bits where $k$ has $1$ to verify feasibility. The closed form computes the answer with constant number of primitive operations; it is time-optimal up to constant factors in the unit-cost RAM model.}
\COMPLEXITY{Same as Approach B.}
\[
\begin{aligned}
T(n,k) &= O(1)\ \text{(unit-cost)}, \\
S(n,k) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# LeetCode-style class with a clear method name and signature.
class Solution:
    def minChanges(self, n: int, k: int) -> int:
        # If k has any 1 where n has 0, we cannot create that 1 by allowed operations.
        if (k & ~n) != 0:
            return -1
        # Number of 1->0 flips equals extra 1s present in n but not in k.
        return n.bit_count() - k.bit_count()

# Self-checks (3 asserts)
if __name__ == "__main__":
    S = Solution()
    assert S.minChanges(13, 4) == 2
    assert S.minChanges(21, 21) == 0
    assert S.minChanges(14, 13) == -1
\end{minted}
\VALIDATION{Exactly the three problem examples are asserted.}
\RESULT{Return $-1$ if any bit of $k$ is not present in $n$; otherwise return $\operatorname{popcount}(n)-\operatorname{popcount}(k)$, i.e., the number of $1$-bits to clear in $n$ to reach $k$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on examples, equality cases ($n=k$), impossible cases ($k$ has a high bit not in $n$), boundary values ($1$ and $10^6$), and randomized cross-check against a bitwise scan.}
\LINE{CROSS-CHECKS}{Compare baseline bit-by-bit (Approach A) with popcount forms (B,C) for many random pairs; they must match.}
\LINE{EDGE-CASE GENERATOR}{Generate small integers and ensure transitions across powers of two and mismatched high bits are covered.}
\begin{minted}{python}
import random

def baseline_scan(n: int, k: int) -> int:
    ans = 0
    nn, kk = n, k
    while nn > 0 or kk > 0:
        a, b = nn & 1, kk & 1
        if b == 1 and a == 0:
            return -1
        if a == 1 and b == 0:
            ans += 1
        nn >>= 1
        kk >>= 1
    return ans

def popcount_way(n: int, k: int) -> int:
    if (k & ~n) != 0:
        return -1
    return (n & ~k).bit_count()

def closed_form(n: int, k: int) -> int:
    if (k & ~n) != 0:
        return -1
    return n.bit_count() - k.bit_count()

if __name__ == "__main__":
    # Directed tests
    for n, k, want in [(13,4,2),(21,21,0),(14,13,-1),(1,0,1),(8,0,1),(8,8,0)]:
        assert baseline_scan(n,k) == want
        assert popcount_way(n,k) == want
        assert closed_form(n,k) == want

    # Random cross-checks
    rng = random.Random(0)
    for _ in range(5000):
        n = rng.randrange(0, 1_000_001)
        k = rng.randrange(0, 1_000_001)
        a = baseline_scan(n,k)
        b = popcount_way(n,k)
        c = closed_form(n,k)
        assert a == b == c
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def minChanges(self, n: int, k: int) -> int:
        # Check feasibility: cannot create 1s, so k must be a subset of n's 1-bits.
        if (k & ~n) != 0:
            return -1
        # Number of 1->0 flips equals extra 1-bits in n beyond those needed by k.
        return n.bit_count() - k.bit_count()

# Minimal self-test when run locally
if __name__ == "__main__":
    S = Solution()
    assert S.minChanges(13, 4) == 2
    assert S.minChanges(21, 21) == 0
    assert S.minChanges(14, 13) == -1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Feasibility check $(k \mathbin{\&} \lnot n)=0$ plus answer $\operatorname{popcount}(n)-\operatorname{popcount}(k)$.}
\WHY{Appears as a quick bit-manipulation screening problem; tests your ability to reason about allowed bit transitions and popcount identities.}
\CHECKLIST{
\begin{bullets}
\item Can I only clear bits? Then require $k$'s $1$-bits $\subseteq$ $n$'s $1$-bits.
\item Compute feasibility $(k \mathbin{\&} \lnot n)=0$.
\item If feasible, compute $\operatorname{popcount}(n \mathbin{\&} \lnot k)$ or $\operatorname{popcount}(n)-\operatorname{popcount}(k)$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=k$.
\item $k=0$.
\item $n=1$, $k=2$ (impossible, different high bit).
\item $n$ is a power of two; $k$ is zero or same power.
\item $k$ has a higher set bit than $n$.
\item Max bounds: $n$ or $k=10^6$.
\item Very small: $n=1$, $k=1$.
\item Many extra bits in $n$ relative to $k$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting the feasibility test and returning $\operatorname{popcount}(n \oplus k)$ (wrong problem).
\item Confusing $n \mathbin{\&} \lnot k$ with $k \mathbin{\&} \lnot n$.
\item Off-by-one in bit loops if implementing the baseline (ensure loop continues while $n>0$ or $k>0$).
\item Using signed shift assumptions; in Python, integers are unbounded and shifts are safe.
\item Forgetting to handle $k=0$ correctly (answer is $\operatorname{popcount}(n)$ if feasible, and it always is).
\item Misinterpreting ``change'' as allowing $0 \to 1$ flips.
\end{bullets}
}
\FAILMODES{Any approach that tries to build $k$ by turning on bits in $n$ fails due to operation constraints. The popcount formula survives all cases by first verifying subset relation.}
\ELI{You cannot light new bulbs; you can only switch off some of the ones that are already on. If the target has any bulb on that is currently off, it is impossible; otherwise, turn off exactly the extra bulbs.}
\NotePages{3}

\end{document}