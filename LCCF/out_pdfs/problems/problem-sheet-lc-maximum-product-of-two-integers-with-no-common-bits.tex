% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximum Product of Two Integers With No Common Bits}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximum-product-of-two-integers-with-no-common-bits/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given an integer array \texttt{nums}. Find two \textbf{distinct} indices $i$ and $j$ such that the product $nums[i] \times nums[j]$ is maximized, and the binary representations of $nums[i]$ and $nums[j]$ share no common set bits, i.e., $(nums[i] \mathbin{\&} nums[j]) = 0$. Return the \textbf{maximum} possible product of such a pair. If no such pair exists, return $0$.

Examples:
\begin{bullets}
\item Input: \texttt{nums = [1, 2, 3, 4, 5, 6, 7]}. Output: \texttt{12}. Explanation: The best pair is $3$ (011) and $4$ (100). They share no set bits and $3 \times 4 = 12$.
\item Input: \texttt{nums = [5, 6, 4]}. Output: \texttt{0}. Explanation: Every pair has a common set bit, so no valid pair exists.
\item Input: \texttt{nums = [64, 8, 32]}. Output: \texttt{2048}. Explanation: No pair shares a common bit, so the product of the two maximum elements is $64 \times 32 = 2048$.
\end{bullets}

Constraints:
\begin{bullets}
\item $2 \le \texttt{nums.length} \le 10^5$
\item $1 \le \texttt{nums}[i] \le 10^6$
\end{bullets}
}
\BREAKDOWN{We must maximize $a \times b$ over two distinct elements with bitwise-\texttt{AND} equal to zero. A direct $O(n^2)$ scan is too slow for $n$ up to $10^5$. We exploit bitmask structure: each number is its own bitmask (since values are $\le 10^6$), and disjointness means masks have no overlapping $1$ bits.}
\ELI{We want the best pair of numbers whose $1$-bits do not clash.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{On LeetCode, implement \texttt{class Solution} with method \texttt{def maxProductNoCommonBits(self, nums: List[int]) -> int}. The input array length satisfies $2 \le n \le 10^5$, with $1 \le nums[i] \le 10^6$.}
\OUTPUTS{Return the maximum product of two distinct elements whose bitwise-\texttt{AND} is $0$. If no such pair exists, return $0$.}
\SAMPLES{
\begin{bullets}
\item \texttt{nums = [1, 2, 3, 4, 5, 6, 7]} $\to$ \texttt{12}
\item \texttt{nums = [5, 6, 4]} $\to$ \texttt{0}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A = (a_1,\ldots,a_n)$, and let $m(x)$ denote the bitmask of $x$ (the set of positions of $1$-bits in $x$). We seek
\begin{BreakableEquation*}
\max_{1 \le i < j \le n} a_i a_j \quad \text{s.t.} \quad m(a_i) \mathbin{\&} m(a_j) = 0.
\end{BreakableEquation*}
Equivalently, $a_i \mathbin{\&} a_j = 0$.}
\varmapStart
\var{n}{array length}
\var{a_i}{the $i$-th value in the array}
\var{B}{number of relevant bits; $B = \max_i \lceil \log_2(a_i+1)\rceil \le 20$}
\var{m(x)}{the bitmask of $x$; here $m(x)=x$ since $x$ encodes its bits}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer} = \max_{i} \left\{ a_i \cdot \left(\max_{s \subseteq \overline{m(a_i)}} a_{k(s)}\right) \right\},
\end{BreakableEquation*}
where $\overline{m}$ is the $B$-bit complement and $k(s)$ ranges over indices whose mask is $s$.}
\ASSUMPTIONS{All numbers are nonzero and at most $10^6$, so $B \le 20$. Distinct indices are required.}
\INVARIANTS{
\begin{bullets}
\item If $a_i \mathbin{\&} a_j = 0$, then $m(a_i) \subseteq \overline{m(a_j)}$ and $m(a_j) \subseteq \overline{m(a_i)}$.
\item For a fixed mask $S$, the maximum over all submasks of $S$ can be precomputed by Sum Over Subsets DP (SOS DP).
\end{bullets}
}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all pairs $(i,j)$, check $a_i \mathbin{\&} a_j = 0$, and keep the maximum $a_i a_j$.}
\ASSUMPTIONS{None beyond constraints; intended as a correctness baseline for small $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{best} to $0$.
\item For each $0 \le i < j < n$, if $(a_i \mathbin{\&} a_j) = 0$, set \texttt{best} to $\max(\texttt{best}, a_i \times a_j)$.
\item Return \texttt{best}.
\end{algosteps}
\COMPLEXITY{Time $T(n) = \Theta(n^2)$, space $S(n) = \Theta(1)$ extra.}
\[
\begin{aligned}
T(n) &= \binom{n}{2} = \frac{n(n-1)}{2} = \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{All pairs are tested; the maximum among valid pairs is returned, otherwise $0$.}
\EDGECASES{All pairs collide on at least one bit; arrays with many duplicates; minimal $n=2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxProductNoCommonBits(self, nums: List[int]) -> int:
        n = len(nums)
        best = 0
        for i in range(n):
            ai = nums[i]
            for j in range(i + 1, n):
                aj = nums[j]
                if (ai & aj) == 0:
                    prod = ai * aj
                    if prod > best:
                        best = prod
        return best

# Basic validation
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxProductNoCommonBits([1,2,3,4,5,6,7]) == 12
    assert sol.maxProductNoCommonBits([5,6,4]) == 0
    assert sol.maxProductNoCommonBits([64,8,32]) == 2048
    # More checks
    assert sol.maxProductNoCommonBits([1,2]) == 2
    assert sol.maxProductNoCommonBits([1,1]) == 0
\end{minted}
\VALIDATION{The asserts cover the samples and a few corner cases: disjoint pair, no pair, duplicates.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sorting With Product-Based Pruning}
\WHICHFORMULA{Sort descending. For each $i$, any partner $j>i$ yields product $\le nums[i] \times nums[j]$. If that upper bound no longer beats the current best, break the inner loop.}
\ASSUMPTIONS{Sorting does not change correctness; pruning only skips pairs that cannot improve the current best.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort \texttt{nums} in nonincreasing order.
\item For each $i$ from $0$ to $n-1$:
  \begin{bullets}
  \item If $nums[i] \times nums[i+1] \le \texttt{best}$, break; no later pair can beat \texttt{best}.
  \item For $j$ from $i+1$ to $n-1$:
    \begin{bullets}
    \item If $nums[i] \times nums[j] \le \texttt{best}$, break; further $j$ only shrink product.
    \item If $(nums[i] \mathbin{\&} nums[j]) = 0$, update \texttt{best}.
    \end{bullets}
  \end{bullets}
\item Return \texttt{best}.
\end{algosteps}
\COMPLEXITY{Worst case still $O(n^2)$, but often prunes heavily when values drop fast. Sorting costs $O(n \log n)$.}
\[
\begin{aligned}
T(n) &= O(n \log n) + O(\text{pairs inspected after pruning}), \\
     &\le O(n^2) \text{ in the worst case.}
\end{aligned}
\]
\CORRECTNESS{Pruning only occurs when the maximal possible product with the current $i$ cannot exceed the incumbent best; thus, no optimal pair is skipped.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxProductNoCommonBits(self, nums: List[int]) -> int:
        arr = sorted(nums, reverse=True)
        n = len(arr)
        best = 0
        for i in range(n):
            if i + 1 < n and arr[i] * arr[i + 1] <= best:
                break
            ai = arr[i]
            for j in range(i + 1, n):
                if ai * arr[j] <= best:
                    break
                if (ai & arr[j]) == 0:
                    prod = ai * arr[j]
                    if prod > best:
                        best = prod
        return best

# Checks on edge inputs
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxProductNoCommonBits([1,2,3,4,5,6,7]) == 12
    assert sol.maxProductNoCommonBits([5,6,4]) == 0
    assert sol.maxProductNoCommonBits([64,8,32]) == 2048
    # Cases with many equal values
    assert sol.maxProductNoCommonBits([3,3,3]) == 0
\end{minted}
\VALIDATION{Covers samples and adversarial duplicates.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sum Over Subsets DP (SOS DP) on Bitmasks}
\WHICHFORMULA{Let $B$ be the bit length of $\max(nums)$. Build an array \texttt{dp} over all $B$-bit masks where \texttt{dp[mask]} stores the maximum value among numbers whose mask is a submask of \texttt{mask}. For each $x$, query \texttt{dp[\textasciitilde mask(x)]} to get the best disjoint partner.}
\ASSUMPTIONS{Values $\le 10^6$ imply $B \le 20$, so $2^B \approx 10^6$ is feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set $B = \max(1, \text{bit\_length}(\max(nums)))$, \texttt{SIZE} $= 2^B$.
\item Create \texttt{base} of length \texttt{SIZE} with zeros. For each $v$ in \texttt{nums}, set \texttt{base[v]} $\gets \max(\texttt{base[v]}, v)$.
\item Initialize \texttt{dp = base}. For each bit $b$ from $0$ to $B-1$, for each \texttt{mask} with bit $b$ set, do \texttt{dp[mask]} $\gets \max(\texttt{dp[mask]}, \texttt{dp[mask \textasciicircum (1<<b)]})$. After this, \texttt{dp[S]} is the maximum value among all submasks of $S$.
\item For each $v$ in \texttt{nums}, let $C = ((1 \ll B) - 1) \mathbin{\wedge} \sim v$ (the $B$-bit complement). If \texttt{dp[C]} $> 0$, update \texttt{best} with $v \times \texttt{dp[C]}$.
\item Return \texttt{best}.
\end{algosteps}
\OPTIMALITY{Each candidate partner for $v$ must have mask contained in the complement of $v$'s mask. The SOS DP precomputes, for every complement mask, the maximum-valued available partner in $O(2^B B)$ time, yielding an $O(n + 2^B B)$ total algorithm, which is tight up to constants for this bitmask domain.}
\COMPLEXITY{Let $B \le 20$.
\[
\begin{aligned}
T(n) &= O(n) \;(\text{build}) + O(2^B \cdot B) \;(\text{SOS DP}) + O(n) \;(\text{queries}) = O(n + 2^B B),\\
S(n) &= O(2^B).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxProductNoCommonBits(self, nums: List[int]) -> int:
        # Determine bit width
        mx = max(nums)
        B = max(1, mx.bit_length())  # at most 20 for nums[i] <= 1e6
        SIZE = 1 << B

        # base[mask] = maximum value among numbers with exact mask == mask
        base = [0] * SIZE
        for v in nums:
            # value v is its own mask since mask(v) == v (within B bits)
            base[v] = v if v > base[v] else base[v]

        # SOS DP: dp[mask] = maximum over all submasks of mask
        dp = base[:]  # copy
        # For each bit position, propagate from submask without the bit to supermask with the bit
        for b in range(B):
            bit = 1 << b
            for mask in range(SIZE):
                if mask & bit:
                    # Combine with submask missing this bit
                    sub = mask ^ bit
                    if dp[sub] > dp[mask]:
                        dp[mask] = dp[sub]

        # Query for each value: best partner among submasks of complement
        all_bits_mask = (1 << B) - 1
        best = 0
        for v in nums:
            complement = all_bits_mask ^ v
            partner = dp[complement]
            if partner:
                prod = v * partner
                if prod > best:
                    best = prod
        return best

# Exactly 3 asserts (mini-tests)
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxProductNoCommonBits([1,2,3,4,5,6,7]) == 12
    assert sol.maxProductNoCommonBits([5,6,4]) == 0
    assert sol.maxProductNoCommonBits([64,8,32]) == 2048
\end{minted}
\VALIDATION{The three asserts match the problem examples.}
\RESULT{Return the maximum product among pairs with disjoint set bits; return $0$ if no such pair exists.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests: samples; minimal $n=2$; all pairs invalid (e.g., powers of two colliding); random small arrays cross-checked by brute force.}
\LINE{CROSS-CHECKS}{Compare Approaches A, B, and C on small random instances ($n \le 60$) to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of identical numbers; arrays of powers of two; arrays with numbers that are complements within $B$ bits.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_all_equal(n: int, v: int) -> List[int]:
    return [v] * n

def gen_powers_of_two(n: int, B: int = 20) -> List[int]:
    arr = []
    for i in range(n):
        arr.append(1 << (i % B))
    return arr

def gen_complements(n: int, B: int = 20) -> List[int]:
    # Pairs like (x, ~x & ((1<<B)-1)) are disjoint
    res = []
    mask = (1 << B) - 1
    for i in range(n // 2):
        x = (i + 1) | (1 << (i % B))
        res.extend([x, mask ^ x])
    if len(res) < n:
        res.append(1)
    return res[:n]

# Reference brute-force for cross-check on small inputs
def brute(nums: List[int]) -> int:
    best = 0
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if (nums[i] & nums[j]) == 0:
                best = max(best, nums[i] * nums[j])
    return best
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxProductNoCommonBits(self, nums: List[int]) -> int:
        mx = max(nums)
        B = max(1, mx.bit_length())
        SIZE = 1 << B
        base = [0] * SIZE
        for v in nums:
            if v > base[v]:
                base[v] = v
        dp = base[:]
        for b in range(B):
            bit = 1 << b
            for mask in range(SIZE):
                if mask & bit:
                    sub = mask ^ bit
                    if dp[sub] > dp[mask]:
                        dp[mask] = dp[sub]
        all_bits_mask = (1 << B) - 1
        best = 0
        for v in nums:
            partner = dp[all_bits_mask ^ v]
            if partner:
                prod = v * partner
                if prod > best:
                    best = prod
        return best

if __name__ == "__main__":
    sol = Solution()
    assert sol.maxProductNoCommonBits([1,2]) == 2
    assert sol.maxProductNoCommonBits([1,1]) == 0
    assert sol.maxProductNoCommonBits([1,2,3,4,5,6,7]) == 12
    assert sol.maxProductNoCommonBits([5,6,4]) == 0
    assert sol.maxProductNoCommonBits([64,8,32]) == 2048
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize $a \times b$ subject to $(a \mathbin{\&} b) = 0$, using SOS DP over masks to query the best disjoint partner.}
\WHY{Classic pattern: replace $O(n^2)$ pair scans by subset transforms when the constraint is submask-based.}
\CHECKLIST{
\begin{bullets}
\item Compute $B = \text{bit\_length}(\max(nums))$.
\item Build \texttt{base[mask]} with maxima for exact masks.
\item SOS DP to fill \texttt{dp} with submask maxima.
\item Query complements and update the best product.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item No valid pair at all $\to$ return $0$.
\item Duplicate values and masks; distinct indices still required.
\item $n=2$ minimal size.
\item Very small $B$ (e.g., all ones like \texttt{[1,1,1]}).
\item Large values near $10^6$; product up to about $10^{12}$.
\item Highly skewed arrays (one huge value plus many small).
\item Many powers of two; abundant disjoint pairs.
\item Numbers sharing a common lowest bit.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using $B=32$ or $64$ unnecessarily increases $2^B$; cap $B$ to \texttt{max(nums).bit\_length()}.
\item Forgetting that each value is its own mask in this setting.
\item Off-by-one in the SOS DP loops over bits and masks.
\item Overwriting \texttt{dp} incorrectly (must take max).
\item Accidentally pairing an element with itself (impossible here since masks cannot be submasks of their own complement).
\item Assuming the answer fits in 32-bit integers; use Python int.
\item Not handling the case when \texttt{dp[complement]} is $0$ (no partner).
\item Using dense loops in Python without pruning in non-DP approaches.
\end{bullets}
}
\FAILMODES{Brute force times out at $n=10^5$. Sorting-only heuristics still degrade on adversarial inputs. SOS DP succeeds because it transforms submask queries into linear-time over $2^B$ with $B \le 20$.}
\ELI{Think of each number as a set of bit positions. We want two sets that do not overlap and whose values multiply to the largest number. Precompute, for every set of allowed bits, the largest value available; then for each number, look up the best partner that fits in its complement.}
\NotePages{3}

\end{document}