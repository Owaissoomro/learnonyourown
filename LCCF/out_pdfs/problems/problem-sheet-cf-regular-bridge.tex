% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Regular Bridge}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/550/D}}
\LINE{DIFFICULTY / RATING}{1900 (CF 550/D)}
\STATEMENT{An undirected graph is called $k$-regular, if the degrees of all its vertices are equal $k$. An edge of a connected graph is called a bridge, if after removing it the graph is being split into two connected components.

Build a connected undirected $k$-regular graph containing at least one bridge, or else state that such graph does not exist.

Input:
The single line of the input contains integer $k$ ($1 \le k \le 100$) — the required degree of the vertices of the regular graph.

Output:
Print ``NO'' (without quotes), if such graph does not exist.

Otherwise, print ``YES'' in the first line and the description of any suitable graph in the next lines.

The description of the made graph must start with numbers $n$ and $m$ — the number of vertices and edges respectively.

Each of the next $m$ lines must contain two integers, $a$ and $b$ ($1 \le a, b \le n$, $a \ne b$), that mean that there is an edge connecting the vertices $a$ and $b$. A graph should not contain multiple edges and edges that lead from a vertex to itself. A graph must be connected, the degrees of all vertices of the graph must be equal $k$. At least one edge of the graph must be a bridge. You can print the edges of the graph in any order. You can print the ends of each edge in any order.

The constructed graph must contain at most $10^6$ vertices and $10^6$ edges (it is guaranteed that if at least one graph that meets the requirements exists, then there also exists the graph with at most $10^6$ vertices and at most $10^6$ edges).

Note:
In the sample from the statement there is a suitable graph consisting of two vertices, connected by a single edge.}
\BREAKDOWN{Decide feasibility based on the parity of $k$, and if feasible, construct an explicit graph with a bridge and all degrees equal to $k$ within the bounds.}
\ELI{Even $k$ is impossible; for odd $k$, glue two identical $k$-regular gadgets by a single edge so that this edge is a bridge.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $k$ with $1 \le k \le 100$.}
\OUTPUTS{Either print ``NO'', or print ``YES'' followed by:
- $n$ and $m$,
- then $m$ edges as pairs $a~b$ ($1 \le a<b \le n$) describing a simple connected graph in which all vertex degrees are $k$ and at least one edge is a bridge.}
\SAMPLES{Examples (illustrative):
- Input: 1; Output: YES, $n=2$, $m=1$, edge $1~2$.
- Input: 2; Output: NO.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Find a simple connected graph $G=(V,E)$ such that $\deg_G(v)=k$ for all $v\in V$, and there exists $e\in E$ whose removal disconnects $G$.}
\varmapStart
\var{k}{target regular degree}
\var{n}{number of vertices}
\var{m}{number of edges}
\var{e^\ast}{a designated bridge edge}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall v\in V:\ \deg_G(v)=k,\qquad \text{$G$ connected},\qquad \exists e^\ast\in E:\ G-e^\ast\ \text{is disconnected.}
\end{BreakableEquation*}
}
\ASSUMPTIONS{Simple undirected graphs; no multiple edges or loops; indices $1..n$.}
\INVARIANTS{
- Sum of degrees equals $2m$ is even; if a component has all degrees $k$ except one of $k-1$, its order must be odd.
- A single inter-component edge is a bridge iff no other cross edges exist.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Parity obstruction: a $k$-regular graph with a bridge exists iff $k$ is odd; for $k=1$, the graph is a single edge.}
\ASSUMPTIONS{Use direct constructive patterns or declare impossibility by parity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k=1$: output two vertices and one edge.
\item Else if $k$ is even: output NO.
\item Else ($k\ge 3$ odd): construct by simple hand-crafted small cases or trial assembly (baseline, not scalable). 
\end{algosteps}
\COMPLEXITY{The baseline relies on ad hoc assembly; not precise.}
\[
\begin{aligned}
T(n) &= O(1)\ \text{decisions only} \\
\end{aligned}
\]
\CORRECTNESS{Parity check is necessary; however, baseline lacks a general construction for all odd $k\ge 3$.}
\EDGECASES{$k=1$; even $k$; minimal odd $k=3$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input() -> int:
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def solve_case_baseline(k: int):
    if k == 1:
        n = 2
        edges = [(1, 2)]
        return ("YES", n, edges)
    if k % 2 == 0:
        return ("NO", None, None)
    # Placeholder naive attempt: for k odd and >=3, this baseline just says NO (not acceptable for final)
    # Left here to satisfy baseline stage; improved stages will provide full construction.
    return ("NO", None, None)

def solve_all():
    k = read_input()
    ans, n, edges = solve_case_baseline(k)
    if ans == "NO":
        print("NO")
    else:
        print("YES")
        m = len(edges)
        print(n, m)
        for a, b in edges:
            print(a, b)

if __name__ == "__main__":
    # Simple asserts on trivial cases
    assert solve_case_baseline(1)[0] == "YES"
    assert solve_case_baseline(2)[0] == "NO"
    # For k=3, baseline is intentionally incomplete
    assert solve_case_baseline(3)[0] == "NO"
\end{minted}
\VALIDATION{Baseline only validates $k=1$ and even $k$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Symmetric Gadget With a Bridge}
\WHICHFORMULA{For odd $k$, build two identical odd-order components, each $k$-regular except one special vertex of degree $k-1$; connect these two specials by a single edge to make a bridge and raise both to degree $k$.}
\ASSUMPTIONS{Within a component, start from $K_{k,k}$, delete a matching of size $k-1$ to free degrees on one side, add a perfect matching among those freed vertices, and connect the special vertex to $k-1$ vertices on the other side.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k=1$: output two vertices with the single edge.
\item If $k$ is even: output NO (impossible).
\item Else ($k\ge 3$ odd), construct one component on $2k+1$ vertices:
  \begin{bullets}
  \item Partitions $L=\{1,\ldots,k\}$, $R=\{k+1,\ldots,2k\}$, and special $s=2k+1$.
  \item Add all bipartite edges $L$--$R$ (i.e., $K_{k,k}$).
  \item Remove the matching edges $(i, k+i)$ for $i=1,\ldots,k-1$.
  \item Add a perfect matching inside $R'=\{k+1,\ldots,2k-1\}$ by pairing consecutive vertices.
  \item Connect $s$ to vertices $1,\ldots,k-1$ in $L$.
  \end{bullets}
\item Duplicate this component disjointly and connect the two special vertices by a single bridge edge.
\end{algosteps}
\COMPLEXITY{Linear in the output size $m=2k^2+k=O(k^2)$.}
\[
\begin{aligned}
T(k) &= \Theta(k^2),\quad S(k)=\Theta(k^2)\ \text{(to store edges).}
\end{aligned}
\]
\CORRECTNESS{Degrees: In each component, all vertices have degree $k$ except $s$ with degree $k-1$; the final bridge increases both specials to $k$. Connectivity: each component is connected (dense bipartite core with small edits), and the only cross-component edge is the bridge, hence it is indeed a bridge.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import defaultdict, deque

def read_input() -> int:
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def build_component(k: int, offset: int):
    """
    Build one (2k+1)-vertex component:
    - Vertices: offset+1..offset+k (L), offset+k+1..offset+2k (R), s=offset+2k+1
    - Start with K_{k,k} between L and R
    - Remove edges (L_i, R_i) for i=1..k-1
    - Add matching inside R' = R[0..k-2] by consecutive pairs
    - Connect s to L_1..L_{k-1}
    Returns: (edges, s_index)
    """
    edges = []
    L = [offset + i for i in range(1, k + 1)]
    R = [offset + k + j for j in range(1, k + 1)]
    s = offset + 2 * k + 1

    # K_{k,k} minus a matching for i=1..k-1 (map i -> R[i-1])
    removed = set()
    for i in range(1, k):  # 1..k-1
        a = offset + i
        b = offset + k + i
        if a > b:
            a, b = b, a
        removed.add((a, b))

    for li in L:
        for rj in R:
            a, b = (li, rj) if li < rj else (rj, li)
            if (a, b) not in removed:
                edges.append((a, b))

    # Perfect matching inside R' = R excluding the last vertex (size k-1, which is even)
    for idx in range(0, k - 1, 2):
        a = R[idx]
        b = R[idx + 1]
        if a > b:
            a, b = b, a
        edges.append((a, b))

    # Connect s to L[0..k-2]
    for li in L[:-1]:
        a, b = (s, li) if s < li else (li, s)
        edges.append((a, b))

    return edges, s

def solve_case_improved(k: int):
    if k == 1:
        return ("YES", 2, [(1, 2)])
    if k % 2 == 0:
        return ("NO", None, None)

    # Build two components and connect specials
    edges_all = []
    comp1_edges, s1 = build_component(k, 0)
    comp2_edges, s2 = build_component(k, 2 * k + 1)
    edges_all.extend(comp1_edges)
    edges_all.extend(comp2_edges)
    # Bridge last to facilitate testing
    edges_all.append((min(s1, s2), max(s1, s2)))

    n = 4 * k + 2
    return ("YES", n, edges_all)

def solve_all():
    k = read_input()
    ans, n, edges = solve_case_improved(k)
    if ans == "NO":
        print("NO")
        return
    print("YES")
    m = len(edges)
    print(n, m)
    for a, b in edges:
        print(a, b)

def _check_degrees(n, edges, k):
    deg = [0] * (n + 1)
    seen = set()
    for a, b in edges:
        assert 1 <= a <= n and 1 <= b <= n and a != b
        e = (a, b) if a < b else (b, a)
        assert e not in seen
        seen.add(e)
        deg[a] += 1
        deg[b] += 1
    for v in range(1, n + 1):
        assert deg[v] == k

def _is_connected(n, edges):
    g = [[] for _ in range(n + 1)]
    for a, b in edges:
        g[a].append(b)
        g[b].append(a)
    vis = [False] * (n + 1)
    q = deque([1])
    vis[1] = True
    cnt = 0
    while q:
        u = q.popleft()
        cnt += 1
        for w in g[u]:
            if not vis[w]:
                vis[w] = True
                q.append(w)
    return cnt == n

if __name__ == "__main__":
    # Quick checks
    assert solve_case_improved(2)[0] == "NO"
    ok1, n1, e1 = solve_case_improved(1)
    assert ok1 == "YES" and n1 == 2 and e1 == [(1, 2)]
    ok3, n3, e3 = solve_case_improved(3)
    assert ok3 == "YES" and n3 == 14
    _check_degrees(n3, e3, 3)
    # The last edge is the bridge between the two specials; removing it disconnects.
    e3_wo = e3[:-1]
    assert not _is_connected(n3, e3_wo)
\end{minted}
\VALIDATION{Asserts for $k=1$, $k=2$, and $k=3$; degree checks and bridge removal connectivity check for $k=3$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Canonical CF Construction for Odd $k$}
\WHICHFORMULA{Use the $K_{k,k}$-based component of size $2k+1$ per side; join the two specials by a single edge. This yields $n=4k+2$, $m=2k^2+k$, within bounds.}
\ASSUMPTIONS{$k$ odd $\Rightarrow$ $k-1$ is even, so the perfect matching inside $R'$ exists. For $k=1$, the trivial single edge works; even $k$ is impossible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k=1$: output the graph with vertices $\{1,2\}$ and edge $(1,2)$.
\item Else if $k$ is even: print NO.
\item Else:
  \begin{bullets}
  \item Build two disjoint components as in Approach B with offsets $0$ and $2k+1$.
  \item Add the bridge between the two special vertices.
  \end{bullets}
\end{algosteps}
\OPTIMALITY{Meets all constraints with minimal conceptual complexity; output size is $\Theta(k^2)$ which is optimal up to constants for such dense constructions.}
\COMPLEXITY{Time and space linear in the number of edges emitted.}
\[
\begin{aligned}
T(k) &= \Theta(k^2),\qquad S(k)=\Theta(k^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input() -> int:
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def build_component(k: int, offset: int):
    """
    Build one component (2k+1 vertices) with all degrees k except the special s of degree k-1.
    L = offset+1..offset+k, R = offset+k+1..offset+2k, s = offset+2k+1.
    Edges:
      - All L-R edges except (L_i, R_i) for i=1..k-1
      - Matching inside R' = {R_1..R_{k-1}} by consecutive pairs
      - (s, L_i) for i=1..k-1
    """
    edges = []
    L = [offset + i for i in range(1, k + 1)]
    R = [offset + k + j for j in range(1, k + 1)]
    s = offset + 2 * k + 1

    removed = set()
    for i in range(1, k):  # remove (L_i, R_i) for i=1..k-1
        a = offset + i
        b = offset + k + i
        if a > b:
            a, b = b, a
        removed.add((a, b))

    for li in L:
        for rj in R:
            a, b = (li, rj) if li < rj else (rj, li)
            if (a, b) not in removed:
                edges.append((a, b))

    # Perfect matching inside R' of size k-1 (even when k is odd)
    for idx in range(0, k - 1, 2):
        a = R[idx]
        b = R[idx + 1]
        if a > b:
            a, b = b, a
        edges.append((a, b))

    # Connect s to first k-1 vertices in L
    for li in L[:-1]:
        a, b = (s, li) if s < li else (li, s)
        edges.append((a, b))

    return edges, s

def solve_case(k: int):
    if k == 1:
        return ("YES", 2, [(1, 2)])
    if k % 2 == 0:
        return ("NO", None, None)

    edges_all = []
    comp1_edges, s1 = build_component(k, 0)
    comp2_edges, s2 = build_component(k, 2 * k + 1)
    edges_all.extend(comp1_edges)
    edges_all.extend(comp2_edges)
    # Add the bridge last
    a, b = (s1, s2) if s1 < s2 else (s2, s1)
    edges_all.append((a, b))

    n = 4 * k + 2
    return ("YES", n, edges_all)

def solve_all():
    k = read_input()
    ans, n, edges = solve_case(k)
    if ans == "NO":
        print("NO")
        return
    print("YES")
    print(n, len(edges))
    for a, b in edges:
        print(a, b)

# --- Tests ---
def _check_degrees(n, edges, k):
    deg = [0] * (n + 1)
    seen = set()
    for a, b in edges:
        assert 1 <= a <= n and 1 <= b <= n and a != b
        e = (a, b) if a < b else (b, a)
        assert e not in seen
        seen.add(e)
        deg[a] += 1
        deg[b] += 1
    for v in range(1, n + 1):
        assert deg[v] == k

def _is_connected(n, edges):
    g = [[] for _ in range(n + 1)]
    for a, b in edges:
        g[a].append(b)
        g[b].append(a)
    vis = [False] * (n + 1)
    q = deque([1])
    vis[1] = True
    cnt = 0
    while q:
        u = q.popleft()
        cnt += 1
        for w in g[u]:
            if not vis[w]:
                vis[w] = True
                q.append(w)
    return cnt == n

if __name__ == "__main__":
    # Deterministic asserts
    assert solve_case(2)[0] == "NO"
    ok1, n1, e1 = solve_case(1)
    assert ok1 == "YES" and n1 == 2 and e1 == [(1, 2)]
    ok3, n3, e3 = solve_case(3)
    assert ok3 == "YES" and n3 == 14
    _check_degrees(n3, e3, 3)
    # Remove last edge (the bridge) and connectivity breaks
    e3_wo = e3[:-1]
    assert not _is_connected(n3, e3_wo)
    # Ready to run solve_all() for judge input
    # Commented out to avoid interfering with asserts in local runs:
    # solve_all()
\end{minted}
\VALIDATION{Exactly three asserts: $k=2$ NO, $k=1$ trivial, $k=3$ degree and bridge removal check.}
\RESULT{If $k$ is even and not $1$, print NO. If $k=1$, output $n=2$, $m=1$, edge $(1,2)$. If $k\ge 3$ is odd, output $n=4k+2$ and $m=2k^2+k$ with edges as constructed; the last printed edge is a bridge.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify parity handling; for odd $k$, check degrees and that removing the final bridge disconnects the graph.}
\LINE{CROSS-CHECKS}{Compare degree sequences and edge counts for $k\in\{1,3,5\}$; ensure $n=4k+2$, $m=2k^2+k$.}
\LINE{EDGE-CASE GENERATOR}{Generate small odd $k$ values and validate properties deterministically.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from collections import deque

def generate_k_values():
    return [1, 2, 3, 5, 7]

def reference_construct(k: int):
    # Reuse final solution construction for reference
    from typing import Tuple, List
    def build_component(k: int, offset: int):
        edges = []
        L = [offset + i for i in range(1, k + 1)]
        R = [offset + k + j for j in range(1, k + 1)]
        s = offset + 2 * k + 1
        removed = set()
        for i in range(1, k):
            a = offset + i
            b = offset + k + i
            if a > b: a, b = b, a
            removed.add((a, b))
        for li in L:
            for rj in R:
                a, b = (li, rj) if li < rj else (rj, li)
                if (a, b) not in removed:
                    edges.append((a, b))
        for idx in range(0, k - 1, 2):
            a = R[idx]; b = R[idx + 1]
            if a > b: a, b = b, a
            edges.append((a, b))
        for li in L[:-1]:
            a, b = (s, li) if s < li else (li, s)
            edges.append((a, b))
        return edges, s
    if k == 1:
        return 2, [(1, 2)]
    if k % 2 == 0:
        return None, None
    e1, s1 = build_component(k, 0)
    e2, s2 = build_component(k, 2 * k + 1)
    edges = e1 + e2 + [((s1 if s1 < s2 else s2), (s2 if s1 < s2 else s1))]
    n = 4 * k + 2
    return n, edges

def check(n, edges, k):
    if n is None:
        return k % 2 == 0 and k != 1
    deg = [0]*(n+1)
    seen = set()
    for a,b in edges:
        assert 1<=a<=n and 1<=b<=n and a!=b
        e = (a,b) if a<b else (b,a)
        assert e not in seen
        seen.add(e)
        deg[a]+=1; deg[b]+=1
    assert all(d==k for d in deg[1:])
    # remove last edge and test connectivity
    g=[[] for _ in range(n+1)]
    for a,b in edges[:-1]:
        g[a].append(b); g[b].append(a)
    vis=[False]*(n+1)
    q=deque([1]); vis[1]=True; cnt=0
    while q:
        u=q.popleft(); cnt+=1
        for w in g[u]:
            if not vis[w]:
                vis[w]=True; q.append(w)
    return cnt!=n

def main_test():
    for k in generate_k_values():
        n, edges = reference_construct(k)
        assert check(n, edges, k), f"failed for k={k}"

if __name__ == "__main__":
    main_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input() -> int:
    data = sys.stdin.read().strip().split()
    return int(data[0]) if data else 0

def build_component(k: int, offset: int):
    edges = []
    L = [offset + i for i in range(1, k + 1)]
    R = [offset + k + j for j in range(1, k + 1)]
    s = offset + 2 * k + 1

    removed = set()
    for i in range(1, k):
        a = offset + i
        b = offset + k + i
        if a > b:
            a, b = b, a
        removed.add((a, b))

    for li in L:
        for rj in R:
            a, b = (li, rj) if li < rj else (rj, li)
            if (a, b) not in removed:
                edges.append((a, b))

    for idx in range(0, k - 1, 2):
        a = R[idx]
        b = R[idx + 1]
        if a > b:
            a, b = b, a
        edges.append((a, b))

    for li in L[:-1]:
        a, b = (s, li) if s < li else (li, s)
        edges.append((a, b))

    return edges, s

def solve_case(k: int):
    if k == 1:
        return ("YES", 2, [(1, 2)])
    if k % 2 == 0:
        return ("NO", None, None)
    edges_all = []
    comp1_edges, s1 = build_component(k, 0)
    comp2_edges, s2 = build_component(k, 2 * k + 1)
    edges_all.extend(comp1_edges)
    edges_all.extend(comp2_edges)
    a, b = (s1, s2) if s1 < s2 else (s2, s1)
    edges_all.append((a, b))
    n = 4 * k + 2
    return ("YES", n, edges_all)

def main():
    k = read_input()
    ans, n, edges = solve_case(k)
    if ans == "NO":
        print("NO")
        return
    print("YES")
    print(n, len(edges))
    for a, b in edges:
        print(a, b)

if __name__ == "__main__":
    # Minimal internal asserts
    assert solve_case(2)[0] == "NO"
    ok1, n1, e1 = solve_case(1)
    assert ok1 == "YES" and n1 == 2 and e1 == [(1, 2)]
    ok3, n3, e3 = solve_case(3)
    assert ok3 == "YES" and n3 == 14 and len(e3) == 2 * 3 * 3 + 3
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Odd $k$ admits a construction; even $k$ does not (except the trivial $k=1$).}
\WHY{Combines degree-regularity with a bridge, testing understanding of parity constraints and explicit constructions.}
\CHECKLIST{
- Check $k=1$ trivial case.
- If $k$ even: print NO.
- If $k$ odd: build two components of size $2k+1$ each with one special of degree $k-1$.
- Add only one inter-component edge as the bridge.
- Verify $n=4k+2$, $m=2k^2+k$, within bounds.}
\EDGECASES{
- $k=1$.
- $k=3$ minimal odd with nontrivial construction.
- Avoid duplicate edges when removing/adding matchings.
- Ensure $k-1$ is even to form perfect matching inside $R'$.
- Connectivity after removing the bridge should fail.
- Upper bounds easily satisfied for $k\le 100$.}
\PITFALLS{
- Forgetting to handle $k=1$ separately.
- Accidentally adding multiple edges or self-loops by poor indexing.
- Not ordering endpoints consistently, leading to duplicate detection failures in tests.
- Building cross edges between components besides the bridge (breaks bridge property).
- Off-by-one in removing the matching (should remove exactly $k-1$ edges).
- Forgetting to add the internal matching on $R'$ to fix degrees.}
\FAILMODES{Any approach that tries to connect two $k$-regular components with more than one edge will lose the bridge property; attempts for even $k$ fail due to parity/handshaking constraints.}
\ELI{Make two identical gadgets that are almost $k$-regular, each missing one degree on a special node. Connect these two specials by a single edge to complete regularity; that edge is the only connection between the gadgets, so it is a bridge.}
\NotePages{3}

\end{document}