% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — DravDe saves the world}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/28/E}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{How horrible! The empire of galactic chickens tries to conquer a beautiful city ``Z'', they have built a huge incubator that produces millions of chicken soldiers a day, and fenced it around. The huge incubator looks like a polygon on the plane $Oxy$ with $n$ vertices. Naturally, DravDe cannot keep still, he wants to destroy the chicken empire. For sure, he will start with the incubator.

DravDe is strictly outside the incubator's territory in point $A(x_a, y_a)$, and wants to get inside and kill all the chickens working there. But it takes a lot of doing! The problem is that recently DravDe went roller skating and has broken both his legs. He will get to the incubator's territory in his jet airplane LEVAP-41.

LEVAP-41 flies at speed $V(x_v, y_v, z_v)$. DravDe can get on the plane in point $A$, fly for some time, and then air drop himself. DravDe is very heavy, that is why he falls vertically at speed $F_{\text{down}}$, but in each point of his free fall DravDe can open his parachute, and from that moment he starts to fall at the wind speed $U(x_u, y_u, z_u)$ until he lands. Unfortunately, DravDe is not good at mathematics. Would you help poor world's saviour find such an air dropping plan, that allows him to land on the incubator's territory? If the answer is not unique, DravDe wants to find the plan with the minimum time of his flight on the plane. If the answers are still multiple, he wants to find the one with the minimum time of his free fall before opening his parachute.

Input:
The first line contains the number $n$ ($3 \le n \le 10^{4}$) — the amount of vertices of the fence. Then there follow $n$ lines containing the coordinates of these vertices (two integer numbers $x_i, y_i$) in clockwise or counter-clockwise order. It is guaranteed that the fence does not contain self-intersections.

The following four lines contain coordinates of point $A(x_a, y_a)$, speeds $V(x_v, y_v, z_v)$, $F_{\text{down}}$ and speed $U(x_u, y_u, z_u)$. All the input numbers are integer. All the coordinates do not exceed $10^{4}$ in absolute value. It is guaranteed that $z_v > 0$ and $F_{\text{down}}, z_u < 0$, and point $A$ is strictly outside the incubator's territory.

Output:
In the first line output two numbers $t_1, t_2$ such that if DravDe air drops at time $t_1$ (counting from the beginning of the flight), he lands on the incubator's territory (landing on the border is regarded as landing on the territory). If DravDe does not open his parachute, the second number should be equal to the duration of DravDe's falling down. If it is impossible for DravDe to get to the incubator's territory, output $-1~{-1}$. If the answer is not unique, output the answer with the minimum $t_1$. If the answers are still multiple, output the answer with the minimum $t_2$. Your answer must have an absolute or relative error less than $10^{-6}$.}
\BREAKDOWN{Model the set of all possible landing points as the cone generated by two 2D vectors derived from the motion with and without immediate parachute opening. Find the earliest time $t_1$ such that the segment of reachable landings at that time intersects the polygon; among those, choose the smallest free-fall time $t_2$.}
\ELI{The plane gives you two horizontal directions: with parachute opened immediately and without. You can land anywhere on the segment between those two positions at the same plane time; grow that segment from the start and stop when it first touches the polygon.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One polygon with $n$ vertices ($3 \le n \le 10^{4}$). Then: point $A$ (two integers), vector $V$ (three integers with $z_v>0$), scalar $F_{\text{down}}<0$, and vector $U$ (three integers with $z_u<0$). Absolute values of coordinates and components are $\le 10^{4}$.}
\OUTPUTS{Two reals $t_1, t_2$:
- $t_1 \ge 0$: plane flight time before drop,
- $t_2 \ge 0$: free-fall time before opening parachute (if never opened, $t_2$ equals the whole free-fall time).
If impossible, print $-1 -1$.}
\SAMPLES{Example 1 (reachable): square; $A$ to the left; outputs a finite $t_1$ and $t_2$.

Example 2 (impossible): polygon behind the cone; outputs $-1 -1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $P \subset \mathbb{R}^2$ be a simple polygon. Let $p=(x_a,y_a)$. Let $v=(x_v,y_v)$ and $z_v>0$. Let $f=F_{\text{down}}<0$. Let $u=(x_u,y_u)$ and $z_u<0$. Define $w=u/z_u$ (componentwise division by scalar $z_u$). Define
\begin{BreakableEquation*}
d_1 = v,\qquad d_0 = v - w\, z_v.
\end{BreakableEquation*}
At plane time $t\ge 0$ and parachute ratio $\lambda\in[0,1]$, the landing point is
\begin{BreakableEquation*}
L(t,\lambda) = p + t\bigl((1-\lambda)d_0+\lambda d_1\bigr).
\end{BreakableEquation*}
The free-fall time before opening is $s = \tfrac{z_v}{-f}\, t\, \lambda$.}
\varmapStart
\var{p}{start point $A$ on the plane}
\var{P}{target polygon}
\var{d_0}{direction with immediate parachute opening}
\var{d_1}{direction without parachute (horizontal projection of plane)}
\var{t}{plane time $t_1$}
\var{\lambda}{mix parameter along the segment at fixed $t$}
\var{s}{free-fall time $t_2$ before opening}
\varmapEnd
\GOVERN{
\[
\text{Reachable}(t) = \{\,L(t,\lambda): \lambda\in[0,1]\,\},\quad
\text{Cone} = \{\,p+\alpha d_0+\beta d_1:\ \alpha,\beta\ge 0\,\}.
\]
Find $\min t$ such that $\text{Reachable}(t)\cap P\ne\emptyset$; among all achieving $\min t$, take the minimum $\lambda$ and set $s=\tfrac{z_v}{-f}\,t\,\lambda$.
}
\ASSUMPTIONS{Polygon is simple; $z_v>0$, $f<0$, $z_u<0$; $A\notin P$. Vectors $d_0,d_1$ may be parallel; handle as a single ray.}
\INVARIANTS{For fixed $t$, $\text{Reachable}(t)$ is a segment between $p+t d_0$ and $p+t d_1$. The union over $t\ge 0$ equals the cone generated by $d_0,d_1$. Minimizing $t$ is equivalent to minimizing $\alpha+\beta$ over $x\in P\cap\text{Cone}$ where $x-p=\alpha d_0+\beta d_1$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Parameterize directions by $\lambda\in[0,1]$ with ray direction $r(\lambda)=(1-\lambda)d_0+\lambda d_1$. For each $\lambda$, compute the first intersection distance $t(\lambda)$ of the ray $p+t r(\lambda)$ with the polygon boundary. Take the minimum $t(\lambda)$; break ties by minimum $\lambda$.}
\ASSUMPTIONS{Enumerate a finite candidate set of $\lambda$ where the minimum can occur: endpoints $\{0,1\}$ and roots where per-edge feasibility changes (parallelism and segment parameter hitting endpoints).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $d_0,d_1$ and polygon edges.
\item For each edge, add candidate $\lambda$ where $D(\lambda)=\operatorname{cross}(r(\lambda),e)=0$, $N(\lambda)=\operatorname{cross}(p-s,r(\lambda))=0$, and $N(\lambda)+D(\lambda)=0$, plus $\{0,1\}$.
\item For each candidate $\lambda$, shoot ray and find first hit $t\ge 0$; keep the best pair $(t,\lambda)$.
\item Output $t_1=t$ and $t_2=\tfrac{z_v}{-f}\,t\,\lambda$, or $-1 -1$ if no hit.
\end{algosteps}
\COMPLEXITY{This enumeration yields $O(n)$ candidates per edge and $O(n)$ edges per candidate, thus $O(n^2)$ time and $O(1)$ extra space (beyond input).}
\[
\begin{aligned}
T(n) &= O(n) \text{ candidates per edge} \times O(n) \text{ edges} = O(n^2),\\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{On each edge, the first-hit distance is a monotone function of $\lambda$ between feasibility breakpoints; hence the global minimum occurs at interval boundaries, which are included in the candidate set, or at $\lambda\in\{0,1\}$.}
\EDGECASES{Parallel $d_0\parallel d_1$; rays parallel to edges; intersections at vertices; nearly tangent hits; numerical tolerances.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
import math

EPS = 1e-12

def cross(a, b):
    return a[0]*b[1] - a[1]*b[0]

def dot(a, b):
    return a[0]*b[0] + a[1]*b[1]

def sub(a, b):
    return (a[0]-b[0], a[1]-b[1])

def add(a, b):
    return (a[0]+b[0], a[1]+b[1])

def mul(a, k):
    return (a[0]*k, a[1]*k)

def ray_seg_first_t(p, r, s, e):
    # Returns smallest t >= 0 for intersection of ray p + t r with segment [s, s+e], or None
    nr2 = r[0]*r[0] + r[1]*r[1]
    if nr2 < EPS:
        return None
    D = cross(r, e)
    ps = sub(p, s)
    if abs(D) > EPS:
        C = cross(ps, e)
        t = -C / D
        N = cross(ps, r)
        tau = N / (-D)  # in [0,1]
        if t >= -1e-10 and tau >= -1e-10 and tau <= 1+1e-10:
            return max(0.0, t)
        return None
    # Parallel: check collinear
    if abs(cross(ps, r)) > 1e-9:
        return None
    # Collinear: consider endpoints projections
    best = None
    for q in (s, add(s, e)):
        v = sub(q, p)
        if abs(cross(v, r)) <= 1e-9:
            t = dot(v, r) / nr2
            if t >= -1e-10:
                t = max(0.0, t)
                if best is None or t < best:
                    best = t
    return best

def solve_by_candidates(poly, p, d0, d1, zv, fdown):
    n = len(poly)
    cand = [0.0, 1.0]
    delta = (d1[0]-d0[0], d1[1]-d0[1])
    for i in range(n):
        s = poly[i]
        t = poly[(i+1)%n]
        e = sub(t, s)
        ps = sub(p, s)
        a = cross(d0, e)
        b = cross(delta, e)
        n0 = cross(ps, d0)
        n1 = cross(ps, delta)
        def add_root(num, den):
            if abs(den) > EPS:
                lam = -num/den
                if lam >= -1e-8 and lam <= 1+1e-8:
                    if lam < 0: lam = 0.0
                    if lam > 1: lam = 1.0
                    cand.append(lam)
        add_root(a, b)           # D(λ)=0
        add_root(n0, n1)         # N(λ)=0
        add_root(n0 + a, n1 + b) # N(λ)+D(λ)=0
    # Deduplicate candidates approximately
    cand = sorted(set([round(x, 12) for x in cand]))
    best_t = None
    best_lam = None
    # Evaluate each candidate
    for lam in cand:
        r = (d0[0] + delta[0]*lam, d0[1] + delta[1]*lam)
        # find first intersection
        best_for_ray = None
        for i in range(n):
            s = poly[i]
            tpt = poly[(i+1)%n]
            e = sub(tpt, s)
            tt = ray_seg_first_t(p, r, s, e)
            if tt is not None:
                if best_for_ray is None or tt < best_for_ray:
                    best_for_ray = tt
        if best_for_ray is None:
            continue
        if best_t is None or best_for_ray < best_t - 1e-12 or (abs(best_for_ray - best_t) <= 1e-12 and lam < best_lam - 1e-12):
            best_t = best_for_ray
            best_lam = lam
    if best_t is None:
        return None
    t1 = best_t
    t2 = (zv/(-fdown)) * t1 * max(0.0, min(1.0, best_lam))
    return (t1, t2)

def read_input(data=None):
    it = iter(sys.stdin.read().strip().split() if data is None else data.strip().split())
    def nxt(): return next(it)
    try:
        n = int(nxt())
    except StopIteration:
        return None
    poly = []
    for _ in range(n):
        x = float(nxt()); y = float(nxt())
        poly.append((x, y))
    xa = float(nxt()); ya = float(nxt())
    xv = float(nxt()); yv = float(nxt()); zv = float(nxt())
    fdown = float(nxt())
    xu = float(nxt()); yu = float(nxt()); zu = float(nxt())
    return n, poly, (xa, ya), (xv, yv, zv), fdown, (xu, yu, zu)

def solve_all():
    data = read_input()
    if data is None:
        return
    n, poly, A, V3, fdown, U3 = data
    p = A
    xv, yv, zv = V3
    xu, yu, zu = U3
    # Build d0, d1
    d1 = (xv, yv)
    w = (xu/zu, yu/zu)  # zu < 0
    d0 = (xv - w[0]*zv, yv - w[1]*zv)
    ans = solve_by_candidates(poly, p, d0, d1, zv, fdown)
    if ans is None:
        print("-1 -1")
    else:
        t1, t2 = ans
        print("{:.15f} {:.15f}".format(t1, t2))

def _tests():
    # Test 1: square; A left; V to right; U no horizontal; immediate opening equivalent
    poly = [(0.0,0.0),(10.0,0.0),(10.0,10.0),(0.0,10.0)]
    A = (-10.0, 5.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -10.0
    U3 = (0.0, 0.0, -1.0)
    xv,yv,zv = V3
    xu,yu,zu = U3
    d1 = (xv,yv)
    w = (xu/zu, yu/zu)
    d0 = (xv - w[0]*zv, yv - w[1]*zv)
    ans = solve_by_candidates(poly, A, d0, d1, zv, fdown)
    assert ans is not None
    t1,t2 = ans
    assert abs(t1 - 10.0) < 1e-7
    assert abs(t2 - 0.0) < 1e-7

    # Test 2: need parachute drift; square at (1,1)-(3,3), A at (0,0)
    poly = [(1.0,1.0),(3.0,1.0),(3.0,3.0),(1.0,3.0)]
    A = (0.0, 0.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -5.0
    U3 = (0.0, 1.0, -1.0)  # w=(0,-1), d0=(1,1)
    xv,yv,zv = V3; xu,yu,zu = U3
    d1 = (xv,yv)
    w = (xu/zu, yu/zu)
    d0 = (xv - w[0]*zv, yv - w[1]*zv)
    ans = solve_by_candidates(poly, A, d0, d1, zv, fdown)
    assert ans is not None
    t1,t2 = ans
    assert abs(t1 - 1.0) < 1e-7
    assert abs(t2 - 0.0) < 1e-7

    # Test 3: impossible (cone to +x, polygon to -x)
    poly = [(-10.0,-1.0),(-8.0,-1.0),(-8.0,1.0),(-10.0,1.0)]
    A = (0.0, 0.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -1.0
    U3 = (0.0, 0.0, -1.0)  # no drift; cone is +x only
    xv,yv,zv = V3; xu,yu,zu = U3
    d1 = (xv,yv)
    w = (xu/zu, yu/zu)
    d0 = (xv - w[0]*zv, yv - w[1]*zv)
    ans = solve_by_candidates(poly, A, d0, d1, zv, fdown)
    assert ans is None

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\VALIDATION{Checks:
- Parallel directions ($d_0=d_1$)
- Immediate parachute case ($\lambda=0$)
- Impossible case (no intersection with cone).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Avoid the $O(n^2)$ scan by using geometric extremality: minimizing a linear functional over the intersection of a polygon and a cone occurs at extreme points of that intersection. These are polygon vertices inside the cone and intersections of polygon edges with the cone boundary rays.}
\ASSUMPTIONS{The objective $t=\alpha+\beta$ is linear in $x$ because $(\alpha,\beta)$ depend linearly on $x$ via the inverse of the $[d_0\ d_1]$ matrix; therefore the minimum over a polygonal set occurs at boundary extreme points.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $d_0$ and $d_1$ are parallel, reduce to ray--polygon first-hit computation.
\item Else compute $\det = \operatorname{cross}(d_0,d_1)\ne 0$.
\item For each vertex $x$ of $P$, compute $(\alpha,\beta)$ via
$\alpha = \tfrac{\operatorname{cross}(x-p, d_1)}{\det}$, $\beta = \tfrac{\operatorname{cross}(d_0, x-p)}{\det}$. If $\alpha,\beta\ge 0$, candidate $t=\alpha+\beta$, $\lambda=\beta/(\alpha+\beta)$.
\item For each boundary ray ($d_0$ and $d_1$), compute the nearest intersection with $P$; add candidate with $(\alpha,\beta)=(t,0)$ for $d_0$ or $(0,t)$ for $d_1$.
\item Take the candidate with minimal $t$; break ties by minimal $\lambda$. Output $t_1=t$ and $t_2=\tfrac{z_v}{-f}t\lambda$.
\end{algosteps}
\COMPLEXITY{Each step scans edges/vertices once: $O(n)$ time, $O(1)$ space.}
\[
\begin{aligned}
T(n) &= O(n),\\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Any point in the feasible region can be expressed as a convex combination of extreme points; a linear objective attains its minimum at an extreme point. The enumerated candidates include all extreme points of $P\cap\text{Cone}$ (vertices in the cone and intersections with cone rays).}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
import math

EPS = 1e-12

def cross(a, b):
    return a[0]*b[1] - a[1]*b[0]

def dot(a, b):
    return a[0]*b[0] + a[1]*b[1]

def sub(a, b):
    return (a[0]-b[0], a[1]-b[1])

def add(a, b):
    return (a[0]+b[0], a[1]+b[1])

def mul(a, k):
    return (a[0]*k, a[1]*k)

def ray_seg_first_t(p, r, s, e):
    nr2 = r[0]*r[0] + r[1]*r[1]
    if nr2 < EPS:
        return None
    D = cross(r, e)
    ps = sub(p, s)
    if abs(D) > EPS:
        C = cross(ps, e)
        t = -C / D
        N = cross(ps, r)
        tau = N / (-D)
        if t >= -1e-10 and tau >= -1e-10 and tau <= 1+1e-10:
            return max(0.0, t)
        return None
    if abs(cross(ps, r)) > 1e-9:
        return None
    best = None
    for q in (s, add(s, e)):
        v = sub(q, p)
        if abs(cross(v, r)) <= 1e-9:
            t = dot(v, r) / nr2
            if t >= -1e-10:
                t = max(0.0, t)
                if best is None or t < best:
                    best = t
    return best

def solve_linear(poly, p, d0, d1, zv, fdown):
    n = len(poly)
    det = cross(d0, d1)
    # Parallel case: single ray along d1 (same as d0 up to scale)
    if abs(det) < 1e-15:
        # use d = d1 (if degenerate, use d0)
        d = d1
        if d[0]*d[0]+d[1]*d[1] < EPS:
            return None
        best_t = None
        for i in range(n):
            s = poly[i]; tpt = poly[(i+1)%n]; e = sub(tpt, s)
            tt = ray_seg_first_t(p, d, s, e)
            if tt is not None:
                if best_t is None or tt < best_t:
                    best_t = tt
        if best_t is None:
            return None
        t1 = best_t
        lam = 0.0  # tie-break: minimal free-fall
        t2 = (zv/(-fdown)) * t1 * lam
        return (t1, t2)
    # Non-parallel: enumerate extreme points
    best = None  # (t, lam)
    # 1) vertices in cone
    for x in poly:
        xp = sub(x, p)
        alpha = cross(xp, d1) / det
        beta  = cross(d0, xp) / det
        if alpha >= -1e-12 and beta >= -1e-12:
            t = alpha + beta
            if t >= -1e-12:
                t = max(0.0, t)
                lam = 0.0 if t == 0.0 else beta / t
                cand = (t, lam)
                if best is None or cand[0] < best[0] - 1e-12 or (abs(cand[0]-best[0]) <= 1e-12 and cand[1] < best[1] - 1e-12):
                    best = cand
    # 2) nearest hit along ray d0 (beta=0)
    best_t_d0 = None
    for i in range(n):
        s = poly[i]; tpt = poly[(i+1)%n]; e = sub(tpt, s)
        tt = ray_seg_first_t(p, d0, s, e)
        if tt is not None:
            if best_t_d0 is None or tt < best_t_d0:
                best_t_d0 = tt
    if best_t_d0 is not None:
        cand = (best_t_d0, 0.0)
        if best is None or cand[0] < best[0] - 1e-12 or (abs(cand[0]-best[0]) <= 1e-12 and cand[1] < best[1] - 1e-12):
            best = cand
    # 3) nearest hit along ray d1 (alpha=0)
    best_t_d1 = None
    for i in range(n):
        s = poly[i]; tpt = poly[(i+1)%n]; e = sub(tpt, s)
        tt = ray_seg_first_t(p, d1, s, e)
        if tt is not None:
            if best_t_d1 is None or tt < best_t_d1:
                best_t_d1 = tt
    if best_t_d1 is not None:
        cand = (best_t_d1, 1.0)
        if best is None or cand[0] < best[0] - 1e-12 or (abs(cand[0]-best[0]) <= 1e-12 and cand[1] < best[1] - 1e-12):
            best = cand
    if best is None:
        return None
    t1, lam = best
    t2 = (zv/(-fdown)) * t1 * lam
    return (t1, t2)

def read_input(data=None):
    it = iter(sys.stdin.read().strip().split() if data is None else data.strip().split())
    def nxt(): return next(it)
    try:
        n = int(nxt())
    except StopIteration:
        return None
    poly = []
    for _ in range(n):
        x = float(nxt()); y = float(nxt())
        poly.append((x, y))
    xa = float(nxt()); ya = float(nxt())
    xv = float(nxt()); yv = float(nxt()); zv = float(nxt())
    fdown = float(nxt())
    xu = float(nxt()); yu = float(nxt()); zu = float(nxt())
    return n, poly, (xa, ya), (xv, yv, zv), fdown, (xu, yu, zu)

def solve_all():
    data = read_input()
    if data is None:
        return
    n, poly, A, V3, fdown, U3 = data
    p = A
    xv, yv, zv = V3
    xu, yu, zu = U3
    d1 = (xv, yv)
    w = (xu/zu, yu/zu)
    d0 = (xv - w[0]*zv, yv - w[1]*zv)
    ans = solve_linear(poly, p, d0, d1, zv, fdown)
    if ans is None:
        print("-1 -1")
    else:
        t1, t2 = ans
        print("{:.15f} {:.15f}".format(t1, t2))

def _tests():
    # Same tests as baseline
    poly = [(0.0,0.0),(10.0,0.0),(10.0,10.0),(0.0,10.0)]
    A = (-10.0, 5.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -10.0
    U3 = (0.0, 0.0, -1.0)
    xv,yv,zv = V3
    xu,yu,zu = U3
    d1 = (xv,yv)
    w = (xu/zu, yu/zu)
    d0 = (xv - w[0]*zv, yv - w[1]*zv)
    ans = solve_linear(poly, A, d0, d1, zv, fdown)
    assert ans is not None and abs(ans[0]-10.0)<1e-7 and abs(ans[1]-0.0)<1e-7

    poly = [(1.0,1.0),(3.0,1.0),(3.0,3.0),(1.0,3.0)]
    A = (0.0, 0.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -5.0
    U3 = (0.0, 1.0, -1.0)
    xv,yv,zv = V3; xu,yu,zu = U3
    d1 = (xv,yv); w=(xu/zu, yu/zu); d0=(xv-w[0]*zv, yv-w[1]*zv)
    ans = solve_linear(poly, A, d0, d1, zv, fdown)
    assert ans is not None and abs(ans[0]-1.0)<1e-7 and abs(ans[1]-0.0)<1e-7

    poly = [(-10.0,-1.0),(-8.0,-1.0),(-8.0,1.0),(-10.0,1.0)]
    A = (0.0, 0.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -1.0
    U3 = (0.0, 0.0, -1.0)
    xv,yv,zv = V3; xu,yu,zu = U3; d1=(xv,yv); w=(xu/zu,yu/zu); d0=(xv-w[0]*zv, yv-w[1]*zv)
    ans = solve_linear(poly, A, d0, d1, zv, fdown)
    assert ans is None

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\VALIDATION{Covers aligned/parallel cases, immediate parachute, and impossible configurations.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Minimize $t=\alpha+\beta$ over $x\in P\cap\text{Cone}$ with $x-p=\alpha d_0+\beta d_1$, $\alpha,\beta\ge 0$. Since $(\alpha,\beta)=M^{-1}(x-p)$ with $M=[d_0\ d_1]$, $t$ is linear in $x$. Therefore the minimum over a polygonal set occurs at an extreme point of $P\cap\text{Cone}$: polygon vertices in the cone or intersections of polygon edges with the two rays from $p$ along $d_0$ and $d_1$.}
\ASSUMPTIONS{Polygon is simple; numeric tolerance handles boundary inclusion.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $d_0=v-w z_v$, $d_1=v$, where $w=u/z_u$.
\item If $d_0$ and $d_1$ are parallel, find the nearest intersection along the single ray; set $\lambda=0$ by tie-break.
\item Else:
\begin{bullets}
\item For each vertex $x$, compute $(\alpha,\beta)$ via cross formulas; if $\alpha,\beta\ge 0$, candidate $(t,\lambda)=(\alpha+\beta,\ \beta/(\alpha+\beta))$.
\item Compute nearest intersection along ray $d_0$ (candidate $(t,0)$) and along ray $d_1$ (candidate $(t,1)$).
\end{bullets}
\item Take lexicographically minimal $(t,\lambda)$; output $t_1=t$, $t_2=\tfrac{z_v}{-f}t\lambda$.
\end{algosteps}
\OPTIMALITY{By linear programming on a polygonal feasible region, an optimum occurs at an extreme point. Our enumeration covers all extreme points of $P\cap\text{Cone}$; hence the solution is optimal in $t$, and by selecting the smallest feasible $\lambda$ among equal $t$ we satisfy the tie-break on $t_2$.}
\COMPLEXITY{$O(n)$ time and $O(1)$ space.}
\[
\begin{aligned}
T(n) &= O(n),\\
S(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
import math

EPS = 1e-12

def cross(a, b):
    return a[0]*b[1] - a[1]*b[0]

def dot(a, b):
    return a[0]*b[0] + a[1]*b[1]

def sub(a, b):
    return (a[0]-b[0], a[1]-b[1])

def add(a, b):
    return (a[0]+b[0], a[1]+b[1])

def mul(a, k):
    return (a[0]*k, a[1]*k)

def ray_seg_first_t(p, r, s, e):
    nr2 = r[0]*r[0] + r[1]*r[1]
    if nr2 < EPS:
        return None
    D = cross(r, e)
    ps = sub(p, s)
    if abs(D) > EPS:
        C = cross(ps, e)
        t = -C / D
        N = cross(ps, r)
        tau = N / (-D)
        if t >= -1e-10 and tau >= -1e-10 and tau <= 1+1e-10:
            return max(0.0, t)
        return None
    if abs(cross(ps, r)) > 1e-9:
        return None
    best = None
    for q in (s, add(s, e)):
        v = sub(q, p)
        if abs(cross(v, r)) <= 1e-9:
            t = dot(v, r) / nr2
            if t >= -1e-10:
                t = max(0.0, t)
                if best is None or t < best:
                    best = t
    return best

def solve_optimal(poly, p, d0, d1, zv, fdown):
    n = len(poly)
    det = cross(d0, d1)
    # Parallel case
    if abs(det) < 1e-15:
        d = d1 if (d1[0]*d1[0]+d1[1]*d1[1] >= EPS) else d0
        if d[0]*d[0]+d[1]*d[1] < EPS:
            return None
        best_t = None
        for i in range(n):
            s = poly[i]; tpt = poly[(i+1)%n]; e = sub(tpt, s)
            tt = ray_seg_first_t(p, d, s, e)
            if tt is not None:
                if best_t is None or tt < best_t:
                    best_t = tt
        if best_t is None:
            return None
        t1 = best_t
        lam = 0.0  # minimize free-fall
        t2 = (zv/(-fdown)) * t1 * lam
        return (t1, t2)
    # Non-parallel
    best = None  # pair (t, lam)
    # Candidates: vertices
    for x in poly:
        xp = sub(x, p)
        alpha = cross(xp, d1) / det
        beta  = cross(d0, xp) / det
        if alpha >= -1e-12 and beta >= -1e-12:
            t = alpha + beta
            if t >= -1e-12:
                t = max(0.0, t)
                lam = 0.0 if t == 0.0 else beta / t
                cand = (t, lam)
                if best is None or cand[0] < best[0] - 1e-12 or (abs(cand[0]-best[0]) <= 1e-12 and cand[1] < best[1] - 1e-12):
                    best = cand
    # Candidates: nearest along d0 and d1
    best_t_d0 = None
    best_t_d1 = None
    for i in range(n):
        s = poly[i]; tpt = poly[(i+1)%n]; e = sub(tpt, s)
        tt0 = ray_seg_first_t(p, d0, s, e)
        if tt0 is not None and (best_t_d0 is None or tt0 < best_t_d0):
            best_t_d0 = tt0
        tt1 = ray_seg_first_t(p, d1, s, e)
        if tt1 is not None and (best_t_d1 is None or tt1 < best_t_d1):
            best_t_d1 = tt1
    if best_t_d0 is not None:
        cand = (best_t_d0, 0.0)
        if best is None or cand[0] < best[0] - 1e-12 or (abs(cand[0]-best[0]) <= 1e-12 and cand[1] < best[1] - 1e-12):
            best = cand
    if best_t_d1 is not None:
        cand = (best_t_d1, 1.0)
        if best is None or cand[0] < best[0] - 1e-12 or (abs(cand[0]-best[0]) <= 1e-12 and cand[1] < best[1] - 1e-12):
            best = cand
    if best is None:
        return None
    t1, lam = best
    t2 = (zv/(-fdown)) * t1 * lam
    return (t1, t2)

def read_input(data=None):
    it = iter(sys.stdin.read().strip().split() if data is None else data.strip().split())
    def nxt(): return next(it)
    try:
        n = int(nxt())
    except StopIteration:
        return None
    poly = []
    for _ in range(n):
        x = float(nxt()); y = float(nxt())
        poly.append((x, y))
    xa = float(nxt()); ya = float(nxt())
    xv = float(nxt()); yv = float(nxt()); zv = float(nxt())
    fdown = float(nxt())
    xu = float(nxt()); yu = float(nxt()); zu = float(nxt())
    return n, poly, (xa, ya), (xv, yv, zv), fdown, (xu, yu, zu)

def solve_all():
    data = read_input()
    if data is None:
        return
    n, poly, A, V3, fdown, U3 = data
    p = A
    xv, yv, zv = V3
    xu, yu, zu = U3
    d1 = (xv, yv)
    w = (xu/zu, yu/zu)  # zu < 0
    d0 = (xv - w[0]*zv, yv - w[1]*zv)
    ans = solve_optimal(poly, p, d0, d1, zv, fdown)
    if ans is None:
        print("-1 -1")
    else:
        t1, t2 = ans
        print("{:.15f} {:.15f}".format(t1, t2))

def _tests():
    # Test 1: straight ray through square
    poly = [(0.0,0.0),(10.0,0.0),(10.0,10.0),(0.0,10.0)]
    A = (-10.0, 5.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -10.0
    U3 = (0.0, 0.0, -1.0)
    xv,yv,zv = V3; xu,yu,zu = U3
    d1=(xv,yv); w=(xu/zu,yu/zu); d0=(xv-w[0]*zv, yv-w[1]*zv)
    ans = solve_optimal(poly, A, d0, d1, zv, fdown)
    assert ans is not None and abs(ans[0]-10.0)<1e-7 and abs(ans[1]-0.0)<1e-7

    # Test 2: need drift
    poly = [(1.0,1.0),(3.0,1.0),(3.0,3.0),(1.0,3.0)]
    A = (0.0, 0.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -5.0
    U3 = (0.0, 1.0, -1.0)
    xv,yv,zv=V3; xu,yu,zu=U3; d1=(xv,yv); w=(xu/zu,yu/zu); d0=(xv-w[0]*zv, yv-w[1]*zv)
    ans = solve_optimal(poly, A, d0, d1, zv, fdown)
    assert ans is not None and abs(ans[0]-1.0)<1e-7 and abs(ans[1]-0.0)<1e-7

    # Test 3: impossible
    poly = [(-10.0,-1.0),(-8.0,-1.0),(-8.0,1.0),(-10.0,1.0)]
    A = (0.0, 0.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -1.0
    U3 = (0.0, 0.0, -1.0)
    xv,yv,zv=V3; xu,yu,zu=U3; d1=(xv,yv); w=(xu/zu,yu/zu); d0=(xv-w[0]*zv, yv-w[1]*zv)
    ans = solve_optimal(poly, A, d0, d1, zv, fdown)
    assert ans is None

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts exercising straight-line, drift-needed, and impossible cases.}
\RESULT{Outputs $t_1$ (plane time to drop) and $t_2$ (free-fall before opening). Among multiple valid plans, the algorithm selects minimal $t_1$ and then minimal $t_2$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests target three regimes: parallel directions ($d_0 \parallel d_1$), immediate-parachute usefulness ($\lambda=0$), and unreachable cone/polygon. Random fuzzing can verify consistency between baseline and optimal solvers on small polygons.}
\LINE{CROSS-CHECKS}{Compare outputs of the $O(n^2)$ candidate-$\lambda$ solver and the $O(n)$ extreme-point solver on random convex and non-convex polygons with random $V,U$; assert differences $<10^{-7}$.}
\LINE{EDGE-CASE GENERATOR}{Generate polygons where rays hit exactly at vertices; collinear edges with rays; tiny wedges with almost-parallel $d_0,d_1$; degenerate when $|d|$ nearly zero.}
\begin{minted}{python}
import random
random.seed(0)

def gen_polygon_convex(m=6, R=10.0):
    pts = []
    angs = sorted([random.random()*2*math.pi for _ in range(m)])
    for a in angs:
        r = R*(0.4+0.6*random.random())
        pts.append((r*math.cos(a), r*math.sin(a)))
    # ensure CCW
    return pts

def compare_methods(poly, A, V3, fdown, U3):
    xv,yv,zv = V3; xu,yu,zu = U3
    d1=(xv,yv); w=(xu/zu,yu/zu); d0=(xv-w[0]*zv, yv-w[1]*zv)
    a1 = solve_by_candidates(poly, A, d0, d1, zv, fdown)
    a2 = solve_linear(poly, A, d0, d1, zv, fdown)
    a3 = solve_optimal(poly, A, d0, d1, zv, fdown)
    assert (a1 is None) == (a2 is None) == (a3 is None)
    if a1 is not None:
        for (x,y) in (a1,a2,a3):
            pass
        assert abs(a1[0]-a2[0]) < 1e-6 and abs(a1[0]-a3[0]) < 1e-6
        assert abs(a1[1]-a2[1]) < 1e-6 and abs(a1[1]-a3[1]) < 1e-6

# Quick deterministic run
poly = gen_polygon_convex(7, 20.0)
A = (0.0, -30.0)
V3 = (5.0, 12.0, 3.0)
fdown = -7.0
U3 = (-2.0, 1.0, -4.0)
compare_methods(poly, A, V3, fdown, U3)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
import math

EPS = 1e-12

def cross(a, b):
    return a[0]*b[1] - a[1]*b[0]

def dot(a, b):
    return a[0]*b[0] + a[1]*b[1]

def sub(a, b):
    return (a[0]-b[0], a[1]-b[1])

def add(a, b):
    return (a[0]+b[0], a[1]+b[1])

def ray_seg_first_t(p, r, s, e):
    nr2 = r[0]*r[0] + r[1]*r[1]
    if nr2 < EPS:
        return None
    D = cross(r, e)
    ps = sub(p, s)
    if abs(D) > EPS:
        C = cross(ps, e)
        t = -C / D
        N = cross(ps, r)
        tau = N / (-D)
        if t >= -1e-10 and tau >= -1e-10 and tau <= 1+1e-10:
            return max(0.0, t)
        return None
    if abs(cross(ps, r)) > 1e-9:
        return None
    best = None
    for q in (s, add(s, e)):
        v = sub(q, p)
        if abs(cross(v, r)) <= 1e-9:
            t = dot(v, r) / nr2
            if t >= -1e-10:
                t = max(0.0, t)
                if best is None or t < best:
                    best = t
    return best

def solve(poly, A, V3, fdown, U3):
    p = A
    xv, yv, zv = V3
    xu, yu, zu = U3
    d1 = (xv, yv)
    w = (xu/zu, yu/zu)  # zu < 0
    d0 = (xv - w[0]*zv, yv - w[1]*zv)
    det = cross(d0, d1)
    n = len(poly)
    # Parallel case
    if abs(det) < 1e-15:
        d = d1 if (d1[0]*d1[0]+d1[1]*d1[1] >= EPS) else d0
        if d[0]*d[0]+d[1]*d[1] < EPS:
            return None
        best_t = None
        for i in range(n):
            s = poly[i]; tpt = poly[(i+1)%n]; e = sub(tpt, s)
            tt = ray_seg_first_t(p, d, s, e)
            if tt is not None:
                if best_t is None or tt < best_t:
                    best_t = tt
        if best_t is None:
            return None
        t1 = best_t
        lam = 0.0
        t2 = (zv/(-fdown)) * t1 * lam
        return (t1, t2)
    # Non-parallel: enumerate extreme points
    best = None
    for x in poly:
        xp = sub(x, p)
        alpha = cross(xp, d1) / det
        beta  = cross(d0, xp) / det
        if alpha >= -1e-12 and beta >= -1e-12:
            t = alpha + beta
            if t >= -1e-12:
                t = max(0.0, t)
                lam = 0.0 if t == 0.0 else beta / t
                cand = (t, lam)
                if best is None or cand[0] < best[0] - 1e-12 or (abs(cand[0]-best[0]) <= 1e-12 and cand[1] < best[1] - 1e-12):
                    best = cand
    best_t_d0 = None
    best_t_d1 = None
    for i in range(n):
        s = poly[i]; tpt = poly[(i+1)%n]; e = sub(tpt, s)
        tt0 = ray_seg_first_t(p, d0, s, e)
        if tt0 is not None and (best_t_d0 is None or tt0 < best_t_d0):
            best_t_d0 = tt0
        tt1 = ray_seg_first_t(p, d1, s, e)
        if tt1 is not None and (best_t_d1 is None or tt1 < best_t_d1):
            best_t_d1 = tt1
    if best_t_d0 is not None:
        cand = (best_t_d0, 0.0)
        if best is None or cand[0] < best[0] - 1e-12 or (abs(cand[0]-best[0]) <= 1e-12 and cand[1] < best[1] - 1e-12):
            best = cand
    if best_t_d1 is not None:
        cand = (best_t_d1, 1.0)
        if best is None or cand[0] < best[0] - 1e-12 or (abs(cand[0]-best[0]) <= 1e-12 and cand[1] < best[1] - 1e-12):
            best = cand
    if best is None:
        return None
    t1, lam = best
    t2 = (zv/(-fdown)) * t1 * lam
    return (t1, t2)

def read_input():
    it = iter(sys.stdin.read().strip().split())
    def nxt(): return next(it)
    try:
        n = int(nxt())
    except StopIteration:
        return None
    poly = []
    for _ in range(n):
        x = float(nxt()); y = float(nxt())
        poly.append((x, y))
    xa = float(nxt()); ya = float(nxt())
    xv = float(nxt()); yv = float(nxt()); zv = float(nxt())
    fdown = float(nxt())
    xu = float(nxt()); yu = float(nxt()); zu = float(nxt())
    return n, poly, (xa, ya), (xv, yv, zv), fdown, (xu, yu, zu)

def solve_all():
    data = read_input()
    if data is None:
        return
    n, poly, A, V3, fdown, U3 = data
    ans = solve(poly, A, V3, fdown, U3)
    if ans is None:
        print("-1 -1")
    else:
        t1, t2 = ans
        print("{:.15f} {:.15f}".format(t1, t2))

def _tests():
    # Deterministic sanity tests
    poly = [(0.0,0.0),(10.0,0.0),(10.0,10.0),(0.0,10.0)]
    A = (-10.0, 5.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -10.0
    U3 = (0.0, 0.0, -1.0)
    ans = solve(poly, A, V3, fdown, U3)
    assert ans is not None and abs(ans[0]-10.0)<1e-7 and abs(ans[1]-0.0)<1e-7

    poly = [(1.0,1.0),(3.0,1.0),(3.0,3.0),(1.0,3.0)]
    A = (0.0, 0.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -5.0
    U3 = (0.0, 1.0, -1.0)
    ans = solve(poly, A, V3, fdown, U3)
    assert ans is not None and abs(ans[0]-1.0)<1e-7 and abs(ans[1]-0.0)<1e-7

    poly = [(-10.0,-1.0),(-8.0,-1.0),(-8.0,1.0),(-10.0,1.0)]
    A = (0.0, 0.0)
    V3 = (1.0, 0.0, 1.0)
    fdown = -1.0
    U3 = (0.0, 0.0, -1.0)
    ans = solve(poly, A, V3, fdown, U3)
    assert ans is None

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Transform the reachable landing set into a 2D cone generated by two vectors and minimize plane time to reach the polygon, then minimize free-fall before opening.}
\WHY{This mixes continuous motion planning with geometric optimization under tie-breaks; it tests ability to find the right transformation and reduce to linear optimization on polygonal sets.}
\CHECKLIST{
- Compute $d_0=v-w z_v$ and $d_1=v$ with $w=u/z_u$.
- Handle $d_0\parallel d_1$ (degenerate cone).
- Enumerate candidates: vertices in cone; nearest hits along both rays.
- Choose minimal $t_1$; among equals, minimal $\lambda$.
- Output $t_2=\tfrac{z_v}{-f} t_1 \lambda$.}
\EDGECASES{
- Parallel $d_0,d_1$.
- Rays parallel to an edge or collinear with it; pick nearest endpoint in front.
- Landing exactly on border (allow with tolerance).
- Large coordinates and times; keep double precision and EPS.
- Starting point strictly outside polygon (no $t_1=0$).
- Very small $|z_u|$ or large speeds; avoid division by zero.}
\PITFALLS{
- Forgetting that $z_u<0$ so $w=u/z_u$ flips signs.
- Using integer division; must use floats.
- Not clamping $\lambda$ to $[0,1]$ when computing $t_2$ numerically.
- Mishandling collinear ray/edge (must check endpoints).
- Missing tie-break: must minimize $\lambda$ for equal $t_1$.
- Not including polygon vertices inside the cone as candidates.}
\FAILMODES{A naive scan over many $\lambda$ misses the true minimum between samples; the candidate-root method addresses this but is $O(n^2)$. The optimal $O(n)$ method avoids timeouts on $n=10^{4}$.}
\ELI{Think of two straight tracks on the ground that grow as time passes. At any time $t$, you can land anywhere between the two tips. Keep growing them until they just touch the fence, and pick the earliest touch. If there is a tie, prefer opening the parachute as early as possible.}
\NotePages{3}

\end{document}