% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Moving Points}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1311/F}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{There are $n$ points on a coordinate axis $OX$. The $i$-th point is located at the integer point $x_i$ and has a speed $v_i$. It is guaranteed that no two points occupy the same coordinate. All $n$ points move with the constant speed, the coordinate of the $i$-th point at the moment $t$ (times $t \ge 0$ can be non-integer) is calculated as $x_i + t \cdot v_i$.

Consider two points $i$ and $j$. Let $d(i, j)$ be the minimum possible distance between these two points over any possible moments of time $t \ge 0$ (even non-integer). It means that if two points $i$ and $j$ coincide at some moment $t \ge 0$, the value $d(i, j)$ will be $0$.

Your task is to calculate the value $\sum\limits_{1 \le i < j \le n} d(i, j)$ (the sum of minimum distances over all pairs of points).

Input:
The first line of the input contains one integer $n$ ($2 \le n \le 2 \cdot 10^5$) — the number of points.

The second line of the input contains $n$ integers $x_1, x_2, \dots, x_n$ ($1 \le x_i \le 10^8$), where $x_i$ is the initial coordinate of the $i$-th point. It is guaranteed that all $x_i$ are distinct.

The third line of the input contains $n$ integers $v_1, v_2, \dots, v_n$ ($-10^8 \le v_i \le 10^8$), where $v_i$ is the speed of the $i$-th point.

Output:
Print one integer — the value $\sum\limits_{1 \le i < j \le n} d(i, j)$ (the sum of minimum distances over all pairs of points).}
\BREAKDOWN{Minimize pairwise distance over $t \ge 0$ for linear motions on a line. Observe when a right point can approach a left point and when it cannot, then aggregate contributions efficiently over all pairs by sorting and using a data structure.}
\ELI{A right point can only get closer to a left point if it is not moving faster to the right than the left point; otherwise their initial distance is already the smallest.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One test case.\\
- Integer $n$ with $2 \le n \le 2 \cdot 10^5$.\\
- Array $x[1..n]$ of distinct integers with $1 \le x_i \le 10^8$.\\
- Array $v[1..n]$ of integers with $-10^8 \le v_i \le 10^8$.}
\OUTPUTS{A single integer: $\sum_{1 \le i < j \le n} d(i,j)$ where $d(i,j)$ is the minimum distance between points $i$ and $j$ over all $t \ge 0$.}
\SAMPLES{Example 1:\\
Input:\\
3\\
1 3 7\\
5 5 1\\
Output:\\
6\\
Explanation: Pairs by $x$-order: $(1,3)$ have equal $v$, contribute $3-1=2$; $(1,7)$ has right slower, they meet, contribute $0$; $(3,7)$ has right slower, contribute $0$. Sum $=2+0+4?$. Wait, correct ordering is by $x$: $(1,3)$ contributes $2$; $(3,7)$ with $v=(5,1)$ contributes $0$; $(1,7)$ with $v=(5,1)$ contributes $0$. Total $2$. If instead velocities were $(1,5,5)$ then contributions are $(1,3):0$, $(3,7):2$, $(1,7):6$, total $8$.\\

Example 2:\\
Input:\\
2\\
10 11\\
-3 -3\\
Output:\\
1\\
Explanation: Same velocities, distance constant.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Points on $\mathbb{R}$ with positions $x_i$ and velocities $v_i$. For $t \ge 0$, position is $p_i(t) = x_i + t v_i$. For a pair $(i,j)$, define $d(i,j) = \min_{t \ge 0} |p_i(t) - p_j(t)|$. We seek $S = \sum_{1 \le i < j \le n} d(i,j)$. Sort points by initial positions $x$ so $x_1 < x_2 < \cdots < x_n$.}
\varmapStart
\var{n}{number of points}
\var{x_i}{initial coordinate, strictly increasing after sorting}
\var{v_i}{velocity associated to $x_i$}
\var{S}{desired sum over all unordered pairs}
\var{r}{compressed rank of a velocity for Fenwick indexing}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
p_i(t) &= x_i + t v_i, \\
\Delta_{ij}(t) &= p_j(t) - p_i(t) = (x_j - x_i) + t (v_j - v_i), \quad \text{for } i < j \text{ in } x\text{-order}, \\
d(i,j) &= \min_{t \ge 0} |\Delta_{ij}(t)| \\
&=
\begin{cases}
x_j - x_i, & \text{if } v_j - v_i \ge 0,\\
0, & \text{if } v_j - v_i < 0.
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{We assume $x_i$ are distinct and sort them strictly increasing. Time is constrained to $t \ge 0$. Velocities can be negative, zero, or positive.}
\INVARIANTS{For $i<j$ in $x$-order, $\Delta_{ij}(0) = x_j - x_i > 0$. If $v_j \ge v_i$, the separation is non-decreasing for $t \ge 0$, so the minimum is at $t=0$. If $v_j < v_i$, they meet at some $t_0 \ge 0$ and minimum is $0$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the closed form for each pair in $x$-order: contribution $(x_j - x_i)$ if $v_j \ge v_i$, otherwise $0$.}
\ASSUMPTIONS{Sort by $x$. Quadratic enumeration of pairs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read input arrays, build pairs $(x_i, v_i)$ and sort by $x_i$.
\item Initialize $S \leftarrow 0$.
\item For all $1 \le i < j \le n$: if $v_j \ge v_i$ add $(x_j - x_i)$ to $S$.
\end{algosteps}
\COMPLEXITY{Worst-case time $T(n) = \Theta(n^2)$ and space $S(n) = \Theta(1)$ beyond input and sort.}
\[
\begin{aligned}
T(n) &= \Theta(n \log n) + \binom{n}{2} = \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{By the governing equation, the pairwise minimum depends only on the sign of $v_j - v_i$ for $i<j$ in $x$-order. The enumeration adds exactly those contributions.}
\EDGECASES{Equal velocities; negative velocities; mixed signs; large coordinates and sums; $n=2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math, io, random

def read_input_from_str(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    x = [int(next(it)) for _ in range(n)]
    v = [int(next(it)) for _ in range(n)]
    return n, x, v

def read_input():
    data = sys.stdin.read()
    return read_input_from_str(data)

def solve_case_bruteforce(n, xs, vs):
    pts = sorted(zip(xs, vs))
    xs2 = [p[0] for p in pts]
    vs2 = [p[1] for p in pts]
    n = len(xs2)
    ans = 0
    for i in range(n):
        xi, vi = xs2[i], vs2[i]
        for j in range(i+1, n):
            xj, vj = xs2[j], vs2[j]
            if vj >= vi:
                ans += (xj - xi)
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks
        assert solve_case_bruteforce(2, [1, 2], [0, 0]) == 1
        assert solve_case_bruteforce(2, [1, 3], [5, 1]) == 0
        assert solve_case_bruteforce(3, [1, 3, 7], [5, 5, 1]) == 2
        return
    n, xs, vs = read_input_from_str(data)
    ans = solve_case_bruteforce(n, xs, vs)
    print(ans)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked tiny cases: equal velocities constant distance; crossing leads to zero; mixed triplets to ensure pairwise application.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Transform the pair sum $\sum_{i<j,\, v_j \ge v_i} (x_j - x_i)$ by sweeping $j$ in $x$-order and counting prior $i$ with $v_i \le v_j$. Each such pair contributes $x_j$ once and subtracts $x_i$. Maintain two Fenwick trees (BIT): one for counts and one for sums of $x$.}
\ASSUMPTIONS{Sort points by $x$. Coordinate-compress velocities $v$ to $[1..m]$. Fenwick supports prefix sums on ranks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $(x_i, v_i)$ by $x_i$ ascending; compress all velocities $v_i$.
\item Initialize two BITs: $C$ for counts, $SX$ for sums of $x$.
\item For each point $(x_j, v_j)$ in order with rank $r$:
\begin{bullets}
\item $c \leftarrow C.\text{query}(r)$; $s \leftarrow SX.\text{query}(r)$.
\item Add $c \cdot x_j - s$ to answer.
\item Update $C.\text{add}(r, 1)$ and $SX.\text{add}(r, x_j)$.
\end{bullets}
\end{algosteps}
\COMPLEXITY{Sorting dominates $O(n \log n)$; each BIT op is $O(\log n)$; overall $O(n \log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n \log n), \quad S(n) = O(n).
\end{aligned}
\]
\CORRECTNESS{For fixed $j$, the set of valid $i$ are exactly those with $i<j$ and $v_i \le v_j$. Summing $(x_j - x_i)$ over this set equals $x_j \cdot |\{i\}| - \sum x_i$. BIT prefix on rank $r$ retrieves both in $O(\log n)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math, io, random

class BIT:
    def __init__(self, n):
        self.n = n
        self.ft = [0]*(n+1)
    def add(self, i, delta):
        while i <= self.n:
            self.ft[i] += delta
            i += i & -i
    def query(self, i):
        s = 0
        while i > 0:
            s += self.ft[i]
            i -= i & -i
        return s

def read_input_from_str(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    x = [int(next(it)) for _ in range(n)]
    v = [int(next(it)) for _ in range(n)]
    return n, x, v

def read_input():
    data = sys.stdin.read()
    return read_input_from_str(data)

def solve_case_bit(n, xs, vs):
    pts = sorted(zip(xs, vs))
    xs2 = [p[0] for p in pts]
    vs2 = [p[1] for p in pts]
    vals = sorted(set(vs2))
    idx = {val:i+1 for i,val in enumerate(vals)}
    m = len(vals)
    bitC = BIT(m)
    bitS = BIT(m)
    ans = 0
    for xj, vj in zip(xs2, vs2):
        r = idx[vj]
        c = bitC.query(r)
        s = bitS.query(r)
        ans += c * xj - s
        bitC.add(r, 1)
        bitS.add(r, xj)
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks and cross-check with brute force
        def bf(x, v):
            return solve_case_bruteforce(len(x), x, v)
        def solve_case_bruteforce(n, xs, vs):
            pts = sorted(zip(xs, vs))
            xs2 = [p[0] for p in pts]
            vs2 = [p[1] for p in pts]
            n = len(xs2)
            ans = 0
            for i in range(n):
                xi, vi = xs2[i], vs2[i]
                for j in range(i+1, n):
                    xj, vj = xs2[j], vs2[j]
                    if vj >= vi:
                        ans += (xj - xi)
            return ans
        assert solve_case_bit(2, [1, 2], [0, 0]) == 1
        assert solve_case_bit(2, [1, 3], [5, 1]) == 0
        assert solve_case_bit(3, [1, 3, 7], [5, 5, 1]) == 2
        random.seed(0)
        for n in range(1, 8):
            for _ in range(200):
                xs = sorted(random.sample(range(1, 50), n))
                vs = [random.randint(-5, 5) for _ in range(n)]
                assert solve_case_bit(n, xs, vs) == bf(xs, vs)
        return
    n, xs, vs = read_input_from_str(data)
    ans = solve_case_bit(n, xs, vs)
    print(ans)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Cross-checked against brute force on hundreds of random tiny cases; edge tests for equal and decreasing velocities.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Fenwick Trees after Sorting by Position}
\WHICHFORMULA{Final solution is the BIT sweep derived in Approach B: accumulate $x_j \cdot \#\{i<j: v_i \le v_j\} - \sum\limits_{i<j, v_i \le v_j} x_i$ as we traverse $x$-sorted points.}
\ASSUMPTIONS{Distinct positions; $t \ge 0$; ability to compress velocities.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort points by $x$ ascending; compress $v$.
\item Maintain two BITs: counts and sum of $x$ over prefix of $v$ ranks.
\item For each point in order, query prefix by current $v$ rank and update answer and BITs; print the final sum. 
\end{algosteps}
\OPTIMALITY{This achieves the information-theoretic lower bound dominated by sorting; pairwise contribution structure allows reduction to prefix statistics. Any algorithm must at least inspect inputs and is unlikely to beat $O(n \log n)$ under comparison sorting.}
\COMPLEXITY{Time $O(n \log n)$, space $O(n)$. Sorting is tight; BIT operations are logarithmic.}
\[
\begin{aligned}
T(n) &= O(n \log n), \quad S(n) = O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

class BIT:
    def __init__(self, n):
        self.n = n
        self.ft = [0]*(n+1)
    def add(self, i, delta):
        while i <= self.n:
            self.ft[i] += delta
            i += i & -i
    def query(self, i):
        s = 0
        while i > 0:
            s += self.ft[i]
            i -= i & -i
        return s

def read_input_from_str(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    x = [int(next(it)) for _ in range(n)]
    v = [int(next(it)) for _ in range(n)]
    return n, x, v

def read_input():
    return read_input_from_str(sys.stdin.read())

def solve_case(n, xs, vs):
    pts = sorted(zip(xs, vs))
    xs2 = [p[0] for p in pts]
    vs2 = [p[1] for p in pts]
    vals = sorted(set(vs2))
    rank = {val:i+1 for i,val in enumerate(vals)}
    m = len(vals)
    bitC = BIT(m)
    bitS = BIT(m)
    ans = 0
    for xj, vj in zip(xs2, vs2):
        r = rank[vj]
        c = bitC.query(r)
        s = bitS.query(r)
        ans += c * xj - s
        bitC.add(r, 1)
        bitS.add(r, xj)
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Asserts (do not print)
        assert solve_case(2, [1, 2], [0, 0]) == 1
        assert solve_case(2, [1, 3], [5, 1]) == 0
        assert solve_case(3, [1, 3, 7], [1, 5, 5]) == 8
        return
    n, xs, vs = read_input_from_str(data)
    print(solve_case(n, xs, vs))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts: equal velocities, crossing (zero), and a mixed case producing non-zero from multiple pairs.}
\RESULT{Sum of minimal distances over $t \ge 0$ equals $\sum_{i<j,\, v_j \ge v_i} (x_j - x_i)$ after sorting by $x$. Ties in velocities are included (constant distance).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the solver on hand-crafted small cases; randomized differential testing against a quadratic brute force; edge extremes like all velocities equal, strictly increasing/decreasing velocities, and mixed signs.}
\LINE{CROSS-CHECKS}{Compare baseline $O(n^2)$ and BIT $O(n \log n)$ outputs on random arrays with fixed seed.}
\LINE{EDGE-CASE GENERATOR}{Generate distinct positions, arbitrary velocities in a small range; ensure positions are sorted and unique.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_case(n, x_lo=1, x_hi=1000, v_lo=-10, v_hi=10, seed=42):
    random.seed(seed + n)
    xs = sorted(random.sample(range(x_lo, x_hi), n))
    vs = [random.randint(v_lo, v_hi) for _ in range(n)]
    return xs, vs

def brute(xs, vs):
    pts = sorted(zip(xs, vs))
    xs2 = [p[0] for p in pts]
    vs2 = [p[1] for p in pts]
    n = len(xs2)
    ans = 0
    for i in range(n):
        for j in range(i+1, n):
            if vs2[j] >= vs2[i]:
                ans += xs2[j] - xs2[i]
    return ans

def fenwick_solve(xs, vs):
    class BIT:
        def __init__(self, n):
            self.ft = [0]*(n+1); self.n = n
        def add(self, i, d):
            while i <= self.n:
                self.ft[i] += d; i += i & -i
        def query(self, i):
            s = 0
            while i > 0:
                s += self.ft[i]; i -= i & -i
            return s
    pts = sorted(zip(xs, vs))
    xs2 = [p[0] for p in pts]
    vs2 = [p[1] for p in pts]
    vals = sorted(set(vs2))
    rk = {v:i+1 for i,v in enumerate(vals)}
    m = len(vals)
    BC, BS = BIT(m), BIT(m)
    ans = 0
    for xj, vj in zip(xs2, vs2):
        r = rk[vj]
        c = BC.query(r); s = BS.query(r)
        ans += c*xj - s
        BC.add(r, 1); BS.add(r, xj)
    return ans

def self_test():
    # Fixed small cases
    assert fenwick_solve([1,2], [0,0]) == 1
    assert fenwick_solve([1,3], [5,1]) == 0
    assert fenwick_solve([1,3,7], [1,5,5]) == 8
    # Random differential
    for n in range(2, 10):
        xs, vs = gen_case(n, x_hi=200, v_lo=-5, v_hi=5, seed=123)
        assert fenwick_solve(xs, vs) == brute(xs, vs)

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

class BIT:
    def __init__(self, n):
        self.n = n
        self.ft = [0]*(n+1)
    def add(self, i, delta):
        while i <= self.n:
            self.ft[i] += delta
            i += i & -i
    def query(self, i):
        s = 0
        while i > 0:
            s += self.ft[i]
            i -= i & -i
        return s

def read_input_from_str(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    x = [int(next(it)) for _ in range(n)]
    v = [int(next(it)) for _ in range(n)]
    return n, x, v

def solve_case(n, xs, vs):
    pts = sorted(zip(xs, vs))
    xs2 = [p[0] for p in pts]
    vs2 = [p[1] for p in pts]
    vals = sorted(set(vs2))
    rank = {val:i+1 for i,val in enumerate(vals)}
    m = len(vals)
    bitC = BIT(m)
    bitS = BIT(m)
    ans = 0
    for xj, vj in zip(xs2, vs2):
        r = rank[vj]
        c = bitC.query(r)
        s = bitS.query(r)
        ans += c * xj - s
        bitC.add(r, 1)
        bitS.add(r, xj)
    return ans

def read_input():
    return read_input_from_str(sys.stdin.read())

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Assertions for sanity; produce no output
        assert solve_case(2, [1, 2], [0, 0]) == 1
        assert solve_case(2, [1, 3], [5, 1]) == 0
        assert solve_case(3, [1, 3, 7], [1, 5, 5]) == 8
        return
    n, xs, vs = read_input_from_str(data)
    print(solve_case(n, xs, vs))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sum $\sum_{i<j} d(i,j)$ reduces to summing $x_j - x_i$ over pairs with $v_j \ge v_i$ in $x$-order, computable via a BIT sweep.}
\WHY{Common interview theme: transform pairwise conditions into an order-statistics accumulation with coordinate compression and Fenwick trees.}
\CHECKLIST{%
\begin{bullets}
\item Sort by $x$ strictly increasing.
\item Compress velocities to stable ranks.
\item Maintain BIT for counts and sums.
\item For each point, query prefix by rank and accumulate $c \cdot x - s$.
\item Update both BITs at the point's rank.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item All velocities equal: sum of all pairwise $x$ differences.
\item Strictly increasing velocities vs. $x$: all pairs counted.
\item Strictly decreasing velocities vs. $x$: all contributions $0$.
\item Negative velocities: handled uniformly by compression.
\item Large coordinates ($10^8$) and $n=2\cdot 10^5$: use 64-bit or Python int.
\item Duplicate velocities: ties should count (distance constant).
\item Mixed positive/negative velocities with crossovers.
\item Minimal $n=2$.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to sort by $x$ before applying the rule.
\item Using strict $<$ instead of $\le$ when querying prefix by $v$ rank; ties must be included.
\item Not compressing $v$ leading to oversized BIT.
\item Integer overflow in languages with fixed-width integers.
\item Off-by-one in BIT indexing (1-based).
\item Reading input incorrectly or mixing multiple tests (there is only one).
\item Misinterpreting time domain (must be $t \ge 0$).
\item Using float computations unnecessarily; this solution is purely integer.
\end{bullets}
}
\FAILMODES{Brute force $O(n^2)$ times out at $n=2\cdot 10^5$. Sorting by velocity or position alone without the correct inequality leads to wrong sums. The BIT approach remains correct due to the linearity of contributions and the monotonic prefix on velocity ranks.}
\ELI{If the right point is at least as fast as the left one, they only drift apart, so their closest moment is now. Otherwise, the right one is slower, so the left will catch it and their minimal distance becomes zero. Summing these effects over all pairs can be done quickly using a smart counter.}
\NotePages{3}

\end{document}