% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Funny Substrings}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1538/E}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{Polycarp came up with a new programming language. There are only two types of statements in it:

\begin{bullets}
\item ``x := s'': assign the variable named x the value s (where s is a string). For example, the statement var := hello assigns the variable named var the value hello. Note that s is the value of a string, not the name of a variable. Between the variable name, the := operator and the string contains exactly one space each.
\item ``x = a + b'': assign the variable named x the concatenation of values of two variables a and b. For example, if the program consists of three statements a := hello, b := world, c = a + b, then the variable c will contain the string helloworld. It is guaranteed that the program is correct and the variables a and b were previously defined. There is exactly one space between the variable names and the = and + operators.
\end{bullets}

All variable names and strings only consist of lowercase letters of the English alphabet and do not exceed $5$ characters.

The result of the program is the number of occurrences of string haha in the string that was written to the variable in the last statement.

Polycarp was very tired while inventing that language. He asks you to implement it. Your task is — for given program statements calculate the number of occurrences of string haha in the last assigned variable.

Input: The first line contains an integer $t$ ($1 \le t \le 10^3$). Then $t$ test cases follow.

The first line of each test case contains a single integer $n$ ($1 \le n \le 50$) — the number of statements in the program. All variable names and strings are guaranteed to consist only of lowercase letters of the English alphabet and do not exceed $5$ characters.

This is followed by $n$ lines describing the statements in the format described above. It is guaranteed that the program is correct.

Output: For each set of input data, output the number of occurrences of the haha substring in the string that was written to the variable in the last statement.

Note: In the first test case the resulting value of d is hhahahaha.}
\BREAKDOWN{Parse each statement in order. Maintain for every variable a compact summary sufficient to compute the number of occurrences of haha after concatenations. Output the count for the last assigned variable of each test.}
\ELI{Keep only the first 3 letters, last 3 letters, and count of haha for each variable to combine results without storing long strings.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test:
\begin{bullets}
\item Integer $n$ ($1 \le n \le 50$).
\item $n$ statements, each either of the form \texttt{x := s} where s is a lowercase string of length $\le 5$, or \texttt{x = a + b} where a and b are names of previously defined variables.
\end{bullets}}
\OUTPUTS{For each test case, print a single integer: the number of occurrences (overlapping allowed) of the substring haha in the string assigned in the final statement.}
\SAMPLES{\begin{tcolorbox}
Input
\begin{verbatim}
2
3
a := ha
b := haha
c = a + b
4
a := h
b := aha
c = a + b
d = c + c
\end{verbatim}
Output
\begin{verbatim}
2
3
\end{verbatim}
Explanation: In test 1, c = hahaha has two haha occurrences. In test 2, d = hahahaha has three.
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For each variable $v$, maintain a summary triple $(c_v, p_v, s_v)$ where $c_v$ is the number of occurrences of haha in the string value of $v$, $p_v$ is its prefix of length up to $3$, and $s_v$ is its suffix of length up to $3$. For concatenation $x = a + b$ we derive $(c_x, p_x, s_x)$ from $(c_a, p_a, s_a)$ and $(c_b, p_b, s_b)$.}
\varmapStart
\var{c_v}{count of haha occurrences in variable $v$'s value}
\var{p_v}{prefix of variable $v$'s value of length $\le 3$}
\var{s_v}{suffix of variable $v$'s value of length $\le 3$}
\var{x = a + b}{concatenation of strings of variables $a$ and $b$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
c_x &= c_a + c_b + \#\{\text{occurrences of } \text{``haha'' in } s_a p_b\},\\
p_x &= \text{first 3 characters of } (p_a p_b),\\
s_x &= \text{last 3 characters of } (s_a s_b).
\end{aligned}
\]
}
\ASSUMPTIONS{Overlapping occurrences are counted. Input program is correct; a and b are defined before use. Variable and literal lengths are finite; only up to $3$ boundary characters are needed because $|\text{``haha''}|=4$.}
\INVARIANTS{
\begin{bullets}
\item $p_v$ equals the first $\min(3, |v|)$ characters of the value of $v$.
\item $s_v$ equals the last $\min(3, |v|)$ characters of the value of $v$.
\item $c_v$ equals the total occurrences of haha in the value of $v$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Explicitly build each variable's full string value and count occurrences of haha by scanning.}
\ASSUMPTIONS{Programs are small enough for testing; this approach can blow up because concatenations can create very long strings.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a map from variable name to its entire string.
\item For \texttt{x := s}, store $s$.
\item For \texttt{x = a + b}, store the concatenation map[a] + map[b].
\item After the last statement, scan the final string to count all windows equal to haha.
\end{algosteps}
\COMPLEXITY{Let $L$ be the maximum intermediate string length. Each concatenation copies strings, so worst case $O(nL)$ copying and $O(L)$ final scan. This is infeasible when $L$ grows exponentially with $n$.}
\[
\begin{aligned}
T(n) &\in O\!\left(\sum \text{len(assignments)} + \sum \text{len(concats)} + L\right) = O(nL),\\
S(n) &\in O(L).
\end{aligned}
\]
\CORRECTNESS{Building exact strings guarantees that the final scan counts every occurrence, including overlaps.}
\EDGECASES{Very short strings; zero occurrences; overlapping matches like in hahaha; repeated reassignments of the same variable name.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def count_haha(s: str) -> int:
    return sum(1 for i in range(len(s) - 3) if s[i:i+4] == "haha")

def read_input():
    data = sys.stdin.read().strip().splitlines()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        stmts = [next(it).rstrip("\n") for __ in range(n)]
        tests.append(stmts)
    return tests

def solve_case_bruteforce(stmts) -> int:
    vals = {}
    last_var = None
    for line in stmts:
        parts = line.split()
        if parts[1] == ":=":
            x, s = parts[0], parts[2]
            vals[x] = s
            last_var = x
        else:
            # x = a + b
            x, a, b = parts[0], parts[2], parts[4]
            vals[x] = vals[a] + vals[b]
            last_var = x
    return count_haha(vals[last_var])

def solve_all():
    tests = read_input()
    out_lines = []
    for stmts in tests:
        out_lines.append(str(solve_case_bruteforce(stmts)))
    sys.stdout.write("\n".join(out_lines))

# Minimal asserts (do not depend on stdin)
assert count_haha("haha") == 1
assert count_haha("hahaha") == 2
assert solve_case_bruteforce(["a := ha", "b := haha", "c = a + b"]) == 2

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Tiny tests: literal only; one concatenation; overlapping matches.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Summarize each variable by $(\text{count}, \text{prefix}_{\le 3}, \text{suffix}_{\le 3})$; only boundary overlap between two variables is relevant to new occurrences.}
\ASSUMPTIONS{Pattern length is $4$, so a boundary check needs at most $3$ chars from each side.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For literal assignment x := s, compute $c=\#\text{haha in }s$, $p=s[:3]$, $q=s[-3:]$.
\item For concatenation x = a + b, set:
\begin{bullets}
\item $c_x = c_a + c_b + \#\text{haha in } (q_a + p_b)$,
\item $p_x = (p_a + p_b)[:3]$,
\item $q_x = (q_a + q_b)[-3:]$.
\end{bullets}
\item The answer is $c$ of the last assigned variable.
\end{algosteps}
\COMPLEXITY{Each statement is processed in $O(1)$ time with $O(1)$ memory per variable, independent of actual string lengths.}
\[
\begin{aligned}
T(n) &= O(n), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Any new haha created by concatenating $a$ and $b$ must cross the boundary and thus appear within $q_a + p_b$. All internal occurrences are already counted in $c_a$ and $c_b$. Prefix and suffix collapse preserves enough information for future concatenations.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import Tuple, Dict

Triple = Tuple[int, str, str]  # (count, prefix<=3, suffix<=3)

def count_haha_in(s: str) -> int:
    return sum(1 for i in range(len(s) - 3) if s[i:i+4] == "haha")

def summarize_literal(s: str) -> Triple:
    return (count_haha_in(s), s[:3], s[-3:] if len(s) >= 3 else s)

def combine(A: Triple, B: Triple) -> Triple:
    ca, pa, qa = A
    cb, pb, qb = B
    cross = count_haha_in(qa + pb)
    c = ca + cb + cross
    p = (pa + pb)[:3]
    q = (qa + qb)[-3:] if len(qa + qb) >= 3 else (qa + qb)
    return (c, p, q)

def read_input():
    data = sys.stdin.read().strip().splitlines()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        stmts = [next(it).rstrip("\n") for __ in range(n)]
        tests.append(stmts)
    return tests

def solve_case_optimized(stmts) -> int:
    info: Dict[str, Triple] = {}
    last_var = None
    for line in stmts:
        parts = line.split()
        if parts[1] == ":=":
            x, s = parts[0], parts[2]
            info[x] = summarize_literal(s)
            last_var = x
        else:
            x, a, b = parts[0], parts[2], parts[4]
            info[x] = combine(info[a], info[b])
            last_var = x
    return info[last_var][0]

def solve_all():
    tests = read_input()
    out_lines = []
    for stmts in tests:
        out_lines.append(str(solve_case_optimized(stmts)))
    sys.stdout.write("\n".join(out_lines))

# Minimal asserts
assert count_haha_in("hhaha") == 1
assert summarize_literal("haha") == (1, "hah", "aha")
assert solve_case_optimized(["a := ha", "b := haha", "c = a + b"]) == 2

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Check literals with no matches; overlaps across boundary; multi-step chains where only boundary contributes.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Store, per variable, exactly the sufficient statistics: number of haha occurrences and the boundary strings of length up to $3$; combine in $O(1)$.}
\ASSUMPTIONS{Pattern length fixed at $4$. Program is correct; variables exist before use.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse each statement.
\item For literals, precompute $(c, p, q)$.
\item For concatenations, compute $(c, p, q)$ via constant-time combination of parents.
\end{algosteps}
\OPTIMALITY{Any algorithm must read all statements, yielding an $\Omega(n)$ lower bound. This method achieves $O(n)$ time and $O(n)$ space with constant work per statement.}
\COMPLEXITY{$T(n)=O(n)$, $S(n)=O(n)$; independent of actual concatenated string lengths.}
\[
\begin{aligned}
T(n) &= \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import Tuple, Dict

Triple = Tuple[int, str, str]  # (count, prefix<=3, suffix<=3)

def count_haha_in(s: str) -> int:
    return sum(1 for i in range(len(s) - 3) if s[i:i+4] == "haha")

def summarize_literal(s: str) -> Triple:
    return (count_haha_in(s), s[:3], s[-3:] if len(s) >= 3 else s)

def combine(A: Triple, B: Triple) -> Triple:
    ca, pa, qa = A
    cb, pb, qb = B
    cross = count_haha_in(qa + pb)
    c = ca + cb + cross
    p = (pa + pb)[:3]
    tail = qa + qb
    q = tail[-3:] if len(tail) >= 3 else tail
    return (c, p, q)

def read_input():
    data = sys.stdin.read().strip().splitlines()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        stmts = [next(it).rstrip("\n") for __ in range(n)]
        tests.append(stmts)
    return tests

def solve_case(stmts) -> int:
    info: Dict[str, Triple] = {}
    last_var = None
    for line in stmts:
        parts = line.split()
        if parts[1] == ":=":
            x, s = parts[0], parts[2]
            info[x] = summarize_literal(s)
            last_var = x
        else:
            x, a, b = parts[0], parts[2], parts[4]
            info[x] = combine(info[a], info[b])
            last_var = x
    return info[last_var][0]

def solve_all():
    tests = read_input()
    out_lines = []
    for stmts in tests:
        out_lines.append(str(solve_case(stmts)))
    sys.stdout.write("\n".join(out_lines))

# Exactly 3 asserts
assert count_haha_in("hahahaha") == 3
assert summarize_literal("abc") == (0, "abc", "abc")
assert solve_case(["a := h", "b := aha", "c = a + b", "d = c + c"]) == 3

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts included; they cover overlapping matches, boundary-only matches, and multi-step concatenations.}
\RESULT{For each test case, print the total number of haha occurrences in the final variable's value.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test helpers; compare brute force vs optimized on small, randomly generated programs; edge cases like very short literals and repeated concatenations.}
\LINE{CROSS-CHECKS}{Ensure counts from baseline and optimized implementations match on many small instances; deterministic seed for reproducibility.}
\LINE{EDGE-CASE GENERATOR}{Generates programs with $n \le 8$, literals length $\le 3$, variable reuse, and chains of concatenations; ensures boundary-heavy cases.}
\begin{minted}{python}
import sys
from typing import List, Tuple
import random

def count_haha(s: str) -> int:
    return sum(1 for i in range(len(s) - 3) if s[i:i+4] == "haha")

def solve_case_bruteforce(stmts: List[str]) -> int:
    vals = {}
    last = None
    for line in stmts:
        p = line.split()
        if p[1] == ":=":
            vals[p[0]] = p[2]
            last = p[0]
        else:
            vals[p[0]] = vals[p[2]] + vals[p[4]]
            last = p[0]
    return count_haha(vals[last])

def solve_case_optimized(stmts: List[str]) -> int:
    def sum_lit(s: str) -> Tuple[int, str, str]:
        return (count_haha(s), s[:3], s[-3:] if len(s) >= 3 else s)
    def combine(A, B):
        ca, pa, qa = A
        cb, pb, qb = B
        c = ca + cb + count_haha(qa + pb)
        p = (pa + pb)[:3]
        q = (qa + qb)[-3:] if len(qa + qb) >= 3 else (qa + qb)
        return (c, p, q)
    info = {}
    last = None
    for line in stmts:
        p = line.split()
        if p[1] == ":=":
            info[p[0]] = sum_lit(p[2])
            last = p[0]
        else:
            info[p[0]] = combine(info[p[2]], info[p[4]])
            last = p[0]
    return info[last][0]

def gen_program(n: int, rng: random.Random) -> List[str]:
    names = [chr(ord('a') + i) for i in range(26)]
    alive = []
    prog = []
    for i in range(n):
        x = names[i % len(names)]
        if not alive or rng.random() < 0.5:
            s = "".join(rng.choice("hax") for _ in range(rng.randint(0, 3)))
            prog.append(f"{x} := {s}")
            if x not in alive:
                alive.append(x)
        else:
            a = rng.choice(alive)
            b = rng.choice(alive)
            prog.append(f"{x} = {a} + {b}")
            if x not in alive:
                alive.append(x)
    return prog

def cross_check():
    rng = random.Random(0)
    for n in range(1, 9):
        for _ in range(50):
            prog = gen_program(n, rng)
            bf = solve_case_bruteforce(prog)
            opt = solve_case_optimized(prog)
            assert bf == opt, f"mismatch: {prog}\n{bf} vs {opt}"

# Do not run cross_check() on submission by default.
# Quick sanity asserts:
assert solve_case_bruteforce(["x := haha"]) == 1
assert solve_case_optimized(["a := ha", "b := ha", "c = a + b"]) == 1
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import Tuple, Dict

Triple = Tuple[int, str, str]  # (count, prefix<=3, suffix<=3)

def count_haha_in(s: str) -> int:
    return sum(1 for i in range(len(s) - 3) if s[i:i+4] == "haha")

def summarize_literal(s: str) -> Triple:
    return (count_haha_in(s), s[:3], s[-3:] if len(s) >= 3 else s)

def combine(A: Triple, B: Triple) -> Triple:
    ca, pa, qa = A
    cb, pb, qb = B
    cross = count_haha_in(qa + pb)
    c = ca + cb + cross
    p = (pa + pb)[:3]
    tail = qa + qb
    q = tail[-3:] if len(tail) >= 3 else tail
    return (c, p, q)

def read_input():
    data = sys.stdin.read().strip().splitlines()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        stmts = [next(it).rstrip("\n") for __ in range(n)]
        tests.append(stmts)
    return tests

def solve_case(stmts) -> int:
    info: Dict[str, Triple] = {}
    last_var = None
    for line in stmts:
        parts = line.split()
        if parts[1] == ":=":
            x, s = parts[0], parts[2]
            info[x] = summarize_literal(s)
            last_var = x
        else:
            x, a, b = parts[0], parts[2], parts[4]
            info[x] = combine(info[a], info[b])
            last_var = x
    return info[last_var][0]

def solve_all():
    tests = read_input()
    out_lines = []
    for stmts in tests:
        out_lines.append(str(solve_case(stmts)))
    sys.stdout.write("\n".join(out_lines))

# Light asserts (safe and deterministic)
assert count_haha_in("haha") == 1
assert summarize_literal("hah") == (0, "hah", "hah")
assert solve_case(["a := ha", "b := haha", "c = a + b"]) == 2

if __name__ == "__main__":
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count haha occurrences in the final variable after a sequence of assignments and concatenations, without materializing huge strings.}
\WHY{Tests understanding of string pattern overlaps, compact summaries, and constant-time combination tricks often used in competitive programming.}
\CHECKLIST{
\begin{bullets}
\item Parse lines correctly: \texttt{x := s} vs \texttt{x = a + b}.
\item For literals: compute count, prefix, suffix.
\item For concatenations: add counts and boundary overlaps from suffix(a)+prefix(b).
\item Update new prefix to first $3$ of prefix(a)+prefix(b).
\item Update new suffix to last $3$ of suffix(a)+suffix(b).
\item Output count of last assigned variable.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Very short strings ($|s|<4$) with zero matches.
\item Overlapping matches like in hahaha.
\item Concatenating empty or very short literals.
\item Same variable name redefined later.
\item Boundary-only new matches from \texttt{a + b}.
\item Chains where only the ends matter.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Storing entire strings can explode in size.
\item Forgetting to count overlaps across the boundary.
\item Using more than $3$ boundary chars (unnecessary) or fewer than $3$ (incorrect).
\item Off-by-one when slicing last $3$ characters.
\item Misparsing spaces and tokens (\texttt{:=}, \texttt{=}, \texttt{+}).
\item Not tracking the very last assigned variable name.
\end{bullets}}
\FAILMODES{Brute force fails on large implicit strings. The summary method remains $O(1)$ per operation regardless of implicit length.}
\ELI{You never need the whole string. Just remember how it starts, how it ends, and how many hahas are already inside. When you glue two pieces, new hahas can only appear where they touch.}
\NotePages{3}

\end{document}