% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — City Union}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1799/E}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{You are given $n \times m$ grid. Some cells are filled and some are empty.

A city is a maximal (by inclusion) set of filled cells such that it is possible to get from any cell in the set to any other cell in the set by moving to adjacent (by side) cells, without moving into any cells not in the set. In other words, a city is a connected component of filled cells with edges between adjacent (by side) cells.

Initially, there are two cities on the grid. You want to change some empty cells into filled cells so that both of the following are satisfied:
\begin{bullets}
\item There is one city on the resulting grid.
\item The shortest path between any two filled cells, achievable only by moving onto filled cells, is equal to the Manhattan distance between them.
\end{bullets}

The Manhattan distance between two cells $(a, b)$ and $(c, d)$ is equal to $\lvert a - c\rvert + \lvert b - d\rvert$.

Find a way to add filled cells that satisfies these conditions and minimizes the total number of filled cells.

Input: Input consists of multiple test cases. The first line contains a single integer $t$, the number of test cases ($1 \le t \le 5000$).

The first line of each test case contains two integers $n$ and $m$ ($1 \le n, m \le 50$, $nm \ge 3$).

The next $n$ lines describe the grid. The $i$-th line contains a string $s_i$ of length $m$. $s_{i,j}$ is '\#' if the cell in position $(i, j)$ is filled, and '.' if it is empty.

It is guaranteed that there are exactly two cities in the initial grid.

It is guaranteed that the sum of $n\cdot m$ over all test cases does not exceed $25{,}000$.

Output: For each test case, output $n$ lines, each containing a string of length $m$, describing the grid you create in the same format as the input.

If there are multiple possible answers with the minimum number of filled cells print any.

Note: In the first test case, we can add a single filled cell between the two cities to connect them. We can verify that the second condition is satisfied.

In the second test case, we can also connect the cities with a single filled cell, while satisfying the second condition.

In the third test case, note that if we filled the 3 cells in the top left, the cities would be connected, but the second condition would not be satisfied for cells $(4, 2)$ and $(2, 4)$.}
\BREAKDOWN{Turn two connected components of '\#' into one connected set while ensuring that shortest paths inside the set match Manhattan distances; this is equivalent to making the final set horizontally and vertically convex (HV-convex) and connected with minimum added cells.}
\ELI{Make one plus-shaped or L-shaped corridor that links the two cities, then fill any gaps on rows and columns to remove holes, picking the corridor that causes the least total filled cells.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n,m$; then $n$ lines with characters '\#' and '.'. Exactly two connected components of '\#'.}
\OUTPUTS{For each test case, $n$ lines forming a grid after adding cells (turning '.' to '\#') so that the final set of '\#' cells is a single connected component and for any two '\#' cells the shortest path length within '\#' equals their Manhattan distance. Among all such outcomes, minimize the total number of '\#' cells; any optimal solution is accepted.}
\SAMPLES{Example 1: a $2\times 3$ grid with '\#' at $(1,1)$ and $(2,3)$ can be solved by adding the L-corridor $(1,2)$ and $(1,3)$ or $(2,2)$ and $(1,2)$, then closing row/column gaps.

Example 2: two $1\times 1$ cities separated by one empty cell merge by filling the middle cell.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G \subseteq [1..n]\times[1..m]$ be the initial set of filled cells, with two connected components $A$ and $B$. We seek a superset $S \supseteq G$ minimizing $\lvert S\rvert$ such that:
\begin{bullets}
\item $S$ is connected under 4-neighborhood,
\item For every $x,y \in S$, the shortest path length in the induced grid graph on $S$ equals $\|x-y\|_1$.
\end{bullets}
The second condition is equivalent to $S$ being HV-convex: every row and every column intersects $S$ in a (possibly empty) contiguous interval.}
\varmapStart
\var{A,B}{initial cities (connected components) of $G$}
\var{S}{final superset of $G$ to output}
\var{r,c}{row and column indices for candidate L-corridor elbows}
\var{\mathrm{cl}(X)}{HV-convex closure of a set $X$ (minimal HV-convex superset of $X$)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Find }S=\mathrm{cl}\bigl(G \cup P\bigr)\text{ for some corridor }P\text{ connecting }A\text{ and }B,\\
&\text{minimizing }|S|, \text{ where } \mathrm{cl} \text{ iteratively fills row/column intervals.}
\end{aligned}
\]
}
\ASSUMPTIONS{Grid indices are 1-based in description; implementation uses 0-based. Exactly two cities initially.}
\INVARIANTS{
\begin{bullets}
\item HV-closure is monotone and terminates in at most $nm$ additions.
\item Adding cells cannot disconnect the set; adding an L-corridor touching both cities yields connectivity before closure.
\item HV-convexity implies a Manhattan shortest path exists between any two cells in $S$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all elbows formed by any pair of cells $(a\in A,b\in B)$: connect $a$ to $b$ with the two possible L-shaped corridors, then take the HV-closure and pick the minimum cardinality result.}
\ASSUMPTIONS{Brute force over $|A|\cdot|B|$ elbows is feasible only for small instances; included here for clarity and verification on toy cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse grid and extract the two components $A$ and $B$ by BFS.
\item For each ordered pair $(a\in A,b\in B)$, build two L-corridors with elbows at $(r_a,c_b)$ and $(r_b,c_a)$; add to $G$ and compute HV-closure.
\item Track and output the closure with the least number of '\#' cells.
\end{algosteps}
\COMPLEXITY{For $k_1=|A|$, $k_2=|B|$,
\[
\begin{aligned}
\text{Candidates} &= 2 k_1 k_2,\\
\text{Closure per candidate} &= O(nm\cdot I),\ \ I\le nm,\\
T(n) &\approx O(k_1 k_2\cdot nm\cdot I)\ \text{(slow)},\qquad S(n)=O(nm).
\end{aligned}
\]
}
\CORRECTNESS{Enumerating all elbows ensures we consider a superset of any optimal L-corridor. HV-closure yields the minimal HV-convex superset, guaranteeing the Manhattan shortest-path property.}
\EDGECASES{Cities touching at corners only; thin lines; multiple disjoint segments within same row/column.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        tests.append((n, m, grid))
    return tests

def bfs_components(n, m, grid):
    vis = [[False]*m for _ in range(n)]
    comps = []
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '#' and not vis[i][j]:
                q = deque([(i, j)])
                vis[i][j] = True
                comp = []
                while q:
                    x, y = q.popleft()
                    comp.append((x, y))
                    for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nx, ny = x+dx, y+dy
                        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '#' and not vis[nx][ny]:
                            vis[nx][ny] = True
                            q.append((nx, ny))
                comps.append(comp)
    return comps

def add_segment_row(cur, r, c1, c2):
    if c1 > c2: c1, c2 = c2, c1
    for j in range(c1, c2+1):
        cur[r][j] = True

def add_segment_col(cur, c, r1, r2):
    if r1 > r2: r1, r2 = r2, r1
    for i in range(r1, r2+1):
        cur[i][c] = True

def hv_closure(n, m, base_bool):
    cur = [row[:] for row in base_bool]
    changed = True
    while changed:
        changed = False
        # rows
        for i in range(n):
            l = None; r = None
            for j in range(m):
                if cur[i][j]:
                    l = j; break
            if l is None:
                continue
            for j in range(m-1, -1, -1):
                if cur[i][j]:
                    r = j; break
            for j in range(l, r+1):
                if not cur[i][j]:
                    cur[i][j] = True
                    changed = True
        # cols
        for j in range(m):
            u = None; d = None
            for i in range(n):
                if cur[i][j]:
                    u = i; break
            if u is None:
                continue
            for i in range(n-1, -1, -1):
                if cur[i][j]:
                    d = i; break
            for i in range(u, d+1):
                if not cur[i][j]:
                    cur[i][j] = True
                    changed = True
    return cur

def count_cells(n, m, cur):
    return sum(cur[i][j] for i in range(n) for j in range(m))

def to_bool(n, m, grid):
    return [[grid[i][j] == '#' for j in range(m)] for i in range(n)]

def solve_case_brutal(n, m, grid):
    comps = bfs_components(n, m, grid)
    assert len(comps) == 2
    A, B = comps[0], comps[1]
    base = to_bool(n, m, grid)
    best = None
    best_bool = None
    for (ra, ca) in A:
        for (rb, cb) in B:
            # elbow at (ra, cb)
            cur = [row[:] for row in base]
            add_segment_row(cur, ra, ca, cb)
            add_segment_col(cur, cb, ra, rb)
            closed = hv_closure(n, m, cur)
            cnt = count_cells(n, m, closed)
            if best is None or cnt < best:
                best = cnt
                best_bool = closed
            # elbow at (rb, ca)
            cur = [row[:] for row in base]
            add_segment_row(cur, rb, ca, cb)
            add_segment_col(cur, ca, ra, rb)
            closed = hv_closure(n, m, cur)
            cnt = count_cells(n, m, closed)
            if best is None or cnt < best:
                best = cnt
                best_bool = closed
    # Convert to grid
    ans = [['#' if best_bool[i][j] else '.' for j in range(m)] for i in range(n)]
    return [''.join(row) for row in ans]

def solve_all_brutal(tests):
    out = []
    for (n, m, grid) in tests:
        out.extend(solve_case_brutal(n, m, grid))
    return '\n'.join(out)

def main():
    tests = read_input()
    print(solve_all_brutal(tests))

if __name__ == "__main__":
    # Tiny asserts
    data = """3
2 3
#..
..#
2 2
#.
.#
3 3
#.#
...
.#.
"""
    tests = read_input(data.split())
    out = solve_all_brutal(tests).splitlines()
    # Check dimensions preserved
    assert len(out) == sum(t[0] for t in tests)
    # Ensure only '#' and '.'
    for line in out:
        assert set(line) <= set("#.")
    # Basic connectivity check for first case
    n, m, _ = tests[0]
    g0 = out[:n]
    # Count components
    comps = bfs_components(n, m, [list(row) for row in g0])
    assert len(comps) == 1
    # Print nothing here; rely on CF runner
    pass
\end{minted}
\VALIDATION{Includes asserts for formatting and connectivity on tiny cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Elbow Search via Row/Column Projections}
\WHICHFORMULA{Instead of all $|A|\cdot|B|$ elbows, try only elbows formed by $(\text{row from }A,\ \text{column from }B)$ and $(\text{row from }B,\ \text{column from }A)$. Attach to the nearest existing cell along that row/column, then HV-close. This reduces candidates to $O(nm)$.}
\ASSUMPTIONS{Nearest attachment along a row/column minimizes the corridor length for that elbow; HV-closure remains minimal among HV-convex supersets.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Extract sets of rows used by $A$ and columns used by $B$ (and vice versa).
\item For each $(r_A, c_B)$: add the horizontal segment on row $r_A$ to the nearest $A$ cell in that row and the vertical segment on column $c_B$ to the nearest $B$ cell in that column; HV-close.
\item Repeat for $(r_B, c_A)$ elbows. Keep the best closure by total '\#' count.
\end{algosteps}
\COMPLEXITY{At most $2\cdot 50\cdot 50=5000$ elbows; each HV-closure is $O(nm\cdot I)$ with small $I$ in practice. This is fast for the constraints.}
\[
\begin{aligned}
T(n) &= O((n+m)\cdot nm \cdot I) \ \text{per test in practice},\\
S(n) &= O(nm).
\end{aligned}
\]
\CORRECTNESS{Every optimal L-corridor elbow aligns with some row of one city and some column of the other; snapping to nearest existing cells yields a minimal attachment for that elbow. HV-closure guarantees geodesic equality.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        tests.append((n, m, grid))
    return tests

def bfs_components(n, m, grid):
    vis = [[False]*m for _ in range(n)]
    comps = []
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '#' and not vis[i][j]:
                q = deque([(i, j)])
                vis[i][j] = True
                comp = []
                while q:
                    x, y = q.popleft()
                    comp.append((x, y))
                    for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nx, ny = x+dx, y+dy
                        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '#' and not vis[nx][ny]:
                            vis[nx][ny] = True
                            q.append((nx, ny))
                comps.append(comp)
    return comps

def to_bool(n, m, grid):
    return [[grid[i][j] == '#' for j in range(m)] for i in range(n)]

def add_segment_row(cur, r, c1, c2):
    if c1 > c2: c1, c2 = c2, c1
    for j in range(c1, c2+1):
        cur[r][j] = True

def add_segment_col(cur, c, r1, r2):
    if r1 > r2: r1, r2 = r2, r1
    for i in range(r1, r2+1):
        cur[i][c] = True

def hv_closure(n, m, base_bool):
    cur = [row[:] for row in base_bool]
    changed = True
    while changed:
        changed = False
        # rows
        for i in range(n):
            l = None; r = None
            for j in range(m):
                if cur[i][j]:
                    l = j; break
            if l is None:
                continue
            for j in range(m-1, -1, -1):
                if cur[i][j]:
                    r = j; break
            for j in range(l, r+1):
                if not cur[i][j]:
                    cur[i][j] = True
                    changed = True
        # cols
        for j in range(m):
            u = None; d = None
            for i in range(n):
                if cur[i][j]:
                    u = i; break
            if u is None:
                continue
            for i in range(n-1, -1, -1):
                if cur[i][j]:
                    d = i; break
            for i in range(u, d+1):
                if not cur[i][j]:
                    cur[i][j] = True
                    changed = True
    return cur

def count_cells(n, m, cur):
    return sum(cur[i][j] for i in range(n) for j in range(m))

def nearest_in_sorted(lst, x):
    # lst is a sorted list of integers (may have duplicates not expected)
    if not lst:
        return None
    # binary search
    lo, hi = 0, len(lst)-1
    if x <= lst[0]: return lst[0]
    if x >= lst[-1]: return lst[-1]
    while lo <= hi:
        mid = (lo+hi)//2
        if lst[mid] == x:
            return x
        if lst[mid] < x:
            lo = mid + 1
        else:
            hi = mid - 1
    # now hi < lo, candidate neighbors are lst[hi], lst[lo]
    # hi >=0, lo < len(lst)
    if abs(lst[hi] - x) <= abs(lst[lo] - x):
        return lst[hi]
    else:
        return lst[lo]

def solve_case(n, m, grid):
    comps = bfs_components(n, m, grid)
    assert len(comps) == 2
    A, B = comps[0], comps[1]
    base = to_bool(n, m, grid)

    # Precompute rows->cols lists and cols->rows lists for A and B
    rowsA = {}
    colsA = {}
    rowsB = {}
    colsB = {}
    for (r, c) in A:
        rowsA.setdefault(r, []).append(c)
        colsA.setdefault(c, []).append(r)
    for (r, c) in B:
        rowsB.setdefault(r, []).append(c)
        colsB.setdefault(c, []).append(r)
    for r in rowsA: rowsA[r].sort()
    for c in colsA: colsA[c].sort()
    for r in rowsB: rowsB[r].sort()
    for c in colsB: colsB[c].sort()

    best = None
    best_bool = None

    # Orientation 1: (row from A, col from B)
    for ra, cols_in_A in rowsA.items():
        for cb, rows_in_B in colsB.items():
            cur = [row[:] for row in base]
            ca = nearest_in_sorted(cols_in_A, cb)
            rb = nearest_in_sorted(rows_in_B, ra)
            add_segment_row(cur, ra, ca, cb)
            add_segment_col(cur, cb, ra, rb)
            closed = hv_closure(n, m, cur)
            cnt = count_cells(n, m, closed)
            if best is None or cnt < best:
                best = cnt
                best_bool = closed

    # Orientation 2: (row from B, col from A)
    for rb, cols_in_B in rowsB.items():
        for ca, rows_in_A in colsA.items():
            cur = [row[:] for row in base]
            cb = nearest_in_sorted(cols_in_B, ca)
            ra = nearest_in_sorted(rows_in_A, rb)
            add_segment_row(cur, rb, ca, cb)
            add_segment_col(cur, ca, ra, rb)
            closed = hv_closure(n, m, cur)
            cnt = count_cells(n, m, closed)
            if best is None or cnt < best:
                best = cnt
                best_bool = closed

    # Convert to grid of strings
    ans = [['#' if best_bool[i][j] else '.' for j in range(m)] for i in range(n)]
    return [''.join(row) for row in ans]

def solve_all(tests):
    out = []
    for (n, m, grid) in tests:
        out.extend(solve_case(n, m, grid))
    return '\n'.join(out)

def check_hv_and_connect(n, m, grid_lines):
    grid = [list(row) for row in grid_lines]
    # HV check
    for i in range(n):
        cols = [j for j in range(m) if grid[i][j] == '#']
        if cols:
            if max(cols) - min(cols) + 1 != len(cols):
                return False
    for j in range(m):
        rows = [i for i in range(n) if grid[i][j] == '#']
        if rows:
            if max(rows) - min(rows) + 1 != len(rows):
                return False
    # Connectivity
    comps = bfs_components(n, m, grid)
    return len(comps) == 1

def main():
    tests = read_input()
    print(solve_all(tests))

if __name__ == "__main__":
    # Sanity tests
    data = """3
2 3
#..
..#
2 2
#.
.#
4 4
#..#
....
....
#..#
"""
    tests = read_input(data.split())
    out = solve_all(tests).splitlines()
    # Check dimensions and characters
    assert len(out) == sum(t[0] for t in tests)
    for line in out:
        assert set(line) <= set("#.")
    # Check HV + connectivity for these small cases
    idx = 0
    for (n, m, _) in tests:
        grid_lines = out[idx:idx+n]
        assert check_hv_and_connect(n, m, grid_lines)
        idx += n
    pass
\end{minted}
\VALIDATION{Includes HV-convexity and connectivity checks on crafted tiny cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Row/Column Elbow Search + HV-Closure (Final)}
\WHICHFORMULA{Enumerate elbows from $(\text{rows of one city})\times(\text{columns of the other})$ in both orientations; attach to nearest existing cells, take HV-closure, and select the minimum.}
\ASSUMPTIONS{The minimal solution can be realized by one L-corridor; closure yields the minimal HV-convex superset ensuring Manhattan geodesics.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Identify cities $A,B$ via BFS.
\item Precompute per-row and per-column lists of occupied indices for $A$ and $B$.
\item For each elbow candidate in both orientations, add minimal horizontal/vertical segments to touch $A$ and $B$; HV-close; track the best.
\item Output the corresponding grid.
\end{algosteps}
\OPTIMALITY{Among all connected supersets with the Manhattan geodesic property, the HV-closure is minimal for any seed. Thus it suffices to minimize the closure size over seeds made by a single L-corridor that connects the two cities. Restricting elbows to $(\text{row of one}, \text{column of the other})$ covers all L-corridor shapes up to redundant cells, ensuring optimality.}
\COMPLEXITY{With at most $2\cdot 50\cdot 50$ elbows and fast closure, total time is well within limits; space is linear in grid size.}
\[
\begin{aligned}
T(n) &\le O( (n\cdot m) \cdot nm)\ \text{in practice far smaller},\\
S(n) &= O(nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        tests.append((n, m, grid))
    return tests

def bfs_components(n, m, grid):
    vis = [[False]*m for _ in range(n)]
    comps = []
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '#' and not vis[i][j]:
                q = deque([(i, j)])
                vis[i][j] = True
                comp = []
                while q:
                    x, y = q.popleft()
                    comp.append((x, y))
                    for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nx, ny = x+dx, y+dy
                        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '#' and not vis[nx][ny]:
                            vis[nx][ny] = True
                            q.append((nx, ny))
                comps.append(comp)
    return comps

def to_bool(n, m, grid):
    return [[grid[i][j] == '#' for j in range(m)] for i in range(n)]

def add_segment_row(cur, r, c1, c2):
    if c1 > c2: c1, c2 = c2, c1
    for j in range(c1, c2+1):
        cur[r][j] = True

def add_segment_col(cur, c, r1, r2):
    if r1 > r2: r1, r2 = r2, r1
    for i in range(r1, r2+1):
        cur[i][c] = True

def hv_closure(n, m, base_bool):
    cur = [row[:] for row in base_bool]
    changed = True
    while changed:
        changed = False
        # rows
        for i in range(n):
            l = None; r = None
            for j in range(m):
                if cur[i][j]:
                    l = j; break
            if l is None:
                continue
            for j in range(m-1, -1, -1):
                if cur[i][j]:
                    r = j; break
            for j in range(l, r+1):
                if not cur[i][j]:
                    cur[i][j] = True
                    changed = True
        # cols
        for j in range(m):
            u = None; d = None
            for i in range(n):
                if cur[i][j]:
                    u = i; break
            if u is None:
                continue
            for i in range(n-1, -1, -1):
                if cur[i][j]:
                    d = i; break
            for i in range(u, d+1):
                if not cur[i][j]:
                    cur[i][j] = True
                    changed = True
    return cur

def count_cells(n, m, cur):
    return sum(cur[i][j] for i in range(n) for j in range(m))

def nearest_in_sorted(lst, x):
    if not lst:
        return None
    lo, hi = 0, len(lst)-1
    if x <= lst[0]: return lst[0]
    if x >= lst[-1]: return lst[-1]
    while lo <= hi:
        mid = (lo+hi)//2
        if lst[mid] == x:
            return x
        if lst[mid] < x:
            lo = mid + 1
        else:
            hi = mid - 1
    if abs(lst[hi] - x) <= abs(lst[lo] - x):
        return lst[hi]
    else:
        return lst[lo]

def solve_case(n, m, grid):
    comps = bfs_components(n, m, grid)
    assert len(comps) == 2
    A, B = comps[0], comps[1]
    base = to_bool(n, m, grid)
    rowsA, colsA, rowsB, colsB = {}, {}, {}, {}
    for (r, c) in A:
        rowsA.setdefault(r, []).append(c)
        colsA.setdefault(c, []).append(r)
    for (r, c) in B:
        rowsB.setdefault(r, []).append(c)
        colsB.setdefault(c, []).append(r)
    for r in rowsA: rowsA[r].sort()
    for c in colsA: colsA[c].sort()
    for r in rowsB: rowsB[r].sort()
    for c in colsB: colsB[c].sort()

    best = None
    best_bool = None

    # Orientation 1: (row from A, col from B)
    for ra, cols_in_A in rowsA.items():
        for cb, rows_in_B in colsB.items():
            cur = [row[:] for row in base]
            ca = nearest_in_sorted(cols_in_A, cb)
            rb = nearest_in_sorted(rows_in_B, ra)
            add_segment_row(cur, ra, ca, cb)
            add_segment_col(cur, cb, ra, rb)
            closed = hv_closure(n, m, cur)
            cnt = count_cells(n, m, closed)
            if best is None or cnt < best:
                best = cnt
                best_bool = closed

    # Orientation 2: (row from B, col from A)
    for rb, cols_in_B in rowsB.items():
        for ca, rows_in_A in colsA.items():
            cur = [row[:] for row in base]
            cb = nearest_in_sorted(cols_in_B, ca)
            ra = nearest_in_sorted(rows_in_A, rb)
            add_segment_row(cur, rb, ca, cb)
            add_segment_col(cur, ca, ra, rb)
            closed = hv_closure(n, m, cur)
            cnt = count_cells(n, m, closed)
            if best is None or cnt < best:
                best = cnt
                best_bool = closed

    ans = [['#' if best_bool[i][j] else '.' for j in range(m)] for i in range(n)]
    return [''.join(row) for row in ans]

def solve_all(tests):
    out = []
    for (n, m, grid) in tests:
        out.extend(solve_case(n, m, grid))
    return '\n'.join(out)

def main():
    tests = read_input()
    print(solve_all(tests))

if __name__ == "__main__":
    # Exactly 3 asserts
    data = """3
3 3
#..
..#
...
2 3
#..
..#
3 4
#..#
....
#..#
"""
    tests = read_input(data.split())
    out = solve_all(tests).splitlines()
    # 1) Lines count
    assert len(out) == sum(t[0] for t in tests)
    # 2) Characters
    for line in out:
        assert set(line) <= set("#.")
    # 3) Resulting grids are connected
    idx = 0
    for (n, m, _) in tests:
        grid_lines = out[idx:idx+n]
        comps = bfs_components(n, m, [list(row) for row in grid_lines])
        assert len(comps) == 1
        idx += n
    pass
\end{minted}
\VALIDATION{Three asserts: line count, character set, connectivity on a few tiny tests.}
\RESULT{Print the final '\#' grid per test case; any optimal solution is accepted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test helpers (HV-closure, components); property checks on small grids; randomized micro tests under constraints $n,m\le 6$.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved on tiny random cases; ensure equal counts and HV-convexity.}
\LINE{EDGE-CASE GENERATOR}{Generate pairs of single-cell cities; thin snakes; diagonal placements; overlapping projections.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_single_cells(n, m, a, b):
    g = [['.' for _ in range(m)] for _ in range(n)]
    (r1, c1), (r2, c2) = a, b
    g[r1][c1] = '#'
    g[r2][c2] = '#'
    return [''.join(row) for row in g]

def gen_snakes(n, m):
    g = [['.' for _ in range(m)] for _ in range(n)]
    # zig city A on top row
    for j in range(0, m, 2):
        g[0][j] = '#'
    # zig city B on bottom row
    for j in range(1, m, 2):
        g[n-1][j] = '#'
    return [''.join(row) for row in g]

def run_reference():
    # Use the final solver
    from collections import deque
    import sys
    tests = []
    grids = []
    # Case 1
    n, m = 3, 3
    g = gen_single_cells(n, m, (0,0), (2,2))
    grids.append((n, m, [list(row) for row in g]))
    # Case 2
    n2, m2 = 4, 5
    g2 = gen_snakes(n2, m2)
    grids.append((n2, m2, [list(row) for row in g2]))
    # Solve
    from sys import stdout
    from itertools import chain
    def solve_all(tests):
        out = []
        for (n, m, grid) in tests:
            out.extend(solve_case(n, m, grid))
        return out
    # Local copy of solve_case (same as final)
    def bfs_components(n, m, grid):
        vis = [[False]*m for _ in range(n)]
        comps = []
        from collections import deque
        for i in range(n):
            for j in range(m):
                if grid[i][j] == '#' and not vis[i][j]:
                    q = deque([(i, j)])
                    vis[i][j] = True
                    comp = []
                    while q:
                        x, y = q.popleft()
                        comp.append((x, y))
                        for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                            nx, ny = x+dx, y+dy
                            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '#' and not vis[nx][ny]:
                                vis[nx][ny] = True
                                q.append((nx, ny))
                    comps.append(comp)
        return comps
    # Omitted: duplicate full reference to avoid redundancy in this snippet
    return True
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        grid = [list(next(it).strip()) for _ in range(n)]
        tests.append((n, m, grid))
    return tests

def bfs_components(n, m, grid):
    vis = [[False]*m for _ in range(n)]
    comps = []
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '#' and not vis[i][j]:
                q = deque([(i, j)])
                vis[i][j] = True
                comp = []
                while q:
                    x, y = q.popleft()
                    comp.append((x, y))
                    for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nx, ny = x+dx, y+dy
                        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '#' and not vis[nx][ny]:
                            vis[nx][ny] = True
                            q.append((nx, ny))
                comps.append(comp)
    return comps

def to_bool(n, m, grid):
    return [[grid[i][j] == '#' for j in range(m)] for i in range(n)]

def add_segment_row(cur, r, c1, c2):
    if c1 > c2: c1, c2 = c2, c1
    for j in range(c1, c2+1):
        cur[r][j] = True

def add_segment_col(cur, c, r1, r2):
    if r1 > r2: r1, r2 = r2, r1
    for i in range(r1, r2+1):
        cur[i][c] = True

def hv_closure(n, m, base_bool):
    cur = [row[:] for row in base_bool]
    changed = True
    while changed:
        changed = False
        # rows
        for i in range(n):
            l = None; r = None
            for j in range(m):
                if cur[i][j]:
                    l = j; break
            if l is None:
                continue
            for j in range(m-1, -1, -1):
                if cur[i][j]:
                    r = j; break
            for j in range(l, r+1):
                if not cur[i][j]:
                    cur[i][j] = True
                    changed = True
        # cols
        for j in range(m):
            u = None; d = None
            for i in range(n):
                if cur[i][j]:
                    u = i; break
            if u is None:
                continue
            for i in range(n-1, -1, -1):
                if cur[i][j]:
                    d = i; break
            for i in range(u, d+1):
                if not cur[i][j]:
                    cur[i][j] = True
                    changed = True
    return cur

def count_cells(n, m, cur):
    return sum(cur[i][j] for i in range(n) for j in range(m))

def nearest_in_sorted(lst, x):
    if not lst:
        return None
    lo, hi = 0, len(lst)-1
    if x <= lst[0]: return lst[0]
    if x >= lst[-1]: return lst[-1]
    while lo <= hi:
        mid = (lo+hi)//2
        if lst[mid] == x:
            return x
        if lst[mid] < x:
            lo = mid + 1
        else:
            hi = mid - 1
    if abs(lst[hi] - x) <= abs(lst[lo] - x):
        return lst[hi]
    else:
        return lst[lo]

def solve_case(n, m, grid):
    comps = bfs_components(n, m, grid)
    assert len(comps) == 2
    A, B = comps[0], comps[1]
    base = to_bool(n, m, grid)
    rowsA, colsA, rowsB, colsB = {}, {}, {}, {}
    for (r, c) in A:
        rowsA.setdefault(r, []).append(c)
        colsA.setdefault(c, []).append(r)
    for (r, c) in B:
        rowsB.setdefault(r, []).append(c)
        colsB.setdefault(c, []).append(r)
    for r in rowsA: rowsA[r].sort()
    for c in colsA: colsA[c].sort()
    for r in rowsB: rowsB[r].sort()
    for c in colsB: colsB[c].sort()

    best = None
    best_bool = None

    for ra, cols_in_A in rowsA.items():
        for cb, rows_in_B in colsB.items():
            cur = [row[:] for row in base]
            ca = nearest_in_sorted(cols_in_A, cb)
            rb = nearest_in_sorted(rows_in_B, ra)
            add_segment_row(cur, ra, ca, cb)
            add_segment_col(cur, cb, ra, rb)
            closed = hv_closure(n, m, cur)
            cnt = count_cells(n, m, closed)
            if best is None or cnt < best:
                best = cnt
                best_bool = closed

    for rb, cols_in_B in rowsB.items():
        for ca, rows_in_A in colsA.items():
            cur = [row[:] for row in base]
            cb = nearest_in_sorted(cols_in_B, ca)
            ra = nearest_in_sorted(rows_in_A, rb)
            add_segment_row(cur, rb, ca, cb)
            add_segment_col(cur, ca, ra, rb)
            closed = hv_closure(n, m, cur)
            cnt = count_cells(n, m, closed)
            if best is None or cnt < best:
                best = cnt
                best_bool = closed

    ans = [['#' if best_bool[i][j] else '.' for j in range(m)] for i in range(n)]
    return [''.join(row) for row in ans]

def solve_all(tests):
    out = []
    for (n, m, grid) in tests:
        out.extend(solve_case(n, m, grid))
    return '\n'.join(out)

def main():
    tests = read_input()
    print(solve_all(tests))

if __name__ == "__main__":
    # Minimal deterministic asserts
    data = """2
2 2
#.
.#
3 3
#..
..#
...
"""
    tests = read_input(data.split())
    out = solve_all(tests).splitlines()
    assert len(out) == sum(t[0] for t in tests)
    for line in out:
        assert set(line) <= set("#.")
    # Connectedness check
    idx = 0
    for (n, m, _) in tests:
        grid_lines = out[idx:idx+n]
        comps = bfs_components(n, m, [list(row) for row in grid_lines])
        assert len(comps) == 1
        idx += n
    # Ready for submission
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Connect two cities with one L-corridor and HV-close to ensure all shortest paths equal Manhattan distance; choose the elbow minimizing the closure size.}
\WHY{This tests grid geometry, BFS, discrete convex closures, and search-space pruning under tight IO constraints.}
\CHECKLIST{
\begin{bullets}
\item Extract exactly two components.
\item Build candidate elbows: rows of one city $\times$ columns of the other (both orientations).
\item Attach to nearest cells along row/column.
\item Apply HV-closure until stable.
\item Keep minimal total '\#' count and output grid.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Cities touching diagonally (need 1 cell).
\item One city is a line; nearest attachment inside its span.
\item Holes within a row/column must be filled by closure.
\item Very small grids ($nm=3$).
\item Multiple segments in same row/column.
\item Overlapping row/column projections.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to include both elbow orientations.
\item Choosing non-nearest attachments inflates closure.
\item Incomplete closure (must iterate rows and columns until no change).
\item Shallow copies of 2D arrays causing aliasing.
\item Off-by-one on segment ends (inclusive ranges).
\item Not preserving output format across multiple test cases.
\end{bullets}}
\FAILMODES{Purely connecting by a shortest path without closure violates the Manhattan property due to holes; conversely, overfilling by rectangles is suboptimal. The elbow+closure survives by minimal seeding then minimal HV-convex completion.}
\ELI{We draw a single L-shaped road that touches both cities, then fill any gaps along rows and columns so the city has no holes. We try all reasonable places to bend the L and pick the one that makes the fewest total filled cells.}
\NotePages{3}

\end{document}