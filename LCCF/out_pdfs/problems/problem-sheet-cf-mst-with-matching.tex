% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — MST with Matching}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1948/G}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{You are given an undirected connected graph on $n$ vertices. Each edge of this graph has a weight; the weight of the edge connecting vertices $i$ and $j$ is $w_{i,j}$ (or $w_{i,j} = 0$ if there is no edge between $i$ and $j$). All weights are positive integers.

You are also given a positive integer $c$.

You have to build a spanning tree of this graph; i.\,e. choose exactly $(n-1)$ edges of this graph in such a way that every vertex can be reached from every other vertex by traversing some of the chosen edges. The cost of the spanning tree is the sum of two values:
\begin{bullets}
\item the sum of weights of all chosen edges;
\item the maximum matching in the spanning tree (i.\,e. the maximum size of a set of edges such that they all belong to the chosen spanning tree, and no vertex has more than one incident edge in this set), multiplied by the given integer $c$.
\end{bullets}
Find any spanning tree with the minimum cost. Since the graph is connected, there exists at least one spanning tree.

Input: The first line contains two integers $n$ and $c$ ($2 \le n \le 20$; $1 \le c \le 10^6$).

Then $n$ lines follow. The $i$-th of them contains $n$ integers $w_{i,1}, w_{i,2}, \dots, w_{i,n}$ ($0 \le w_{i,j} \le 10^6$), where $w_{i,j}$ denotes the weight of the edge between $i$ and $j$ (or $w_{i,j} = 0$ if there is no such edge).

Additional constraints on the input:
\begin{bullets}
\item for every $i \in [1, n]$, $w_{i,i} = 0$;
\item for every pair of integers $(i, j)$ such that $i \in [1, n]$ and $j \in [1, n]$, $w_{i,j} = w_{j,i}$;
\item the given graph is connected.
\end{bullets}
Output: Print one integer — the minimum cost of a spanning tree of the given graph.

Note: In the first example, the minimum cost spanning tree consists of edges $(1, 3)$, $(2, 3)$ and $(3, 4)$. The maximum matching for it is $1$.

In the second example, the minimum cost spanning tree consists of edges $(1, 2)$, $(2, 3)$ and $(3, 4)$. The maximum matching for it is $2$.}
\BREAKDOWN{We need a spanning tree minimizing sum of weights plus $c$ times the tree's maximum matching size. Trees are bipartite, so $\nu(T)$ equals the minimum vertex cover size. Reparameterize by choosing a vertex cover $C$ for the tree: then no edge can have both ends outside $C$. For each $C$, the optimal tree is the MST over edges with at least one endpoint in $C$, which decomposes into an MST on $C$ plus, for each outside vertex, its cheapest edge into $C$. Minimize over all $C \subseteq V$.}
\ELI{Pick a set of ``covered'' vertices $C$; all tree edges must touch $C$. The best such tree uses the cheapest links from uncovered vertices to $C$ and an MST inside $C$. Try all $C$ and take the cheapest total plus $c|C|$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n$ and $c$. Then an $n \times n$ symmetric matrix $W=(w_{i,j})$ with $w_{i,i}=0$ and $w_{i,j}=0$ meaning ``no edge'', otherwise a positive weight. Indices are $1$-based in the statement; convert to $0$-based internally. Valid ranges: $2 \le n \le 20$, $1 \le c \le 10^6$, $0 \le w_{i,j} \le 10^6$.}
\OUTPUTS{One integer: the minimum possible value of $\sum_{e \in T} w_e + c \cdot \nu(T)$ over all spanning trees $T$, where $\nu(T)$ is the size of a maximum matching in $T$.}
\SAMPLES{Example 1:
\begin{itemize}
\item $n=4$, $c=10$. A path $1$--$2$--$3$--$4$ with edge weights all $1$; no other edges. Answer is $3 + 2 \cdot 10 = 23$.
\end{itemize}
Example 2:
\begin{itemize}
\item $n=4$, $c=5$. A star centered at $1$ with edges $(1,2),(1,3),(1,4)$ of weight $1$; no other edges. Answer is $3 + 1 \cdot 5 = 8$.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be the given graph with $|V|=n$. For any spanning tree $T \subseteq E$, denote by $\nu(T)$ the size of a maximum matching in $T$. The objective is
\begin{BreakableEquation*}
\min_{T \text{ spanning tree}} \left( \sum_{e \in T} w(e) + c \cdot \nu(T) \right).
\end{BreakableEquation*}
By K\H{o}nig's theorem on bipartite graphs (trees are bipartite), $\nu(T)$ equals the minimum vertex cover size of $T$. Let $C \subseteq V$ be a vertex cover of $T$; then $T$ has no edge with both endpoints in $S:=V \setminus C$. Equivalently, $T$ is a spanning tree of the graph whose allowed edges are those incident to at least one vertex in $C$.}
\varmapStart
\var{V}{vertex set $\{1,\dots,n\}$}
\var{E}{undirected edges with positive weights $w:E \to \mathbb{Z}_{>0}$}
\var{c}{penalty coefficient for each matched edge counted via $\nu(T)$}
\var{C}{a vertex cover of tree $T$; edges with both ends in $S=V \setminus C$ are forbidden}
\var{T}{spanning tree respecting $C$}
\var{MST(C)}{MST weight on the subgraph induced by $C$ (using only $C$--$C$ edges)}
\var{a(u,C)}{for $u \in S$, cheapest incident edge from $u$ to any $v \in C$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\min_{C \subseteq V} \left( c \cdot |C| + \underbrace{\mathrm{MST}(C)}_{\text{$C$--$C$ edges}} + \underbrace{\sum_{u \in V \setminus C} a(u,C)}_{\text{attach each $u$ once to $C$}} \right),
\end{BreakableEquation*}
subject to: $C \ne \varnothing$, the subgraph $G[C]$ is connected (if $|C|\ge 2$), and $a(u,C)<\infty$ for all $u \in V \setminus C$. If any constraint fails, the term is infeasible.}
\ASSUMPTIONS{Weights on existing edges are positive; $w_{i,j}=0$ denotes absence. The input graph is connected, hence the choice $C=V$ is always feasible.}
\INVARIANTS{For a fixed $C$, any spanning tree using no $S$--$S$ edge has all $u \in S$ as leaves attached to $C$; changing attachment choices is independent across $u \in S$. Among such trees, minimizing total weight decomposes into: attachments at their individual minima and an MST on $C$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all spanning trees (e.\,g. by Prüfer codes), compute $\sum w_e$ and $\nu(T)$ via tree DP, and take the minimum.}
\ASSUMPTIONS{Feasible only for very small $n$ (e.\,g. $n \le 10$), since the number of trees is $n^{n-2}$ by Cayley.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all Prüfer codes of length $n-2$ to generate all labeled trees on $n$ vertices.
\item For each tree $T$, compute $\sum w_e$ and $\nu(T)$ by a DP on the tree.
\item Track the minimum of $\sum w_e + c \cdot \nu(T)$.
\end{algosteps}
\COMPLEXITY{Exponential in $n$: $T(n)=\Theta(n^{n-2} \cdot n)$ to generate and evaluate; $S(n)=\Theta(n)$ per tree.}
\[
\begin{aligned}
T(n) &= \Theta(n^{n-2}) \cdot \Theta(n) \\
     &= \Theta(n^{n-1}).
\end{aligned}
\]
\CORRECTNESS{Complete enumeration guarantees coverage; DP on trees computes exact maximum matching; thus the minimum found is correct.}
\EDGECASES{Graphs with missing edges (weight $0$ meaning absent) must be filtered; trees using absent edges are infeasible and skipped.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline (illustrative; exponential) with Prüfer codes for very small n.
# Includes read_input / solve_case / main + guard + asserts, per CF contract.

from typing import List, Tuple
import sys
import itertools

INF = 10**30

def read_input() -> Tuple[int, int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); c = int(next(it))
    W = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            W[i][j] = int(next(it))
    return n, c, W

def max_matching_on_tree(n: int, adj: List[List[int]]) -> int:
    # Root arbitrarily at 0; DP[u][0/1]: max matching size in subtree of u
    # state 0 = u is unmatched with parent; 1 = u is matched with one child
    sys.setrecursionlimit(10000)
    par = [-1]*n
    order = []
    stack = [0]
    par[0] = -2
    while stack:
        u = stack.pop()
        order.append(u)
        for v in adj[u]:
            if par[v] == -1:
                par[v] = u
                stack.append(v)
    DP0 = [0]*n
    DP1 = [0]*n
    for u in reversed(order):
        # u unmatched with parent: can choose to match u with at most one child
        total0 = 0
        gains = []
        for v in adj[u]:
            if v == par[u]: continue
            total0 += max(DP0[v], DP1[v])
            gains.append(1 + DP0[v] - max(DP0[v], DP1[v]))
        best = 0
        if gains:
            best = max(0, max(gains))
        DP0[u] = total0 + best
        # u matched with parent: cannot match u with its children
        total1 = 0
        for v in adj[u]:
            if v == par[u]: continue
            total1 += max(DP0[v], DP1[v])
        DP1[u] = total1
    return max(DP0[0], DP1[0])

def solve_case(n: int, c: int, W: List[List[int]]) -> int:
    if n == 0:
        return 0
    # Build list of existing edges (i<j) with weight > 0
    edges = []
    for i in range(n):
        for j in range(i+1, n):
            w = W[i][j]
            if w > 0:
                edges.append((i, j, w))
    # Prüfer codes enumeration (only feasible for very small n)
    # Map Prüfer code to tree edges.
    def prufer_to_edges(code: List[int]) -> List[Tuple[int,int]]:
        deg = [1]*n
        for x in code:
            deg[x] += 1
        import heapq
        leaves = [i for i in range(n) if deg[i] == 1]
        heapq.heapify(leaves)
        E = []
        for x in code:
            u = heapq.heappop(leaves)
            E.append((u, x))
            deg[u] -= 1
            deg[x] -= 1
            if deg[x] == 1:
                heapq.heappush(leaves, x)
        u = heapq.heappop(leaves)
        v = heapq.heappop(leaves)
        E.append((u, v))
        return E

    # Speed guard: if n > 10, fallback to trivial MST + matching penalty on that tree (not optimal).
    if n > 10:
        # Prim MST
        inC = [False]*n
        best = [INF]*n
        best[0] = 0
        total_w = 0
        for _ in range(n):
            u = -1; bw = INF
            for i in range(n):
                if not inC[i] and best[i] < bw:
                    bw = best[i]; u = i
            if u == -1 or bw >= INF//2:
                return 0
            inC[u] = True
            total_w += bw
            for v in range(n):
                w = W[u][v]
                if w > 0 and not inC[v] and w < best[v]:
                    best[v] = w
        # Build adjacency of MST for matching DP
        adj = [[] for _ in range(n)]
        # Re-run Prim to retrieve edges
        inC = [False]*n
        best = [INF]*n
        parent = [-1]*n
        best[0] = 0
        for _ in range(n):
            u = -1; bw = INF
            for i in range(n):
                if not inC[i] and best[i] < bw:
                    bw = best[i]; u = i
            inC[u] = True
            if parent[u] != -1:
                a, b = u, parent[u]
                adj[a].append(b); adj[b].append(a)
            for v in range(n):
                w = W[u][v]
                if w > 0 and not inC[v] and w < best[v]:
                    best[v] = w; parent[v] = u
        mm = max_matching_on_tree(n, adj)
        return total_w + c * mm

    ans = INF
    # Enumerate all Prüfer codes
    for code in itertools.product(range(n), repeat=n-2):
        E = prufer_to_edges(list(code))
        ok = True
        total_w = 0
        adj = [[] for _ in range(n)]
        for u, v in E:
            w = W[u][v]
            if w <= 0:
                ok = False
                break
            total_w += w
            adj[u].append(v); adj[v].append(u)
        if not ok:
            continue
        mm = max_matching_on_tree(n, adj)
        cost = total_w + c * mm
        if cost < ans:
            ans = cost
    return ans if ans < INF//2 else 0

def main():
    n, c, W = read_input()
    if n == 0:
        return
    print(solve_case(n, c, W))

if __name__ == "__main__":
    # Tiny sanity tests for the baseline (use small n to keep it fast)
    def mat_from_edges(n, edges):
        W = [[0]*n for _ in range(n)]
        for u, v, w in edges:
            W[u][v] = w; W[v][u] = w
        return W
    # Path of 4 nodes, c=10: cost = 3 + 2*10 = 23
    W1 = mat_from_edges(4, [(0,1,1),(1,2,1),(2,3,1)])
    assert solve_case(4, 10, W1) == 23
    # Star of 4 nodes centered at 0, c=5: cost = 3 + 1*5 = 8
    W2 = mat_from_edges(4, [(0,1,1),(0,2,1),(0,3,1)])
    assert solve_case(4, 5, W2) == 8
    # Complete graph K3 with weights 1, c any: MST=2, matching size in any tree is 1
    W3 = mat_from_edges(3, [(0,1,1),(1,2,1),(0,2,1)])
    assert solve_case(3, 7, W3) == 2 + 7*1
    # Do not run main auto for baseline
\end{minted}
\VALIDATION{Validated on tiny hand-crafted graphs: path, star, and triangle, matching expected values.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Vertex-Cover Reparameterization}
\WHICHFORMULA{Use K\H{o}nig's theorem to replace $\nu(T)$ by the size of a minimum vertex cover of $T$. For a chosen cover $C$, the tree cannot use any edge entirely in $S=V \setminus C$. The optimal restricted tree decomposes into an MST on $C$ plus cheapest attachments from each $u \in S$ into $C$.}
\ASSUMPTIONS{We assume $w_{i,j}=0$ means no edge; all other weights are positive. For feasibility: $C \ne \varnothing$, $G[C]$ is connected (if $|C|\ge 2$), and each $u \in S$ has some neighbor in $C$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iterate over all subsets $C \subseteq V$, $C \ne \varnothing$.
\item Compute $\mathrm{MST}(C)$ on the induced subgraph $G[C]$; if disconnected, skip.
\item For each $u \in S=V \setminus C$, add $a(u,C)=\min_{v \in C, (u,v)\in E} w_{u,v}$; if any is undefined, skip.
\item Cost for $C$ is $c|C| + \mathrm{MST}(C) + \sum_{u \in S} a(u,C)$; keep the minimum.
\end{algosteps}
\COMPLEXITY{There are $2^n-1$ subsets. With Prim on $C$ costing $O(|C|^2)$ and attachments computed naïvely in $O(n|C|)$, the total is roughly $\sum_{k=1}^n \binom{n}{k}(k^2 + n k) = O(n^2 2^n)$.}
\[
\begin{aligned}
T(n) &\approx \sum_{k=1}^n \binom{n}{k} (k^2 + nk) \\
     &= O(n^2 2^n), \quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{For any valid $C$, every $u \in S$ is a leaf in $T$ and can be attached independently with its cheapest edge to $C$, while cycles can only form within $C$, hence an MST over $C$ is optimal for intra-$C$ edges. Taking the minimum over all $C$ implements $\min_T \left(\sum w + c\nu(T)\right)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved: iterate subsets; compute Prim on C and attachments naively.
# Same API/signature as baseline; deterministic; with asserts.

from typing import List, Tuple
import sys

INF = 10**30

def read_input() -> Tuple[int, int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); c = int(next(it))
    W = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            W[i][j] = int(next(it))
    return n, c, W

def prim_on_mask(mask: int, W: List[List[int]]) -> int:
    # Return MST cost inside vertex set 'mask'; INF if disconnected.
    if mask == 0:
        return INF
    n = len(W)
    # pick lsb as start
    start = (mask & -mask).bit_length() - 1
    inT = 1 << start
    best = [INF] * n
    for v in range(n):
        if (mask >> v) & 1 and v != start:
            w = W[start][v]
            if w > 0:
                best[v] = w
    total = 0
    remaining = mask ^ inT
    while remaining:
        u = -1; bw = INF
        m = remaining
        while m:
            b = m & -m
            v = b.bit_length() - 1
            if best[v] < bw:
                bw = best[v]; u = v
            m ^= b
        if u == -1 or bw >= INF//2:
            return INF
        total += bw
        inT |= 1 << u
        remaining ^= 1 << u
        # relax edges from u
        m = remaining
        while m:
            b = m & -m
            v = b.bit_length() - 1
            w = W[u][v]
            if w > 0 and w < best[v]:
                best[v] = w
            m ^= b
    return total

def solve_case(n: int, c: int, W: List[List[int]]) -> int:
    if n == 0:
        return 0
    N = 1 << n
    ans = INF
    for mask in range(1, N):  # C non-empty
        mst_c = prim_on_mask(mask, W)
        if mst_c >= INF//2:
            continue
        # attachments from S to C
        attach = 0
        ok = True
        for u in range(n):
            if (mask >> u) & 1:
                continue
            best = INF
            m = mask
            while m:
                b = m & -m
                v = b.bit_length() - 1
                w = W[u][v]
                if w > 0 and w < best:
                    best = w
                m ^= b
            if best >= INF//2:
                ok = False
                break
            attach += best
        if not ok:
            continue
        cost = mst_c + attach + c * mask.bit_count()
        if cost < ans:
            ans = cost
    return ans

def main():
    n, c, W = read_input()
    if n == 0:
        return
    print(solve_case(n, c, W))

if __name__ == "__main__":
    # Simple asserts on tiny graphs
    def mat_from_edges(n, edges):
        W = [[0]*n for _ in range(n)]
        for u, v, w in edges:
            W[u][v] = w; W[v][u] = w
        return W
    W1 = mat_from_edges(4, [(0,1,1),(1,2,1),(2,3,1)])
    assert solve_case(4, 10, W1) == 23
    W2 = mat_from_edges(4, [(0,1,1),(0,2,1),(0,3,1)])
    assert solve_case(4, 5, W2) == 8
\end{minted}
\VALIDATION{Checked on path and star graphs; infeasible masks are safely skipped due to INF returns.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Subset DP + Decomposed MST}
\WHICHFORMULA{For each $C$, the cost is $c|C| + \mathrm{MST}(C) + \sum_{u \in S} a(u,C)$. Precompute $a(u,\cdot)$ for all $u$ and all masks via standard subset DP in $O(n 2^n)$. Then enumerate masks, compute $\mathrm{MST}(C)$ with Prim in $O(|C|^2)$, and add the precomputed attachment sum $\sum_{u \notin C} a(u,C)$.}
\ASSUMPTIONS{Dense bit-mask operations, Python integers; $n \le 20$ keeps $2^n$ feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute for each $u$ an array $f_u[\text{mask}] = \min_{v \in \text{mask}} w_{u,v}$ via $f_u[\text{mask}] = \min(f_u[\text{mask} \setminus \{\ell\}], w_{u,\ell})$ using the least-significant bit $\ell$.
\item Compute $A[\text{mask}] = \sum_{u \notin \text{mask}} f_u[\text{mask}]$ (attachments total).
\item For each non-empty mask $C$, compute $\mathrm{MST}(C)$ by Prim restricted to $C$. If disconnected or any $f_u[C]=\infty$ for some $u \notin C$, skip.
\item Aggregate cost $c|C| + \mathrm{MST}(C) + A[C]$; take minimum.
\end{algosteps}
\OPTIMALITY{For fixed $C$, independence of leaf attachments and the cut property of MSTs ensure optimal composition. Minimizing over $C$ realizes the exact $\min_T \left(\sum w + c \nu(T)\right)$ by the vertex-cover reparameterization.}
\COMPLEXITY{Precompute $f_u$: $O(n 2^n)$. Precompute $A$: $O(n 2^n)$. For each mask, Prim on $C$ costs $O(|C|^2)$; total $\sum \binom{n}{k} k^2 = O(n^2 2^n)$. Overall $O(n^2 2^n)$ time and $O(n 2^n)$ memory.}
\[
\begin{aligned}
T(n) &= O(n 2^n) + O(n 2^n) + O(n^2 2^n) = O(n^2 2^n), \\
S(n) &= O(n 2^n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final CF-ready solution: O(n^2 2^n). Includes read_input(), solve_all(), main()+guard, and asserts.

from typing import List, Tuple
import sys

INF = 10**30

def read_input() -> Tuple[int, int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); c = int(next(it))
    W = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            W[i][j] = int(next(it))
    return n, c, W

def prim_on_mask(mask: int, W: List[List[int]]) -> int:
    if mask == 0:
        return INF
    n = len(W)
    start = (mask & -mask).bit_length() - 1
    inT = 1 << start
    best = [INF] * n
    for v in range(n):
        if v != start and ((mask >> v) & 1):
            w = W[start][v]
            if w > 0:
                best[v] = w
    total = 0
    remaining = mask ^ inT
    while remaining:
        u = -1; bw = INF
        m = remaining
        while m:
            b = m & -m
            v = b.bit_length() - 1
            if best[v] < bw:
                bw = best[v]; u = v
            m ^= b
        if u == -1 or bw >= INF//2:
            return INF
        total += bw
        inT |= 1 << u
        remaining ^= 1 << u
        m = remaining
        while m:
            b = m & -m
            v = b.bit_length() - 1
            w = W[u][v]
            if w > 0 and w < best[v]:
                best[v] = w
            m ^= b
    return total

def solve_all(n: int, c: int, W: List[List[int]]) -> int:
    if n == 0:
        return 0
    N = 1 << n
    # Precompute f_u[mask] = min_{v in mask} w[u][v] (w>0), INF if none
    f = [ [INF]*N for _ in range(n) ]
    single = [ [INF]*n for _ in range(n) ]
    for u in range(n):
        for v in range(n):
            w = W[u][v]
            if w > 0:
                single[u][v] = w
    for u in range(n):
        f[u][0] = INF
        for mask in range(1, N):
            lsb = mask & -mask
            vidx = lsb.bit_length() - 1
            prev = f[u][mask ^ lsb]
            here = single[u][vidx]
            f[u][mask] = prev if prev < here else here
    # Precompute A[mask] = sum_{u not in mask} f[u][mask]
    A = [0]*N
    for mask in range(N):
        s = 0
        for u in range(n):
            if ((mask >> u) & 1) == 0:
                s_val = f[u][mask]
                if s_val >= INF//2:
                    s = INF
                    break
                s += s_val
        A[mask] = s
    ans = INF
    for mask in range(1, N):  # C non-empty
        attach = A[mask]
        if attach >= INF//2:
            continue
        mst_c = prim_on_mask(mask, W)
        if mst_c >= INF//2:
            continue
        cost = attach + mst_c + c * mask.bit_count()
        if cost < ans:
            ans = cost
    return ans

def main():
    n, c, W = read_input()
    if n == 0:
        return
    print(solve_all(n, c, W))

if __name__ == "__main__":
    # Exactly 3 asserts
    def mat_from_edges(n, edges):
        W = [[0]*n for _ in range(n)]
        for u, v, w in edges:
            W[u][v] = w; W[v][u] = w
        return W
    # 1) Path of 4 nodes, c=10: MST=3, matching size=2 => 23
    W1 = mat_from_edges(4, [(0,1,1),(1,2,1),(2,3,1)])
    assert solve_all(4, 10, W1) == 23
    # 2) Star on 4 nodes centered at 0, c=5: MST=3, matching size=1 => 8
    W2 = mat_from_edges(4, [(0,1,1),(0,2,1),(0,3,1)])
    assert solve_all(4, 5, W2) == 8
    # 3) Complete graph K3 with unit weights, c=7: MST=2, matching size=1 => 9
    W3 = mat_from_edges(3, [(0,1,1),(1,2,1),(0,2,1)])
    assert solve_all(3, 7, W3) == 2 + 7
\end{minted}
\VALIDATION{Three self-checks: path, star, and triangle. In each, the decomposition into $C$ plus attachments matches the analytical optimum.}
\RESULT{Output is the minimal possible value of $\sum w(T) + c \cdot \nu(T)$. Ties in trees are irrelevant since only the minimal value is printed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on canonical shapes (paths, stars, cycles), random dense/sparse small graphs, and adversarial cases (isolated-to-$C$ infeasibility).}
\LINE{CROSS-CHECKS}{Compare Approach B and C on random $n \le 12$ instances; both must agree. Baseline (A) can be used for $n \le 9$ for ground truth.}
\LINE{EDGE-CASE GENERATOR}{Generate graphs with missing edges to force $C$ connectivity checks and $a(u,C)$ infeasibility, and with multiple equal-weight options to test stability.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

import random

def gen_path(n: int, w: int = 1):
    W = [[0]*n for _ in range(n)]
    for i in range(n-1):
        W[i][i+1] = w; W[i+1][i] = w
    return W

def gen_star(n: int, center: int = 0, w: int = 1):
    W = [[0]*n for _ in range(n)]
    for v in range(n):
        if v != center:
            W[center][v] = w; W[v][center] = w
    return W

def gen_complete(n: int, low: int = 1, high: int = 5, seed: int = 1):
    random.seed(seed)
    W = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            w = random.randint(low, high)
            W[i][j] = w; W[j][i] = w
    return W

# Cross-check small instances
def brute(n, c, W):
    # Use Approach B implementation (subset enumeration with naive attachments)
    INF = 10**30
    def prim_on_mask(mask, W):
        if mask == 0: return INF
        n = len(W)
        start = (mask & -mask).bit_length()-1
        inT = 1<<start
        best = [INF]*n
        for v in range(n):
            if v != start and ((mask>>v)&1):
                w = W[start][v]
                if w>0: best[v]=w
        total = 0
        rem = mask ^ inT
        while rem:
            u=-1; bw=INF; m=rem
            while m:
                b=m&-m; v=b.bit_length()-1
                if best[v]<bw: bw=best[v]; u=v
                m^=b
            if u==-1 or bw>=INF//2: return INF
            total+=bw; inT|=1<<u; rem^=1<<u
            m=rem
            while m:
                b=m&-m; v=b.bit_length()-1
                w=W[u][v]
                if w>0 and w<best[v]: best[v]=w
                m^=b
        return total
    ans = INF
    N = 1<<n
    for mask in range(1, N):
        mst = prim_on_mask(mask, W)
        if mst>=INF//2: continue
        att = 0; ok=True
        for u in range(n):
            if (mask>>u)&1: continue
            best = INF; m = mask
            while m:
                b=m&-m; v=b.bit_length()-1
                w=W[u][v]
                if w>0 and w<best: best=w
                m^=b
            if best>=INF//2: ok=False; break
            att+=best
        if not ok: continue
        cost = mst + att + c*mask.bit_count()
        if cost<ans: ans=cost
    return ans

def test_cross():
    import itertools
    for n in range(2, 8):
        for seed in range(3):
            W = gen_complete(n, 1, 7, seed)
            for c in [1, 3, 10]:
                from sys import stdout
                # Use final solver from Approach C (imported/reused if running together)
                ans_b = brute(n, c, W)
                # Re-define here minimal solve_all for isolation:
                def solve_all(n, c, W):
                    INF = 10**30
                    N = 1<<n
                    f = [[INF]*N for _ in range(n)]
                    single = [[INF]*n for _ in range(n)]
                    for u in range(n):
                        for v in range(n):
                            w=W[u][v]
                            if w>0: single[u][v]=w
                    for u in range(n):
                        f[u][0]=INF
                        for mask in range(1, N):
                            lsb = mask & -mask
                            vidx = lsb.bit_length()-1
                            prev = f[u][mask^lsb]
                            here = single[u][vidx]
                            f[u][mask] = prev if prev < here else here
                    A=[0]*N
                    for mask in range(N):
                        s=0
                        for u in range(n):
                            if ((mask>>u)&1)==0:
                                val=f[u][mask]
                                if val>=INF//2:
                                    s=INF; break
                                s+=val
                        A[mask]=s
                    def prim(mask):
                        if mask==0: return INF
                        start=(mask&-mask).bit_length()-1
                        inT=1<<start; best=[INF]*n
                        for v in range(n):
                            if v!=start and ((mask>>v)&1):
                                w=W[start][v]
                                if w>0: best[v]=w
                        total=0; rem=mask^inT
                        while rem:
                            u=-1; bw=INF; m=rem
                            while m:
                                b=m&-m; v=b.bit_length()-1
                                if best[v]<bw: bw=best[v]; u=v
                                m^=b
                            if u==-1 or bw>=INF//2: return INF
                            total+=bw; inT|=1<<u; rem^=1<<u
                            m=rem
                            while m:
                                b=m&-m; v=b.bit_length()-1
                                w=W[u][v]
                                if w>0 and w<best[v]: best[v]=w
                                m^=b
                        return total
                    ans=INF
                    for mask in range(1, N):
                        if A[mask]>=INF//2: continue
                        mst=prim(mask)
                        if mst>=INF//2: continue
                        cost = A[mask] + mst + c*mask.bit_count()
                        if cost<ans: ans=cost
                    return ans
                ans_c = solve_all(n, c, W)
                assert ans_b == ans_c

# test_cross()  # Disabled by default to keep runtime bounded in this reference block
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final, ready-to-submit CF solution (same as Approach C), with required API and asserts.

from typing import List, Tuple
import sys

INF = 10**30

def read_input() -> Tuple[int, int, List[List[int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); c = int(next(it))
    W = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            W[i][j] = int(next(it))
    return n, c, W

def prim_on_mask(mask: int, W: List[List[int]]) -> int:
    if mask == 0:
        return INF
    n = len(W)
    start = (mask & -mask).bit_length() - 1
    inT = 1 << start
    best = [INF] * n
    for v in range(n):
        if v != start and ((mask >> v) & 1):
            w = W[start][v]
            if w > 0:
                best[v] = w
    total = 0
    remaining = mask ^ inT
    while remaining:
        u = -1; bw = INF
        m = remaining
        while m:
            b = m & -m
            v = b.bit_length() - 1
            if best[v] < bw:
                bw = best[v]; u = v
            m ^= b
        if u == -1 or bw >= INF//2:
            return INF
        total += bw
        inT |= 1 << u
        remaining ^= 1 << u
        m = remaining
        while m:
            b = m & -m
            v = b.bit_length() - 1
            w = W[u][v]
            if w > 0 and w < best[v]:
                best[v] = w
            m ^= b
    return total

def solve_all(n: int, c: int, W: List[List[int]]) -> int:
    if n == 0:
        return 0
    N = 1 << n
    # f[u][mask] = min_{v in mask} w[u][v], INF if none
    f = [ [INF]*N for _ in range(n) ]
    single = [ [INF]*n for _ in range(n) ]
    for u in range(n):
        for v in range(n):
            w = W[u][v]
            if w > 0:
                single[u][v] = w
    for u in range(n):
        f[u][0] = INF
        for mask in range(1, N):
            lsb = mask & -mask
            vidx = lsb.bit_length() - 1
            prev = f[u][mask ^ lsb]
            here = single[u][vidx]
            f[u][mask] = prev if prev < here else here
    A = [0]*N
    for mask in range(N):
        s = 0
        for u in range(n):
            if ((mask >> u) & 1) == 0:
                val = f[u][mask]
                if val >= INF//2:
                    s = INF
                    break
                s += val
        A[mask] = s
    ans = INF
    for mask in range(1, N):
        attach = A[mask]
        if attach >= INF//2:
            continue
        mst_c = prim_on_mask(mask, W)
        if mst_c >= INF//2:
            continue
        cost = attach + mst_c + c * mask.bit_count()
        if cost < ans:
            ans = cost
    return ans

def main():
    n, c, W = read_input()
    if n == 0:
        return
    print(solve_all(n, c, W))

if __name__ == "__main__":
    # 3 asserts
    def mat_from_edges(n, edges):
        W = [[0]*n for _ in range(n)]
        for u, v, w in edges:
            W[u][v] = w; W[v][u] = w
        return W
    W1 = mat_from_edges(4, [(0,1,1),(1,2,1),(2,3,1)])
    assert solve_all(4, 10, W1) == 23
    W2 = mat_from_edges(4, [(0,1,1),(0,2,1),(0,3,1)])
    assert solve_all(4, 5, W2) == 8
    W3 = mat_from_edges(3, [(0,1,1),(1,2,1),(0,2,1)])
    assert solve_all(3, 7, W3) == 9
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize $\sum w(T) + c \cdot \nu(T)$ over spanning trees by reparameterizing via a vertex cover $C$ of the tree and optimizing MST on $C$ plus cheapest attachments from $V \setminus C$.}
\WHY{Transforms a tricky matching-in-tree objective into a clean subset optimization over vertex covers, enabling an $O(n^2 2^n)$ solution for $n \le 20$. Useful pattern: exchange max-matching for min-vertex-cover on bipartite structures.}
\CHECKLIST{
\begin{bullets}
\item Convert $w_{i,j}=0$ to ``no edge''.
\item For a fixed $C \ne \varnothing$, compute $\mathrm{MST}(C)$ restricted to $C$--$C$ edges.
\item Compute $a(u,C)=\min_{v \in C} w_{u,v}$ for all $u \notin C$; ensure all finite.
\item Cost is $c|C| + \mathrm{MST}(C) + \sum a(u,C)$; take minimum across all $C$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $C=\varnothing$ is infeasible.
\item $|C|=1$: $\mathrm{MST}(C)=0$; all vertices must connect to that single node.
\item Missing edges: some $u \notin C$ may have no neighbor in $C$; skip such $C$.
\item $G[C]$ disconnected (for $|C|\ge 2$): skip.
\item All-ones $C=V$ always feasible; attachments sum is $0$.
\item Multiple equal minima: deterministic Prim still yields a correct MST.
\item Large $c$: solution tends toward smaller $C$ if connectivity allows.
\item Small $c$: solution tends toward $C=V$ (pure MST).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Treating $w=0$ as a valid edge (it denotes absence) would undercut correctness.
\item Forgetting that $S$--$S$ edges are forbidden under a chosen $C$.
\item Not handling $|C|=1$ correctly (MST is $0$ there).
\item Overflow concerns in languages with fixed-width ints; use 64-bit or big ints.
\item Inefficient per-mask attachment loops; use subset DP for $a(u,C)$.
\item Prim must be restricted to $C$; do not relax via any vertex outside $C$.
\item Skipping feasibility checks for $a(u,C)$ may propagate INF silently.
\item Off-by-one in bit operations; use $(mask \& -mask)$ and bit\_length carefully.
\end{bullets}}
\FAILMODES{Approaches that fix a tree first (MST) and then add matching penalty can be suboptimal; also, enumerating trees is infeasible for $n$ near $20$. The subset-based approach survives by decomposing the objective and pruning infeasible $C$.}
\ELI{Because trees are bipartite, counting matched edges is the same as counting the smallest set of vertices touching all edges. If you pick those vertices first, the cheapest tree is just an MST inside them plus the cheapest spokes from everyone else. Trying all such sets is doable for $n \le 20$.}
\NotePages{3}

\end{document}