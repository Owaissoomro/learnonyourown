% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Subsequences with a Unique Middle Mode II}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/subsequences-with-a-unique-middle-mode-ii/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an integer array $\,\texttt{nums}\,$ of length $n$. We call a pair $(T,p)$ valid if:
\begin{bullets}
\item $T$ is a subsequence of $\texttt{nums}$ (obtained by deleting zero or more elements without changing the order).
\item $p$ is an index in $\{0,\ldots,n-1\}$ such that $p$ is included in $T$.
\item Let $x=\texttt{nums}[p]$. In $T$, the value $x$ is the unique mode, i.e., its frequency in $T$ is strictly greater than the frequency of any other value in $T$.
\end{bullets}
Count the number of valid pairs $(T,p)$ and return the answer modulo $998{,}244{,}353$.

Notes:
\begin{bullets}
\item Two pairs are considered different if either the subsequences differ in at least one chosen index, or the distinguished index $p$ differs.
\item There is no restriction on the length of $T$ beyond being nonempty (because it must contain $p$).
\item This problem version (\emph{II}) counts pairs $(T,p)$ with a distinguished occurrence $p$ of the mode; it is not merely counting subsequences.
\end{bullets}

Constraints:
\begin{bullets}
\item $1 \le n \le 2\cdot 10^5$
\item $-10^9 \le \texttt{nums}[i] \le 10^9$
\item Answer is taken modulo $998{,}244{,}353$
\end{bullets}}
\BREAKDOWN{We must count all subsequences $T$ for which a chosen included index $p$ has value $x$ that is strictly more frequent in $T$ than any other value. Aggregate by value $x$ and use a combinatorial product factorization over global value frequencies.}
\ELI{Pick an index $p$ and count how many ways to add other elements so that $p$'s value appears more times than any other value; then sum over all $p$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode-style method: class \texttt{Solution} with
\begin{bullets}
\item \texttt{def subsequencesWithUniqueMiddleModeII(self, nums: List[int]) -> int}
\end{bullets}
where \texttt{nums} is the given array.}
\OUTPUTS{An integer: the number of valid pairs $(T,p)$ modulo $998{,}244{,}353$.}
\SAMPLES{
Example 1:
\begin{bullets}
\item \texttt{nums = [1]} $\rightarrow$ Only pair is $T=[1]$, $p=0$. Answer: $1$.
\end{bullets}
Example 2:
\begin{bullets}
\item \texttt{nums = [1,1]} $\rightarrow$ Valid pairs: for $p=0$: $T=[1]$, $T=[1,1]$; for $p=1$: $T=[1]$, $T=[1,1]$. Answer: $4$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the multiset of values in \texttt{nums} have distinct values $v_1,\ldots,v_m$ with global counts $c_1,\ldots,c_m$ (so $\sum_{j=1}^m c_j=n$). For each index $p$ with value $x=v_j$, we count subsequences $T$ that include $p$ and make $x$ a unique mode. The total is the sum over all indices $p$.}
\varmapStart
\var{n}{array length}
\var{v_j}{the $j$-th distinct value}
\var{c_j}{global frequency of $v_j$ in the array}
\var{S(c,s)}{$\sum_{t=0}^{\min(c,s)} \binom{c}{t}$}
\var{P(s)}{$\prod_{j=1}^m S(c_j,s)$}
\var{M}{the modulus $998{,}244{,}353$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Ans} \equiv \sum_{j=1}^{m} c_j \cdot \left( \sum_{s=0}^{c_j-1} \binom{c_j-1}{s} \cdot \frac{P(s)}{S(c_j,s)} \right) \pmod{M}
\end{BreakableEquation*}
}
\ASSUMPTIONS{Values are grouped only by equality. Unlabeled subsequences are determined by chosen indices. Products/sums are computed modulo $M$; divisions are via modular inverses when defined.}
\INVARIANTS{
\begin{bullets}
\item For a fixed distinguished value $x$ and chosen $s$ extra copies of $x$, any other value may be chosen at most $s$ times to keep $x$ uniquely most frequent.
\item Vandermonde: choices across left/right of the array collapse to choosing from the union by $\binom{c}{t}$.
\item $P(s)$ factors over distinct values, depending only on their global counts.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all nonempty subsequences and all included indices $p$, check uniqueness of mode for $\texttt{nums}[p]$.}
\ASSUMPTIONS{Practical only for $n \le 22$ or so due to $O(n 2^n)$ growth.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each mask $1\ldots (1\ll n)-1$, build the subsequence multiset and frequency map.
\item For each index $p$ included in the mask, test whether $\texttt{nums}[p]$ has strictly larger frequency than every other value in that subsequence.
\item Accumulate the count modulo $M$.
\end{algosteps}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= \Theta(n\cdot 2^n) \\
S(n) &= \Theta(n)
\end{aligned}
\]
}
\CORRECTNESS{Exhaustive enumeration covers all pairs $(T,p)$ by construction; the predicate directly tests the unique-mode condition.}
\EDGECASES{All-equal arrays; all-distinct arrays; $n=1$; highly repeated single value; negative values.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
from collections import Counter

MOD = 998244353

class SolutionBF:
    def subsequencesWithUniqueMiddleModeII(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for mask in range(1, 1 << n):
            # Build frequency for this subsequence
            freq = Counter()
            for i in range(n):
                if (mask >> i) & 1:
                    freq[nums[i]] += 1
            # For each included index p, check if its value is a unique mode
            max_other_cache = None
            # Precompute max frequency among all values for speed
            max_freq = 0
            for v, f in freq.items():
                if f > max_freq:
                    max_freq = f
            # For each p included, confirm strictly greater than all others
            for p in range(n):
                if (mask >> p) & 1:
                    x = nums[p]
                    fx = freq[x]
                    # If fx is not strictly the unique maximum, skip
                    good = True
                    for y, fy in freq.items():
                        if y != x and fy >= fx:
                            good = False
                            break
                    if good:
                        ans += 1
            ans %= MOD
        return ans

# Tiny self-checks for baseline
bf = SolutionBF()
assert bf.subsequencesWithUniqueMiddleModeII([1]) == 1
assert bf.subsequencesWithUniqueMiddleModeII([1, 1]) == 4
assert bf.subsequencesWithUniqueMiddleModeII([1, 2]) == 2
assert bf.subsequencesWithUniqueMiddleModeII([1, 1, 2]) == 7
\end{minted}
\VALIDATION{The asserts check degenerate and small mixed cases and match hand calculations.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Value Grouping and Product Factorization}
\WHICHFORMULA{Group by distinct value counts $c$, precompute $S(c,s)=\sum_{t=0}^{\min(c,s)}\binom{c}{t}$, and use $P(s)=\prod_v S(c_v,s)$. Then for value $x$ with count $c_x$, the contribution is $\sum_{s=0}^{c_x-1} \binom{c_x-1}{s}\cdot P(s)/S(c_x,s)$.}
\ASSUMPTIONS{Modulus $M=998{,}244{,}353$ is prime; modular inverses exist for typical inputs. Precompute factorials up to $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build frequency map of values and histogram of counts: for each $c$, how many distinct values have count $c$.
\item Precompute factorials and inverse factorials up to $n$ to evaluate $\binom{\cdot}{\cdot}$ in $O(1)$.
\item For each distinct count $c$, precompute $S(c,s)$ for $s=0,\ldots,c$; note $S(c,s)=2^c$ for $s\ge c$.
\item Observe $P(s)=\prod_v S(c_v,s)=\prod_c S(c,s)^{\text{mult}[c]}$. Also $P_{\text{base}}=\prod_v 2^{c_v}=2^n$.
\item Initialize $P[s]\gets 2^n$ for $s=0,\ldots,\max c - 1$. For each $c$ and for $s=0,\ldots, c-1$, multiply $P[s]$ by $\big(S(c,s)\cdot (2^{-c})\big)^{\text{mult}[c]}$.
\item For each $c$ with multiplicity $m$, add $m\cdot c \cdot \sum_{s=0}^{c-1} \binom{c-1}{s}\cdot P[s]\cdot S(c,s)^{-1}$ to the answer.
\end{algosteps}
\COMPLEXITY{Precomputations are $O(n)$, and building $P[\cdot]$ costs $O\!\big(\sum_c c\big)=O(n)$. Summation costs $O\!\big(\sum_c c\big)=O(n)$. Overall near-linear.
\[
\begin{aligned}
T(n) &= O(n \log M) \\
S(n) &= O(n)
\end{aligned}
\]
}
\CORRECTNESS{Fix a distinguished value $x$ and let $s$ be the number of extra $x$'s selected beyond index $p$. To keep $x$ uniquely most frequent, each other value $y$ can be chosen at most $s$ times. The number of such choices for $y$ across the array is $S(c_y,s)$. Independence across values yields the product $P(s)$; we divide out $S(c_x,s)$ because the $s$ extra copies of $x$ are counted explicitly via $\binom{c_x-1}{s}$. Summing $s$ and then summing $p$ over all occurrences (a factor $c_x$) yields the formula.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Dict
from collections import Counter

MOD = 998244353

def modinv(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def precompute_fact(n: int):
    fact = [1] * (n + 1)
    invfact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[n] = modinv(fact[n])
    for i in range(n, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def nCk(n: int, k: int, fact, invfact) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

class SolutionImproved:
    def subsequencesWithUniqueMiddleModeII(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        freq = Counter(nums)
        counts = list(freq.values())
        maxC = max(counts)
        # Histogram: mult[c] = number of distinct values with count c
        mult: Dict[int, int] = Counter(counts)

        fact, invfact = precompute_fact(n)
        pow2 = [1] * (maxC + 1)
        for i in range(1, maxC + 1):
            pow2[i] = (pow2[i - 1] * 2) % MOD

        # Precompute S(c, s) for each distinct c and for s = 0..c
        S_rows: Dict[int, List[int]] = {}
        for c, m in mult.items():
            # Build prefix sums of binomial coefficients for row c
            row = [0] * (c + 1)
            ssum = 0
            for s in range(0, c + 1):
                ssum = (ssum + nCk(c, s, fact, invfact)) % MOD
                row[s] = ssum
            S_rows[c] = row  # row[s] valid for s<=c; for s>c, value is 2^c

        # Compute P[s] for s = 0..maxC-1 using base 2^n and corrections
        P = [pow(2, n, MOD)] * (maxC if maxC > 0 else 1)
        for c, m in mult.items():
            inv_pow2_c = modinv(pow2[c])
            row = S_rows[c]
            for s in range(0, c):
                factor = row[s] * inv_pow2_c % MOD
                P[s] = P[s] * pow(factor, m, MOD) % MOD

        # Sum contributions group-by-count
        ans = 0
        for c, m in mult.items():
            row = S_rows[c]
            group_sum = 0
            for s in range(0, c):
                comb = nCk(c - 1, s, fact, invfact)
                denom = row[s]  # S(c, s)
                term = comb * P[s] % MOD * modinv(denom) % MOD
                group_sum = (group_sum + term) % MOD
            contrib = (m * c) % MOD * group_sum % MOD
            ans = (ans + contrib) % MOD
        return ans

# Cross-check with baseline on small cases
bf = SolutionBF()
imp = SolutionImproved()
for arr in ([], [1], [1,1], [1,2], [1,1,2], [2,2,2], [1,2,2,3]):
    if arr:
        assert imp.subsequencesWithUniqueMiddleModeII(arr) == bf.subsequencesWithUniqueMiddleModeII(arr)
    else:
        assert imp.subsequencesWithUniqueMiddleModeII(arr) == 0
\end{minted}
\VALIDATION{Cross-checks against the brute force on small arrays.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Near-Linear Combinatorial Aggregation}
\WHICHFORMULA{Compute $P(s)$ once for all $s$ via base $2^n$ with $O(\sum_c c)$ corrections, then accumulate contributions per count group.}
\ASSUMPTIONS{Prime modulus $998{,}244{,}353$; input size up to $2\cdot 10^5$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count frequencies of distinct values; build histogram $\text{mult}[c]$.
\item Precompute factorials, inverse factorials up to $n$; precompute $2^i$ up to $\max c$.
\item For each distinct $c$, build $S(c,s)$ for $s=0,\ldots,c$.
\item Initialize $P[s]\gets 2^n$ for $s=0,\ldots,\max c-1$, then for each $c$ and $s=0,\ldots,c-1$ multiply $P[s]$ by $\big(S(c,s)\cdot (2^{-c})\big)^{\text{mult}[c]}$.
\item Sum answer: for each $c$ with multiplicity $m$, add $m\cdot c\cdot \sum_{s=0}^{c-1} \binom{c-1}{s} \cdot P[s] \cdot S(c,s)^{-1}$.
\end{algosteps}
\OPTIMALITY{Each distinct count $c$ contributes $O(c)$ work and $\sum_c c = n$. Factorials allow $O(1)$ binomials. This is optimal up to near-linear factors without heavier transforms.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= O(n \log M) \\
S(n) &= O(n)
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Dict
from collections import Counter

MOD = 998244353

def _modinv(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def _precompute_fact(n: int):
    fact = [1] * (n + 1)
    invfact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[n] = _modinv(fact[n])
    for i in range(n, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def _nCk(n: int, k: int, fact, invfact) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

class Solution:
    def subsequencesWithUniqueMiddleModeII(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        freq = Counter(nums)
        counts = list(freq.values())
        maxC = max(counts)
        mult: Dict[int, int] = Counter(counts)

        fact, invfact = _precompute_fact(n)

        # Precompute powers of 2 up to maxC
        pow2 = [1] * (maxC + 1)
        for i in range(1, maxC + 1):
            pow2[i] = (pow2[i - 1] * 2) % MOD

        # Precompute S_rows[c][s] = sum_{t=0}^{s} C(c, t), for s=0..c
        S_rows: Dict[int, List[int]] = {}
        for c, m in mult.items():
            row = [0] * (c + 1)
            ssum = 0
            for s in range(0, c + 1):
                ssum = (ssum + _nCk(c, s, fact, invfact)) % MOD
                row[s] = ssum
            S_rows[c] = row

        # P[s] for s=0..maxC-1 starts at 2^n, then corrected
        L = maxC if maxC > 0 else 1
        P = [pow(2, n, MOD)] * L
        for c, m in mult.items():
            inv_pow2_c = _modinv(pow2[c])
            row = S_rows[c]
            for s in range(0, c):
                factor = row[s] * inv_pow2_c % MOD
                P[s] = P[s] * pow(factor, m, MOD) % MOD

        ans = 0
        for c, m in mult.items():
            row = S_rows[c]
            subtotal = 0
            for s in range(0, c):
                comb = _nCk(c - 1, s, fact, invfact)
                term = comb * P[s] % MOD * _modinv(row[s]) % MOD
                subtotal = (subtotal + term) % MOD
            contrib = (m * c) % MOD * subtotal % MOD
            ans = (ans + contrib) % MOD
        return ans

# Asserts: exact 3 mini-tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.subsequencesWithUniqueMiddleModeII([1]) == 1
    assert sol.subsequencesWithUniqueMiddleModeII([1, 1]) == 4
    assert sol.subsequencesWithUniqueMiddleModeII([1, 1, 2]) == 7
\end{minted}
\VALIDATION{Three asserts cover single-element, all-equal, and mixed small cases with known answers.}
\RESULT{Returns the number of valid pairs $(T,p)$ modulo $998{,}244{,}353$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-validate the optimized solution with the brute-force on random arrays of small length (e.g., $n\le 12$). Include adversarial patterns: all equal, all distinct, two-value mixtures with skewed counts.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A and C on the same inputs; they must match exactly modulo $M$.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with: $n=1$; all entries identical; alternating two values; random small values with limited alphabet for high collision.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
def gen_all_equal(n: int, v: int) -> List[int]:
    return [v] * n

def gen_all_distinct(n: int) -> List[int]:
    return list(range(1, n + 1))

def gen_two_value(n: int, a: int, b: int, k: int) -> List[int]:
    # k copies of 'a' then (n-k) copies of 'b'
    return [a] * k + [b] * (n - k)

def gen_alternating(n: int, a: int, b: int) -> List[int]:
    return [a if i % 2 == 0 else b for i in range(n)]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Dict
from collections import Counter

MOD = 998244353

def _modinv(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def _precompute_fact(n: int):
    fact = [1] * (n + 1)
    invfact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invfact[n] = _modinv(fact[n])
    for i in range(n, 0, -1):
        invfact[i - 1] = invfact[i] * i % MOD
    return fact, invfact

def _nCk(n: int, k: int, fact, invfact) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

class Solution:
    def subsequencesWithUniqueMiddleModeII(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        freq = Counter(nums)
        counts = list(freq.values())
        maxC = max(counts)
        mult: Dict[int, int] = Counter(counts)

        fact, invfact = _precompute_fact(n)

        pow2 = [1] * (maxC + 1)
        for i in range(1, maxC + 1):
            pow2[i] = (pow2[i - 1] * 2) % MOD

        S_rows: Dict[int, List[int]] = {}
        for c, m in mult.items():
            row = [0] * (c + 1)
            ssum = 0
            for s in range(0, c + 1):
                ssum = (ssum + _nCk(c, s, fact, invfact)) % MOD
                row[s] = ssum
            S_rows[c] = row

        L = maxC if maxC > 0 else 1
        P = [pow(2, n, MOD)] * L
        for c, m in mult.items():
            inv_pow2_c = _modinv(pow2[c])
            row = S_rows[c]
            for s in range(0, c):
                factor = row[s] * inv_pow2_c % MOD
                P[s] = P[s] * pow(factor, m, MOD) % MOD

        ans = 0
        for c, m in mult.items():
            row = S_rows[c]
            subtotal = 0
            for s in range(0, c):
                comb = _nCk(c - 1, s, fact, invfact)
                term = comb * P[s] % MOD * _modinv(row[s]) % MOD
                subtotal = (subtotal + term) % MOD
            contrib = (m * c) % MOD * subtotal % MOD
            ans = (ans + contrib) % MOD
        return ans

# Final quick tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.subsequencesWithUniqueMiddleModeII([1]) == 1
    assert sol.subsequencesWithUniqueMiddleModeII([1, 1]) == 4
    assert sol.subsequencesWithUniqueMiddleModeII([1, 1, 2]) == 7
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count pairs $(T,p)$ where $p$'s value is the unique mode of $T$, using global value counts and a product factorization.}
\WHY{A classic hard combinatorics pattern: constrain other values by a cap tied to the chosen mode's multiplicity, then factor across distinct values.}
\CHECKLIST{
\begin{bullets}
\item Build value frequency map and histogram of counts.
\item Precompute factorials/inverses and powers of $2$.
\item Compute $S(c,s)$ rows and assemble $P[s]$ from $2^n$ with corrections.
\item Accumulate contributions per count $c$ with binomials and modular inverses.
\item Modulo at each step; handle empty array as $0$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item All values identical.
\item All values distinct.
\item Two-value arrays with skewed multiplicities.
\item Large $n$ near $2\cdot 10^5$.
\item Values outside small ranges (negatives/large positives) do not matter; only equality matters.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting that $S(c,s)=2^c$ for $s\ge c$ and overcomputing arrays.
\item Dividing by $S(c,s)$ without modular inverse.
\item Overflow if not reducing modulo during products.
\item Building $P[s]$ in $O(m\cdot \max c)$ naively; use the $2^n$ base with $O(\sum c)$ corrections.
\item Wrongly double-counting by value instead of by count group.
\item Off-by-one in $\binom{c-1}{s}$ and the $s$ summation limits.
\end{bullets}}
\FAILMODES{Naive enumeration explodes at $n\ge 30$. Incorrect factorization yields wrong counts on arrays with multiple high-frequency values. The presented method maintains caps per value and aggregates safely.}
\ELI{Pick a champion value $x$ and decide to take $s$ more copies of it; then every other value can appear at most $s$ times. Multiply the choices across values and sum over $s$. Do this once per count group and add everything up.}
\NotePages{3}

\end{document}