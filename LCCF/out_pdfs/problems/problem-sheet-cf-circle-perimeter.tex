% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Circle Perimeter}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1971/F}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Given an integer $r$, find the number of lattice points that have a Euclidean distance from $(0, 0)$ greater than or equal to $r$ but strictly less than $r+1$.

A lattice point is a point with integer coordinates. The Euclidean distance from $(0, 0)$ to the point $(x,y)$ is $\sqrt{x^2 + y^2}$.

Input:
The first line contains a single integer $t$ ($1 \le t \le 1000$) — the number of test cases.

The only line of each test case contains a single integer $r$ ($1 \le r \le 10^5$).

The sum of $r$ over all test cases does not exceed $10^5$.

Output:
For each test case, output a single integer — the number of lattice points that have an Euclidean distance $d$ from $(0, 0)$ such that $r \le d < r+1$.

Note:
The points for the first three test cases are shown below.}
\BREAKDOWN{Count integer points in the annulus $r^2 \le x^2+y^2 < (r+1)^2$ by exploiting symmetry and integer square roots. Handle strict inequality at the outer boundary carefully.}
\ELI{We are counting integer grid points that lie between two concentric circles of radii $r$ and $r+1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $t$; then $t$ lines, each with an integer $r$ where $1 \le r \le 10^5$ and $\sum r \le 10^5$.}
\OUTPUTS{For each test case, print the number of integer pairs $(x,y)$ with $r \le \sqrt{x^2+y^2} < r+1$ on its own line.}
\SAMPLES{Example:
\begin{bullets}
\item Input:
\begin{BreakableEquation*}
\begin{aligned}
3\\
1\\
2\\
3
\end{aligned}
\end{BreakableEquation*}
Output:
\begin{BreakableEquation*}
\begin{aligned}
8\\
16\\
20
\end{aligned}
\end{BreakableEquation*}
\item Explanation: For $r=1$, the 8 points are $(\pm1,0)$, $(0,\pm1)$, $(\pm1,\pm1)$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathbb{Z}$ denote the integers. For a given $r\in\mathbb{Z}_{\ge 1}$, define the set
\begin{BreakableEquation*}
S_r=\{(x,y)\in\mathbb{Z}^2 \mid r^2 \le x^2+y^2 < (r+1)^2\}.
\end{BreakableEquation*}
The required answer is $|S_r|$.}
\varmapStart
\var{r}{annulus inner radius (integer)}
\var{R}{shorthand $R=r+1$}
\var{x,y}{integer coordinates of a lattice point}
\var{d}{Euclidean distance $\sqrt{x^2+y^2}$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
|S_r|=\left|\{(x,y)\in\mathbb{Z}^2: r^2 \le x^2+y^2 < (r+1)^2\}\right|.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Use integer arithmetic only; distances are compared by squaring to avoid floating point. Use symmetry across axes to reduce to the first quadrant, then multiply with care for axis points.}
\INVARIANTS{
\begin{bullets}
\item Monotonicity: For fixed $r$, as $x$ increases, the admissible $y$ range in the first quadrant is nonincreasing.
\item Boundary handling: Outer radius is strict ($<$), inner is non-strict ($\le$).
\item Axis points: Exactly $4$ points lie on axes, namely $(\pm r,0)$ and $(0,\pm r)$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly test all integer points in the bounding square $[-(r+1), r+1]^2$ and count those with $r^2 \le x^2+y^2 < (r+1)^2$.}
\ASSUMPTIONS{Bounding by the smallest axis-aligned square containing both circles. Use squared distances to avoid floating-point errors.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each test case, initialize count $ans=0$.
\item Loop $x$ from $-(r+1)$ to $r+1$, and $y$ from $-(r+1)$ to $r+1$.
\item If $r^2 \le x^2+y^2 < (r+1)^2$, increment $ans$.
\end{algosteps}
\COMPLEXITY{Quadratic in $r$.}
\[
\begin{aligned}
T(r) &\in \Theta\big((2r+3)^2\big)=\Theta(r^2), \\
S(r) &\in \Theta(1) \text{ extra (beyond input/output).}
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration over the bounding square ensures every candidate point is checked exactly once; squared comparison matches the annulus definition.}
\EDGECASES{Small $r$ (e.g., $r=1$), and ensuring the strict upper bound excludes points with $x^2+y^2=(r+1)^2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    rs = [int(next(it)) for _ in range(t)]
    return rs

def solve_case_bruteforce(r: int) -> int:
    R = r + 1
    r2 = r * r
    R2 = R * R
    lo = -(R)
    hi = R
    ans = 0
    for x in range(lo, hi + 1):
        xx = x * x
        for y in range(lo, hi + 1):
            s = xx + y * y
            if r2 <= s < R2:
                ans += 1
    return ans

def solve_all_bruteforce(rs):
    out = []
    for r in rs:
        out.append(str(solve_case_bruteforce(r)))
    return "\n".join(out)

def main():
    rs = read_input()
    print(solve_all_bruteforce(rs))

if __name__ == "__main__":
    # Tiny self-checks
    assert solve_case_bruteforce(1) == 8
    assert solve_case_bruteforce(2) == 16
    assert solve_case_bruteforce(3) == 20
    # Cross-check a few small values
    for r in range(1, 8):
        brute = solve_case_bruteforce(r)
        # known perimeter grows roughly ~ 2*pi*r, but we only assert monotonic nondecreasing
        if r > 1:
            assert brute >= prev
        prev = brute
    # Do not run main() in tests
    # main()
\end{minted}
\VALIDATION{Verified on $r\in\{1,2,3\}$ and a sweep over small $r$ for sanity.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Two-Pointer Monotone Boundaries}
\WHICHFORMULA{Count points in the first quadrant by maintaining two monotone pointers: $y_{\max}$ for the strict outer bound $x^2+y^2 < (r+1)^2$, and $y_{\min}$ for the inner bound $x^2+y^2 \ge r^2$.}
\ASSUMPTIONS{As $x$ increases, both $y_{\max}$ and $y_{\min}$ never increase. This allows amortized $O(1)$ updates and $O(r)$ time per test.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $y_{\max}=\left\lfloor\sqrt{(r+1)^2-1}\right\rfloor$ and $y_{\min}=r$.
\item For $x=0,1,\ldots,r$:
  \begin{bullets}
  \item Decrease $y_{\max}$ while $x^2+y_{\max}^2 \ge (r+1)^2$.
  \item Decrease $y_{\min}$ while $y_{\min}>0$ and $x^2+(y_{\min}-1)^2 \ge r^2$.
  \item Let $cnt=\max(0,\,y_{\max}-y_{\min}+1)$ be the number of $y\ge 0$ in range.
  \item Add to the answer using symmetry: for $x=0$, contribute $2\cdot cnt$; for $x>0$, contribute $2$ if $y=0$ is included, plus $4$ for each strictly positive $y$.
  \end{bullets}
\item Output the total.
\end{algosteps}
\COMPLEXITY{Both pointers move only downward across all $x$.}
\[
\begin{aligned}
T(r) &\in O(r),\\
S(r) &\in O(1).
\end{aligned}
\]
\CORRECTNESS{For each $x$, $[y_{\min},y_{\max}]$ exactly characterizes integer $y\ge 0$ satisfying $r^2 \le x^2+y^2 < (r+1)^2$. Symmetry multiplies by $4$ for interior quadrant points and by $2$ for axis points. Outer boundary is strict by construction of $y_{\max}$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    rs = [int(next(it)) for _ in range(t)]
    return rs

def solve_case_twoptr(r: int) -> int:
    R = r + 1
    r2 = r * r
    R2 = R * R
    ans = 0
    # y_max satisfies x^2 + y^2 < R2
    y_max = int(math.isqrt(R2 - 1))  # for x=0
    # y_min is the smallest y >= 0 with x^2 + y^2 >= r2; start at x=0 => y_min=r
    y_min = r
    for x in range(0, r + 1):
        xx = x * x
        while y_max >= 0 and xx + y_max * y_max >= R2:
            y_max -= 1
        while y_min > 0 and xx + (y_min - 1) * (y_min - 1) >= r2:
            y_min -= 1
        if y_max < y_min:
            continue
        cnt = y_max - y_min + 1  # number of y >= 0
        if x == 0:
            # y=0 never occurs for r>=1; but formula 2*cnt still holds
            ans += 2 * cnt
        else:
            has_y0 = 1 if y_min == 0 else 0
            pos = cnt - has_y0
            ans += 2 * has_y0 + 4 * pos
    return ans

def solve_all_twoptr(rs):
    out = []
    for r in rs:
        out.append(str(solve_case_twoptr(r)))
    return "\n".join(out)

def main():
    rs = read_input()
    print(solve_all_twoptr(rs))

if __name__ == "__main__":
    # Cross-check with a brute force for small r
    def brute(r: int) -> int:
        r2, R2 = r * r, (r + 1) * (r + 1)
        c = 0
        for x in range(-(r + 1), r + 2):
            xx = x * x
            for y in range(-(r + 1), r + 2):
                s = xx + y * y
                if r2 <= s < R2:
                    c += 1
        return c
    for r in range(1, 70):
        assert solve_case_twoptr(r) == brute(r)
    # main()
\end{minted}
\VALIDATION{Checked exactly against brute force for $r$ up to $69$; matches known small examples.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Quadrant Counting with Integer Square Roots}
\WHICHFORMULA{For each $x\in[0,r]$, compute
$y_{\min}=\left\lceil\sqrt{\max(0, r^2-x^2)}\right\rceil$ and
$y_{\max}=\left\lfloor\sqrt{(r+1)^2-x^2-1}\right\rfloor$ (the $-1$ enforces the strict outer bound). Then add symmetry contributions.}
\ASSUMPTIONS{Use exact integer square roots: $\lfloor\sqrt{\cdot}\rfloor$ via \texttt{math.isqrt}, and ceil via a small adjustment. The sum of $r$ across tests is $\le 10^5$, so $O(r)$ per test is fast.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each test case:
\item For $x=0,1,\ldots,r$, compute
$y_{\min}=\left\lceil\sqrt{\max(0, r^2-x^2)}\right\rceil$ and
$y_{\max}=\left\lfloor\sqrt{(r+1)^2-x^2-1}\right\rfloor$.
\item If $y_{\max}<y_{\min}$, continue. Let $cnt=y_{\max}-y_{\min}+1$.
\item If $x=0$, add $2\cdot cnt$; else add $2$ if $y=0$ is included, and $4$ for each strictly positive $y$ in the range.
\item Output the accumulated sum.
\end{algosteps}
\OPTIMALITY{Each $x$ is processed in $O(1)$ time using integer arithmetic; by symmetry, no point is double-counted. This meets the natural $\Omega(r)$ lower bound to enumerate distinct $x$-slices.}
\COMPLEXITY{Linear in $r$ per test case.}
\[
\begin{aligned}
T(r) &\in \Theta(r),\quad S(r)\in \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, math

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    rs = [int(next(it)) for _ in range(t)]
    return rs

def ceil_isqrt(n: int) -> int:
    if n <= 0:
        return 0
    s = math.isqrt(n)
    return s if s * s == n else s + 1

def solve_case(r: int) -> int:
    r2 = r * r
    R2 = (r + 1) * (r + 1)
    ans = 0
    for x in range(0, r + 1):
        xx = x * x
        lo = r2 - xx
        y_min = ceil_isqrt(lo) if lo > 0 else 0
        up_excl = R2 - xx - 1
        if up_excl < 0:
            y_max = -1
        else:
            y_max = math.isqrt(up_excl)
        if y_max < y_min:
            continue
        cnt = y_max - y_min + 1
        if x == 0:
            ans += 2 * cnt  # (0, y) and (0, -y), y>0
        else:
            has_y0 = 1 if y_min == 0 else 0
            pos = cnt - has_y0
            ans += 2 * has_y0 + 4 * pos  # axes (±x,0) + interior 4-way symmetry
    return ans

def solve_all(rs):
    out = []
    for r in rs:
        out.append(str(solve_case(r)))
    return "\n".join(out)

def main():
    rs = read_input()
    print(solve_all(rs))

if __name__ == "__main__":
    # Cross-check final solver vs brute for small r
    def brute(r: int) -> int:
        r2, R2 = r * r, (r + 1) * (r + 1)
        c = 0
        for x in range(-(r + 1), r + 2):
            xx = x * x
            for y in range(-(r + 1), r + 2):
                s = xx + y * y
                if r2 <= s < R2:
                    c += 1
        return c
    assert solve_case(1) == 8
    assert solve_case(2) == 16
    assert solve_case(3) == 20
    for r in range(1, 120):
        assert solve_case(r) == brute(r)
    # main()
\end{minted}
\VALIDATION{Asserts for $r=1,2,3$ and exhaustive cross-check up to $r=119$ against brute force.}
\RESULT{For each test case, print the exact number of lattice points in the annulus $r^2 \le x^2+y^2 < (r+1)^2$. Tie-breaking is not applicable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the solver against a brute-force reference for $r$ up to $120$. Additionally, spot-check axis-only cases and growth trend with increasing $r$.}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches B and C on random small radii; both must match the brute-force baseline.}
\LINE{EDGE-CASE GENERATOR}{Generate radii at boundaries: $r=1$, primes, perfect squares, and values where $2r$ is a perfect square to stress the $y_{\max}$ computation.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random, math

def gen_rs_small(max_r=120):
    return list(range(1, max_r+1))

def gen_rs_mixed():
    rs = [1, 2, 3, 4, 5, 10, 25, 50, 75, 100]
    # radii where 2r is a perfect square stress outer ceil/floor edges
    rs += [2 * k * k for k in range(1, 16)]
    rs = sorted(set([r for r in rs if r >= 1]))
    return rs

def run_cross_checks():
    from math import isqrt
    def brute(r: int) -> int:
        r2, R2 = r * r, (r + 1) * (r + 1)
        c = 0
        for x in range(-(r + 1), r + 2):
            xx = x * x
            for y in range(-(r + 1), r + 2):
                s = xx + y * y
                if r2 <= s < R2:
                    c += 1
        return c

    def solve_case_twoptr(r: int) -> int:
        R = r + 1
        r2 = r * r
        R2 = R * R
        ans = 0
        y_max = int(math.isqrt(R2 - 1))
        y_min = r
        for x in range(0, r + 1):
            xx = x * x
            while y_max >= 0 and xx + y_max * y_max >= R2:
                y_max -= 1
            while y_min > 0 and xx + (y_min - 1) * (y_min - 1) >= r2:
                y_min -= 1
            if y_max < y_min:
                continue
            cnt = y_max - y_min + 1
            if x == 0:
                ans += 2 * cnt
            else:
                has_y0 = 1 if y_min == 0 else 0
                pos = cnt - has_y0
                ans += 2 * has_y0 + 4 * pos
        return ans

    def solve_case_final(r: int) -> int:
        r2 = r * r
        R2 = (r + 1) * (r + 1)
        ans = 0
        for x in range(0, r + 1):
            xx = x * x
            lo = r2 - xx
            y_min = 0 if lo <= 0 else (math.isqrt(lo) if math.isqrt(lo)**2 == lo else math.isqrt(lo) + 1)
            up_excl = R2 - xx - 1
            y_max = -1 if up_excl < 0 else math.isqrt(up_excl)
            if y_max < y_min:
                continue
            cnt = y_max - y_min + 1
            if x == 0:
                ans += 2 * cnt
            else:
                has_y0 = 1 if y_min == 0 else 0
                pos = cnt - has_y0
                ans += 2 * has_y0 + 4 * pos
        return ans

    for r in gen_rs_small():
        b = brute(r)
        assert solve_case_twoptr(r) == b
        assert solve_case_final(r) == b
    for r in gen_rs_mixed():
        b = brute(r)
        assert solve_case_twoptr(r) == b
        assert solve_case_final(r) == b

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys, math

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    rs = [int(next(it)) for _ in range(t)]
    return rs

def ceil_isqrt(n: int) -> int:
    if n <= 0:
        return 0
    s = math.isqrt(n)
    return s if s * s == n else s + 1

def solve_case(r: int) -> int:
    r2 = r * r
    R2 = (r + 1) * (r + 1)
    ans = 0
    for x in range(0, r + 1):
        xx = x * x
        lo = r2 - xx
        y_min = ceil_isqrt(lo) if lo > 0 else 0
        up_excl = R2 - xx - 1
        y_max = -1 if up_excl < 0 else math.isqrt(up_excl)
        if y_max < y_min:
            continue
        cnt = y_max - y_min + 1
        if x == 0:
            ans += 2 * cnt
        else:
            has_y0 = 1 if y_min == 0 else 0
            pos = cnt - has_y0
            ans += 2 * has_y0 + 4 * pos
    return ans

def solve_all(rs):
    return "\n".join(str(solve_case(r)) for r in rs)

def main():
    rs = read_input()
    print(solve_all(rs))

if __name__ == "__main__":
    # Minimal sanity asserts
    assert solve_case(1) == 8
    assert solve_case(2) == 16
    assert solve_case(3) == 20
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count integer lattice points in the annulus $r \le \sqrt{x^2+y^2} < r+1$ exactly using integer arithmetic and symmetry.}
\WHY{Annulus counting arises in geometry, number theory, and as a warm-up for Gauss-circle-type arguments; it tests careful boundary handling under time pressure.}
\CHECKLIST{
\begin{bullets}
\item Compare squared distances to avoid floating point.
\item Outer bound is strict: use $R^2-1$ inside a floor square root.
\item Use symmetry: interior quadrant points $\times 4$, axis points $\times 2$.
\item Include $(\pm r,0)$ and $(0,\pm r)$ exactly once each.
\item Prefer $O(r)$ scan; sum $r \le 10^5$ is safe.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $r=1$ (smallest radius).
\item When $R^2-x^2-1<0$ (no valid $y$).
\item When $r^2-x^2\le 0$ (inner bound allows $y=0$).
\item $x=r$ slice: only small $y$ remain; ensure $y=0$ counted correctly.
\item $x=0$ slice: contributes only vertical pairs $(0,\pm y)$.
\item Large $r$ near the constraint limit; performance must remain linear.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting the strict inequality on the outer radius.
\item Off-by-one in ceil/floor of square roots.
\item Double-counting axis points when multiplying by $4$.
\item Using floating point sqrt and hitting rounding issues.
\item Scanning beyond $x=r$ unnecessarily.
\item Negative argument inside $\sqrt{\cdot}$ without checks.
\end{bullets}
}
\FAILMODES{Brute force over a square is $\Theta(r^2)$ and times out when $r$ is large across many cases. Floating-point comparisons can misclassify points near the boundary; integer arithmetic avoids this.}
\ELI{We slice the donut-shaped region by vertical lines. For each $x$, we find the allowed $y$ integers using exact square roots, then mirror across axes to get all four quadrants without double-counting points on the axes.}
\NotePages{3}

\end{document}