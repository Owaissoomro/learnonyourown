% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Number of Ways to Stay in the Same Place After Some Steps}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You have a pointer at index \texttt{0} in an array of size \texttt{arrLen}. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (the pointer should not be placed outside the array at any time). Given two integers \texttt{steps} and \texttt{arrLen}, return the number of ways such that your pointer is still at index \texttt{0} after exactly \texttt{steps} steps. Since the answer may be too large, return it modulo $10^9+7$.

Example 1:

Input: \texttt{steps = 3, arrLen = 2}\\
Output: \texttt{4}\\
Explanation: There are 4 different ways to stay at index 0 after 3 steps.\\
Right, Left, Stay\\
Stay, Right, Left\\
Right, Stay, Left\\
Stay, Stay, Stay

Example 2:

Input: \texttt{steps = 2, arrLen = 4}\\
Output: \texttt{2}\\
Explanation: There are 2 different ways to stay at index 0 after 2 steps.\\
Right, Left\\
Stay, Stay

Example 3:

Input: \texttt{steps = 4, arrLen = 2}\\
Output: \texttt{8}

Constraints:
\begin{itemize}
\item $1 \le \texttt{steps} \le 500$
\item $1 \le \texttt{arrLen} \le 10^6$
\end{itemize}}
\BREAKDOWN{We must count length-\texttt{steps} sequences over moves \{-1, 0, +1\} that never leave the array bounds $[0,\texttt{arrLen}-1]$ and end at index 0. This is a classic dynamic programming over time and position with a tight bound on positions that can matter.}
\ELI{Count all left/right/stay sequences that never step outside and end back at zero; use DP to add ways from neighbors.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers: \texttt{steps} and \texttt{arrLen}. Valid ranges: $1 \le \texttt{steps} \le 500$, $1 \le \texttt{arrLen} \le 10^6$.}
\OUTPUTS{An integer: the number of valid sequences modulo $10^9+7$.}
\SAMPLES{Example 1: \texttt{steps = 3, arrLen = 2} $\to$ \texttt{4}. Example 2: \texttt{steps = 2, arrLen = 4} $\to$ \texttt{2}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $M = 10^9+7$. Define $dp_t(i)$ as the number of ways to be at position $i$ after exactly $t$ steps while staying within $[0,\texttt{arrLen}-1]$. We seek $dp_{\texttt{steps}}(0) \bmod M$.}
\varmapStart
\var{t}{time step index, $0 \le t \le \texttt{steps}$}
\var{i}{position index, $0 \le i \le \texttt{arrLen}-1$}
\var{M}{modulus $10^9+7$}
\var{W}{effective width bound $W = \min(\texttt{arrLen}-1,\ \texttt{steps})$ or tighter $W' = \min(\texttt{arrLen}-1,\ \lfloor \texttt{steps}/2 \rfloor + 1)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
dp_0(0) &= 1,\quad dp_0(i) = 0\ \text{for } i \ne 0,\\
dp_{t+1}(i) &=
\begin{cases}
\big(dp_t(i) + dp_t(i-1) + dp_t(i+1)\big) \bmod M, & 0 < i < \texttt{arrLen}-1,\\
\big(dp_t(0) + dp_t(1)\big) \bmod M, & i = 0,\\
\big(dp_t(\texttt{arrLen}-1) + dp_t(\texttt{arrLen}-2)\big) \bmod M, & i = \texttt{arrLen}-1.
\end{cases}
\end{aligned}
\]
To reduce computation, restrict $i$ to $0 \le i \le W'$ since the walk cannot drift farther than $\lfloor t/2 \rfloor$ from 0 and still return by time $t$.
}
\ASSUMPTIONS{Zero-based indexing. Moves are in $\{-1,0,+1\}$ and must stay within bounds at every step. Modulo arithmetic is used. We clamp the state space to a provably sufficient width bound.}
\INVARIANTS{Non-negativity: $dp_t(i) \ge 0$ for all $t,i$. Conservation under transitions: total ways at step $t+1$ equals the sum of contributions from step $t$ across allowed moves. Boundary safety: contributions beyond $[0,\texttt{arrLen}-1]$ are treated as zero.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct enumeration of all length-\texttt{steps} sequences of moves in $\{-1,0,+1\}$, pruning any path that steps out of bounds; count those ending at 0.}
\ASSUMPTIONS{Feasible only for tiny \texttt{steps} (e.g., $\le 12$) due to $3^{\texttt{steps}}$ branching.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Depth-first search from $(t=0, pos=0)$.
\item At each node, try moves $\{-1,0,+1\}$ if the resulting position stays within $[0,\texttt{arrLen}-1]$.
\item When $t=\texttt{steps}$, add 1 if $pos=0$.
\end{algosteps}
\COMPLEXITY{Exponential in steps; worst-case $T(n) = 3^{\texttt{steps}}$ with small pruning, $S(n) = O(\texttt{steps})$ recursion depth.}
\[
\begin{aligned}
T(\texttt{steps}) &\approx 3^{\texttt{steps}} \\
S(\texttt{steps}) &= O(\texttt{steps})
\end{aligned}
\]
\CORRECTNESS{By construction, explores every legal sequence exactly once and counts those that end at 0.}
\EDGECASES{Small arrays, e.g., \texttt{arrLen}=1 where only stay is allowed; steps odd vs. even; immediate out-of-bounds moves are pruned.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline brute force (only for very small steps due to 3^steps growth)
# LeetCode API: class Solution with numWays(self, steps: int, arrLen: int) -> int
class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        MOD = 10**9 + 7
        # Brute force: exponential; keep only for tiny inputs.
        # For general inputs, this would time out; used here for validation on small cases.
        if steps > 12:  # guard to avoid explosion in this baseline
            return self._fallback_dp(steps, arrLen)
        count = 0

        def dfs(t: int, pos: int) -> None:
            nonlocal count
            if t == steps:
                if pos == 0:
                    count += 1
                return
            # Try left, stay, right
            for d in (-1, 0, 1):
                np = pos + d
                if 0 <= np < arrLen:
                    dfs(t + 1, np)

        dfs(0, 0)
        return count % MOD

    # Simple DP fallback to ensure method is defined for general inputs
    def _fallback_dp(self, steps: int, arrLen: int) -> int:
        MOD = 10**9 + 7
        max_pos = min(arrLen - 1, steps)
        dp = [0] * (max_pos + 1)
        dp[0] = 1
        for _ in range(steps):
            ndp = [0] * (max_pos + 1)
            for i in range(max_pos + 1):
                v = dp[i]
                ndp[i] = (ndp[i] + v) % MOD
                if i - 1 >= 0:
                    ndp[i - 1] = (ndp[i - 1] + v) % MOD
                if i + 1 <= max_pos:
                    ndp[i + 1] = (ndp[i + 1] + v) % MOD
            dp = ndp
        return dp[0]

# Tiny validations for the baseline
s = Solution()
assert s.numWays(3, 2) == 4
assert s.numWays(2, 4) == 2
assert s.numWays(4, 2) == 8
\end{minted}
\VALIDATION{Checked examples. Also check \texttt{arrLen=1}: only stay moves are valid, so the answer is 1 if and only if \texttt{steps} can be any integer; paths are 1 way per step sequence, hence exactly 1.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Dynamic programming with position width bounded by $\min(\texttt{arrLen}-1,\ \texttt{steps})$. Use 1D rolling arrays: $ndp[i] = (dp[i] + dp[i-1] + dp[i+1]) \bmod M$.}
\ASSUMPTIONS{Only positions within the effective width can be reached and still return to 0 within the allotted steps.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $W = \min(\texttt{arrLen}-1,\ \texttt{steps})$; allocate arrays of size $W+1$.
\item Initialize $dp[0]=1$, others 0.
\item For each time step, compute $ndp[i]$ from neighbors within bounds; replace $dp \leftarrow ndp$.
\end{algosteps}
\COMPLEXITY{Each step updates $W+1$ states; $T = O(\texttt{steps} \cdot \min(\texttt{arrLen}, \texttt{steps}))$, $S = O(\min(\texttt{arrLen}, \texttt{steps}))$.}
\[
\begin{aligned}
T(\texttt{steps}, \texttt{arrLen}) &= \Theta\big(\texttt{steps} \cdot \min(\texttt{arrLen}, \texttt{steps})\big) \\
S(\texttt{steps}, \texttt{arrLen}) &= \Theta\big(\min(\texttt{arrLen}, \texttt{steps})\big)
\end{aligned}
\]
\CORRECTNESS{By the DP recurrence, $dp_t(i)$ aggregates exactly all ways to arrive at $i$ from legal previous positions. The width bound excludes unreachable positions without affecting $dp_{\texttt{steps}}(0)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Iterative DP with width bound min(arrLen-1, steps)
class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        MOD = 10**9 + 7
        width = min(arrLen - 1, steps)
        dp = [0] * (width + 1)
        dp[0] = 1
        for _ in range(steps):
            ndp = [0] * (width + 1)
            for i in range(width + 1):
                # stay
                ndp[i] = (ndp[i] + dp[i]) % MOD
                # left
                if i - 1 >= 0:
                    ndp[i - 1] = (ndp[i - 1] + dp[i]) % MOD
                # right
                if i + 1 <= width:
                    ndp[i + 1] = (ndp[i + 1] + dp[i]) % MOD
            dp = ndp
        return dp[0]

# Checks on edge and sample inputs
s = Solution()
assert s.numWays(3, 2) == 4
assert s.numWays(2, 4) == 2
assert s.numWays(1, 1) == 1  # only stay
\end{minted}
\VALIDATION{Validated on samples and trivial boundary \texttt{arrLen=1}. For small \texttt{steps} (e.g., $\le 10$), cross-check against brute force.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{DP with both width and per-step reachable-range pruning: at time $t$, positions $i > \min(W', t)$ have zero ways, where $W'=\min(\texttt{arrLen}-1,\ \lfloor \texttt{steps}/2 \rfloor + 1)$. Transition: $ndp[i] = (dp[i] + [i>0]dp[i-1] + [i<\text{prev\_max}]dp[i+1]) \bmod M$.}
\ASSUMPTIONS{A path ending at 0 after $t$ steps cannot exceed distance $\lfloor t/2 \rfloor$ from 0, yielding a tighter cap than $\texttt{steps}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $W' = \min(\texttt{arrLen}-1,\ \lfloor \texttt{steps}/2 \rfloor + 1)$; allocate arrays of size $W'+1$.
\item Initialize $dp[0]=1$, others 0.
\item For $t=1$ to \texttt{steps}, limit updates to $i \in [0, \min(W', t)]$ and read neighbors only up to $\min(W', t-1)$.
\item Return $dp[0]$ after the final step.
\end{algosteps}
\OPTIMALITY{Time $O(\texttt{steps} \cdot \min(\texttt{arrLen}, \texttt{steps}))$ with a smaller constant by trimming per-step loops to the reachable frontier; space $O(\min(\texttt{arrLen}, \texttt{steps}))$. This matches known lower bounds for enumerating all nonzero states.}
\COMPLEXITY{As above; in practice tighter than Approach B due to frontier limiting.}
\[
\begin{aligned}
T &\in \Theta\!\left(\sum_{t=1}^{\texttt{steps}} \min(W', t)\right) = \Theta\big(\texttt{steps} \cdot \min(\texttt{arrLen}, \texttt{steps})\big),\\
S &= \Theta(W') = \Theta(\min(\texttt{arrLen}, \texttt{steps})).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final LC-ready solution with frontier-limited DP
class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        MOD = 10**9 + 7
        width = min(arrLen - 1, steps // 2 + 1)
        dp = [0] * (width + 1)
        dp[0] = 1
        for t in range(1, steps + 1):
            ndp = [0] * (width + 1)
            max_i = min(width, t)
            prev_max = min(width, t - 1)
            for i in range(0, max_i + 1):
                s = dp[i]  # stay
                if i - 1 >= 0:
                    s += dp[i - 1]
                if i + 1 <= prev_max:
                    s += dp[i + 1]
                ndp[i] = s % MOD
            dp = ndp
        return dp[0]

# Exactly 3 asserts (as requested) on the problem's examples
s = Solution()
assert s.numWays(3, 2) == 4
assert s.numWays(2, 4) == 2
assert s.numWays(4, 2) == 8
\end{minted}
\VALIDATION{Three sample asserts pass. Additional randomized cross-checking against a brute-force for tiny steps further increases confidence.}
\RESULT{Return the count of valid sequences modulo $10^9+7$. If multiple sequences exist, all are counted; no tie-breaking is needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test samples, trivial boundaries (\texttt{arrLen}=1), parity-driven checks (odd steps can still stay via stays), and randomized small cases comparing brute force vs. DP.}
\LINE{CROSS-CHECKS}{For $\texttt{steps} \le 10$ and modest \texttt{arrLen}, compare brute force counts with Approach C results.}
\LINE{EDGE-CASE GENERATOR}{Generate random pairs $(\texttt{steps}, \texttt{arrLen})$ with small ranges and ensure DP matches brute force; include extremes like \texttt{arrLen}=1 and \texttt{arrLen} $\gg$ \texttt{steps}.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple

def brute_num_ways(steps: int, arrLen: int) -> int:
    MOD = 10**9 + 7
    count = 0
    def dfs(t: int, pos: int) -> None:
        nonlocal count
        if t == steps:
            if pos == 0:
                count += 1
            return
        for d in (-1, 0, 1):
            np = pos + d
            if 0 <= np < arrLen:
                dfs(t + 1, np)
    dfs(0, 0)
    return count % MOD

def random_tests() -> List[Tuple[int, int]]:
    cases = []
    # boundaries
    for steps in range(0, 6):
        for arrLen in range(1, 6):
            cases.append((steps, arrLen))
    # adversarial: very tall arrLen vs small steps
    for steps in [7, 8, 9, 10]:
        cases.append((steps, 100))
    return cases

# Cross-check brute vs. DP for small steps
class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        MOD = 10**9 + 7
        width = min(arrLen - 1, steps // 2 + 1)
        dp = [0] * (width + 1)
        dp[0] = 1
        for t in range(1, steps + 1):
            ndp = [0] * (width + 1)
            max_i = min(width, t)
            prev_max = min(width, t - 1)
            for i in range(0, max_i + 1):
                s = dp[i]
                if i - 1 >= 0:
                    s += dp[i - 1]
                if i + 1 <= prev_max:
                    s += dp[i + 1]
                ndp[i] = s % MOD
            dp = ndp
        return dp[0]

s = Solution()
for steps, arrLen in random_tests():
    if steps <= 10 and arrLen <= 8:
        assert s.numWays(steps, arrLen) == brute_num_ways(steps, arrLen)
# spot checks
assert s.numWays(3, 2) == 4
assert s.numWays(2, 4) == 2
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference implementation for LeetCode
class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        MOD = 10**9 + 7
        # Effective width: cannot stray more than floor(steps/2) and cannot exceed array bounds
        width = min(arrLen - 1, steps // 2 + 1)
        dp = [0] * (width + 1)
        dp[0] = 1
        for t in range(1, steps + 1):
            ndp = [0] * (width + 1)
            max_i = min(width, t)
            prev_max = min(width, t - 1)
            for i in range(0, max_i + 1):
                total = dp[i]
                if i - 1 >= 0:
                    total += dp[i - 1]
                if i + 1 <= prev_max:
                    total += dp[i + 1]
                ndp[i] = total % MOD
            dp = ndp
        return dp[0]

# Self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.numWays(3, 2) == 4
    assert s.numWays(2, 4) == 2
    assert s.numWays(4, 2) == 8
    # Additional quick checks
    assert s.numWays(1, 1) == 1
    assert s.numWays(0, 100) == 1  # zero steps, at origin
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{DP over time and bounded position with transition $ndp[i] = dp[i] + dp[i-1] + dp[i+1] \bmod 10^9+7$.}
\WHY{Common DP pattern: counting constrained walks on a line with boundaries and modulo arithmetic.}
\CHECKLIST{At reading time: confirm modulo, ensure boundary handling, choose tight width bound, use rolling arrays, restrict per-step frontier, return $dp[0]$.}
\EDGECASES{arrLen $=1$; steps $=0$; very large \texttt{arrLen} vs. small \texttt{steps}; odd vs. even \texttt{steps}; ensure no access at $i+1$ when beyond previous frontier; modulo on every addition.}
\PITFALLS{Forgetting per-step frontier $\min(W', t)$; using full \texttt{arrLen} and TLE; off-by-one at boundaries; missing modulo; using width $=\texttt{steps}$ but indexing past allocated size; incorrect base case $dp[0]=1$.}
\FAILMODES{Brute force fails for \texttt{steps} around 20+. Naive 2D DP with full \texttt{arrLen} fails when \texttt{arrLen} is big. Frontier-limited 1D DP remains efficient.}
\ELI{You can only go left, right, or stay. Keep track of how many ways to be at each spot after each step, but you only need to track spots near zero because you cannot wander far and still come back in time. Add up from neighbors and take modulo.}
\NotePages{3}

\end{document}