% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — A/B Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1360/G}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{You are given four positive integers $n$, $m$, $a$, $b$ ($1 \le b \le n \le 50$; $1 \le a \le m \le 50$). Find any such rectangular matrix of size $n \times m$ that satisfies all of the following conditions:
\begin{bullets}
\item each row of the matrix contains exactly $a$ ones;
\item each column of the matrix contains exactly $b$ ones;
\item all other elements are zeros.
\end{bullets}
If the desired matrix does not exist, indicate this.

For example, for $n=3$, $m=6$, $a=2$, $b=1$, there exists a matrix satisfying the conditions above:
\[
\begin{bmatrix}
0 & 1 & 0 & 0 & 0 & 1 \\
1 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 & 1 & 0
\end{bmatrix}
\]

Input: The first line contains an integer $t$ ($1 \le t \le 1000$) — the number of test cases. Then $t$ test cases follow.

Each test case is described by four positive integers $n$, $m$, $a$, $b$ ($1 \le b \le n \le 50$; $1 \le a \le m \le 50$), where $n$ and $m$ are the sizes of the matrix, and $a$ and $b$ are the number of ones for rows and columns, respectively.

Output: For each test case print:
\begin{bullets}
\item ``YES'' and the required matrix (if there are several answers, print any) if it exists, or
\item ``NO'' if it does not exist.
\end{bullets}
To print the matrix $n \times m$, print $n$ rows, each of which consists of $m$ numbers $0$ or $1$ describing a row of the matrix. Numbers must be printed without spaces.}
\BREAKDOWN{Check feasibility, then construct a $0/1$ matrix with row sum $a$ and column sum $b$. A circulant shift construction works when $n a = m b$.}
\ELI{The total number of ones must match both by rows and by columns; then slide an $a$-long window around the $m$ columns as you go down the rows.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case: integers $n$, $m$, $a$, $b$ with $1 \le b \le n \le 50$ and $1 \le a \le m \le 50$.}
\OUTPUTS{For each test case, print either:
\begin{bullets}
\item YES on one line and then $n$ lines, each a length-$m$ string of 0/1 without spaces, such that every row has exactly $a$ ones and every column has exactly $b$ ones; or
\item NO if such a matrix does not exist.
\end{bullets}}
\SAMPLES{Example 1:
\begin{bullets}
\item Input:
\[
\begin{aligned}
1\\
3~6~2~1
\end{aligned}
\]
\item Output:
\begin{BreakableEquation*}
\text{YES}\quad\text{(then one valid matrix, e.g.)}
\end{BreakableEquation*}
\[
010001\\
100100\\
001010
\]
\end{bullets}
Example 2:
\begin{bullets}
\item Input:
\[
\begin{aligned}
1\\
2~2~2~1
\end{aligned}
\]
\item Output:
\begin{BreakableEquation*}
\text{NO}
\end{BreakableEquation*}
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Construct a binary matrix $X \in \{0,1\}^{n \times m}$ with prescribed row sums and column sums:
\[
\sum_{j=1}^{m} X_{i,j} = a\quad\forall i \in [n],\qquad
\sum_{i=1}^{n} X_{i,j} = b\quad\forall j \in [m].
\]
A necessary condition is $n a = m b$.}
\varmapStart
\var{n}{number of rows}
\var{m}{number of columns}
\var{a}{ones per row}
\var{b}{ones per column}
\var{X_{i,j}}{entry in row $i$, column $j$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&X_{i,j} \in \{0,1\},\\
&\sum_{j=1}^m X_{i,j} = a\ \ (\forall i),\quad \sum_{i=1}^n X_{i,j} = b\ \ (\forall j),\\
&\text{Feasibility: } n a = \sum_{i=1}^n \sum_{j=1}^m X_{i,j} = \sum_{j=1}^m \sum_{i=1}^n X_{i,j} = m b.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are 0-based or 1-based consistently; we use 0-based in constructions. Feasibility requires and, for this problem, is equivalent to $n a = m b$.}
\INVARIANTS{
\begin{bullets}
\item Total ones equals $n a$ at all times in a construction that sets exactly $a$ ones per row.
\item Column counts sum to $n a$; checking each equals $b$ proves correctness.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Feasibility check $n a = m b$, then greedily fill each row by placing ones in the columns currently having the smallest counts.}
\ASSUMPTIONS{Greedy balancing may succeed on many cases but is not guaranteed to be simplest to reason about; we verify at the end.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n a \ne m b$, print NO.
\item Maintain an array of column counts, initially zeros.
\item For each row, choose $a$ columns with smallest current counts (break ties by index), set them to 1; update counts.
\item After all rows, verify every column count equals $b$. If yes, print YES and the matrix; else print NO.
\end{algosteps}
\COMPLEXITY{Sorting columns per row costs $O(m \log m)$; over $n$ rows the time is $O(n m \log m)$; space is $O(n m)$ for the matrix plus $O(m)$ for counts.}
\[
\begin{aligned}
T(n,m) &= n \cdot O(m \log m) = O(n m \log m),\\
S(n,m) &= O(n m).
\end{aligned}
\]
\CORRECTNESS{If it outputs a matrix and verification passes, it satisfies the row and column constraints by construction.}
\EDGECASES{Reject when $n a \ne m b$. Handle $a=0$ or $b=0$ (not present here since $a,b \ge 1$ by constraints).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); a = int(next(it)); b = int(next(it))
        cases.append((n, m, a, b))
    return t, cases

def greedy_construct(n, m, a, b):
    if n * a != m * b:
        return None
    col = [0] * m
    mat = [[0] * m for _ in range(n)]
    for i in range(n):
        order = list(range(m))
        order.sort(key=lambda j: (col[j], j))
        pick = order[:a]
        for j in pick:
            mat[i][j] = 1
            col[j] += 1
    if all(c == b for c in col):
        return ["".join("1" if x else "0" for x in row) for row in mat]
    return None

def solve_case(n, m, a, b):
    mat = greedy_construct(n, m, a, b)
    if mat is None:
        return ["NO"]
    out = ["YES"]
    out.extend(mat)
    return out

def solve_all(data: str) -> str:
    t, cases = read_input(data)
    out_lines = []
    for (n, m, a, b) in cases:
        out_lines.extend(solve_case(n, m, a, b))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    # Basic asserts for baseline (may print NO in some valid cases due to greedy; that's acceptable here)
    t1 = "1\n3 6 2 1\n"
    res1 = solve_all(t1).splitlines()
    assert res1[0] in ("YES", "NO")
    t2 = "1\n2 2 2 1\n"
    assert solve_all(t2).strip() == "NO"
    # Feasible small case should be YES (greedy typically succeeds here)
    t3 = "1\n4 6 3 2\n"
    assert solve_all(t3).splitlines()[0] == "YES"
    # Uncomment to run interactively:
    # main()
    pass
\end{minted}
\VALIDATION{Quick checks include: infeasible pairs yield NO; small feasible pairs typically produce YES with correct counts (manually verified).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Cyclic Shift Construction}
\WHICHFORMULA{When $n a = m b$, set the $i$-th row to have ones in $a$ consecutive columns starting at offset $(i \cdot a) \bmod m$.}
\ASSUMPTIONS{Uses modular arithmetic on columns; $a$ consecutive positions are wrapped around modulo $m$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n a \ne m b$, output NO.
\item For each row $i = 0,\ldots,n-1$, compute $s_i = (i \cdot a) \bmod m$.
\item Set row $i$ to have ones at columns $s_i, s_i+1, \ldots, s_i + (a-1)$ modulo $m$, zeros elsewhere.
\item Output YES and the constructed matrix.
\end{algosteps}
\COMPLEXITY{We fill $n a$ ones in $O(n a)$ time plus output; space $O(n m)$. It strictly improves constants over the baseline greedy and is linear in matrix size.}
\[
\begin{aligned}
T(n,m) &= O(n a) = O(n m)\ \text{in worst case},\\
S(n,m) &= O(n m).
\end{aligned}
\]
\CORRECTNESS{Total ones is $n a = m b$. The starting offsets advance by $a$ each row; this circulant pattern distributes ones uniformly across columns so that each column appears exactly $b$ times.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); a = int(next(it)); b = int(next(it))
        cases.append((n, m, a, b))
    return t, cases

def construct_circulant(n, m, a, b):
    if n * a != m * b:
        return None
    mat = [["0"] * m for _ in range(n)]
    for i in range(n):
        s = (i * a) % m
        for k in range(a):
            j = (s + k) % m
            mat[i][j] = "1"
    rows = ["".join(row) for row in mat]
    # Verify column counts
    cols = [0] * m
    for r in rows:
        for j, ch in enumerate(r):
            if ch == "1":
                cols[j] += 1
    assert all(c == b for c in cols), (cols, b)
    return rows

def solve_case(n, m, a, b):
    mat = construct_circulant(n, m, a, b)
    if mat is None:
        return ["NO"]
    out = ["YES"]
    out.extend(mat)
    return out

def solve_all(data: str) -> str:
    t, cases = read_input(data)
    out_lines = []
    for (n, m, a, b) in cases:
        out_lines.extend(solve_case(n, m, a, b))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    # Feasibility check
    assert construct_circulant(3, 6, 2, 1) is not None
    assert construct_circulant(2, 2, 2, 1) is None
    # Another feasible example
    mat = construct_circulant(4, 6, 3, 2)
    assert mat is not None and len(mat) == 4 and all(len(r) == 6 for r in mat)
    # main()  # disabled in asserts block
    pass
\end{minted}
\VALIDATION{Checked on $(n,m,a,b)=(3,6,2,1)$ and $(4,6,3,2)$. Infeasible $(2,2,2,1)$ correctly returns NO.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Circulant Construction}
\WHICHFORMULA{Use the circulant pattern: row $i$ has ones at columns $\{(i \cdot a + k) \bmod m : 0 \le k < a\}$.}
\ASSUMPTIONS{Feasible iff $n a = m b$. This construction works for all such feasible inputs; no further structure needed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n a \ne m b$, print NO.
\item Otherwise, for each $i=0,\ldots,n-1$ and $k=0,\ldots,a-1$, set $X_{i,(i a + k) \bmod m} \gets 1$.
\item Print YES and the matrix.
\end{algosteps}
\OPTIMALITY{This is $O(n m)$ in the worst case and $O(n a)$ in general, which is optimal up to constants because the output itself has size $n m$.}
\COMPLEXITY{Linear-time fill of $n a$ ones; verification is optional for submissions but included in tests.}
\[
\begin{aligned}
T(n,m) &= O(n a) \le O(n m),\\
S(n,m) &= O(n m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); a = int(next(it)); b = int(next(it))
        cases.append((n, m, a, b))
    return t, cases

def construct_matrix(n, m, a, b):
    if n * a != m * b:
        return None
    mat = [["0"] * m for _ in range(n)]
    for i in range(n):
        s = (i * a) % m
        for k in range(a):
            mat[i][(s + k) % m] = "1"
    rows = ["".join(row) for row in mat]
    # Optional safety check in local runs
    cols = [0] * m
    for r in rows:
        for j, ch in enumerate(r):
            if ch == "1":
                cols[j] += 1
    assert all(c == b for c in cols), (cols, b)
    return rows

def solve_case(n, m, a, b):
    mat = construct_matrix(n, m, a, b)
    if mat is None:
        return ["NO"]
    return ["YES", *mat]

def solve_all():
    t, cases = read_input()
    out_lines = []
    for (n, m, a, b) in cases:
        out_lines.extend(solve_case(n, m, a, b))
    sys.stdout.write("\n".join(out_lines))

def _test_local():
    # Exactly 3 asserts
    assert construct_matrix(3, 6, 2, 1) is not None
    assert construct_matrix(2, 2, 2, 1) is None
    mat = construct_matrix(4, 6, 3, 2)
    assert mat is not None and len(mat) == 4 and all(len(r) == 6 for r in mat)

if __name__ == "__main__":
    # _test_local()  # keep disabled on CF; uncomment for local testing
    solve_all()
\end{minted}
\VALIDATION{Asserts cover a feasible small case, an infeasible case, and shape validation for another feasible case.}
\RESULT{Outputs ``YES'' and any valid matrix for feasible inputs; otherwise ``NO''. Ties among many valid matrices are broken arbitrarily by the fixed circulant rule.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test feasibility, column-sum correctness, and shape on random feasible triples with small $n,m$. Cross-validate greedy vs. circulant.}
\LINE{CROSS-CHECKS}{For small sizes, compare matrices returned by baseline and final construction; validate both meet column counts.}
\LINE{EDGE-CASE GENERATOR}{Generate $n,m \in [1,8]$, $a \in [1,m]$, set $b = \tfrac{n a}{m}$ when integral; otherwise skip. This covers divisibility edges and small gcd patterns.}
\begin{minted}{python}
import random

def gen_feasible_cases(limit_n=8, limit_m=8, trials=50, seed=0):
    rng = random.Random(seed)
    cases = []
    for _ in range(trials):
        n = rng.randint(1, limit_n)
        m = rng.randint(1, limit_m)
        a = rng.randint(1, m)
        total = n * a
        if total % m != 0:
            continue
        b = total // m
        if 1 <= b <= n:
            cases.append((n, m, a, b))
    return cases

# Reference Code (Ready to Submit) follows:
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); a = int(next(it)); b = int(next(it))
        cases.append((n, m, a, b))
    return t, cases

def construct_matrix(n, m, a, b):
    if n * a != m * b:
        return None
    mat = [["0"] * m for _ in range(n)]
    for i in range(n):
        s = (i * a) % m
        for k in range(a):
            mat[i][(s + k) % m] = "1"
    return ["".join(row) for row in mat]

def solve_case(n, m, a, b):
    mat = construct_matrix(n, m, a, b)
    if mat is None:
        return ["NO"]
    return ["YES", *mat]

def solve_all():
    t, cases = read_input()
    out_lines = []
    for (n, m, a, b) in cases:
        out_lines.extend(solve_case(n, m, a, b))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Simple asserts
    assert construct_matrix(3, 6, 2, 1) is not None
    assert construct_matrix(2, 2, 2, 1) is None
    assert construct_matrix(4, 6, 3, 2) is not None
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Construct a binary $n \times m$ matrix with row sum $a$ and column sum $b$ by a circulant shift if and only if $n a = m b$.}
\WHY{Balanced degree bipartite constructions and incidence matrices appear often in interview and contest settings; recognizing the necessary-and-sufficient divisibility is key.}
\CHECKLIST{
\begin{bullets}
\item Compute and check $n a$ and $m b$.
\item If not equal, print NO.
\item Else, implement circulant construction: start offset $(i a) \bmod m$ per row.
\item Verify column counts locally if unsure.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n a \ne m b$ must be NO.
\item $a=1$ or $b=1$.
\item $a=m$ or $b=n$ (all-ones rows or columns).
\item $m=1$ or $n=1$.
\item Large $t$ with many small cases.
\item Non-trivial $\gcd(m,a)$ (short cycles of offsets).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to wrap indices modulo $m$ for the $a$ consecutive ones.
\item Off-by-one in placing $a$ ones (placing $a+1$ or $a-1$).
\item Printing spaces between digits (the problem forbids spaces).
\item Mixing 1-based vs. 0-based indices in modular arithmetic.
\item Not flushing output across multiple test cases (concatenation mistakes).
\item Accidentally using random tie-breaking in greedy without determinism.
\end{bullets}}
\FAILMODES{Greedy approaches can get stuck or need verification; the circulant construction avoids backtracking and always works when feasible.}
\ELI{Make sure the total number of ones matches both by rows and by columns. Then, on each new row, slide a window of $a$ ones to the right by $a$ columns (wrapping around). This evenly spreads ones so each column gets exactly $b$.}
\NotePages{3}

\end{document}