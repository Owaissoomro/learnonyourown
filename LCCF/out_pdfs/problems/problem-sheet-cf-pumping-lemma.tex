% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Pumping Lemma}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1909/G}}
\LINE{DIFFICULTY / RATING}{3000}
\STATEMENT{You are given two strings $s$, $t$ of length $n$, $m$, respectively. Both strings consist of lowercase letters of the English alphabet.

Count the triples $(x, y, z)$ of strings such that the following conditions are true:
\begin{bullets}
\item $s = x+y+z$ (the symbol $+$ represents the concatenation);
\item $t = x+\underbrace{ y+\dots+y }_{k \text{ times}} + z$ for some integer $k$.
\end{bullets}

\textbf{Input:}
The first line contains two integers $n$ and $m$ ($1 \le n < m \le 10^7$)~— the length of the strings $s$ and $t$, respectively.

The second line contains the string $s$ of length $n$, consisting of lowercase letters of the English alphabet.

The third line contains the string $t$ of length $m$, consisting of lowercase letters of the English alphabet.

\textbf{Output:}
Output a single integer: the number of valid triples $(x, y, z)$.

\textbf{Note:}
In the first test case, the only valid triple is $(x, y, z) = (\texttt{"a"}, \texttt{"bc"}, \texttt{"d"})$. In fact,
\begin{bullets}
\item $\texttt{"abcd"} = \texttt{"a"} + \texttt{"bc"} + \texttt{"d"}$;
\item $\texttt{"abcbcbcd"} = \texttt{"a"} + \texttt{"bc"} + \texttt{"bc"} + \texttt{"bc"} + \texttt{"d"}$.
\end{bullets}

In the second test case, there are $5$ valid triples:
\begin{bullets}
\item $(x, y, z) = (\texttt{""}, \texttt{"a"}, \texttt{"aa"})$;
\item $(x, y, z) = (\texttt{""}, \texttt{"aa"}, \texttt{"a"})$;
\item $(x, y, z) = (\texttt{"a"}, \texttt{"a"}, \texttt{"a"})$;
\item $(x, y, z) = (\texttt{"a"}, \texttt{"aa"}, \texttt{""})$;
\item $(x, y, z) = (\texttt{"aa"}, \texttt{"a"}, \texttt{""})$.
\end{bullets}

In the third test case, there are $8$ valid triples:
\begin{bullets}
\item $(x, y, z) = (\texttt{"ab"}, \texttt{"ba"}, \texttt{"babacaab"})$;
\item $(x, y, z) = (\texttt{"abb"}, \texttt{"ab"}, \texttt{"abacaab"})$;
\item $(x, y, z) = (\texttt{"abba"}, \texttt{"ba"}, \texttt{"bacaab"})$;
\item $(x, y, z) = (\texttt{"ab"}, \texttt{"baba"}, \texttt{"bacaab"})$;
\item $(x, y, z) = (\texttt{"abbab"}, \texttt{"ab"}, \texttt{"acaab"})$;
\item $(x, y, z) = (\texttt{"abb"}, \texttt{"abab"}, \texttt{"acaab"})$;
\item $(x, y, z) = (\texttt{"abbaba"}, \texttt{"ba"}, \texttt{"caab"})$;
\item $(x, y, z) = (\texttt{"abba"}, \texttt{"baba"}, \texttt{"caab"})$.
\end{bullets}}
\BREAKDOWN{Let $D=m-n>0$. If $s=x+y+z$ and $t=x+y^{k}+z$ with $k\ge 2$, then $m=n+(k-1)\lvert y\rvert$, so $\lvert y\rvert$ must divide $D$. For each split position $i=\lvert x\rvert$ and length $j=\lvert y\rvert$ dividing $D$ with $i+j\le n$, check that the prefix $x$ matches, the suffix $z$ matches when aligned, and the middle of $t$ is $y$ repeated $k=1+D/j$ times.}
\ELI{You can get $t$ from $s$ by picking a middle chunk $y$ of $s$ and duplicating it several extra times; count all places and lengths where that works.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n,m$ with $1\le n<m\le 10^7$; a string $s$ of length $n$; a string $t$ of length $m$.}
\OUTPUTS{A single integer: the number of triples $(x,y,z)$ such that $s=x+y+z$ and $t=x+y^k+z$ for some integer $k\ge 2$.}
\SAMPLES{Example 1:
\[
\begin{aligned}
n,m&=4,8\\
s&=\texttt{abcd}\\
t&=\texttt{abcbcbcd}\\
\text{answer}&=1
\end{aligned}
\]
Example 2:
\[
\begin{aligned}
n,m&=3,5\\
s&=\texttt{aaa}\\
t&=\texttt{aaaaa}\\
\text{answer}&=5
\end{aligned}
\]}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma=\{a,\ldots,z\}$. Given $s\in\Sigma^n$, $t\in\Sigma^m$ ($m>n$), count pairs $(i,j)$ with $i\in[0,n]$, $j\in[1,n-i]$ and an integer $k\ge 2$ such that
\begin{BreakableEquation*}
t = s[0:i]\;\cdot\;\bigl(s[i:i+j]\bigr)^{k}\;\cdot\;s[i+j:n].
\end{BreakableEquation*}
By length, $m=n+(k-1)j$. Thus $j\mid (m-n)$ and $k=1+\tfrac{m-n}{j}$.}
\varmapStart
\var{s,t}{input strings}
\var{n,m}{lengths of $s$ and $t$}
\var{D}{length gap $D=m-n>0$}
\var{i}{prefix length $\lvert x\rvert$}
\var{j}{middle block length $\lvert y\rvert$}
\var{k}{repetition count $k=1+D/j\ge 2$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&j \mid D,\quad 0\le i\le n-j,\quad k=1+\dfrac{D}{j},\\
&s[0:i]=t[0:i],\\
&t[i:i+k j]=\bigl(s[i:i+j]\bigr)^{k},\\
&t[i+k j:m]=s[i+j:n].
\end{aligned}
\]
}
\ASSUMPTIONS{Strings are 0-indexed. $y$ must be non-empty ($j\ge 1$). $k\ge 2$ follows from $m>n$.}
\INVARIANTS{
\begin{bullets}
\item Length invariant: $m=n+(k-1)j$.
\item Prefix-suffix alignment: the suffix $z$ in $s$ and $t$ starts at indices $i+j$ in $s$ and $i+k j$ in $t$.
\item Middle periodicity: the middle block of $t$ has period $j$ and equals the first copy $s[i:i+j]$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all candidate lengths $j$ that divide $D=m-n$. For each such $j$ and each split $i$ with $0\le i\le n-j$, directly check the three conditions: matching prefix, $j$-periodic middle equal to $s[i:i+j]$, and matching suffix.}
\ASSUMPTIONS{Python slicing and repetition checks on small to mid-size inputs are acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $D=m-n$ and the set $\mathcal{J}$ of positive divisors of $D$.
\item Let $c=\text{LCP}(s,t)$, the longest common prefix length. Only $i\le c$ are viable.
\item For each $j\in\mathcal{J}$ and each $i\in[0,\min(c,n-j)]$, set $k=1+D/j$ and test:
\begin{bullets}
\item $t[i:i+k j] \stackrel{?}{=} \bigl(s[i:i+j]\bigr)^{k}$,
\item $t[i+k j:]\stackrel{?}{=} s[i+j:]$.
\end{bullets}
\item Count all successful pairs $(i,j)$.
\end{algosteps}
\COMPLEXITY{Let $\tau(D)$ be the number of divisors of $D$. In the worst case, this is $O(\sqrt{D})$. The naive substring equalities cost up to $O(m)$ per $(i,j)$ in the worst case.
\[
\begin{aligned}
T(n) &\le O\!\Bigl(\tau(D)\cdot \min(n,c)\cdot (k j + (n-i-j))\Bigr)\ \text{in worst-case slicing},\\
S(n) &= O(1)\ \text{beyond input}.
\end{aligned}
\]
}
\CORRECTNESS{The enumeration is exhaustive over all feasible $j$ by the length constraint and over all $i$ with $i+j\le n$. Each check enforces exactly the three defining equalities, hence counts precisely valid triples.}
\EDGECASES{All-$a$ strings; $D$ prime (few divisors); $i=0$ or $i=n-j$; $j=1$; highly periodic strings; immediate mismatch in prefix $c=0$ implies answer 0.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def divisors(D: int) -> List[int]:
    res = []
    i = 1
    while i * i <= D:
        if D % i == 0:
            res.append(i)
            if i * i != D:
                res.append(D // i)
        i += 1
    res.sort()
    return res

def lcp(a: str, b: str) -> int:
    L = min(len(a), len(b))
    i = 0
    while i < L and a[i] == b[i]:
        i += 1
    return i

def count_triples_bruteforce(s: str, t: str) -> int:
    n, m = len(s), len(t)
    if m <= n:
        return 0
    D = m - n
    J = divisors(D)
    c = lcp(s, t)
    total = 0
    for j in J:
        k = 1 + D // j
        max_i = min(c, n - j)
        for i in range(max_i + 1):
            b = s[i:i + j]
            # middle check
            if t[i:i + k * j] != b * k:
                continue
            # suffix check
            if t[i + k * j:] != s[i + j:]:
                continue
            total += 1
    return total

# CF-style IO
def read_input(data: str) -> Tuple[int, int, str, str]:
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    s = next(it).strip()
    t = next(it).strip()
    assert len(s) == n and len(t) == m
    return n, m, s, t

def solve_case(n: int, m: int, s: str, t: str) -> int:
    return count_triples_bruteforce(s, t)

def solve_all(data: str) -> str:
    if not data.strip():
        return ""
    n, m, s, t = read_input(data)
    return str(solve_case(n, m, s, t))

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks
        assert count_triples_bruteforce("abcd", "abcbcbcd") == 1
        assert count_triples_bruteforce("aaa", "aaaaa") == 5
        assert count_triples_bruteforce("abbababacaab", "abbabababacaab") == 8
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Quick checks:
\begin{bullets}
\item $s=\texttt{abcd}$, $t=\texttt{abcbcbcd} \Rightarrow 1$.
\item $s=\texttt{aaa}$, $t=\texttt{aaaaa} \Rightarrow 5$.
\item $s=\texttt{abbababacaab}$, $t=\texttt{abbabababacaab} \Rightarrow 8$.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Pruning via Prefix Match and Divisors}
\WHICHFORMULA{Exploit the necessary prefix match: only $i\le \text{LCP}(s,t)$ are feasible. Also use the length constraint $j\mid (m-n)$ to reduce candidates. These prune the search space aggressively before any substring checks.}
\ASSUMPTIONS{String equality checks are short-circuited by Python and often exit early on mismatch.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $D=m-n$ and its divisors $\mathcal{J}$.
\item Compute $c=\text{LCP}(s,t)$ once.
\item For each $j\in\mathcal{J}$, $k=1+D/j$, iterate $i=0.. \min(c,n-j)$:
\begin{bullets}
\item First verify the first copy equality $t[i:i+j]=s[i:i+j]$; skip fast if it fails.
\item Then verify $t[i:i+k j]=(s[i:i+j])^k$ and $t[i+k j:]=s[i+j:]$.
\end{bullets}
\item Count successes.
\end{algosteps}
\COMPLEXITY{Same worst-case as baseline, but prunes many $(i,j)$ early due to $i\le c$ and the quick first-copy check:
\begin{BreakableEquation*}
T(n)\approx O\!\Bigl(\tau(D)\cdot \min(c,n)\Bigr)\ \text{in random-like inputs};\quad S(n)=O(1).
\end{BreakableEquation*}
}
\CORRECTNESS{The pruning retains exactly the feasible region; all remaining checks are identical to the specification, preserving correctness.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

def divisors(D: int) -> List[int]:
    res = []
    i = 1
    while i * i <= D:
        if D % i == 0:
            res.append(i)
            if i * i != D:
                res.append(D // i)
        i += 1
    res.sort()
    return res

def lcp(a: str, b: str) -> int:
    L = min(len(a), len(b))
    i = 0
    while i < L and a[i] == b[i]:
        i += 1
    return i

def count_triples(s: str, t: str) -> int:
    n, m = len(s), len(t)
    if m <= n:
        return 0
    D = m - n
    J = divisors(D)
    c = lcp(s, t)
    total = 0
    for j in J:
        k = 1 + D // j
        max_i = min(c, n - j)
        for i in range(max_i + 1):
            # quick first-copy check
            if t[i:i + j] != s[i:i + j]:
                continue
            b = s[i:i + j]
            # middle periodic block
            if t[i:i + k * j] != b * k:
                continue
            # suffix equality
            if t[i + k * j:] != s[i + j:]:
                continue
            total += 1
    return total

# CF-style IO
def read_input(data: str) -> Tuple[int, int, str, str]:
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    s = next(it).strip()
    t = next(it).strip()
    assert len(s) == n and len(t) == m
    return n, m, s, t

def solve_case(n: int, m: int, s: str, t: str) -> int:
    return count_triples(s, t)

def solve_all(data: str) -> str:
    if not data.strip():
        return ""
    n, m, s, t = read_input(data)
    return str(solve_case(n, m, s, t))

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks
        assert count_triples("abcd", "abcbcbcd") == 1
        assert count_triples("aaa", "aaaaa") == 5
        assert count_triples("abbababacaab", "abbabababacaab") == 8
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge inputs:
\begin{bullets}
\item Immediate mismatch: $s=\texttt{b}$, $t=\texttt{aa}\Rightarrow 0$.
\item Prime gap $D$: fewer $j$ to try.
\item Highly periodic: $s=\texttt{aaaa}$, $t=\texttt{aaaaaa}$.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divisor Filtering + Periodicity via String Algorithms}
\WHICHFORMULA{Use $j\mid D$ and $i\le\text{LCP}(s,t)$ as before. Verify the middle periodicity and suffix equality in near $O(1)$ per candidate with string algorithms:
\begin{bullets}
\item Precompute rolling hashes (or Z/KMP) on $s$ and $t$ to compare arbitrary substrings in $O(1)$ time.
\item For periodicity, check $t[i:i+\alpha j]$ equals $\bigl(t[i:i+j]\bigr)^\alpha$ by comparing each $j$-sized block via $O(\alpha)$ hash checks or via a Z-function on $t[i:i+\alpha j]$ seeded by the first block.
\end{bullets}}
\ASSUMPTIONS{Rolling-hash collisions are negligible in practice; on CF one would use double-mod or 64-bit hashing. KMP/Z are collision-free and linear.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $D=m-n$, its divisors $\mathcal{J}$, and $c=\text{LCP}(s,t)$.
\item Precompute substring-equality oracle (rolling hash or Z/KMP scaffolding).
\item For each $j\in\mathcal{J}$ and $i\in[0,\min(c,n-j)]$ with $t[i:i+j]=s[i:i+j]$:
\begin{bullets}
\item Let $\alpha=1+D/j$ and verify periodicity of $t[i:i+\alpha j]$ with period $j$.
\item Verify $t[i+\alpha j:]=s[i+j:]$.
\end{bullets}
\item Count all successes.
\end{algosteps}
\OPTIMALITY{We reduce candidates to $O(\tau(D)\cdot \min(c,n))$. With $O(1)$ substring-oracle queries, the total becomes near-linear in $n+m$ plus candidate count, which is information-theoretically tight given the need to touch input and enumerate outputs.}
\COMPLEXITY{With Z/KMP or robust hashing:
\begin{BreakableEquation*}
T(n)=O(n+m+\tau(D)\cdot \min(c,n))\quad S(n)=O(n+m).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

def divisors(D: int) -> List[int]:
    res = []
    i = 1
    while i * i <= D:
        if D % i == 0:
            res.append(i)
            if i * i != D:
                res.append(D // i)
        i += 1
    res.sort()
    return res

def lcp(a: str, b: str) -> int:
    L = min(len(a), len(b))
    i = 0
    while i < L and a[i] == b[i]:
        i += 1
    return i

def count_triples_final(s: str, t: str) -> int:
    n, m = len(s), len(t)
    if m <= n:
        return 0
    D = m - n
    J = divisors(D)
    c = lcp(s, t)
    total = 0
    for j in J:
        alpha = 1 + D // j
        max_i = min(c, n - j)
        for i in range(max_i + 1):
            # First copy must match
            if t[i:i + j] != s[i:i + j]:
                continue
            b = s[i:i + j]
            # Periodicity of the middle
            mid = t[i:i + alpha * j]
            if mid != b * alpha:
                continue
            # Suffix equality
            if t[i + alpha * j:] != s[i + j:]:
                continue
            total += 1
    return total

# CF IO
def read_input(data: str) -> Tuple[int, int, str, str]:
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    s = next(it).strip()
    t = next(it).strip()
    assert len(s) == n and len(t) == m
    return n, m, s, t

def solve_case(n: int, m: int, s: str, t: str) -> int:
    return count_triples_final(s, t)

def solve_all(data: str) -> str:
    if not data.strip():
        return ""
    n, m, s, t = read_input(data)
    return str(solve_case(n, m, s, t))

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        # Exactly 3 asserts / mini-tests
        assert count_triples_final("abcd", "abcbcbcd") == 1
        assert count_triples_final("aaa", "aaaaa") == 5
        assert count_triples_final("abbababacaab", "abbabababacaab") == 8
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts embedded:
\begin{bullets}
\item $(\texttt{abcd},\texttt{abcbcbcd})\mapsto 1$.
\item $(\texttt{aaa},\texttt{aaaaa})\mapsto 5$.
\item $(\texttt{abbababacaab},\texttt{abbabababacaab})\mapsto 8$.
\end{bullets}}
\RESULT{Counts all $(x,y,z)$ with $y\ne\texttt{""}$ and $k\ge 2$ such that $t$ is obtained from $s$ by pumping $y$ between $x$ and $z$. Ties do not apply; we sum over all valid splits.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on crafted cases: different $D$ (prime/composite), fully periodic strings, random strings, boundary splits $i=0$, $i=n-j$, $j=1$, and mismatch prefixes ($c=0$).}
\LINE{CROSS-CHECKS}{For small strings, compare results from Baseline, Improved, and Final to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate random $s$, choose $i,j$, and $k\ge 2$ to construct $t=s[0:i]+(s[i:i+j])^k+s[i+j:]$, then verify that at least $(i,j)$ is counted.}
\begin{minted}{python}
import random
random.seed(0)

def construct_pumped(s: str, i: int, j: int, k: int) -> str:
    return s[:i] + s[i:i+j] * k + s[i+j:]

def ref_count(s: str, t: str) -> int:
    return count_triples_final(s, t)

def rand_string(n: int, alphabet="ab"):
    return "".join(random.choice(alphabet) for _ in range(n))

def generator_tests():
    # Random constructive tests
    for _ in range(50):
        n = random.randint(1, 8)
        s = rand_string(n, "ab")
        i = random.randint(0, n-1)
        j = random.randint(1, n - i)
        k = random.randint(2, 4)
        t = construct_pumped(s, i, j, k)
        # The constructed (i,j) should be counted
        c = ref_count(s, t)
        assert c >= 1
    # Cross-check baseline vs final on tiny strings
    for _ in range(30):
        n = random.randint(1, 7)
        m = random.randint(n+1, n+5)
        s = rand_string(n, "abc")
        # naive t random
        t = rand_string(m, "abc")
        a = count_triples_bruteforce(s, t)
        b = count_triples_final(s, t)
        assert a == b

if __name__ == "__main__":
    generator_tests()
    print("All tests passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

def divisors(D: int) -> List[int]:
    res = []
    i = 1
    while i * i <= D:
        if D % i == 0:
            res.append(i)
            if i * i != D:
                res.append(D // i)
        i += 1
    res.sort()
    return res

def lcp(a: str, b: str) -> int:
    L = min(len(a), len(b))
    i = 0
    while i < L and a[i] == b[i]:
        i += 1
    return i

def count_triples_final(s: str, t: str) -> int:
    n, m = len(s), len(t)
    if m <= n:
        return 0
    D = m - n
    J = divisors(D)
    c = lcp(s, t)
    total = 0
    for j in J:
        alpha = 1 + D // j
        max_i = min(c, n - j)
        for i in range(max_i + 1):
            if t[i:i + j] != s[i:i + j]:
                continue
            b = s[i:i + j]
            if t[i:i + alpha * j] != b * alpha:
                continue
            if t[i + alpha * j:] != s[i + j:]:
                continue
            total += 1
    return total

# CF IO: single test as per problem statement
def read_input(data: str) -> Tuple[int, int, str, str]:
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    s = next(it).strip()
    t = next(it).strip()
    assert len(s) == n and len(t) == m
    return n, m, s, t

def solve_case(n: int, m: int, s: str, t: str) -> int:
    return count_triples_final(s, t)

def solve_all(data: str) -> str:
    if not data.strip():
        return ""
    n, m, s, t = read_input(data)
    return str(solve_case(n, m, s, t))

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        # Unit sanity
        assert count_triples_final("abcd", "abcbcbcd") == 1
        assert count_triples_final("aaa", "aaaaa") == 5
        assert count_triples_final("abbababacaab", "abbabababacaab") == 8
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count all ways to obtain $t$ from $s$ by choosing a contiguous block $y$ in $s$ and inserting extra copies of it in place.}
\WHY{Tests divisors reasoning from length constraints, string periodicity, and careful alignment; common in hard string DP/periodicity interview problems.}
\CHECKLIST{
\begin{bullets}
\item Compute $D=m-n$; if $D\le 0$, answer is $0$.
\item Enumerate $j\mid D$.
\item Limit $i$ to $0\le i\le \min(\text{LCP}(s,t), n-j)$.
\item Check $t[i:i+j]=s[i:i+j]$.
\item Check $t[i:i+(1+D/j)j]=\bigl(s[i:i+j]\bigr)^{1+D/j}$.
\item Check $t[i+(1+D/j)j:]=s[i+j:]$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $c=\text{LCP}(s,t)=0$: only $i=0$ possible; often yields $0$.
\item $j=1$ (single-character pumping).
\item $i=0$ (empty $x$) and $i=n-j$ (empty $z$).
\item Highly periodic strings (e.g., all equal letters).
\item Prime $D$ (only $j=1$ and $j=D$ divisors).
\item First-copy mismatch $t[i]\ne s[i]$ forces reject quickly.
\item Very short $s$ with much longer $t$.
\item $y$ cannot be empty ($j\ge 1$) as $m>n$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting that $k\ge 2$; $k=1$ would give $m=n$.
\item Not enforcing $i+j\le n$ (block must be inside $s$).
\item Off-by-one when slicing middle and suffix.
\item Assuming $t$'s middle periodicity without checking first copy equality.
\item Ignoring prefix constraint $i\le \text{LCP}(s,t)$ leading to wasted checks.
\item Building massive temporary strings in tight loops for huge inputs (optimize in practice).
\item Miscounting when $y$ has smaller period; still valid, but be careful not to over-restrict.
\item Using integer division incorrectly for $k=1+D/j$ when $j\nmid D$.
\end{bullets}}
\FAILMODES{Weaker approaches that try all $j$ and all $i$ without divisor filtering or prefix pruning will time out on large cases. The optimal approach survives by reducing candidates and using $O(1)$ substring checks.}
\ELI{We stretch a chunk inside $s$ to get $t$. The length gap tells us how long that chunk could be. We try all such lengths and start positions that keep both ends matching, and count the ones where the middle of $t$ is just that chunk repeated.}
\NotePages{3}

\end{document}