% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Binary Tree Paths}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/binary-tree-paths/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given the root of a binary tree, return all root-to-leaf paths in \emph{any order}. A leaf is a node with no children.

Example 1: Input: root = [1,2,3,null,5]. Output: ["1$\to$2$\to$5","1$\to$3"].

Example 2: Input: root = [1]. Output: ["1"].

Constraints:
\begin{bullets}
\item The number of nodes in the tree is in the range [1, 100].
\item $-100 \le \text{Node.val} \le 100$.
\end{bullets}
}
\BREAKDOWN{Traverse the binary tree from the root, accumulate node values along the path, and when at a leaf, record the path as a string joined by "->". Ensure all root-to-leaf paths are captured exactly once in any order.}
\ELI{Walk from the root to every leaf and write down the sequence of values you step on, joined by arrows.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single pointer/reference \texttt{root} to the root \texttt{TreeNode} of a binary tree. Each \texttt{TreeNode} has integer \texttt{val} and possibly null \texttt{left} and \texttt{right} children. Valid node count is 1 to 100, and values are in $[-100,100]$.}
\OUTPUTS{A list of strings. Each string is the values along a root-to-leaf path, joined by "->" with no trailing arrow. Order of the list may be arbitrary.}
\SAMPLES{
Example A:
\begin{bullets}
\item Input: root = [1,2,3,null,5]
\item Output: ["1->2->5","1->3"]
\end{bullets}
Example B:
\begin{bullets}
\item Input: root = [1]
\item Output: ["1"]
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a rooted binary tree with root $r\in V$. A path is a sequence of nodes $(r=v_0,v_1,\ldots,v_k)$ where each $(v_i,v_{i+1})\in E$. A leaf is $v\in V$ with $\deg^+(v)=0$. Objective: return the multiset $\mathcal{P}=\{ \text{str}(r\rightsquigarrow \ell) : \ell \text{ is a leaf}\}$, where $\text{str}$ formats node values with "\,$\to$\,".}
\varmapStart
\var{T}{input binary tree}
\var{r}{root of $T$}
\var{\mathcal{L}}{set of leaves of $T$}
\var{\mathcal{P}}{set/list of all root-to-leaf path strings}
\var{n}{number of nodes, $1\le n\le 100$}
\var{h}{height of the tree}
\var{L}{maximum number of nodes on any root-to-leaf path ($L=h+1$)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\mathcal{P}=\left\{\,\texttt{join}\big(\langle \text{val}(v_0),\ldots,\text{val}(v_k)\rangle,\text{"->"}\big)\ \middle|\ (v_0=r,\ldots,v_k=\ell),\ \ell\in\mathcal{L}\,\right\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{The tree is finite and acyclic. Node values are integers in $[-100,100]$. The input root is non-null.}
\INVARIANTS{
\begin{bullets}
\item Every recorded path ends at a leaf by construction.
\item Each root-to-leaf path is visited exactly once in a DFS or iterative stack traversal.
\item Path strings contain node values in top-down order separated by exactly one "->".
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use a depth-first search (DFS). Pass along the path as a string; at a leaf, append the finalized string to the answer.}
\ASSUMPTIONS{Tree size is small (\texttt{n} up to 100), so naive string concatenation along recursion is acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If the current node is null, return.
\item Extend the current path string with the node's value (prepend "->" only if the path is non-empty).
\item If the node is a leaf, record the path; otherwise recurse into left and right children.
\end{algosteps}
\COMPLEXITY{Let $P$ be the number of root-to-leaf paths and $L$ the maximum path length (in nodes). Time is $O(n + \sum_{p\in \mathcal{P}} |p|)$ due to string building; with small constraints this is effectively $O(nL)$. Space is $O(h)$ recursion depth plus output size.}
\[
\begin{aligned}
T(n) &\in O\!\left(n + \sum_{p\in \mathcal{P}} |p|\right)\ \subseteq\ O(nL),\\
S(n) &\in O(h) \text{ (call stack) } + O(\text{output}).
\end{aligned}
\]
\CORRECTNESS{By induction on the tree: the base case (single node) emits that single value. The inductive step extends each partial path uniquely and visits both subtrees, ensuring coverage of and only the root-to-leaf paths.}
\EDGECASES{Single-node tree; a skewed tree; negative values; left-only or right-only chains.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import Optional, List

# LeetCode definition (provided by platform)
class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res: List[str] = []
        def dfs(node: Optional[TreeNode], path: str) -> None:
            if not node:
                return
            cur = str(node.val) if not path else path + "->" + str(node.val)
            if not node.left and not node.right:
                res.append(cur)
                return
            dfs(node.left, cur)
            dfs(node.right, cur)
        dfs(root, "")
        return res

# Helpers and tests for local validation
def build_tree_level(levels: List[Optional[int]]) -> Optional[TreeNode]:
    if not levels:
        return None
    it = iter(levels)
    root_val = next(it)
    if root_val is None:
        return None
    root = TreeNode(root_val)
    q = [root]
    for v in it:
        node = q.pop(0)
        # left
        if v is not None:
            node.left = TreeNode(v)
            q.append(node.left)
        # right
        try:
            v2 = next(it)
        except StopIteration:
            break
        if v2 is not None:
            node.right = TreeNode(v2)
            q.append(node.right)
    return root

# Asserts
root = build_tree_level([1, 2, 3, None, 5])
ans = sorted(Solution().binaryTreePaths(root))
assert ans == ["1->2->5", "1->3"]

root2 = build_tree_level([1])
ans2 = Solution().binaryTreePaths(root2)
assert ans2 == ["1"]

root3 = build_tree_level([1, -2, 3])
ans3 = sorted(Solution().binaryTreePaths(root3))
assert ans3 == ["1->-2", "1->3"]
\end{minted}
\VALIDATION{The asserts check two examples from the prompt and an extra case with a negative value.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use an explicit stack for iterative DFS to avoid recursion overhead and potential recursion limits, while still building path strings on the fly.}
\ASSUMPTIONS{Stack-based traversal mirrors recursion and is safe for the small constraints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a stack with the tuple (root, string of root value).
\item Pop a node and its path string; if it is a leaf, record the path.
\item Otherwise, push non-null children with extended path strings.
\end{algosteps}
\COMPLEXITY{Same asymptotic bounds as the baseline, but without recursion stack.}
\[
\begin{aligned}
T(n) &\in O\!\left(n + \sum_{p\in \mathcal{P}} |p|\right),\quad
S(n) \in O(h) \text{ (explicit stack) } + O(\text{output}).
\end{aligned}
\]
\CORRECTNESS{The stack simulates a preorder traversal; each edge is traversed once and every leaf produces exactly one path string.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import Optional, List

class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if not root:
            return []
        res: List[str] = []
        stack: List[tuple[TreeNode, str]] = [(root, str(root.val))]
        while stack:
            node, path = stack.pop()
            if not node.left and not node.right:
                res.append(path)
                continue
            if node.right:
                stack.append((node.right, path + "->" + str(node.right.val)))
            if node.left:
                stack.append((node.left, path + "->" + str(node.left.val)))
        return res

# Helpers and local tests
def build_tree_level(levels: List[Optional[int]]) -> Optional[TreeNode]:
    if not levels:
        return None
    it = iter(levels)
    root_val = next(it)
    if root_val is None:
        return None
    root = TreeNode(root_val)
    q = [root]
    for v in it:
        node = q.pop(0)
        if v is not None:
            node.left = TreeNode(v)
            q.append(node.left)
        try:
            v2 = next(it)
        except StopIteration:
            break
        if v2 is not None:
            node.right = TreeNode(v2)
            q.append(node.right)
    return root

# Asserts
root = build_tree_level([1, 2, 3, None, 5])
ans = sorted(Solution().binaryTreePaths(root))
assert ans == ["1->2->5", "1->3"]

root2 = build_tree_level([1])
ans2 = Solution().binaryTreePaths(root2)
assert ans2 == ["1"]

root3 = build_tree_level([1, -2, 3, -4, None, None, 5])
ans3 = sorted(Solution().binaryTreePaths(root3))
assert ans3 == ["1->-2->-4", "1->3->5"]
\end{minted}
\VALIDATION{Covers balanced and skewed subtrees, including negatives and missing children.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{DFS with path as a dynamic list of strings and join only at leaves. This minimizes intermediate string creation to $O(L)$ per leaf.}
\ASSUMPTIONS{Values convert to strings in $O(1)$ amortized time for small magnitudes; joining occurs once per leaf.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a list \texttt{path} of the stringified node values along the current recursion.
\item On entry, append the current node's value to \texttt{path}.
\item If leaf, append "\texttt{->}".join(path) to results; else recurse to children.
\item On exit, pop the last value to backtrack.
\end{algosteps}
\OPTIMALITY{Any algorithm must visit each node at least once and output each leaf path of length $|p|$ at a cost $\Omega(|p|)$ to write the string. This method achieves $O(n + \sum_{p\in\mathcal{P}} |p|)$ which is optimal up to constants.}
\COMPLEXITY{Linear in nodes plus total output length; stack depth $O(h)$.}
\[
\begin{aligned}
T(n) &\in O\!\left(n + \sum_{p\in \mathcal{P}} |p|\right),\quad
S(n) \in O(h) + O(\text{output}).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import Optional, List

class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if not root:
            return []
        res: List[str] = []
        path: List[str] = []
        def dfs(node: Optional[TreeNode]) -> None:
            if not node:
                return
            path.append(str(node.val))
            if not node.left and not node.right:
                res.append("->".join(path))
            else:
                dfs(node.left)
                dfs(node.right)
            path.pop()
        dfs(root)
        return res

# Helpers and exact 3 asserts
def build_tree_level(levels: List[Optional[int]]) -> Optional[TreeNode]:
    if not levels:
        return None
    it = iter(levels)
    root_val = next(it)
    if root_val is None:
        return None
    root = TreeNode(root_val)
    q = [root]
    for v in it:
        node = q.pop(0)
        if v is not None:
            node.left = TreeNode(v)
            q.append(node.left)
        try:
            v2 = next(it)
        except StopIteration:
            break
        if v2 is not None:
            node.right = TreeNode(v2)
            q.append(node.right)
    return root

# 1) Prompt example
root = build_tree_level([1, 2, 3, None, 5])
assert sorted(Solution().binaryTreePaths(root)) == ["1->2->5", "1->3"]
# 2) Single node
root2 = build_tree_level([1])
assert Solution().binaryTreePaths(root2) == ["1"]
# 3) Mixed signs and skew
root3 = build_tree_level([1, -2, None, -3, None, -4, None])
assert Solution().binaryTreePaths(root3) == ["1->-2->-3->-4"]
\end{minted}
\VALIDATION{Three asserts: both examples and a left-skewed chain with negatives to verify arrow formatting and order independence.}
\RESULT{Return a list of strings representing every root-to-leaf path, joined by "->". Any ordering is acceptable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests: single-node tree; balanced tree with two leaves; left-only and right-only chains; trees with negative values; trees with missing single children; randomized small trees with fixed seed.}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A, B, and C on identical generated trees by sorting their outputs and asserting equality.}
\LINE{EDGE-CASE GENERATOR}{Produce deterministic small trees: empty (not used on LC), single, skewed, and mixed-branch trees within value range $[-100,100]$.}
\begin{minted}{python}
from typing import Optional, List, Tuple
import random

class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

def build_tree_level(levels: List[Optional[int]]) -> Optional[TreeNode]:
    if not levels:
        return None
    it = iter(levels)
    root_val = next(it)
    if root_val is None:
        return None
    root = TreeNode(root_val)
    q = [root]
    for v in it:
        node = q.pop(0)
        if v is not None:
            node.left = TreeNode(v)
            q.append(node.left)
        try:
            v2 = next(it)
        except StopIteration:
            break
        if v2 is not None:
            node.right = TreeNode(v2)
            q.append(node.right)
    return root

class A:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res: List[str] = []
        def dfs(node: Optional[TreeNode], path: str) -> None:
            if not node:
                return
            cur = str(node.val) if not path else path + "->" + str(node.val)
            if not node.left and not node.right:
                res.append(cur); return
            dfs(node.left, cur); dfs(node.right, cur)
        dfs(root, ""); return res

class B:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if not root: return []
        res: List[str] = []; st: List[Tuple[TreeNode, str]] = [(root, str(root.val))]
        while st:
            node, path = st.pop()
            if not node.left and not node.right: res.append(path); continue
            if node.right: st.append((node.right, path + "->" + str(node.right.val)))
            if node.left: st.append((node.left, path + "->" + str(node.left.val)))
        return res

class C:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if not root: return []
        res: List[str] = []; path: List[str] = []
        def dfs(node: Optional[TreeNode]) -> None:
            if not node: return
            path.append(str(node.val))
            if not node.left and not node.right: res.append("->".join(path))
            else: dfs(node.left); dfs(node.right)
            path.pop()
        dfs(root); return res

def gen_skew_left(n: int) -> Optional[TreeNode]:
    if n <= 0: return None
    root = TreeNode(0); cur = root
    for i in range(1, n):
        cur.left = TreeNode(-i)
        cur = cur.left
    return root

def gen_random(n: int, p_null: float, seed: int = 0) -> Optional[TreeNode]:
    random.seed(seed)
    vals: List[Optional[int]] = []
    for i in range(n):
        if i == 0 or random.random() > p_null:
            vals.append(random.randint(-3, 3))
        else:
            vals.append(None)
    if vals and vals[0] is None:
        vals[0] = 0
    return build_tree_level(vals)

def paths_sorted(solver, root):
    return sorted(solver.binaryTreePaths(root))

# Cross-checks
root1 = build_tree_level([1, 2, 3, None, 5])
assert paths_sorted(A(), root1) == paths_sorted(B(), root1) == paths_sorted(C(), root1)

root2 = gen_skew_left(5)
assert paths_sorted(A(), root2) == paths_sorted(B(), root2) == paths_sorted(C(), root2)

root3 = gen_random(15, p_null=0.3, seed=42)
assert paths_sorted(A(), root3) == paths_sorted(B(), root3) == paths_sorted(C(), root3)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import Optional, List

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if not root:
            return []
        res: List[str] = []
        path: List[str] = []
        def dfs(node: Optional[TreeNode]) -> None:
            if not node:
                return
            path.append(str(node.val))
            if not node.left and not node.right:
                res.append("->".join(path))
            else:
                dfs(node.left)
                dfs(node.right)
            path.pop()
        dfs(root)
        return res

# Local tests (deterministic)
def build_tree_level(levels: List[Optional[int]]) -> Optional[TreeNode]:
    if not levels: return None
    it = iter(levels)
    root_val = next(it)
    if root_val is None: return None
    root = TreeNode(root_val); q = [root]
    for v in it:
        node = q.pop(0)
        if v is not None:
            node.left = TreeNode(v); q.append(node.left)
        try:
            v2 = next(it)
        except StopIteration:
            break
        if v2 is not None:
            node.right = TreeNode(v2); q.append(node.right)
    return root

# Asserts mirror the prompt and extras
assert sorted(Solution().binaryTreePaths(build_tree_level([1, 2, 3, None, 5]))) == ["1->2->5", "1->3"]
assert Solution().binaryTreePaths(build_tree_level([1])) == ["1"]
assert sorted(Solution().binaryTreePaths(build_tree_level([1, -2, 3]))) == ["1->-2", "1->3"]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Traverse all root-to-leaf paths and output them as arrow-joined strings.}
\WHY{Common DFS pattern that tests recursion, path accumulation, base-case handling, and string building.}
\CHECKLIST{
\begin{bullets}
\item Handle leaf detection: both children null.
\item Append without trailing arrow.
\item Backtrack correctly if using a shared path list.
\item Cover both left and right children.
\item Return empty list only if root is null (not in this LC constraints).
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Single-node tree.
\item Left-only or right-only chains.
\item Trees with negative values.
\item Trees where only one child exists at many nodes.
\item Balanced trees with multiple leaves at same depth.
\item Values repeating across different paths.
\item Maximum size tree ($n=100$).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Adding "->" after every node including the leaf, causing trailing arrows.
\item Forgetting to pop from the path list on backtrack.
\item Building path strings in-place and mutating them across branches.
\item Not guarding against null children before recursing.
\item Assuming an output order; judge accepts any order.
\item Recursion depth limits in other languages or larger constraints.
\end{bullets}
}
\FAILMODES{A solution that appends "->" eagerly or misses backtracking will produce incorrect strings. A solution that only explores one branch (e.g., returns early after left) misses paths. The presented methods visit all nodes and record only at leaves, preventing these failures.}
\ELI{We walk from the root to each leaf, keep a breadcrumb list of values, and when we hit a leaf we write those breadcrumbs with arrows between them. Then we back up and try other branches until all leaves are covered.}
\NotePages{3}

\end{document}