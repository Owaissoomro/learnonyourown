% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — GCD Counting}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/990/G}}
\LINE{DIFFICULTY / RATING}{CF 2400}
\STATEMENT{You are given a tree consisting of $n$ vertices. A number is written on each vertex; the number on vertex $i$ is equal to $a_i$.

Let us denote the function $g(x, y)$ as the greatest common divisor of the numbers written on the vertices belonging to the simple path from vertex $x$ to vertex $y$ (including these two vertices).

For every integer from $1$ to $2 \cdot 10^5$ you have to count the number of pairs $(x, y)$ $(1 \le x \le y \le n)$ such that $g(x, y)$ is equal to this number.

Input:
The first line contains one integer $n$ — the number of vertices $(1 \le n \le 2 \cdot 10^5)$.

The second line contains $n$ integers $a_1$, $a_2$, \ldots, $a_n$ $(1 \le a_i \le 2 \cdot 10^5)$ — the numbers written on vertices.

Then $n - 1$ lines follow, each containing two integers $x$ and $y$ $(1 \le x, y \le n, x \ne y)$ denoting an edge connecting vertex $x$ with vertex $y$. It is guaranteed that these edges form a tree.

Output:
For every integer $i$ from $1$ to $2 \cdot 10^5$ do the following: if there is no pair $(x, y)$ such that $x \le y$ and $g(x, y) = i$, do not output anything. Otherwise output two integers: $i$ and the number of aforementioned pairs. You have to consider the values of $i$ in ascending order.

See the examples for better understanding.}
\BREAKDOWN{We must count, for each $d$, the number of pairs $(x, y)$ with $x \le y$ such that the $\gcd$ of all values on the $x \leftrightarrow y$ path equals $d$. Count pairs with $\gcd$ divisible by $d$ using induced subgraphs on nodes whose values are multiples of $d$, then use inclusion--exclusion over multiples to get exact counts.}
\ELI{For each divisor $d$, keep only nodes with values divisible by $d$; pairs in the same kept-component have path $\gcd$ divisible by $d$. Subtract higher multiples to isolate exactly $d$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A tree with $n$ nodes: integer $n$; array $a_1,\ldots,a_n$ with $1 \le a_i \le 200{,}000$; and $n-1$ undirected edges forming a tree.}
\OUTPUTS{For each $i$ with at least one pair $(x,y)$, $1 \le x \le y \le n$, and path $\gcd$ equal to $i$, print a line: $i$ and the count. Lines in increasing $i$.}
\SAMPLES{Example 1: $n=1$, $a=[5]$; output: ``5 1''.
Example 2: $n=3$ chain, $a=[2,4,6]$; output lines: ``2 4'', ``4 1'', ``6 1''.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let a tree $T=(V,E)$ with $|V|=n$ and labels $a:V\to \mathbb{Z}_{>0}$. For $x,y\in V$, define $g(x,y)=\gcd\{a(v)\mid v\in P(x,y)\}$ where $P(x,y)$ is the simple $x\text{--}y$ path. For each $d\in[1..200{,}000]$, let $A[d]=|\{(x,y):x\le y,\,g(x,y)=d\}|$.}
\varmapStart
\var{n}{number of vertices}
\var{a_i}{value on vertex $i$}
\var{E}{edge set of the tree}
\var{F[d]}{number of pairs $(x,y)$ with $g(x,y)$ divisible by $d$}
\var{A[d]}{number of pairs $(x,y)$ with $g(x,y)=d$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
S_d &:= \{v\in V:\; d \mid a(v)\},\\
F[d] &= \sum_{\text{components }C \text{ of } T[S_d]} \binom{|C|}{2} \;+\; |S_d|,\\
A[d] &= F[d] - \sum_{k\ge 2} A[kd]\quad\text{for }d\ge 1.
\end{aligned}
\]
}
\ASSUMPTIONS{Tree is connected and acyclic; indices are $1$-based; pairs are counted with $x \le y$ so singletons are included.}
\INVARIANTS{For fixed $d$, the unique path between any two nodes in the same connected component of $T[S_d]$ lies entirely in $S_d$. Also $F[d]=\sum_{m: d\mid m} A[m]$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute $g(x,y)$ for all $\tfrac{n(n+1)}{2}$ pairs and tally.}
\ASSUMPTIONS{Use BFS per pair to extract the path and a running $\gcd$. Only for tiny $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each pair $(x,y)$ with $x \le y$, find the unique path via BFS.
\item Compute the $\gcd$ over values on that path.
\item Increment the counter for that $\gcd$.
\end{algosteps}
\COMPLEXITY{Brute-force BFS per pair is prohibitive.}
\[
\begin{aligned}
T(n) &= \Theta\!\big(n^2 \cdot \text{avg path length}\big)\approx \Theta(n^3)\ \text{in worst-case},\\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Enumerates all pairs and computes the definition of $g(x,y)$ exactly.}
\EDGECASES{Handles $n=1$; identical values; star and chain trees.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict
from math import gcd

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], []
    a = [0] + [int(next(it)) for _ in range(n)]
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    return n, a, edges

def bfs_path(adj, s, t):
    n = len(adj) - 1
    parent = [-1] * (n + 1)
    dq = deque([s])
    parent[s] = s
    while dq:
        u = dq.popleft()
        if u == t:
            break
        for v in adj[u]:
            if parent[v] == -1:
                parent[v] = u
                dq.append(v)
    if parent[t] == -1:
        return []  # shouldn't happen in a tree
    path = []
    cur = t
    while True:
        path.append(cur)
        if cur == s:
            break
        cur = parent[cur]
    path.reverse()
    return path

def solve_all_brutal(n, a, edges):
    if n == 0:
        return ""
    adj = [[] for _ in range(n + 1)]
    for u, v in edges:
        adj[u].append(v); adj[v].append(u)
    MAXA = max(a[1:]) if n > 0 else 0
    cnt = defaultdict(int)
    for x in range(1, n + 1):
        # singletons
        cnt[a[x]] += 1
        for y in range(x + 1, n + 1):
            path = bfs_path(adj, x, y)
            g = 0
            for u in path:
                g = gcd(g, a[u])
            cnt[g] += 1
    out = []
    for i in range(1, MAXA + 1):
        if cnt.get(i, 0) > 0:
            out.append(f"{i} {cnt[i]}")
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks for tiny inputs
        n, a, edges = 1, [0, 5], []
        out = solve_all_brutal(n, a, edges)
        assert out.strip() == "5 1"
        n, a, edges = 3, [0, 2, 4, 6], [(1, 2), (2, 3)]
        out = solve_all_brutal(n, a, edges).splitlines()
        assert "2 4" in out and "4 1" in out and "6 1" in out
        n, a, edges = 4, [0, 1, 1, 1, 1], [(1,2),(1,3),(1,4)]
        out = solve_all_brutal(n, a, edges).strip()
        assert out == "1 10"
        print("OK")
    else:
        n, a, edges = read_input(data)
        print(solve_all_brutal(n, a, edges))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts cover $n=1$, a chain with mixed multiples, and a star with all ones.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Union-Find per Divisor with Touch-Only Reset}
\WHICHFORMULA{For each $d$, restrict to nodes with $d \mid a[v]$, union adjacent such nodes, then sum $\binom{|C|}{2}$ over components plus $|S_d|$.}
\ASSUMPTIONS{Each node appears only for divisors of its value; each edge is considered only for common divisors of its endpoints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Bucket nodes by their exact value $a[v]$.
\item For each $d=1\ldots \max(a)$:
  gather nodes in $\bigcup_{k} \{v: a[v]=kd\}$.
\item Mark gathered nodes, union adjacent marked pairs, sum component sizes.
\item Let $F[d]=\sum \binom{s}{2} + |S_d|$. Use $A[d]=F[d]-\sum_{k\ge 2}A[kd]$ in decreasing $d$.
\end{algosteps}
\COMPLEXITY{Each vertex participates in as many $d$ as $\tau(a[v])$; each edge is traversed for $\tau(\gcd(a[u],a[v]))$ divisors. This yields near $O\!\big((n+\max A)\log\log \max A + \sum \tau\big)$ in practice.}
\[
\begin{aligned}
T(n) &\approx O\!\left(\sum_{v}\tau(a[v]) + \sum_{(u,v)\in E} \tau(\gcd(a[u],a[v])) + \max A \log \max A\right).\\
\end{aligned}
\]
\CORRECTNESS{Connectivity inside the induced subgraph $T[S_d]$ characterizes paths with $\gcd$ divisible by $d$; subtracting multiples isolates exact $d$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from math import gcd

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], []
    a = [0] + [int(next(it)) for _ in range(n)]
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    return n, a, edges

class DSU:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.size = [1] * (n + 1)
        self.touched = []

    def reset_nodes(self, nodes):
        for u in nodes:
            self.parent[u] = u
            self.size[u] = 1

    def find(self, x):
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.size[ra] < self.size[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        self.size[ra] += self.size[rb]
        return True

def solve_all_dsu(n, a, edges):
    if n == 0:
        return ""
    MAXA = max(a[1:])
    buckets = [[] for _ in range(MAXA + 1)]
    freq = [0] * (MAXA + 1)
    for i in range(1, n + 1):
        val = a[i]
        buckets[val].append(i)
        freq[val] += 1
    adj = [[] for _ in range(n + 1)]
    for u, v in edges:
        adj[u].append(v); adj[v].append(u)

    marked = [False] * (n + 1)
    Fpairs = [0] * (MAXA + 1)
    countDiv = [0] * (MAXA + 1)

    dsu = DSU(n)

    for d in range(1, MAXA + 1):
        nodes = []
        for m in range(d, MAXA + 1, d):
            if buckets[m]:
                nodes.extend(buckets[m])
        if not nodes:
            continue
        for u in nodes:
            marked[u] = True
        dsu.reset_nodes(nodes)
        # Union adjacent marked nodes
        for u in nodes:
            for v in adj[u]:
                if marked[v]:
                    dsu.union(u, v)
        # Accumulate pairs via component sizes
        seen_root = set()
        total_pairs = 0
        for u in nodes:
            r = dsu.find(u)
            if r not in seen_root:
                seen_root.add(r)
                s = dsu.size[r]
                total_pairs += s * (s - 1) // 2
        Fpairs[d] = total_pairs
        countDiv[d] = len(nodes)
        for u in nodes:
            marked[u] = False

    Finc = [0] * (MAXA + 1)
    for d in range(1, MAXA + 1):
        if Fpairs[d] or countDiv[d]:
            Finc[d] = Fpairs[d] + countDiv[d]

    ans = [0] * (MAXA + 1)
    for d in range(MAXA, 0, -1):
        s = Finc[d]
        m = d + d
        while m <= MAXA:
            s -= ans[m]
            m += d
        ans[d] = s

    out = []
    for i in range(1, MAXA + 1):
        if ans[i] > 0:
            out.append(f"{i} {ans[i]}")
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Quick checks
        n, a, edges = 1, [0, 5], []
        assert solve_all_dsu(n, a, edges).strip() == "5 1"
        n, a, edges = 3, [0, 2, 4, 6], [(1, 2), (2, 3)]
        out = solve_all_dsu(n, a, edges).splitlines()
        assert "2 4" in out and "4 1" in out and "6 1" in out
        n, a, edges = 4, [0, 1, 1, 1, 1], [(1,2),(1,3),(1,4)]
        assert solve_all_dsu(n, a, edges).strip() == "1 10"
        print("OK")
    else:
        n, a, edges = read_input(data)
        print(solve_all_dsu(n, a, edges))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Same three asserts as baseline, verifying divisibility counting and inclusion of singletons.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sieve over Divisors + Induced-Subgraph Components + Inclusion--Exclusion}
\WHICHFORMULA{For each $d$, gather nodes with $d \mid a[v]$. Count components in the induced subgraph to get $F[d]=\sum \binom{s}{2}+|S_d|$. Then $A[d]=F[d]-\sum_{k\ge 2}A[kd]$ computed in descending $d$.}
\ASSUMPTIONS{Values $a_i \le 200{,}000$ allow sieving over multiples efficiently.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Bucket vertices by exact value; build adjacency.
\item For $d=1$ to $\max(a)$:
  collect nodes in multiples of $d$, mark them.
\item DFS/BFS components only across marked nodes to sum $\binom{s}{2}$; add $|S_d|$.
\item Compute exact counts by subtracting multiples in descending $d$; output $i$ with $A[i]>0$.
\end{algosteps}
\OPTIMALITY{Each vertex appears exactly for divisors of its value; each tree edge is explored only for common divisors of its endpoints. The multiplicative structure yields near-linear behavior in practice; known accepted solution for CF 990G.}
\COMPLEXITY{$T \approx O\!\big(\sum_v \tau(a[v]) + \sum_{(u,v)\in E} \tau(\gcd(a[u],a[v])) + \max A \log \max A\big)$; $S=O(n+\max A)$.}
\[
\begin{aligned}
T(n) &= O\!\left(\sum_{d=1}^{\max(a)} \big(|S_d| + \text{edges within } S_d\big)\right) + O(\max(a)\log \max(a)).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque
from typing import List

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], []
    a = [0] + [int(next(it)) for _ in range(n)]
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    return n, a, edges

def solve_all(n: int, a: List[int], edges: List[tuple]) -> str:
    if n == 0:
        return ""
    MAXA = max(a[1:])
    buckets = [[] for _ in range(MAXA + 1)]
    for i in range(1, n + 1):
        buckets[a[i]].append(i)
    adj = [[] for _ in range(n + 1)]
    for u, v in edges:
        adj[u].append(v); adj[v].append(u)

    marked = [False] * (n + 1)
    seen = [False] * (n + 1)
    Fpairs = [0] * (MAXA + 1)
    countDiv = [0] * (MAXA + 1)

    stack = []

    for d in range(1, MAXA + 1):
        nodes = []
        for m in range(d, MAXA + 1, d):
            if buckets[m]:
                nodes.extend(buckets[m])
        if not nodes:
            continue
        for u in nodes:
            marked[u] = True
        total_pairs = 0
        for u in nodes:
            if not seen[u]:
                s = 0
                stack.append(u)
                seen[u] = True
                while stack:
                    x = stack.pop()
                    s += 1
                    for w in adj[x]:
                        if marked[w] and not seen[w]:
                            seen[w] = True
                            stack.append(w)
                total_pairs += s * (s - 1) // 2
        Fpairs[d] = total_pairs
        countDiv[d] = len(nodes)
        for u in nodes:
            marked[u] = False
            seen[u] = False

    Finc = [0] * (MAXA + 1)
    for d in range(1, MAXA + 1):
        if Fpairs[d] or countDiv[d]:
            Finc[d] = Fpairs[d] + countDiv[d]

    ans = [0] * (MAXA + 1)
    for d in range(MAXA, 0, -1):
        s = Finc[d]
        m = d + d
        while m <= MAXA:
            s -= ans[m]
            m += d
        ans[d] = s

    out_lines = []
    for i in range(1, MAXA + 1):
        if ans[i] > 0:
            out_lines.append(f"{i} {ans[i]}")
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Exactly 3 asserts
        n, a, edges = 1, [0, 5], []
        assert solve_all(n, a, edges).strip() == "5 1"
        n, a, edges = 3, [0, 2, 4, 6], [(1, 2), (2, 3)]
        out = solve_all(n, a, edges).splitlines()
        assert "2 4" in out and "4 1" in out and "6 1" in out
        n, a, edges = 4, [0, 1, 1, 1, 1], [(1,2),(1,3),(1,4)]
        assert solve_all(n, a, edges).strip() == "1 10"
        print("OK")
    else:
        n, a, edges = read_input(data)
        sys.stdout.write(solve_all(n, a, edges))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts: singleton tree; chain with mixed multiples; star with all ones.}
\RESULT{Lines ``$i$ count'' in increasing $i$, where count is the number of pairs $(x,y)$ with $x \le y$ and path $\gcd$ exactly $i$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small trees where brute force is feasible; random small trees cross-checked; adversarial labelings (all equal, co-prime, powers of a prime).}
\LINE{CROSS-CHECKS}{Compare brute-force (Approach A) vs final (Approach C) on $n \le 12$ across random trees and labels $\le 30$.}
\LINE{EDGE-CASE GENERATOR}{Generate stars, chains, and balanced trees; labels all ones, all same prime power, pairwise co-prime, and all equal to $k$.}
\begin{minted}{python}
import random
from math import gcd

def gen_chain(n):
    edges = [(i, i+1) for i in range(1, n)]
    return edges

def gen_star(n):
    return [(1, i) for i in range(2, n+1)]

def gen_random_tree(n, rng):
    pr = list(range(1, n+1))
    edges = []
    for v in range(2, n+1):
        u = rng.randint(1, v-1)
        edges.append((u, v))
    return edges

def brute(n, a, edges):
    # from Approach A
    from collections import deque
    adj = [[] for _ in range(n+1)]
    for u, v in edges:
        adj[u].append(v); adj[v].append(u)
    def path(u, v):
        par = [-1]*(n+1); dq=deque([u]); par[u]=u
        while dq:
            x=dq.popleft()
            if x==v: break
            for w in adj[x]:
                if par[w]==-1: par[w]=x; dq.append(w)
        cur=v; res=[]
        while True:
            res.append(cur)
            if cur==u: break
            cur=par[cur]
        res.reverse(); return res
    from collections import defaultdict
    cnt = defaultdict(int)
    for x in range(1, n+1):
        cnt[a[x]] += 1
        for y in range(x+1, n+1):
            g=0
            for t in path(x,y):
                g = gcd(g, a[t])
            cnt[g]+=1
    out = {k:v for k,v in cnt.items() if v>0}
    return out

def fast(n, a, edges):
    # from Approach C
    return solve_all(n, a, edges)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution: CF 990G - GCD Counting
import sys
from typing import List

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], []
    a = [0] + [int(next(it)) for _ in range(n)]
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    return n, a, edges

def solve_all(n: int, a: List[int], edges: List[tuple]) -> str:
    if n == 0:
        return ""
    MAXA = max(a[1:])
    buckets = [[] for _ in range(MAXA + 1)]
    for i in range(1, n + 1):
        buckets[a[i]].append(i)
    adj = [[] for _ in range(n + 1)]
    for u, v in edges:
        adj[u].append(v); adj[v].append(u)

    marked = [False] * (n + 1)
    seen = [False] * (n + 1)
    Fpairs = [0] * (MAXA + 1)
    countDiv = [0] * (MAXA + 1)

    stack = []

    for d in range(1, MAXA + 1):
        nodes = []
        for m in range(d, MAXA + 1, d):
            if buckets[m]:
                nodes.extend(buckets[m])
        if not nodes:
            continue
        for u in nodes:
            marked[u] = True
        total_pairs = 0
        for u in nodes:
            if not seen[u]:
                s = 0
                stack.append(u)
                seen[u] = True
                while stack:
                    x = stack.pop()
                    s += 1
                    for w in adj[x]:
                        if marked[w] and not seen[w]:
                            seen[w] = True
                            stack.append(w)
                total_pairs += s * (s - 1) // 2
        Fpairs[d] = total_pairs
        countDiv[d] = len(nodes)
        for u in nodes:
            marked[u] = False
            seen[u] = False

    Finc = [0] * (MAXA + 1)
    for d in range(1, MAXA + 1):
        if Fpairs[d] or countDiv[d]:
            Finc[d] = Fpairs[d] + countDiv[d]

    ans = [0] * (MAXA + 1)
    for d in range(MAXA, 0, -1):
        s = Finc[d]
        m = d + d
        while m <= MAXA:
            s -= ans[m]
            m += d
        ans[d] = s

    out_lines = []
    for i in range(1, MAXA + 1):
        if ans[i] > 0:
            out_lines.append(f"{i} {ans[i]}")
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests
        n, a, edges = 1, [0, 5], []
        assert solve_all(n, a, edges).strip() == "5 1"
        n, a, edges = 3, [0, 2, 4, 6], [(1, 2), (2, 3)]
        out = solve_all(n, a, edges).splitlines()
        assert "2 4" in out and "4 1" in out and "6 1" in out
        n, a, edges = 4, [0, 1, 1, 1, 1], [(1,2),(1,3),(1,4)]
        assert solve_all(n, a, edges).strip() == "1 10"
        print("OK")
    else:
        n, a, edges = read_input(data)
        sys.stdout.write(solve_all(n, a, edges))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count pairs whose path $\gcd$ equals $d$ via induced subgraphs on multiples of $d$, then subtract contributions of multiples.}
\WHY{Classic technique combining graph connectivity with divisor-sieve style inclusion--exclusion; appears in divisor/path gcd problems.}
\CHECKLIST{
- Compute buckets of vertices by exact value.
- For each $d$, gather nodes at multiples and mark.
- Traverse only marked-induced subgraph; sum $\binom{s}{2}$ and add $|S_d|$.
- Möbius-style subtraction in descending $d$ to isolate exact counts.
- Output only positive counts in ascending order.
}
\EDGECASES{
- $n=1$ (only one singleton pair).
- All $a_i=1$ (single line ``1 $\tfrac{n(n+1)}{2}$'').
- All $a_i$ equal to the same $p$ (only multiples of $p$ appear).
- Co-prime labels on a chain (many answers at $1$).
- Large $a_i$ near limit $200{,}000$.
- Highly composite values (many divisors; ensure performance).
- Deep trees (avoid recursion depth; use iterative DFS).
- Sparse outputs (skip zeros).
}
\PITFALLS{
- Forgetting to include singletons in $F[d]$.
- Clearing visited/marked arrays with $O(n)$ per $d$ (must clear only touched nodes).
- Integer overflows in other languages; in Python it is safe.
- Off-by-one in ranges over multiples.
- Reusing DSU/visited state across $d$ without reinitialization.
- Printing lines with zero counts or out of order.
- Using recursion causing recursion depth errors on deep trees.
- Misinterpreting $(x,y)$ as ordered pairs; they are with $x \le y$.
}
\FAILMODES{A naive all-pairs path search is $\Theta(n^3)$ and times out. Counting only pairs with $x<y$ and forgetting singletons yields wrong answers. Not subtracting multiples leads to counts for ``divisible by $d$'', not ``exactly $d$''.}
\ELI{Keep nodes that are multiples of $d$; all pairs inside those kept islands have path values all divisible by $d$. Do that for every $d$, then peel off higher multiples to get exactly $d$.}
\NotePages{3}

\end{document}