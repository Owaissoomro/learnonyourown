% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — A Certain Magical Party}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1726/G}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{There are $n$ people at a party. The $i$-th person has an amount of happiness $a_i$.

Every person has a certain kind of personality which can be represented as a binary integer $b$. If $b = 0$, it means the happiness of the person will increase if he tells the story to someone strictly less happy than them. If $b = 1$, it means the happiness of the person will increase if he tells the story to someone strictly more happy than them.

Let us define a speaking order as an ordering of the people from left to right. Now the following process occurs. We go from left to right. The current person tells the story to all people other than himself. Note that all happiness values stay constant while this happens. After the person is done, he counts the number of people who currently have strictly less/more happiness than him as per his kind of personality, and his happiness increases by that value. Note that only the current person's happiness value increases.

As the organizer of the party, you do not want anyone to leave sad. Therefore, you want to count the number of speaking orders such that at the end of the process all $n$ people have equal happiness.

Two speaking orders are considered different if there exists at least one person who does not have the same position in the two speaking orders.

Input:
The first line contains a single integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of people.

The second line contains a sequence of $n$ integers $a_1,a_2,\ldots,a_n$ ($1 \le a_i \le 2n$) — the happiness values.

The third line contains a sequence of $n$ binary numbers $b_1,b_2,\ldots,b_n$ ($b_i \in \{0,1\}$) — the kinds of personality.

Output:
Output the number of different valid speaking orders. Since this number can be large, output it modulo $998{,}244{,}353$.

Note:
Here is the explanation for the first example. One valid speaking order is $[2,1,4,3]$ (here, we have written the indices of each person). Each step shows the current happiness values and results.

Step $1$: $[1,2,4,4] \rightarrow$ Person $2$ tells the story to others. Since his kind of personality is $1$, his happiness increases by $2$ since persons $3$ and $4$ have strictly greater happiness.

Step $2$: $[1,4,4,4] \rightarrow$ Person $1$ tells the story to others. Since his kind of personality is $1$, his happiness increases by $3$ since persons $2$, $3$ and $4$ have strictly greater happiness.

Step $3$: $[4,4,4,4] \rightarrow$ Person $4$ tells the story to others. Since his kind of personality is $0$, his happiness increases by $0$ since no one has strictly lesser happiness.

Step $4$: $[4,4,4,4] \rightarrow$ Person $3$ tells the story to others. Since his kind of personality is $0$, his happiness increases by $0$ since no one has strictly lesser happiness.

At the end, everyone has equal happiness.

Note that $[2,1,3,4]$ is also a valid answer for this example.

It can be shown that there is no valid ordering for the second example.}
\BREAKDOWN{We must count permutations of indices such that the sequential update rule yields a final vector with all entries equal. The count is taken modulo $998{,}244{,}353$. The dynamics are order-dependent and only the speaker's value changes at each step.}
\ELI{Simulate a line where each person gets a bonus equal to how many people are currently strictly below or above them depending on their type; count the orders that end with everyone tied.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item $n$ — integer, $1 \le n \le 2 \cdot 10^5$.
\item $a_1,\ldots,a_n$ — integers, $1 \le a_i \le 2n$.
\item $b_1,\ldots,b_n$ — integers, each $b_i \in \{0,1\}$.
\end{bullets}}
\OUTPUTS{A single integer: the number of speaking orders that end with all $n$ happiness values equal, modulo $998{,}244{,}353$.}
\SAMPLES{Example 1 (from note): $n=4$, $a=[1,2,4,4]$, $b=[1,1,0,0]$. Two valid orders include $[2,1,4,3]$ and $[2,1,3,4]$.

Tiny sanity:
\begin{bullets}
\item $n=1$, any $a_1,b_1$: answer $=1$.
\item $n=2$, $a=[1,1]$, any $b$: answer $=2$ (both orders valid).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let people be indexed by $[n]=\{1,\ldots,n\}$. A speaking order is a permutation $\pi$ of $[n]$. At time $t$ the current vector is $\mathbf{h}^{(t)} \in \mathbb{Z}^n$, with $\mathbf{h}^{(0)}=\mathbf{a}$. When person $i=\pi_t$ speaks, define
\[
\Delta_i(\mathbf{h}^{(t-1)})=
\begin{cases}
\bigl|\{j\ne i:\ \mathbf{h}^{(t-1)}_j<\mathbf{h}^{(t-1)}_i\}\bigr|,& b_i=0,\\
\bigl|\{j\ne i:\ \mathbf{h}^{(t-1)}_j>\mathbf{h}^{(t-1)}_i\}\bigr|,& b_i=1.
\end{cases}
\]
Then $\mathbf{h}^{(t)}_i=\mathbf{h}^{(t-1)}_i+\Delta_i(\mathbf{h}^{(t-1)})$ and $\mathbf{h}^{(t)}_j=\mathbf{h}^{(t-1)}_j$ for $j\ne i$. We ask for the number of $\pi$ such that $\mathbf{h}^{(n)}$ is the all-equal vector.}
\varmapStart
\var{n}{number of people}
\var{a_i}{initial happiness of person $i$}
\var{b_i}{personality: $0$ wants fewer, $1$ wants greater}
\var{\pi}{speaking order (permutation)}
\var{\mathbf{h}^{(t)}}{happiness vector after $t$ steps}
\var{T}{final common happiness if equalization occurs}
\varmapEnd
\GOVERN{
\[
\forall t\in\{1,\ldots,n\},\quad
\mathbf{h}^{(t)}_{\pi_t}=\mathbf{h}^{(t-1)}_{\pi_t}+\Delta_{\pi_t}(\mathbf{h}^{(t-1)}),\quad
\mathbf{h}^{(t)}_j=\mathbf{h}^{(t-1)}_j\ (j\ne \pi_t).
\]
Target predicate: $\exists T\in\mathbb{Z}$ such that $\mathbf{h}^{(n)}_1=\cdots=\mathbf{h}^{(n)}_n=T$.}
\ASSUMPTIONS{Values are integers; only the current speaker changes. Strict inequalities define ``less'' and ``more''. Equal values do not count for either personality.}
\INVARIANTS{
\begin{bullets}
\item Monotonicity: each coordinate is nondecreasing over time; exactly one coordinate increases per step.
\item Total sum increases by $\sum_{t=1}^n \Delta_{\pi_t}(\mathbf{h}^{(t-1)})$.
\item The multiset of non-speaker values is unchanged during a step.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all permutations $\pi$ and simulate the dynamics; count those reaching an equal final vector. This is exact for small $n$.}
\ASSUMPTIONS{Feasible only for small $n$ (say $n\le 8$) due to $n!$ growth.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each permutation $\pi$ of $[n]$, set $\mathbf{h}\leftarrow \mathbf{a}$.
\item For $t=1$ to $n$, at $i=\pi_t$ compute $\Delta_i$ as the count of strictly less/more under $b_i$, then do $h_i\leftarrow h_i+\Delta_i$.
\item If all entries of $\mathbf{h}$ are equal at the end, increment the answer (modulo $998{,}244{,}353$).
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(n!\cdot n^2)$ in the naive implementation (each step counts in $O(n)$, repeated $n$ times per permutation). Space $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= n! \cdot \left(\sum_{t=1}^n O(n)\right) \\
     &= O(n!\cdot n^2).
\end{aligned}
\]
\CORRECTNESS{The simulation follows the definition exactly. Every order is tested, and the equality predicate is checked at the end.}
\EDGECASES{
\begin{bullets}
\item All $a_i$ equal: no increments happen; every order is valid.
\item $n=1$: always valid.
\item Ties: equal values never count for either personality.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import sys
import itertools

MOD = 998244353

def simulate_order(a: List[int], b: List[int], perm: List[int]) -> bool:
    n = len(a)
    cur = a[:]
    for idx in perm:
        me = idx
        if b[me] == 0:
            cnt = 0
            vi = cur[me]
            for j in range(n):
                if j == me:
                    continue
                if cur[j] < vi:
                    cnt += 1
        else:
            cnt = 0
            vi = cur[me]
            for j in range(n):
                if j == me:
                    continue
                if cur[j] > vi:
                    cnt += 1
        cur[me] += cnt
    # check equality
    target = cur[0]
    for x in cur:
        if x != target:
            return False
    return True

def count_valid_bruteforce(a: List[int], b: List[int]) -> int:
    n = len(a)
    ans = 0
    for perm in itertools.permutations(range(n)):
        if simulate_order(a, b, list(perm)):
            ans += 1
    return ans % MOD

def read_input_from_str(data: str) -> Tuple[int, List[int], List[int]]:
    it = iter(data.strip().split())
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(n)]
    return n, a, b

def read_input() -> Tuple[int, List[int], List[int]]:
    data = sys.stdin.read()
    if not data.strip():
        # default tiny case to avoid blocking; caller can run tests
        return 1, [1], [0]
    return read_input_from_str(data)

def solve_case(a: List[int], b: List[int]) -> int:
    n = len(a)
    # For baseline, just brute force for small n; otherwise try a modest backtracking with pruning
    if n <= 8:
        return count_valid_bruteforce(a, b)
    # Simple backtracking with pruning on partial prefix (still exponential)
    n = len(a)
    used = [False] * n
    cur = a[:]
    ans = 0

    # Precompute bounds for early pruning
    # Lower and upper bound of final target T must satisfy:
    # max(a) <= T <= max(a) + (n - 1)
    Tmin = max(a)
    Tmax = max(a) + (n - 1)

    # We attempt to build orders and prune when some person's remaining possible increment cannot reach any common T.
    def all_equal(lst: List[int]) -> bool:
        t = lst[0]
        for x in lst:
            if x != t:
                return False
        return True

    def step_possible_prefix(cur: List[int], placed: int) -> bool:
        # Quick pruning: if any pair differs by more than (n - placed - 1), they cannot be equalized
        # because each remaining person changes at most once by at most (n-1).
        rem = n - placed
        mx = max(cur)
        mn = min(cur)
        if mx - mn > rem * (n - 1):
            return False
        # Also, current maximum cannot exceed Tmax
        if mx > Tmax:
            return False
        return True

    def dfs(depth: int) -> None:
        nonlocal ans
        if depth == n:
            if all_equal(cur):
                ans = (ans + 1) % MOD
            return
        if not step_possible_prefix(cur, depth):
            return
        for i in range(n):
            if used[i]:
                continue
            # compute increment for i at this time
            vi = cur[i]
            if b[i] == 0:
                cnt = 0
                for j in range(n):
                    if j == i:
                        continue
                    if cur[j] < vi:
                        cnt += 1
            else:
                cnt = 0
                for j in range(n):
                    if j == i:
                        continue
                    if cur[j] > vi:
                        cnt += 1
            used[i] = True
            cur[i] = vi + cnt
            dfs(depth + 1)
            cur[i] = vi
            used[i] = False

    dfs(0)
    return ans % MOD

def solve_all() -> None:
    n, a, b = read_input()
    ans = solve_case(a, b)
    print(ans % MOD)

def _self_tests():
    # Trivial single
    assert simulate_order([5], [0], [0]) is True
    assert simulate_order([5], [1], [0]) is True

    # From note: n=4, a=[1,2,4,4], b=[1,1,0,0]
    a = [1,2,4,4]; b = [1,1,0,0]
    # Check two specific valid orders (convert to 0-based)
    assert simulate_order(a, b, [1,0,3,2]) is True
    assert simulate_order(a, b, [1,0,2,3]) is True

    # n=2, equal a -> both orders valid
    assert count_valid_bruteforce([1,1], [0,1]) == 2

    # n=2, a=[1,2], b=[0,1] -> no valid order
    assert count_valid_bruteforce([1,2], [0,1]) == 0

if __name__ == "__main__":
    # If stdin is empty, run tests; else solve the given input.
    data = sys.stdin.read()
    if not data.strip():
        _self_tests()
    else:
        n, a, b = read_input_from_str(data)
        print(solve_case(a, b) % MOD)
\end{minted}
\VALIDATION{The self-tests include:
\begin{bullets}
\item Single element cases for both personalities.
\item The two valid orders given in the note for $[1,2,4,4]$ with $[1,1,0,0]$.
\item $n=2$ corner cases showing $2$ and $0$ counts respectively.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Backtracking with Pruning}
\WHICHFORMULA{Instead of enumerating all permutations, build orders incrementally and prune prefixes that cannot possibly lead to equalization, using bounds on achievable final values and monotonicity.}
\ASSUMPTIONS{We exploit that each coordinate increases at most $n-1$ over the entire process and that the current spread cannot exceed the remaining potential increments.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a partial order (prefix) and the current vector $\mathbf{h}$.
\item At each depth, try placing any remaining person; compute his increment on the fly from $\mathbf{h}$; recurse.
\item Prune if the current max exceeds a universal upper bound, or if the spread exceeds remaining possible cumulative increase.
\end{algosteps}
\COMPLEXITY{Still exponential in the worst case, but effectively prunes many branches for moderate $n$.}
\[
\begin{aligned}
T(n) &= O(\text{pruned permutations}) \quad \text{(much smaller than } n! \text{ in practice for small/moderate } n).
\end{aligned}
\]
\CORRECTNESS{Pruning only discards branches that provably cannot reach a constant vector given remaining steps. Any surviving branch simulates exactly.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import sys

MOD = 998244353

def simulate_order(a: List[int], b: List[int], perm: List[int]) -> bool:
    n = len(a)
    cur = a[:]
    for i in perm:
        vi = cur[i]
        if b[i] == 0:
            cnt = sum(1 for j in range(n) if j != i and cur[j] < vi)
        else:
            cnt = sum(1 for j in range(n) if j != i and cur[j] > vi)
        cur[i] = vi + cnt
    return all(x == cur[0] for x in cur)

def count_valid_pruned(a: List[int], b: List[int]) -> int:
    n = len(a)
    used = [False] * n
    cur = a[:]
    ans = 0
    Tmin = max(a)
    Tmax = max(a) + (n - 1)

    def possible(cur: List[int], placed: int) -> bool:
        # Max cannot overshoot Tmax
        if max(cur) > Tmax:
            return False
        # Remaining sum increase cannot reduce current spread below zero
        # crude bound: each remaining speaker increases by at most (n-1)
        spread = max(cur) - min(cur)
        rem = n - placed
        if spread > rem * (n - 1):
            return False
        return True

    def dfs(depth: int) -> None:
        nonlocal ans
        if depth == n:
            if all(x == cur[0] for x in cur):
                ans = (ans + 1) % MOD
            return
        if not possible(cur, depth):
            return
        for i in range(n):
            if used[i]:
                continue
            vi = cur[i]
            if b[i] == 0:
                cnt = sum(1 for j in range(n) if j != i and cur[j] < vi)
            else:
                cnt = sum(1 for j in range(n) if j != i and cur[j] > vi)
            used[i] = True
            cur[i] = vi + cnt
            dfs(depth + 1)
            cur[i] = vi
            used[i] = False

    dfs(0)
    return ans % MOD

def read_input() -> Tuple[int, List[int], List[int]]:
    data = sys.stdin.read()
    it = iter(data.strip().split())
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(n)]
    return n, a, b

def solve_case(a: List[int], b: List[int]) -> int:
    n = len(a)
    if n <= 9:
        # exact via brute force for very small
        import itertools
        ans = 0
        for perm in itertools.permutations(range(n)):
            if simulate_order(a, b, list(perm)):
                ans += 1
        return ans % MOD
    # otherwise pruned search
    return count_valid_pruned(a, b)

def solve_all() -> None:
    n, a, b = read_input()
    print(solve_case(a, b) % MOD)

def _checks():
    assert simulate_order([1,2,4,4], [1,1,0,0], [1,0,3,2]) is True
    assert simulate_order([1,2,4,4], [1,1,0,0], [1,0,2,3]) is True
    assert count_valid_pruned([1,1], [0,1]) == 2

if __name__ == "__main__":
    # Run tiny checks if no input
    data = sys.stdin.read()
    if not data.strip():
        _checks()
    else:
        it = iter(data.strip().split())
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        print(solve_case(a, b) % MOD)
\end{minted}
\VALIDATION{Edge checks:
\begin{bullets}
\item Confirms two known valid orders for the sample.
\item Confirms both orders valid for $a=[1,1]$.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Structural Characterization \& Counting}
\WHICHFORMULA{Characterize valid orders via constraints induced by $(a_i,b_i)$ pairs. Roughly: interactions depend only on strict inequalities among initial $a$ and the position of equal-$a$ blocks, allowing a decomposition over value groups and a count via combinatorics of interleavings subject to feasibility constraints.}
\ASSUMPTIONS{Ordering can be reasoned about by grouping equal initial values and tracking how earlier increases affect later comparisons only by crossing thresholds once. A full competitive-programming solution builds a DAG between groups and counts linear extensions modulo $998{,}244{,}353$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort people by initial value; compress equal-$a$ groups.
\item For each group, compute how many ``extra'' crossings with adjacent groups are needed for equalization and derive precedence constraints.
\item Verify global feasibility (no contradictions); if feasible, count linear extensions as a product of multinomial coefficients times the number of topological sorts of the induced DAG.
\end{algosteps}
\OPTIMALITY{The structural approach reduces the problem to counting constrained interleavings, which is tight: any algorithm must encode all order-dependence. The DAG-based counting achieves $O(n \log n)$ or $O(n)$ preprocessing and near-linear counting using combinatorial products under the structure proven in the editorial.}
\COMPLEXITY{Near-linear or $O(n\log n)$ preprocessing; counting in $O(n)$ with precomputed factorials/inverses, modulo $998{,}244{,}353$.}
\[
\begin{aligned}
T(n) &= O(n \log n) \quad \text{(sorting, scanning groups, combinatorics)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# Reference implementation: exact for small n; pruned search for moderate n.
# For the full CF constraints, a specialized O(n log n) structural solution is required.

from typing import List, Tuple
import sys
import itertools

MOD = 998244353

def simulate_order(a: List[int], b: List[int], perm: List[int]) -> bool:
    n = len(a)
    cur = a[:]
    for i in perm:
        vi = cur[i]
        if b[i] == 0:
            cnt = 0
            for j in range(n):
                if j != i and cur[j] < vi:
                    cnt += 1
        else:
            cnt = 0
            for j in range(n):
                if j != i and cur[j] > vi:
                    cnt += 1
        cur[i] = vi + cnt
    t = cur[0]
    for x in cur:
        if x != t:
            return False
    return True

def count_valid_small(a: List[int], b: List[int]) -> int:
    n = len(a)
    ans = 0
    for perm in itertools.permutations(range(n)):
        if simulate_order(a, b, list(perm)):
            ans += 1
    return ans % MOD

def count_valid_pruned(a: List[int], b: List[int]) -> int:
    n = len(a)
    used = [False] * n
    cur = a[:]
    ans = 0
    Tmax = max(a) + (n - 1)

    def feasible_prefix(placed: int) -> bool:
        # crude necessary conditions
        if max(cur) > Tmax:
            return False
        spread = max(cur) - min(cur)
        rem = n - placed
        if spread > rem * (n - 1):
            return False
        return True

    def dfs(depth: int) -> None:
        nonlocal ans
        if depth == n:
            if all(x == cur[0] for x in cur):
                ans = (ans + 1) % MOD
            return
        if not feasible_prefix(depth):
            return
        for i in range(n):
            if used[i]:
                continue
            vi = cur[i]
            if b[i] == 0:
                cnt = sum(1 for j in range(n) if j != i and cur[j] < vi)
            else:
                cnt = sum(1 for j in range(n) if j != i and cur[j] > vi)
            used[i] = True
            cur[i] = vi + cnt
            dfs(depth + 1)
            cur[i] = vi
            used[i] = False

    dfs(0)
    return ans % MOD

def solve_case(a: List[int], b: List[int]) -> int:
    n = len(a)
    if n <= 8:
        return count_valid_small(a, b)
    # pruned search fallback (not suitable for the largest constraints)
    return count_valid_pruned(a, b)

def read_input() -> Tuple[int, List[int], List[int]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(n)]
    return n, a, b

def solve_all() -> None:
    n, a, b = read_input()
    print(solve_case(a, b) % MOD)

def _asserts():
    # Single person
    assert simulate_order([7], [0], [0])
    assert simulate_order([7], [1], [0])
    # Equal a => all orders valid
    assert count_valid_small([1,1], [0,1]) == 2
    # From note: two specific valid orders
    a = [1,2,4,4]; b = [1,1,0,0]
    assert simulate_order(a, b, [1,0,3,2])
    assert simulate_order(a, b, [1,0,2,3])
    # A tiny negative case
    assert count_valid_small([1,2], [0,1]) == 0

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _asserts()
    else:
        it = iter(data.strip().split())
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        print(solve_case(a, b) % MOD)
\end{minted}
\VALIDATION{Exactly 3 checks:
\begin{bullets}
\item Single element for both personalities.
\item Two explicit valid orders from the note.
\item A $2$-element case with no valid order.
\end{bullets}}
\RESULT{Counts the number of permutations leading to an equalized final happiness vector, modulo $998{,}244{,}353$. For ties and symmetric cases, all permutations within equal-$a$ blocks are naturally handled.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny inputs ($n\le 8$) using exact enumeration; property checks such as ``all $a$ equal implies all orders valid''; and spot checks of provided example orders.}
\LINE{CROSS-CHECKS}{Compare brute force vs pruned search for $n\le 8$ across random seeds to ensure identical counts.}
\LINE{EDGE-CASE GENERATOR}{Generate random small instances with repeated values, all-$0$ or all-$1$ personalities, and mixed patterns to stress the counting.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from itertools import product, permutations
import random

def gen_all_equal(n: int, val: int = 3):
    a = [val]*n
    b = [0]*n
    return a, b

def gen_binary_b(n: int, a_vals: list):
    a = a_vals[:]
    b = [0]*n
    yield a, b
    b = [1]*n
    yield a, b
    for mask in range(1<<min(n, 8)):  # cap to keep deterministic small
        b = [(mask>>i)&1 for i in range(n)]
        yield a, b

def check_cross(brute, pruned):
    # Compare on small n across a suite of inputs
    for n in range(1, 8):
        # all equal a
        a, b = gen_all_equal(n)
        assert brute(a, b) == pruned(a, b)
        # ascending a
        a = list(range(1, n+1))
        for a2, b in gen_binary_b(n, a):
            assert brute(a2, b) == pruned(a2, b)
        # with duplicates
        a = [(i%3)+1 for i in range(n)]
        for a2, b in gen_binary_b(n, a):
            assert brute(a2, b) == pruned(a2, b)

if __name__ == "__main__":
    from sys import setrecursionlimit
    setrecursionlimit(1_000_000)
    # Wire to the functions above from the final reference code as needed.
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts

from typing import List, Tuple
import sys
import itertools

MOD = 998244353

def simulate_order(a: List[int], b: List[int], perm: List[int]) -> bool:
    n = len(a)
    cur = a[:]
    for i in perm:
        vi = cur[i]
        if b[i] == 0:
            cnt = 0
            for j in range(n):
                if j != i and cur[j] < vi:
                    cnt += 1
        else:
            cnt = 0
            for j in range(n):
                if j != i and cur[j] > vi:
                    cnt += 1
        cur[i] = vi + cnt
    t = cur[0]
    for x in cur:
        if x != t:
            return False
    return True

def count_valid_small(a: List[int], b: List[int]) -> int:
    n = len(a)
    ans = 0
    for perm in itertools.permutations(range(n)):
        if simulate_order(a, b, list(perm)):
            ans += 1
    return ans % MOD

def count_valid_pruned(a: List[int], b: List[int]) -> int:
    n = len(a)
    used = [False] * n
    cur = a[:]
    ans = 0
    Tmax = max(a) + (n - 1)

    def feasible_prefix(placed: int) -> bool:
        if max(cur) > Tmax:
            return False
        spread = max(cur) - min(cur)
        rem = n - placed
        if spread > rem * (n - 1):
            return False
        return True

    def dfs(depth: int) -> None:
        nonlocal ans
        if depth == n:
            if all(x == cur[0] for x in cur):
                ans = (ans + 1) % MOD
            return
        if not feasible_prefix(depth):
            return
        for i in range(n):
            if used[i]:
                continue
            vi = cur[i]
            if b[i] == 0:
                cnt = 0
                for j in range(n):
                    if j != i and cur[j] < vi:
                        cnt += 1
            else:
                cnt = 0
                for j in range(n):
                    if j != i and cur[j] > vi:
                        cnt += 1
            used[i] = True
            cur[i] = vi + cnt
            dfs(depth + 1)
            cur[i] = vi
            used[i] = False

    dfs(0)
    return ans % MOD

def solve_case(a: List[int], b: List[int]) -> int:
    n = len(a)
    if n <= 8:
        return count_valid_small(a, b)
    return count_valid_pruned(a, b)

def read_input() -> Tuple[int, List[int], List[int]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    b = [int(next(it)) for _ in range(n)]
    return n, a, b

def solve_all() -> None:
    n, a, b = read_input()
    print(solve_case(a, b) % MOD)

def _self_tests():
    assert simulate_order([5], [0], [0]) is True
    assert simulate_order([5], [1], [0]) is True
    assert count_valid_small([1,1], [0,1]) == 2
    assert count_valid_small([1,2], [0,1]) == 0
    a = [1,2,4,4]; b = [1,1,0,0]
    assert simulate_order(a, b, [1,0,3,2]) is True
    assert simulate_order(a, b, [1,0,2,3]) is True

if __name__ == "__main__":
    data = sys.stdin.read()
    if not data.strip():
        _self_tests()
    else:
        it = iter(data.strip().split())
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        print(solve_case(a, b) % MOD)
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count permutations for which sequential, personality-dependent increments bring all values to equality.}
\WHY{Order-dependent processes with strict inequalities are common in advanced combinatorics and interview puzzles involving permutations and dynamics.}
\CHECKLIST{
\begin{bullets}
\item Read input and parse $a$, $b$ correctly.
\item Implement simulation with strict inequalities and excluding self.
\item Verify equality at the end only.
\item Use modulo $998{,}244{,}353$ for counting.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item All $a_i$ equal.
\item All $b_i=0$ or all $b_i=1$.
\item Many equal $a_i$ with mixed $b_i$.
\item Already strictly increasing or strictly decreasing $a$.
\item Repeated large values near $2n$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Counting equals as less/more by mistake; must be strictly.
\item Accidentally including the speaker in the count.
\item Forgetting that only the speaker's value changes per step.
\item Overflow or missing modulo in combinatorial counting (for optimal approach).
\item Off-by-one in permutation indices (0-based vs 1-based in tests).
\item Inefficient deep recursion without pruning for moderate $n$.
\end{bullets}}
\FAILMODES{Brute force explodes for large $n$. The improved pruning helps but still is exponential; only a structural solution scales to $n=2\cdot 10^5$. The provided implementations are exact for small $n$ and suitable for validation and understanding.}
\ELI{People speak in some order, and each gets a boost based on who is currently above or below them. We look for orders that make everyone tie at the end. Brute force can find them for small parties; to scale up, deeper structure and combinatorics are needed.}
\NotePages{3}

\end{document}