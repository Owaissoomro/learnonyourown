% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tournament Winners}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/tournament-winners/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a list \texttt{matches} of played games in a tournament among distinct players labeled by positive integers. Each element is a pair \texttt{[winner, loser]} indicating that \texttt{winner} defeated \texttt{loser} in one match. There are no ties. The same pair of players may play multiple matches in any order. A player may appear in \texttt{matches} only as a winner, only as a loser, or in both roles.

Define a \emph{tournament winner} as any player who appears in at least one match and never loses any match in \texttt{matches}.

Return the list of all tournament winners in ascending order of their labels. If no such player exists, return an empty list.}
\BREAKDOWN{Model matches as a directed graph from winner to loser. Count losses per player and record whether they ever won. The answer is the sorted set of players with zero losses who won at least once.}
\ELI{Track how many times each player lost; winners are those with loss count zero and at least one recorded win.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function signature (LeetCode style): \texttt{def tournamentWinners(self, matches: List[List[int]]) -\textgreater{} List[int]}.

Constraints:
\begin{bullets}
\item $0 \le m \le 200{,}000$ where $m = \text{len(matches)}$.
\item Player labels are positive integers within 32-bit signed range.
\item Each \texttt{matches[i]} is a list of two distinct integers \texttt{[winner, loser]}.
\end{bullets}}
\OUTPUTS{A list of integers: all players who appear in at least one match and have zero losses, sorted in strictly increasing order.}
\SAMPLES{
Example 1:
\begin{bullets}
\item Input: \texttt{matches = [[1,2],[2,3],[1,3]]}
\item Output: \texttt{[1]}
\item Explanation: Loss counts are $\{1:0,\,2:1,\,3:2\}$. Player $1$ has at least one win and zero losses.
\end{bullets}
Example 2:
\begin{bullets}
\item Input: \texttt{matches = [[5,6],[7,5]]}
\item Output: \texttt{[7]}
\item Explanation: Player $7$ never loses and has a win; players $5$ and $6$ each have at least one loss.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V$ be the set of players that appear in \texttt{matches} and let $E \subseteq V \times V$ be directed edges $u \to v$ for each recorded match where $u$ defeated $v$. For each $v \in V$, let $\operatorname{indeg}(v)$ be the number of incoming edges and $\operatorname{outdeg}(v)$ the number of outgoing edges. We seek
\begin{BreakableEquation*}
W \coloneqq \{\, v \in V : \operatorname{indeg}(v) = 0 \text{ and } \operatorname{outdeg}(v) \ge 1 \,\},
\end{BreakableEquation*}
returned as an increasing list.}
\varmapStart
\var{V}{set of players appearing in \texttt{matches}}
\var{E}{multiset of directed edges $u \to v$ for each match result}
\var{\operatorname{indeg}(v)}{number of losses of player $v$}
\var{\operatorname{outdeg}(v)}{number of wins of player $v$}
\var{W}{set of tournament winners to be returned}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
W = \{\, v \in V : \operatorname{indeg}(v)=0 \land \operatorname{outdeg}(v)\ge 1 \,\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{
\begin{bullets}
\item Every match has a unique ordered outcome $(\text{winner},\text{loser})$; no ties.
\item Multiple matches between the same ordered pair may exist; each contributes $+1$ to the relevant degree.
\item Only players present in \texttt{matches} are considered; players not present are excluded from $V$.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item For any player $v \in V$, $\operatorname{indeg}(v) \ge 0$ and $\operatorname{outdeg}(v) \ge 0$.
\item $\sum_{v \in V} \operatorname{indeg}(v) = \sum_{v \in V} \operatorname{outdeg}(v) = |E|$ by edge counting.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute in-degree (loss count) and whether a player ever won. The winners are those with loss count $0$ and at least one win.}
\ASSUMPTIONS{Use hash maps to count; sort the final list to satisfy ascending order.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize empty sets: $V$ for all seen players and $W_{\text{seen}}$ for players who have at least one win. Initialize a dictionary $\text{losses}$ mapping player $\to$ loss count (default $0$).
\item For each pair $[u,v]$ in \texttt{matches}: add $u,v$ to $V$; increment $\text{losses}[v]$ by $1$; ensure $\text{losses}[u]$ exists (set to $0$ if unseen); add $u$ to $W_{\text{seen}}$.
\item Build the list $A = [\,x \in V : \text{losses}[x]=0 \land x \in W_{\text{seen}}\,]$ and return \texttt{sorted(A)}.
\end{algosteps}
\COMPLEXITY{Let $m$ be the number of matches and $k = |V|$ distinct players. Hash updates are $O(1)$ expected.
\[
\begin{aligned}
T(m,k) &= O(m) + O(k) + O(k \log k) \text{ for the final sort} \\
       &= O(m + k \log k), \\
S(m,k) &= O(k) \text{ to store losses and sets.}
\end{aligned}
\]}
\CORRECTNESS{Every loss increments the in-degree of the corresponding player, and every winner is recorded. A player returned must have zero losses and at least one win, matching the definition. Conversely, any qualifying player satisfies the filter and is included.}
\EDGECASES{
\begin{bullets}
\item No matches: return empty list.
\item All players lose at least once: return empty list.
\item Duplicate matches: each loss still counted; zero-loss criterion remains correct.
\item Large labels: handled by hash maps without coordinate constraints.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Dict, Set

class Solution:
    def tournamentWinners(self, matches: List[List[int]]) -> List[int]:
        seen: Set[int] = set()
        winners_seen: Set[int] = set()
        losses: Dict[int, int] = {}
        for pair in matches:
            # Defensive parse for robustness to various LC inputs
            if not isinstance(pair, list) or len(pair) != 2:
                raise ValueError("Each match must be a list [winner, loser]")
            u, v = pair
            seen.add(u); seen.add(v)
            winners_seen.add(u)
            losses[v] = losses.get(v, 0) + 1
            # Ensure winner has an entry with zero losses if not present
            if u not in losses:
                losses[u] = 0
        # Players with zero losses who also have at least one win
        ans = [p for p in seen if losses.get(p, 0) == 0 and p in winners_seen]
        ans.sort()
        return ans

# Basic asserts (baseline)
sol = Solution()
assert sol.tournamentWinners([[1, 2], [2, 3], [1, 3]]) == [1]
assert sol.tournamentWinners([[5, 6], [7, 5]]) == [7]
assert sol.tournamentWinners([]) == []
\end{minted}
\VALIDATION{Checked empty input, simple chains, and multiple matches via asserts above.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Coordinate Compression to Tight Arrays}
\WHICHFORMULA{Compress sparse player labels to dense indices $[0..k-1]$ to use lists instead of dicts; this can be faster in Python and more memory-efficient for large inputs.}
\ASSUMPTIONS{Two passes: first collect unique players, compress; second count losses and wins in arrays; finally build and sort the answer by original labels.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan \texttt{matches} to build the sorted unique label list $L$ and a mapping $id[x] \mapsto$ dense index.
\item Initialize arrays \texttt{losses} and \texttt{has\_win} of length $k=|L|$ with zeros.
\item Second scan: for each $[u,v]$, increment \texttt{losses[id[v]]} and set \texttt{has\_win[id[u]]} to $1$.
\item Collect labels $L[i]$ where \texttt{losses[i] == 0 and has\_win[i] == 1}; return them in increasing order (already increasing because $L$ is sorted).
\end{algosteps}
\COMPLEXITY{Coordinate compression sorts $k$ labels once.
\[
\begin{aligned}
T(m,k) &= O(m + k \log k) \\
S(m,k) &= O(k) \text{ for arrays and the label map.}
\end{aligned}
\]
This matches the baseline asymptotically but improves constants for Python list operations.}
\CORRECTNESS{Compression preserves identity and ordering of labels. Zero-loss and has-win predicates are evaluated exactly as in the baseline, then mapped back to original labels in sorted order.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Dict

class Solution:
    def tournamentWinners(self, matches: List[List[int]]) -> List[int]:
        if not matches:
            return []
        # First pass: collect labels
        labels_set = set()
        for pair in matches:
            if not isinstance(pair, list) or len(pair) != 2:
                raise ValueError("Each match must be a list [winner, loser]")
            u, v = pair
            labels_set.add(u); labels_set.add(v)
        labels = sorted(labels_set)
        k = len(labels)
        id_map: Dict[int, int] = {x: i for i, x in enumerate(labels)}
        # Arrays
        losses = [0] * k
        has_win = [0] * k
        # Second pass: count
        for u, v in matches:
            losses[id_map[v]] += 1
            has_win[id_map[u]] = 1
        # Collect zero-loss with at least one win
        ans = [labels[i] for i in range(k) if losses[i] == 0 and has_win[i] == 1]
        # Already sorted because labels is sorted
        return ans

# Asserts (improved)
sol = Solution()
assert sol.tournamentWinners([[1, 2], [2, 3], [1, 3]]) == [1]
assert sol.tournamentWinners([[5, 6], [7, 5]]) == [7]
assert sol.tournamentWinners([]) == []
\end{minted}
\VALIDATION{Validated identical behavior on the same tests as baseline; compression preserves sorted output.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single-Pass Hashing + Final Sort}
\WHICHFORMULA{Maintain two hash maps/sets during one pass: loss count per player and whether they ever won. The final sorting of winners is necessary to meet ascending order; comparison-based sorting lower bound implies no further asymptotic improvement.}
\ASSUMPTIONS{Labels are arbitrary integers; hash maps handle sparsity. Sorting the output is unavoidable unless the platform relaxes ordering.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{losses = \{\}} and \texttt{winners\_seen = set()}.
\item For each match $[u,v]$: increment \texttt{losses[v]} and ensure \texttt{losses[u]} exists with $0$; add $u$ to \texttt{winners\_seen}.
\item Build the list of players $p$ with \texttt{losses[p] == 0} and $p \in$ \texttt{winners\_seen}; sort asc and return.
\end{algosteps}
\OPTIMALITY{Any algorithm that outputs a sorted list of $r$ winners must perform $\Omega(r \log r)$ comparisons in the general case. Counting losses requires $\Theta(m)$ updates. Thus $T(m,k)=\Theta(m + r \log r)$ is information-theoretically tight up to constant factors.}
\COMPLEXITY{
\[
\begin{aligned}
T(m,k) &= O(m) + O(r \log r) \subseteq O(m + k \log k), \\
S(m,k) &= O(k).
\end{aligned}
\]
Here $k$ is the number of distinct players and $r \le k$ the number of winners.}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Dict, Set

class Solution:
    def tournamentWinners(self, matches: List[List[int]]) -> List[int]:
        losses: Dict[int, int] = {}
        winners_seen: Set[int] = set()
        for pair in matches:
            if not isinstance(pair, list) or len(pair) != 2:
                raise ValueError("Each match must be a list [winner, loser]")
            u, v = pair
            # Record winner seen and update loss counts
            winners_seen.add(u)
            losses[v] = losses.get(v, 0) + 1
            # Ensure winner present in losses dict with zero
            if u not in losses:
                losses[u] = 0
        # Filter zero-loss players who also have at least one win
        ans = [p for p, cnt in losses.items() if cnt == 0 and p in winners_seen]
        ans.sort()
        return ans

# VALIDATION: exactly three asserts
_s = Solution()
assert _s.tournamentWinners([[1, 2], [2, 3], [1, 3]]) == [1]
assert _s.tournamentWinners([[10, 20], [30, 10], [30, 40], [50, 30]]) == [50]
assert _s.tournamentWinners([[4, 5], [4, 6], [4, 7], [8, 4]]) == [8]
\end{minted}
\VALIDATION{Three asserts cover a chain, a branching path with transitive losses, and a case where the only winner is a player who defeats someone that defeats many others.}
\RESULT{Return the labels of all players who appear in \texttt{matches} with zero losses and at least one win, sorted ascending; return an empty list if none.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests: small hand-crafted scenarios; property checks that any player in the answer has zero losses and at least one recorded win; adversarial cases with duplicates and large labels.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach A, B, and C on the same small inputs to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Create deterministic families: empty input; single match; two disjoint winners; heavy duplication; star winner beating many players.}
\begin{minted}{python}
from typing import List, Dict, Tuple

def ref_solution(matches: List[List[int]]) -> List[int]:
    losses: Dict[int, int] = {}
    winners_seen = set()
    for u, v in matches:
        winners_seen.add(u)
        losses[v] = losses.get(v, 0) + 1
        if u not in losses:
            losses[u] = 0
    ans = [p for p, c in losses.items() if c == 0 and p in winners_seen]
    ans.sort()
    return ans

def gen_empty() -> List[List[int]]:
    return []

def gen_single() -> List[List[int]]:
    return [[1, 2]]

def gen_star(center: int, leaves: List[int]) -> List[List[int]]:
    return [[center, x] for x in leaves]

def gen_chain(vals: List[int]) -> List[List[int]]:
    # vals like [a,b,c,d] => a>b, b>c, c>d
    return [[vals[i], vals[i+1]] for i in range(len(vals)-1)]

def run_tests():
    assert ref_solution(gen_empty()) == []
    assert ref_solution(gen_single()) == [1]
    assert ref_solution(gen_star(10, [1,2,3,4])) == [10]
    assert ref_solution(gen_chain([5,4,3,2,1])) == [5]
    # Duplicates and large labels
    ms = [[10**9, -10**9+1], [10**9, -10**9+2], [123, 10**9], [123, 456], [123, 456]]
    assert ref_solution(ms) == [123]

run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Dict, Set

class Solution:
    def tournamentWinners(self, matches: List[List[int]]) -> List[int]:
        losses: Dict[int, int] = {}
        winners_seen: Set[int] = set()
        for pair in matches:
            if not isinstance(pair, list) or len(pair) != 2:
                raise ValueError("Each match must be a list [winner, loser]")
            u, v = pair
            winners_seen.add(u)
            losses[v] = losses.get(v, 0) + 1
            if u not in losses:
                losses[u] = 0
        ans = [p for p, cnt in losses.items() if cnt == 0 and p in winners_seen]
        ans.sort()
        return ans

# Quick self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.tournamentWinners([[1, 2], [2, 3], [1, 3]]) == [1]
    assert s.tournamentWinners([[5, 6], [7, 5]]) == [7]
    assert s.tournamentWinners([]) == []
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count each player's losses and track who ever won; return players with zero losses and at least one win, sorted.}
\WHY{Graph-degree counting is a frequent building block in interviews and coding tests; careful handling of duplicates and ordering is common.}
\CHECKLIST{
\begin{bullets}
\item Initialize loss counts for winners to $0$ when first seen.
\item Track whether a player has at least one win.
\item Exclude players who never won even if they have zero losses by construction.
\item Sort the final list ascending.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Empty \texttt{matches}.
\item Duplicate matches between the same players.
\item A single dominant player who beats many players.
\item Chains where only the first player qualifies.
\item Labels that are large or negative within 32-bit range.
\item Players who only ever lose never appear in the answer.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to set winners' initial loss count to $0$ can drop them from the dictionary.
\item Including players who never won just because they have zero losses is incorrect per the definition here.
\item Not sorting the output violates platform expectations.
\item Misparsing input pairs or assuming fixed ranges for labels.
\item Using per-candidate scans over all matches, causing $O(km)$ time.
\item Mutating structures while iterating in ways that skip elements.
\end{bullets}}
\FAILMODES{
\begin{bullets}
\item Approaches that recompute losses by scanning matches for each player time out on large $m$.
\item Forgetting to handle duplicate matches can undercount losses.
\item Assuming contiguous small labels breaks when labels are sparse without compression.
\end{bullets}}
\ELI{Every match adds one loss to the loser. Winners are exactly the players with zero losses who have at least one win recorded. Count, filter, and sort.}
\NotePages{3}

\end{document}