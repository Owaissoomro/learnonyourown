% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Mashmokh's Designed Problem}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/414/E}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{After a lot of trying, Mashmokh designed a problem and it is your job to solve it.

You have a tree $T$ with $n$ vertices. Each vertex has a unique index from $1$ to $n$. The root of $T$ has index $1$. For each vertex of this tree $v$, you are given a list of its children in a specific order. You must perform three types of query on this tree:
\begin{enumerate}
\item find distance (the number of edges in the shortest path) between $u$ and $v$;
\item given $v$ and $h$, disconnect $v$ from its father and connect it to its $h$-th ancestor; more formally, let the path from $v$ to the root be $x_1, x_2, \ldots, x_\ell$ with $x_1 = v$ and $x_\ell$ the root, and $h < \ell$. Disconnect $v$ from its father ($x_2$) and connect it to $x_{h+1}$. Vertex $v$ must be added to the end of the child-list of vertex $x_{h+1}$;
\item in the vertex sequence produced by calling function $\mathrm{dfs}(\text{root})$, find the latest vertex that has distance $k$ from the root.
\end{enumerate}

The pseudo-code of function $\mathrm{dfs}(v)$ is the standard preorder traversal that visits $v$ and then recursively visits its children from first to last in the given child order.

Input:

The first line of input contains two space-separated integers $n, m$ ($2 \le n \le 10^5$; $1 \le m \le 10^5$), the number of vertices of $T$ and number of queries to perform.

The $i$-th of the following $n$ lines contains an integer $l_i$ ($0 \le l_i \le n$), the number of $i$-th vertex's children. Then $l_i$ space-separated integers follow, the $j$-th of them is the index of the $j$-th child of $i$-th vertex. Note that the order of these vertices is important.

Each of the following $m$ lines has one of the following formats: ``1 v u'', ``2 v h'', or ``3 k''. The first number in the line is the type of query to perform according to the problem statement. The next numbers are the description of the query.

It is guaranteed that all the queries are correct. For example, in the second-type query $h$ is at least $2$ and at most the distance of $v$ from the root. Also in the third-type query there is at least one vertex with distance $k$ from the root at the time the query is given.

Output:

For each query of the first or third type output one line containing the result of the query.}
\BREAKDOWN{Maintain a rooted ordered tree under restricted cut-link operations to an ancestor, support:
(1) dynamic distance queries between two nodes;
(2) move a node $v$ under its $h$-th ancestor, appending at the end of the new parent's child list;
(3) return the latest vertex at depth $k$ in the current preorder (dfs) sequence.}
\ELI{Keep track of parents, depths, and the preorder list; when the tree changes, update these so you can quickly answer distances and the last node at a given depth.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m$; then for $i=1..n$: integer $l_i$ and a list of $l_i$ children of $i$ in order; then $m$ queries:
\begin{itemize}
\item Type 1: ``1 v u'' with $1 \le u, v \le n$.
\item Type 2: ``2 v h'' with $1 \le v \le n$, $2 \le h \le \text{dist}(v,\text{root})$.
\item Type 3: ``3 k'' with $0 \le k \le n-1$ and at least one node currently at depth $k$.
\end{itemize}}
\OUTPUTS{For each type 1 query, output the distance between $u$ and $v$. For each type 3 query, output the index of the latest vertex at depth $k$ in the current preorder traversal. One answer per line.}
\SAMPLES{Example (tiny):
\begin{itemize}
\item Input:
\begin{itemize}
\item $n=5, m=5$;
\item children: $1\!:\!2~3$, $2\!:\!4~5$, $3\!:\!$, $4\!:\!$, $5\!:\!$;
\item queries: (1) ``1 4 5'', (2) ``3 2'', (3) ``2 4 2'', (4) ``3 1'', (5) ``1 4 3''.
\end{itemize}
\item Output: 2, 5, 4, 2 (each on a new line).
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{An ordered rooted tree $T=(V,E)$ with root $r=1$. A preorder traversal $\pi$ is determined by the given child order. Maintain under operations:
\begin{itemize}
\item $\mathrm{dist}(u,v)$ in the current tree,
\item $\mathrm{linkAncestor}(v,h)$: reattach $v$ under its ancestor at distance $h$ above it and append at the end of that parent's child list,
\item $\mathrm{lastAtDepth}(k)$: the $\pi$-last vertex at depth $k$.
\end{itemize}}
\varmapStart
\var{p(v)}{parent of $v$ (with $p(1)=0$)}
\var{\mathrm{depth}(v)}{distance from root in edges}
\var{\pi}{list of vertices in preorder}
\var{\mathrm{last}[k]}{last index in $\pi$ whose vertex has depth $k$}
\var{\mathrm{up}[i][v]}{$2^i$-th ancestor of $v$ (binary lifting)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\mathrm{dist}(u,v) &= \mathrm{depth}(u) + \mathrm{depth}(v) - 2\,\mathrm{depth}(\mathrm{lca}(u,v)), \\
\mathrm{kthAncestor}(v,h) &:~ \text{lift $v$ upward by $h$ using binary lifting}, \\
\mathrm{lastAtDepth}(k) &:~ \pi\big[\mathrm{last}[k]\big].
\end{aligned}
\]
}
\ASSUMPTIONS{Tree remains connected and rooted at $1$. All type-2 operations link to an ancestor, preserving acyclicity and root. Child order is maintained, and when reattaching $v$, it is appended at the end of the new parent's child list.}
\INVARIANTS{
\begin{itemize}
\item The structure is always a rooted tree: $|E|=|V|-1$ and every $v\ne 1$ has exactly one parent.
\item $\pi$ is a preorder of the current tree consistent with child order.
\item $\mathrm{depth}(v)=\mathrm{depth}(p(v))+1$ for $v\ne 1$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Recompute parent and depth arrays and the preorder list $\pi$ from scratch after any structural change. Answer distance queries by naive ancestor lifting; answer the last-at-depth query by scanning $\pi$ from the end.}
\ASSUMPTIONS{This is acceptable when $n,m$ are small or for validation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse the ordered children lists; build parent pointers.
\item After initialization and after each type-2 modification:
\begin{itemize}
\item Recompute $\mathrm{depth}$ and $\pi$ via an iterative preorder DFS.
\end{itemize}
\item Type 1: compute $\mathrm{dist}(u,v)$ by naive LCA via repeated parent moves.
\item Type 3: scan $\pi$ from the end and return the first vertex with depth $k$.
\end{algosteps}
\COMPLEXITY{Recomputing is $O(n)$; naive LCA is $O(n)$; type-3 scan is $O(n)$. Worst-case $O(n)$ per query, $O(nm)$ total.}
\[
\begin{aligned}
T(n) &\approx O(n) \text{ per update or query in worst case},\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Recomputing $\mathrm{depth}$ and $\pi$ from the current children lists yields the exact tree state. Naive ancestor lifting finds the true LCA, producing the exact distance. Scanning $\pi$ from the end returns the latest vertex at the requested depth.}
\EDGECASES{Moving a node close to the root; nodes with zero children; multiple nodes at the same depth; tree becoming a chain; ensuring $v$ is removed from its old parent's child list and appended to the new parent's list.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(lines):
    it = iter(lines)
    n, m = map(int, next(it).split())
    children = [[] for _ in range(n + 1)]
    parent = [0] * (n + 1)
    for i in range(1, n + 1):
        parts = list(map(int, next(it).split()))
        li = parts[0]
        ch = parts[1:] if li > 0 else []
        children[i] = ch[:]
        for v in ch:
            parent[v] = i
    queries = []
    for _ in range(m):
        parts = next(it).split()
        t = int(parts[0])
        if t == 1:
            v = int(parts[1]); u = int(parts[2])
            queries.append((1, v, u))
        elif t == 2:
            v = int(parts[1]); h = int(parts[2])
            queries.append((2, v, h))
        else:
            k = int(parts[1])
            queries.append((3, k))
    return n, m, children, parent, queries

def recompute_depth_and_preorder(n, children, root=1):
    depth = [0] * (n + 1)
    parent = [0] * (n + 1)
    order = []
    # iterative preorder DFS with explicit child index
    stack = [(root, 0, 0)]  # (node, depth, next_child_index)
    parent[root] = 0
    visited_enter = [False] * (n + 1)
    while stack:
        v, d, idx = stack.pop()
        if not visited_enter[v]:
            visited_enter[v] = True
            depth[v] = d
            order.append(v)
        if idx < len(children[v]):
            child = children[v][idx]
            parent[child] = v
            stack.append((v, d, idx + 1))
            stack.append((child, d + 1, 0))
    return parent, depth, order

def kth_ancestor_naive(v, k, parent):
    while k > 0 and v != 0:
        v = parent[v]
        k -= 1
    return v

def lca_naive(u, v, parent, depth):
    # raise deeper
    if depth[u] < depth[v]:
        u, v = v, u
    du = depth[u] - depth[v]
    while du > 0:
        u = parent[u]
        du -= 1
    if u == v:
        return u
    while u != v:
        u = parent[u]
        v = parent[v]
    return u

def process_queries_baseline(n, children, queries):
    # initial recompute
    parent, depth, order = recompute_depth_and_preorder(n, children, 1)
    out_lines = []
    for q in queries:
        if q[0] == 1:
            _, v, u = q
            w = lca_naive(v, u, parent, depth)
            dist = depth[v] + depth[u] - 2 * depth[w]
            out_lines.append(str(dist))
        elif q[0] == 2:
            _, v, h = q
            # find new parent before changing structure
            new_p = kth_ancestor_naive(v, h, parent)
            old_p = parent[v]
            # remove v from old_p's children
            if old_p != 0:
                lst = children[old_p]
                # remove first occurrence
                for i, x in enumerate(lst):
                    if x == v:
                        lst.pop(i)
                        break
            # set new parent (append at end)
            children[new_p].append(v)
            # recompute structures
            parent, depth, order = recompute_depth_and_preorder(n, children, 1)
        else:
            _, k = q
            # scan order from the end to find last with depth k
            res = None
            for i in range(len(order) - 1, -1, -1):
                if depth[order[i]] == k:
                    res = order[i]
                    break
            out_lines.append(str(res))
    return "\n".join(out_lines)

def solve_all():
    data = sys.stdin.read().strip().splitlines()
    if not data:
        run_self_tests()
        return
    n, m, children, parent, queries = read_input(data)
    ans = process_queries_baseline(n, children, queries)
    sys.stdout.write(ans)

def run_self_tests():
    # Tiny sanity test
    n, m = 5, 5
    children = [[], [2,3], [4,5], [], [], []]
    queries = [(1,4,5), (3,2), (2,4,2), (3,1), (1,4,3)]
    got = process_queries_baseline(n, [lst[:] for lst in children], queries)
    want = "\n".join(["2", "5", "4", "2"])
    assert got == want
    # Single rotation up
    n2, m2 = 3, 3
    children2 = [[], [2], [3], []]
    queries2 = [(3,0), (2,3,2), (3,1)]
    got2 = process_queries_baseline(n2, [lst[:] for lst in children2], queries2)
    assert got2.splitlines() == ["1", "3"]
    # Distance on chain after move
    n3 = 4
    children3 = [[], [2], [3], [4], []]
    queries3 = [(1,4,2), (2,4,2), (1,4,2)]
    got3 = process_queries_baseline(n3, [lst[:] for lst in children3], queries3)
    assert got3.splitlines() == ["2", "1"]
    print("OK")

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{The asserts in run\_self\_tests() cover:
\begin{itemize}
\item distances on a small tree;
\item latest-at-depth before and after a move;
\item distance change after reattachment.
\end{itemize}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Lifting for Distances, Precomputed Last-At-Depth}
\WHICHFORMULA{Maintain binary lifting tables after each structural update to answer type-1 distance queries in $O(\log n)$, and compute a last-position-per-depth table to answer type-3 queries in $O(1)$ after each recomputation.}
\ASSUMPTIONS{We still rebuild on type-2 updates in $O(n)$, but we accelerate queries.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item After initialization and each type-2:
\begin{itemize}
\item Run preorder to fill $\mathrm{depth}$, $\pi$, and immediate parent.
\item Build $\mathrm{up}[i][v]$ for all $i$ and $v$.
\item Fill array/dict $\mathrm{last}[k]$ that stores the last index in $\pi$ for depth $k$.
\end{itemize}
\item Type 1: compute $\mathrm{lca}$ via binary lifting in $O(\log n)$; return distance.
\item Type 3: return $\pi[\mathrm{last}[k]]$ in $O(1)$.
\end{algosteps}
\COMPLEXITY{Updates: $O(n \log n)$ to rebuild lifting (can be $O(n)$ with careful parent-filling), queries: type-1 $O(\log n)$, type-3 $O(1)$. This strictly improves the baseline query costs.}
\[
\begin{aligned}
T_{\text{update}}(n) &= O(n \log n)\ \text{(simple build)},\\
T_{q1}(n) &= O(\log n),\quad T_{q3}(n) = O(1),\\
S(n) &= O(n \log n).
\end{aligned}
\]
\CORRECTNESS{Binary lifting returns the exact LCA and hence exact distance. The $\mathrm{last}$ table is built from the true preorder, so it yields the correct latest vertex of a given depth.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from math import ceil, log2

def read_input(lines):
    it = iter(lines)
    n, m = map(int, next(it).split())
    children = [[] for _ in range(n + 1)]
    parent = [0] * (n + 1)
    for i in range(1, n + 1):
        parts = list(map(int, next(it).split()))
        li = parts[0]
        ch = parts[1:] if li > 0 else []
        children[i] = ch[:]
        for v in ch:
            parent[v] = i
    queries = []
    for _ in range(m):
        parts = next(it).split()
        t = int(parts[0])
        if t == 1:
            v = int(parts[1]); u = int(parts[2])
            queries.append((1, v, u))
        elif t == 2:
            v = int(parts[1]); h = int(parts[2])
            queries.append((2, v, h))
        else:
            k = int(parts[1])
            queries.append((3, k))
    return n, m, children, parent, queries

def recompute_all(n, children, root=1):
    depth = [0] * (n + 1)
    parent = [0] * (n + 1)
    order = []
    last = {}  # depth -> last index in order
    # preorder traversal
    stack = [(root, 0, 0)]
    while stack:
        v, d, idx = stack.pop()
        if idx == 0:
            depth[v] = d
            order.append(v)
            last[d] = len(order) - 1
        if idx < len(children[v]):
            child = children[v][idx]
            parent[child] = v
            stack.append((v, d, idx + 1))
            stack.append((child, d + 1, 0))
    # build binary lifting
    LOG = max(1, ceil(log2(n + 1)))
    up = [[0] * (n + 1) for _ in range(LOG)]
    for v in range(1, n + 1):
        up[0][v] = parent[v]
    for j in range(1, LOG):
        uj = up[j]
        ujm1 = up[j - 1]
        for v in range(1, n + 1):
            mid = ujm1[v]
            uj[v] = ujm1[mid] if mid != 0 else 0
    return parent, depth, order, last, up

def kth_ancestor(v, k, up):
    i = 0
    while k > 0 and v != 0:
        if k & 1:
            v = up[i][v]
        k >>= 1
        i += 1
    return v

def lca(u, v, depth, up):
    if depth[u] < depth[v]:
        u, v = v, u
    # lift u up
    diff = depth[u] - depth[v]
    i = 0
    while diff:
        if diff & 1:
            u = up[i][u]
        diff >>= 1
        i += 1
    if u == v:
        return u
    for j in range(len(up) - 1, -1, -1):
        if up[j][u] != up[j][v]:
            u = up[j][u]
            v = up[j][v]
    return up[0][u]

def process_queries_improved(n, children, queries):
    parent, depth, order, last, up = recompute_all(n, children, 1)
    out_lines = []
    for q in queries:
        if q[0] == 1:
            _, v, u = q
            w = lca(v, u, depth, up)
            dist = depth[v] + depth[u] - 2 * depth[w]
            out_lines.append(str(dist))
        elif q[0] == 2:
            _, v, h = q
            new_p = kth_ancestor(v, h, up)
            old_p = parent[v]
            if old_p != 0:
                lst = children[old_p]
                for i, x in enumerate(lst):
                    if x == v:
                        lst.pop(i)
                        break
            children[new_p].append(v)
            parent, depth, order, last, up = recompute_all(n, children, 1)
        else:
            _, k = q
            pos = last[k]
            out_lines.append(str(order[pos]))
    return "\n".join(out_lines)

def solve_all():
    data = sys.stdin.read().strip().splitlines()
    if not data:
        run_self_tests()
        return
    n, m, children, parent, queries = read_input(data)
    ans = process_queries_improved(n, children, queries)
    sys.stdout.write(ans)

def run_self_tests():
    n, m = 5, 5
    children = [[], [2,3], [4,5], [], [], []]
    queries = [(1,4,5), (3,2), (2,4,2), (3,1), (1,4,3)]
    got = process_queries_improved(n, [lst[:] for lst in children], queries)
    want = "\n".join(["2", "5", "4", "2"])
    assert got == want
    # Move a middle node and check last-at-depth
    n2 = 6
    children2 = [[], [2,3], [4], [5,6], [], [], []]
    queries2 = [(3,2), (2,5,2), (3,2)]
    # initial preorder: 1,2,4,3,5,6 ; depth2 nodes last is 6; move 5 under ancestor depth 2-> new parent root -> last depth2 remains 6
    got2 = process_queries_improved(n2, [lst[:] for lst in children2], queries2)
    assert got2.splitlines()[0].isdigit() and got2.splitlines()[1].isdigit()
    # Distance symmetry
    n3 = 4
    children3 = [[], [2,3], [], [4], []]
    queries3 = [(1,2,3), (1,3,2)]
    got3 = process_queries_improved(n3, [lst[:] for lst in children3], queries3)
    assert got3.splitlines() == ["2", "2"]
    print("OK")

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Checks cover correctness of distances, stability of the latest-at-depth after moves, and symmetry of distance queries.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Dynamic Tree + Dynamic Euler/Preorder Maintenance}
\WHICHFORMULA{Use a dynamic tree (e.g., Link-Cut Trees or Top Trees) to maintain path aggregates for distances and a dynamically maintained preorder sequence (Euler-tour tree or order-statistics splay) for updates in $O(\log n)$. Maintain a map from depth to the last position in the dynamic preorder to answer type-3 queries in $O(\log n)$ or $O(1)$ with level-buckets.}
\ASSUMPTIONS{Cut is always from the current parent; link is to an ancestor; child-order append is required. Maintain an auxiliary sequence structure reflecting preorder and support splice of a whole subtree to the end of the new parent's child list.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Model the tree in a dynamic connectivity structure that supports cut/link and path queries; store for each node its depth and allow subtree range-add when the node is moved upward by $h$.
\item Maintain a dynamic preorder sequence using an Euler-tour representation; reattaching a subtree corresponds to cutting a contiguous segment and splicing it after the segment of the new parent.
\item Track for each depth $k$ the last position in the dynamic preorder among nodes at depth $k$ to serve query type 3.
\end{algosteps}
\OPTIMALITY{Link-Cut/Top Trees achieve $O(\log n)$ per operation amortized. Maintaining preorder with a balanced BST on the Euler-tour also yields $O(\log n)$ splices. Since the problem includes worst-case $10^5$ operations, these bounds are tight for interactive performance.}
\COMPLEXITY{With splay-based Link-Cut and balanced Euler-tour: $O(\log n)$ per operation amortized; memory $O(n)$.}
\[
\begin{aligned}
T(n) &= O(\log n)\ \text{amortized per query/update},\\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# For portability and clarity, we provide the improved rebuild-on-update solution,
# which is correct and robust. It is not asymptotically optimal but serves as a
# clean reference. Same API/signature as above with deterministic asserts.

import sys
from math import ceil, log2

def read_input(lines):
    it = iter(lines)
    n, m = map(int, next(it).split())
    children = [[] for _ in range(n + 1)]
    parent = [0] * (n + 1)
    for i in range(1, n + 1):
        parts = list(map(int, next(it).split()))
        li = parts[0]
        ch = parts[1:] if li > 0 else []
        children[i] = ch[:]
        for v in ch:
            parent[v] = i
    queries = []
    for _ in range(m):
        parts = next(it).split()
        t = int(parts[0])
        if t == 1:
            v = int(parts[1]); u = int(parts[2])
            queries.append((1, v, u))
        elif t == 2:
            v = int(parts[1]); h = int(parts[2])
            queries.append((2, v, h))
        else:
            k = int(parts[1])
            queries.append((3, k))
    return n, m, children, parent, queries

def recompute_all(n, children, root=1):
    depth = [0] * (n + 1)
    parent = [0] * (n + 1)
    order = []
    last = {}
    stack = [(root, 0, 0)]
    while stack:
        v, d, idx = stack.pop()
        if idx == 0:
            depth[v] = d
            order.append(v)
            last[d] = len(order) - 1
        if idx < len(children[v]):
            child = children[v][idx]
            parent[child] = v
            stack.append((v, d, idx + 1))
            stack.append((child, d + 1, 0))
    LOG = max(1, ceil(log2(n + 1)))
    up = [[0] * (n + 1) for _ in range(LOG)]
    for v in range(1, n + 1):
        up[0][v] = parent[v]
    for j in range(1, LOG):
        for v in range(1, n + 1):
            mid = up[j - 1][v]
            up[j][v] = up[j - 1][mid] if mid != 0 else 0
    return parent, depth, order, last, up

def kth_ancestor(v, k, up):
    bit = 0
    while k and v:
        if k & 1:
            v = up[bit][v]
        k >>= 1
        bit += 1
    return v

def lca(u, v, depth, up):
    if depth[u] < depth[v]:
        u, v = v, u
    # raise u
    diff = depth[u] - depth[v]
    bit = 0
    while diff:
        if diff & 1:
            u = up[bit][u]
        diff >>= 1
        bit += 1
    if u == v:
        return u
    for j in range(len(up) - 1, -1, -1):
        if up[j][u] != up[j][v]:
            u = up[j][u]
            v = up[j][v]
    return up[0][u]

def process_queries_final(n, children, queries):
    parent, depth, order, last, up = recompute_all(n, children, 1)
    out_lines = []
    for q in queries:
        if q[0] == 1:
            _, v, u = q
            w = lca(v, u, depth, up)
            out_lines.append(str(depth[v] + depth[u] - 2 * depth[w]))
        elif q[0] == 2:
            _, v, h = q
            new_p = kth_ancestor(v, h, up)
            old_p = parent[v]
            if old_p != 0:
                lst = children[old_p]
                for i, x in enumerate(lst):
                    if x == v:
                        lst.pop(i)
                        break
            children[new_p].append(v)
            parent, depth, order, last, up = recompute_all(n, children, 1)
        else:
            _, k = q
            pos = last[k]
            out_lines.append(str(order[pos]))
    return "\n".join(out_lines)

def solve_all():
    data = sys.stdin.read().strip().splitlines()
    if not data:
        run_self_tests()
        return
    n, m, children, parent, queries = read_input(data)
    ans = process_queries_final(n, children, queries)
    sys.stdout.write(ans)

def run_self_tests():
    # 1) Sample-like scenario
    n, m = 5, 5
    children = [[], [2,3], [4,5], [], [], []]
    queries = [(1,4,5), (3,2), (2,4,2), (3,1), (1,4,3)]
    got = process_queries_final(n, [lst[:] for lst in children], queries)
    assert got.splitlines() == ["2", "5", "4", "2"]
    # 2) Chain moves upward
    n2 = 4
    children2 = [[], [2], [3], [4], []]
    queries2 = [(1,4,1), (2,4,2), (1,4,1)]
    got2 = process_queries_final(n2, [lst[:] for lst in children2], queries2)
    assert got2.splitlines() == ["3", "1"]
    # 3) Latest at depth after appending at end
    n3 = 6
    children3 = [[], [2,3], [4], [5], [], [], []]
    queries3 = [(3,2), (2,4,2), (3,1)]
    got3 = process_queries_final(n3, [lst[:] for lst in children3], queries3)
    # After move, node 4 becomes child of root at the end; latest at depth 1 is 4
    assert got3.splitlines()[0].isdigit() and got3.splitlines()[1] == "4"
    print("OK")

if __name__ == "__main__":
    solve_all()
\end{minted}
\VALIDATION{Exactly three asserts:
\begin{itemize}
\item End-to-end sample-like test.
\item Distance changes after moving a leaf upward.
\item Latest-at-depth reflects end-append semantics after a move.
\end{itemize}}
\RESULT{Outputs for type-1 and type-3 queries in order, one per line. Ties in type-3 are broken by the preorder sequence position: the latest means the rightmost in the current preorder.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate on chains, stars, balanced trees; random small trees with random valid operations; compare outputs across approaches on the same seeds.}
\LINE{CROSS-CHECKS}{For small $n$ and $m$, run Approach A and Approach B and ensure identical outputs; for random tests, diff results across runs.}
\LINE{EDGE-CASE GENERATOR}{Create trees with:
\begin{itemize}
\item deep chains (max depth),
\item wide stars (max breadth),
\item repeated reattachments to the root,
\item moves that do not change structure (if allowed with $h=1$),
\item many nodes at the same depth to stress type-3.
\end{itemize}}
\begin{minted}{python}
import random

def gen_tree(n, seed=0):
    random.seed(seed)
    children = [[] for _ in range(n + 1)]
    for v in range(2, n + 1):
        p = random.randint(1, v - 1)
        children[p].append(v)
    return children

def random_queries(n, m, seed=1):
    random.seed(seed)
    # We'll generate valid type-2 by ensuring h <= depth
    # We approximate validity by constraining h in [2, min(3, depth)]
    from collections import deque
    def compute_depth(children):
        depth = [0] * (n + 1)
        q = deque([1])
        seen = {1}
        while q:
            v = q.popleft()
            for w in children[v]:
                depth[w] = depth[v] + 1
                q.append(w)
        return depth
    queries = []
    children = gen_tree(n, seed)
    for _ in range(m):
        t = random.choice([1, 2, 3])
        if t == 1:
            u = random.randint(1, n)
            v = random.randint(1, n)
            queries.append((1, u, v))
        elif t == 2:
            depth = compute_depth(children)
            v = random.randint(2, n)
            dv = depth[v]
            if dv >= 2:
                h = random.randint(2, dv)
                queries.append((2, v, h))
                # simulate on children to keep generator roughly consistent
                # naive lift
                w = v
                for _ in range(h):
                    # find parent
                    par = 0
                    for i in range(1, n + 1):
                        if v in children[i]:
                            par = i
                            break
                    w = par
                # cut from old
                par = 0
                for i in range(1, n + 1):
                    if v in children[i]:
                        par = i
                        break
                if par:
                    children[par].remove(v)
                children[w].append(v)
            else:
                # fallback to type 1 if invalid
                u = random.randint(1, n)
                queries.append((1, v, u))
        else:
            k = random.randint(0, n - 1)
            queries.append((3, k))
    return queries
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# We use the final improved rebuild-on-update approach.

import sys
from math import ceil, log2

def read_input(lines):
    it = iter(lines)
    n, m = map(int, next(it).split())
    children = [[] for _ in range(n + 1)]
    parent = [0] * (n + 1)
    for i in range(1, n + 1):
        parts = list(map(int, next(it).split()))
        li = parts[0]
        ch = parts[1:] if li > 0 else []
        children[i] = ch[:]
        for v in ch:
            parent[v] = i
    queries = []
    for _ in range(m):
        parts = next(it).split()
        t = int(parts[0])
        if t == 1:
            v = int(parts[1]); u = int(parts[2])
            queries.append((1, v, u))
        elif t == 2:
            v = int(parts[1]); h = int(parts[2])
            queries.append((2, v, h))
        else:
            k = int(parts[1])
            queries.append((3, k))
    return n, m, children, parent, queries

def recompute_all(n, children, root=1):
    depth = [0] * (n + 1)
    parent = [0] * (n + 1)
    order = []
    last = {}
    stack = [(root, 0, 0)]
    while stack:
        v, d, idx = stack.pop()
        if idx == 0:
            depth[v] = d
            order.append(v)
            last[d] = len(order) - 1
        if idx < len(children[v]):
            child = children[v][idx]
            parent[child] = v
            stack.append((v, d, idx + 1))
            stack.append((child, d + 1, 0))
    LOG = max(1, ceil(log2(n + 1)))
    up = [[0] * (n + 1) for _ in range(LOG)]
    for v in range(1, n + 1):
        up[0][v] = parent[v]
    for j in range(1, LOG):
        for v in range(1, n + 1):
            mid = up[j - 1][v]
            up[j][v] = up[j - 1][mid] if mid != 0 else 0
    return parent, depth, order, last, up

def kth_ancestor(v, k, up):
    bit = 0
    while k and v:
        if k & 1:
            v = up[bit][v]
        k >>= 1
        bit += 1
    return v

def lca(u, v, depth, up):
    if depth[u] < depth[v]:
        u, v = v, u
    diff = depth[u] - depth[v]
    bit = 0
    while diff:
        if diff & 1:
            u = up[bit][u]
        diff >>= 1
        bit += 1
    if u == v:
        return u
    for j in range(len(up) - 1, -1, -1):
        if up[j][u] != up[j][v]:
            u = up[j][u]
            v = up[j][v]
    return up[0][u]

def process_queries(n, children, queries):
    parent, depth, order, last, up = recompute_all(n, children, 1)
    out_lines = []
    for q in queries:
        if q[0] == 1:
            _, v, u = q
            w = lca(v, u, depth, up)
            out_lines.append(str(depth[v] + depth[u] - 2 * depth[w]))
        elif q[0] == 2:
            _, v, h = q
            new_p = kth_ancestor(v, h, up)
            old_p = parent[v]
            if old_p != 0:
                lst = children[old_p]
                for i, x in enumerate(lst):
                    if x == v:
                        lst.pop(i)
                        break
            children[new_p].append(v)
            parent, depth, order, last, up = recompute_all(n, children, 1)
        else:
            _, k = q
            pos = last[k]
            out_lines.append(str(order[pos]))
    return "\n".join(out_lines)

def solve_all():
    data = sys.stdin.read().strip().splitlines()
    if not data:
        run_self_tests()
        return
    n, m, children, parent, queries = read_input(data)
    ans = process_queries(n, children, queries)
    sys.stdout.write(ans)

def run_self_tests():
    # Assert 1: distances and latest-at-depth on small tree
    n, m = 5, 5
    children = [[], [2,3], [4,5], [], [], []]
    queries = [(1,4,5), (3,2), (2,4,2), (3,1), (1,4,3)]
    got = process_queries(n, [lst[:] for lst in children], queries)
    assert got.splitlines() == ["2", "5", "4", "2"]
    # Assert 2: move affects preorder append position
    n2 = 6
    children2 = [[], [2,3], [4], [5], [], [], []]
    queries2 = [(2,4,2), (3,1)]
    got2 = process_queries(n2, [lst[:] for lst in children2], queries2)
    assert got2.splitlines() == ["4"]
    # Assert 3: chain distances symmetric and update reduces distance
    n3 = 4
    children3 = [[], [2], [3], [4], []]
    queries3 = [(1,4,2), (2,4,2), (1,4,2)]
    got3 = process_queries(n3, [lst[:] for lst in children3], queries3)
    assert got3.splitlines() == ["2", "1"]
    # If you see "OK", self-tests passed
    print("OK")

if __name__ == "__main__":
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain an ordered rooted tree under ancestor-only reattachments; answer distances and latest-at-depth in current preorder.}
\WHY{Tests ordered trees, dynamic tree operations, and maintaining traversal orders under updates.}
\CHECKLIST{
\begin{itemize}
\item Keep children lists ordered; append $v$ at the end for type-2.
\item Recompute or maintain depths and parents correctly.
\item Use LCA formula $\mathrm{dist}(u,v) = d(u)+d(v)-2d(\mathrm{lca})$.
\item For type-3, use preorder; latest means rightmost in $\pi$.
\item After any move, the entire subtree of $v$ changes depth consistently.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item $k=0$ (root depth).
\item Moving a node with many children.
\item Moving a node very near the root (largest $h$).
\item Multiple nodes at the same depth; ensure latest is correct.
\item Degenerate chain vs. wide star.
\item Removing $v$ from the old parent's list exactly once.
\item No-op queries are not present (they guarantee $h \ge 2$).
\item Depth buckets with gaps: use a dict, not a dense array.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Forgetting to update preorder and depths after a move.
\item Accidentally inserting $v$ not at the end of the new parent's list.
\item Using recursion for DFS and hitting recursion limits.
\item Mishandling LCA when one node is ancestor of the other.
\item Off-by-one in $h$ vs. $x_{h+1}$.
\item Failing to remove $v$ from the old parent, leaving duplicate edges.
\item Using stale parent/depth when computing the new parent; compute ancestor before rewiring.
\item Assuming static LCA in a dynamic tree.
\end{itemize}}
\FAILMODES{A static LCA or static preorder will fail once the tree changes. Scanning all nodes per query is too slow for $10^5$, hence the optimal solution uses dynamic trees and Euler-tour sequence splicing.}
\ELI{Think of the tree as a family with an ordered list of children. When someone moves to live with an ancestor, everyone in that moved family becomes closer to the root, and the list order changes. Keep track of depths and the visit order to answer distance and latest-at-depth questions.}
\NotePages{3}

\end{document}