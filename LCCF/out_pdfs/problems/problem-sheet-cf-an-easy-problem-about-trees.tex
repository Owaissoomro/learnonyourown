% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — An easy problem about trees}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/457/F}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{Pieguy and Piegirl are playing a game. They have a rooted binary tree, that has a property that each node is either a leaf or has exactly two children. Each leaf has a number associated with it.

On his/her turn a player can choose any two leaves that share their immediate parent, remove them, and associate either of their values with their parent, that now became a leaf (the player decides which of the two values to associate). The game ends when only one node (the one that was the root of the tree) is left.

Pieguy goes first, and his goal is to maximize the value that will be associated with the root when the game ends. Piegirl wants to minimize that value. Assuming that both players are playing optimally, what number will be associated with the root when the game ends?

Input:
First line contains a single integer $t$ ($1 \le t \le 100$) — number of test cases. Then $t$ test cases follow. Each test case begins with an empty line, followed by a line with a single integer $n$ ($1 \le n \le 250$), followed by $n$ lines describing $n$ nodes of the tree. Each of those $n$ lines either contains a non-negative number $a_i$, indicating a leaf node with value $a_i$ ($0 \le a_i \le 1000$) associated with it, or $-1$ followed by integers $l$ and $r$, indicating a non-leaf node with children $l$ and $r$ ($0 \le l, r \le n - 1$). Nodes are numbered from $0$ to $n - 1$. The root is always node $0$.

Output:
For each test case print one line with one integer on it — the number that will be associated with the root when the game ends.}
\BREAKDOWN{Reduce the impartial game to selecting one of the original leaves. Compute, for the tree shape alone, the best rank (order statistic) of the final leaf the first player can ensure. Then pick that rank from the multiset of leaf values.}
\ELI{The game always ends with exactly one original leaf surviving; the first player can force this survivor to be among the top $K$ leaves for a certain $K$ that depends only on the tree shape.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{For each test case:
\begin{bullets}
\item $n$ (int), number of nodes, $1 \le n \le 250$.
\item For $i=0,\ldots,n-1$, either:
  \begin{bullets}
  \item a non-negative integer $a_i$ ($0 \le a_i \le 1000$), meaning node $i$ is a leaf with value $a_i$, or
  \item line ``$-1~l~r$'' with integers $l,r$ ($0 \le l,r \le n-1$), meaning node $i$ is an internal node with children $l$ and $r$.
  \end{bullets}
\item Root index is always $0$. The tree is full (every non-leaf has exactly two children).
\end{bullets}}
\OUTPUTS{For each test case, a single integer: the value that will be associated with the root at the end of optimal play.}
\SAMPLES{Example 1 (one test):
\begin{bullets}
\item $n=3$; nodes: $0:\,-1~1~2$; $1:\,5$; $2:\,7$. Output: $7$.
\end{bullets}
Example 2:
\begin{bullets}
\item $n=7$; nodes: $0:\,-1~1~2$; $1:\,-1~3~4$; $2:\,-1~5~6$; $3:\,1$; $4:\,100$; $5:\,2$; $6:\,3$. Output: $3$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T$ be a rooted full binary tree with leaf multiset $A=\{a(\ell)\}$ (values on leaves). A play removes sibling leaves and assigns one of their values to their parent; after all merges, exactly one original leaf's value remains at the root. Under optimal alternating play (Pieguy first), the result equals the $K$-th smallest value of $A$, where $K$ depends only on $T$.}
\varmapStart
\var{L(u)}{number of leaves in the subtree rooted at node $u$}
\var{F(u)}{largest rank (within the $L(u)$ leaves of $u$) the current player can guarantee when moving first on subtree $u$}
\var{S(u)}{largest rank the current player can guarantee when moving second on subtree $u$}
\var{K}{the guaranteed rank at the root, $K=F(\text{root})$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Base (leaf $u$):}\quad L(u)=1,\quad F(u)=1,\quad S(u)=1.\\
&\text{Internal $u$ with children }x,y:\quad L(u)=L(x)+L(y),\\
&\qquad F(u)=\max\big(S(x)+L(y),\;S(y)+L(x)\big),\\
&\qquad S(u)=\min\big(F(x),\;F(y)\big).
\end{aligned}
\]
}
\ASSUMPTIONS{Tree is full; node indices form a rooted tree with root $0$. Values on leaves are integers and comparisons define a total order.}
\INVARIANTS{
\begin{bullets}
\item $1 \le S(u) \le F(u) \le L(u)$ for all nodes $u$ (by induction on the tree).
\item $F(u)$, $S(u)$ depend only on the tree shape, not on leaf values.
\item The final result equals the $K$-th order statistic of leaf values with $K=F(0)$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the rank DP directly on the tree shape to compute $K=F(0)$, then pick the $K$-th smallest leaf value. This avoids enumerating interleavings of moves.}
\ASSUMPTIONS{We can traverse the tree from the root; each non-leaf has exactly two children; recursion depth $\le n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse the tree; collect which nodes are leaves and internal, with children for internal nodes.
\item Depth-first compute $(L(u),F(u),S(u))$ by the recurrences; also collect all leaf values.
\item Let $K=F(0)$. Sort the leaf values non-decreasingly and output the $K$-th element (1-based).
\end{algosteps}
\COMPLEXITY{Compute $L,F,S$ in $\mathcal{O}(n)$ per test; sorting $\ell$ leaf values costs $\mathcal{O}(\ell\log\ell)$, with $\ell \le n$.}
\[
\begin{aligned}
T(n) &\le \mathcal{O}(n) + \mathcal{O}(\ell \log \ell) \le \mathcal{O}(n \log n),\\
S(n) &= \mathcal{O}(n)\ \text{(arrays for tree and DP)}.
\end{aligned}
\]
\CORRECTNESS{By the model, $F(u)$ is the best rank the side-to-move can force when the game is confined to subtree $u$. The combine rules capture two cases: moving first at $u$ lets you decide which child your opponent must open first (hence adding the full leaf count of the other child), while moving second limits you to the worse of the two $F$ values (hence $\min$). At the root, Pieguy moves first, so $K=F(0)$.}
\EDGECASES{Single node (leaf-only tree); skewed shapes; duplicate equal leaf values; zero values.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def solve_one_case(n, nodes):
    # nodes[i]: either ("leaf", val) or ("int", l, r)
    sys.setrecursionlimit(10000)
    is_leaf = [nodes[i][0] == "leaf" for i in range(n)]
    left = [-1]*n
    right = [-1]*n
    val = [0]*n
    for i in range(n):
        if is_leaf[i]:
            val[i] = nodes[i][1]
        else:
            left[i], right[i] = nodes[i][1], nodes[i][2]

    L = [0]*n
    F = [0]*n
    S_ = [0]*n
    leaves = []

    def dfs(u):
        if is_leaf[u]:
            L[u] = 1
            F[u] = 1
            S_[u] = 1
            leaves.append(val[u])
            return
        v = left[u]
        w = right[u]
        dfs(v)
        dfs(w)
        L[u] = L[v] + L[w]
        F[u] = max(S_[v] + L[w], S_[w] + L[v])
        S_[u] = min(F[v], F[w])

    dfs(0)
    K = F[0]
    leaves.sort()
    return leaves[K-1]

def read_input():
    data = sys.stdin.read().strip().splitlines()
    # Robustly handle possible empty lines between tests
    it = iter(data)
    def next_nonempty():
        for line in it:
            if line.strip() != "":
                return line.strip()
        return None
    t_line = next_nonempty()
    if t_line is None:
        return []
    t = int(t_line)
    cases = []
    for _ in range(t):
        line = next_nonempty()
        while line is None or line == "":
            line = next_nonempty()
        n = int(line)
        raw = []
        for _i in range(n):
            s = next_nonempty()
            parts = s.split()
            if parts[0] == "-1":
                raw.append(("int", int(parts[1]), int(parts[2])))
            else:
                raw.append(("leaf", int(parts[0])))
        cases.append((n, raw))
    return cases

def solve_all():
    cases = read_input()
    out = []
    for (n, nodes) in cases:
        out.append(str(solve_one_case(n, nodes)))
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Self-checks (tiny):
    # 1) Two leaves: choose max
    n = 3
    nodes = [
        ("int", 1, 2),
        ("leaf", 5),
        ("leaf", 7),
    ]
    assert solve_one_case(n, nodes) == 7

    # 2) Four leaves in two pairs -> second largest overall
    n2 = 7
    nodes2 = [
        ("int", 1, 2),
        ("int", 3, 4),
        ("int", 5, 6),
        ("leaf", 1),
        ("leaf", 100),
        ("leaf", 2),
        ("leaf", 3),
    ]
    assert solve_one_case(n2, nodes2) == 3

    # 3) Mixed subtree sizes: 3 leaves -> largest chosen
    n3 = 5
    nodes3 = [
        ("int", 1, 2),
        ("leaf", 10),
        ("int", 3, 4),
        ("leaf", 1),
        ("leaf", 7),
    ]
    assert solve_one_case(n3, nodes3) == 10

    # If input provided, run solver
    if not sys.stdin.isatty():
        solve_all()
\end{minted}
\VALIDATION{The three asserts cover: minimal tree, balanced four-leaf tree, and an unbalanced three-leaf case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same DP, but written iteratively or memoized with a single DFS and compact arrays; no recursion overhead beyond tree depth, and leaf values gathered in one pass.}
\ASSUMPTIONS{Tree nodes $\le 250$; Python recursion is safe with a raised limit; the DP uses only primitive arrays.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Preallocate arrays for $L$, $F$, $S$ and a vector for leaf values.
\item One post-order DFS computes $L$, $F$, $S$ and collects leaf values.
\item Sort leaf values and pick the $F(0)$-th.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline; small constant-factor improvements by single-pass aggregation.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(n \log n),\quad S(n)=\mathcal{O}(n).
\end{aligned}
\]
\CORRECTNESS{Identical to the baseline proof; the DP recurrences are unchanged.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def solve_one_case(n, nodes):
    sys.setrecursionlimit(10000)
    is_leaf = [nodes[i][0] == "leaf" for i in range(n)]
    L = [0]*n
    F = [0]*n
    S_ = [0]*n
    left = [-1]*n
    right = [-1]*n
    val = [0]*n
    for i in range(n):
        if is_leaf[i]:
            val[i] = nodes[i][1]
        else:
            left[i], right[i] = nodes[i][1], nodes[i][2]
    leaves = []

    def dfs(u):
        if is_leaf[u]:
            L[u] = 1
            F[u] = 1
            S_[u] = 1
            leaves.append(val[u])
            return
        v, w = left[u], right[u]
        dfs(v); dfs(w)
        L[u] = L[v] + L[w]
        F[u] = max(S_[v] + L[w], S_[w] + L[v])
        S_[u] = min(F[v], F[w])

    dfs(0)
    K = F[0]
    leaves.sort()
    return leaves[K-1]

def read_input():
    data = sys.stdin.read().splitlines()
    it = iter(data)
    def next_nonempty():
        for line in it:
            if line.strip() != "":
                return line.strip()
        return None
    t_line = next_nonempty()
    if t_line is None:
        return []
    t = int(t_line)
    cases = []
    for _ in range(t):
        line = next_nonempty()
        while line is None or line == "":
            line = next_nonempty()
        n = int(line)
        nodes = []
        for _i in range(n):
            parts = next_nonempty().split()
            if parts[0] == "-1":
                nodes.append(("int", int(parts[1]), int(parts[2])))
            else:
                nodes.append(("leaf", int(parts[0])))
        cases.append((n, nodes))
    return cases

def solve_all():
    cases = read_input()
    out = []
    for n, nodes in cases:
        out.append(str(solve_one_case(n, nodes)))
    print("\n".join(out))

if __name__ == "__main__":
    # Sanity checks
    assert solve_one_case(3, [("int",1,2),("leaf",5),("leaf",7)]) == 7
    assert solve_one_case(7, [("int",1,2),("int",3,4),("int",5,6),
                              ("leaf",1),("leaf",100),("leaf",2),("leaf",3)]) == 3
    assert solve_one_case(5, [("int",1,2),("leaf",10),("int",3,4),("leaf",1),("leaf",7)]) == 10

    if not sys.stdin.isatty():
        solve_all()
\end{minted}
\VALIDATION{Same three asserts; behavior is identical and robust to node ordering.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Compute $K=F(0)$ via the rank DP
\begin{BreakableEquation*}
F(u)=\max\big(S(x)+L(y), S(y)+L(x)\big),\quad S(u)=\min\big(F(x),F(y)\big),
\end{BreakableEquation*}
then return the $K$-th smallest leaf value.}
\ASSUMPTIONS{Tree is full; comparisons of integers define the order statistic; recursion stack fits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Post-order traverse to compute $(L,F,S)$ and collect leaf values.
\item Set $K\leftarrow F(\text{root})$.
\item Sort leaf values; output the element at 1-based index $K$.
\end{algosteps}
\OPTIMALITY{Every play deletes exactly one original leaf per move; the survivor is an original leaf. The DP characterizes the maximal guaranteed rank independent of leaf values, thus the order-statistic selection is tight. No algorithm can avoid at least sorting or selection among $\ell$ values; we use sorting for simplicity, which is optimal up to logarithmic factors if the full ordering is needed.}
\COMPLEXITY{Linear DP on the tree plus sorting the leaves.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(n) + \mathcal{O}(\ell\log\ell) \le \mathcal{O}(n\log n),\\
S(n) &= \mathcal{O}(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def solve_one_case(n, nodes):
    sys.setrecursionlimit(10000)
    is_leaf = [False]*n
    left = [-1]*n
    right = [-1]*n
    val = [0]*n
    for i in range(n):
        tag = nodes[i][0]
        if tag == "leaf":
            is_leaf[i] = True
            val[i] = nodes[i][1]
        else:
            left[i], right[i] = nodes[i][1], nodes[i][2]

    L = [0]*n
    F = [0]*n
    S_ = [0]*n
    leaves = []

    def dfs(u):
        if is_leaf[u]:
            L[u] = 1
            F[u] = 1
            S_[u] = 1
            leaves.append(val[u])
            return
        v, w = left[u], right[u]
        dfs(v); dfs(w)
        L[u] = L[v] + L[w]
        F[u] = max(S_[v] + L[w], S_[w] + L[v])
        S_[u] = min(F[v], F[w])

    dfs(0)
    K = F[0]
    leaves.sort()
    return leaves[K-1]

def read_input():
    data = sys.stdin.read().splitlines()
    it = iter(data)
    def next_nonempty():
        for line in it:
            if line.strip() != "":
                return line.strip()
        return None
    line = next_nonempty()
    if line is None:
        return []
    t = int(line)
    cases = []
    for _ in range(t):
        n_line = next_nonempty()
        while n_line is None or n_line == "":
            n_line = next_nonempty()
        n = int(n_line)
        nodes = []
        for _i in range(n):
            parts = next_nonempty().split()
            if parts[0] == "-1":
                nodes.append(("int", int(parts[1]), int(parts[2])))
            else:
                nodes.append(("leaf", int(parts[0])))
        cases.append((n, nodes))
    return cases

def solve_all():
    cases = read_input()
    out = []
    for n, nodes in cases:
        out.append(str(solve_one_case(n, nodes)))
    print("\n".join(out))

if __name__ == "__main__":
    # Exactly 3 asserts:
    assert solve_one_case(3, [("int",1,2),("leaf",5),("leaf",7)]) == 7
    assert solve_one_case(7, [("int",1,2),("int",3,4),("int",5,6),
                              ("leaf",1),("leaf",100),("leaf",2),("leaf",3)]) == 3
    assert solve_one_case(5, [("int",1,2),("leaf",10),("int",3,4),("leaf",1),("leaf",7)]) == 10

    if not sys.stdin.isatty():
        solve_all()
\end{minted}
\VALIDATION{Three asserts: 2-leaf, balanced 4-leaf, and 3-leaf unbalanced trees.}
\RESULT{Return the $K$-th smallest leaf value where $K=F(0)$ comes from the tree-shape DP. Ties among equal values are handled naturally by sorting.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test hand-crafted trees (single leaf, two leaves, balanced four leaves, mixed sizes), and randomized small trees with random values cross-checked by a slow game simulation for sanity (optional offline).}
\LINE{CROSS-CHECKS}{Compare rank $K$ from DP against exhaustive play on tiny trees to ensure the survivor is the $K$-th smallest.}
\LINE{EDGE-CASE GENERATOR}{Generate full binary trees by recursively expanding leaves with small probability; assign random leaf values including duplicates and zeros.}
\begin{minted}{python}
import random

def gen_full_tree(max_nodes=15):
    # Generate a small random full binary tree and nodes list for solver
    # Returns (n, nodes)
    idx = 0
    nodes = []
    children = []
    # Start with a single leaf; iteratively expand random leaves
    nodes.append(("leaf", random.randint(0, 10)))
    frontier = [0]
    while len(nodes) + 2 <= max_nodes and frontier and random.random() < 0.7:
        u = frontier.pop()
        # Expand u into an internal node with two new leaves
        nodes[u] = ("int", len(nodes), len(nodes)+1)
        nodes.append(("leaf", random.randint(0, 10)))
        nodes.append(("leaf", random.randint(0, 10)))
        frontier.extend([nodes[u][1], nodes[u][2]])
    return len(nodes), nodes

def slow_solve(n, nodes):
    # Exponential for tiny trees: simulate all valid plays to compute minimax over values
    # Represent state as the current tree structure mapping node-> either ("leaf", val) or ("int", l, r)
    from functools import lru_cache

    is_leaf = [nodes[i][0] == "leaf" for i in range(n)]
    val = [0]*n
    left = [-1]*n
    right = [-1]*n
    for i in range(n):
        if is_leaf[i]:
            val[i] = nodes[i][1]
        else:
            left[i], right[i] = nodes[i][1], nodes[i][2]

    # Build adjacency for parent lookup
    parent = [-1]*n
    for i in range(n):
        if not is_leaf[i]:
            parent[left[i]] = i
            parent[right[i]] = i

    # We will use a multiset-of-leaves dictionary (id->value) that respects sibling structure:
    # A move is allowed on siblings that are both leaves at that moment.

    # Build children map
    children = {i: [] for i in range(n)}
    for i in range(n):
        if left[i] != -1:
            children[i].append(left[i])
        if right[i] != -1:
            children[i].append(right[i])

    # Compute initial leaves
    def snapshot(u):
        # Return tuple of (u, structure) suitable for memo: we encode which nodes are leaves and their values
        return tuple((i, ("L", val_state[i]) if leaf_state[i] else ("I", children[i][0], children[i][1]))
                     for i in range(n))

    # Initialize mutable leaf/internal state
    leaf_state = [False]*n
    val_state = [0]*n
    for i in range(n):
        if is_leaf[i]:
            leaf_state[i] = True
            val_state[i] = val[i]

    # Recompute leaves until stable (initial state is already consistent)
    # Minimax recursion
    from functools import lru_cache

    @lru_cache(maxsize=None)
    def minimax(state, turn):
        # state: tuple of (node_id, ("L", val) or ("I", l, r)) for all nodes
        # turn: 0 for maximizing, 1 for minimizing
        # Reconstruct leaf/internal from state
        local_leaf = {}
        local_val = {}
        local_children = {}
        for node_id, tag in state:
            if tag[0] == "L":
                local_leaf[node_id] = True
                local_val[node_id] = tag[1]
            else:
                local_leaf[node_id] = False
                local_children[node_id] = (tag[1], tag[2])
        # Find all playable moves: internal node whose both children are leaves now
        moves = []
        for u in range(n):
            if u in local_children:
                l, r = local_children[u]
                if local_leaf.get(l, False) and local_leaf.get(r, False):
                    moves.append((u, l, r))
        if not moves:
            # Only root remains leaf
            return local_val[0]
        if turn == 0:
            best = -10**9
            for (u, l, r) in moves:
                for keep in (l, r):
                    # apply move
                    new_state = dict(state)
                    new_state[u] = (u, ("L", local_val[keep]))
                    # children l, r remain but will be ignored; leaves elsewhere unchanged
                    # pack
                    best = max(best, minimax(tuple(sorted(new_state.items())), 1))
            return best
        else:
            best = 10**9
            for (u, l, r) in moves:
                for keep in (l, r):
                    new_state = dict(state)
                    new_state[u] = (u, ("L", local_val[keep]))
                    best = min(best, minimax(tuple(sorted(new_state.items())), 0))
            return best

    # Build initial state
    init = []
    for i in range(n):
        if is_leaf[i]:
            init.append((i, ("L", val[i])))
        else:
            init.append((i, ("I", left[i], right[i])))
    init_state = tuple(sorted(init))
    return minimax(init_state, 0)

def reference_solve(n, nodes):
    # Use the DP rank method from the main solution
    return solve_one_case(n, nodes)

# Example cross-check on tiny random trees (commented to avoid long runs by default):
# for _ in range(10):
#     n, nodes = gen_full_tree(max_nodes=11)
#     if n <= 11:
#         assert reference_solve(n, nodes) == slow_solve(n, nodes)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def solve_one_case(n, nodes):
    sys.setrecursionlimit(10000)
    is_leaf = [False]*n
    left = [-1]*n
    right = [-1]*n
    val = [0]*n
    for i in range(n):
        tag = nodes[i][0]
        if tag == "leaf":
            is_leaf[i] = True
            val[i] = nodes[i][1]
        else:
            left[i], right[i] = nodes[i][1], nodes[i][2]

    L = [0]*n
    F = [0]*n
    S_ = [0]*n
    leaves = []

    def dfs(u):
        if is_leaf[u]:
            L[u] = 1
            F[u] = 1
            S_[u] = 1
            leaves.append(val[u])
            return
        v, w = left[u], right[u]
        dfs(v); dfs(w)
        L[u] = L[v] + L[w]
        F[u] = max(S_[v] + L[w], S_[w] + L[v])
        S_[u] = min(F[v], F[w])

    dfs(0)
    K = F[0]
    leaves.sort()
    return leaves[K-1]

def read_input():
    data = sys.stdin.read().splitlines()
    it = iter(data)
    def next_nonempty():
        for line in it:
            if line.strip() != "":
                return line.strip()
        return None
    line = next_nonempty()
    if line is None:
        return []
    t = int(line)
    cases = []
    for _ in range(t):
        n_line = next_nonempty()
        while n_line is None or n_line == "":
            n_line = next_nonempty()
        n = int(n_line)
        nodes = []
        for _i in range(n):
            parts = next_nonempty().split()
            if parts[0] == "-1":
                nodes.append(("int", int(parts[1]), int(parts[2])))
            else:
                nodes.append(("leaf", int(parts[0])))
        cases.append((n, nodes))
    return cases

def solve_all():
    cases = read_input()
    out = []
    for n, nodes in cases:
        out.append(str(solve_one_case(n, nodes)))
    print("\n".join(out))

if __name__ == "__main__":
    # Final tiny asserts
    assert solve_one_case(3, [("int",1,2),("leaf",5),("leaf",7)]) == 7
    assert solve_one_case(7, [("int",1,2),("int",3,4),("int",5,6),
                              ("leaf",1),("leaf",100),("leaf",2),("leaf",3)]) == 3
    assert solve_one_case(5, [("int",1,2),("leaf",10),("int",3,4),("leaf",1),("leaf",7)]) == 10

    if not sys.stdin.isatty():
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute $K$ from tree shape with a two-state DP, then select the $K$-th smallest leaf value.}
\WHY{This pattern (game reduces to an order statistic) appears in adversarial merging/pruning games on trees; recognizing it avoids exponential search.}
\CHECKLIST{
\begin{bullets}
\item Parse tree; ensure full-binary structure.
\item Post-order DP to compute $L$, $F$, $S$.
\item Collect leaf values; sort; pick index $F(0)-1$ (0-based).
\item Output exactly one integer per test.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Single node (answer is its value).
\item Two leaves under root (answer is $\max$ of the two).
\item Deep skewed tree (recursion depth).
\item Duplicate leaf values (stable under sorting).
\item Zero values and maximum values.
\item Input with blank lines between tests.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Misinterpreting input where ``$-1$'' denotes internal node.
\item Forgetting to treat indices as 0-based.
\item Mixing up $F$ and $S$ in recurrences.
\item Off-by-one when selecting the $K$-th smallest (1-based vs 0-based).
\item Not collecting all leaf values from the whole tree.
\item Stack overflow if recursion limit too low (raise if needed).
\end{bullets}}
\FAILMODES{Enumerating game interleavings is exponential; the DP avoids this by collapsing the game to ranks. The solution is robust to tree shapes and duplicate values.}
\ELI{You always end up keeping exactly one original leaf. The tree shape tells you how many of the largest leaves the first player can insist on keeping in the running. Once you know that count $K$, just take the $K$-th smallest number from the leaves and that is the final result.}
\NotePages{3}

\end{document}