% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Binary Number with Alternating Bits}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/binary-number-with-alternating-bits/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given a positive integer $n$, check whether it has alternating bits: namely, if two adjacent bits always have different values.

\textbf{Example 1:}

Input: $n = 5$; Output: true. Explanation: the binary representation of $5$ is $101$.

\textbf{Example 2:}

Input: $n = 7$; Output: false. Explanation: the binary representation of $7$ is $111$.

\textbf{Example 3:}

Input: $n = 11$; Output: false. Explanation: the binary representation of $11$ is $1011$.

\textbf{Constraints:} $1 \le n \le 2^{31} - 1$.}
\BREAKDOWN{We need to verify that in the binary representation of $n$, every adjacent pair of bits differs. This can be done by scanning bits or by a bit-manipulation identity.}
\ELI{Bits alternate if, after XORing the number with itself shifted right by one, you get a run of all $1$ bits.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single integer $n$ with $1 \le n \le 2^{31} - 1$. On LeetCode, this is the method parameter \texttt{n: int}.}
\OUTPUTS{A boolean indicating whether the binary representation of $n$ has alternating bits. On LeetCode, return \texttt{True} or \texttt{False}.}
\SAMPLES{Examples:
\begin{bullets}
\item Input: $n=5$ ($101_2$) $\to$ Output: \texttt{True}.
\item Input: $n=7$ ($111_2$) $\to$ Output: \texttt{False}.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n \in \mathbb{Z}_{>0}$. Write its binary expansion as $n = \sum_{i=0}^{L-1} b_i 2^i$ with $b_i \in \{0,1\}$ and $b_{L-1}=1$. Decide whether $\forall i \in \{0,\ldots,L-2\}$, $b_i \ne b_{i+1}$.}
\varmapStart
\var{n}{input integer}
\var{b_i}{bit at position $i$, least significant bit at $i=0$}
\var{L}{number of bits in $n$}
\var{x}{auxiliary value $x = n \oplus \lfloor n/2 \rfloor$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i \in \{0,\ldots,L-2\}:\; b_i \ne b_{i+1}
\end{BreakableEquation*}
Equivalently, with $x = n \oplus (n \gg 1)$,
\begin{BreakableEquation*}
\text{$n$ has alternating bits} \iff \text{$x$ is a bitstring of all $1$s} \iff (x \,\&\, (x+1)) = 0.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Binary representation has no leading zeros; $n \ge 1$, so $L \ge 1$. Bitwise operators use two's-complement semantics but all operations are on nonnegative integers.}
\INVARIANTS{
\begin{bullets}
\item During a right-shift scan, the previously seen bit equals $n \,\&\, 1$ at each step, and $n$ strictly decreases until it becomes $0$.
\item For any $n \ge 1$, $x = n \oplus (n \gg 1)$ yields $x$ of the form $11\ldots1_2$ iff bits of $n$ alternate.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Scan bits from least significant to most significant. Track the previous bit, compare with the next bit, and fail if two adjacent bits are equal.}
\ASSUMPTIONS{Integer shifts and bitwise \texttt{\&} are $O(1)$; the loop runs $O(\log n)$ iterations.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{prev} to \texttt{-1} (sentinel).
\item While $n>0$: let \texttt{bit} be $n \,\&\, 1$; if \texttt{prev == bit}, return \texttt{False}; set \texttt{prev = bit}; set $n \leftarrow n \gg 1$.
\item Return \texttt{True}.
\end{algosteps}
\COMPLEXITY{Time is $O(\log n)$ since we process each bit once; space is $O(1)$.}
\[
\begin{aligned}
T(n) &= \Theta(\lfloor \log_2 n \rfloor + 1), \\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Each iteration compares adjacent bits $b_i$ and $b_{i+1}$ exactly once. If any equal pair exists, it is detected and the algorithm returns \texttt{False}; otherwise, the loop completes and returns \texttt{True}.}
\EDGECASES{Minimal $n=1$ returns \texttt{True}; powers of two (like $2$ or $8$) alternate because their binary is $10\ldots0$; the maximum $2^{31}-1$ is all ones and returns \texttt{False}.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        prev = -1
        while n:
            bit = n & 1
            if bit == prev:
                return False
            prev = bit
            n >>= 1
        return True

# Tests (baseline)
s = Solution()
assert s.hasAlternatingBits(5) is True      # 101
assert s.hasAlternatingBits(7) is False     # 111
assert s.hasAlternatingBits(11) is False    # 1011
assert s.hasAlternatingBits(1) is True      # 1
assert s.hasAlternatingBits(2) is True      # 10
\end{minted}
\VALIDATION{Checked given samples and quick edges: $n=1$, $n=2$, $n=3$, and a few random values.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use the bit trick: if bits alternate, then $x = n \oplus (n \gg 1)$ is a run of ones; then test if $x$ is of the form $11\ldots1_2$ by checking $(x \,\&\, (x+1)) = 0$.}
\ASSUMPTIONS{Bitwise operations are $O(1)$ on fixed-width integers; no loops required.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $x \leftarrow n \oplus (n \gg 1)$.
\item Return \texttt{True} iff $(x \,\&\, (x+1)) = 0$.
\item This works because a string of all ones has the property $x \,\&\, (x+1) = 0$ and only such strings do.
\end{algosteps}
\COMPLEXITY{Constant time and space on fixed-width integers; this avoids the $\log n$ loop.}
\[
\begin{aligned}
T(n) &= \Theta(1), \\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{If bits alternate, then adjacent bits differ, so XOR with the one-bit right shift yields $111\ldots1$. Conversely, if $x$ is all ones, adjacent bits must have differed. The mask test is a standard identity for all-ones bit patterns.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        x = n ^ (n >> 1)
        return (x & (x + 1)) == 0

# Tests (improved)
s = Solution()
assert s.hasAlternatingBits(5) is True      # 101
assert s.hasAlternatingBits(7) is False     # 111
assert s.hasAlternatingBits(11) is False    # 1011
assert s.hasAlternatingBits(10) is True     # 1010
\end{minted}
\VALIDATION{Covers both alternating (5, 10) and non-alternating (7, 11) cases; also stresses boundary behavior implicitly.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{The bit-identity method $x=n \oplus (n \gg 1)$ with $(x \,\&\, (x+1))=0$ is optimal in constant time and space.}
\ASSUMPTIONS{Applies to any nonnegative integer within machine word size; the input satisfies $1 \le n \le 2^{31}-1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $x \leftarrow n \oplus (n \gg 1)$.
\item Check if $(x \,\&\, (x+1))=0$; return the result.
\item No loops, no branches beyond the final comparison.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect information about the bits; on fixed-width integers this can be done in $O(1)$ using word-level operations. The method is tight with a constant number of operations.}
\COMPLEXITY{Constant time, constant space.}
\[
\begin{aligned}
T(n) &= \Theta(1), \\
S(n) &= \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        x = n ^ (n >> 1)
        return (x & (x + 1)) == 0

# Exactly 3 asserts
s = Solution()
assert s.hasAlternatingBits(1) is True      # 1
assert s.hasAlternatingBits(3) is False     # 11
assert s.hasAlternatingBits(10) is True     # 1010
\end{minted}
\VALIDATION{Three targeted tests: smallest input, a clear negative, and a multi-bit positive.}
\RESULT{Return \texttt{True} iff the binary representation of $n$ alternates ($1010\ldots$ or $0101\ldots$).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify samples; cross-check baseline loop vs optimal bit-trick for a sweep of inputs; test boundary values $1$, $2$, $3$, $2^{k}-1$, $2^{k}$.}
\LINE{CROSS-CHECKS}{For $n$ in a deterministic range, compare outputs of both implementations; any mismatch indicates a bug.}
\LINE{EDGE-CASE GENERATOR}{Generate numbers that are: alternating (e.g., $(1\ll k)-1$ XOR-shifted), all ones ($2^{k}-1$), powers of two, and random within a small bound.}
\begin{minted}{python}
def baseline(n: int) -> bool:
    prev = -1
    while n:
        bit = n & 1
        if bit == prev:
            return False
        prev = bit
        n >>= 1
    return True

def optimal(n: int) -> bool:
    x = n ^ (n >> 1)
    return (x & (x + 1)) == 0

# Cross-check on a deterministic sweep
for n in range(1, 10000):
    assert baseline(n) == optimal(n)

# Boundary checks
for k in range(1, 21):
    n = (1 << k)          # 1000...0
    m = (1 << k) - 1      # 111...1
    assert optimal(n) is True
    assert optimal(m) is (k == 1)  # only 1 is alternating among all-ones

# Reference LeetCode-ready solution with asserts
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        x = n ^ (n >> 1)
        return (x & (x + 1)) == 0

s = Solution()
assert s.hasAlternatingBits(5) is True
assert s.hasAlternatingBits(7) is False
assert s.hasAlternatingBits(11) is False
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        x = n ^ (n >> 1)
        return (x & (x + 1)) == 0

# Self-checks (can be removed before submit)
s = Solution()
assert s.hasAlternatingBits(1) is True
assert s.hasAlternatingBits(2) is True
assert s.hasAlternatingBits(3) is False
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Determine if adjacent bits of $n$ alternate between $0$ and $1$.}
\WHY{Bit-manipulation identities are common in interviews; recognizing XOR and all-ones tests demonstrates fluency with low-level operations.}
\CHECKLIST{
\begin{bullets}
\item Write bits LSB to MSB or use the XOR-shift trick.
\item If scanning, compare current bit to previous and shift right.
\item If using the trick, compute $x=n \oplus (n \gg 1)$ and test $(x \,\&\, (x+1))=0$.
\item Validate key edges: $1$, $2$, $3$, $2^{k}-1$, $2^{k}$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ $\to$ \texttt{True}.
\item $n=2$ ($10_2$) $\to$ \texttt{True}.
\item $n=3$ ($11_2$) $\to$ \texttt{False}.
\item $n=5$ ($101_2$) $\to$ \texttt{True}.
\item $n=7$ ($111_2$) $\to$ \texttt{False}.
\item $n=2^{k}$ ($1000\ldots0_2$) $\to$ \texttt{True}.
\item $n=2^{31}-1$ ($31$ ones) $\to$ \texttt{False}.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to update the previous bit in the scan loop.
\item Using arithmetic division by $2$ instead of right shift on negative numbers (here $n \ge 1$, so safe).
\item Misapplying $(x \,\&\, (x-1))=0$ which tests power-of-two, not all-ones.
\item Off-by-one in constructing test cases like $2^{k}-1$ vs $2^{k}$.
\item Assuming leading zeros matter; they do not in standard binary representation.
\end{bullets}}
\FAILMODES{A naive string-based approach may introduce overhead and mistakes with leading zeros; the bit-trick approach is robust and constant-time.}
\ELI{If a number alternates in binary, XORing it with itself shifted right turns every position into $1$. Then we just check if the result is all ones, which is easy to test with one more bitwise operation.}
\NotePages{3}

\end{document}