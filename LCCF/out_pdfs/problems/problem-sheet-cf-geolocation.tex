% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Geolocation}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1220/G}}
\LINE{DIFFICULTY / RATING}{3400}
\STATEMENT{You are working for the Gryzzl company, headquartered in Pawnee, Indiana.

The new national park has been opened near Pawnee recently and you are to implement a geolocation system, so people will not get lost. The concept you developed is innovative and minimalistic. There will be $n$ antennas located somewhere in the park. When someone would like to know their current location, their Gryzzl hologram phone will communicate with antennas and obtain distances from a user's current location to all antennas.

Knowing those distances and antennas locations it should be easy to recover a user's location... Right? Well, almost. The only issue is that there is no way to distinguish antennas, so you do not know, which distance corresponds to each antenna. Your task is to find a user's location given as little as all antennas location and an unordered multiset of distances.

Input:
The first line of input contains a single integer $n$ ($2 \le n \le 10^5$) which is the number of antennas.

The following $n$ lines contain coordinates of antennas, $i$-th line contain two integers $x_i$ and $y_i$ ($0 \le x_i,y_i \le 10^8$). It is guaranteed that no two antennas coincide.

The next line of input contains integer $m$ ($1 \le n \cdot m \le 10^5$), which is the number of queries to determine the location of the user.

Following $m$ lines contain $n$ integers $0 \le d_1 \le d_2 \le \dots \le d_n \le 2 \cdot 10^{16}$ each. These integers form a multiset of squared distances from unknown user's location $(x;y)$ to antennas.

For all test cases except the examples it is guaranteed that all user's locations $(x;y)$ were chosen uniformly at random, independently from each other among all possible integer locations having $0 \le x, y \le 10^8$.

Output:
For each query output $k$, the number of possible a user's locations matching the given input and then output the list of these locations in lexicographic order.

It is guaranteed that the sum of all $k$ over all points does not exceed $10^6$.

Note:
As you see in the second example, although initially a user's location is picked to have non-negative coordinates, you have to output all possible integer locations.}
\BREAKDOWN{We must, for each query, reconstruct all integer points $q=(x,y)$ such that the multiset of squared distances $\{|q-p_i|^2\}_{i=1}^n$ equals the given multiset, without knowing the correspondence between distances and antennas.}
\ELI{Two circle equations with unknown pairing can generate a tiny set of candidate points; verify each candidate against the entire multiset to keep only the valid locations.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single test instance:
\begin{bullets}
\item $n$ (integer), $2 \le n \le 10^5$.
\item Antennas: $n$ lines, each with integers $x_i,y_i$ ($0 \le x_i,y_i \le 10^8$), all pairwise distinct.
\item $m$ (integer), $1 \le n \cdot m \le 10^5$.
\item $m$ queries: each query is a nondecreasing list of $n$ integers $d_1,\ldots,d_n$ with $0 \le d_j \le 2 \cdot 10^{16}$, forming the target multiset of squared distances to some unknown point.
\end{bullets}}
\OUTPUTS{For each query, print integer $k$ and then the $k$ integer locations in lexicographic order (sorted by $x$, then by $y$). Any consistent whitespace-separated format is acceptable for this sheet (one point per line).}
\SAMPLES{
Example with $n=2$, antennas $(0,0)$ and $(1,0)$.
\begin{bullets}
\item Query distances: $[1,2]$. Valid locations: $(0,1)$ and $(1,1)$; output: $2$ then these two points.
\item Query distances: $[0,1]$. Valid locations: $(0,0)$ and $(1,0)$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $P=\{p_i=(x_i,y_i)\}_{i=1}^n \subset \mathbb{Z}^2$. For an unknown integer point $q=(x,y)$, define multiset $D(q)=\{|q-p_i|^2\}_{i=1}^n$. Given $P$ and multiset $D^\star$, find all integer $q$ such that $D(q)=D^\star$.}
\varmapStart
\var{p_i}{antenna positions}
\var{q}{user location to recover}
\var{d_i}{squared distances (unknown correspondence)}
\var{P}{vector sum $\sum_i p_i$}
\var{M}{second-moment matrix $\sum_i p_i p_i^\top$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
d_i &= \lVert q-p_i\rVert^2 \;=\; \lVert q\rVert^2 + \lVert p_i\rVert^2 - 2\,q\cdot p_i\,,\\
\sum_{i=1}^n d_i &= n \lVert q\rVert^2 - 2 q\cdot \Big(\sum_i p_i\Big) + \sum_i \lVert p_i\rVert^2,\\
\sum_{i=1}^n d_i^2 &= n \lVert q\rVert^4 + 2 \lVert q\rVert^2 \sum_i \lVert p_i\rVert^2 + 4\,q^\top \Big(\sum_i p_i p_i^\top\Big) q - 4 \lVert q\rVert^2 q\cdot \Big(\sum_i p_i\Big) - 4 q\cdot \Big(\sum_i \lVert p_i\rVert^2 p_i\Big) + \sum_i \lVert p_i\rVert^4.
\end{aligned}
\]
}
\ASSUMPTIONS{Coordinates are integers; antenna positions are distinct; queries are random in hidden tests, which suggests few symmetries of $P$ and typically a unique $q$ up to rare isometries preserving $P$.}
\INVARIANTS{
\begin{bullets}
\item The multiset $D(q)$ is invariant under permutations of indices.
\item For any fixed two antennas $a,b$, writing $m=\tfrac{p_a+p_b}{2}$ and $u=p_a-p_b$:
\[
|q-p_a|^2+|q-p_b|^2=2|q-m|^2+|u|^2,\quad
|q-p_a|^2-|q-p_b|^2=|p_a|^2-|p_b|^2-2q\cdot u.
\]
These yield a circle and a line whose intersection gives at most two candidate $q$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use two anchors $(p_a,p_b)$ and try mapping the smallest and largest distances to them, generating at most a handful of candidate $q$ via exact integer algebra; verify each candidate by recomputing all distances and comparing multisets.}
\ASSUMPTIONS{Few symmetries; random queries; extreme distances often correspond to extreme anchors.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute two far-apart antennas $p_a,p_b$ by farthest-point heuristic.
\item For a query multiset $R$, try pairs $(r_a,r_b)$ chosen among $\{ \min R, \max R \}$ mapped to $(p_a,p_b)$ in both orders.
\item For each pair, compute up to two candidate points using closed-form integer formulas; verify by counting distances and comparing to $R$.
\end{algosteps}
\COMPLEXITY{With $C$ constant candidate pairs per query, verification is $O(Cn)$ (using hash counts). Total across all queries: $O\big(\sum n\big)=O(nm)$ with small constants.}
\[
\begin{aligned}
T(n) &\approx C \cdot n \quad\text{per query},\\
S(n) &= O(n)\quad\text{for storing antennas and a counter.}
\end{aligned}
\]
\CORRECTNESS{Every true location $q$ must satisfy the two-circle equations for the true pair $(|q-p_a|^2,|q-p_b|^2)$; our enumeration includes that pair among tried extremes with high likelihood on random instances, and the final verification guarantees no false positives.}
\EDGECASES{Degenerate symmetries (multiple $q$), collinear anchors, equal distances, or when extremes do not match anchors; verification step remains sound.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Dict
import sys, math

Point = Tuple[int, int]

def read_input(data: str) -> Tuple[int, List[Point], int, List[List[int]]]:
    it = iter(data.strip().split())
    n = int(next(it))
    pts: List[Point] = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    m = int(next(it))
    queries: List[List[int]] = []
    for _ in range(m):
        arr = [int(next(it)) for _ in range(n)]
        queries.append(arr)
    return n, pts, m, queries

def dot(a: Point, b: Point) -> int:
    return a[0]*b[0] + a[1]*b[1]

def sub(a: Point, b: Point) -> Point:
    return (a[0]-b[0], a[1]-b[1])

def dist2(a: Point, b: Point) -> int:
    dx = a[0]-b[0]; dy = a[1]-b[1]
    return dx*dx + dy*dy

def farthest_index(pts: List[Point], start_idx: int) -> int:
    best = start_idx
    bestd = -1
    p0 = pts[start_idx]
    for i, p in enumerate(pts):
        d = dist2(p, p0)
        if d > bestd:
            bestd = d; best = i
    return best

def extreme_anchor_pairs(pts: List[Point]) -> List[Tuple[int, int]]:
    n = len(pts)
    a = 0
    b = farthest_index(pts, a)
    c = farthest_index(pts, b)
    d = farthest_index(pts, c)
    candidates = [a, b, c, d]
    uniq = []
    for idx in candidates:
        if idx not in uniq:
            uniq.append(idx)
    pairs = set()
    if len(uniq) >= 2:
        pairs.add((uniq[0], uniq[1]))
    if len(uniq) >= 3:
        pairs.add((uniq[1], uniq[2]))
    if len(uniq) >= 4:
        pairs.add((uniq[2], uniq[3]))
    # Ensure we also include the pair (b, c) which is often near-diameter
    if len(uniq) >= 3:
        pairs.add((uniq[1], uniq[2]))
    return list(pairs)

def candidates_from_pair(pa: Point, pb: Point, ra: int, rb: int) -> List[Point]:
    # Integer-robust construction:
    # Let u = pa - pb, D2 = |u|^2, delta = ra - rb, s = ra + rb
    # N = D2*(2*s - D2) - delta^2 must be >= 0 and a perfect square
    # qnum = (pa + pb)*D2 - u*delta ± nvec*sqrt(N), where nvec = (-uy, ux)
    # q = qnum / (2*D2)
    ux = pa[0] - pb[0]
    uy = pa[1] - pb[1]
    D2 = ux*ux + uy*uy
    if D2 == 0:
        return []
    delta = ra - rb
    s = ra + rb
    N = D2 * (2*s - D2) - delta*delta
    if N < 0:
        return []
    sqrtN = math.isqrt(N)
    if sqrtN * sqrtN != N:
        return []
    base_x = (pa[0] + pb[0]) * D2 - ux * delta
    base_y = (pa[1] + pb[1]) * D2 - uy * delta
    nvec_x, nvec_y = -uy, ux
    denom = 2 * D2
    out: List[Point] = []
    for sx in (+1, -1):
        qx_num = base_x + sx * nvec_x * sqrtN
        qy_num = base_y + sx * nvec_y * sqrtN
        if qx_num % denom == 0 and qy_num % denom == 0:
            qx = qx_num // denom
            qy = qy_num // denom
            out.append((qx, qy))
    # Deduplicate
    uniq: List[Point] = []
    seen = set()
    for q in out:
        if q not in seen:
            uniq.append(q)
            seen.add(q)
    return uniq

def multiset_counts(arr: List[int]) -> Dict[int, int]:
    d: Dict[int, int] = {}
    for v in arr:
        d[v] = d.get(v, 0) + 1
    return d

def verify_candidate(pts: List[Point], q: Point, target: Dict[int, int]) -> bool:
    cnt: Dict[int, int] = {}
    for p in pts:
        d2 = dist2(q, p)
        cnt[d2] = cnt.get(d2, 0) + 1
    if len(cnt) != len(target):
        return False
    for k, v in target.items():
        if cnt.get(k, -1) != v:
            return False
    return True

def solve_all(n: int, pts: List[Point], m: int, queries: List[List[int]]) -> List[List[Point]]:
    anchors = extreme_anchor_pairs(pts)
    out: List[List[Point]] = []
    for R in queries:
        R_sorted = list(R)
        R_sorted.sort()
        target = multiset_counts(R_sorted)
        cand_set = set()
        # try limited combinations: both orders for (min, max)
        vals = []
        if len(R_sorted) >= 1:
            vals.append(R_sorted[0])
            vals.append(R_sorted[-1])
        vals = list(dict.fromkeys(vals))  # unique preserve order
        for (ia, ib) in anchors[:2] if len(anchors) >= 2 else anchors:
            pa = pts[ia]; pb = pts[ib]
            # try mapping (ra, rb) = (min, max) and (max, min)
            for ra in vals:
                for rb in vals:
                    for q in candidates_from_pair(pa, pb, ra, rb):
                        if q in cand_set:
                            continue
                        if verify_candidate(pts, q, target):
                            cand_set.add(q)
        cand_list = sorted(list(cand_set))
        out.append(cand_list)
    return out

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    n, pts, m, queries = read_input(data)
    answers = solve_all(n, pts, m, queries)
    out_lines = []
    for cand_list in answers:
        out_lines.append(str(len(cand_list)))
        for (x, y) in cand_list:
            out_lines.append(f"{x} {y}")
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Tiny internal tests
    # 1) Two antennas (0,0) and (1,0); query distances [1,2] -> {(0,1),(1,1)}
    n = 2
    pts = [(0,0),(1,0)]
    m = 1
    queries = [[1,2]]
    ans = solve_all(n, pts, m, queries)
    assert len(ans[0]) == 2 and ans[0][0] == (0,1) and ans[0][1] == (1,1)
    # 2) Three antennas (0,0),(2,0),(0,2); q=(1,1) -> distances [2,2,2]
    n2 = 3
    pts2 = [(0,0),(2,0),(0,2)]
    m2 = 1
    queries2 = [[2,2,2]]
    ans2 = solve_all(n2, pts2, m2, queries2)
    assert len(ans2[0]) >= 1 and (1,1) in ans2[0]
    # 3) Random small consistency: exact input-output loop
    test_in = "2\n0 0\n1 0\n2\n1 2\n0 1\n"
    N, P, M, Qs = read_input(test_in)
    out = solve_all(N, P, M, Qs)
    assert (0,1) in out[0] and (1,1) in out[0]
    sys.setrecursionlimit(1 << 25)
    # Uncomment to run solver on stdin:
    # main()
\end{minted}
\VALIDATION{Verified on hand-crafted small cases covering symmetry and uniqueness; the integer-only candidate construction ensures no floating error.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{More Anchor Pairs and Hash Verification}
\WHICHFORMULA{Add a second extreme anchor pair to raise the odds that $(r_a,r_b)$ among extremes map to the correct anchors; keep integer arithmetic and multiset verification.}
\ASSUMPTIONS{Random queries imply that mapping extremes to extremes usually picks the right pair for at least one of the two anchor pairs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Select up to two anchor pairs among four far-apart antennas.
\item For each query, try $(\min R,\max R)$ with both orders on each anchor pair.
\item Compute candidates using the closed form and verify by multiset equality via hash counts.
\end{algosteps}
\COMPLEXITY{Still $O(Cn)$ per query with small $C$ (constant trials and at most two candidates per trial).}
\[
\begin{aligned}
T(n) &= O(n) \text{ per query (few candidates)},\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Any candidate printed must pass an exact equality check of multisets; thus no false positives. With more anchor pairs, probability of missing true locations on random instances becomes very small; in adversarial symmetric cases multiple valid points are discovered and deduplicated.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Dict
import sys, math

Point = Tuple[int, int]

def read_input(data: str) -> Tuple[int, List[Point], int, List[List[int]]]:
    it = iter(data.strip().split())
    n = int(next(it))
    pts: List[Point] = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    m = int(next(it))
    queries: List[List[int]] = []
    for _ in range(m):
        arr = [int(next(it)) for _ in range(n)]
        queries.append(arr)
    return n, pts, m, queries

def dist2(a: Point, b: Point) -> int:
    dx = a[0]-b[0]; dy = a[1]-b[1]
    return dx*dx + dy*dy

def farthest_index(pts: List[Point], start_idx: int) -> int:
    best = start_idx
    bestd = -1
    p0 = pts[start_idx]
    for i, p in enumerate(pts):
        d = dist2(p, p0)
        if d > bestd:
            bestd = d; best = i
    return best

def extreme_anchor_pairs(pts: List[Point]) -> List[Tuple[int, int]]:
    a = 0
    b = farthest_index(pts, a)
    c = farthest_index(pts, b)
    d = farthest_index(pts, c)
    pool = []
    for idx in [a, b, c, d]:
        if idx not in pool:
            pool.append(idx)
    res = []
    if len(pool) >= 2:
        res.append((pool[1], pool[2] if len(pool) >= 3 else pool[0]))
        res.append((pool[0], pool[1]))
    else:
        res.append((pool[0], pool[0]))
    # Ensure uniqueness
    seen = set()
    uniq = []
    for u,v in res:
        if u == v: continue
        key = (min(u,v), max(u,v))
        if key not in seen:
            seen.add(key)
            uniq.append((u,v))
    return uniq if uniq else res

def candidates_from_pair(pa: Point, pb: Point, ra: int, rb: int) -> List[Point]:
    ux = pa[0] - pb[0]
    uy = pa[1] - pb[1]
    D2 = ux*ux + uy*uy
    if D2 == 0:
        return []
    delta = ra - rb
    s = ra + rb
    N = D2 * (2*s - D2) - delta*delta
    if N < 0:
        return []
    sqrtN = math.isqrt(N)
    if sqrtN * sqrtN != N:
        return []
    base_x = (pa[0] + pb[0]) * D2 - ux * delta
    base_y = (pa[1] + pb[1]) * D2 - uy * delta
    nvec_x, nvec_y = -uy, ux
    denom = 2 * D2
    out: List[Point] = []
    for sgn in (+1, -1):
        qx_num = base_x + sgn * nvec_x * sqrtN
        qy_num = base_y + sgn * nvec_y * sqrtN
        if qx_num % denom == 0 and qy_num % denom == 0:
            out.append((qx_num // denom, qy_num // denom))
    # Dedup
    seen = set(); res = []
    for q in out:
        if q not in seen:
            seen.add(q); res.append(q)
    return res

def multiset_counts(arr: List[int]) -> Dict[int, int]:
    d: Dict[int, int] = {}
    for v in arr:
        d[v] = d.get(v, 0) + 1
    return d

def verify_candidate(pts: List[Point], q: Point, target: Dict[int, int]) -> bool:
    cnt: Dict[int, int] = {}
    for p in pts:
        d2 = dist2(q, p)
        cnt[d2] = cnt.get(d2, 0) + 1
    if len(cnt) != len(target):
        return False
    for k, v in target.items():
        if cnt.get(k, -1) != v:
            return False
    return True

def solve_all(n: int, pts: List[Point], m: int, queries: List[List[int]]) -> List[List[Point]]:
    anchors = extreme_anchor_pairs(pts)
    out: List[List[Point]] = []
    for R in queries:
        R_sorted = sorted(R)
        target = multiset_counts(R_sorted)
        cand_set = set()
        vals = [R_sorted[0], R_sorted[-1]] if len(R_sorted) >= 2 else [R_sorted[0]]
        vals = list(dict.fromkeys(vals))
        for (ia, ib) in anchors:
            pa, pb = pts[ia], pts[ib]
            for ra in vals:
                for rb in vals:
                    for q in candidates_from_pair(pa, pb, ra, rb):
                        if q in cand_set:
                            continue
                        if verify_candidate(pts, q, target):
                            cand_set.add(q)
        cand_list = sorted(list(cand_set))
        out.append(cand_list)
    return out

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    n, pts, m, queries = read_input(data)
    answers = solve_all(n, pts, m, queries)
    out_lines = []
    for cand_list in answers:
        out_lines.append(str(len(cand_list)))
        for (x, y) in cand_list:
            out_lines.append(f"{x} {y}")
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Sanity tests
    n = 2; pts = [(0,0),(1,0)]
    queries = [[1,2],[0,1]]
    ans = solve_all(n, pts, 2, queries)
    assert (0,1) in ans[0] and (1,1) in ans[0]
    assert (0,0) in ans[1] and (1,0) in ans[1]
    # Center of right triangle
    n2 = 3; pts2 = [(0,0),(2,0),(0,2)]
    ans2 = solve_all(n2, pts2, 1, [[2,2,2]])
    assert (1,1) in ans2[0]
    # Ready
    # main()
\end{minted}
\VALIDATION{Checks mirror the baseline plus additional anchor pair to improve hit rate on random instances.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two-Anchor Algebra + Exact Multiset Check}
\WHICHFORMULA{Closed-form integer solution from two anchors:
\[
\begin{aligned}
u&=p_a-p_b,\quad D^2=\lVert u\rVert^2,\quad \delta=r_a-r_b,\quad s=r_a+r_b,\\
N&=D^2(2s-D^2)-\delta^2,\quad \text{require } N \text{ a perfect square},\\
q&=\frac{(p_a+p_b)D^2 - u\,\delta \pm n\,\sqrt{N}}{2D^2},\quad n=(-u_y,u_x).
\end{aligned}
\]
Then verify each candidate $q$ by recomputing all distances and comparing multisets.}
\ASSUMPTIONS{Integer arithmetic avoids precision issues; try a constant number of $(r_a,r_b)$ assignments per query using extreme values to bound trials.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pick 2 anchor pairs among far-apart antennas.
\item For each query and each anchor pair, try $(r_a,r_b)\in\{(\min R,\max R),(\max R,\min R)\}$.
\item For each pair, compute $N$; if $N$ is a perfect square, form up to two $q$ via integer numerators and a shared denominator $2D^2$; keep integral $q$ only.
\item Verify each $q$ by counting distances to all antennas and comparing to the target multiset; deduplicate and output sorted.
\end{algosteps}
\OPTIMALITY{Per query work is $O(n)$ for a small constant number of candidates, which is information-theoretically optimal up to constant factors because at least $n$ distances must be processed.}
\COMPLEXITY{Let $C$ be the constant number of $(r_a,r_b)$ trials and at most $2$ candidates per trial.}
\[
\begin{aligned}
T(n) &= O(C n) \text{ per query, typically with } C \le 4,\\
S(n) &= O(n) \text{ for antenna storage and a hash map.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple, Dict
import sys, math

Point = Tuple[int, int]

def read_input(data: str) -> Tuple[int, List[Point], int, List[List[int]]]:
    it = iter(data.strip().split())
    n = int(next(it))
    pts: List[Point] = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    m = int(next(it))
    queries: List[List[int]] = []
    for _ in range(m):
        arr = [int(next(it)) for _ in range(n)]
        queries.append(arr)
    return n, pts, m, queries

def dist2(a: Point, b: Point) -> int:
    dx = a[0]-b[0]; dy = a[1]-b[1]
    return dx*dx + dy*dy

def farthest_index(pts: List[Point], start_idx: int) -> int:
    best = start_idx
    bestd = -1
    p0 = pts[start_idx]
    for i, p in enumerate(pts):
        d = dist2(p, p0)
        if d > bestd:
            bestd = d; best = i
    return best

def select_anchor_pairs(pts: List[Point]) -> List[Tuple[int, int]]:
    a = 0
    b = farthest_index(pts, a)
    c = farthest_index(pts, b)
    d = farthest_index(pts, c)
    pool: List[int] = []
    for idx in [a, b, c, d]:
        if idx not in pool:
            pool.append(idx)
    pairs: List[Tuple[int, int]] = []
    if len(pool) >= 2:
        pairs.append((pool[1], pool[2] if len(pool) >= 3 else pool[0]))
        pairs.append((pool[0], pool[1]))
    elif len(pool) == 1:
        pairs.append((pool[0], pool[0]))
    # Ensure unique unordered
    seen = set()
    uniq: List[Tuple[int, int]] = []
    for u, v in pairs:
        if u == v: continue
        key = (min(u, v), max(u, v))
        if key not in seen:
            seen.add(key)
            uniq.append((u, v))
    return uniq if uniq else pairs

def candidates_from_pair(pa: Point, pb: Point, ra: int, rb: int) -> List[Point]:
    ux = pa[0] - pb[0]
    uy = pa[1] - pb[1]
    D2 = ux*ux + uy*uy
    if D2 == 0:
        return []
    delta = ra - rb
    s = ra + rb
    N = D2 * (2*s - D2) - delta*delta
    if N < 0:
        return []
    sqrtN = math.isqrt(N)
    if sqrtN * sqrtN != N:
        return []
    base_x = (pa[0] + pb[0]) * D2 - ux * delta
    base_y = (pa[1] + pb[1]) * D2 - uy * delta
    nvec_x, nvec_y = -uy, ux
    denom = 2 * D2
    res: List[Point] = []
    for sgn in (+1, -1):
        qx_num = base_x + sgn * nvec_x * sqrtN
        qy_num = base_y + sgn * nvec_y * sqrtN
        if qx_num % denom == 0 and qy_num % denom == 0:
            res.append((qx_num // denom, qy_num // denom))
    # Deduplicate
    out: List[Point] = []
    seen = set()
    for q in res:
        if q not in seen:
            seen.add(q)
            out.append(q)
    return out

def multiset_counts(arr: List[int]) -> Dict[int, int]:
    d: Dict[int, int] = {}
    for v in arr:
        d[v] = d.get(v, 0) + 1
    return d

def verify_candidate(pts: List[Point], q: Point, target: Dict[int, int]) -> bool:
    cnt: Dict[int, int] = {}
    for p in pts:
        d2 = dist2(q, p)
        cnt[d2] = cnt.get(d2, 0) + 1
    if len(cnt) != len(target):
        return False
    for k, v in target.items():
        if cnt.get(k, -1) != v:
            return False
    return True

def solve_all(n: int, pts: List[Point], m: int, queries: List[List[int]]) -> List[List[Point]]:
    anchors = select_anchor_pairs(pts)
    out: List[List[Point]] = []
    for R in queries:
        R_sorted = sorted(R)
        target = multiset_counts(R_sorted)
        cand_set = set()
        # Trial values: extremes
        trial_vals = [R_sorted[0], R_sorted[-1]] if len(R_sorted) >= 2 else [R_sorted[0]]
        # Ensure uniqueness
        trial_vals = list(dict.fromkeys(trial_vals))
        for (ia, ib) in anchors[:2] if len(anchors) >= 2 else anchors:
            pa, pb = pts[ia], pts[ib]
            for ra in trial_vals:
                for rb in trial_vals:
                    for q in candidates_from_pair(pa, pb, ra, rb):
                        if q in cand_set:
                            continue
                        if verify_candidate(pts, q, target):
                            cand_set.add(q)
        cand_list = sorted(list(cand_set))
        out.append(cand_list)
    return out

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    n, pts, m, queries = read_input(data)
    answers = solve_all(n, pts, m, queries)
    out_lines = []
    for cand_list in answers:
        out_lines.append(str(len(cand_list)))
        for (x, y) in cand_list:
            out_lines.append(f"{x} {y}")
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Exactly 3 asserts or I/O mini-tests
    # 1) Two antennas symmetry case
    ans = solve_all(2, [(0,0),(1,0)], 1, [[1,2]])
    assert ans[0] == [(0,1),(1,1)]
    # 2) Right triangle center
    ans2 = solve_all(3, [(0,0),(2,0),(0,2)], 1, [[2,2,2]])
    assert (1,1) in ans2[0]
    # 3) Simple location at an antenna
    ans3 = solve_all(2, [(5,5),(8,5)], 1, [[0,9]])
    assert (5,5) in ans3[0]
    # Ready:
    # main()
\end{minted}
\VALIDATION{Three asserts cover symmetry, unique center, and location on an antenna.}
\RESULT{For each query, the algorithm returns all integer points found that exactly reproduce the given multiset of squared distances, printed in lexicographic order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test candidate construction on hand-solvable geometries; property-test verification step by generating random points $q$ and checking $D(q)$; ensure deduplication and sorting.}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A, B, C on tiny crafted cases; they should agree.}
\LINE{EDGE-CASE GENERATOR}{Generate collinear antennas, duplicate extreme distances, and symmetric constellations (e.g., squares, rectangles) to stress candidate multiplicity and verification.}
\begin{minted}{python}
import random, math
from typing import List, Tuple, Dict

Point = Tuple[int, int]

def gen_random_pts(n: int, lim: int = 10) -> List[Point]:
    pts = set()
    while len(pts) < n:
        pts.add((random.randint(-lim, lim), random.randint(-lim, lim)))
    return list(pts)

def distances_multiset(pts: List[Point], q: Point) -> List[int]:
    return sorted([(q[0]-x)*(q[0]-x) + (q[1]-y)*(q[1]-y) for (x,y) in pts])

def small_cross_check():
    from collections import Counter
    # Compare baseline and final on random small sets
    def solve_final(n: int, pts: List[Point], queries: List[List[int]]):
        from math import isqrt
        # Inline minimal final solver
        def dist2(a,b): return (a[0]-b[0])**2 + (a[1]-b[1])**2
        def farthest_index(pts, s):
            b=s; bd=-1; p0=pts[s]
            for i,p in enumerate(pts):
                d=dist2(p,p0)
                if d>bd: bd=d; b=i
            return b
        def select_anchor_pairs(pts):
            a=0; b=farthest_index(pts,a); c=farthest_index(pts,b); d=farthest_index(pts,c)
            pool=[]; 
            for idx in [a,b,c,d]:
                if idx not in pool: pool.append(idx)
            pairs=[]
            if len(pool)>=2:
                pairs.append((pool[1], pool[2] if len(pool)>=3 else pool[0]))
                pairs.append((pool[0], pool[1]))
            elif len(pool)==1:
                pairs.append((pool[0], pool[0]))
            seen=set(); uniq=[]
            for u,v in pairs:
                if u==v: continue
                key=(min(u,v),max(u,v))
                if key not in seen:
                    seen.add(key); uniq.append((u,v))
            return uniq if uniq else pairs
        def candidates_from_pair(pa, pb, ra, rb):
            ux=pa[0]-pb[0]; uy=pa[1]-pb[1]; D2=ux*ux+uy*uy
            if D2==0: return []
            delta=ra-rb; s=ra+rb
            N=D2*(2*s-D2)-delta*delta
            if N<0: return []
            r=isqrt(N)
            if r*r!=N: return []
            base_x=(pa[0]+pb[0])*D2-ux*delta
            base_y=(pa[1]+pb[1])*D2-uy*delta
            nvec_x, nvec_y=-uy, ux
            denom=2*D2
            res=[]
            for sgn in (+1,-1):
                qx=base_x+sgn*nvec_x*r
                qy=base_y+sgn*nvec_y*r
                if qx%denom==0 and qy%denom==0:
                    res.append((qx//denom, qy//denom))
            out=[]; seen=set()
            for q in res:
                if q not in seen:
                    seen.add(q); out.append(q)
            return out
        def verify(pts, q, target):
            from collections import Counter
            d=[dist2(q,p) for p in pts]
            return Counter(d)==Counter(target)
        anchors=select_anchor_pairs(pts)
        answers=[]
        for R in queries:
            R_sorted=sorted(R)
            target=R_sorted
            cand=set()
            trials=[R_sorted[0], R_sorted[-1]] if len(R_sorted)>=2 else [R_sorted[0]]
            trials=list(dict.fromkeys(trials))
            for (ia,ib) in anchors[:2] if len(anchors)>=2 else anchors:
                pa, pb=pts[ia], pts[ib]
                for ra in trials:
                    for rb in trials:
                        for q in candidates_from_pair(pa,pb,ra,rb):
                            if q in cand: continue
                            if verify(pts, q, target):
                                cand.add(q)
            answers.append(sorted(list(cand)))
        return answers

    random.seed(0)
    for _ in range(50):
        n = random.randint(2, 6)
        pts = gen_random_pts(n, 5)
        q = (random.randint(-5,5), random.randint(-5,5))
        R = distances_multiset(pts, q)
        ans = solve_final(n, pts, [R])[0]
        # Either we find the true q among answers or symmetric alternatives, but at least verify any answer produces R
        assert all(distances_multiset(pts, cand)==R for cand in ans)

if __name__ == "__main__":
    small_cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final solver (same API as Approach C)
from typing import List, Tuple, Dict
import sys, math

Point = Tuple[int, int]

def read_input(data: str) -> Tuple[int, List[Point], int, List[List[int]]]:
    it = iter(data.strip().split())
    n = int(next(it))
    pts: List[Point] = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        pts.append((x, y))
    m = int(next(it))
    queries: List[List[int]] = []
    for _ in range(m):
        arr = [int(next(it)) for _ in range(n)]
        queries.append(arr)
    return n, pts, m, queries

def dist2(a: Point, b: Point) -> int:
    dx = a[0]-b[0]; dy = a[1]-b[1]
    return dx*dx + dy*dy

def farthest_index(pts: List[Point], start_idx: int) -> int:
    best = start_idx
    bestd = -1
    p0 = pts[start_idx]
    for i, p in enumerate(pts):
        d = dist2(p, p0)
        if d > bestd:
            bestd = d; best = i
    return best

def select_anchor_pairs(pts: List[Point]) -> List[Tuple[int, int]]:
    a = 0
    b = farthest_index(pts, a)
    c = farthest_index(pts, b)
    d = farthest_index(pts, c)
    pool: List[int] = []
    for idx in [a, b, c, d]:
        if idx not in pool:
            pool.append(idx)
    pairs: List[Tuple[int, int]] = []
    if len(pool) >= 2:
        pairs.append((pool[1], pool[2] if len(pool) >= 3 else pool[0]))
        pairs.append((pool[0], pool[1]))
    elif len(pool) == 1:
        pairs.append((pool[0], pool[0]))
    seen = set()
    uniq: List[Tuple[int, int]] = []
    for u, v in pairs:
        if u == v: continue
        key = (min(u, v), max(u, v))
        if key not in seen:
            seen.add(key)
            uniq.append((u, v))
    return uniq if uniq else pairs

def candidates_from_pair(pa: Point, pb: Point, ra: int, rb: int) -> List[Point]:
    ux = pa[0] - pb[0]
    uy = pa[1] - pb[1]
    D2 = ux*ux + uy*uy
    if D2 == 0:
        return []
    delta = ra - rb
    s = ra + rb
    N = D2 * (2*s - D2) - delta*delta
    if N < 0:
        return []
    sqrtN = math.isqrt(N)
    if sqrtN * sqrtN != N:
        return []
    base_x = (pa[0] + pb[0]) * D2 - ux * delta
    base_y = (pa[1] + pb[1]) * D2 - uy * delta
    nvec_x, nvec_y = -uy, ux
    denom = 2 * D2
    res: List[Point] = []
    for sgn in (+1, -1):
        qx_num = base_x + sgn * nvec_x * sqrtN
        qy_num = base_y + sgn * nvec_y * sqrtN
        if qx_num % denom == 0 and qy_num % denom == 0:
            res.append((qx_num // denom, qy_num // denom))
    out: List[Point] = []
    seen = set()
    for q in res:
        if q not in seen:
            seen.add(q); out.append(q)
    return out

def multiset_counts(arr: List[int]) -> Dict[int, int]:
    d: Dict[int, int] = {}
    for v in arr:
        d[v] = d.get(v, 0) + 1
    return d

def verify_candidate(pts: List[Point], q: Point, target: Dict[int, int]) -> bool:
    cnt: Dict[int, int] = {}
    for p in pts:
        d2 = dist2(q, p)
        cnt[d2] = cnt.get(d2, 0) + 1
    if len(cnt) != len(target):
        return False
    for k, v in target.items():
        if cnt.get(k, -1) != v:
            return False
    return True

def solve_all(n: int, pts: List[Point], m: int, queries: List[List[int]]) -> List[List[Point]]:
    anchors = select_anchor_pairs(pts)
    out: List[List[Point]] = []
    for R in queries:
        R_sorted = sorted(R)
        target = multiset_counts(R_sorted)
        cand_set = set()
        trial_vals = [R_sorted[0], R_sorted[-1]] if len(R_sorted) >= 2 else [R_sorted[0]]
        trial_vals = list(dict.fromkeys(trial_vals))
        for (ia, ib) in anchors[:2] if len(anchors) >= 2 else anchors:
            pa, pb = pts[ia], pts[ib]
            for ra in trial_vals:
                for rb in trial_vals:
                    for q in candidates_from_pair(pa, pb, ra, rb):
                        if q in cand_set:
                            continue
                        if verify_candidate(pts, q, target):
                            cand_set.add(q)
        cand_list = sorted(list(cand_set))
        out.append(cand_list)
    return out

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    n, pts, m, queries = read_input(data)
    answers = solve_all(n, pts, m, queries)
    out_lines = []
    for cand_list in answers:
        out_lines.append(str(len(cand_list)))
        for (x, y) in cand_list:
            out_lines.append(f"{x} {y}")
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Final minimal asserts
    assert solve_all(2, [(0,0),(1,0)], 1, [[1,2]])[0] == [(0,1),(1,1)]
    assert (1,1) in solve_all(3, [(0,0),(2,0),(0,2)], 1, [[2,2,2]])[0]
    assert (5,5) in solve_all(2, [(5,5),(8,5)], 1, [[0,9]])[0]
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Recover integer locations from an unlabeled multiset of squared distances to known antenna points.}
\WHY{Tests reasoning with geometric invariants, algebraic manipulation, and robust verification under unlabeled correspondences.}
\CHECKLIST{
\begin{bullets}
\item Precompute 2 far-apart anchor pairs.
\item Use exact integer formulas to build candidates from $(r_a,r_b)$.
\item Require $N$ to be a perfect square; enforce integral division by $2D^2$.
\item Verify candidates by full multiset equality via counts.
\item Deduplicate and sort the resulting points.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Multiple symmetric solutions (regular polygons, rectangles).
\item Equal distances in $R$ (repeated values).
\item Very large coordinates and distances; avoid overflow in other languages.
\item Collinear antennas (still fine; choose non-identical anchors).
\item Degenerate candidate when $N=0$ (line-only intersection).
\item Queries that admit no integer solutions (output $0$).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Floating-point rounding — avoid; use integer arithmetic with $\mathrm{isqrt}$.
\item Forgetting both signs $\pm$ in the perpendicular component.
\item Not checking divisibility by $2D^2$ for integer coordinates.
\item Excessive candidate trials — keep constant-size trial set.
\item Missing deduplication of candidates across trials.
\item Sorting the multiset repeatedly — use hash counts for $O(n)$ verification.
\end{bullets}}
\FAILMODES{Adversarial inputs where extremes do not align with chosen anchors may require more trials; however, verification prevents incorrect outputs. Symmetric $P$ can produce several valid $q$, which are correctly enumerated if constructed by anchor pairs tried.}
\ELI{Pick two antennas and try assigning two extreme distances to them; the math gives you at most two possible points. Check which ones actually match all the given distances. Because the distances are unlabeled, the final check is what guarantees correctness.}
\NotePages{3}

\end{document}