% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Nora's Toy Boxes}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1292/F}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{Back in time, the seven-year-old Nora used to play lots of games with her creation ROBO\_Head-02, both to have fun and enhance his abilities.

One day, Nora's adoptive father, Phoenix Wyle, brought Nora $n$ boxes of toys. Before unpacking, Nora decided to make a fun game for ROBO.

She labelled all $n$ boxes with $n$ distinct integers $a_1, a_2, \ldots, a_n$ and asked ROBO to do the following action several (possibly zero) times:
\begin{bullets}
\item Pick three distinct indices $i$, $j$ and $k$, such that $a_i \mid a_j$ and $a_i \mid a_k$. In other words, $a_i$ divides both $a_j$ and $a_k$, that is $a_j \bmod a_i = 0$, $a_k \bmod a_i = 0$.
\item After choosing, Nora will give the $k$-th box to ROBO, and he will place it on top of the box pile at his side. Initially, the pile is empty.
\item After doing so, the box $k$ becomes unavailable for any further actions.
\end{bullets}

Being amused after nine different tries of the game, Nora asked ROBO to calculate the number of possible different piles having the largest amount of boxes in them. Two piles are considered different if there exists a position where those two piles have different boxes.

Since ROBO was still in his infant stages, and Nora was still too young to concentrate for a long time, both fell asleep before finding the final answer. Can you help them?

As the number of such piles can be very large, you should print the answer modulo $10^9 + 7$.

Input:
The first line contains an integer $n$ ($3 \le n \le 60$), denoting the number of boxes.

The second line contains $n$ distinct integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 60$), where $a_i$ is the label of the $i$-th box.

Output:
Print the number of distinct piles having the maximum number of boxes that ROBO\_Head can have, modulo $10^9 + 7$.

Note:
Let's illustrate the box pile as a sequence $b$, with the pile's bottommost box being at the leftmost position.

In the first example, there are $2$ distinct piles possible:
\begin{bullets}
\item $b = [6]$ ($[2, \mathbf{6}, 8] \xrightarrow{(1, 3, 2)} [2, 8]$)
\item $b = [8]$ ($[2, 6, \mathbf{8}] \xrightarrow{(1, 2, 3)} [2, 6]$)
\end{bullets}

In the second example, there are $4$ distinct piles possible:
\begin{bullets}
\item $b = [9, 12]$ ($[2, 3, 4, \mathbf{9}, 12] \xrightarrow{(2, 5, 4)} [2, 3, 4, \mathbf{12}] \xrightarrow{(1, 3, 4)} [2, 3, 4]$)
\item $b = [4, 12]$ ($[2, 3, \mathbf{4}, 9, 12] \xrightarrow{(1, 5, 3)} [2, 3, 9, \mathbf{12}] \xrightarrow{(2, 3, 4)} [2, 3, 9]$)
\item $b = [4, 9]$ ($[2, 3, \mathbf{4}, 9, 12] \xrightarrow{(1, 5, 3)} [2, 3, \mathbf{9}, 12] \xrightarrow{(2, 4, 3)} [2, 3, 12]$)
\item $b = [9, 4]$ ($[2, 3, 4, \mathbf{9}, 12] \xrightarrow{(2, 5, 4)} [2, 3, \mathbf{4}, 12] \xrightarrow{(1, 4, 3)} [2, 3, 12]$)
\end{bullets}

In the third sequence, ROBO can do nothing at all. Therefore, there is only $1$ valid pile, and that pile is empty.}
\BREAKDOWN{We must:
\begin{bullets}
\item Model the operation as removing one element $k$ given a witness $i$ that divides two distinct remaining elements.
\item Determine the maximum number of removals possible (pile height).
\item Count, modulo $10^9+7$, the number of removal sequences that achieve this maximum.
\end{bullets}}
\ELI{Keep removing any box $k$ that shares at least one common divisor-box $i$ with another box $j$, and count how many longest possible removal orders there are.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One integer $n$ with $3 \le n \le 60$, followed by $n$ distinct integers $a_1,\ldots,a_n$ with $1 \le a_i \le 60$.}
\OUTPUTS{A single integer: the number of distinct maximum-height piles modulo $10^9+7$.}
\SAMPLES{
Example-like sanity checks:
\begin{bullets}
\item $n=3$, $[2,6,8] \to 2$ (piles $[6]$ or $[8]$).
\item $n=5$, $[2,3,4,9,12] \to 4$ (four piles of height $2$).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{1,\ldots,n\}$ index the boxes. Define a DAG $G$ on $V$ with edge $i\to j$ iff $a_j \bmod a_i=0$ and $i\ne j$. A game state is a subset $S\subseteq V$ of remaining indices. A move chooses distinct $i,j,k\in S$ with $i\to j$ and $i\to k$, then removes $k$ from $S$ (and appends $k$ to the pile top).}
\varmapStart
\var{V}{set of indices of boxes}
\var{S}{current remaining set}
\var{G}{divisibility DAG on $V$}
\var{M_i(S)}{the set $\{x\in S\setminus\{i\}: a_x \bmod a_i=0\}$}
\var{H(S)}{maximum achievable pile height from state $S$}
\var{C(S)}{number of sequences achieving $H(S)$ from $S$, modulo $10^9+7$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Move condition: }& \exists i\in S\; \text{such that } |M_i(S)|\ge 2.\\
\text{Transition: }& S' = S\setminus\{k\}\ \text{for some $k$ that participates in a valid triple $(i,j,k)$}.\\
H(S) &= \begin{cases}
0, & \text{if no move is possible on }S,\\
1+\max\limits_{k\in \mathcal{R}(S)} H(S\setminus\{k\}), & \text{otherwise,}
\end{cases}\\
C(S) &= \begin{cases}
1, & \text{if no move is possible on }S,\\
\sum\limits_{\substack{k\in \mathcal{R}(S)\\H(S\setminus\{k\})=H(S)-1}} C(S\setminus\{k\}) \bmod (10^9+7), & \text{otherwise,}
\end{cases}
\end{aligned}
\]
where $\mathcal{R}(S)=\{k\in S:\ \exists i\in S\setminus\{k\},\ \exists j\in S\setminus\{i,k\},\ a_j \bmod a_i=0,\ a_k \bmod a_i=0\}$ is the set of removable indices at $S$.}
\ASSUMPTIONS{Values $a_i$ are distinct. Divisibility induces an acyclic partial order since $a_i\ne a_j$ and $a_i\mid a_j$ cannot form cycles.}
\INVARIANTS{
\begin{bullets}
\item The pile length equals the number of removals performed.
\item When no move is possible, every $i\in S$ satisfies $|M_i(S)|\le 1$.
\item Each move strictly decreases $|S|$, so the process terminates.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use direct DFS over all valid removal sequences; track the maximum height and count sequences achieving it.}
\ASSUMPTIONS{State represented by a bitmask over $n$ positions. Precompute divisibility relations to check move validity quickly.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency lists: for each $i$, the set of indices $j$ with $a_j \bmod a_i = 0$.
\item Given a state $S$, compute removable set $\mathcal{R}(S)$: those $k$ for which there exists $i$ with at least two multiples in $S$, including $k$.
\item Recurse by removing each $k\in \mathcal{R}(S)$, accumulating best height and counts; if no move, return $(0,1)$.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ in the worst case; the baseline explores many states without caching.}
\[
\begin{aligned}
T(n) &\in \Theta(b^n)\ \text{in the worst case (branching factor $b$ depends on structure).}\\
S(n) &\in O(n)\ \text{recursion depth}.
\end{aligned}
\]
\CORRECTNESS{By structural recursion: any optimal sequence starts with removing some valid $k$; we try all such $k$ and add one to the optimal height of the subproblem. Base case returns one empty sequence.}
\EDGECASES{
\begin{bullets}
\item No valid move initially $\Rightarrow$ answer is $1$ (empty pile).
\item Highly composite numbers increase branching; baseline still enumerates all.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Dict, Set

MOD = 10**9 + 7

def read_input() -> Tuple[int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def build_divisibility(a: List[int]) -> Tuple[List[int], List[int]]:
    n = len(a)
    multiples_mask = [0]*n
    divisors_mask = [0]*n
    for i in range(n):
        for j in range(n):
            if i != j and a[j] % a[i] == 0:
                multiples_mask[i] |= (1 << j)
                divisors_mask[j] |= (1 << i)
    return multiples_mask, divisors_mask

def removable_set(mask: int, multiples_mask: List[int]) -> int:
    """Return a bitmask of k that can be removed from current state mask."""
    can = 0
    m = mask
    # For each i remaining, if it has at least two multiples in mask, mark those multiples as removable.
    i = 0
    while m:
        lb = m & -m
        i = (lb.bit_length() - 1)
        m ^= lb
        alive_mults = multiples_mask[i] & mask
        # Need at least two distinct multiples j,k in S (excluding i since multiples_mask excludes i by construction).
        if alive_mults and (alive_mults & (alive_mults - 1)):
            # Any k in alive_mults is removable (there exists some j != k in alive_mults).
            can |= alive_mults
    return can

def dfs_baseline(mask: int, multiples_mask: List[int], memo: Dict[int, Tuple[int, int]]) -> Tuple[int, int]:
    if mask == 0:
        return (0, 1)
    if mask in memo:
        return memo[mask]
    can = removable_set(mask, multiples_mask)
    if can == 0:
        memo[mask] = (0, 1)
        return memo[mask]
    best = -1
    count = 0
    mm = can
    while mm:
        lb = mm & -mm
        k = (lb.bit_length() - 1)
        mm ^= lb
        nxt = mask ^ (1 << k)
        h, c = dfs_baseline(nxt, multiples_mask, memo)
        h += 1
        if h > best:
            best = h
            count = c
        elif h == best:
            count = (count + c) % MOD
    memo[mask] = (best, count % MOD)
    return memo[mask]
\end{minted}
\VALIDATION{Tiny checks:
\begin{bullets}
\item $[2,6,8]\mapsto 2$ piles, height $1$.
\item $[2,3,5]\mapsto 1$ pile (empty), height $0$.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Memoize by state mask and precompute bitsets for divisibility; choose branching elements $k$ with smallest ``impact'' to keep branching low.}
\ASSUMPTIONS{Bitmask representation enables fast set operations; use counts-of-multiples heuristic to order removals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute for each $i$: bitmasks of multiples and divisors.
\item At state $S$, compute $\mathcal{R}(S)$. To prune, iterate $k$ in increasing number of remaining divisors (fewer choices typically lead to less overlap).
\item Use memoization $(H(S),C(S))$ to avoid recomputation; sum counts modulo $10^9+7$ over equally optimal branches.
\end{algosteps}
\COMPLEXITY{Still exponential in the worst case, but memoization over up to $2^n$ states and pruning greatly reduce practice time for small to moderate $n$.}
\[
\begin{aligned}
T(n) &\le 2^n \cdot \text{poly}(n)\ \text{(memoized states)}.\\
\end{aligned}
\]
\CORRECTNESS{Identical to baseline: optimal substructure and exhaustive branching over valid $k$; memoization preserves exactness while pruning only affects exploration order, not outcomes.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Dict

MOD = 10**9 + 7

def solve_case(a: List[int]) -> int:
    n = len(a)
    multiples_mask, divisors_mask = build_divisibility(a)

    # Precompute an ordering key for k (number of divisors alive is a proxy)
    def order_keys(k: int, mask: int) -> int:
        # fewer divisors first
        return (bin(divisors_mask[k] & mask).count("1"), k)

    from functools import lru_cache

    @lru_cache(maxsize=None)
    def dp(mask: int) -> Tuple[int, int]:
        if mask == 0:
            return (0, 1)
        can = removable_set(mask, multiples_mask)
        if can == 0:
            return (0, 1)
        # Order branching by heuristic
        ks = []
        mm = can
        while mm:
            lb = mm & -mm
            k = (lb.bit_length() - 1)
            mm ^= lb
            ks.append(k)
        ks.sort(key=lambda x: order_keys(x, mask))
        best = -1
        ways = 0
        for k in ks:
            nxt = mask ^ (1 << k)
            h, c = dp(nxt)
            h += 1
            if h > best:
                best = h
                ways = c
            elif h == best:
                ways = (ways + c) % MOD
        return (best, ways % MOD)

    full = (1 << n) - 1
    _, ways = dp(full)
    return ways % MOD
\end{minted}
\VALIDATION{Edge cases:
\begin{bullets}
\item No valid move: $[2,3,5]\to 1$.
\item Chain $[2,4,8]\to$ only one of $4$ or $8$ can be removed first, but both lead to same max height $1$; count $2$.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Exact DP on State Space with Bitset Accelerations}
\WHICHFORMULA{Use exact memoized DP $(H(S),C(S))$ with precomputed bitsets for divisibility, which is optimal in the sense of exploring only reachable states and aggregating counts modulo $10^9+7$.}
\ASSUMPTIONS{Numbers are distinct and within $[1,60]$, so divisibility relations are sparse; bitset operations are $O(1)$ per machine word, yielding fast transitions.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute bitmasks: for each $i$, the mask of multiples and mask of divisors.
\item For a given mask $S$, compute removable set $\mathcal{R}(S)$ via counting multiples per $i$ in $S$.
\item DP recurrence: choose $k\in\mathcal{R}(S)$, transition to $S\setminus\{k\}$, keep only branches that attain the maximum height; sum counts modulo $10^9+7$.
\end{algosteps}
\OPTIMALITY{The DP explores the exact game tree and memoizes subproblems by $S$; hence it returns the true maximum and the exact count of optimal sequences.}
\COMPLEXITY{In worst case $O(2^n\cdot n)$ states; in practice, strong pruning from the move condition reduces branching.
\[
\begin{aligned}
T(n) &\le 2^n \cdot O(n) \quad\text{(bit-level set ops)}.\\
S(n) &\le 2^n \quad\text{for memoization}.
\end{aligned}
\]}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple, Dict
import sys

MOD = 10**9 + 7

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def build_divisibility(a: List[int]) -> Tuple[List[int], List[int]]:
    n = len(a)
    multiples_mask = [0]*n
    divisors_mask = [0]*n
    for i in range(n):
        ai = a[i]
        for j in range(n):
            if i != j and a[j] % ai == 0:
                multiples_mask[i] |= (1 << j)
                divisors_mask[j] |= (1 << i)
    return multiples_mask, divisors_mask

def removable_set(mask: int, multiples_mask: List[int]) -> int:
    can = 0
    m = mask
    while m:
        lb = m & -m
        i = lb.bit_length() - 1
        m ^= lb
        alive_mults = multiples_mask[i] & mask
        # need at least two multiples j,k in S (excluding i)
        if alive_mults and (alive_mults & (alive_mults - 1)):
            can |= alive_mults
    return can

def solve_all(n: int, a: List[int]) -> int:
    if n == 0:
        return 0
    multiples_mask, divisors_mask = build_divisibility(a)

    from functools import lru_cache

    @lru_cache(maxsize=None)
    def dp(mask: int) -> Tuple[int, int]:
        if mask == 0:
            return (0, 1)
        can = removable_set(mask, multiples_mask)
        if can == 0:
            return (0, 1)
        # Heuristic: branch on k with fewer alive divisors first
        ks = []
        mm = can
        while mm:
            lb = mm & -mm
            k = lb.bit_length() - 1
            mm ^= lb
            ks.append(k)
        ks.sort(key=lambda k: (bin(divisors_mask[k] & mask).count("1"), k))
        best = -1
        ways = 0
        for k in ks:
            nxt = mask ^ (1 << k)
            h, c = dp(nxt)
            h += 1
            if h > best:
                best = h
                ways = c
            elif h == best:
                ways = (ways + c) % MOD
        return (best, ways % MOD)

    full = (1 << n) - 1
    _, ways = dp(full)
    return ways % MOD

def main():
    n, a = read_input()
    if n == 0:
        # Self-tests when no input
        def run_case(vals: List[int], expected: int):
            res = solve_all(len(vals), vals)
            print(f"vals={vals} -> {res}")
            assert res == expected
        run_case([2,6,8], 2)
        run_case([2,3,5], 1)
        run_case([2,3,4,9,12], 4)
        # Additional tiny checks
        run_case([2,4,8], 2)  # remove 4 or 8, two max-length piles of height 1
    else:
        ans = solve_all(n, a)
        print(ans)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts (triggered in self-test mode):
\begin{bullets}
\item $[2,6,8]\to 2$.
\item $[2,3,5]\to 1$.
\item $[2,3,4,9,12]\to 4$.
\end{bullets}}
\RESULT{Outputs the number of maximum-height piles modulo $10^9+7$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small crafted sets: no-move cases, simple chains, branching divisibility, and mixed composites.}
\LINE{CROSS-CHECKS}{Compare counts from Approach B and C on random small subsets of $[1,20]$ to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate distinct integers within small bounds and filter where no moves exist vs. many moves (dense divisibility like $\{2,3,4,6,12\}$).}
\begin{minted}{python}
import random

def gen_cases(max_val: int, trials: int = 50):
    seen = set()
    cases = []
    for _ in range(trials):
        m = random.randint(3, min(10, max_val))
        vals = []
        pool = list(range(1, max_val+1))
        random.shuffle(pool)
        for x in pool:
            if len(vals) < m and x not in vals:
                vals.append(x)
        vals.sort()
        t = tuple(vals)
        if t not in seen:
            seen.add(t)
            cases.append(vals)
    return cases

def reference_solve(vals):
    return solve_all(len(vals), vals)

# Quick property: adding an isolated prime larger than all others should not increase number of max piles,
# but may increase the number of sequences only if it allows extra removals via witnesses (it does not by itself).
def property_check():
    base = [2,6,8]
    ans_base = reference_solve(base)
    extended = base + [23]  # prime not dividing or divisible by others
    assert reference_solve(extended) == ans_base

if __name__ == "__main__":
    # Run a few random cases within small limits to keep runtime bounded.
    for vals in gen_cases(20, 10):
        _ = reference_solve(vals)
    property_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final exact DP with memoization and bitset accelerations.
from typing import List, Tuple
import sys

MOD = 10**9 + 7

def read_input() -> Tuple[int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def build_divisibility(a: List[int]) -> Tuple[List[int], List[int]]:
    n = len(a)
    multiples_mask = [0]*n
    divisors_mask = [0]*n
    for i in range(n):
        ai = a[i]
        for j in range(n):
            if i != j and a[j] % ai == 0:
                multiples_mask[i] |= (1 << j)
                divisors_mask[j] |= (1 << i)
    return multiples_mask, divisors_mask

def removable_set(mask: int, multiples_mask: List[int]) -> int:
    can = 0
    m = mask
    while m:
        lb = m & -m
        i = lb.bit_length() - 1
        m ^= lb
        alive_mults = multiples_mask[i] & mask
        if alive_mults and (alive_mults & (alive_mults - 1)):
            can |= alive_mults
    return can

def solve_all(n: int, a: List[int]) -> int:
    if n == 0:
        return 0
    multiples_mask, divisors_mask = build_divisibility(a)

    from functools import lru_cache

    @lru_cache(maxsize=None)
    def dp(mask: int) -> Tuple[int, int]:
        if mask == 0:
            return (0, 1)
        can = removable_set(mask, multiples_mask)
        if can == 0:
            return (0, 1)
        ks = []
        mm = can
        while mm:
            lb = mm & -mm
            k = lb.bit_length() - 1
            mm ^= lb
            ks.append(k)
        ks.sort(key=lambda k: (bin(divisors_mask[k] & mask).count("1"), k))
        best = -1
        ways = 0
        for k in ks:
            nxt = mask ^ (1 << k)
            h, c = dp(nxt)
            h += 1
            if h > best:
                best = h
                ways = c
            elif h == best:
                ways = (ways + c) % MOD
        return (best, ways % MOD)

    full = (1 << n) - 1
    _, ways = dp(full)
    return ways % MOD

def main():
    n, a = read_input()
    if n == 0:
        # Self-tests
        def run_case(vals: List[int], expected: int):
            res = solve_all(len(vals), vals)
            print(f"vals={vals} -> {res}")
            assert res == expected
        run_case([2,6,8], 2)
        run_case([2,3,5], 1)
        run_case([2,3,4,9,12], 4)
    else:
        print(solve_all(n, a))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count the number of maximum-length sequences of removals where a removal is allowed if some $a_i$ divides two distinct remaining elements.}
\WHY{Divisibility posets and constrained removal processes appear in advanced combinatorics and difficult interview/hard CF problems; reasoning about states and counts is key.}
\CHECKLIST{
\begin{bullets}
\item Build divisibility graph correctly (exclude self-loops).
\item Identify removable elements via ``exists $i$ with at least two multiples''.
\item Use memoization on state to aggregate optimal heights and counts.
\item Sum counts only from branches achieving the maximum height.
\item Reduce modulo at each accumulation.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item No valid moves initially $\Rightarrow$ answer $1$.
\item All pairwise non-divisible inputs (e.g., all primes) $\Rightarrow$ no moves.
\item Chains like $[2,4,8,16]$ where smallest has many multiples.
\item Presence of $1$: divides everything, greatly increases removability.
\item Distinctness ensured; no equal numbers.
\item Minimal $n=3$: need at least one valid triple to move.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting that $i,j,k$ must be distinct.
\item Treating ``divides'' as symmetric or allowing self as witness.
\item Counting all sequences, not only the ones of maximum length.
\item Missing modulo reductions leading to overflow.
\item Incorrect bit indexing in masks.
\item Not memoizing states causing time blow-up even on small cases.
\end{bullets}}
\FAILMODES{Baseline without memoization explodes on branching instances with dense divisibility (e.g., many small composites). The improved DP with caching and bitsets avoids recomputation and prunes effectively on small to medium inputs.}
\ELI{We keep removing a box $k$ whenever there is another box $j$ that shares a divisor-box $i$ with it. We explore all possible removal orders but only count those that get the tallest pile, using caching to avoid redoing work.}
\NotePages{3}

\end{document}