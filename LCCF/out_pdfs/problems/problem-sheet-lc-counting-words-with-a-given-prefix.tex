% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Counting Words With a Given Prefix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/counting-words-with-a-given-prefix/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given an array of strings \texttt{words} and a string \texttt{pref}. Return the number of strings in \texttt{words} that contain \texttt{pref} as a prefix. A prefix of a string $s$ is any leading contiguous substring of $s$. 

Examples:
\begin{itemize}
\item Input: \texttt{words = ["pay","attention","practice","attend"]}, \texttt{pref = "at"}. Output: \texttt{2}. Explanation: The 2 strings that contain \texttt{"at"} as a prefix are \texttt{"attention"} and \texttt{"attend"}.
\item Input: \texttt{words = ["leetcode","win","loops","success"]}, \texttt{pref = "code"}. Output: \texttt{0}. Explanation: There are no strings that contain \texttt{"code"} as a prefix.
\end{itemize}

Constraints:
\begin{itemize}
\item $1 \le \text{len}(\texttt{words}) \le 100$.
\item $1 \le \text{len}(\texttt{words}[i]),~\text{len}(\texttt{pref}) \le 100$.
\item Each \texttt{words[i]} and \texttt{pref} consists of lowercase English letters.
\end{itemize}}
\BREAKDOWN{Count how many strings in the list start with the given prefix. Subtasks: iterate strings, check prefix relation, sum counts.}
\ELI{Scan each word and add 1 if it starts with the prefix.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{words} of $n$ lowercase strings; a lowercase string \texttt{pref}. Valid ranges: $1 \le n \le 100$ and $1 \le$ lengths $\le 100$.}
\OUTPUTS{An integer: the number of \texttt{words[i]} such that \texttt{pref} is a prefix of \texttt{words[i]}.}
\SAMPLES{
\begin{itemize}
\item \texttt{words=["pay","attention","practice","attend"]}, \texttt{pref="at"} $\to$ \texttt{2}.
\item \texttt{words=["leetcode","win","loops","success"]}, \texttt{pref="code"} $\to$ \texttt{0}.
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a multiset $W=\{w_1,\ldots,w_n\}$ of strings over alphabet $\Sigma=\{a,\ldots,z\}$ and a string $p\in\Sigma^{*}$, compute
\begin{BreakableEquation*}
f(W,p) \coloneqq \sum_{i=1}^{n} \mathbf{1}\big[w_i[1..|p|]=p\big].
\end{BreakableEquation*}
}
\varmapStart
\var{n}{number of words}
\var{w_i}{the $i$-th word}
\var{p}{the prefix string \texttt{pref}}
\var{|x|}{length of string $x$}
\var{\mathbf{1}[\cdot]}{indicator function (1 if condition true, else 0)}
\varmapEnd
\GOVERN{
\[
\forall i\in\{1,\ldots,n\}:\quad \mathbf{1}\big[w_i[1..|p|]=p\big]=
\begin{cases}
1,& \text{if } |w_i|\ge |p| \text{ and } \big(\forall j\in\{1,\ldots,|p|\}:~w_i[j]=p[j]\big),\\
0,& \text{otherwise}.
\end{cases}
\]
}
\ASSUMPTIONS{Strings are indexed from 1 to their length for the mathematical description; inputs meet the constraints and contain only lowercase letters.}
\INVARIANTS{
\begin{itemize}
\item For any word $w$, if $|w|<|p|$, it cannot contribute to the count.
\item The count is in $[0,n]$.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly evaluate $\mathbf{1}[w_i[1..|p|]=p]$ for each $w_i$ and sum. In code, use built-in prefix check.}
\ASSUMPTIONS{Single pass over the array; built-in \texttt{startswith} is $O(|p|)$ per word.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a counter $c\leftarrow 0$.
\item For each word $w$ in \texttt{words}, if $w$ starts with \texttt{pref}, increment $c$.
\item Return $c$.
\end{algosteps}
\COMPLEXITY{Let $n=\text{len}(\texttt{words})$ and $k=\text{len}(\texttt{pref})$. Worst-case time $O(n\cdot k)$; space $O(1)$ auxiliary.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} O(k) = O(nk). \\
\end{aligned}
\]
\CORRECTNESS{Each word contributes exactly 1 if and only if its first $k$ characters match \texttt{pref}, matching the definition of prefix.}
\EDGECASES{Empty prefix would match all words, but constraints guarantee $k\ge 1$. Words shorter than \texttt{pref} never match.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        # Direct use of Python's startswith
        return sum(1 for w in words if w.startswith(pref))


# ---- Tests (Baseline) ----
if __name__ == "__main__":
    s = Solution()
    assert s.prefixCount(["pay", "attention", "practice", "attend"], "at") == 2
    assert s.prefixCount(["leetcode", "win", "loops", "success"], "code") == 0
    # Edge within logic (though LC constraints have n>=1)
    assert s.prefixCount([], "a") == 0
    print("Baseline OK")
\end{minted}
\VALIDATION{Checked sample cases; also verified empty list returns 0.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Length Filter + Slice Compare}
\WHICHFORMULA{Avoid method dispatch; compare slices of length $k=\text{len}(\texttt{pref})$ only when $|w|\ge k$. Similar asymptotics with tiny constant-factor savings.}
\ASSUMPTIONS{String slicing of length $k$ is $O(k)$; length checks prune obvious non-matches early.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $k\leftarrow$ length of \texttt{pref}.
\item For each $w$ with $|w|\ge k$, compare $w[:k]==\texttt{pref}$ and count matches.
\item Return the total.
\end{algosteps}
\COMPLEXITY{Still $O(nk)$ time; $O(1)$ extra space. The early length check may skip slicing for short words.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} O(\min(|w_i|,k)) \le O(nk).
\end{aligned}
\]
\CORRECTNESS{Slice equality on the first $k$ characters is equivalent to the prefix definition.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        k = len(pref)
        cnt = 0
        for w in words:
            if len(w) >= k and w[:k] == pref:
                cnt += 1
        return cnt


# ---- Tests (Improved) ----
if __name__ == "__main__":
    s = Solution()
    assert s.prefixCount(["pay", "attention", "practice", "attend"], "at") == 2
    assert s.prefixCount(["leetcode", "win", "loops", "success"], "code") == 0
    assert s.prefixCount(["a", "aa", "b"], "a") == 2
    print("Improved OK")
\end{minted}
\VALIDATION{Verified on samples and an extra case with varying lengths.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Tight Single-Pass Count}
\WHICHFORMULA{Single pass with built-in prefix check is optimal for a single query: one must inspect up to $k$ chars per word in the worst case.}
\ASSUMPTIONS{Single query on the array. If there were many queries on the same \texttt{words}, a trie could help; for one query, scanning is optimal.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{ans} to 0.
\item For each \texttt{w} in \texttt{words}, if \texttt{w.startswith(pref)} then \texttt{ans += 1}.
\item Return \texttt{ans}.
\end{algosteps}
\OPTIMALITY{Any algorithm must distinguish matches from non-matches, requiring inspection of up to $k$ characters per word in adversarial inputs. Thus $\Omega(nk)$ character inspections are necessary; this matches the algorithm.}
\COMPLEXITY{$T(n)=O(nk)$, $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= O(n\cdot k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        return sum(1 for w in words if w.startswith(pref))


# ---- Validation (exactly 3 asserts) ----
if __name__ == "__main__":
    s = Solution()
    assert s.prefixCount(["pay", "attention", "practice", "attend"], "at") == 2
    assert s.prefixCount(["leetcode", "win", "loops", "success"], "code") == 0
    assert s.prefixCount(["at", "a", "t"], "at") == 1
    print("Final OK")
\end{minted}
\VALIDATION{Three asserts: both samples and a short exact-match case.}
\RESULT{Returns the count of words with \texttt{pref} as a prefix; no tie-breaking is involved.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: samples, varying lengths, all-match and no-match cases, and boundary lengths $k=1$ and $k=100$ in crafted inputs.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A, B, and C on identical small cases to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Produce deterministic crafted words to test boundaries: shorter than prefix, equal to prefix, longer with matching and non-matching continuations.}
\begin{minted}{python}
from typing import List, Tuple

def gen_cases() -> List[Tuple[List[str], str, int]]:
    cases = []
    # Basic samples
    cases.append((["pay", "attention", "practice", "attend"], "at", 2))
    cases.append((["leetcode", "win", "loops", "success"], "code", 0))
    # Boundary-related
    cases.append((["a", "aa", "aaa", "b"], "a", 3))
    cases.append((["x"*100, "x"*99 + "y", "y"*100], "x"*100, 1))
    cases.append((["ab", "abc", "abcd", "a", ""], "abc", 1))  # empty allowed here for extra check
    return cases

class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        return sum(1 for w in words if w.startswith(pref))

if __name__ == "__main__":
    # Cross-check equality among implementations
    def A(words: List[str], pref: str) -> int:
        return sum(1 for w in words if w.startswith(pref))

    def B(words: List[str], pref: str) -> int:
        k = len(pref)
        cnt = 0
        for w in words:
            if len(w) >= k and w[:k] == pref:
                cnt += 1
        return cnt

    def C(words: List[str], pref: str) -> int:
        # Same as A; final reference
        return sum(1 for w in words if w.startswith(pref))

    for words, pref, want in gen_cases():
        gotA = A(words, pref)
        gotB = B(words, pref)
        gotC = C(words, pref)
        assert gotA == want and gotB == want and gotC == want
    print("Cross-checks OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        # Single-pass; O(n*k) time, O(1) extra space
        return sum(1 for w in words if w.startswith(pref))


# Self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.prefixCount(["pay", "attention", "practice", "attend"], "at") == 2
    assert s.prefixCount(["leetcode", "win", "loops", "success"], "code") == 0
    assert s.prefixCount(["pref", "prefix", "pre"], "pre") == 3
    print("Reference OK")
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count how many words start with a given prefix via a single scan.}
\WHY{A canonical warm-up on string handling and array iteration; tests careful handling of lengths and off-by-one boundaries.}
\CHECKLIST{
\begin{itemize}
\item Compute $k=\text{len}(\texttt{pref})$.
\item For each word, if its length $\ge k$ and first $k$ chars equal \texttt{pref}, count it.
\item Return the accumulated count.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item Word shorter than \texttt{pref}.
\item Word exactly equal to \texttt{pref}.
\item All words match; no words match.
\item Repeated words.
\item \texttt{pref} length 1.
\item Maximum lengths (100).
\item Non-overlapping first character.
\item Many words sharing the prefix but diverging later.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Off-by-one when slicing: ensure $w[:k]$ not $w[:k-1]$.
\item Forgetting to check length before manual character-by-character compare.
\item Confusing substring containment with prefix check.
\item Creating unnecessary copies; stick to prefix compare.
\item Early returns inside loops that skip remaining words.
\item Misreading constraints to allow empty \texttt{pref} (not allowed here).
\end{itemize}
}
\FAILMODES{Algorithms that search for \texttt{pref} anywhere (substring) will overcount. Character comparisons without a length guard may raise errors or be incorrect.}
\ELI{Look at the start of each word and see if it begins with \texttt{pref}. Count how many do. That is all.}
\NotePages{3}

\end{document}