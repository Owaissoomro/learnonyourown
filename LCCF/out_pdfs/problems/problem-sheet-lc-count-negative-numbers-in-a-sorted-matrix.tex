% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Count Negative Numbers in a Sorted Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given an $m \times n$ matrix \texttt{grid} which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in \texttt{grid}.

Example 1:

\quad Input: \texttt{grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]}

\quad Output: \texttt{8}

\quad Explanation: There are $8$ negative numbers in the matrix.

Example 2:

\quad Input: \texttt{grid = [[3,2],[1,0]]}

\quad Output: \texttt{0}

Constraints:
\begin{bullets}
\item $m = \lvert\texttt{grid}\rvert$.
\item $n = \lvert\texttt{grid[i]}\rvert$ for every valid $i$.
\item $1 \le m, n \le 100$.
\item $-100 \le \texttt{grid[i][j]} \le 100$.
\end{bullets}
Follow-up: Can you find an $O(n+m)$ solution?}
\BREAKDOWN{We must count entries $<0$ in a matrix that is non-increasing left-to-right in each row and top-to-bottom in each column. Use the sorted structure to improve from brute force to $O(m\log n)$ or $O(m+n)$.}
\ELI{Walk from one corner and skip whole blocks at a time since rows and columns are sorted non-increasingly.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of lists \texttt{grid} of integers with shape $m \times n$, where $1 \le m,n \le 100$ and $-100 \le \texttt{grid[i][j]} \le 100$. Each row is sorted in non-increasing order, and each column is sorted in non-increasing order.}
\OUTPUTS{Return a single integer: the total count of entries in \texttt{grid} that are strictly negative.}
\SAMPLES{
Example A: \texttt{grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]} $\to$ \texttt{8}.

Example B: \texttt{grid = [[3,2],[1,0]]} $\to$ \texttt{0}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in \mathbb{Z}^{m \times n}$ with indices $i \in \{0,\ldots,m-1\}$ and $j \in \{0,\ldots,n-1\}$. Constraints: $A_{i,j} \ge A_{i,j+1}$ for $0 \le j < n-1$ (rows non-increasing), and $A_{i,j} \ge A_{i+1,j}$ for $0 \le i < m-1$ (columns non-increasing). Objective: compute
\begin{BreakableEquation*}
C \coloneqq \sum_{i=0}^{m-1}\sum_{j=0}^{n-1} \mathbf{1}\{A_{i,j} < 0\}.
\end{BreakableEquation*}%
}
\varmapStart
\var{m,n}{numbers of rows and columns}
\var{A_{i,j}}{value at row $i$, column $j$}
\var{C}{desired count of negative entries}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i,j:\quad A_{i,j} \ge A_{i,j+1}\ \text{if } j+1<n,\qquad A_{i,j} \ge A_{i+1,j}\ \text{if } i+1<m.
\end{BreakableEquation*}
}
\ASSUMPTIONS{0-based indexing; $m,n \ge 1$; input is already non-increasing along rows and columns.}
\INVARIANTS{
\begin{bullets}
\item If $A_{i,j} < 0$, then $A_{i,k} < 0$ for all $k>j$ (right of it in same row).
\item If $A_{i,j} \ge 0$, then $A_{k,j} \ge 0$ for all $k<i$ (above it in same column).
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Count all entries $<0$ by scanning every cell; equivalent to evaluating the indicator sum definition of $C$.}
\ASSUMPTIONS{None beyond input validity and bounds.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{count = 0}.
\item For each row and each value \texttt{x}, if \texttt{x < 0}, increment \texttt{count}.
\item Return \texttt{count}.
\end{algosteps}
\COMPLEXITY{Touch each of the $m n$ cells once. Time $T(m,n)=\Theta(mn)$; space $S(m,n)=\Theta(1)$ auxiliary.}
\[
\begin{aligned}
T(m,n) &= \sum_{i=0}^{m-1}\sum_{j=0}^{n-1} 1 \;=\; mn.
\end{aligned}
\]
\CORRECTNESS{By construction it counts exactly those and only those entries that are negative. Sorting is unused.}
\EDGECASES{All non-negative $\Rightarrow 0$; all negative $\Rightarrow mn$; single row or single column.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        # Brute force: scan every cell
        return sum(1 for row in grid for x in row if x < 0)

# Tiny tests (LC-style)
s = Solution()
assert s.countNegatives([[3, 2], [1, 0]]) == 0
assert s.countNegatives([[4, 3, 2, -1],
                         [3, 2, 1, -1],
                         [1, 1, -1, -2],
                         [-1, -1, -2, -3]]) == 8
# Edge: all negative
assert s.countNegatives([[-1, -1], [-2, -3]]) == 4
\end{minted}
\VALIDATION{Matches the provided samples and a simple all-negative case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Binary search in each row to find the first negative index since rows are non-increasing. Sum the counts $n - \text{first\_neg\_pos}$.}
\ASSUMPTIONS{Each row is sorted non-increasingly.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each row, binary search the leftmost index $j$ with \texttt{row[j] < 0}.
\item Add $n - j$ to the total.
\item Return the sum.
\end{algosteps}
\COMPLEXITY{For $m$ rows, each binary search is $O(\log n)$, so $T(m,n)=O(m\log n)$; space $\Theta(1)$.}
\[
\begin{aligned}
T(m,n) &= \sum_{i=1}^{m} O(\log n) \;=\; O(m\log n).
\end{aligned}
\]
\CORRECTNESS{Binary search returns the first negative due to row monotonicity. Elements to its right are all $\le$ that negative, hence negative, contributing exactly $n-j$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        if not grid:
            return 0
        n = len(grid[0])
        total = 0
        for row in grid:
            l, r = 0, n
            # Find first index with row[idx] < 0
            while l < r:
                mid = (l + r) // 2
                if row[mid] < 0:
                    r = mid
                else:
                    l = mid + 1
            total += n - l
        return total

# Tests
s = Solution()
assert s.countNegatives([[3, 2], [1, 0]]) == 0
assert s.countNegatives([[4, 3, 2, -1],
                         [3, 2, 1, -1],
                         [1, 1, -1, -2],
                         [-1, -1, -2, -3]]) == 8
# Mixed with negatives only at end
assert s.countNegatives([[10, 0, -1, -2]]) == 2
\end{minted}
\VALIDATION{Checks no-negatives, mixed row, and the provided larger example.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Staircase walk from bottom-left. If current is negative, all to its right are negative; count them and move up. Otherwise move right. This is the classic $O(m+n)$ two-pointer traversal for sorted matrices.}
\ASSUMPTIONS{Matrix is non-increasing along rows and columns.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $i=m-1$, $j=0$, \texttt{count = 0}.
\item While $i \ge 0$ and $j < n$:
\begin{bullets}
\item If \texttt{grid[i][j] < 0}, add $n-j$ to \texttt{count} and decrement $i$.
\item Else increment $j$.
\end{bullets}
\item Return \texttt{count}.
\end{algosteps}
\OPTIMALITY{Each step strictly decreases $i$ or increases $j$, so there are at most $m+n-1$ moves. A comparison-based method must inspect at least one element per row or column boundary change, matching the tight $O(m+n)$.}
\COMPLEXITY{Each of $i$ and $j$ changes at most $m$ and $n$ times respectively, so $T(m,n)=\Theta(m+n)$ and $S(m,n)=\Theta(1)$.}
\[
\begin{aligned}
T(m,n) &= O(m+n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        i, j = m - 1, 0
        count = 0
        while i >= 0 and j < n:
            if grid[i][j] < 0:
                count += n - j
                i -= 1
            else:
                j += 1
        return count

# Exactly 3 asserts
s = Solution()
assert s.countNegatives([[3, 2], [1, 0]]) == 0
assert s.countNegatives([[4, 3, 2, -1],
                         [3, 2, 1, -1],
                         [1, 1, -1, -2],
                         [-1, -1, -2, -3]]) == 8
assert s.countNegatives([[-1, -1, -2]]) == 3
\end{minted}
\VALIDATION{Covers no-negatives, mixed large example, and an all-negative row.}
\RESULT{Returns the total number of negative entries. No tie-breaking needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on samples; rows-only and columns-only cases; all-negative and all-non-negative; random monotone matrices generated by separable row/column decrements.}
\LINE{CROSS-CHECKS}{Compare brute-force counts vs optimal on generated inputs; ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Constructs matrices as $A_{i,j} = B - r_i - c_j$ with non-decreasing $r_i$ and $c_j$, guaranteeing non-increasing rows and columns.}
\begin{minted}{python}
from typing import List, Tuple

def naive_count(grid: List[List[int]]) -> int:
    return sum(1 for row in grid for x in row if x < 0)

def is_non_increasing_rows_cols(grid: List[List[int]]) -> bool:
    m = len(grid)
    n = len(grid[0]) if m > 0 else 0
    for i in range(m):
        for j in range(n - 1):
            if grid[i][j] < grid[i][j + 1]:
                return False
    for j in range(n):
        for i in range(m - 1):
            if grid[i][j] < grid[i + 1][j]:
                return False
    return True

def make_monotone_grid(m: int, n: int) -> List[List[int]]:
    # Deterministic construction: A[i][j] = base - r[i] - c[j]
    base = 3
    r = [i for i in range(m)]               # non-decreasing
    c = [j // 2 for j in range(n)]          # non-decreasing
    grid = [[base - r[i] - c[j] for j in range(n)] for i in range(m)]
    assert is_non_increasing_rows_cols(grid)
    return grid

# Cross-check brute force vs optimal on several sizes
from typing import List

class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        i, j = m - 1, 0
        count = 0
        while i >= 0 and j < n:
            if grid[i][j] < 0:
                count += n - j
                i -= 1
            else:
                j += 1
        return count

s = Solution()
for m, n in [(1, 1), (1, 5), (5, 1), (3, 4), (6, 6)]:
    g = make_monotone_grid(m, n)
    assert is_non_increasing_rows_cols(g)
    assert s.countNegatives(g) == naive_count(g)

# Boundary-flavored crafted cases
assert s.countNegatives([[0]]) == 0
assert s.countNegatives([[-1]]) == 1
assert s.countNegatives([[5, 4, 3], [4, 3, 2]]) == 0
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        i, j = m - 1, 0
        count = 0
        while i >= 0 and j < n:
            if grid[i][j] < 0:
                count += n - j
                i -= 1
            else:
                j += 1
        return count

# Sanity checks
s = Solution()
assert s.countNegatives([[3, 2], [1, 0]]) == 0
assert s.countNegatives([[4, 3, 2, -1],
                         [3, 2, 1, -1],
                         [1, 1, -1, -2],
                         [-1, -1, -2, -3]]) == 8
assert s.countNegatives([[-1, -1, -2]]) == 3
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count negatives in a matrix sorted non-increasing by rows and columns using an $O(m+n)$ staircase traversal.}
\WHY{Appears in interviews to test using sorted structure across two dimensions and designing linear-time scans.}
\CHECKLIST{
\begin{bullets}
\item Choose correct corner: bottom-left or top-right.
\item If current $<0$, add all to the right; else move right.
\item Maintain bounds and update exactly one of $i$ or $j$ per step.
\item Prefer $O(m+n)$ unless constraints are tiny.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All non-negative $\Rightarrow 0$.
\item All negative $\Rightarrow mn$.
\item Single row or single column.
\item Zeros at the boundary between non-negative and negative.
\item Minimal size $1 \times 1$.
\item Large but narrow or tall matrices.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one when adding $n-j$; ensure it includes the current column.
\item Moving in the wrong direction from the chosen corner.
\item Assuming strictly decreasing instead of non-increasing.
\item Forgetting that constraints guarantee $m,n \ge 1$ on LC.
\item Binary search condition should be \texttt{< 0}, not \texttt{<= 0}.
\item Misusing Python \texttt{bisect} on non-increasing sequences.
\end{bullets}}
\FAILMODES{Row-wise-only or column-wise-only monotonicity is insufficient for the staircase method; it relies on both. Brute force times out on larger bounds, while $O(m+n)$ scales linearly.}
\ELI{Start at the bottom-left. If you see a negative, everything to its right is also negative, so count them and go up. If not negative, go right. You finish after at most $m+n$ steps.}
\NotePages{3}

\end{document}