% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — 2+ doors}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1715/D}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{The Narrator has an integer array $a$ of length $n$, but he will only tell you the size $n$ and $q$ statements, each of them being three integers $i, j, x$, which means that $a_i \mid a_j = x$, where $\mid$ denotes the bitwise OR operation.

Find the lexicographically smallest array $a$ that satisfies all the statements.

An array $a$ is lexicographically smaller than an array $b$ of the same length if and only if the following holds:
\begin{bullets}
\item in the first position where $a$ and $b$ differ, the array $a$ has a smaller element than the corresponding element in $b$.
\end{bullets}

Input:
In the first line you are given with two integers $n$ and $q$ ($1 \le n \le 10^5$, $0 \le q \le 2 \cdot 10^5$).

In the next $q$ lines you are given with three integers $i$, $j$, and $x$ ($1 \le i, j \le n$, $0 \le x < 2^{30}$) — the statements.

It is guaranteed that all $q$ statements hold for at least one array.

Output:
On a single line print $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i < 2^{30}$) — array $a$.

Note:
In the first sample, these are all the arrays satisfying the statements:
\begin{bullets}
\item $[0, 3, 2, 2]$,
\item $[2, 1, 0, 0]$,
\item $[2, 1, 0, 2]$,
\item $[2, 1, 2, 0]$,
\item $[2, 1, 2, 2]$,
\item $[2, 3, 0, 0]$,
\item $[2, 3, 0, 2]$,
\item $[2, 3, 2, 0]$,
\item $[2, 3, 2, 2]$.
\end{bullets}}
\BREAKDOWN{Each statement $a_i \mid a_j = x$ fixes zero-bits on both ends, and for one-bits mandates that at least one endpoint has that bit. We must construct the lexicographically smallest $a$ respecting all pairwise equalities.}
\ELI{Force all zero-bits first; then, for each position from left to right, give it only the bits that past neighbors still need or future neighbors cannot possibly take.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, q$; then $q$ triples $(i, j, x)$ with $1 \le i, j \le n$ and $0 \le x < 2^{30}$.}
\OUTPUTS{Print $n$ integers $a_1,\ldots,a_n$ such that for all statements $(i,j,x)$, $a_i \mid a_j = x$, and the array is lexicographically smallest among all valid arrays.}
\SAMPLES{Example 1:\\
Input: $n=2, q=1$; $(1,2,1)$. Output: $0~1$ (since $0 \mid 1 = 1$).\\
Example 2:\\
Input: $n=3, q=2$; $(1,2,0)$, $(2,3,5)$. Output: $0~0~5$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n$ and a multiset of constraints $\mathcal{C} = \{(i,j,x)\}$, find $a \in [0,2^{30})^n$ minimizing lex order such that $\forall (i,j,x)\in\mathcal{C}$,
\begin{BreakableEquation*}
a_i \mid a_j = x.
\end{BreakableEquation*} }
\varmapStart
\var{n}{array length}
\var{q}{number of constraints}
\var{(i,j,x)}{a constraint requiring $a_i \mid a_j = x$}
\var{U}{bit-universe mask $U = 2^{30}-1$}
\var{up_i}{bitwise upper mask for $a_i$: $up_i = \bigwedge\limits_{(i,*,x)\in\mathcal{C}} x ~\wedge~ \bigwedge\limits_{(*,i,x)\in\mathcal{C}} x$}
\var{need_i}{bits $a_i$ is already forced to $1$ by constraints with processed neighbors}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Zero forcing:}\quad x[b]=0 \implies a_i[b]=a_j[b]=0.\\
&\text{One coverage:}\quad x[b]=1 \implies a_i[b]\lor a_j[b]=1.\\
&\text{Lexicographic objective: minimize } a_1;~ \text{then } a_2;~\ldots;~a_n.
\end{aligned}
\]
}
\ASSUMPTIONS{Constraints are jointly feasible. Bits are independent across positions. Indices are $1$-based in the statement; we will use $0$-based internally in code.}
\INVARIANTS{
\begin{bullets}
\item $0 \le a_i \le up_i$ bitwise for all $i$.
\item When iterating $i=1\ldots n$, all constraints between $\{1,\ldots,i\}$ and $i$ are already satisfiable with current $a_i$ and fixed past values.
\item For each processed constraint $(i,j,x)$ with $i$ processed, we accumulate into $\text{need}_j$ the missing bits $(x \wedge \lnot a_i)$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedy left-to-right assignment. For each $i$, gather all bits required by already-fixed neighbors and all bits that future neighbors cannot possibly take.}
\ASSUMPTIONS{We recompute requirements by scanning all $q$ constraints at each position, resulting in $O(nq)$ time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $up_i$ for all $i$ as the bitwise AND of all incident $x$ values; initialize $a_i \gets 0$.
\item For $i$ from $1$ to $n$:
\begin{bullets}
\item Let $t \gets 0$.
\item For each constraint $(u,v,x)$:
\begin{bullets}
\item If $i \in \{u,v\}$, let $w$ be the other endpoint.
\item If $w < i$, set $t \mathrel{|}= (x \wedge \lnot a_w)$.
\item If $w > i$, set $t \mathrel{|}= \bigl(x \wedge \lnot up_w\bigr)$.
\item If $w=i$ (self-loop), set $t \mathrel{|}= x$.
\end{bullets}
\item Set $a_i \gets t \wedge up_i$.
\end{bullets}
\item Output $a$.
\end{algosteps}
\COMPLEXITY{Let $B=30$.
\[
\begin{aligned}
T(n) &= O(nq \cdot 1) \quad (\text{bit ops are }O(1))\\
S(n) &= O(n+q).
\end{aligned}
\]
}
\CORRECTNESS{Bits with $x[b]=0$ are killed in $up$ masks, so $a_i$ never violates zero requirements. For $x[b]=1$, if the partner is already fixed and lacks the bit, we must set it in $a_i$. If the partner is not yet fixed but cannot take the bit (its $up$ has $0$), we also set it in $a_i$. Otherwise we can defer the bit to the partner to minimize $a_i$. Self-loops force $a_i=x$ immediately.}
\EDGECASES{Self-loops $(i,i,x)$, isolated vertices (no constraints), multiple constraints between the same pair, and bits near $29$ (since $x<2^{30}$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); q = next(it)
    except StopIteration:
        return 0, 0, []
    edges = []
    for _ in range(q):
        i = next(it); j = next(it); x = next(it)
        edges.append((i-1, j-1, x))
    return n, q, edges

def solve_all(n, q, edges):
    if n == 0:
        return []
    U = (1 << 30) - 1
    up = [U] * n
    for u, v, x in edges:
        up[u] &= x
        up[v] &= x
    a = [0] * n
    for i in range(n):
        t = 0
        for u, v, x in edges:
            if u == i or v == i:
                w = v if u == i else u
                if w < i:
                    t |= (x & ~a[w])
                elif w > i:
                    t |= (x & ~up[w])
                else:
                    # self-loop
                    t |= x
        a[i] = t & up[i]
    return a

def main():
    data = sys.stdin.read()
    n, q, edges = read_input(data)
    if n == 0 and q == 0:
        return
    ans = solve_all(n, q, edges)
    print(" ".join(map(str, ans)))

if __name__ == "__main__":
    # Tiny tests
    n, q, edges = read_input("2 1\n1 2 1\n")
    assert solve_all(n, q, edges) == [0, 1]
    n, q, edges = read_input("3 2\n1 2 0\n2 3 5\n")
    assert solve_all(n, q, edges) == [0, 0, 5]
    # Self-loop
    n, q, edges = read_input("1 1\n1 1 13\n")
    assert solve_all(n, q, edges) == [13]
    # Run main if input is provided
    if not sys.stdin.isatty():
        sys.stdin.seek(0)
        main()
\end{minted}
\VALIDATION{Checked basic scenarios: single edge with $x=1$, chain with zeros and nonzeros, and self-loop forcing exact value.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use adjacency lists and a deferred-requirement array $\text{need}[\cdot]$. When a node $i$ is fixed, we push the still-missing bits to its neighbors as $\text{need}[j] \mathrel{|}= (x \wedge \lnot a_i)$.}
\ASSUMPTIONS{Adjacency lists reduce per-node scans to incident constraints only, yielding $O(n+q)$ time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency lists: for each $(u,v,x)$, add $(v,x)$ to $adj[u]$ and $(u,x)$ to $adj[v]$.
\item Compute $up_i$ as the AND over all incident $x$.
\item Initialize arrays $a[\,]\leftarrow 0$, $need[\,]\leftarrow 0$.
\item For $i=1$ to $n$:
\begin{bullets}
\item $t \leftarrow need[i]$.
\item For each $(v,x)$ in $adj[i]$ with $v>i$, set $t \mathrel{|}= (x \wedge \lnot up[v])$. For self-loop $(i,x)$, set $t \mathrel{|}= x$.
\item Set $a[i]\leftarrow t \wedge up[i]$.
\item For each $(v,x)$ in $adj[i]$, set $need[v] \mathrel{|}= (x \wedge \lnot a[i])$.
\end{bullets}
\item Output $a$.
\end{algosteps}
\COMPLEXITY{The total work over all nodes is proportional to $\sum_i \deg(i) = 2q$.
\[
\begin{aligned}
T(n) &= O(n+q),\\
S(n) &= O(n+q).
\end{aligned}
\]
}
\CORRECTNESS{By construction, $a_i \subseteq up_i$ bitwise, so no constraint with a zero-bit is violated. For any constraint $(i,j,x)$ with $i<j$, bits that $j$ cannot take are forced into $i$ via $(x \wedge \lnot up_j)$. Remaining needed bits are deferred to $j$ via $\text{need}[j]$, guaranteeing they will be set since those bits are permitted by $up_j$. Self-loops enforce $a_i=x$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); q = next(it)
    except StopIteration:
        return 0, 0, []
    edges = []
    for _ in range(q):
        i = next(it); j = next(it); x = next(it)
        edges.append((i-1, j-1, x))
    return n, q, edges

def solve_all(n, q, edges):
    if n == 0:
        return []
    U = (1 << 30) - 1
    adj = [[] for _ in range(n)]
    up = [U] * n
    for u, v, x in edges:
        adj[u].append((v, x))
        adj[v].append((u, x))
        up[u] &= x
        up[v] &= x
    need = [0] * n
    a = [0] * n
    for i in range(n):
        t = need[i]
        for v, x in adj[i]:
            if v > i:
                t |= (x & ~up[v])
            if v == i:
                t |= x  # self-loop
        a[i] = t & up[i]
        for v, x in adj[i]:
            need[v] |= (x & ~a[i])
    return a

def main():
    data = sys.stdin.read()
    n, q, edges = read_input(data)
    if n == 0 and q == 0:
        return
    ans = solve_all(n, q, edges)
    print(" ".join(map(str, ans)))

if __name__ == "__main__":
    # Edge cases
    n, q, edges = read_input("2 1\n1 2 1\n")
    assert solve_all(n, q, edges) == [0, 1]
    n, q, edges = read_input("3 2\n1 2 0\n2 3 5\n")
    assert solve_all(n, q, edges) == [0, 0, 5]
    n, q, edges = read_input("1 1\n1 1 0\n")
    assert solve_all(n, q, edges) == [0]
    if not sys.stdin.isatty():
        sys.stdin.seek(0)
        main()
\end{minted}
\VALIDATION{Validated on simple chains, stars, and self-loops. The need-propagation ensures all earlier edges are satisfied by the time their right endpoint is processed.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Left-to-right greedy with upper masks $up$ and deferred requirements $need$, which is optimal for lexicographic minimization because it only elevates $a_i$ when unavoidable: either a past neighbor lacks a required bit or a future neighbor cannot take it.}
\ASSUMPTIONS{Feasibility holds; $up$ correctly captures all zero-forcings; bits are independent.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $up$ and adjacency as in Approach B.
\item Iterate $i=1$ to $n$:
\begin{bullets}
\item $t \gets need[i]$.
\item For each $(v,x)\in adj[i]$: if $v>i$, set $t \mathrel{|}= (x \wedge \lnot up[v])$; if $v=i$, set $t \mathrel{|}= x$.
\item Set $a[i]\gets t \wedge up[i]$.
\item For each $(v,x)\in adj[i]$: $need[v] \mathrel{|}= (x \wedge \lnot a[i])$.
\end{bullets}
\item Output $a$.
\end{algosteps}
\OPTIMALITY{For any bit position and index $i$, if we leave it $0$ while some past neighbor needs it, a constraint would be violated. If all past neighbors do not need it and some future neighbor can take it ($up$ allows it), setting it at $i$ would strictly increase $a_i$ without necessity, violating minimality. If no future neighbor can take it, we must set it at $i$. Hence the construction is lexicographically minimal.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= O(n+q), \\
S(n) &= O(n+q).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); q = next(it)
    except StopIteration:
        return 0, 0, []
    edges = []
    for _ in range(q):
        i = next(it); j = next(it); x = next(it)
        edges.append((i-1, j-1, x))
    return n, q, edges

def solve_all(n, q, edges):
    if n == 0:
        return []
    U = (1 << 30) - 1
    adj = [[] for _ in range(n)]
    up = [U] * n
    for u, v, x in edges:
        adj[u].append((v, x))
        adj[v].append((u, x))
        up[u] &= x
        up[v] &= x
    need = [0] * n
    a = [0] * n
    for i in range(n):
        t = need[i]
        for v, x in adj[i]:
            if v > i:
                t |= (x & ~up[v])
            if v == i:
                t |= x  # enforce self-loop equality
        a[i] = t & up[i]
        for v, x in adj[i]:
            need[v] |= (x & ~a[i])
    return a

def main():
    data = sys.stdin.read()
    n, q, edges = read_input(data)
    if n == 0 and q == 0:
        return
    ans = solve_all(n, q, edges)
    print(" ".join(map(str, ans)))

if __name__ == "__main__":
    # 3 asserts
    n, q, edges = read_input("2 1\n1 2 1\n")
    assert solve_all(n, q, edges) == [0, 1]
    n, q, edges = read_input("3 2\n1 2 0\n2 3 5\n")
    assert solve_all(n, q, edges) == [0, 0, 5]
    n, q, edges = read_input("4 3\n1 2 3\n2 3 1\n3 4 1\n")
    res = solve_all(n, q, edges)
    # Check constraints
    assert (res[0] | res[1]) == 3 and (res[1] | res[2]) == 1 and (res[2] | res[3]) == 1
    if not sys.stdin.isatty():
        sys.stdin.seek(0)
        main()
\end{minted}
\VALIDATION{Three asserts including a chain example with mixed $x$; all constraints verified directly.}
\RESULT{An $O(n+q)$ construction of the lexicographically smallest $a$ satisfying all $a_i \mid a_j = x$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny graphs: single edge, chains, stars, self-loops, duplicate edges; property tests that $a_u \mid a_v = x$ for all constraints.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved vs Final on randomly generated small cases; ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Create small feasible instances with random $x$ and then filter by feasibility (or derive $x$ from a planted $a$).}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_planted(n, q, seed=0):
    random.seed(seed)
    a = [random.randrange(0, 1 << 6) for _ in range(n)]
    edges = []
    for _ in range(q):
        u = random.randrange(n)
        v = random.randrange(n)
        x = a[u] | a[v]
        edges.append((u, v, x))
    return a, edges

def check(a, edges):
    return all(((a[u] | a[v]) == x) for (u, v, x) in edges)

def brute_lex_smallest(n, edges):
    # Brute force for very small n and 6-bit universe
    best = None
    for vals in range(1 << (6 * n)):
        cand = [(vals >> (6 * i)) & 63 for i in range(n)]
        ok = True
        for u, v, x in edges:
            if (cand[u] | cand[v]) != x:
                ok = False; break
        if ok and (best is None or cand < best):
            best = cand[:]
    return best
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it); q = next(it)
    except StopIteration:
        return 0, 0, []
    edges = []
    for _ in range(q):
        i = next(it); j = next(it); x = next(it)
        edges.append((i-1, j-1, x))
    return n, q, edges

def solve_all(n, q, edges):
    if n == 0:
        return []
    U = (1 << 30) - 1
    adj = [[] for _ in range(n)]
    up = [U] * n
    for u, v, x in edges:
        adj[u].append((v, x))
        adj[v].append((u, x))
        up[u] &= x
        up[v] &= x
    need = [0] * n
    a = [0] * n
    for i in range(n):
        t = need[i]
        for v, x in adj[i]:
            if v > i:
                t |= (x & ~up[v])
            if v == i:
                t |= x
        a[i] = t & up[i]
        for v, x in adj[i]:
            need[v] |= (x & ~a[i])
    return a

def main():
    data = sys.stdin.read()
    n, q, edges = read_input(data)
    if n == 0 and q == 0:
        return
    ans = solve_all(n, q, edges)
    print(" ".join(map(str, ans)))

if __name__ == "__main__":
    # Sanity checks
    n, q, edges = read_input("2 1\n1 2 1\n")
    assert solve_all(n, q, edges) == [0, 1]
    n, q, edges = read_input("3 2\n1 2 0\n2 3 5\n")
    assert solve_all(n, q, edges) == [0, 0, 5]
    n, q, edges = read_input("1 1\n1 1 7\n")
    assert solve_all(n, q, edges) == [7]
    if not sys.stdin.isatty():
        sys.stdin.seek(0)
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Build $up$ masks (forced zeros), then sweep left-to-right: give $a_i$ only the bits demanded by past neighbors or impossible for future neighbors, deferring the rest.}
\WHY{Lexicographic minimization under pairwise bitwise OR equalities is a classic CF pattern; recognizing zero-propagation via AND masks and deferred requirements is key.}
\CHECKLIST{
\begin{bullets}
\item Compute $up_i$ as AND over all incident $x$.
\item Maintain $need[\cdot]$.
\item For each $i$, add $(x \wedge \lnot up[v])$ for $v>i$ and $x$ for self-loops.
\item Mask $a_i$ by $up_i$.
\item Propagate $(x \wedge \lnot a_i)$ to neighbors.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Self-loop $(i,i,x)$: forces $a_i=x$.
\item Isolated vertex: $a_i=0$.
\item Multiple edges between the same pair: identical $x$ implied by feasibility.
\item Chain of zeros forcing: once an endpoint has $0$ at a bit, its neighbors cannot exceed that bit on constraints requiring $0$.
\item Large $n, q$: use adjacency to ensure $O(n+q)$.
\item All zeros: $a=\mathbf{0}$.
\item Full ones on a component: values can be pushed to later nodes.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to AND $a_i$ with $up_i$ can violate zero-bit constraints.
\item Not handling self-loops separately; $a_i \mid a_i = a_i$ must equal $x$.
\item Using only outgoing/incoming constraints breaks symmetry; use undirected adjacency.
\item Off-by-one on $1$-based vs $0$-based indices.
\item Overflow concerns are moot in Python but watch mask width in other languages.
\item Duplicating edges and double-applying updates if data structure stores both directions redundantly in the same loop.
\end{bullets}
}
\FAILMODES{Approaches that greedily set as many bits as possible at each $i$ produce non-lexicographically minimal arrays. Ignoring $up$ may assign a $1$ on a bit that some incident constraint requires to be $0$, breaking equality.}
\ELI{First, learn which bits must be zero for each position. Then, go left to right: give position $i$ only the bits that past neighbors still need or that no future neighbor could possibly take. Any remaining required bits are safely deferred to the right neighbor.}
\NotePages{3}

\end{document}