% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Timofey and rectangles}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/763/B}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{One of Timofey's birthday presents is a colourbook in a shape of an infinite plane. On the plane $n$ rectangles with sides parallel to coordinate axes are situated. All sides of the rectangles have odd length. Rectangles cannot intersect, but they can touch each other.

Help Timofey to color his rectangles in $4$ different colors in such a way that every two rectangles touching each other by side would have different color, or determine that it is impossible.

Two rectangles intersect if their intersection has positive area. Two rectangles touch by sides if there is a pair of sides such that their intersection has non-zero length.

The picture corresponds to the first example.

Input:
The first line contains single integer $n$ ($1 \le n \le 5 \cdot 10^5$) — the number of rectangles.

$n$ lines follow. The $i$-th of these lines contains four integers $x_1, y_1, x_2$ and $y_2$ ($-10^9 \le x_1 < x_2 \le 10^9$, $-10^9 \le y_1 < y_2 \le 10^9$), that means that points $(x_1, y_1)$ and $(x_2, y_2)$ are the coordinates of two opposite corners of the $i$-th rectangle.

It is guaranteed that all sides of the rectangles have odd lengths and rectangles do not intersect each other.

Output:
Print ``NO'' in the only line if it is impossible to color the rectangles in $4$ different colors in such a way that every two rectangles touching each other by side would have different color.

Otherwise, print ``YES'' in the first line. Then print $n$ lines, in the $i$-th of them print single integer $c_i$ ($1 \le c_i \le 4$) — the color of $i$-th rectangle.}
\BREAKDOWN{We need to color axis-aligned, pairwise non-intersecting rectangles (with odd side lengths) so that any pair sharing a side segment of positive length have different colors. Show a constructive $4$-coloring or detect impossibility. The odd side-length constraint hints at a parity-based construction.}
\ELI{Color each rectangle by the parity of its lower-left corner: left/right neighbors flip $x$ parity and up/down neighbors flip $y$ parity, so touching rectangles always differ.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item Integer $n$ ($1 \le n \le 5 \cdot 10^5$).
\item For each $i \in \{1,\ldots,n\}$: integers $x_1, y_1, x_2, y_2$ with $-10^9 \le x_1 < x_2 \le 10^9$, $-10^9 \le y_1 < y_2 \le 10^9$, and both $(x_2-x_1)$ and $(y_2-y_1)$ odd.
\end{bullets}}
\OUTPUTS{
\begin{bullets}
\item Print YES and then $n$ integers $c_i \in \{1,2,3,4\}$, one per line, a valid coloring; or
\item Print NO if impossible (this never happens under the given constraints due to the odd-length property).
\end{bullets}}
\SAMPLES{Example 1:
\begin{tcolorbox}
Input
\begin{verbatim}
2
0 0 3 3
3 0 6 3
\end{verbatim}
Output
\begin{verbatim}
YES
1
3
\end{verbatim}
\end{tcolorbox}
Example 2:
\begin{tcolorbox}
Input
\begin{verbatim}
3
-3 -1 -2 2
-2 -1 1 2
-2 2 1 5
\end{verbatim}
Output
\begin{verbatim}
YES
4
2
1
\end{verbatim}
\end{tcolorbox}
Note: Multiple valid outputs may exist; shown outputs match the parity construction.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathcal{R}=\{R_i\}_{i=1}^n$ be axis-aligned rectangles with coordinates $(x_1^{(i)},y_1^{(i)},x_2^{(i)},y_2^{(i)})$ and odd side lengths: $(x_2^{(i)}-x_1^{(i)})$ and $(y_2^{(i)}-y_1^{(i)})$ are odd. Define a graph $G=(V,E)$ with $V=\{1,\ldots,n\}$ and $\{i,j\}\in E$ if $R_i$ and $R_j$ share a side segment of positive length. We seek a mapping $c:V\to\{1,2,3,4\}$ such that adjacent vertices receive different colors.}
\varmapStart
\var{R_i}{the $i$-th rectangle}
\var{(x_1^{(i)},y_1^{(i)})}{its lower-left corner}
\var{(x_2^{(i)},y_2^{(i)})}{its upper-right corner}
\var{c(i)}{assigned color in $\{1,2,3,4\}$}
\var{G}{touch-by-side adjacency graph}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{For all } i:~ (x_2^{(i)}-x_1^{(i)}) \equiv 1 \pmod{2},\quad (y_2^{(i)}-y_1^{(i)}) \equiv 1 \pmod{2}.\\
&\{i,j\}\in E ~\Longleftrightarrow~
\bigl(x_2^{(i)}=x_1^{(j)} \lor x_1^{(i)}=x_2^{(j)}\bigr)\ \land\ \operatorname{len}\bigl([y_1^{(i)},y_2^{(i)}]\cap[y_1^{(j)},y_2^{(j)}]\bigr)>0\\
&\qquad\qquad\quad\lor~
\bigl(y_2^{(i)}=y_1^{(j)} \lor y_1^{(i)}=y_2^{(j)}\bigr)\ \land\ \operatorname{len}\bigl([x_1^{(i)},x_2^{(i)}]\cap[x_1^{(j)},x_2^{(j)}]\bigr)>0.\\
&\text{Goal: } \forall\{i,j\}\in E:\ c(i)\ne c(j).
\end{aligned}
\]
}
\ASSUMPTIONS{Rectangles are closed sets for contact purposes; they do not overlap with positive area; side-touching is along a segment of non-zero length; coordinates are integers.}
\INVARIANTS{
\begin{bullets}
\item Parity flip: If two rectangles touch vertically, then $x_1$ parities differ; if they touch horizontally, $y_1$ parities differ.
\item Mapping $\phi(i)=(x_1^{(i)} \bmod 2, y_1^{(i)} \bmod 2)$ yields $4$ classes; any edge connects distinct classes.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Build the adjacency graph explicitly and then color greedily using $4$ colors. This is conceptually straightforward but too slow at $O(n^2)$ to build edges.}
\ASSUMPTIONS{Small $n$ for feasibility; use interval overlap tests to detect side-touching.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each pair $(i,j)$, check vertical or horizontal side-contact with positive overlap to add an edge.
\item Perform greedy coloring in any order with color set $\{1,2,3,4\}$.
\item If any vertex needs a fifth color, report NO; otherwise print the coloring.
\end{algosteps}
\COMPLEXITY{Pairwise contact checks dominate.}
\[
\begin{aligned}
T(n) &= \Theta(n^2) \text{ contact checks } + \Theta(n \Delta) \text{ greedy} \\
     &= \Theta(n^2). \\
S(n) &= \Theta(n + |E|) \le \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{Greedy coloring succeeds on chordal-like orders, but may fail in general even if a $4$-coloring exists. Hence as a baseline it is not robust.}
\EDGECASES{Degenerate overlaps at a point are not edges; only segments of non-zero length count.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> List[Tuple[int,int,int,int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    rects = []
    for _ in range(n):
        x1 = int(next(it)); y1 = int(next(it)); x2 = int(next(it)); y2 = int(next(it))
        rects.append((x1,y1,x2,y2))
    return rects

def touch_side(a: Tuple[int,int,int,int], b: Tuple[int,int,int,int]) -> bool:
    ax1, ay1, ax2, ay2 = a
    bx1, by1, bx2, by2 = b
    # vertical side touch
    if ax2 == bx1 or ax1 == bx2:
        lo = max(ay1, by1)
        hi = min(ay2, by2)
        if hi - lo > 0:
            return True
    # horizontal side touch
    if ay2 == by1 or ay1 == by2:
        lo = max(ax1, bx1)
        hi = min(ax2, bx2)
        if hi - lo > 0:
            return True
    return False

def greedy_four_color(rects: List[Tuple[int,int,int,int]]) -> Tuple[bool, List[int]]:
    n = len(rects)
    # Build full adjacency (baseline; O(n^2))
    adj = [[] for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            if touch_side(rects[i], rects[j]):
                adj[i].append(j)
                adj[j].append(i)
    colors = [0]*n
    for i in range(n):
        used = {colors[j] for j in adj[i] if colors[j] != 0}
        # try to assign one of 1..4
        assigned = 0
        for c in range(1, 5):
            if c not in used:
                assigned = c
                break
        if assigned == 0:
            return (False, [])
        colors[i] = assigned
    return (True, colors)

def solve_all(rects: List[Tuple[int,int,int,int]]) -> str:
    ok, colors = greedy_four_color(rects)
    if not ok:
        return "NO"
    out = ["YES"]
    out.extend(str(c) for c in colors)
    return "\n".join(out)

def main():
    rects = read_input()
    if rects:
        print(solve_all(rects))

if __name__ == "__main__":
    # Tiny asserts for baseline on small inputs
    r1 = (0,0,3,3)
    r2 = (3,0,6,3)
    ans = solve_all([r1,r2]).splitlines()
    assert ans[0] == "YES" and ans[1] != ans[2]
    # No-touch case: same color allowed
    r3 = (10,10,13,13)
    ans2 = solve_all([r1,r3]).splitlines()
    assert ans2[0] == "YES"
    # Horizontal touch
    r4 = (0,3,3,6)
    ans3 = solve_all([r1,r4]).splitlines()
    assert ans3[0] == "YES" and ans3[1] != ans3[2]
    main()
\end{minted}
\VALIDATION{Tested on pairs that touch vertically and horizontally; verified differing colors.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Parity Coloring: O(n)}
\WHICHFORMULA{Exploit odd side lengths: if two rectangles touch vertically, their $x_1$ parities differ; if they touch horizontally, their $y_1$ parities differ. Thus color by the pair $(x_1 \bmod 2, y_1 \bmod 2)$.}
\ASSUMPTIONS{All sides have odd integer length; coordinates are integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each rectangle, compute $p_x = x_1 \bmod 2$ and $p_y = y_1 \bmod 2$.
\item Map $(p_x,p_y)\in\{0,1\}^2$ to colors $\{1,2,3,4\}$, e.g., $1+2p_x+p_y$.
\item Output YES and the color list.
\end{algosteps}
\COMPLEXITY{One pass over $n$ rectangles with $O(1)$ work each.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1) \text{ (excluding input/output).}
\end{aligned}
\]
\CORRECTNESS{If two rectangles share a vertical side, then $x_2^{(i)}=x_1^{(j)}$, and since widths are odd, $x_2^{(i)}\equiv x_1^{(i)}+1\pmod{2}$ and $x_1^{(j)}\equiv x_1^{(i)}+1\pmod{2}$, so $p_x$ differs. Similarly for horizontal touch and $p_y$. Hence adjacent rectangles get different $(p_x,p_y)$ and thus different colors.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> List[Tuple[int,int,int,int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    rects = []
    for _ in range(n):
        x1 = int(next(it)); y1 = int(next(it)); x2 = int(next(it)); y2 = int(next(it))
        rects.append((x1,y1,x2,y2))
    return rects

def parity_color_rectangles(rects: List[Tuple[int,int,int,int]]) -> List[int]:
    colors = []
    for x1,y1,x2,y2 in rects:
        px = x1 & 1
        py = y1 & 1
        c = 1 + (px << 1) + py
        colors.append(c)
    return colors

def solve_all(rects: List[Tuple[int,int,int,int]]) -> str:
    cols = parity_color_rectangles(rects)
    out = ["YES"]
    out.extend(str(c) for c in cols)
    return "\n".join(out)

def main():
    rects = read_input()
    if rects:
        print(solve_all(rects))

if __name__ == "__main__":
    # Deterministic asserts
    # Vertical touch -> different colors
    r1 = (0,0,3,3)
    r2 = (3,0,6,3)
    cols = parity_color_rectangles([r1,r2])
    assert cols[0] != cols[1]
    # Horizontal touch -> different colors
    r3 = (0,3,3,6)
    cols2 = parity_color_rectangles([r1,r3])
    assert cols2[0] != cols2[1]
    # Negative coordinates parity still works
    r4 = (-3,-5,-2,-2)  # widths/heights odd
    c4 = parity_color_rectangles([r4])[0]
    assert c4 in (1,2,3,4)
    main()
\end{minted}
\VALIDATION{Checked vertical and horizontal touches and negative-coordinate rectangles; colors always in $\{1,2,3,4\}$ and differ when touching.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Final Parity-Based 4-Coloring}
\WHICHFORMULA{Final method: $c=1+2\cdot(x_1 \bmod 2)+(y_1 \bmod 2)$.}
\ASSUMPTIONS{All side lengths are odd. No intersections with positive area.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read all rectangles.
\item Compute color $c_i = 1 + 2\cdot(x_1^{(i)} \bmod 2) + (y_1^{(i)} \bmod 2)$.
\item Print YES and the $c_i$ values in input order.
\end{algosteps}
\OPTIMALITY{Runs in linear time and constant extra space; no graph construction needed. The $4$ colors are tight for this construction as we use all parity combinations.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1) \text{ (excluding output buffer).}
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> List[Tuple[int,int,int,int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    rects = []
    for _ in range(n):
        x1 = int(next(it)); y1 = int(next(it)); x2 = int(next(it)); y2 = int(next(it))
        rects.append((x1,y1,x2,y2))
    return rects

def solve_all(rects: List[Tuple[int,int,int,int]]) -> str:
    out = ["YES"]
    for x1,y1,x2,y2 in rects:
        px = x1 & 1
        py = y1 & 1
        c = 1 + (px << 1) + py
        out.append(str(c))
    return "\n".join(out)

def main():
    rects = read_input()
    if rects:
        sys.stdout.write(solve_all(rects))

if __name__ == "__main__":
    # Exactly 3 asserts
    # 1) Vertical adjacency
    s = [(0,0,3,3),(3,0,6,3)]
    res = solve_all(s).splitlines()
    assert res[0] == "YES" and res[1] != res[2]
    # 2) Horizontal adjacency
    s2 = [(10,10,13,13),(10,13,13,16)]
    res2 = solve_all(s2).splitlines()
    assert res2[0] == "YES" and res2[1] != res2[2]
    # 3) Negative coords, odd sizes
    s3 = [(-3,-1,-2,2)]
    res3 = solve_all(s3).splitlines()
    assert res3[0] == "YES" and res3[1] in ("1","2","3","4")
    main()
\end{minted}
\VALIDATION{Three asserts cover vertical and horizontal touches and negative coordinates with odd sizes.}
\RESULT{Always outputs YES and a valid $4$-coloring with $c_i \in \{1,2,3,4\}$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests verify the parity-coloring invariant on crafted touching cases (vertical and horizontal) and parity handling for negative coordinates. Property: touching rectangles must differ in color.}
\LINE{CROSS-CHECKS}{Compare Approach A and C on small random instances to ensure both produce valid colorings; Approach C should never fail while A might in pathological orderings.}
\LINE{EDGE-CASE GENERATOR}{Generate rectangles on a coarse grid of odd-sized boxes to create many side contacts; also generate separated rectangles and negative-coordinate cases.}
\begin{minted}{python}
import random

def gen_rect(base_x, base_y, w, h):
    # Ensure odd sizes: w, h odd positive
    return (base_x, base_y, base_x + w, base_y + h)

def grid_instances(rows=3, cols=3, size=3, gap=0):
    rects = []
    for i in range(rows):
        for j in range(cols):
            x = j*(size+gap)
            y = i*(size+gap)
            rects.append(gen_rect(x, y, size, size))
    return rects

def random_instances(n=20, coord_range=50):
    rects = []
    used = []
    attempts = 0
    while len(rects) < n and attempts < n*100:
        attempts += 1
        x1 = random.randint(-coord_range, coord_range)
        y1 = random.randint(-coord_range, coord_range)
        w = random.randrange(1, 11, 2)
        h = random.randrange(1, 11, 2)
        x2 = x1 + w
        y2 = y1 + h
        # Avoid intersection with existing by simple rejection on area overlap
        ok = True
        for (ax1,ay1,ax2,ay2) in rects:
            if not (x2 <= ax1 or ax2 <= x1 or y2 <= ay1 or ay2 <= y1):
                ok = False
                break
        if ok:
            rects.append((x1,y1,x2,y2))
    return rects

def parity_colors(rects):
    return [1 + ((x1 & 1) << 1) + (y1 & 1) for (x1,y1,_,_) in rects]

def touches(a,b):
    ax1,ay1,ax2,ay2 = a
    bx1,by1,bx2,by2 = b
    if ax2 == bx1 or ax1 == bx2:
        if min(ay2,by2) - max(ay1,by1) > 0:
            return True
    if ay2 == by1 or ay1 == by2:
        if min(ax2,bx2) - max(ax1,bx1) > 0:
            return True
    return False

def check_coloring(rects, colors):
    n = len(rects)
    for i in range(n):
        for j in range(i+1, n):
            if touches(rects[i], rects[j]):
                assert colors[i] != colors[j]

# Cross-check grid instances
R = grid_instances(2, 3, 3, 0)
C = parity_colors(R)
check_coloring(R, C)

# Random tests
R2 = random_instances(30, coord_range=100)
C2 = parity_colors(R2)
check_coloring(R2, C2)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    n = int(next(it))
    rects = []
    for _ in range(n):
        x1 = int(next(it)); y1 = int(next(it)); x2 = int(next(it)); y2 = int(next(it))
        rects.append((x1,y1,x2,y2))
    return rects

def solve_all(rects):
    out = ["YES"]
    for x1,y1,x2,y2 in rects:
        c = 1 + ((x1 & 1) << 1) + (y1 & 1)
        out.append(str(c))
    return "\n".join(out)

def main():
    rects = read_input()
    if rects:
        sys.stdout.write(solve_all(rects))

if __name__ == "__main__":
    # Basic sanity checks
    assert solve_all([(0,0,3,3),(3,0,6,3)]).splitlines()[0] == "YES"
    col1 = solve_all([(0,0,3,3)]).splitlines()[1]
    assert col1 in ("1","2","3","4")
    # Horizontal touch differs
    out = solve_all([(0,0,3,3),(0,3,3,6)]).splitlines()
    assert out[1] != out[2]
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Color each rectangle by the parity class of its lower-left corner: $c=1+2(x_1 \bmod 2)+(y_1 \bmod 2)$.}
\WHY{Odd side lengths guarantee that moving across a touching side flips the corresponding parity, ensuring adjacent rectangles differ. This trick appears in geometry and grid-parity problems.}
\CHECKLIST{
\begin{bullets}
\item Confirm widths and heights are odd.
\item Define $p_x=x_1 \bmod 2$, $p_y=y_1 \bmod 2$.
\item Map $(p_x,p_y)$ to $\{1,2,3,4\}$ consistently.
\item Output YES and the colors.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Rectangles touching only at a corner: not adjacent; same color allowed.
\item Negative coordinates: use bitwise parity $(x \& 1)$ to avoid modulo pitfalls.
\item Large coordinates ($\pm 10^9$): arithmetic fits in $64$-bit Python ints.
\item Many rectangles with no contacts: any colors valid.
\item Chains of alternating contacts: parity guarantees alternation automatically.
\item Multiple rectangles meeting along the same line: parity still distinguishes neighbors.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using $(x \% 2)$ and assuming non-negative; in Python negative mod works but using bitwise $(x \& 1)$ is clearer.
\item Accidentally using $x_2$ or $y_2$ parities; $x_1$ and $y_1$ are consistent but any fixed corner works if consistent.
\item Mishandling the definition of ``touch by side'' (must be positive-length overlap).
\item Printing extra spaces or missing newlines in output format.
\item Forgetting to print YES first.
\item Using slow $O(n^2)$ adjacency checks unnecessarily.
\end{bullets}}
\FAILMODES{Baseline greedy can fail on some graphs; parity method avoids graph construction and always satisfies constraints under odd side lengths.}
\ELI{Because each rectangle's width and height are odd, crossing a shared vertical side flips the left $x$ parity, and crossing a shared horizontal side flips the $y$ parity. So labeling by $(x_1\bmod 2,y_1\bmod 2)$ guarantees neighbors differ, using at most four colors.}
\NotePages{3}

\end{document}