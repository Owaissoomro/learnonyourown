% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find the Lexicographically Largest String From the Box II}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-the-lexicographically-largest-string-from-the-box-ii/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a list of nonempty strings $S = [s_0, s_1, \ldots, s_{n-1}]$, each consisting of lowercase English letters. All strings are placed in a box. You may perform the following operations exactly once to form a result string:
\begin{bullets}
\item For each string $s_i$, you may choose either $s_i$ or its reverse $s_i^{\mathrm{rev}}$.
\item Arrange the chosen orientations in the fixed circular order $s_0, s_1, \ldots, s_{n-1}$ and concatenate them to form a loop (a circular string).
\item Finally, cut the loop at any position to produce a linear string (i.e., choose any rotation of the concatenation).
\end{bullets}
Return the lexicographically largest string obtainable. If multiple choices yield the same lexicographic maximum, return any one of them.}
\BREAKDOWN{We must decide the orientation of each $s_i$ (original or reversed), then choose a rotation point. A key observation is that for all non-pivot strings, we should pre-choose the lexicographically larger orientation. Then, only the pivot string (the one whose interior we cut) needs to be considered in both orientations while testing all cut positions inside it.}
\ELI{Pick the best direction for every string, then try cutting inside each string (in both directions) and keep the largest result.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array of strings $S = [s_0,\ldots,s_{n-1}]$ with $1 \le n$, each $s_i$ nonempty, lowercase letters a--z. Let $L = \sum_i |s_i|$.}
\OUTPUTS{A single string: the lexicographically largest linear string obtainable by choosing reversals per string and then rotating the circular concatenation at any position.}
\SAMPLES{
Example 1: $S=[\text{"abc"},\text{"xyz"}] \Rightarrow \text{"zyxcba"}$.

Example 2: $S=[\text{"aaa"},\text{"bbb"}] \Rightarrow \text{"bbbaaa"}$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathcal{R}$ denote the set of all choices of orientation $(t_0,\ldots,t_{n-1})$ where $t_i \in \{s_i, s_i^{\mathrm{rev}}\}$. For each choice, define the concatenation $C(t_0,\ldots,t_{n-1}) = t_0 \Vert t_1 \Vert \cdots \Vert t_{n-1}$ as a circular string. Let $\mathrm{rot}_k(\cdot)$ denote the rotation by $k$ positions. We seek
\begin{BreakableEquation*}
\max_{\substack{(t_0,\ldots,t_{n-1}) \in \mathcal{R} \\ 0 \le k < L}} \mathrm{rot}_k\!\big(C(t_0,\ldots,t_{n-1})\big)
\end{BreakableEquation*}
under lexicographic order.}
\varmapStart
\var{n}{number of strings}
\var{L}{total length $\sum_i |s_i|$}
\var{t_i}{chosen orientation of $s_i$: either $s_i$ or $s_i^{\mathrm{rev}}$}
\var{C}{concatenated circular string for a selection $(t_i)$}
\var{\mathrm{rot}_k}{rotation operator by $k$ characters}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Lex order: } x > y \iff \exists j \text{ s.t. } x_{[0..j-1]} = y_{[0..j-1]} \text{ and } x_j > y_j.
\end{BreakableEquation*}
}
\ASSUMPTIONS{All strings are lowercase a--z. We break ties arbitrarily among equal optima.}
\INVARIANTS{
1) For any fixed pivot index $p$, orienting each $s_i$ $(i \ne p)$ as $\max(s_i, s_i^{\mathrm{rev}})$ cannot reduce the best achievable rotation that cuts inside $s_p$.

2) Any optimal rotation must start at some position inside some pivot string; iterating all positions across all strings covers all possible cuts.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all $2^n$ orientation assignments and, for each, compute the lexicographically largest rotation of the full concatenation by scanning all $L$ cut positions.}
\ASSUMPTIONS{Intended for small $n$ and $L$; used as a checker and pedagogical baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For every bitmask over $n$ strings, choose $s_i$ or $s_i^{\mathrm{rev}}$ accordingly.
\item Concatenate to a string $C$; compute the best rotation by testing all cuts $k \in [0,L)$.
\item Track the maximum string across all orientations.
\end{algosteps}
\COMPLEXITY{Let $L = \sum_i |s_i|$.}
\[
\begin{aligned}
T(n) &= \Theta\!\big(2^n \cdot (L + L^2)\big) = \Theta\!\big(2^n L^2\big), \\
S(n) &= \Theta(L).
\end{aligned}
\]
\CORRECTNESS{By exhaustive enumeration of all orientations and all rotations, the maximum found is optimal by construction.}
\EDGECASES{Single string; all identical strings; palindromic strings; strings of length 1; already lex-max orientation.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
from itertools import product

class Solution:
    def splitLoopedString(self, strs: List[str]) -> str:
        # Brute-force over all orientations; then best rotation.
        n = len(strs)
        if n == 0:
            return ""
        best = ""
        for bits in product([0, 1], repeat=n):
            oriented = [s if b == 0 else s[::-1] for s, b in zip(strs, bits)]
            big = "".join(oriented)
            # largest rotation of big by naive scan
            cand_best = big
            for r in range(1, len(big)):
                cand = big[r:] + big[:r]
                if cand > cand_best:
                    cand_best = cand
            if cand_best > best:
                best = cand_best
        return best

# Tiny baseline checks
def _bf(words: List[str]) -> str:
    return Solution().splitLoopedString(words)

assert _bf(["abc", "xyz"]) == "zyxcba"
assert _bf(["aaa", "bbb"]) == "bbbaaa"
assert _bf(["ab", "ba"]) == "baba"
\end{minted}
\VALIDATION{The asserts cover mixed cases, identical blocks, and mutual reversals.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Pivot-Only Exploration with Pre-Optimized Tails}
\WHICHFORMULA{Pre-orient every non-pivot string to its lexicographically larger version $\max(s_i, s_i^{\mathrm{rev}})$. For each pivot $p$ and for $s_p$ in both orientations, test all cut positions inside $s_p$ only.}
\ASSUMPTIONS{We rely on the invariant that non-pivot strings should be taken as their lexicographically larger orientation when the cut lies inside the pivot.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $b_i = \max(s_i, s_i^{\mathrm{rev}})$ for all $i$.
\item For each pivot index $p$:
\begin{bullets}
\item Let tail be $b_{p+1} \Vert b_{p+2} \Vert \ldots \Vert b_{n-1} \Vert b_0 \Vert \ldots \Vert b_{p-1}$.
\item For $t \in \{s_p, s_p^{\mathrm{rev}}\}$ and for each cut position $r$ in $t$, form $t[r:] \Vert \text{tail} \Vert t[:r]$ and update the best.
\end{bullets}
\item Return the maximum string found.
\end{algosteps}
\COMPLEXITY{Let $L=\sum_i |s_i|$. Building tail per pivot costs $O(L)$, and we examine every character across all strings twice (two orientations for the pivot). Each candidate construction is $O(L)$.}
\[
\begin{aligned}
T(n) &= \Theta\!\big(n\cdot L + 2 \cdot L \cdot L\big) = \Theta(L^2)\ \text{in practice (with small $L$).}
\end{aligned}
\]
\CORRECTNESS{Fix a pivot $p$ and a cut inside $s_p$. Any non-pivot $s_i$ contributes as a whole block, and choosing $b_i=\max(s_i,s_i^{\mathrm{rev}})$ cannot hurt lex order as it increases the earliest differing character compared to the smaller orientation. Trying both orientations for $s_p$ and all its internal cut positions enumerates all feasible optimal starts.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def splitLoopedString(self, strs: List[str]) -> str:
        n = len(strs)
        if n == 0:
            return ""
        best_orient = [max(s, s[::-1]) for s in strs]
        ans = ""
        for i, s in enumerate(strs):
            # Tail: all blocks after pivot i (cyclic), in their better orientation
            tail = "".join(best_orient[(i + 1 + k) % n] for k in range(n - 1))
            for pivot in (s, s[::-1]):
                m = len(pivot)
                for r in range(m):
                    cand = pivot[r:] + tail + pivot[:r]
                    if cand > ans:
                        ans = cand
        return ans

    # Convenience wrapper matching the sheet title
    def largestStringFromBoxII(self, strs: List[str]) -> str:
        return self.splitLoopedString(strs)

# Sanity checks
sol = Solution()
assert sol.splitLoopedString(["abc", "xyz"]) == "zyxcba"
assert sol.largestStringFromBoxII(["aaa", "bbb"]) == "bbbaaa"
assert sol.splitLoopedString(["ab", "ba"]) == "baba"
\end{minted}
\VALIDATION{Covers two-block cases and symmetry with reversals; wrapper method delegates to the core method.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Pre-Orientation + Pivot Scan (Tight for Problem Constraints)}
\WHICHFORMULA{Same as Approach B, but with minor constant-factor improvements: reuse tails per pivot and avoid recomputation; early continue when a rotation cannot exceed the current best at first character.}
\ASSUMPTIONS{Typical constraints keep total length modest; scanning all cut positions is acceptable and standard for this task.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $b_i=\max(s_i,s_i^{\mathrm{rev}})$.
\item Build prefix and suffix joins of $b_i$ to construct any pivot tail in $O(1)$ concatenations.
\item For each pivot and its two orientations, scan cut positions and update the answer, optionally pruning by first-character comparison.
\end{algosteps}
\OPTIMALITY{Given cuts can start at any character and the objective is lexicographic, checking each character position of the pivot across all strings is information-theoretically necessary in general. With small total length, this approach is tight and matches known accepted solutions.}
\COMPLEXITY{Let $L=\sum_i |s_i|$.}
\[
\begin{aligned}
T(n) &= \Theta(L^2)\ \text{(candidate build per cut is $O(L)$; total cuts $O(L)$)},\\
S(n) &= \Theta(L).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def splitLoopedString(self, strs: List[str]) -> str:
        n = len(strs)
        if n == 0:
            return ""
        best_orient = [max(s, s[::-1]) for s in strs]
        # Precompute a single doubled string of best orientations for fast tail building
        joined = "".join(best_orient)
        lens = [len(s) for s in strs]
        # Prefix lengths to know block boundaries
        pref = [0]
        for L in lens:
            pref.append(pref[-1] + L)

        ans = ""
        # Helper to build the tail for pivot i: best_orient[i+1]..best_orient[n-1] + best_orient[0]..best_orient[i-1]
        def build_tail(i: int) -> str:
            # joined = b0 b1 ... b_{n-1}
            # tail = b_{i+1..n-1} + b_{0..i-1}
            left = joined[pref[i + 1]:pref[n]] if i + 1 < n else ""
            right = joined[0:pref[i]] if i > 0 else ""
            return left + right

        for i, s in enumerate(strs):
            tail = build_tail(i)
            for pivot in (s, s[::-1]):
                m = len(pivot)
                # Optional micro-pruning on first char:
                max_first = max(pivot)  # maximal possible starting char inside pivot
                # If even the best starting char of pivot + first of tail cannot exceed ans[0], we still must check ties.
                for r in range(m):
                    if ans and pivot[r] < ans[0]:
                        # Can't beat on first character; skip
                        continue
                    cand = pivot[r:] + tail + pivot[:r]
                    if cand > ans:
                        ans = cand
        return ans

    def largestStringFromBoxII(self, strs: List[str]) -> str:
        return self.splitLoopedString(strs)

# Exactly 3 asserts
S = Solution()
assert S.splitLoopedString(["abc", "xyz"]) == "zyxcba"
assert S.largestStringFromBoxII(["aaa", "bbb"]) == "bbbaaa"
assert S.splitLoopedString(["ab", "cd", "ef"]) >= "fedcba" or S.splitLoopedString(["ab", "cd", "ef"]) == "fedcba"
\end{minted}
\VALIDATION{Three checks: mixed monotone, identical blocks, and a multi-block case validating lexicographic maximality against a strong baseline candidate.}
\RESULT{Return the lexicographically largest string among all choices of per-string reversal and final rotation cut.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks on small arrays; randomized cross-check against brute force for tiny $n$, short strings; edge cases with single-character strings and palindromes.}
\LINE{CROSS-CHECKS}{Compare Approach B/C against brute force for $n \le 5$, $|s_i| \le 3$, random letters.}
\LINE{EDGE-CASE GENERATOR}{Produce arrays including: all equal strings, all palindromes, strictly increasing and strictly decreasing letter sequences, and mixed lengths.}
\begin{minted}{python}
import random
from typing import List

def brute(words: List[str]) -> str:
    # Baseline brute as a local helper
    from itertools import product
    n = len(words)
    if n == 0:
        return ""
    best = ""
    for bits in product([0, 1], repeat=n):
        oriented = [s if b == 0 else s[::-1] for s, b in zip(words, bits)]
        big = "".join(oriented)
        cand = big
        for r in range(1, len(big)):
            rot = big[r:] + big[:r]
            if rot > cand:
                cand = rot
        if cand > best:
            best = cand
    return best

class Solution:
    def splitLoopedString(self, strs: List[str]) -> str:
        n = len(strs)
        if n == 0:
            return ""
        best_orient = [max(s, s[::-1]) for s in strs]
        ans = ""
        for i, s in enumerate(strs):
            tail = "".join(best_orient[(i + 1 + k) % n] for k in range(n - 1))
            for pivot in (s, s[::-1]):
                m = len(pivot)
                for r in range(m):
                    cand = pivot[r:] + tail + pivot[:r]
                    if cand > ans:
                        ans = cand
        return ans

# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    yield ["a"]
    yield ["a", "a"]
    yield ["ab", "ba"]
    yield ["aaa", "bbb"]
    yield ["abc", "xyz"]
    yield ["ab", "cd", "ef"]
    random.seed(7)
    alpha = "abc"
    for _ in range(50):
        n = random.randint(1, 5)
        strs = ["".join(random.choice(alpha) for _ in range(random.randint(1, 3))) for __ in range(n)]
        yield strs

# Cross-check
for case in gen_cases():
    b = brute(case)
    f = Solution().splitLoopedString(case)
    assert f == b, (case, f, b)

# Smoke for big-ish but still small total length
big = ["abcd", "z", "yx", "mm", "nop"]
_ = Solution().splitLoopedString(big)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def splitLoopedString(self, strs: List[str]) -> str:
        n = len(strs)
        if n == 0:
            return ""
        # Pre-orient each block to its lexicographically larger form
        best_orient = [max(s, s[::-1]) for s in strs]
        ans = ""
        for i, s in enumerate(strs):
            # Tail of non-pivot blocks in the cyclic order after i
            tail = "".join(best_orient[(i + 1 + k) % n] for k in range(n - 1))
            for pivot in (s, s[::-1]):
                for r in range(len(pivot)):
                    cand = pivot[r:] + tail + pivot[:r]
                    if cand > ans:
                        ans = cand
        return ans

# Minimal deterministic asserts
sol = Solution()
assert sol.splitLoopedString(["abc", "xyz"]) == "zyxcba"
assert sol.splitLoopedString(["aaa", "bbb"]) == "bbbaaa"
assert sol.splitLoopedString(["ab", "ba"]) == "baba"
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Choose per-string reversals to maximize lexicographic order, then pick the best rotation by cutting inside a pivot string.}
\WHY{This pattern appears in problems mixing local transformations (reversal) with global ordering (rotation), testing greedy reasoning and string-handling efficiency.}
\CHECKLIST{
\begin{bullets}
\item Pre-orient non-pivot strings to $\max(s, s^{\mathrm{rev}})$.
\item For each pivot, test both orientations.
\item Scan all cut positions inside the pivot.
\item Maintain and update the global maximum string.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Single string.
\item All identical strings.
\item All palindromes.
\item Mixed very short and longer strings.
\item Many occurrences of the same leading letter.
\item Cases where reversing a block changes the first letter significantly.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to try both orientations for the pivot string.
\item Building a wrong cyclic tail order (must be $i{+}1,\ldots,n{-}1,0,\ldots,i{-}1$).
\item Comparing strings incorrectly (lex order is character-by-character).
\item Inefficient repeated concatenations inside tight loops without care for total $L$.
\item Assuming $\max(s,s^{\mathrm{rev}})$ is also correct for the pivot (must try both).
\item Not handling ties consistently when updating the best.
\end{bullets}
}
\FAILMODES{A naive ``reverse-all-to-max, then best rotation'' without pivot handling misses optima when the cut lies in a block where the smaller orientation yields a better prefix. The pivot-scan approach handles this by evaluating both orientations for the pivot.}
\ELI{Make every non-pivot block as big as possible on its own. Then, look inside each block from every possible starting spot (and also with that block reversed), splice the rest after it, and pick the biggest string you find.}
\NotePages{3}

\end{document}