% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Modular Stability}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1359/E}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{We define $x \bmod y$ as the remainder of division of $x$ by $y$ ($\%$ operator in C++ or Java, mod operator in Pascal).

Let's call an array of positive integers $[a_1, a_2, \dots, a_k]$ stable if for every permutation $p$ of integers from $1$ to $k$, and for every non-negative integer $x$, the following condition is met:
\[
  (((x \bmod a_1) \bmod a_2) \dots \bmod a_{k - 1}) \bmod a_k
  =
  (((x \bmod a_{p_1}) \bmod a_{p_2}) \dots \bmod a_{p_{k - 1}}) \bmod a_{p_k}.
\]
That is, for each non-negative integer $x$, the value of $(((x \bmod a_1) \bmod a_2) \dots \bmod a_{k - 1}) \bmod a_k$ does not change if we reorder the elements of the array $a$.

For two given integers $n$ and $k$, calculate the number of stable arrays $[a_1, a_2, \dots, a_k]$ such that $1 \le a_1 < a_2 < \dots < a_k \le n$.

Input:
The only line contains two integers $n$ and $k$ ($1 \le n, k \le 5 \cdot 10^5$).

Output:
Print one integer — the number of stable arrays $[a_1, a_2, \dots, a_k]$ such that $1 \le a_1 < a_2 < \dots < a_k \le n$. Since the answer may be large, print it modulo $998{,}244{,}353$.}
\BREAKDOWN{Characterize when nested modulo is permutation-invariant; show this forces pairwise divisibility comparability and hence a chain $a_1 \mid a_2 \mid \dots \mid a_k$. Reduce counting to chains in the divisibility poset of $[1..n]$, and compute efficiently via a floor-division dynamic program with harmonic grouping.}
\ELI{Stable means the result after any order of taking remainders is the same, which happens exactly when each next number is a multiple of the previous; then count such increasing divisibility chains.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers: $n$ and $k$.
\begin{bullets}
\item Types: $n,k \in \mathbb{Z}_{\ge 1}$.
\item Ranges: $1 \le n,k \le 5\cdot 10^5$.
\end{bullets}}
\OUTPUTS{A single integer: the number of strictly increasing stable arrays of length $k$ with elements in $[1..n]$, modulo $998{,}244{,}353$.}
\SAMPLES{
\begin{bullets}
\item Example 1: $n=3$, $k=2$.
  Valid arrays: $[1,2], [1,3]$. Answer: $2$.
\item Example 2: $n=6$, $k=3$.
  Valid arrays: $[1,2,4], [1,2,6], [1,3,6]$. Answer: $3$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $[k]=\{1,\dots,k\}$. An array $(a_1,\dots,a_k)$ with $1 \le a_1 < \dots < a_k \le n$ is stable iff for all $i<j$ we have $a_i \mid a_j$. Therefore the count equals the number of chains of length $k$ in the divisibility poset on $[1..n]$.}
\varmapStart
\var{n}{upper bound on values}
\var{k}{length of the array}
\var{a_1<\dots<a_k}{chain elements with $a_i \mid a_{i+1}$}
\var{M}{budget variable $M=\lfloor n/a_1\rfloor$}
\var{g(M,t)}{number of sequences of $t$ integers $\ge 2$ with product $\le M$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Stability: } &\quad (x \bmod a) \bmod b = (x \bmod b) \bmod a \ \forall x \quad\Longleftrightarrow\quad a \mid b \text{ or } b \mid a. \\
\text{Chains: } &\quad 1 \le a_1 < \dots < a_k \le n,\ \ a_i \mid a_{i+1}\ \ \forall i. \\
\text{Ratios: } &\quad a_t = a_1 \cdot \prod_{i=1}^{t-1} r_i,\ \ r_i \in \mathbb{Z},\ r_i \ge 2. \\
\text{Budget: } &\quad \prod_{i=1}^{t-1} r_i \le \left\lfloor \frac{n}{a_1}\right\rfloor = M. \\
g(M,0)&=1,\qquad g(M,t)=\sum_{j=2}^{M} g\!\left(\left\lfloor \frac{M}{j}\right\rfloor, t-1\right). \\
\text{Answer: } &\quad \sum_{a_1=1}^{n} g\!\left(\left\lfloor \frac{n}{a_1}\right\rfloor, k-1\right).
\end{aligned}
\]
}
\ASSUMPTIONS{Strictly increasing arrays; divisibility poset on $[1..n]$; ratios $r_i \ge 2$ ensure strictness.}
\INVARIANTS{
\begin{bullets}
\item If $2^t > M$ then $g(M,t)=0$ (minimal product bound).
\item For fixed $t$, $g(M,t)$ is non-decreasing in $M$.
\item The final value of nested mod equals $x \bmod \min(a_1,\dots,a_k)$ when the set is a chain.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all strictly increasing $k$-tuples $(a_1,\dots,a_k)$ and test pairwise comparability by divisibility.}
\ASSUMPTIONS{Feasible only for very small $n,k$ (e.g., $n \le 25$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate all $\binom{n}{k}$ increasing $k$-tuples.
\item Check if $a_i \mid a_j$ for all $i<j$; if true, count it.
\item Return count modulo $998244353$.
\end{algosteps}
\COMPLEXITY{Exponential in $k$ and polynomial in $n$; enumeration dominates.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(\binom{n}{k}\cdot k^2\right), \\
S(n) &= \Theta(k).
\end{aligned}
\]
\CORRECTNESS{Directly tests the necessary and sufficient chain condition equivalent to stability.}
\EDGECASES{Handles $k=1$ (all singletons valid); returns $0$ if $k>n$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (baseline brute force; for sanity only)
MOD = 998244353

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, k = map(int, data[:2])
    return n, k

def is_chain(arr):
    # arr is increasing
    m = len(arr)
    for i in range(m):
        for j in range(i + 1, m):
            if arr[j] % arr[i] != 0:
                return False
    return True

def solve_case_bruteforce(n, k):
    if k == 0:
        return 0
    if k == 1:
        return n % MOD
    if k > n:
        return 0
    from itertools import combinations
    ans = 0
    for comb in combinations(range(1, n + 1), k):
        if is_chain(comb):
            ans += 1
    return ans % MOD

def main():
    nk = read_input()
    if nk is None:
        # self-test small
        assert solve_case_bruteforce(3, 1) == 3
        assert solve_case_bruteforce(3, 2) == 2  # [1,2], [1,3]
        assert solve_case_bruteforce(6, 2) == 8
        assert solve_case_bruteforce(6, 3) == 3
        print("OK")
    else:
        n, k = nk
        print(solve_case_bruteforce(n, k))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The asserts in main cover tiny cases and match hand enumeration.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{DP on Values via Divisors}
\WHICHFORMULA{Dynamic programming over endpoints: dp[t][x] = number of chains of length $t$ ending at $x$, transitioning along divisors.}
\ASSUMPTIONS{Precompute divisors or multiples; sum over multiples faster: dp[t][m] accumulates dp[t-1][d] for $d \mid m$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize dp[1][x] = 1 for all $x \in [1..n]$.
\item For $t=2..k$, for each $m$, let dp[t][m] = $\sum_{d \mid m,\, d<m}$ dp[t-1][d].
\item Sum dp[k][m] over $m$ to get the answer.
\end{algosteps}
\COMPLEXITY{Using sieve-like accumulation over multiples:}
\[
\begin{aligned}
T(n) &= \Theta\!\big(k \cdot n \log n\big)\quad\text{(harmonic sum of multiples)},\\
S(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Builds chains by appending a multiple; respects strict increase and divisibility.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved DP summing over divisors/multiples (still heavy for max constraints)
MOD = 998244353

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, k = map(int, data[:2])
    return n, k

def solve_case_dp_divisors(n, k):
    if k == 1:
        return n % MOD
    dp = [0] * (n + 1)
    # dp for length 1: any single number
    for m in range(1, n + 1):
        dp[m] = 1
    for _ in range(2, k + 1):
        ndp = [0] * (n + 1)
        # For each d, add dp[d] to all multiples m = d * t with t >= 2
        for d in range(1, n + 1):
            val = dp[d]
            if val == 0:
                continue
            m = d * 2
            while m <= n:
                ndp[m] += val
                if ndp[m] >= MOD:
                    ndp[m] -= MOD
                m += d
        dp = ndp
    return sum(dp) % MOD

def main():
    nk = read_input()
    if nk is None:
        # sanity tests
        assert solve_case_dp_divisors(3, 1) == 3
        assert solve_case_dp_divisors(3, 2) == 2
        assert solve_case_dp_divisors(6, 2) == 8
        assert solve_case_dp_divisors(6, 3) == 3
        print("OK")
    else:
        n, k = nk
        print(solve_case_dp_divisors(n, k))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Matches brute force on small $n$. Still too slow for worst case but establishes correctness.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Harmonic Floor-DP on Ratios with Range-Add}
\WHICHFORMULA{Use the ratios DP $g(M,t)$ with recurrence $g(M,t)=\sum_{j=2}^{M} g(\lfloor M/j\rfloor, t-1)$ and compute each layer with $O(n \log n)$ range-add updates via the identity $\lfloor m/j\rfloor=v \iff m \in [vj, vj+j-1]$.}
\ASSUMPTIONS{Only $t \le \lfloor \log_2 n \rfloor$ layers matter, since $2^t \le n$ is necessary for non-zero counts.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $T=\lfloor \log_2 n \rfloor$ and set $L=\min(k-1, T)$. Initialize array $dp$ of size $n$ (1-indexed) by $dp[M]=1$ for all $M \in [1..n]$ (this is $g(M,0)$).
\item For each layer $t=1..L$:
  \begin{bullets}
  \item Create difference array $diff$ of size $n+2$ initialized to $0$.
  \item For each $j$ from $2$ to $n$, for each $v$ from $1$ to $\lfloor n/j\rfloor$, range-add $dp[v]$ to indices $m \in [v j, \min(v j + j - 1, n)]$ by $diff[l]+=dp[v]$, $diff[r+1]-=dp[v]$.
  \item Prefix-sum $diff$ to obtain the new $dp$ layer modulo $998244353$.
  \end{bullets}
\item If $k=1$, answer is $n$. Else, after $L$ layers, if $k-1 > T$ then answer is $0$; otherwise compute $\sum_{a_1=1}^{n} dp[\lfloor n/a_1\rfloor]$ by grouping equal quotients using harmonic ranges $[l..r]$ where $\lfloor n/x \rfloor$ is constant.
\end{algosteps}
\OPTIMALITY{Each layer uses $O\!\left(\sum_{j=2}^{n}\lfloor n/j\rfloor\right)=O(n\log n)$ range-add updates and $O(n)$ prefixing; only $O(\log n)$ layers are non-zero. This is essentially tight under the floor-division DP model.}
\COMPLEXITY{With $L \le \lfloor \log_2 n \rfloor$:}
\[
\begin{aligned}
T(n) &= O\!\big(n \log n \cdot \log n\big),\\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: Modular Stability (1359E) — Optimal DP with harmonic range-add
# Counts increasing chains a1 | a2 | ... | ak in [1..n]
MOD = 998244353

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, k = map(int, data[:2])
    return n, k

def solve_case(n, k):
    if k == 1:
        return n % MOD
    # Number of non-zero layers needed
    T = (n.bit_length() - 1)  # floor(log2 n)
    L = min(k - 1, T)
    # dp[M] = g(M, t) for current t; initialize t=0: g(M,0)=1
    dp = [0] * (n + 1)
    for i in range(1, n + 1):
        dp[i] = 1
    # Build layers t=1..L
    for _ in range(L):
        diff = [0] * (n + 2)
        # For each j, add dp[v] to m in [v*j, min(v*j + j - 1, n)] for v=1..n//j
        for j in range(2, n + 1):
            maxv = n // j
            if maxv == 0:
                break
            base = j
            rcap = j - 1
            for v in range(1, maxv + 1):
                val = dp[v]
                if val:
                    l = v * base
                    r = l + rcap
                    if r > n:
                        r = n
                    diff[l] += val
                    diff[r + 1] -= val
        # prefix to get next dp
        run = 0
        ndp = dp  # reuse memory
        for i in range(1, n + 1):
            run += diff[i]
            # mod reduce while walking to keep numbers small
            if run >= MOD or run <= -MOD:
                run %= MOD
            v = run
            if v < 0:
                v += MOD
            ndp[i] = v
        dp = ndp
    if k - 1 > T:
        return 0
    # Sum over a1: sum_{a1=1..n} dp[n//a1], grouped by equal quotient
    ans = 0
    i = 1
    while i <= n:
        q = n // i
        r = n // q
        # add (r - i + 1) * dp[q]
        ans += (r - i + 1) * dp[q]
        ans %= MOD
        i = r + 1
    return ans % MOD

def main():
    nk = read_input()
    if nk is None:
        # Self-checks
        assert solve_case(1, 1) == 1
        assert solve_case(1, 2) == 0
        assert solve_case(3, 1) == 3
        assert solve_case(3, 2) == 2  # [1,2], [1,3]
        assert solve_case(6, 2) == 8
        assert solve_case(6, 3) == 3  # [1,2,4], [1,2,6], [1,3,6]
        assert solve_case(10, 5) == 0  # need 2^(5-1)=16 product; impossible
        print("OK")
    else:
        n, k = nk
        print(solve_case(n, k))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 mini-tests:
\begin{bullets}
\item $(n,k)=(3,2)\to 2$.
\item $(n,k)=(6,3)\to 3$.
\item $(n,k)=(10,5)\to 0$.
\end{bullets}}
\RESULT{Counts strictly increasing chains $a_1 \mid a_2 \mid \dots \mid a_k$ in $[1..n]$; result modulo $998244353$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-check brute force, divisor-DP, and final DP on small $n$; property tests: monotonicity in $n$, zero when $2^{k-1}>n$.}
\LINE{CROSS-CHECKS}{For $n\le 40$, enumerate all chains and compare with both DP variants.}
\LINE{EDGE-CASE GENERATOR}{Generate $(n,k)$ pairs with $k=1$, $k=n$, $k> \lfloor \log_2 n \rfloor + 1$, primes-only ranges, and powers of two.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_pairs(limit_n=40):
    pairs = []
    for n in range(1, limit_n + 1):
        # k=1, maximal k where non-zero, excessive k, mid k
        pairs.append((n, 1))
        pairs.append((n, (n.bit_length() - 1) + 1))  # k = floor(log2 n)+1
        pairs.append((n, (n.bit_length() - 1) + 2))  # k too large -> 0
        if n >= 3:
            pairs.append((n, 2))
        if n >= 6:
            pairs.append((n, 3))
    # de-duplicate
    out = []
    seen = set()
    for p in pairs:
        if p not in seen:
            seen.add(p)
            out.append(p)
    return out

def oracle_bruteforce(n, k):
    # from Approach A
    if k == 1:
        return n % 998244353
    if k > n:
        return 0
    from itertools import combinations
    ans = 0
    for comb in combinations(range(1, n + 1), k):
        ok = True
        for i in range(k):
            for j in range(i + 1, k):
                if comb[j] % comb[i] != 0:
                    ok = False
                    break
            if not ok:
                break
        if ok:
            ans += 1
    return ans % 998244353

def quick_check():
    for n, k in gen_pairs(30):
        bf = oracle_bruteforce(n, k) if n <= 20 else None
        got = solve_case(n, k)
        if bf is not None:
            assert bf == got, (n, k, bf, got)
    return True

if __name__ == "__main__":
    print("Quick check:", quick_check())
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution (same as Approach C's solve_case), with I/O and asserts.
MOD = 998244353

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    n, k = map(int, data[:2])
    return n, k

def solve_case(n, k):
    if k == 1:
        return n % MOD
    T = (n.bit_length() - 1)
    L = min(k - 1, T)
    dp = [0] * (n + 1)
    for i in range(1, n + 1):
        dp[i] = 1
    for _ in range(L):
        diff = [0] * (n + 2)
        for j in range(2, n + 1):
            maxv = n // j
            if maxv == 0:
                break
            base = j
            rcap = j - 1
            for v in range(1, maxv + 1):
                val = dp[v]
                if val:
                    l = v * base
                    r = l + rcap
                    if r > n:
                        r = n
                    diff[l] += val
                    diff[r + 1] -= val
        run = 0
        for i in range(1, n + 1):
            run += diff[i]
            if run >= MOD or run <= -MOD:
                run %= MOD
            if run < 0:
                run += MOD
            dp[i] = run
    if k - 1 > T:
        return 0
    ans = 0
    i = 1
    while i <= n:
        q = n // i
        r = n // q
        ans += (r - i + 1) * dp[q]
        ans %= MOD
        i = r + 1
    return ans % MOD

def main():
    nk = read_input()
    if nk is None:
        assert solve_case(1, 1) == 1
        assert solve_case(1, 2) == 0
        assert solve_case(3, 2) == 2
        assert solve_case(6, 3) == 3
        print("OK")
    else:
        n, k = nk
        print(solve_case(n, k))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Stable arrays are exactly strictly increasing divisibility chains; count them via a floor-division DP on ratios with $O(n \log n \log n)$ time.}
\WHY{This pattern (chains in a poset, harmonic grouping, floor-division DP) recurs in many number-theory flavored DP problems on CF.}
\CHECKLIST{
\begin{bullets}
\item Prove pairwise comparability by divisibility for permutation-invariant modulo.
\item Reduce to counting chains $a_1 \mid a_2 \mid \dots \mid a_k$.
\item Switch to ratio DP $g(M,t)$ with $M=\lfloor n/a_1\rfloor$.
\item Implement range-add using intervals where $\lfloor m/j \rfloor$ is constant.
\item Only compute up to $t \le \lfloor \log_2 n \rfloor$ layers.
\item Sum final $dp[\lfloor n/a_1\rfloor]$ via quotient grouping.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $k=1$ gives answer $n$.
\item $k>n$ gives $0$.
\item If $2^{k-1} > n$, answer $0$.
\item $n=1$ with any $k>1$ gives $0$.
\item Prime-only ranges do not change logic (chains must double or more via multiples).
\item Large $k$ collapses quickly due to the $2^t$ bound.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting strict increase; ensure ratios $r_i \ge 2$.
\item Double-counting when summing over $a_1$; use quotient grouping.
\item Missing modulo on range-add prefix accumulation.
\item Iterating layers beyond $\lfloor \log_2 n \rfloor$ wastes time.
\item Off-by-one in range-add endpoints $[v j, v j + j - 1]$.
\item Using $O(n^2)$ divisor enumeration instead of multiples or harmonic grouping.
\end{bullets}
}
\FAILMODES{Pure divisor DP without optimization blows up; naive per-$M$ DP with per-$j$ grouping is $O(n^{3/2})$ per layer and times layers is too slow. The harmonic range-add keeps total updates $O(n\log n)$ per layer.}
\ELI{Once you see all numbers must be nested by divisibility, the problem becomes counting how many times you can multiply by integers $\ge 2$ without exceeding $n$ relative to the starting point. That lends itself to a compact DP that groups identical floor divisions to run fast.}
\NotePages{3}

\end{document}