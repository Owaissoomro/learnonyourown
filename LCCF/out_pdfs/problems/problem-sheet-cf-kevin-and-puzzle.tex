% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Kevin and Puzzle}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2061/C}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Kevin enjoys logic puzzles.

He played a game with $n$ classmates who stand in a line. The $i$-th person from the left says that there are $a_i$ liars to their left (not including themselves).

Each classmate is either honest or a liar, with the restriction that no two liars can stand next to each other. Honest classmates always say the truth. Liars can say either the truth or lies, meaning their statements are considered unreliable.

Kevin wants to determine the number of distinct possible game configurations modulo $998{,}244{,}353$. Two configurations are considered different if at least one classmate is honest in one configuration and a liar in the other.

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^4$). The description of the test cases follows.

The first line of each test case contains an integer $n$ ($1\le n \le 2 \cdot 10^5$) — the number of classmates.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0\le a_i \le n$) — the number of liars to the left of the $i$-th person they claimed.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

Output:
For each test case, output one integer — the number of distinct game configurations modulo $998{,}244{,}353$.

Note:
We will use $\color{red}{\text{red}}$ to mark liars and $\color{blue}{\text{blue}}$ to mark honest people.

In the first test case, the only possible way is $(\color{red}{0},\color{blue}{1},\color{red}{2})$.

In the second test case, two possible ways are $(\color{blue}{0},\color{blue}{0},\color{blue}{0},\color{blue}{0},\color{blue}{0})$ and $(\color{blue}{0},\color{blue}{0},\color{blue}{0},\color{blue}{0},\color{red}{0})$.

In the third test case, three possible ways are $(\color{blue}{0},\color{blue}{0},\color{red}{1},\color{blue}{1},\color{red}{2})$, $(\color{blue}{0},\color{red}{0},\color{blue}{1},\color{red}{1},\color{blue}{2})$, $(\color{blue}{0},\color{red}{0},\color{blue}{1},\color{blue}{1},\color{red}{2})$.}
\BREAKDOWN{We must choose a liar/honest label for each position such that: (i) no two liars are adjacent, and (ii) every honest person's $a_i$ equals the number of liars strictly to their left. Count all valid assignments modulo $998{,}244{,}353$.}
\ELI{Scan from left to right: if the current count of liars so far equals $a_i$, you may choose honest or liar (but do not put liars consecutively); otherwise you are forced to put a liar.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: integer $n$ and array $a$ of length $n$ with $0 \le a_i \le n$. Sum of $n$ over tests $\le 2\cdot 10^5$.}
\OUTPUTS{For each test case, a single integer: the number of valid configurations modulo $998{,}244{,}353$.}
\SAMPLES{Examples consistent with the note:
- $n=3$, $a=[0,1,2] \Rightarrow 1$.
- $n=5$, $a=[0,0,0,0,0] \Rightarrow 2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $S \subseteq \{1,\ldots,n\}$ be indices of liars with the constraint $i,i+1\notin S$ for all $i$. Define $L(i)=|\{j\in S: j<i\}|$. A configuration $S$ is valid iff for all $i\notin S$ we have $a_i=L(i)$.}
\varmapStart
\var{n}{number of people}
\var{a_i}{claimed count of liars to the left of position $i$}
\var{S}{set of liar indices (independent set on a path)}
\var{L(i)}{number of liars strictly to the left of $i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
& S \subseteq \{1,\ldots,n\},\quad \forall i:\ \{i,i{+}1\}\nsubseteq S,\\
& \forall i\notin S:\ a_i = L(i)=|\{j\in S: j<i\}|.
\end{aligned}
\]
}
\ASSUMPTIONS{Indexing is $1$-based. No two liars adjacent. Liars' statements impose no constraints; honest statements must match $L(i)$.}
\INVARIANTS{
- Scanning left-to-right, $L(i)$ increases by $1$ exactly at liar positions.
- If position $i$ is honest, then $a_i=L(i)$. If $a_i\ne L(i)$ then $i$ must be a liar (subject to non-adjacency).
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct dynamic programming on positions with the key observation: if previous person is honest, then the number of liars so far equals $a_{i-1}$. If previous is a liar, current must be honest and must satisfy $a_i=a_{i-2}+1$.}
\ASSUMPTIONS{Use $a_0=0$ as the initial condition. Maintain two DP states at position $i$: last is honest or liar.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $a_0=0$. Set $dp\_H(0)=1$, $dp\_L(0)=0$.
\item For $i=1$ to $n$:
  \begin{bullets}
  \item $dp\_H(i) \mathrel{+}= dp\_H(i{-}1)$ if $a_i=a_{i-1}$.
  \item $dp\_H(i) \mathrel{+}= dp\_L(i{-}1)$ if $i\ge2$ and $a_i=a_{i-2}+1$.
  \item $dp\_L(i) = dp\_H(i{-}1)$ (you can lie after an honest person).
  \end{bullets}
\item Answer is $(dp\_H(n)+dp\_L(n)) \bmod 998{,}244{,}353$.
\end{algosteps}
\COMPLEXITY{Linear time and constant memory.}
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{By construction, transitions enforce honesty equalities and no two consecutive liars. The case $dp\_H \leftarrow dp\_L$ enforces that after a liar, the next must be honest with $a_i$ matching the resulting liar count, which is exactly $a_{i-2}+1$. All valid configurations are counted once.}
\EDGECASES{First position: $a_1=0$ allows both honest and liar; $a_1\ne 0$ forces liar. Final position may be a liar without extra constraints. Any mismatch in the required equalities zeroes out the corresponding DP path.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from typing import List, Tuple

MOD = 998244353

def count_configs_dp(a: List[int]) -> int:
    # a is 0-based of length n; we'll use 1-based with a0 = 0
    n = len(a)
    arr = [0] + a[:]  # a0 = 0
    dpH_prev, dpL_prev = 1, 0  # at i=0
    for i in range(1, n + 1):
        dpH = 0
        if arr[i] == arr[i - 1]:
            dpH = (dpH + dpH_prev) % MOD
        if i >= 2 and arr[i] == arr[i - 2] + 1:
            dpH = (dpH + dpL_prev) % MOD
        dpL = dpH_prev % MOD  # can always lie after honest
        dpH_prev, dpL_prev = dpH, dpL
    return (dpH_prev + dpL_prev) % MOD

def read_input() -> List[Tuple[int, List[int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, a))
    return tests

def solve_case(n: int, a: List[int]) -> int:
    return count_configs_dp(a)

def solve_all():
    import sys
    out_lines = []
    for n, a in read_input():
        out_lines.append(str(solve_case(n, a)))
    sys.stdout.write("\n".join(out_lines))

def _naive_count(a: List[int]) -> int:
    # brute force for small n: enumerate liar sets with no adjacency
    n = len(a)
    ans = 0
    for mask in range(1 << n):
        # check no adjacent
        if mask & (mask << 1):
            continue
        ok = True
        for i in range(n):
            if not (mask >> i) & 1:
                # honest at i -> check a_i equals liars to left
                liars_left = 0
                for j in range(i):
                    if (mask >> j) & 1:
                        liars_left += 1
                if a[i] != liars_left:
                    ok = False
                    break
        if ok:
            ans = (ans + 1) % MOD
    return ans

if __name__ == "__main__":
    # Basic asserts
    assert solve_case(3, [0, 1, 2]) == 1
    assert solve_case(5, [0, 0, 0, 0, 0]) == 2
    assert solve_case(5, [0, 0, 1, 1, 2]) == 3
    # Randomized cross-checks on small n
    import random
    random.seed(0)
    for _ in range(200):
        n = random.randint(1, 9)
        a = [random.randint(0, n) for _ in range(n)]
        got = solve_case(n, a)
        want = _naive_count(a)
        assert got == want, (n, a, got, want)
    # If input is provided, run solver
    try:
        import sys
        if not sys.stdin.isatty():
            solve_all()
    except Exception:
        pass
\end{minted}
\VALIDATION{We asserted three illustrative cases and 200 random small cases against a brute-force enumerator.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{State-Compressed DP via Local Equalities}
\WHICHFORMULA{Use only two rolling states: last person honest vs. liar. The only checks needed are $a_i=a_{i-1}$ (honest after honest) and $a_i=a_{i-2}+1$ (honest after liar). This eliminates tracking the exact liar count.}
\ASSUMPTIONS{Set $a_0=0$. No two liars are adjacent; after a liar, the next is forced honest and must satisfy $a_i=a_{i-2}+1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain $(dpH, dpL)$: counts ending at the previous index with Honest or Liar.
\item Update:
\begin{bullets}
\item $dpH' \leftarrow [a_i=a_{i-1}]\cdot dpH + [i\ge2\ \wedge\ a_i=a_{i-2}+1]\cdot dpL$.
\item $dpL' \leftarrow dpH$.
\end{bullets}
\item Replace $(dpH,dpL)\leftarrow(dpH',dpL')$ and continue.
\end{algosteps}
\COMPLEXITY{Same as baseline but cleaner constants; still $O(n)$ time, $O(1)$ memory.}
\[
\begin{aligned}
T(n) &= \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Follows from invariant: in $dpH$ at $i{-}1$ the liar count equals $a_{i-1}$, while in $dpL$ at $i{-}1$ the liar count equals $a_{i-2}+1$. The predicates ensure honest feasibility and forbid consecutive liars.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple

MOD = 998244353

def count_configs_dp_fast(a: List[int]) -> int:
    n = len(a)
    arr = [0] + a[:]
    dpH, dpL = 1, 0
    for i in range(1, n + 1):
        newH = 0
        if arr[i] == arr[i - 1]:
            newH = (newH + dpH) % MOD
        if i >= 2 and arr[i] == arr[i - 2] + 1:
            newH = (newH + dpL) % MOD
        newL = dpH % MOD
        dpH, dpL = newH, newL
    return (dpH + dpL) % MOD

def read_input() -> List[Tuple[int, List[int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, a))
    return tests

def solve_case(n: int, a: List[int]) -> int:
    return count_configs_dp_fast(a)

def solve_all():
    import sys
    out = []
    for n, a in read_input():
        out.append(str(solve_case(n, a)))
    sys.stdout.write("\n".join(out))

def _naive(a: List[int]) -> int:
    n = len(a)
    ans = 0
    for mask in range(1 << n):
        if mask & (mask << 1):
            continue
        ok = True
        cnt = 0
        for i in range(n):
            if (mask >> i) & 1:
                cnt += 1
            else:
                if a[i] != cnt:
                    ok = False
                    break
        if ok:
            ans = (ans + 1) % MOD
    return ans

if __name__ == "__main__":
    # Cross-checks
    assert solve_case(3, [0, 1, 2]) == 1
    assert solve_case(5, [0, 0, 0, 0, 0]) == 2
    assert solve_case(5, [0, 0, 1, 1, 2]) == 3
    import random
    random.seed(1)
    for _ in range(200):
        n = random.randint(1, 10)
        a = [random.randint(0, n) for _ in range(n)]
        assert solve_case(n, a) == _naive(a)
    try:
        import sys
        if not sys.stdin.isatty():
            solve_all()
    except Exception:
        pass
\end{minted}
\VALIDATION{Validated against a naive checker for many random small arrays and specific edge cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two-State Rolling DP with Necessary Equality Checks}
\WHICHFORMULA{Final transitions:
\[
dpH_i = [a_i=a_{i-1}]\,dpH_{i-1} + [i\ge2\ \wedge\ a_i=a_{i-2}+1]\,dpL_{i-1},\quad
dpL_i = dpH_{i-1}.
\]
Answer: $(dpH_n+dpL_n)\bmod 998{,}244{,}353$.}
\ASSUMPTIONS{Set $a_0=0$. After a liar, next must be honest and satisfy $a_i=a_{i-2}+1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dpH=1$, $dpL=0$ and $a_0=0$.
\item For each $i=1..n$, update using the above equations.
\item Return $(dpH+dpL)\bmod 998{,}244{,}353$.
\end{algosteps}
\OPTIMALITY{Any solution must examine each element to validate local equalities; our method is linear-time and constant-space, which is optimal up to constants.}
\COMPLEXITY{Linear time, constant space.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple

MOD = 998244353

def solve_case(n: int, a: List[int]) -> int:
    arr = [0] + a[:]  # a0 = 0
    dpH, dpL = 1, 0
    for i in range(1, n + 1):
        newH = 0
        if arr[i] == arr[i - 1]:
            newH = (newH + dpH) % MOD
        if i >= 2 and arr[i] == arr[i - 2] + 1:
            newH = (newH + dpL) % MOD
        newL = dpH % MOD
        dpH, dpL = newH, newL
    return (dpH + dpL) % MOD

def read_input() -> List[Tuple[int, List[int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, a))
    return tests

def solve_all():
    import sys
    out = []
    for n, a in read_input():
        out.append(str(solve_case(n, a)))
    sys.stdout.write("\n".join(out))

def _naive(a: List[int]) -> int:
    n = len(a)
    ans = 0
    for mask in range(1 << n):
        if mask & (mask << 1):
            continue
        ok = True
        liars_left = 0
        for i in range(n):
            if (mask >> i) & 1:
                liars_left += 1
            else:
                if a[i] != liars_left:
                    ok = False
                    break
        if ok:
            ans = (ans + 1) % MOD
    return ans

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case(3, [0, 1, 2]) == 1
    assert solve_case(5, [0, 0, 0, 0, 0]) == 2
    assert solve_case(5, [0, 0, 1, 1, 2]) == 3
    # Run solver if input present
    try:
        import sys
        if not sys.stdin.isatty():
            solve_all()
    except Exception:
        pass
\end{minted}
\VALIDATION{Three asserts on canonical small cases.}
\RESULT{Counts the number of liar/honest assignments (distinguishing configurations by any differing label) satisfying the constraints, modulo $998{,}244{,}353$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit asserts for hand-picked cases, plus randomized property tests vs. a brute-force oracle on small $n$. Also include degenerate extremes: all zeros, strictly increasing, and oscillating arrays.}
\LINE{CROSS-CHECKS}{Compare Baseline vs. Improved vs. Final for random small arrays; all must match the brute-force oracle.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with patterns: all equal to $0$; $a_i=i{-}1$; alternating mismatches; random within $[0,n]$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
MOD = 998244353

def count_configs_reference(a: List[int]) -> int:
    # Final reference DP
    n = len(a)
    arr = [0] + a[:]
    dpH, dpL = 1, 0
    for i in range(1, n + 1):
        newH = 0
        if arr[i] == arr[i - 1]:
            newH = (newH + dpH) % MOD
        if i >= 2 and arr[i] == arr[i - 2] + 1:
            newH = (newH + dpL) % MOD
        newL = dpH % MOD
        dpH, dpL = newH, newL
    return (dpH + dpL) % MOD

def brute_force_oracle(a: List[int]) -> int:
    n = len(a)
    ans = 0
    for mask in range(1 << n):
        if mask & (mask << 1):  # adjacent liars
            continue
        ok = True
        for i in range(n):
            if not (mask >> i) & 1:
                liars_left = 0
                for j in range(i):
                    if (mask >> j) & 1:
                        liars_left += 1
                if a[i] != liars_left:
                    ok = False
                    break
        if ok:
            ans = (ans + 1) % MOD
    return ans

def generators():
    cases = []
    # all zeros
    for n in range(1, 8):
        cases.append([0] * n)
    # strictly increasing a_i = i-1
    for n in range(1, 8):
        cases.append([i for i in range(n)])
    # alternating 0/1
    cases.append([0, 1, 0, 1, 0, 1, 0][:7])
    # random seedless deterministic set
    base = [3, 0, 2, 1, 4, 0, 1, 2]
    for k in range(1, 8):
        cases.append([x % k for x in base[:k]])
    return cases

if __name__ == "__main__":
    # Cross-check reference vs. oracle
    for a in generators():
        ref = count_configs_reference(a)
        brute = brute_force_oracle(a)
        assert ref == brute, (a, ref, brute)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple

MOD = 998244353

def read_input() -> List[Tuple[int, List[int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, a))
    return tests

def solve_case(n: int, a: List[int]) -> int:
    arr = [0] + a[:]  # a0=0
    dpH, dpL = 1, 0
    for i in range(1, n + 1):
        newH = 0
        if arr[i] == arr[i - 1]:
            newH = (newH + dpH) % MOD
        if i >= 2 and arr[i] == arr[i - 2] + 1:
            newH = (newH + dpL) % MOD
        newL = dpH % MOD
        dpH, dpL = newH, newL
    return (dpH + dpL) % MOD

def solve_all():
    import sys
    out = []
    for n, a in read_input():
        out.append(str(solve_case(n, a)))
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Quick sanity asserts
    assert solve_case(3, [0, 1, 2]) == 1
    assert solve_case(5, [0, 0, 0, 0, 0]) == 2
    assert solve_case(5, [0, 0, 1, 1, 2]) == 3
    # Run if input is piped
    try:
        import sys
        if not sys.stdin.isatty():
            solve_all()
    except Exception:
        pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count assignments of liars/honest with no adjacent liars such that honest $i$ satisfy $a_i=$ liars to their left.}
\WHY{Tests reasoning about dynamic constraints that propagate forward and adjacency constraints; common in CF problems mixing DP with local feasibility checks.}
\CHECKLIST{
- Set $a_0=0$.
- Maintain two states: last honest vs last liar.
- Update $dpH$ with checks $a_i=a_{i-1}$ and $a_i=a_{i-2}+1$.
- Set $dpL \leftarrow dpH_{\text{prev}}$.
- Take modulo $998{,}244{,}353$.
}
\EDGECASES{
- $n=1$ with $a_1=0$ (two configurations) vs $a_1\ne 0$ (one configuration).
- Long runs with $a_i=0$.
- Sequences where $a_i$ suddenly jumps: forces a liar.
- After a liar, verify $a_i=a_{i-2}+1$; otherwise paths die.
- Maximal $n$ with arbitrary $a_i$ values (ensure $O(n)$).
- All $a_i=i{-}1$ (unique staggered pattern).
}
\PITFALLS{
- Forgetting to set $a_0=0$.
- Allowing liar after liar (must be forbidden).
- Checking wrong equality after a liar (must be $a_i=a_{i-2}+1$).
- Off-by-one in indices when $i=1$ or $i=2$.
- Not taking modulo at each addition.
- Misreading that liars can also say the truth (so liar positions impose no direct constraint).
}
\FAILMODES{Any approach that tries to track the exact number of liars as a large DP over $k$ risks $O(n^2)$ blow-up. The compressed two-state DP avoids this by leveraging the equalities tied to $a_{i-1}$ and $a_{i-2}$.}
\ELI{Walk left to right. If the current claim equals what honest people would expect, you may be honest or liar; otherwise you must lie, but never twice in a row. The two simple equalities ensure consistency without counting liars explicitly.}
\NotePages{3}

\end{document}