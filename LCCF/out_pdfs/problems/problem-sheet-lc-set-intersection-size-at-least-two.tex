% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Set Intersection Size At Least Two}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/set-intersection-size-at-least-two/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a 2D integer array \texttt{intervals} where \texttt{intervals[i] = [start\_i, end\_i]} represents all the integers from $start_i$ to $end_i$ inclusively.

A containing set is an array \texttt{nums} where each interval from \texttt{intervals} has at least two integers in \texttt{nums}.
\begin{bullets}
\item For example, if \texttt{intervals = [[1,3], [3,7], [8,9]]}, then \texttt{[1,2,4,7,8,9]} and \texttt{[2,3,4,8,9]} are containing sets.
\end{bullets}
Return the minimum possible size of a containing set.

Examples:
\begin{bullets}
\item Input: \texttt{intervals = [[1,3],[3,7],[8,9]]}; Output: \texttt{5}. Explanation: let \texttt{nums = [2, 3, 4, 8, 9]}. It can be shown that there cannot be any containing array of size \texttt{4}.
\item Input: \texttt{intervals = [[1,3],[1,4],[2,5],[3,5]]}; Output: \texttt{3}. Explanation: let \texttt{nums = [2, 3, 4]}. It can be shown that there cannot be any containing array of size \texttt{2}.
\item Input: \texttt{intervals = [[1,2],[2,3],[2,4],[4,5]]}; Output: \texttt{5}. Explanation: let \texttt{nums = [1, 2, 3, 4, 5]}. It can be shown that there cannot be any containing array of size \texttt{4}.
\end{bullets}
Constraints:
\begin{bullets}
\item $1 \le \texttt{intervals.length} \le 3000$
\item $\texttt{intervals[i].length} = 2$
\item $0 \le start_i < end_i \le 10^8$
\end{bullets}}
\BREAKDOWN{We must choose a smallest set $S \subset \mathbb{Z}$ so that every closed integer interval $[l_i,r_i]$ contains at least two elements of $S$. This is a covering/hitting-set variant with a multiplicity requirement of 2. A classic greedy approach exists when we sort intervals by right endpoint.}
\ELI{Sort intervals by ending point and always place new points as far to the right as possible so they help future intervals.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of intervals \texttt{intervals}, where each interval is a 2-element list \texttt{[l, r]} with integers $l, r$ satisfying $0 \le l < r \le 10^8$ and $1 \le \lvert \texttt{intervals} \rvert \le 3000$.}
\OUTPUTS{Return an integer, the minimum possible size of an array \texttt{nums} such that every input interval contains at least two elements from \texttt{nums}.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{[[1,3],[3,7],[8,9]]} $\to$ Output: \texttt{5}
\item Input: \texttt{[[1,3],[1,4],[2,5],[3,5]]} $\to$ Output: \texttt{3}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given intervals $I=\{[l_i,r_i]\}_{i=1}^n$ over integers, choose a minimum-cardinality set $S \subset \mathbb{Z}$ such that
for all $i$, $\lvert S \cap [l_i,r_i]\rvert \ge 2$.}
\varmapStart
\var{n}{number of intervals}
\var{[l_i,r_i]}{closed integer interval for item $i$}
\var{S}{selected integer set (to minimize $\lvert S \rvert$)}
\var{r(i)}{the right endpoint $r_i$}
\var{l(i)}{the left endpoint $l_i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Minimize}\quad & \lvert S \rvert \\
\text{subject to}\quad & \forall i \in \{1,\ldots,n\}:\ \lvert S \cap \{l_i,l_i{+}1,\ldots,r_i\}\rvert \ge 2, \\
& S \subset \mathbb{Z}.
\end{aligned}
\]
}
\ASSUMPTIONS{Intervals are closed and integral; $l_i < r_i$ ensures each interval contains at least two distinct integers iff $r_i - l_i \ge 1$, which holds. Sorting by nondecreasing right endpoint, breaking ties by nonincreasing left endpoint, enables a greedy choice that is optimal.}
\INVARIANTS{
\begin{bullets}
\item After processing the first $k$ intervals in the sorted order, each of them has at least two chosen points in $S$.
\item Newly added points are always the largest possible within the current interval, maximizing reuse for later intervals.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedy by right endpoint: process intervals sorted by $(r,\ -l)$; for each interval, count how many already-chosen points fall inside; if fewer than two, add the largest values within the interval (from $r$ downward) until the count reaches two. This baseline maintains a plain list and counts by linear scan.}
\ASSUMPTIONS{Counting inside an interval can be done by scanning the whole chosen list; with at most $2n$ chosen points, this is $O(n)$ per interval, yielding $O(n^2)$ total time for $n \le 3000$, which is acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort intervals by increasing $r$ and, on ties, decreasing $l$.
\item Maintain a list \texttt{chosen} (unsorted) and a membership set \texttt{in\_set} for duplicates.
\item For each interval $[l,r]$, count how many of \texttt{chosen} fall in $[l,r]$ by a linear scan.
\item If the count is $< 2$, add distinct integers from $r$ downward that are not yet in \texttt{in\_set} until the interval has two.
\end{algosteps}
\COMPLEXITY{Time $T(n)$ and space $S(n)$:}
\[
\begin{aligned}
T(n) &\le \sum_{i=1}^{n}\bigl(O(\lvert \texttt{chosen}\rvert) + O(1)\bigr) \\
     &\le \sum_{i=1}^{n} O(n) = O(n^2), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{By sorting on $r$ and filling deficits with largest possible points from $r$ downward, any added points are maximally reusable by future intervals (which can only end later). Thus once an interval is satisfied, it remains satisfied; and the greedy additions are never worse than any solution that places points further left.}
\EDGECASES{Intervals of length $1$; many overlapping intervals; disjoint intervals; repeated identical intervals; nested intervals that share the same right endpoint.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        # Sort by right endpoint ascending, then left descending
        intervals.sort(key=lambda x: (x[1], -x[0]))
        chosen: List[int] = []
        in_set = set()
        for l, r in intervals:
            # Count how many chosen lie inside [l, r] by linear scan
            inside = 0
            for v in chosen:
                if l <= v <= r:
                    inside += 1
            # Add the largest missing points from r downward
            v = r
            while inside < 2:
                if v not in in_set:
                    in_set.add(v)
                    chosen.append(v)
                    inside += 1
                v -= 1
        return len(in_set)

# Basic asserts from the prompt
sol = Solution()
assert sol.intersectionSizeTwo([[1,3],[3,7],[8,9]]) == 5
assert sol.intersectionSizeTwo([[1,3],[1,4],[2,5],[3,5]]) == 3
assert sol.intersectionSizeTwo([[1,2],[2,3],[2,4],[4,5]]) == 5
# Extra checks
assert sol.intersectionSizeTwo([[0,1]]) == 2           # need both 0 and 1
assert sol.intersectionSizeTwo([[0,2]]) == 2           # {1,2} or {1,2}
\end{minted}
\VALIDATION{The asserts cover the three examples, a minimal interval, and a slightly larger single interval.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Counting via Bisect}
\WHICHFORMULA{Same greedy order and choice, but maintain \texttt{chosen} in sorted order and count how many lie in $[l,r]$ via binary search indices. Insertions are done with \texttt{bisect.insort}, while membership uses a hash set.}
\ASSUMPTIONS{Sorted \texttt{chosen} enables $O(\log m)$ counting with $m \le 2n$; membership is $O(1)$ average using a set.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort intervals by $(r,\ -l)$.
\item Keep \texttt{chosen} sorted and a companion set \texttt{in\_set}.
\item For each $[l,r]$, compute $k = \#\{v \in \texttt{chosen} : l \le v \le r\}$ via \texttt{bisect\_right - bisect\_left}.
\item If $k < 2$, iterate $v = r, r-1, \ldots$ and insert values not in \texttt{in\_set} until two are covered.
\end{algosteps}
\COMPLEXITY{With $m \le 2n$ total insertions: counting in $O(\log m)$; each insertion also $O(m)$ for list insertion but occurs at most $2n$ times. For $n \le 3000$, this is fast.}
\[
\begin{aligned}
T(n) &= O\bigl(n\log n + n\cdot\log n + (n)\cdot n\bigr) = O(n^2) \text{ in worst-case Python list shifts, but typically much faster.}
\end{aligned}
\]
\CORRECTNESS{Same greedy exchange argument as in Approach A; only the data-structure operations change.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import bisect

class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: (x[1], -x[0]))
        chosen: List[int] = []
        in_set = set()
        for l, r in intervals:
            # Count how many chosen are in [l, r] via bisect
            left = bisect.bisect_left(chosen, l)
            right = bisect.bisect_right(chosen, r)
            have = right - left
            # Add largest feasible values from r downward until have == 2
            v = r
            while have < 2:
                if v not in in_set:
                    in_set.add(v)
                    bisect.insort(chosen, v)
                    have += 1
                v -= 1
        return len(in_set)

# Tests
sol = Solution()
assert sol.intersectionSizeTwo([[1,3],[3,7],[8,9]]) == 5
assert sol.intersectionSizeTwo([[1,3],[1,4],[2,5],[3,5]]) == 3
assert sol.intersectionSizeTwo([[1,2],[2,3],[2,4],[4,5]]) == 5
# Edge cases
assert sol.intersectionSizeTwo([[5,6],[5,6]]) == 2   # same interval repeated
assert sol.intersectionSizeTwo([[0,100]]) == 2       # choose 99, 100
\end{minted}
\VALIDATION{Added repetition and a wide interval.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Tight Greedy with Two Markers}
\WHICHFORMULA{Sort by $(r,\ -l)$ and maintain only the two largest chosen numbers so far: $b$ (largest) and $a$ (second largest), with $a \le b$. For each $[l,r]$:
\begin{bullets}
\item If $b < l$: none covered; add $r-1$ and $r$.
\item Else if $a < l \le b$: one covered; add the largest new point in $[l,r]$ different from $b$ (i.e., $r$ unless $r=b$, then $r-1$).
\item Else: both covered; add nothing.
\end{bullets}
This achieves $O(n\log n)$ due to sorting, and $O(n)$ thereafter.}
\ASSUMPTIONS{Intervals are integral with $l<r$, ensuring $r-1 \ge l$. Sorting tie-breaker ensures when $r$ ties, we process larger $l$ first, preserving correctness.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort intervals by right endpoint increasing, left endpoint decreasing.
\item Initialize $a=b=-\infty$ and answer $ans=0$.
\item For each $[l,r]$:
  \begin{bullets}
  \item If $b < l$: add $r-1$ and $r$; set $a=r-1$, $b=r$; $ans{+}{=}2$.
  \item Else if $a < l$: add $y=r$ if $r\ne b$ else $r-1$; set $a=b$, $b=y$; $ans{+}{=}1$.
  \item Else: do nothing.
  \end{bullets}
\item Return $ans$.
\end{algosteps}
\OPTIMALITY{Greedy exchange: any optimal solution can be transformed to one that chooses the two rightmost points for the first interval needing points without increasing the count, because future intervals end no earlier. The sort tie-break ($-l$) prevents earlier intervals from “stealing” flexibility when $r$ ties. Thus the above greedy is optimal.}
\COMPLEXITY{Sorting dominates; the scan is linear.}
\[
\begin{aligned}
T(n) &= O(n\log n) + O(n) = O(n\log n),\quad S(n)=O(1)\ \text{extra}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        # Sort by end ascending, start descending.
        intervals.sort(key=lambda x: (x[1], -x[0]))
        # Let a <= b be the two largest chosen so far.
        a = -10**18
        b = -10**18
        ans = 0
        for l, r in intervals:
            if b < l:
                # Need two new points.
                ans += 2
                a = r - 1
                b = r
            elif a < l:
                # Exactly one of {a, b} is inside [l, r]; add one more, as large as possible.
                # Prefer r, unless r == b (avoid duplicate), then use r-1.
                y = r if r != b else r - 1
                ans += 1
                a, b = b, y
            else:
                # Already have at least two points in [l, r]; do nothing.
                pass
        return ans

# Exact tests as required
sol = Solution()
assert sol.intersectionSizeTwo([[1,3],[3,7],[8,9]]) == 5
assert sol.intersectionSizeTwo([[1,3],[1,4],[2,5],[3,5]]) == 3
assert sol.intersectionSizeTwo([[1,2],[2,3],[2,4],[4,5]]) == 5
\end{minted}
\VALIDATION{Three asserts exactly reproduce the prompt's examples.}
\RESULT{The function returns the minimal size of a containing set; the actual set is not constructed in this optimal implementation, only its size. Ties in placement are resolved by taking rightmost available values.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover canonical examples, degenerate short intervals, duplicated intervals, nested and disjoint sets. Random small stress tests can compare the Baseline and Optimal outputs for consistency.}
\LINE{CROSS-CHECKS}{On small $n$, Approaches A, B, and C should agree. Any discrepancy indicates a bug in data-structure maintenance, not the greedy rule.}
\LINE{EDGE-CASE GENERATOR}{Generate intervals with: identical $r$, varying $l$; chains of overlaps; alternating disjoint/overlap; and minimal width $r=l+1$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_chain(n: int, start: int = 0, w: int = 2) -> List[List[int]]:
    # Overlapping chain with fixed width >= 2
    res = []
    x = start
    for _ in range(n):
        res.append([x, x + w])
        x += 1
    return res

def gen_same_r(n: int, r: int = 10) -> List[List[int]]:
    # Same right endpoint, varying left
    return [[r - i - 1, r] for i in range(n)]

def gen_mixed(n: int, seed: int = 0) -> List[List[int]]:
    random.seed(seed)
    arr = []
    for _ in range(n):
        l = random.randint(0, 20)
        r = random.randint(l + 1, l + 10)
        arr.append([l, r])
    return arr
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: (x[1], -x[0]))
        a = -10**18  # second largest chosen
        b = -10**18  # largest chosen
        ans = 0
        for l, r in intervals:
            if b < l:
                ans += 2
                a = r - 1
                b = r
            elif a < l:
                y = r if r != b else r - 1
                ans += 1
                a, b = b, y
        return ans

# Quick cross-checks with small crafted cases
sol = Solution()
assert sol.intersectionSizeTwo([[1,3],[3,7],[8,9]]) == 5
assert sol.intersectionSizeTwo([[1,3],[1,4],[2,5],[3,5]]) == 3
assert sol.intersectionSizeTwo([[1,2],[2,3],[2,4],[4,5]]) == 5
assert sol.intersectionSizeTwo([[0,1]]) == 2
assert sol.intersectionSizeTwo([[5,6],[5,6]]) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort intervals by end ascending and left descending; greedily add rightmost missing points to ensure each interval has at least two hits.}
\WHY{This pattern (sort by end, pick rightmost feasible points) is a staple greedy for interval hitting/covering, often appearing in interviews and contests.}
\CHECKLIST{
\begin{bullets}
\item Sort by $(r,\ -l)$.
\item Track how many points already cover current $[l,r]$.
\item If $0$ covered: add $r-1, r$.
\item If $1$ covered: add $r$ unless it's already chosen, else $r-1$.
\item Maintain invariants for processed intervals.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Many intervals sharing the same $r$.
\item Intervals of minimal width $r=l+1$.
\item Completely disjoint intervals (forces 2 points per interval).
\item Long nested chains (ensure tie-break is correct).
\item Duplicate intervals.
\item Large coordinates; do not preallocate arrays by coordinate.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting the tie-break by $-l$ when $r$ ties.
\item Accidentally adding duplicate points when only one more is needed.
\item Choosing points too far left, reducing future flexibility.
\item Off-by-one: selecting $r$ and $r$ instead of $r$ and $r-1$.
\item Assuming real numbers; this problem is on integers only.
\item Using dense boolean arrays up to $10^8$ (memory blow-up).
\end{bullets}
}
\FAILMODES{Approaches that pick leftmost points may fail when later intervals end early; without the $(r,\ -l)$ ordering, greedy can choose suboptimal placements and be forced to add more points later.}
\ELI{Always finish intervals as late as possible. By placing points at the right ends, you maximize their chance to help cover future intervals, leading to an optimal minimal count.}
\NotePages{3}

\end{document}