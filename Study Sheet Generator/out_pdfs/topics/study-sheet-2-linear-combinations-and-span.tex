% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype,setspace,amsmath,amssymb,mathtools,amsthm,unicode-math}
\setstretch{1.05}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}
\setmathfont{Latin Modern Math}

% --- Overflow / line-break safety ---
\allowdisplaybreaks[4]
\setlength{\jot}{7pt}
\setlength{\emergencystretch}{8em}
\sloppy

\usepackage{xcolor,fancyhdr,enumitem,inconsolata,listings}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}
\setlength{\headheight}{26pt}
\setlength{\parindent}{0pt}
\setlength{\parskip}{8pt plus 2pt minus 1pt}
\raggedbottom

% --- Breakable math helpers (use these in the body) ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

% ---------- Safety shims ----------
% Robust minted → listings shim (no shell-escape; supports [opts]{language})
\providecommand{\enumlistm}{enumitem}
\newenvironment{minted}[2][]{%
  \lstset{style=code,language=#2,#1}\begin{lstlisting}%
}{\end{lstlisting}}

% Fallback for \inputminted (ignore file; keep build unbroken)
\newcommand{\inputminted}[3][]{\begin{lstlisting}\end{lstlisting}}

% ---------- Bulleted lines (no tables) ----------
\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

% ---------- Variable mapping (lines, no tables) ----------
\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

% ---------- Glossary item with ELI5 and Pitfall/Example ----------
\newcommand{\glossx}[6]{%
  \textbf{#1}\par
  \begin{bullets}
    \item \textbf{What:} #2
    \item \textbf{Why:} #3
    \item \textbf{How:} #4
    \item \textbf{ELI5:} #5
    \item \textbf{Pitfall/Example:} #6
  \end{bullets}
}

% ---------- Theorem structures ----------
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{claim}[theorem]{Claim}
% ---------- Code blocks ----------
\lstdefinestyle{code}{
  basicstyle=\ttfamily\footnotesize,
  backgroundcolor=\color{black!02},
  frame=single,
  numbers=left, numberstyle=\tiny, numbersep=8pt,
  breaklines=true, breakatwhitespace=true,
  tabsize=4, showstringspaces=false,
  upquote=true, keepspaces=true, columns=fullflexible,
  % Unicode safety: map common symbols so listings never chokes
  literate=
    {–}{{-}}1
    {—}{{-}}1
    {…}{{...}}1
    {≤}{{\ensuremath{\le}}}1
    {≥}{{\ensuremath{\ge}}}1
    {≠}{{\ensuremath{\ne}}}1
    {≈}{{\ensuremath{\approx}}}1
    {±}{{\ensuremath{\pm}}}1
    {→}{{\ensuremath{\to}}}1
    {←}{{\ensuremath{\leftarrow}}}1
    {∞}{{\ensuremath{\infty}}}1
    {√}{{\ensuremath{\sqrt{\ }}}}1
    {×}{{\ensuremath{\times}}}1
    {÷}{{\ensuremath{\div}}}1
}

% Main code environment for all Python blocks
\lstnewenvironment{codepy}[1][]%
  {\lstset{style=code,language=Python,#1}}%
  {}

% Inline code; change delimiters if your snippet contains '!'
\newcommand{\inlinecode}[1]{\lstinline[style=code]!#1!}

% ---------- Line-label macros ----------
\newcommand{\LF}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LF{WHAT}{#1}}
\newcommand{\WHY}[1]{\LF{WHY}{#1}}
\newcommand{\HOW}[1]{\LF{HOW}{#1}}
\newcommand{\ELI}[1]{\LF{ELI5}{#1}}
\newcommand{\SCOPE}[1]{\LF{SCOPE}{#1}}
\newcommand{\CONFUSIONS}[1]{\LF{COMMON CONFUSIONS}{#1}}
\newcommand{\APPLICATIONS}[1]{\LF{APPLICATIONS}{#1}}
\newcommand{\FORMULA}[1]{\LF{FORMULA}{#1}}
\newcommand{\CANONICAL}[1]{\LF{CANONICAL FORM}{#1}}
\newcommand{\PRECONDS}[1]{\LF{PRECONDITIONS}{#1}}
\newcommand{\DERIVATION}[1]{\LF{DERIVATION}{#1}}
\newcommand{\EQUIV}[1]{\LF{EQUIVALENT FORMS}{#1}}
\newcommand{\LIMITS}[1]{\LF{LIMIT CASES}{#1}}
\newcommand{\INPUTS}[1]{\LF{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LF{OUTPUTS}{#1}}
\newcommand{\RESULT}[1]{\LF{RESULT}{#1}}
\newcommand{\INTUITION}[1]{\LF{INTUITION}{#1}}
\newcommand{\PITFALLS}[1]{\LF{PITFALLS}{#1}}
\newcommand{\MODEL}[1]{\LF{CANONICAL MATH MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LF{ASSUMPTIONS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LF{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LF{GOVERNING EQUATION(S)}{#1}}
\newcommand{\UNITCHECK}[1]{\LF{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LF{EDGE CASES}{#1}}
\newcommand{\ALTERNATE}[1]{\LF{ALTERNATE APPROACH (sketch)}{#1}}
\newcommand{\PROBLEM}[1]{\LF{PROBLEM}{#1}}
\newcommand{\API}[1]{\LF{API}{#1}}
\newcommand{\COMPLEXITY}[1]{\LF{COMPLEXITY}{#1}}
\newcommand{\FAILMODES}[1]{\LF{FAILURE MODES}{#1}}
\newcommand{\STABILITY}[1]{\LF{NUMERICAL STABILITY}{#1}}
\newcommand{\VALIDATION}[1]{\LF{VALIDATION}{#1}}
\newcommand{\EXPLANATION}[1]{\LF{EXPLANATION}{#1}}
\newcommand{\SCENARIO}[1]{\LF{SCENARIO}{#1}}
\newcommand{\PIPELINE}[1]{\LF{PIPELINE STEPS}{#1}}
\newcommand{\METRICS}[1]{\LF{METRICS}{#1}}
\newcommand{\INTERPRET}[1]{\LF{INTERPRETATION}{#1}}
\newcommand{\NEXTSTEPS}[1]{\LF{LIMITATIONS \& NEXT STEPS}{#1}}

% ---------- Section formatting ----------
\usepackage{titlesec}
\titleformat{\section}{\Large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2}{*1}
\usepackage{etoolbox}
\pretocmd{\section}{\clearpage}{}{}

% ---------- Page helpers ----------
\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ProblemPage}[2]{%
  \clearpage
  \subsection*{Problem #1: #2}%
  \addcontentsline{toc}{subsection}{Problem #1: #2}%
}
\newcommand{\CodeDemoPage}[1]{%
  \clearpage
  \subsection*{Coding Demo: #1}%
  \addcontentsline{toc}{subsection}{Coding Demo: #1}%
}
\newcommand{\DomainPage}[1]{%
  \clearpage
  \subsection*{#1 (End-to-End)}%
  \addcontentsline{toc}{subsection}{#1 (End-to-End)}%
}

\begin{document}
\title{Comprehensive Study Sheet — Linear Combinations and Span}
\date{\today}
\maketitle
\tableofcontents
\clearpage

\section{Concept Overview}
\WHAT{
Let $\mathbb{F}$ be a field and $V$ a vector space over $\mathbb{F}$.
Given vectors $v_1,\dots,v_k\in V$, a linear combination is any
$u=\alpha_1 v_1+\cdots+\alpha_k v_k$ with coefficients
$\alpha_i\in\mathbb{F}$. The span of a set $S\subseteq V$ is the set
$\mathrm{span}(S)=\{\text{all finite linear combinations of elements of }S\}$.
The span is a linear subspace of $V$ and is the smallest subspace
containing $S$. The column space of a matrix $A\in\mathbb{F}^{m\times n}$
is $\mathrm{Col}(A)=\mathrm{span}(\{a_1,\dots,a_n\})$, where $a_j$ are
the columns of $A$.
}

\WHY{
Linear combinations encode how vectors synthesize from generators.
Span formalizes the idea of all vectors reachable from a set via
addition and scalar multiplication, forming the backbone of dimension,
basis, rank, column space, solution structure of linear systems, and
decomposition of spaces in linear algebra and its applications.
}

\HOW{
1. Fix a field $\mathbb{F}$ and a vector space $V$ with axioms for
addition and scalar multiplication.
2. Define linear combinations by iterating the operations; define
span as the closure under these operations of a generating set.
3. Prove span is a subspace by closure; prove minimality by showing
any subspace containing $S$ must contain all linear combinations.
4. Represent membership in a span via linear systems $Ax=b$, analyze
structure via rank, basis via pivot columns, and uniqueness via linear
independence.
}

\ELI{
Think of vectors as ingredients and coefficients as recipe amounts.
The set $S$ is your pantry, and the span is every dish you can cook by
mixing those ingredients in any proportions, a subspace kitchen where
mixing dishes gives a dish and scaling still gives a dish.
}

\SCOPE{
Valid over any field $\mathbb{F}$ and any vector space $V$.
Edge cases: empty generating set has span $\{0\}$. Infinite sets have
span defined by finite linear combinations only. Coefficients must be
from the underlying field. Over $\mathbb{R}$ vs. $\mathbb{C}$, results
hold identically. Over finite fields, identical definitions apply.
}

\CONFUSIONS{
Span vs. basis: a basis is a minimal generating set that is linearly
independent; span is the set they generate. Span vs. affine hull:
affine hull allows coefficients summing to $1$ without requiring
passing through the origin; span always contains $0$ and is a subspace.
Linear dependence vs. non-unique representation: dependence implies
non-uniqueness of coefficients for the same vector; independence
implies uniqueness. Column space vs. row space: different subspaces
in $\mathbb{F}^m$ and $\mathbb{F}^n$ respectively.
}

\APPLICATIONS{
List 3–4 major domains where this topic directly applies:
\begin{bullets}
\item Mathematical foundations (pure / applied).
\item Computational modeling or simulation.
\item Physical / economic / engineering interpretations.
\item Statistical or algorithmic implications.
\end{bullets}
}

\textbf{ANALYTIC STRUCTURE.}
Span is linear: closed under vector addition and scalar multiplication.
It is convex, symmetric about the origin, and forms a lattice under set
inclusion via $\mathrm{span}(S\cup T)=\mathrm{span}(\mathrm{span}(S)\cup
\mathrm{span}(T))$. Dimension of span equals the size of any basis for it.

\textbf{CANONICAL LINKS.}
Span connects to rank (dimension of column space), null space (solution
non-uniqueness), independence (uniqueness of coefficients), and direct
sum decompositions. Gaussian elimination computes bases for spans.

\textbf{PROBLEM-TYPE RECOGNITION HEURISTICS.}
\begin{bullets}
\item Questions asking if $b$ can be built from given vectors $\to$ solve $Ax=b$.
\item Finding a basis for vectors $\to$ pivot columns or independent subset.
\item Equality of spans $\to$ mutual inclusion via linear systems.
\item Uniqueness of coefficients $\to$ test independence.
\end{bullets}

\textbf{SOLUTION STRATEGY BLUEPRINT.}
\begin{bullets}
\item Translate vectors into matrix columns $A$.
\item Identify the governing linear system $Ax=b$ or $Ax=0$.
\item Row-reduce to RREF to read pivots, rank, and dependencies.
\item Extract basis, coefficients, and determine membership/equality.
\item Validate by substitution and limit cases (rank bounds).
\end{bullets}

\textbf{CONCEPTUAL INVARIANTS.}
Rank of a column set, dimension of span, and zero vector containment are
invariants under elementary column operations induced by invertible
transformations of the generating set.

\textbf{EDGE INTUITION.}
If coefficients go to zero, linear combinations approach $0$. As you add
more generators, span dimension increases up to ambient dimension; once
full, additional vectors are combinations of existing ones.

\section{Glossary}
\glossx{Linear Combination}
{A vector of the form $\sum_{i=1}^k \alpha_i v_i$ with $\alpha_i\in\mathbb{F}$,
$v_i\in V$.}
{Encodes synthesis from generators and is the building block of span,
basis, and dimension.}
{Collect coefficients into a vector $x$ and generators into columns of
$A$; compute $Ax$.}
{Mix ingredients in chosen amounts to make a dish.}
{Pitfall: confusing linear combination with convex combination; convex
requires nonnegative coefficients summing to $1$, linear does not.}

\glossx{Span}
{Set of all finite linear combinations of a subset $S\subseteq V$.}
{Captures all vectors reachable from $S$ by linear operations and forms
a subspace used to define column space and dimension.}
{Form a matrix from $S$ and consider its column space; solve $Ax=b$ to
test membership.}
{All dishes you can cook from your pantry, including the empty dish $0$.}
{Example: $\mathrm{span}(\{(1,0),(0,1)\})=\mathbb{R}^2$. Pitfall:
including infinite sums; only finite combinations are allowed.}

\glossx{Basis}
{A linearly independent set whose span equals the target space/subspace.}
{Gives minimal generators and unique coordinates for every vector.}
{Use Gaussian elimination to find pivot columns forming a basis for the
column space.}
{Smallest set of ingredients that can make every dish uniquely.}
{Pitfall: choosing too many vectors; dependence breaks uniqueness.}

\glossx{Column Space}
{The span of the columns of a matrix $A$, a subspace of $\mathbb{F}^m$.}
{Connects linear systems to span; $b$ is solvable iff $b\in\mathrm{Col}(A)$.}
{Row-reduce $A$ to find pivot columns; those original columns form a
basis.}
{All outputs you can produce by mixing columns with coefficients.}
{Pitfall: using pivot columns of the reduced matrix instead of the
corresponding original columns for a basis.}

\section{Symbol Ledger}
\varmapStart
\var{\mathbb{F}}{Underlying field (e.g., $\mathbb{R}$ or $\mathbb{C}$).}
\var{V}{Vector space over $\mathbb{F}$.}
\var{v_i}{Generator vectors in $V$.}
\var{S}{Subset of $V$ used to generate a span.}
\var{\mathrm{span}(S)}{Linear span of $S$.}
\var{A}{Matrix with columns $a_1,\dots,a_n\in\mathbb{F}^m$.}
\var{a_j}{Column $j$ of matrix $A$.}
\var{x}{Coefficient vector in $\mathbb{F}^n$.}
\var{b}{Target vector in $\mathbb{F}^m$.}
\var{r}{Rank, i.e., dimension of the column space of $A$.}
\var{R}{Row-reduced echelon form of $A$.}
\var{P}{Permutation matrix; $E$ an elementary matrix.}
\var{I}{Identity matrix of suitable size.}
\var{\mathcal{B}}{Basis set.}
\var{n,m,k}{Dimensions and counts: columns, rows, generators.}
\varmapEnd

\section{Formula Canon — One Formula Per Page}

\FormulaPage{1}{Definition and Subspace Properties of Span}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
For $S\subseteq V$, the span $\mathrm{span}(S)$ is the set of all finite
linear combinations of vectors from $S$. It is a subspace of $V$ and is
the smallest subspace containing $S$.

\WHAT{
This formula defines span and asserts two key properties: subspace
closure and minimality among subspaces containing $S$.
}

\WHY{
Subspace closure guarantees algebraic stability of generated sets.
Minimality characterizes span uniquely and enables equivalences such as
$\mathrm{span}(S)=\bigcap\{W\le V: S\subseteq W\}$.
}

\FORMULA{
\[
\mathrm{span}(S)=\left\{\sum_{i=1}^k \alpha_i s_i:
k\in\mathbb{N},\ s_i\in S,\ \alpha_i\in\mathbb{F}\right\}.
\]
If $S\subseteq W\le V$ then $\mathrm{span}(S)\subseteq W$. Moreover,
$\mathrm{span}(S)$ is a subspace: for $u,v\in\mathrm{span}(S)$ and
$\lambda\in\mathbb{F}$, $u+v,\lambda u\in\mathrm{span}(S)$ and $0\in
\mathrm{span}(S)$.
}

\CANONICAL{
$V$ is a vector space over $\mathbb{F}$. $S$ is arbitrary (possibly
infinite). Only finite sums are allowed. No topological or metric
structure is required.
}

\PRECONDS{
\begin{bullets}
\item The vector space axioms on $V$ hold.
\item Coefficients are taken from the same field $\mathbb{F}$.
\item Finite linear combinations only.
\end{bullets}
}

\textbf{SUPPORTING LEMMAS.}
\begin{lemma}
If $S\subseteq W\le V$ then every finite linear combination of elements
of $S$ lies in $W$.
\end{lemma}
\begin{proof}
Because $W$ is a subspace, it is closed under addition and scalar
multiplication. Starting from $s_i\in S\subseteq W$, each $\alpha_i s_i
\in W$ and sums of finitely many such elements remain in $W$. Thus
$\sum_{i=1}^k \alpha_i s_i\in W$. \qedhere
\end{proof}

\DERIVATION{
\begin{align*}
\text{Step 1 (Closure under addition):}\ &u=\sum_{i=1}^k\alpha_i s_i,\
v=\sum_{j=1}^\ell\beta_j t_j\\
&\Rightarrow u+v=\sum_{i=1}^k\alpha_i s_i+\sum_{j=1}^\ell\beta_j t_j
=\sum_{p=1}^{k+\ell}\gamma_p r_p\in \mathrm{span}(S).\\
\text{Step 2 (Closure under scaling):}\ &\lambda u
=\sum_{i=1}^k (\lambda\alpha_i) s_i\in \mathrm{span}(S).\\
\text{Step 3 (Zero vector):}\ &0=\sum_{i=1}^0 (\cdot)=0
\in \mathrm{span}(S)\ \text{by empty sum convention}.\\
\text{Step 4 (Minimality):}\ &\text{Let }W\le V\text{ with }S\subseteq W.\\
&\text{By the lemma, every finite linear combination of }S\text{ lies in }W.\\
&\Rightarrow \mathrm{span}(S)\subseteq W.\\
\text{Step 5 (Uniqueness):}\ &\text{The intersection of all }W\text{ with }
S\subseteq W\text{ equals }\mathrm{span}(S).
\end{align*}
}

\textbf{GENERAL PROBLEM-SOLVING TEMPLATE.}
\begin{bullets}
\item To prove a vector is in $\mathrm{span}(S)$, exhibit coefficients.
\item To prove a set equals a span, show mutual inclusion via closure.
\item To prove minimality, invoke the lemma about subspace containment.
\end{bullets}

\EQUIV{
\begin{bullets}
\item $\mathrm{span}(S)=\bigcap\{W\le V: S\subseteq W\}$.
\item If $S\subseteq T$, then $\mathrm{span}(S)\subseteq\mathrm{span}(T)$.
\item $\mathrm{span}(\mathrm{span}(S))=\mathrm{span}(S)$ (idempotence).
\end{bullets}
}

\LIMITS{
\begin{bullets}
\item If $S=\varnothing$, then $\mathrm{span}(S)=\{0\}$.
\item If $S$ already is a subspace, then $\mathrm{span}(S)=S$.
\item Infinite sums are out of scope; topology would be required.
\end{bullets}
}

\INPUTS{$S\subseteq V$.}

\DERIVATION{
\begin{align*}
\text{Given }S\subseteq V,\ &\text{define the set }L(S)\text{ of all finite
linear combinations.}\\
&\text{Prove }L(S)\le V\ \text{by closure; hence }L(S)=\mathrm{span}(S).
\end{align*}
}

\RESULT{
$\mathrm{span}(S)$ is a well-defined subspace and the minimal one
containing $S$.
}

\UNITCHECK{
No physical units; structural check: closure and minimality satisfy
subspace axioms and lattice properties under inclusion.
}

\PITFALLS{
\begin{bullets}
\item Using infinite series in span without topology.
\item Forgetting that $\mathrm{span}(\varnothing)=\{0\}$.
\item Confusing span with affine hull or convex hull.
\end{bullets}
}

\INTUITION{
Span is the closure of a set under the only operations allowed by linear
structure: add and scale. Minimality says we have added nothing beyond
what linearity forces.
}

\CANONICAL{
\begin{bullets}
\item $\mathrm{span}:\mathcal{P}(V)\to\{\text{subspaces of }V\}$ is
idempotent, extensive, and monotone.
\item $\mathrm{span}(S\cup T)=\mathrm{span}(\mathrm{span}(S)\cup
\mathrm{span}(T))$.
\end{bullets}
}

\FormulaPage{2}{Membership in Span via Linear Systems}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
Given $A=[a_1\ \cdots\ a_n]\in\mathbb{F}^{m\times n}$ and $b\in
\mathbb{F}^m$, $b\in\mathrm{Col}(A)$ if and only if the system
$Ax=b$ has a solution $x\in\mathbb{F}^n$.

\WHAT{
This equates span membership with solvability of a linear system whose
columns are the generators and unknowns are coefficients.
}

\WHY{
It transforms geometric span queries into algebraic computation via
Gaussian elimination, enabling algorithmic tests and coordinate
recovery.
}

\FORMULA{
\[
b\in\mathrm{span}(a_1,\dots,a_n)\ \Longleftrightarrow\ \exists x\in
\mathbb{F}^n\ \text{such that}\ Ax=b.
\]
}

\CANONICAL{
$A\in\mathbb{F}^{m\times n}$, $b\in\mathbb{F}^m$. No rank assumptions.
Use standard elementary row operations to test consistency.
}

\PRECONDS{
\begin{bullets}
\item Correct assembly of $A$ with given generators as columns.
\item Linear system theory over $\mathbb{F}$ applies.
\end{bullets}
}

\textbf{SUPPORTING LEMMAS.}
\begin{lemma}
Elementary row operations preserve the solution set of $Ax=b$.
\end{lemma}
\begin{proof}
Each elementary row operation corresponds to left-multiplication by an
invertible elementary matrix $E$ so that $EAx=Eb$. Because $E$ is
invertible, $Ax=b$ if and only if $EAx=Eb$. Thus consistency and the
solution set are preserved bijectively. \qedhere
\end{proof}

\DERIVATION{
\begin{align*}
\text{Step 1 (Only if):}\ &b\in\mathrm{span}(a_1,\dots,a_n)\\
&\Rightarrow \exists x:\ b=\sum_{j=1}^n x_j a_j=Ax.\\
\text{Step 2 (If):}\ &Ax=b\ \text{for some }x\Rightarrow
b=\sum_{j=1}^n x_j a_j\in\mathrm{span}(a_1,\dots,a_n).\\
\text{Step 3 (Algorithm):}\ &\text{Augment }[A\mid b]\ \text{and row-reduce}.\\
&\text{By the lemma, consistency } \iff b\in\mathrm{Col}(A).\\
\text{Step 4 (Coordinates):}\ &\text{Any solution }x\ \text{gives
coefficients for the linear combination.}
\end{align*}
}

\textbf{GENERAL PROBLEM-SOLVING TEMPLATE.}
\begin{bullets}
\item Form $A$ with generators as columns.
\item Row-reduce $[A\mid b]$ to test consistency.
\item If consistent, read a solution $x$ as coefficients.
\end{bullets}

\EQUIV{
\begin{bullets}
\item $b\in\mathrm{Col}(A)\iff \mathrm{rank}(A)=\mathrm{rank}([A\mid b])$.
\item If $A$ has full column rank, then $x$ is unique.
\end{bullets}
}

\LIMITS{
\begin{bullets}
\item If $A$ has dependent columns, solutions may be non-unique.
\item Inconsistent systems indicate $b\notin\mathrm{Col}(A)$.
\end{bullets}
}

\INPUTS{$A\in\mathbb{F}^{m\times n}$, $b\in\mathbb{F}^m$.}

\DERIVATION{
\begin{align*}
\text{Example:}\ &A=\begin{bmatrix}1&2\\1&3\end{bmatrix},\
b=\begin{bmatrix}3\\4\end{bmatrix}.\\
&[A\mid b]\to \begin{bmatrix}1&2&3\\0&1&1\end{bmatrix}.\
x_2=1,\ x_1=1.\\
&b=1\cdot a_1+1\cdot a_2\in\mathrm{Col}(A).
\end{align*}
}

\RESULT{
Membership reduces to solving $Ax=b$. Existence of solutions equals
membership; solution vectors are coefficient choices.
}

\UNITCHECK{
Structural consistency: left-multiplication by invertible matrices
preserves solvability. Dimensions: $Ax$ defined only if $x\in\mathbb{F}^n$.
}

\PITFALLS{
\begin{bullets}
\item Forgetting to augment $b$ when row-reducing.
\item Misreading pivot columns after row operations on the augmented
matrix; pivot locations refer to $A$'s columns.
\end{bullets}
}

\INTUITION{
If $b$ can be made by mixing columns of $A$, the mix ratios are the
solution $x$ to $Ax=b$.
}

\CANONICAL{
\begin{bullets}
\item Column space equals the set of all outputs $Ax$ for $x\in\mathbb{F}^n$.
\item Consistency criterion via ranks is the algebraic face of span.
\end{bullets}
}

\FormulaPage{3}{Basis of a Span via Pivot Columns}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
The pivot columns of $A$ (in the original $A$) form a basis for
$\mathrm{Col}(A)$. Hence $\dim\mathrm{span}(a_1,\dots,a_n)=\mathrm{rank}(A)$.

\WHAT{
Construct a basis of the span generated by columns of $A$ using Gaussian
elimination; dimension equals the number of pivots.
}

\WHY{
Provides an effective method to extract minimal generators and the
dimension of the span, central to rank and coordinate computations.
}

\FORMULA{
\[
\mathcal{B}=\{a_{j_1},\dots,a_{j_r}\}\ \text{(pivot columns of $A$)}
\quad\Rightarrow\quad \mathrm{Col}(A)=\mathrm{span}(\mathcal{B}),\
|\mathcal{B}|=r.
\]
}

\CANONICAL{
$A\in\mathbb{F}^{m\times n}$, perform elementary row operations to
reach RREF $R$. Let pivot column indices in $R$ be $j_1<\cdots<j_r$.
Then the corresponding original columns form $\mathcal{B}$.
}

\PRECONDS{
\begin{bullets}
\item Validity of elementary row operations and RREF existence.
\item Identification of pivot positions in RREF.
\end{bullets}
}

\textbf{SUPPORTING LEMMAS.}
\begin{lemma}
If $R=EA$ for an invertible matrix $E$, then
$\mathrm{Col}(R)=E\,\mathrm{Col}(A)$ and linear dependencies among the
columns are preserved: for all $c$, $Ac=0$ iff $Rc=0$.
\end{lemma}
\begin{proof}
$R=EA$ implies for any $c$, $Rc=E(Ac)$. Thus $Ac=0$ iff $Rc=0$ since
$E$ is invertible. Hence column dependence relations are unchanged.
Also, every column of $R$ is $E$ applied to a column of $A$, so
$\mathrm{Col}(R)=E\,\mathrm{Col}(A)$. \qedhere
\end{proof}

\DERIVATION{
\begin{align*}
\text{Step 1 (Row-reduce):}\ &R=EA\ \text{in RREF with pivot columns }j_1,\dots,j_r.\\
\text{Step 2 (Independence):}\ &\text{Pivot columns of }R\ \text{are independent}.\\
&\text{If }R[c_{j_1},\dots,c_{j_r}]^\top=0\Rightarrow \text{pivots force }c_{j_i}=0.\\
\text{Step 3 (Preservation):}\ &\text{By lemma, same linear relations for columns of }A.\\
&\Rightarrow \{a_{j_1},\dots,a_{j_r}\}\ \text{are independent}.\\
\text{Step 4 (Spanning):}\ &\text{Non-pivot columns of }R\ \text{are combos of pivot ones}.\\
&\Rightarrow \text{Corresponding }a_k\ \text{are in }\mathrm{span}(a_{j_1},\dots,a_{j_r}).\\
\text{Step 5 (Dimension):}\ &r=\mathrm{rank}(A)=\dim\mathrm{Col}(A).
\end{align*}
}

\textbf{GENERAL PROBLEM-SOLVING TEMPLATE.}
\begin{bullets}
\item Compute RREF, identify pivot columns.
\item Select those columns from the original $A$ as a basis.
\item Count pivots to get dimension.
\end{bullets}

\EQUIV{
\begin{bullets}
\item Any maximal independent subset of $\{a_1,\dots,a_n\}$ is a basis.
\item $\dim\mathrm{Col}(A)=\mathrm{rank}(A)=\mathrm{rank}(A^\top)$.
\end{bullets}
}

\LIMITS{
\begin{bullets}
\item Column swaps change which columns are pivots; track original
indices.
\item Over exact arithmetic assumptions; numerical pivoting may choose
different pivots but same rank.
\end{bullets}
}

\INPUTS{$A\in\mathbb{F}^{m\times n}$.}

\DERIVATION{
\begin{align*}
\text{Example:}\ &A=\begin{bmatrix}1&2&3\\0&1&4\\1&3&7\end{bmatrix}.\
R=\begin{bmatrix}1&0&-1\\0&1&4\\0&0&0\end{bmatrix}.\\
&\text{Pivot columns }1,2\Rightarrow \mathcal{B}=\{a_1,a_2\}.\
\dim=2.\\
&a_3=a_1+4a_2\ \text{from RREF relations.}
\end{align*}
}

\RESULT{
A concrete basis for the span and its dimension are obtained from pivot
columns; non-pivot columns are linear combinations of pivot ones.
}

\UNITCHECK{
Structural: independence via pivots, spanning via column relations, and
dimension equals pivot count.
}

\PITFALLS{
\begin{bullets}
\item Using pivot columns from $R$ directly as basis; must take them in
the original $A$.
\item Miscounting pivots due to almost-zero numerics.
\end{bullets}
}

\INTUITION{
Row operations re-express the same span in a coordinate system where
structure is visible; pivot columns are the essential generators.
}

\CANONICAL{
\begin{bullets}
\item $\mathrm{Col}(A)=\mathrm{span}(\text{pivot columns of }A)$.
\item Rank is the invariant measuring span dimension.
\end{bullets}
}

\FormulaPage{4}{Uniqueness of Coefficients and Linear Independence}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
Given $v_1,\dots,v_k\in V$, every $u\in\mathrm{span}(v_1,\dots,v_k)$ has
a unique representation $u=\sum_{i=1}^k \alpha_i v_i$ if and only if
$\{v_1,\dots,v_k\}$ is linearly independent.

\WHAT{
Characterizes when coefficients in linear combinations are uniquely
determined by the target vector.
}

\WHY{
Uniqueness provides coordinates in the generating set and is essential
for bases and stable representations in computation and theory.
}

\FORMULA{
\[
\left(\forall u\in\mathrm{span}\ \exists!\ \alpha: u=\sum_{i=1}^k
\alpha_i v_i\right)\ \Longleftrightarrow\ \{v_i\}\ \text{is LI}.
\]
}

\CANONICAL{
Work in any vector space over $\mathbb{F}$. LI means
$\sum_{i=1}^k c_i v_i=0\Rightarrow c_i=0$ for all $i$.
}

\PRECONDS{
\begin{bullets}
\item Definitions of linear independence and span.
\item Basic cancellation properties in vector spaces.
\end{bullets}
}

\textbf{SUPPORTING LEMMAS.}
\begin{lemma}
If $\{v_i\}$ is linearly independent and
$\sum_{i=1}^k \alpha_i v_i=\sum_{i=1}^k \beta_i v_i$, then
$\alpha_i=\beta_i$ for all $i$.
\end{lemma}
\begin{proof}
Subtracting gives $\sum_{i=1}^k (\alpha_i-\beta_i)v_i=0$. Independence
forces each $\alpha_i-\beta_i=0$, hence $\alpha_i=\beta_i$. \qedhere
\end{proof}

\DERIVATION{
\begin{align*}
\text{Step 1 (LI $\Rightarrow$ uniqueness):}\ &
u=\sum \alpha_i v_i=\sum \beta_i v_i\Rightarrow \alpha_i=\beta_i
\ \text{by lemma}.\\
\text{Step 2 (Uniqueness $\Rightarrow$ LI):}\ &
\text{Suppose uniqueness holds and }\sum c_i v_i=0.\\
&\text{Then }0=\sum c_i v_i=\sum 0\cdot v_i.\\
&\text{By uniqueness, }c_i=0\ \forall i.\ \text{Thus independent.}
\end{align*}
}

\textbf{GENERAL PROBLEM-SOLVING TEMPLATE.}
\begin{bullets}
\item To test uniqueness, test independence via $Ax=0$.
\item If independent, solve $Ax=u$ to get the unique coefficients.
\item If dependent, parameterize the family of coefficients.
\end{bullets}

\EQUIV{
\begin{bullets}
\item For $A=[v_1\ \cdots\ v_k]$, uniqueness $\iff \ker(A)=\{0\}$.
\item Full column rank $\iff$ unique solution for every $u\in\mathrm{Col}(A)$.
\end{bullets}
}

\LIMITS{
\begin{bullets}
\item If $u\notin\mathrm{span}$, no representation exists.
\item If dependent, representations (when they exist) are not unique.
\end{bullets}
}

\INPUTS{$v_1,\dots,v_k\in V$, target $u\in V$.}

\DERIVATION{
\begin{align*}
\text{Example:}\ &v_1=(1,0),\ v_2=(1,1),\ u=(2,1).\\
&A=\begin{bmatrix}1&1\\0&1\end{bmatrix},\ \ker(A)=\{0\}.\
Ax=u\Rightarrow x=(1,1).\\
&\text{Unique coefficients }(1,1).\\
\text{Counterexample:}\ &v_1=(1,0),\ v_2=(2,0),\ u=(2,0).\\
&Ax=u\ \text{has solutions }(2,0),\ (0,1),\ (2-t,t)\ \text{not unique}.
\end{align*}
}

\RESULT{
Uniqueness of coefficients is equivalent to linear independence of the
generating set, i.e., zero null space for the coefficient matrix.
}

\UNITCHECK{
Dimensionally consistent; the kernel dimension governs non-uniqueness
via the rank-nullity relationship.
}

\PITFALLS{
\begin{bullets}
\item Conflating existence with uniqueness; independence is about
uniqueness, not existence.
\item Forgetting to restrict $u$ to the span when invoking uniqueness.
\end{bullets}
}

\INTUITION{
When generators do not overlap in their influence, the mix required to
make a dish is unique; overlaps allow multiple recipes for the same dish.
}

\CANONICAL{
\begin{bullets}
\item $\ker(A)=\{0\}\ \Leftrightarrow\ \text{columns are LI}\ \Leftrightarrow$
unique coordinates on the column space.
\end{bullets}
}

\section{10 Exhaustive Problems and Solutions}

\ProblemPage{1}{Subspace Generated by Given Vectors in $\mathbb{R}^3$}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
Determine $\mathrm{span}(S)$ for $S=\{(1,2,3)^\top,(2,5,8)^\top\}$,
find a basis, and the dimension. Decide whether $b=(3,7,11)^\top$ is in
the span and give coefficients if so.

\PROBLEM{
Compute a basis of the span using pivot columns and test membership of a
given vector via $Ax=b$.
}

\MODEL{
\[
A=\begin{bmatrix}1&2\\2&5\\3&8\end{bmatrix},\quad
\mathrm{Col}(A)=\mathrm{span}(S).
\]
}

\ASSUMPTIONS{
\begin{bullets}
\item Work over $\mathbb{R}$.
\item Use Gaussian elimination exactly.
\end{bullets}
}

\varmapStart
\var{a_1,a_2}{Generators in $\mathbb{R}^3$.}
\var{A}{Matrix with columns $a_1,a_2$.}
\var{b}{Target vector in $\mathbb{R}^3$.}
\var{x}{Coefficient vector in $\mathbb{R}^2$.}
\varmapEnd

\WHICHFORMULA{
Formula 3 (Pivot columns give a basis) and Formula 2 (Membership via
$Ax=b$).
}

\GOVERN{
\[
R=\mathrm{RREF}(A),\ \text{pivot columns }\Rightarrow \text{basis};
\quad Ax=b\ \text{for membership}.
\]
}

\INPUTS{$a_1=(1,2,3)^\top$, $a_2=(2,5,8)^\top$, $b=(3,7,11)^\top$.}

\DERIVATION{
\begin{align*}
\text{Step 1 (RREF):}\ &[A]=\begin{bmatrix}1&2\\2&5\\3&8\end{bmatrix}
\to \begin{bmatrix}1&2\\0&1\\0&2\end{bmatrix}\to
\begin{bmatrix}1&0\\0&1\\0&0\end{bmatrix}.\\
&\text{Pivots at columns 1,2 }\Rightarrow \{a_1,a_2\}\ \text{independent}.\\
&\dim\mathrm{span}(S)=2,\ \text{basis } \{a_1,a_2\}.\\
\text{Step 2 (Membership):}\ &[A\mid b]=\begin{bmatrix}
1&2&3\\2&5&7\\3&8&11
\end{bmatrix}
\to \begin{bmatrix}
1&2&3\\0&1&1\\0&2&2
\end{bmatrix}
\to \begin{bmatrix}
1&0&1\\0&1&1\\0&0&0
\end{bmatrix}.\\
&x_2=1,\ x_1=1\Rightarrow b=a_1+a_2\in \mathrm{span}(S).
\end{align*}
}

\RESULT{
Basis $\{(1,2,3)^\top,(2,5,8)^\top\}$, dimension $2$, and $b$ is in the
span with coefficients $(1,1)$.
}

\UNITCHECK{
Rank $2\le \min(3,2)$. Consistency verified by exact arithmetic.
}

\EDGECASES{
\begin{bullets}
\item If $a_2$ were a multiple of $a_1$, dimension would drop to $1$.
\item If $b$ violated the linear relation among rows, system would be
inconsistent.
\end{bullets}
}

\ALTERNATE{
Use determinant of the $2\times 2$ minors to verify independence of
columns and solve $Ax=b$ by Cramer when square, or by back substitution.
}

\VALIDATION{
\begin{bullets}
\item Substitute: $a_1+a_2=(3,7,11)^\top=b$.
\item RREF yields identity in first two rows confirming rank $2$.
\end{bullets}
}

\INTUITION{
Two non-collinear vectors in $\mathbb{R}^3$ span a plane through the
origin. The target lies in that plane with equal weights.
}

\CANONICAL{
\begin{bullets}
\item Column rank equals span dimension.
\item Membership equals solvability.
\end{bullets}
}

\ProblemPage{2}{Span of Polynomials and Basis Extraction}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
Given $p_1(t)=1+t$, $p_2(t)=1+2t+t^2$, $p_3(t)=2+3t$, find a basis for
$W=\mathrm{span}\{p_1,p_2,p_3\}\subseteq \mathbb{R}[t]_{\le 2}$ and
express $q(t)=3+5t+2t^2$ in that basis if possible.

\PROBLEM{
Represent polynomials as coordinate vectors in the monomial basis
$\{1,t,t^2\}$ and use pivot columns to find a basis.
}

\MODEL{
\[
p_1\leftrightarrow \begin{bmatrix}1\\1\\0\end{bmatrix},\
p_2\leftrightarrow \begin{bmatrix}1\\2\\1\end{bmatrix},\
p_3\leftrightarrow \begin{bmatrix}2\\3\\0\end{bmatrix},\
A=\begin{bmatrix}1&1&2\\1&2&3\\0&1&0\end{bmatrix}.
\]
}

\ASSUMPTIONS{
\begin{bullets}
\item Coefficients over $\mathbb{R}$.
\item Coordinate isomorphism between polynomials and $\mathbb{R}^3$.
\end{bullets}
}

\varmapStart
\var{p_i}{Generators in $\mathbb{R}[t]_{\le 2}$.}
\var{A}{Matrix of coefficients in monomial basis.}
\var{q}{Target polynomial.}
\var{x}{Coefficient vector for combination.}
\varmapEnd

\WHICHFORMULA{
Formula 3 for basis; Formula 2 for membership via $Ax=q$.
}

\GOVERN{
\[
R=\mathrm{RREF}(A),\ \text{pivot columns basis};\quad Ax=q.
\]
}

\INPUTS{$p_1=1+t$, $p_2=1+2t+t^2$, $p_3=2+3t$, $q=3+5t+2t^2$.}

\DERIVATION{
\begin{align*}
\text{Step 1 (RREF):}\ &
A=\begin{bmatrix}1&1&2\\1&2&3\\0&1&0\end{bmatrix}
\to \begin{bmatrix}1&0&1\\0&1&1\\0&0&0\end{bmatrix}.\\
&\text{Pivot columns }1,2\Rightarrow \mathcal{B}=\{p_1,p_2\}.\\
&p_3=p_1+p_2.\\
\text{Step 2 (Membership):}\ &q\leftrightarrow \begin{bmatrix}3\\5\\2\end{bmatrix}.\
[A\mid q]\\
&\to \begin{bmatrix}1&0&1&2\\0&1&1&3\\0&0&0&0\end{bmatrix}.\\
&x_3\ \text{free}=:t,\ x_1=2-t,\ x_2=3-t.\\
&q=(2-t)p_1+(3-t)p_2+ t p_3.\\
&\text{For basis }\{p_1,p_2\}:\ q=2p_1+3p_2\ \text{(set }t=0).
\end{align*}
}

\RESULT{
Basis $\{1+t,\ 1+2t+t^2\}$, dimension $2$, and
$3+5t+2t^2=2(1+t)+3(1+2t+t^2)$.
}

\UNITCHECK{
All vectors in $\mathbb{R}^3$; rank $2$ consistent with one zero row in
RREF.
}

\EDGECASES{
\begin{bullets}
\item If $q$ had degree $>2$, it could not be in the span in this space.
\item If $p_2$ lacked $t^2$, dimension might drop to $1$.
\end{bullets}
}

\ALTERNATE{
Solve for $x_1,x_2$ by matching coefficients directly:
$x_1+x_2=3$, $x_1+2x_2=5$, $x_2=2$.
}

\VALIDATION{
\begin{bullets}
\item Substitute: $2(1+t)+3(1+2t+t^2)=3+5t+2t^2$.
\item RREF shows dependence $p_3=p_1+p_2$.
\end{bullets}
}

\INTUITION{
Only two independent directions are present: constant-plus-linear and
quadratic direction tied to $p_2$.
}

\CANONICAL{
\begin{bullets}
\item Basis from pivot columns; non-pivots as combinations.
\item Membership by solving $Ax=q$.
\end{bullets}
}

\ProblemPage{3}{Equality of Spans}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
Given $u_1=(1,0,1)$, $u_2=(0,1,1)$, and $v_1=(1,1,2)$, $v_2=(1,-1,0)$ in
$\mathbb{R}^3$, decide whether
$\mathrm{span}\{u_1,u_2\}=\mathrm{span}\{v_1,v_2\}$.

\PROBLEM{
Check mutual inclusion by expressing each generator of one set as a
linear combination of the other set.
}

\MODEL{
\[
U=[u_1\ u_2]=\begin{bmatrix}1&0\\0&1\\1&1\end{bmatrix},\quad
V=[v_1\ v_2]=\begin{bmatrix}1&1\\1&-1\\2&0\end{bmatrix}.
\]
}

\ASSUMPTIONS{
\begin{bullets}
\item Real arithmetic, exact computations.
\end{bullets}
}

\varmapStart
\var{u_i,v_j}{Generators in $\mathbb{R}^3$.}
\var{U,V}{Matrices with columns $u_i$ and $v_j$.}
\var{x,y}{Coefficient vectors to express inclusion.}
\varmapEnd

\WHICHFORMULA{
Formula 2: membership via solving $Ax=b$; apply twice for mutual
inclusion.
}

\GOVERN{
\[
Vx=u_i\ \text{and}\ Uy=v_j\ \text{must be solvable for all generators}.
\]
}

\INPUTS{$u_1,u_2,v_1,v_2$ as above.}

\DERIVATION{
\begin{align*}
\text{Step 1:}\ &Vx=u_1:\ \begin{bmatrix}1&1\\1&-1\\2&0\end{bmatrix}
\begin{bmatrix}x_1\\x_2\end{bmatrix}
=\begin{bmatrix}1\\0\\1\end{bmatrix}.\\
&\text{Equations: }x_1+x_2=1,\ x_1-x_2=0,\ 2x_1=1.\\
&\Rightarrow x_1=\tfrac12,\ x_2=\tfrac12\ \text{consistent}.\\
&Vx=u_2:\ x_1+x_2=0,\ x_1-x_2=1,\ 2x_1=1\\
&\Rightarrow x_1=\tfrac12,\ x_2=-\tfrac12\ \text{consistent}.\\
&\Rightarrow \mathrm{span}(U)\subseteq \mathrm{span}(V).\\
\text{Step 2:}\ &Uy=v_1:\ \begin{bmatrix}1&0\\0&1\\1&1\end{bmatrix}
\begin{bmatrix}y_1\\y_2\end{bmatrix}
=\begin{bmatrix}1\\1\\2\end{bmatrix}.\\
&\Rightarrow y_1=1,\ y_2=1\ \text{and }1+1=2\ \checkmark.\\
&Uy=v_2:\ y_1=1,\ y_2=-1,\ 1+(-1)=0\ \checkmark.\\
&\Rightarrow \mathrm{span}(V)\subseteq \mathrm{span}(U).\\
\text{Conclusion:}\ &\mathrm{span}\{u_1,u_2\}=\mathrm{span}\{v_1,v_2\}.
\end{align*}
}

\RESULT{
The spans are equal; both generate the same $2$-dimensional plane.
}

\UNITCHECK{
Each inclusion verified by consistent linear systems; dimensions $2$ on
both sides by independence.
}

\EDGECASES{
\begin{bullets}
\item If one inclusion failed, spans would be different.
\item If one set had dependent vectors, still could generate the plane.
\end{bullets}
}

\ALTERNATE{
Compute RREFs of $U$ and $V$ and compare bases up to span:
both have rank $2$ and share the same normal vector $(1,1,-1)$.
}

\VALIDATION{
\begin{bullets}
\item Direct substitution verifies expressed combinations.
\item Determinants of $2\times 2$ minors consistent with rank $2$.
\end{bullets}
}

\INTUITION{
Different generating pairs can describe the same plane if each can be
made from the other.
}

\CANONICAL{
\begin{bullets}
\item Span equality iff mutual inclusion holds.
\item In finite dimensions, equal dimensions and one inclusion imply
equality if subspaces coincide geometrically.
\end{bullets}
}

\ProblemPage{4}{Narrative: Alice and Bob's Mixing Lab}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
Alice has base vectors $a_1=(1,1,0)$ and $a_2=(0,1,1)$. Bob has
$b_1=(1,0,1)$ and $b_2=(1,1,1)$. They claim that any mixture one can
make the other can replicate uniquely. Verify the claim and explain the
uniqueness.

\PROBLEM{
Show span equality and uniqueness of coefficients by testing
independence of each set and expressing generators mutually.
}

\MODEL{
\[
A=[a_1\ a_2]=\begin{bmatrix}1&0\\1&1\\0&1\end{bmatrix},\quad
B=[b_1\ b_2]=\begin{bmatrix}1&1\\0&1\\1&1\end{bmatrix}.
\]
}

\ASSUMPTIONS{
\begin{bullets}
\item Real vector space $\mathbb{R}^3$.
\item Exact arithmetic.
\end{bullets}
}

\varmapStart
\var{a_i,b_j}{Generators.}
\var{A,B}{Generator matrices.}
\var{x,y}{Coefficient vectors.}
\varmapEnd

\WHICHFORMULA{
Formula 2 for membership; Formula 4 for uniqueness via independence.
}

\GOVERN{
\[
Bx=a_i\ \text{solvable},\ Ay=b_j\ \text{solvable};\ 
\ker(A)=\{0\},\ \ker(B)=\{0\}.
\]
}

\INPUTS{$a_1,a_2,b_1,b_2$ as above.}

\DERIVATION{
\begin{align*}
\text{Step 1 (Independence):}\ &\det\begin{bmatrix}1&0\\1&1\end{bmatrix}=1\ne0
\ \Rightarrow A\ \text{columns LI}.\\
&\det\begin{bmatrix}1&1\\0&1\end{bmatrix}=1\ne0\ \Rightarrow B\ \text{columns LI}.\\
\text{Step 2 (Mutual expressions):}\ &
Bx=a_1\Rightarrow \begin{bmatrix}1&1\\0&1\\1&1\end{bmatrix}
\begin{bmatrix}x_1\\x_2\end{bmatrix}=\begin{bmatrix}1\\1\\0\end{bmatrix}.\\
&x_1+x_2=1,\ x_2=1,\ x_1+x_2=0\ \text{contradiction?}\\
&\text{Re-evaluate:}\ a_1=(1,1,0)^\top,\ B\ \text{columns }(1,0,1)^\top,(1,1,1)^\top.\\
&\text{Solve: }x_1+x_2=1,\ 0\cdot x_1+1\cdot x_2=1,\ 1\cdot x_1+1\cdot x_2=0.\\
&x_2=1,\ x_1=0\ \text{from first},\ 0+1\ne 0\ \text{inconsistent}.\\
&\text{Thus spans are not equal? Check the claim carefully.}\\
&\text{Compute spans explicitly:}\\
&\mathrm{span}(A)\text{ plane with normal }n_A=(1,-1,1)\ \text{since }n_A^\top a_i=0.\\
&\mathrm{span}(B)\text{ plane with normal }n_B=(0,1,-1)\ \text{since }n_B^\top b_j=0.\\
&n_A\not\parallel n_B\Rightarrow \text{different planes}.\\
\text{Step 3 (Conclusion):}\ &\text{Claim is false; not all mixtures match.}\\
&\text{But uniqueness for each set holds due to independence (Formula 4).}
\end{align*}
}

\RESULT{
Alice and Bob each have unique coefficients within their own spans, but
the spans differ; neither can replicate all mixtures of the other.
}

\UNITCHECK{
Both sets span $2$-dimensional planes through the origin; normals differ
so planes differ.
}

\EDGECASES{
\begin{bullets}
\item If Bob had $b_2=a_1+a_2=(1,2,1)$, spans would be equal.
\item If either set were dependent, uniqueness would fail.
\end{bullets}
}

\ALTERNATE{
Directly row-reduce $[A\mid B]$ block equations to check feasibility of
expressing $a_i$ via $B$ and vice versa.
}

\VALIDATION{
\begin{bullets}
\item Attempt to solve $Bx=a_2$ also fails at the third component.
\item Distinct normals certify different planes.
\end{bullets}
}

\INTUITION{
Unique recipes in different kitchens do not allow swapping dishes across
kitchens if the available ingredients differ fundamentally.
}

\CANONICAL{
\begin{bullets}
\item Independence gives uniqueness; equality requires mutual inclusion.
\end{bullets}
}

\ProblemPage{5}{Narrative: Hidden Dependence in Sensor Readings}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
Three sensors measure $s_1=(1,2,1)$, $s_2=(2,5,2)$, $s_3=(3,7,3)$.
A new reading $r=(4,10,4)$. Identify hidden dependence, find a minimal
sensor set that spans all readings, and express $r$ uniquely.

\PROBLEM{
Detect linear dependence through RREF, select a basis, and compute
coefficients for $r$.
}

\MODEL{
\[
A=[s_1\ s_2\ s_3]=\begin{bmatrix}1&2&3\\2&5&7\\1&2&3\end{bmatrix},\quad
b=r.
\]
}

\ASSUMPTIONS{
\begin{bullets}
\item Real arithmetic.
\end{bullets}
}

\varmapStart
\var{s_i}{Sensor vectors.}
\var{A}{Sensor matrix.}
\var{b}{New reading.}
\var{x}{Coefficients to express $b$.}
\varmapEnd

\WHICHFORMULA{
Formula 3 for basis via pivot columns; Formula 2 for membership.
}

\GOVERN{
\[
R=\mathrm{RREF}(A),\ \text{pivot columns basis};\ Ax=b.
\]
}

\INPUTS{$s_1=(1,2,1)$, $s_2=(2,5,2)$, $s_3=(3,7,3)$, $b=(4,10,4)$.}

\DERIVATION{
\begin{align*}
\text{Step 1 (RREF):}\ &A\to \begin{bmatrix}1&0&1\\0&1&1\\0&0&0\end{bmatrix}.\
\text{Pivots }1,2.\\
&\Rightarrow s_3=s_1+s_2\ \text{hidden dependence}.\\
\text{Step 2 (Basis):}\ &\mathcal{B}=\{s_1,s_2\},\ \dim=2.\\
\text{Step 3 (Membership):}\ &[A\mid b]\to
\begin{bmatrix}1&0&1&4\\0&1&1&10\\0&0&0&0\end{bmatrix}.\\
&x_3\ \text{free}=:t,\ x_1=4-t,\ x_2=10-t.\\
&\text{Unique coords in }\mathcal{B}:\ t=0\Rightarrow x=(4,10,0).\\
&b=4 s_1+10 s_2.
\end{align*}
}

\RESULT{
Hidden dependence $s_3=s_1+s_2$. Basis $\{s_1,s_2\}$ spans all readings.
$r$ expressed uniquely as $4 s_1+10 s_2$.
}

\UNITCHECK{
Rank $2$; consistent system with one free variable matching one
dependence relation.
}

\EDGECASES{
\begin{bullets}
\item If $r$ violated the same relation as rows, system would be
inconsistent; here it aligns.
\item If $s_2$ were a multiple of $s_1$, rank would drop to $1$.
\end{bullets}
}

\ALTERNATE{
Projectively observe proportional third components showing dependence:
first and third rows are identical, forcing a relation.
}

\VALIDATION{
\begin{bullets}
\item Check $s_1+s_2=s_3$ numerically.
\item Verify $4 s_1+10 s_2=(4,10,4)$.
\end{bullets}
}

\INTUITION{
Two independent sensors suffice; the third repeats combined information.
}

\CANONICAL{
\begin{bullets}
\item Pivot columns yield a minimal spanning set.
\item Non-pivot columns are combinations of pivots.
\end{bullets}
}

\ProblemPage{6}{Expectation Puzzle on Random Span Dimension}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
Pick two vectors $X,Y$ independently and uniformly from
$\{(1,0),(0,1),(1,1),(1,-1)\}\subset\mathbb{R}^2$. Let $D$ be the
dimension of $\mathrm{span}\{X,Y\}$. Compute $\mathbb{E}[D]$.

\PROBLEM{
Enumerate cases where $X$ and $Y$ are dependent vs. independent and
average the resulting dimensions.
}

\MODEL{
\[
D=\begin{cases}
1,& Y\in\mathrm{span}\{X\}\\
2,& \text{otherwise}
\end{cases}
\quad\text{in }\mathbb{R}^2.
\]
}

\ASSUMPTIONS{
\begin{bullets}
\item Uniform independent draws over a finite set.
\item Dependence in $\mathbb{R}^2$ means collinearity and nonzero.
\end{bullets}
}

\varmapStart
\var{X,Y}{Random vectors.}
\var{D}{Random span dimension.}
\varmapEnd

\WHICHFORMULA{
Formula 1 for span as subspace; dependence implies $\dim=1$, otherwise
$\dim=2$.
}

\GOVERN{
\[
\mathbb{E}[D]=1\cdot \mathbb{P}(Y\in\mathrm{span}\{X\})+
2\cdot \mathbb{P}(Y\notin\mathrm{span}\{X\}).
\]
}

\INPUTS{Finite set $\mathcal{S}=\{(1,0),(0,1),(1,1),(1,-1)\}$.}

\DERIVATION{
\begin{align*}
\text{Step 1:}\ &\mathbb{P}(Y\in\mathrm{span}\{X\})
=\sum_{x\in\mathcal{S}}\mathbb{P}(X=x)\ \mathbb{P}(Y\in\mathrm{span}\{x\}).\\
\text{Step 2:}\ &\mathbb{P}(X=x)=\tfrac14.\\
&\mathrm{span}\{(1,0)\}=\{(t,0)\};\ \mathcal{S}\cap\text{this line}=\{(1,0)\}.\\
&\mathrm{span}\{(0,1)\}\ \text{intersects in}\ \{(0,1)\}.\\
&\mathrm{span}\{(1,1)\}\ \text{intersects in}\ \{(1,1)\}.\\
&\mathrm{span}\{(1,-1)\}\ \text{intersects in}\ \{(1,-1)\}.\\
&\Rightarrow \mathbb{P}(Y\in\mathrm{span}\{X\}\mid X=x)=\tfrac14.\\
\text{Step 3:}\ &\mathbb{P}(Y\in\mathrm{span}\{X\})=\sum_{x}\tfrac14\cdot\tfrac14
=4\cdot \tfrac{1}{16}=\tfrac14.\\
\text{Step 4:}\ &\mathbb{E}[D]=1\cdot \tfrac14+2\cdot \tfrac34
=\tfrac14+\tfrac{6}{4}=\tfrac{7}{4}=1.75.
\end{align*}
}

\RESULT{
$\mathbb{E}[D]=7/4=1.75$.
}

\UNITCHECK{
Dimension always in $\{1,2\}$; expectation lies between them.
}

\EDGECASES{
\begin{bullets}
\item If zero vector were included, dependence probability would rise.
\item With continuous draws, dependence has probability zero.
\end{bullets}
}

\ALTERNATE{
Compute $1+\mathbb{P}(\text{independent})$ directly since $D=1$ or $2$.
}

\VALIDATION{
\begin{bullets}
\item Symmetry shows each $x$ behaves identically.
\item Exhaustive enumeration confirms the fractions.
\end{bullets}
}

\INTUITION{
Randomly chosen directions in the plane are usually independent; only
when identical lines occur is the dimension $1$.
}

\CANONICAL{
\begin{bullets}
\item Span dimension equals number of independent directions.
\end{bullets}
}

\ProblemPage{7}{Proof-Style: Span of Union and Sum of Subspaces}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
For subspaces $U,W\le V$, prove that $\mathrm{span}(U\cup W)=U+W
=\{u+w: u\in U,\ w\in W\}$.

\PROBLEM{
Show that the span of the union equals the algebraic sum by mutual
inclusion and minimality of span.
}

\MODEL{
\[
U,W\le V,\quad U+W=\{u+w\}.
\]
}

\ASSUMPTIONS{
\begin{bullets}
\item Vector space axioms.
\end{bullets}
}

\varmapStart
\var{U,W}{Subspaces of $V$.}
\var{U+W}{Algebraic sum.}
\varmapEnd

\WHICHFORMULA{
Formula 1 minimality of span.
}

\GOVERN{
\[
\mathrm{span}(U\cup W)\subseteq U+W\subseteq \mathrm{span}(U\cup W).
\]
}

\INPUTS{$U,W\le V$.}

\DERIVATION{
\begin{align*}
\text{Step 1:}\ &U\cup W\subseteq U+W\ \text{since }u=u+0,\ w=0+w.\\
&\Rightarrow \mathrm{span}(U\cup W)\subseteq U+W\ \text{by minimality}.\\
\text{Step 2:}\ &\text{Take }x\in U+W\Rightarrow x=u+w.\\
&\text{Then }x\in \mathrm{span}(U\cup W)\ \text{as a linear combination}.\\
&\Rightarrow U+W\subseteq \mathrm{span}(U\cup W).\\
\text{Conclude:}\ &\mathrm{span}(U\cup W)=U+W.
\end{align*}
}

\RESULT{
Equality holds: the span of the union is precisely the algebraic sum.
}

\UNITCHECK{
Inclusions are exact; both sets are subspaces containing $U\cup W$.
}

\EDGECASES{
\begin{bullets}
\item If $U\subseteq W$, then $U+W=W$ and $\mathrm{span}(U\cup W)=W$.
\item If $U\cap W=\{0\}$, then $U+W$ is a direct sum.
\end{bullets}
}

\ALTERNATE{
Constructively show any finite combination of vectors from $U$ and $W$
can be regrouped into $u+w$ by closure of subspaces.
}

\VALIDATION{
\begin{bullets}
\item Check both contain $U$ and $W$ and are subspaces.
\end{bullets}
}

\INTUITION{
All mixtures using vectors from either subspace reduce to one vector
from each and added together.
}

\CANONICAL{
\begin{bullets}
\item Span as minimal subspace is the glue forming the sum.
\end{bullets}
}

\ProblemPage{8}{Proof-Style: Adding a Spanned Vector Does Not Enlarge Span}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
If $u\in\mathrm{span}(S)$, then $\mathrm{span}(S\cup\{u\})=
\mathrm{span}(S)$.

\PROBLEM{
Use minimality of span and representation of $u$ as a combination of
$S$ to show equality.
}

\MODEL{
\[
u=\sum_{i=1}^k \alpha_i s_i,\ s_i\in S.
\]
}

\ASSUMPTIONS{
\begin{bullets}
\item Vector space axioms.
\end{bullets}
}

\varmapStart
\var{S}{Generating set.}
\var{u}{Vector in $\mathrm{span}(S)$.}
\varmapEnd

\WHICHFORMULA{
Formula 1 minimality and closure of span.
}

\GOVERN{
\[
\mathrm{span}(S)\subseteq \mathrm{span}(S\cup\{u\})\ \text{and}\ 
u\in \mathrm{span}(S)\Rightarrow \mathrm{span}(S\cup\{u\})\subseteq
\mathrm{span}(S).
\]
}

\INPUTS{$S\subseteq V$, $u\in\mathrm{span}(S)$.}

\DERIVATION{
\begin{align*}
\text{Step 1:}\ &\mathrm{span}(S)\subseteq \mathrm{span}(S\cup\{u\})
\ \text{by monotonicity}.\\
\text{Step 2:}\ &u=\sum_{i=1}^k \alpha_i s_i\ \text{with }s_i\in S.\\
&\Rightarrow u\in \mathrm{span}(S).\\
\text{Step 3:}\ &\text{Any linear combination of }S\cup\{u\}\\
&=\sum \beta_i s_i+\gamma u
=\sum \beta_i s_i+\gamma\sum \alpha_i s_i\\
&=\sum (\beta_i+\gamma\alpha_i) s_i\in \mathrm{span}(S).\\
&\Rightarrow \mathrm{span}(S\cup\{u\})\subseteq \mathrm{span}(S).
\end{align*}
}

\RESULT{
$\mathrm{span}(S\cup\{u\})=\mathrm{span}(S)$.
}

\UNITCHECK{
Structural set equality verified by inclusions.
}

\EDGECASES{
\begin{bullets}
\item If $u\notin\mathrm{span}(S)$, the span strictly enlarges.
\item If $S=\varnothing$, adding $u=0$ does not enlarge span.
\end{bullets}
}

\ALTERNATE{
Use the fact that spans are subspaces and the minimality of
$\mathrm{span}(S)$ containing $S\cup\{u\}$.
}

\VALIDATION{
\begin{bullets}
\item Test on concrete $S$ and $u$ that is a combination of $S$.
\end{bullets}
}

\INTUITION{
Adding a recipe you can already cook adds nothing new to your menu.
}

\CANONICAL{
\begin{bullets}
\item Redundant generators do not increase span dimension.
\end{bullets}
}

\ProblemPage{9}{Combo: Geometry of Lines and Planes via Span}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
Describe the line $L=\{(1,2,3)+t(1,-1,0): t\in\mathbb{R}\}$ and the plane
$P=\{s(1,0,1)+t(0,1,1): s,t\in\mathbb{R}\}$ through the lens of span.
Find $L\cap P$.

\PROBLEM{
Interpret line and plane as translates of spans and compute the
intersection by solving for membership.
}

\MODEL{
\[
L=(1,2,3)+\mathrm{span}\{(1,-1,0)\},\quad
P=\mathrm{span}\{(1,0,1),(0,1,1)\}.
\]
}

\ASSUMPTIONS{
\begin{bullets}
\item Work in $\mathbb{R}^3$.
\item Solve linear systems exactly.
\end{bullets}
}

\varmapStart
\var{d}{Direction of line: $(1,-1,0)$.}
\var{p_1,p_2}{Plane generators.}
\var{x}{Coefficients for plane combination.}
\var{t}{Parameter for line.}
\varmapEnd

\WHICHFORMULA{
Formula 2 for membership in a span and Formula 1 for span structure.
}

\GOVERN{
\[
(1,2,3)+t(1,-1,0)=x_1(1,0,1)+x_2(0,1,1).
\]
}

\INPUTS{$d=(1,-1,0)$, $p_1=(1,0,1)$, $p_2=(0,1,1)$.}

\DERIVATION{
\begin{align*}
\text{Step 1:}\ &(1+t,2-t,3)=(x_1, x_2, x_1+x_2).\\
\text{Step 2:}\ &\text{Equate components: }x_1=1+t,\ x_2=2-t,\\
&x_1+x_2=3\ \text{holds automatically}.\\
\text{Step 3:}\ &\text{All }t\in\mathbb{R}\ \text{work}\Rightarrow L\subseteq P.\\
\text{Step 4:}\ &\text{Thus }L\cap P=L\ \text{(entire line).}
\end{align*}
}

\RESULT{
$L$ is contained in $P$; the intersection is the whole line $L$.
}

\UNITCHECK{
The plane contains both $(1,2,3)$ and direction $(1,-1,0)$ as
combinations: $(1,2,3)=(1,0,1)+(0,1,1)$, $(1,-1,0)=(1,0,1)-(0,1,1)$.
}

\EDGECASES{
\begin{bullets}
\item If direction were not in the plane span, intersection could be a
single point or empty (for affine vs. linear plane through origin).
\end{bullets}
}

\ALTERNATE{
Write $P$ as solutions to $x_3=x_1+x_2$ and check that every point on
$L$ satisfies this equation.
}

\VALIDATION{
\begin{bullets}
\item Substitute general point on $L$ into plane equation $z=x+y$.
\end{bullets}
}

\INTUITION{
A line lies in a plane if both its direction and a point lie in the
plane or its affine translate; here both align by span relations.
}

\CANONICAL{
\begin{bullets}
\item Lines and planes are spans of one and two independent vectors.
\end{bullets}
}

\ProblemPage{10}{Combo: Null Space, Column Space, and Coordinate Uniqueness}
\textbf{CANONICAL MATHEMATICAL STATEMENT.}
Given $A=\begin{bmatrix}1&2&0\\0&1&1\\1&3&1\end{bmatrix}$, find a basis
for $\mathrm{Col}(A)$ and determine whether coefficients expressing
$b=(2,3,5)^\top$ are unique.

\PROBLEM{
Extract pivot columns for a basis and examine the null space to decide
uniqueness of coefficients in the span representation.
}

\MODEL{
\[
A=[a_1\ a_2\ a_3],\quad \mathcal{B}=\{\text{pivot columns of }A\},\quad
\ker(A).
\]
}

\ASSUMPTIONS{
\begin{bullets}
\item Real arithmetic, exact elimination.
\end{bullets}
}

\varmapStart
\var{A}{$3\times 3$ matrix.}
\var{\mathcal{B}}{Basis of column space.}
\var{b}{Target vector.}
\var{x}{Coefficient vector.}
\varmapEnd

\WHICHFORMULA{
Formula 3 for basis and Formula 4 for uniqueness via independence
equivalently $\ker(A)=\{0\}$.
}

\GOVERN{
\[
R=\mathrm{RREF}(A),\ \text{pivots}\Rightarrow \mathcal{B};\quad
\ker(A)=\{0\}\ \Leftrightarrow\ \text{unique coefficients}.
\]
}

\INPUTS{$A$ and $b$ as above.}

\DERIVATION{
\begin{align*}
\text{Step 1 (RREF):}\ &
A\to \begin{bmatrix}1&0&-2\\0&1&1\\0&0&0\end{bmatrix}.\
\text{Pivots }1,2.\\
&\Rightarrow \mathcal{B}=\{a_1,a_2\},\ \dim\mathrm{Col}(A)=2.\\
\text{Step 2 (Membership):}\ &[A\mid b]\to
\begin{bmatrix}1&0&-2&2\\0&1&1&3\\0&0&0&0\end{bmatrix}.\\
&x_3\ \text{free}=:t,\ x_1=2+2t,\ x_2=3-t.\\
&\Rightarrow b\in \mathrm{Col}(A).\\
\text{Step 3 (Uniqueness):}\ &\ker(A)\ne\{0\}\ \text{since }x_3\ \text{free}.\\
&\Rightarrow \text{non-unique coefficients; nullity }1.
\end{align*}
}

\RESULT{
Basis $\{a_1,a_2\}$, and $b$ is in the span with infinitely many
representations parameterized by $t$. Coefficients are not unique.
}

\UNITCHECK{
Rank $2$ and nullity $1$ consistent with $n=3$.
}

\EDGECASES{
\begin{bullets}
\item If $A$ were full rank, coefficients would be unique.
\item If $b\notin\mathrm{Col}(A)$, no representation exists.
\end{bullets}
}

\ALTERNATE{
Express $a_3=2a_1-a_2$ from RREF and substitute to eliminate $a_3$.
}

\VALIDATION{
\begin{bullets}
\item Check $A(2+2t,3-t,t)^\top=b$ for any $t$.
\item Verify $A(2,3,0)^\top=b$ and $A(4,2,1)^\top=b$.
\end{bullets}
}

\INTUITION{
A redundant generator creates a free parameter in the representation.
}

\CANONICAL{
\begin{bullets}
\item Uniqueness $\iff$ independence $\iff$ trivial null space.
\end{bullets}
}

\section{Coding Demonstrations}

\CodeDemoPage{Span Membership and Coefficient Recovery via RREF}
\PROBLEM{
Given generators as columns of $A$ and target $b$, decide if $b$ lies in
$\mathrm{span}(A)$ and, if so, return one coefficient vector $x$
satisfying $Ax=b$. Implements Formula 2 deterministically.
}

\API{
\begin{bullets}
\item \inlinecode{def read_input(s) -> tuple}: parse m,n,A,b.
\item \inlinecode{def rref_aug(A,b) -> tuple}: RREF of [A|b].
\item \inlinecode{def solve_case(A,b) -> tuple}: consistency and x.
\item \inlinecode{def validate() -> None}: self-tests.
\item \inlinecode{def main() -> None}: run tests and demo.
\end{bullets}
}

\INPUTS{
$m,n\in\mathbb{N}$, matrix $A\in\mathbb{R}^{m\times n}$ as list of
lists, $b\in\mathbb{R}^m$ as list.
}

\OUTPUTS{
Boolean for membership and a coefficient vector when consistent; otherwise
an empty list. The solution corresponds to a basic solution with free
vars set to zero.
}

\FORMULA{
\[
b\in\mathrm{Col}(A)\iff \mathrm{rank}(A)=\mathrm{rank}([A\mid b]).
\]
}

\textbf{SOLUTION A — From Scratch (Mathematically Explicit Implementation)}
\begin{codepy}
from typing import List, Tuple

def read_input(s: str) -> Tuple[int, int, List[List[float]], List[float]]:
    it = iter(s.split())
    m, n = int(next(it)), int(next(it))
    A = [[float(next(it)) for _ in range(n)] for _ in range(m)]
    b = [float(next(it)) for _ in range(m)]
    return m, n, A, b

def rref_aug(A: List[List[float]], b: List[float]):
    m, n = len(A), len(A[0]) if A else 0
    M = [row[:] + [b[i]] for i, row in enumerate(A)]
    r = c = 0
    pivots = [-1] * m
    while r < m and c < n:
        p = max(range(r, m), key=lambda i: abs(M[i][c]))
        if abs(M[p][c]) < 1e-12:
            c += 1
            continue
        M[r], M[p] = M[p], M[r]
        piv = M[r][c]
        for j in range(c, n + 1):
            M[r][j] /= piv
        for i in range(m):
            if i != r:
                fac = M[i][c]
                if abs(fac) > 0:
                    for j in range(c, n + 1):
                        M[i][j] -= fac * M[r][j]
        pivots[r] = c
        r += 1
        c += 1
    rankA = sum(1 for i in range(m) if pivots[i] != -1)
    inconsistent = any(
        all(abs(M[i][j]) < 1e-10 for j in range(n)) and abs(M[i][n]) > 1e-10
        for i in range(m)
    )
    return M, pivots, rankA, inconsistent

def solve_case(A: List[List[float]], b: List[float]):
    M, pivots, rankA, inconsistent = rref_aug(A, b)
    m, n = len(A), len(A[0]) if A else 0
    if inconsistent:
        return False, []
    x = [0.0] * n
    for i in range(m):
        c = pivots[i]
        if c != -1:
            x[c] = M[i][n]
    return True, x

def validate():
    m, n, A, b = read_input("3 2 1 2 2 5 3 8 3 7 11")
    ok, x = solve_case(A, b)
    assert ok and abs(x[0] - 1) < 1e-9 and abs(x[1] - 1) < 1e-9
    m, n, A, b = read_input("2 2 1 0 0 1 1 1")
    ok, x = solve_case(A, b)
    assert ok and abs(x[0] - 1) < 1e-9 and abs(x[1] - 1) < 1e-9
    m, n, A, b = read_input("2 2 1 0 0 0 1 1")
    ok, x = solve_case(A, b)
    assert not ok

def main():
    validate()
    print("All tests passed.")

if __name__ == "__main__":
    main()
\end{codepy}

\textbf{SOLUTION B — Library-Based (Validated Computational Shortcut)}
\begin{codepy}
import numpy as np

def read_input(s: str):
    it = iter(s.split())
    m, n = int(next(it)), int(next(it))
    A = np.array([[float(next(it)) for _ in range(n)] for _ in range(m)],
                 dtype=float)
    b = np.array([float(next(it)) for _ in range(m)], dtype=float)
    return m, n, A, b

def solve_case(A: np.ndarray, b: np.ndarray):
    x, resid, rank, s = np.linalg.lstsq(A, b, rcond=None)
    ok = np.allclose(A @ x, b, atol=1e-9)
    return bool(ok), x.tolist()

def validate():
    m, n, A, b = read_input("3 2 1 2 2 5 3 8 3 7 11")
    ok, x = solve_case(A, b)
    assert ok and np.allclose(x, [1, 1])
    m, n, A, b = read_input("2 2 1 0 0 0 1 1")
    ok, x = solve_case(A, b)
    assert not ok

def main():
    validate()
    print("All tests passed.")

if __name__ == "__main__":
    main()
\end{codepy}

\COMPLEXITY{
From-scratch RREF: time $\mathcal{O}(mn\min\{m,n\})$, space
$\mathcal{O}(mn)$. Library: $\mathcal{O}(mn\min\{m,n\})$ time via SVD or
QR, space $\mathcal{O}(mn)$.
}

\FAILMODES{
\begin{bullets}
\item Near singular columns cause numerical instability; use tolerances.
\item Inconsistent systems must be detected by augmented row of form
$[0\ \cdots\ 0\mid \ne 0]$.
\item Empty matrices: handle $m=0$ or $n=0$ gracefully.
\end{bullets}
}

\STABILITY{
\begin{bullets}
\item Pivoting reduces growth; use partial pivoting as implemented.
\item Tolerance-based zero detection avoids false pivots.
\end{bullets}
}

\VALIDATION{
\begin{bullets}
\item Compare from-scratch with NumPy \inlinecode{lstsq}.
\item Unit asserts on exact solvable small systems.
\end{bullets}
}

\RESULT{
Both implementations correctly detect membership and recover
coefficients when consistent; results agree within numeric tolerances.
}

\EXPLANATION{
Solving $Ax=b$ yields coefficients for the linear combination expressing
$b$ in the span of columns of $A$, directly implementing Formula 2.
}

\CodeDemoPage{Basis of Column Space via Pivot Columns}
\PROBLEM{
Given $A$, compute a basis for $\mathrm{Col}(A)$ by identifying pivot
columns and return their indices and vectors, implementing Formula 3.
}

\API{
\begin{bullets}
\item \inlinecode{def rref(A) -> tuple}: RREF and pivot indices.
\item \inlinecode{def basis_cols(A) -> tuple}: indices and basis cols.
\item \inlinecode{def validate() -> None}: tests on known matrices.
\item \inlinecode{def main() -> None}: run tests.
\end{bullets}
}

\INPUTS{
$A\in\mathbb{R}^{m\times n}$ as list of lists (from-scratch) or NumPy
array (library).
}

\OUTPUTS{
List of pivot indices and corresponding original columns forming a
basis.
}

\FORMULA{
\[
\mathcal{B}=\{a_{j_1},\dots,a_{j_r}\}\ \text{with }j_i\ \text{pivot
columns in RREF}(A).
\]
}

\textbf{SOLUTION A — From Scratch (Mathematically Explicit Implementation)}
\begin{codepy}
from typing import List, Tuple

def rref(A: List[List[float]]):
    m, n = len(A), len(A[0]) if A else 0
    M = [row[:] for row in A]
    r = c = 0
    pivots = []
    while r < m and c < n:
        p = max(range(r, m), key=lambda i: abs(M[i][c]))
        if abs(M[p][c]) < 1e-12:
            c += 1
            continue
        M[r], M[p] = M[p], M[r]
        piv = M[r][c]
        for j in range(c, n):
            M[r][j] /= piv
        for i in range(m):
            if i != r:
                fac = M[i][c]
                if abs(fac) > 0:
                    for j in range(c, n):
                        M[i][j] -= fac * M[r][j]
        pivots.append(c)
        r += 1
        c += 1
    return M, pivots

def basis_cols(A: List[List[float]]):
    _, piv = rref(A)
    cols = list(zip(*A))
    basis = [list(cols[j]) for j in piv]
    return piv, basis

def validate():
    A = [[1,2,3],[0,1,4],[1,3,7]]
    piv, basis = basis_cols(A)
    assert piv == [0,1]
    assert basis[0] == [1,0,1] and basis[1] == [2,1,3]
    B = [[1,0,1],[0,1,1],[0,0,0]]
    piv, basis = basis_cols(B)
    assert piv == [0,1]

def main():
    validate()
    print("All tests passed.")

if __name__ == "__main__":
    main()
\end{codepy}

\textbf{SOLUTION B — Library-Based (Validated Computational Shortcut)}
\begin{codepy}
import numpy as np

def basis_cols(A: np.ndarray):
    Q, R = np.linalg.qr(A, mode="reduced")
    tol = 1e-10
    piv = [j for j in range(R.shape[1])
           if j < R.shape[0] and abs(R[j, j]) > tol]
    basis = [A[:, j].tolist() for j in piv]
    return piv, basis

def validate():
    A = np.array([[1,2,3],[0,1,4],[1,3,7]], dtype=float)
    piv, basis = basis_cols(A)
    assert piv == [0,1]
    B = np.array([[1,0,1],[0,1,1],[0,0,0]], dtype=float)
    piv, basis = basis_cols(B)
    assert piv == [0,1]

def main():
    validate()
    print("All tests passed.")

if __name__ == "__main__":
    main()
\end{codepy}

\COMPLEXITY{
From-scratch RREF: $\mathcal{O}(mn\min\{m,n\})$ time, $\mathcal{O}(mn)$
space. Library QR: $\mathcal{O}(mn^2)$ for $m\ge n$.
}

\FAILMODES{
\begin{bullets}
\item Near-zero diagonals in $R$ require tolerance; pivot indices may
shift with permutations.
\item Zero matrix: pivots list empty; basis is empty set.
\end{bullets}
}

\STABILITY{
\begin{bullets}
\item Partial pivoting stabilizes RREF; QR is numerically robust for
rank decisions with a tolerance.
\end{bullets}
}

\VALIDATION{
\begin{bullets}
\item Cross-check pivot indices from both methods on test matrices.
\item Verify non-pivot columns are combinations using RREF relations.
\end{bullets}
}

\RESULT{
Both variants correctly return pivot columns as a basis for the column
space in agreement with Formula 3.
}

\EXPLANATION{
Pivot columns in RREF identify independent directions; selecting those
columns in the original matrix yields a basis for the span.
}

\section{Applied Domains — Detailed End-to-End Scenarios}

\DomainPage{Machine Learning}
\SCENARIO{
Determine if a target vector $y$ is exactly representable by a linear
model with features $X$, i.e., $y\in\mathrm{span}$ of columns of $X$,
and recover coefficients if so.
}
\ASSUMPTIONS{
\begin{bullets}
\item Deterministic synthetic data; no noise for exact span tests.
\item Real-valued features; columns possibly dependent.
\end{bullets}
}
\WHICHFORMULA{
Formula 2: $y\in\mathrm{Col}(X)\iff X\beta=y$. Formula 3: pivot columns
provide a minimal feature set spanning $y$.
}
\varmapStart
\var{X}{Design matrix $(n,d)$ with columns as features.}
\var{y}{Target vector in $\mathbb{R}^n$.}
\var{\beta}{Coefficient vector in $\mathbb{R}^d$.}
\varmapEnd
\PIPELINE{
\begin{bullets}
\item Generate $X$ with dependent columns and construct $y=X\beta^\star$.
\item Test span membership and compute one $\beta$.
\item Extract pivot columns as a minimal spanning feature set.
\end{bullets}
}
\textbf{Implementation (From Scratch)}
\begin{codepy}
import numpy as np

def generate():
    np.random.seed(0)
    n, d = 6, 4
    X = np.zeros((n, d))
    X[:, 0] = np.linspace(0, 5, n)
    X[:, 1] = 1.0
    X[:, 2] = X[:, 0] + X[:, 1]  # dependent: col2 = col0 + col1
    X[:, 3] = 2 * X[:, 0]        # dependent: col3 = 2*col0
    beta_star = np.array([2.0, 1.0, 0.0, 0.0])
    y = X @ beta_star
    return X, y

def rref_aug(A, b):
    A = A.astype(float)
    m, n = A.shape
    M = np.hstack([A, b.reshape(-1, 1)])
    r = c = 0
    piv = [-1] * m
    while r < m and c < n:
        p = r + np.argmax(np.abs(M[r:, c]))
        if abs(M[p, c]) < 1e-12:
            c += 1
            continue
        M[[r, p]] = M[[p, r]]
        M[r, c:] = M[r, c:] / M[r, c]
        for i in range(m):
            if i != r:
                M[i, c:] -= M[i, c] * M[r, c:]
        piv[r] = c
        r += 1
        c += 1
    inconsistent = any(
        np.allclose(M[i, :n], 0) and not np.isclose(M[i, n], 0)
        for i in range(m)
    )
    x = np.zeros(n)
    for i in range(m):
        if piv[i] != -1:
            x[piv[i]] = M[i, n]
    return not inconsistent, x

def pivot_cols(A):
    A = A.astype(float)
    m, n = A.shape
    M = A.copy()
    r = c = 0
    piv = []
    while r < m and c < n:
        p = r + np.argmax(np.abs(M[r:, c]))
        if abs(M[p, c]) < 1e-12:
            c += 1
            continue
        M[[r, p]] = M[[p, r]]
        piv.append(c)
        fac = M[r, c]
        M[r, c:] /= fac
        for i in range(m):
            if i != r:
                M[i, c:] -= M[i, c] * M[r, c:]
        r += 1
        c += 1
    return piv

def main():
    X, y = generate()
    ok, beta = rref_aug(X, y)
    print("Representable:", ok)
    print("One beta:", np.round(beta, 3).tolist())
    piv = pivot_cols(X)
    print("Pivot columns:", piv)

if __name__ == "__main__":
    main()
\end{codepy}
\textbf{Implementation (Library Version)}
\begin{codepy}
import numpy as np

def main():
    np.random.seed(0)
    X = np.column_stack([
        np.linspace(0, 5, 6),
        np.ones(6),
        np.linspace(0, 5, 6) + 1.0,
        2 * np.linspace(0, 5, 6)
    ])
    y = X @ np.array([2.0, 1.0, 0.0, 0.0])
    beta, *_ = np.linalg.lstsq(X, y, rcond=None)
    ok = np.allclose(X @ beta, y)
    print("Representable:", bool(ok))
    print("beta:", np.round(beta, 3).tolist())

if __name__ == "__main__":
    main()
\end{codepy}
\METRICS{
Boolean exact representability and list of pivot columns; compare
$X\beta$ to $y$ with a tolerance.
}
\INTERPRET{
If $y$ lies in the feature span, a perfect linear model exists; pivot
columns identify a minimal feature subset providing the same fit.
}
\NEXTSTEPS{
Handle noisy $y$ by orthogonal projection (least squares) and analyze
approximate span with thresholds.
}

\DomainPage{Quantitative Finance}
\SCENARIO{
Check if an asset return series $r$ lies in the span of factor returns
$F$ (exact $k$-factor model), and extract a minimal set of factors that
span $r$.
}
\ASSUMPTIONS{
\begin{bullets}
\item Returns are deterministic inputs here; exact factor replication is
tested.
\item Factors may be collinear; select pivot factors.
\end{bullets}
}
\WHICHFORMULA{
Formula 2: $r\in\mathrm{span}(F)$ iff $Fb=r$. Formula 3: pivot factor
columns form a basis.
}
\varmapStart
\var{F}{Matrix $(n,k)$ of factor returns over $n$ periods.}
\var{r}{Asset return vector in $\mathbb{R}^n$.}
\var{b}{Factor loadings.}
\varmapEnd
\PIPELINE{
\begin{bullets}
\item Build $F$ with dependent factors and synthetic $r=Fb^\star$.
\item Test membership and recover one loading vector.
\item Identify pivot factors forming a basis for $\mathrm{span}(F)$.
\end{bullets}
}
\textbf{Implementation (Full Pipeline)}
\begin{codepy}
import numpy as np

def generate():
    np.random.seed(1)
    n = 8
    f1 = np.linspace(-1, 1, n)
    f2 = np.ones(n)
    f3 = f1 + f2  # dependent factor
    F = np.column_stack([f1, f2, f3])
    b_true = np.array([0.5, 0.2, 0.0])
    r = F @ b_true
    return F, r

def rref_aug(A, b):
    A = A.astype(float)
    m, n = A.shape
    M = np.hstack([A, b.reshape(-1, 1)])
    r = c = 0
    piv = [-1] * m
    while r < m and c < n:
        p = r + np.argmax(np.abs(M[r:, c]))
        if abs(M[p, c]) < 1e-12:
            c += 1
            continue
        M[[r, p]] = M[[p, r]]
        M[r, c:] = M[r, c:] / M[r, c]
        for i in range(m):
            if i != r:
                M[i, c:] -= M[i, c] * M[r, c:]
        piv[r] = c
        r += 1
        c += 1
    inconsistent = any(
        np.allclose(M[i, :n], 0) and not np.isclose(M[i, n], 0)
        for i in range(m)
    )
    x = np.zeros(n)
    for i in range(m):
        if piv[i] != -1:
            x[piv[i]] = M[i, n]
    return not inconsistent, x

def pivot_cols(A):
    A = A.astype(float)
    m, n = A.shape
    M = A.copy()
    r = c = 0
    piv = []
    while r < m and c < n:
        p = r + np.argmax(np.abs(M[r:, c]))
        if abs(M[p, c]) < 1e-12:
            c += 1
            continue
        M[[r, p]] = M[[p, r]]
        piv.append(c)
        fac = M[r, c]
        M[r, c:] /= fac
        for i in range(m):
            if i != r:
                M[i, c:] -= M[i, c] * M[r, c:]
        r += 1
        c += 1
    return piv

def main():
    F, r = generate()
    ok, b = rref_aug(F, r)
    print("Exact k-factor model:", ok)
    print("One loading:", np.round(b, 3).tolist())
    piv = pivot_cols(F)
    print("Pivot factors:", piv)

if __name__ == "__main__":
    main()
\end{codepy}
\METRICS{
Exact replication flag and pivot indices; verify $Fb=r$ exactly.
}
\INTERPRET{
Exact span membership indicates the asset is a linear combination of the
factors; pivot factors reveal essential drivers.
}
\NEXTSTEPS{
Incorporate noise and estimate $b$ by least squares; test residual span
to detect missing factors.
}

\DomainPage{Deep Learning}
\SCENARIO{
In a single-layer linear network $\hat{y}=Xw$, check if training labels
$y$ lie in the span of features $X$ so that zero training error is
achievable without bias.
}
\ASSUMPTIONS{
\begin{bullets}
\item No bias term; features may be dependent.
\item Deterministic synthetic data.
\end{bullets}
}
\WHICHFORMULA{
Formula 2: zero loss possible iff $y\in\mathrm{span}(X)$.
}
\varmapStart
\var{X}{Feature matrix $(n,d)$.}
\var{w}{Weights in $\mathbb{R}^d$.}
\var{y}{Labels in $\mathbb{R}^n$.}
\varmapEnd
\PIPELINE{
\begin{bullets}
\item Generate $X$ with dependent columns and set $y=Xw^\star$.
\item Solve $Xw=y$; report exact fit feasibility.
\item Optionally reduce features to a spanning basis.
\end{bullets}
}
\textbf{Implementation (End-to-End)}
\begin{codepy}
import numpy as np

def generate():
    np.random.seed(2)
    n, d = 10, 3
    x1 = np.linspace(0, 1, n)
    x2 = np.ones(n)
    x3 = x1 + x2
    X = np.column_stack([x1, x2, x3])
    w_true = np.array([1.5, -0.5, 0.0])
    y = X @ w_true
    return X, y

def exact_fit(X, y):
    w, *_ = np.linalg.lstsq(X, y, rcond=None)
    return bool(np.allclose(X @ w, y)), w

def main():
    X, y = generate()
    ok, w = exact_fit(X, y)
    print("Zero training error possible:", ok)
    print("One weight vector:", np.round(w, 3).tolist())

if __name__ == "__main__":
    main()
\end{codepy}
\METRICS{
Exact fit boolean and a weight vector achieving it; check residual norm.
}
\INTERPRET{
If $y$ is in the span of features, a linear layer can interpolate
training labels perfectly; dependence does not hinder exact fit but
induces non-uniqueness.
}
\NEXTSTEPS{
Add bias or regularization; evaluate generalization and consider feature
orthogonalization for numerical stability.
}

\DomainPage{Kaggle / Data Analytics}
\SCENARIO{
Perform feature de-duplication by identifying a basis of the feature
span and removing dependent columns to reduce dimensionality without
losing linear information.
}
\ASSUMPTIONS{
\begin{bullets}
\item Numeric dataset; exact duplicates and linear dependencies exist.
\item Deterministic synthetic data for reproducibility.
\end{bullets}
}
\WHICHFORMULA{
Formula 3: pivot columns form a basis of the feature span.
}
\varmapStart
\var{X}{Data matrix $(n,d)$ with candidate features.}
\var{\mathcal{B}}{Set of basis feature indices.}
\varmapEnd
\PIPELINE{
\begin{bullets}
\item Build $X$ with columns containing linear dependencies.
\item Compute pivot columns as a basis; drop others.
\item Report reduced feature set maintaining the same span.
\end{bullets}
}
\textbf{Implementation (Complete EDA Pipeline)}
\begin{codepy}
import numpy as np
import pandas as pd

def create_df():
    np.random.seed(3)
    n = 12
    A = np.linspace(0, 11, n)
    B = np.ones(n)
    C = A + B
    D = 2 * A
    E = A - B
    df = pd.DataFrame({"A": A, "B": B, "C": C, "D": D, "E": E})
    return df

def pivot_cols(A):
    A = A.astype(float)
    m, n = A.shape
    M = A.copy()
    r = c = 0
    piv = []
    while r < m and c < n:
        p = r + np.argmax(np.abs(M[r:, c]))
        if abs(M[p, c]) < 1e-12:
            c += 1
            continue
        M[[r, p]] = M[[p, r]]
        piv.append(c)
        fac = M[r, c]
        M[r, c:] /= fac
        for i in range(m):
            if i != r:
                M[i, c:] -= M[i, c] * M[r, c:]
        r += 1
        c += 1
    return piv

def main():
    df = create_df()
    X = df.values
    piv = pivot_cols(X)
    cols = df.columns.tolist()
    basis_cols = [cols[j] for j in piv]
    print("Basis features:", basis_cols)

if __name__ == "__main__":
    main()
\end{codepy}
\METRICS{
List of retained features; size equals the rank of $X$; confirm that
dropped features are linear combinations of retained ones.
}
\INTERPRET{
The reduced feature set spans the same column space, preserving all
linear information for downstream linear models.
}
\NEXTSTEPS{
Scale features, detect near-dependencies with tolerances, and apply PCA
to further reduce dimensionality while preserving variance.
}

\end{document}