% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Probability of a Two Boxes Having The Same Number of Distinct Balls}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given \texttt{2n} balls of \texttt{k} distinct colors. You will be given an integer array \texttt{balls} of size \texttt{k} where \texttt{balls[i]} is the number of balls of color \texttt{i}.\\
All the balls will be \textbf{shuffled uniformly at random}, then we will distribute the first \texttt{n} balls to the first box and the remaining \texttt{n} balls to the other box (Please read the explanation of the second example carefully).\\
Please note that the two boxes are considered different. For example, if we have two balls of colors \texttt{a} and \texttt{b}, and two boxes \texttt{[]} and \texttt{()}, then the distribution \texttt{[a] (b)} is considered different than the distribution \texttt{[b] (a)} (Please read the explanation of the first example carefully).\\
Return \emph{the probability} that the two boxes have the same number of distinct balls. Answers within $10^{-5}$ of the actual value will be accepted as correct.\\[4pt]
\textbf{Example 1:}\\
\textbf{Input:} \texttt{balls = [1,1]}\\
\textbf{Output:} \texttt{1.00000}\\
\textbf{Explanation:} Only 2 ways to divide the balls equally:
\begin{bullets}
\item A ball of color 1 to box 1 and a ball of color 2 to box 2
\item A ball of color 2 to box 1 and a ball of color 1 to box 2
\end{bullets}
In both ways, the number of distinct colors in each box is equal. The probability is $2/2 = 1$.\\[4pt]
\textbf{Example 2:}\\
\textbf{Input:} \texttt{balls = [2,1,1]}\\
\textbf{Output:} \texttt{0.66667}\\
\textbf{Explanation:} We have the set of balls \texttt{[1, 1, 2, 3]}. This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. $1/12$):\\
\texttt{[1,1 / 2,3]}, \texttt{[1,1 / 3,2]}, \texttt{[1,2 / 1,3]}, \texttt{[1,2 / 3,1]}, \texttt{[1,3 / 1,2]}, \texttt{[1,3 / 2,1]}, \texttt{[2,1 / 1,3]}, \texttt{[2,1 / 3,1]}, \texttt{[2,3 / 1,1]}, \texttt{[3,1 / 1,2]}, \texttt{[3,1 / 2,1]}, \texttt{[3,2 / 1,1]}.\\
After that, we add the first two balls to the first box and the second two balls to the second box. We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box. Probability is $8/12 = 0.66667$.\\[4pt]
\textbf{Example 3:}\\
\textbf{Input:} \texttt{balls = [1,2,1,2]}\\
\textbf{Output:} \texttt{0.60000}\\
\textbf{Explanation:} The set of balls is \texttt{[1, 2, 2, 3, 4, 4]}. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box. Probability $= 108 / 180 = 0.6$.\\[4pt]
\textbf{Constraints:}
\begin{bullets}
\item \texttt{1 <= balls.length <= 8}
\item \texttt{1 <= balls[i] <= 6}
\item \texttt{sum(balls)} is even.
\end{bullets}}
\BREAKDOWN{Model the process as uniformly choosing a size-$n$ subset from $2n$ labeled balls. Enumerate all feasible splits of each color count between the two boxes; weight each split by the number of underlying labeled choices. Sum favorable weights where both boxes have the same count of distinct colors; divide by the total number of size-$n$ choices.}
\ELI{Pick $n$ balls at random for box 1; count how many colors appear in box 1 and box 2. The probability equals the fraction of choices where these distinct-color counts match.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode function \texttt{getProbability(self, balls: List[int]) -> float}. Here \texttt{balls} has length $k$ with $1 \le k \le 8$ and entries $1 \le \texttt{balls[i]} \le 6$. The sum $\sum \texttt{balls[i]}$ is even; let $2n$ denote the sum.}
\OUTPUTS{Return a Python \texttt{float} equal to the probability that the two ordered boxes each contain exactly $n$ balls and have the same number of distinct colors. An absolute error within $10^{-5}$ is accepted.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{[1,1]} $\rightarrow$ Output: \texttt{1.0}
\item Input: \texttt{[2,1,1]} $\rightarrow$ Output: \texttt{0.6666666667}
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let colors be indexed by $i \in \{1,\ldots,k\}$ with $b_i = \texttt{balls[i]}$. There are $2n=\sum_i b_i$ total balls. A random shuffle then split into the first $n$ and the last $n$ positions is equivalent to choosing a uniformly random size-$n$ subset of the $2n$ labeled balls for box 1. For a split vector $\boldsymbol{x}=(x_1,\ldots,x_k)$ with $0 \le x_i \le b_i$ and $\sum_i x_i = n$, define $y_i=b_i-x_i$. Box 1 contains $x_i$ balls of color $i$, box 2 contains $y_i$.}
\varmapStart
\var{b_i}{count of balls of color $i$}
\var{x_i}{balls of color $i$ in box 1}
\var{y_i}{balls of color $i$ in box 2, $y_i=b_i-x_i$}
\var{n}{half the total balls, $n=\tfrac12\sum_i b_i$}
\var{k}{number of colors, $k=\texttt{len(balls)}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Weight}(\boldsymbol{x}) &= \prod_{i=1}^k \binom{b_i}{x_i},\quad \sum_{i=1}^k x_i = n,\ 0 \le x_i \le b_i,\\
D_1(\boldsymbol{x}) &= \bigl|\{i: x_i>0\}\bigr|,\quad D_2(\boldsymbol{x}) = \bigl|\{i: y_i>0\}\bigr|,\\
\mathsf{Den} &= \binom{2n}{n} = \sum_{\sum x_i=n}\ \prod_{i=1}^k \binom{b_i}{x_i},\\
\mathsf{Num} &= \sum_{\sum x_i=n,\ D_1(\boldsymbol{x})=D_2(\boldsymbol{x})}\ \prod_{i=1}^k \binom{b_i}{x_i},\\
\mathsf{Pr} &= \dfrac{\mathsf{Num}}{\mathsf{Den}}.
\end{aligned}
\]
}
\ASSUMPTIONS{Boxes are ordered; balls of the same color are indistinguishable for distinctness counting but are physically labeled for combinatorial choices. Uniform shuffle implies a uniform choice of a size-$n$ labeled subset.}
\INVARIANTS{
\begin{bullets}
\item $\sum_i x_i = n$ and $\sum_i y_i = n$ always hold.
\item $D_1(\boldsymbol{x})+D_2(\boldsymbol{x}) \le k$ with equality iff no color is entirely in a single box.
\item The total weight over all feasible $\boldsymbol{x}$ equals $\binom{2n}{n}$ by multivariate Vandermonde.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all feasible splits $\boldsymbol{x}$ with $\sum x_i=n$, compute the hypergeometric weight $\prod_i \binom{b_i}{x_i}$, and sum those where $D_1=D_2$. Divide by $\binom{2n}{n}$.}
\ASSUMPTIONS{No pruning; direct recursion over $k \le 8$ colors and $b_i \le 6$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $n=\tfrac12\sum b_i$ and denominator $\binom{2n}{n}$.
\item Depth-first enumerate $x_i \in [0,b_i]$ while tracking the running sum of chosen balls.
\item When the sum reaches $n$, check $D_1=D_2$ and add the weight $\prod_i \binom{b_i}{x_i}$ to the numerator.
\end{algosteps}
\COMPLEXITY{In the worst case explores $\prod_i (b_i+1) \le 7^8$ branches without pruning, which is high but still feasible for these constraints in Python with early-sum checks. Space is $O(k)$ recursion depth.}
\[
\begin{aligned}
T(k,\{b_i\}) &\approx \prod_{i=1}^k (b_i+1),\\
S(k) &= O(k).
\end{aligned}
\]
\CORRECTNESS{By the multivariate hypergeometric model, the probability that box 1 gets composition $\boldsymbol{x}$ is exactly $\prod_i \binom{b_i}{x_i}/\binom{2n}{n}$. Summing these probabilities over all $\boldsymbol{x}$ with $D_1=D_2$ yields the desired event probability.}
\EDGECASES{
\begin{bullets}
\item Single color: always probability $1.0$ when $b_1$ is even.
\item All $b_i=1$: $n=k/2$, any split with $n$ distinct colors in box 1 and $k-n$ in box 2 has $D_1=D_2=n$ if and only if $k=2n$; all choices are favorable.
\item Colors concentrated in one box: counted by $x_i=0$ or $x_i=b_i$, which changes distinct counts correctly.
\end{bullets}
}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
from math import comb

class Solution:
    def getProbability(self, balls: List[int]) -> float:
        total = sum(balls)
        n = total // 2
        k = len(balls)
        denom = comb(total, n)

        num = 0

        def dfs(i: int, taken: int, d1: int, d2: int, weight: int) -> None:
            nonlocal num
            if i == k:
                if taken == n and d1 == d2:
                    num += weight
                return
            bi = balls[i]
            # Try all xi from 0 to bi, respecting taken <= n
            for xi in range(bi + 1):
                if taken + xi > n:
                    continue
                nd1 = d1 + (1 if xi > 0 else 0)
                nd2 = d2 + (1 if bi - xi > 0 else 0)
                dfs(i + 1, taken + xi, nd1, nd2, weight * comb(bi, xi))

        dfs(0, 0, 0, 0, 1)
        return num / denom

# Basic checks from the prompt
s = Solution()
assert abs(s.getProbability([1, 1]) - 1.0) < 1e-12
assert abs(s.getProbability([2, 1, 1]) - (2.0 / 3.0)) < 1e-9
assert abs(s.getProbability([1, 2, 1, 2]) - 0.6) < 1e-9
\end{minted}
\VALIDATION{Matches the three examples exactly within floating error; handles trivial single-color cases, e.g., \texttt{[2]} returns \texttt{1.0}.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Enumeration with Pruning and Precomputed Combinations}
\WHICHFORMULA{Same hypergeometric summation, but prune infeasible branches early and precompute per-color binomial coefficients to avoid recomputation.}
\ASSUMPTIONS{Use remaining-balls feasibility: if current taken $>$ $n$ or taken plus all remaining capacities $<$ $n$, backtrack.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute \texttt{choose[i][x] = C(b\_i, x)} for all colors and $0 \le x \le b_i$.
\item Recurse by colors, carrying: taken sum, $D_1$, $D_2$, and accumulated weight.
\item Prune when taken $>$ $n$ or taken $+$ remaining\_max $<$ $n$.
\item On leaves with taken $=n$ and $D_1=D_2$, add the weight.
\end{algosteps}
\COMPLEXITY{Pruning reduces the explored states substantially from $\prod (b_i+1)$ to only those with $\sum x_i=n$. In practice for $k \le 8$, $b_i \le 6$, this is very fast.}
\[
\begin{aligned}
T &\approx \#\{\boldsymbol{x} \in \prod_i [0,b_i]: \sum x_i = n\} \ll \prod_i (b_i+1),\\
S &= O(k).
\end{aligned}
\]
\CORRECTNESS{Identical counting measure as Approach A; pruning does not change which leaves are evaluated. Precomputed binomials preserve exact integer weights.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from math import comb

class Solution:
    def getProbability(self, balls: List[int]) -> float:
        total = sum(balls)
        n = total // 2
        k = len(balls)

        # Precompute binomial coefficients per color
        choose = []
        for bi in balls:
            choose.append([comb(bi, x) for x in range(bi + 1)])

        # Precompute suffix sums of capacities to prune by remaining max
        suffix_cap = [0] * (k + 1)
        for i in range(k - 1, -1, -1):
            suffix_cap[i] = suffix_cap[i + 1] + balls[i]

        denom = comb(total, n)
        num = 0

        def dfs(i: int, taken: int, d1: int, d2: int, weight: int) -> None:
            nonlocal num
            # Prune infeasible
            if taken > n:
                return
            if taken + suffix_cap[i] < n:
                return
            if i == k:
                if taken == n and d1 == d2:
                    num += weight
                return
            bi = balls[i]
            max_take = min(bi, n - taken)
            for xi in range(max_take + 1):
                nd1 = d1 + (1 if xi > 0 else 0)
                nd2 = d2 + (1 if bi - xi > 0 else 0)
                dfs(i + 1, taken + xi, nd1, nd2, weight * choose[i][xi])

        dfs(0, 0, 0, 0, 1)
        return num / denom

# Checks
s = Solution()
assert abs(s.getProbability([1, 1]) - 1.0) < 1e-12
assert abs(s.getProbability([2, 1, 1]) - (2.0 / 3.0)) < 1e-9
assert abs(s.getProbability([1, 2, 1, 2]) - 0.6) < 1e-9
\end{minted}
\VALIDATION{Improved version returns the same results as baseline on the examples and runs faster on larger cases such as \texttt{[6,6,6,6]} due to pruning.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{DP over colors, tracking used balls and distinct-count difference}
\WHICHFORMULA{Dynamic programming that aggregates integer weights for all splits without explicit DFS. State $(s,\Delta)$ stores the total weight for using $s$ balls in box 1 and distinct-count difference $\Delta = D_1 - D_2$. The answer is $\text{dp}[n][0] / \binom{2n}{n}$.}
\ASSUMPTIONS{Colors are independent contributors to both the number of chosen balls and the distinct-count difference; transitions convolve by per-color choices $x \in [0,b_i]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $n=\tfrac12\sum b_i$. Precompute per-color binomials $\binom{b_i}{x}$ for $0 \le x \le b_i$.
\item Initialize a 2D DP array \texttt{dp[s][d]} of size $(n+1)\times(2k+1)$ with \texttt{dp[0][offset]} $=1$, where \texttt{offset = k}.
\item For each color $i$ and choice $x$:
  \begin{bullets}
  \item $s' = s + x$ must be $\le n$.
  \item $\Delta' = \Delta + \mathbf{1}[x>0] - \mathbf{1}[x<b_i]$.
  \item \texttt{next[s'][d']} $+= \texttt{dp[s][d]} \times \binom{b_i}{x}$.
  \end{bullets}
\item After processing all colors, numerator is \texttt{dp[n][offset]} and denominator is $\binom{2n}{n}$.
\end{algosteps}
\OPTIMALITY{The DP aggregates all split weights in $O\!\bigl(k \cdot n \cdot k \cdot \max b_i\bigr)$ time and $O(nk)$ space. It avoids recursion overhead and explores no infeasible states. This is tight up to a small constant factor for the given constraints.}
\COMPLEXITY{Let $B=\max b_i \le 6$.
\[
\begin{aligned}
T &\in O\!\big(k \cdot n \cdot (2k+1) \cdot (B+1)\big) = O(knkB),\\
S &\in O\!\big((n+1)\cdot(2k+1)\big).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from math import comb

class Solution:
    def getProbability(self, balls: List[int]) -> float:
        total = sum(balls)
        n = total // 2
        k = len(balls)

        # Precompute binomials per color
        choose = [[comb(bi, x) for x in range(bi + 1)] for bi in balls]

        # DP over (used balls in box1, distinct-count difference)
        offset = k
        width = 2 * k + 1
        dp = [[0] * width for _ in range(n + 1)]
        dp[0][offset] = 1

        for i, bi in enumerate(balls):
            next_dp = [[0] * width for _ in range(n + 1)]
            for s in range(0, n + 1):
                row = dp[s]
                # Small speed skip if entire row is zero
                if not any(row):
                    continue
                for d in range(width):
                    ways = row[d]
                    if ways == 0:
                        continue
                    for x in range(0, bi + 1):
                        s2 = s + x
                        if s2 > n:
                            break
                        # delta: +1 if x>0, -1 if y>0 (i.e., x<bi)
                        delta = (1 if x > 0 else 0) - (1 if x < bi else 0)
                        d2 = d + delta
                        next_dp[s2][d2] += ways * choose[i][x]
            dp = next_dp

        numerator = dp[n][offset]
        denominator = comb(total, n)
        return numerator / denominator

# Exactly 3 asserts
s = Solution()
assert abs(s.getProbability([1, 1]) - 1.0) < 1e-12
assert abs(s.getProbability([2, 1, 1]) - (2.0 / 3.0)) < 1e-9
assert abs(s.getProbability([1, 2, 1, 2]) - 0.6) < 1e-9
\end{minted}
\VALIDATION{The three provided examples pass to within floating precision.}
\RESULT{Return a \texttt{float} representing $\mathsf{Num}/\mathsf{Den}$, the probability that both boxes have the same number of distinct colors, treating boxes as ordered and balls as labeled for selection.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate against prompt examples, trivial boundaries (single color; all ones), and a couple of mixed cases. Use exact integer-weight computations to avoid numerical drift; only the final ratio is floating.}
\LINE{CROSS-CHECKS}{Compare the BFS/DFS enumerations (Approach A, B) with the DP result (Approach C) on small random instances to ensure equality of rational values before division.}
\LINE{EDGE-CASE GENERATOR}{Generate small $k \le 4$ with $b_i \le 3$ such that the sum is even; brute-force compare multiple approaches.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
from math import comb
import itertools

def reference_prob(balls: List[int]) -> float:
    # DP reference (Approach C)
    total = sum(balls)
    n = total // 2
    k = len(balls)
    choose = [[comb(bi, x) for x in range(bi + 1)] for bi in balls]
    offset = k
    width = 2 * k + 1
    dp = [[0] * width for _ in range(n + 1)]
    dp[0][offset] = 1
    for i, bi in enumerate(balls):
        ndp = [[0] * width for _ in range(n + 1)]
        for s in range(n + 1):
            for d in range(width):
                w = dp[s][d]
                if w == 0:
                    continue
                for x in range(bi + 1):
                    s2 = s + x
                    if s2 > n:
                        break
                    delta = (1 if x > 0 else 0) - (1 if x < bi else 0)
                    d2 = d + delta
                    ndp[s2][d2] += w * choose[i][x]
        dp = ndp
    num = dp[n][offset]
    den = comb(total, n)
    return num / den

# Sanity tests
assert abs(reference_prob([1, 1]) - 1.0) < 1e-12
assert abs(reference_prob([2, 1, 1]) - (2.0 / 3.0)) < 1e-9
assert abs(reference_prob([1, 2, 1, 2]) - 0.6) < 1e-9
assert abs(reference_prob([2]) - 1.0) < 1e-12
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from math import comb

class Solution:
    def getProbability(self, balls: List[int]) -> float:
        total = sum(balls)
        n = total // 2
        k = len(balls)

        # Precompute binomial coefficients for each color
        choose = [[comb(bi, x) for x in range(bi + 1)] for bi in balls]

        # DP over used balls and distinct-count difference
        offset = k
        width = 2 * k + 1
        dp = [[0] * width for _ in range(n + 1)]
        dp[0][offset] = 1

        for i, bi in enumerate(balls):
            next_dp = [[0] * width for _ in range(n + 1)]
            for s in range(n + 1):
                row = dp[s]
                if not any(row):
                    continue
                for d in range(width):
                    ways = row[d]
                    if ways == 0:
                        continue
                    for x in range(bi + 1):
                        s2 = s + x
                        if s2 > n:
                            break
                        delta = (1 if x > 0 else 0) - (1 if x < bi else 0)
                        d2 = d + delta
                        next_dp[s2][d2] += ways * choose[i][x]
            dp = next_dp

        numerator = dp[n][offset]
        denominator = comb(total, n)
        return numerator / denominator

# Asserts
s = Solution()
assert abs(s.getProbability([1, 1]) - 1.0) < 1e-12
assert abs(s.getProbability([2, 1, 1]) - (2.0 / 3.0)) < 1e-9
assert abs(s.getProbability([1, 2, 1, 2]) - 0.6) < 1e-9
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute the probability that two ordered boxes, each with $n$ balls drawn uniformly without replacement from a multiset, have equal numbers of distinct colors.}
\WHY{Combines multivariate hypergeometric probabilities, counting with indistinguishable items, and dynamic programming over color contributions—classic combinatorics under interview constraints.}
\CHECKLIST{
\begin{bullets}
\item Translate shuffle-and-split into hypergeometric selection.
\item Enumerate splits $\boldsymbol{x}$ with $\sum x_i=n$.
\item Track $D_1$ and $D_2$ correctly using zero vs nonzero $x_i$ and $y_i$.
\item Weight by $\prod \binom{b_i}{x_i}$, divide by $\binom{2n}{n}$.
\item Prefer DP or pruned DFS for performance.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Single color: probability $1.0$.
\item Two colors with even totals like \texttt{[2,2]}.
\item Many singleton colors, e.g., \texttt{[1,1,1,1]}.
\item Highly skewed counts, e.g., \texttt{[6,1,1]}.
\item Colors that must appear in both boxes when $b_i > n$ cannot happen here since $b_i \le 6$ and $n \ge 1$, but still handle $x_i \in [0,b_i]$.
\item Large $k$ near 8 with all $b_i=6$; ensure pruning or DP to keep runtime small.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using permutations multinomials directly can overflow; prefer integer products of $\binom{b_i}{x_i}$.
\item Forgetting boxes are ordered; do not divide by 2.
\item Miscounting distinct colors in box 2: use $y_i=b_i-x_i$, so $y_i>0$ iff $x_i<b_i$.
\item Not pruning infeasible partial sums in DFS causing timeouts.
\item Floating factorials introducing precision loss; keep integer weights until final division.
\item Off-by-one in DP dimensions for distinct-count difference range $[-k,k]$.
\end{bullets}
}
\FAILMODES{A naive permutation-based probability or sampling-based Monte Carlo will be slow or inaccurate. The presented DP is exact and fast for constraints.}
\ELI{Pick $n$ balls uniformly; the count of ways to achieve each color split is a product of binomials. Add up all splits where both boxes have the same number of colors and divide by the total number of size-$n$ picks. The DP just organizes this sum efficiently.}
\NotePages{3}

\end{document}