% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Moderate Modular Mode}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1603/B}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{YouKn0wWho has two even integers $x$ and $y$. Help him to find an integer $n$ such that $1 \le n \le 2 \cdot 10^{18}$ and $n \bmod x = y \bmod n$. Here, $a \bmod b$ denotes the remainder of $a$ after division by $b$. If there are multiple such integers, output any. It can be shown that such an integer always exists under the given constraints.

Input: The first line contains a single integer $t$ ($1 \le t \le 10^{5}$) — the number of test cases.

The first and only line of each test case contains two integers $x$ and $y$ ($2 \le x, y \le 10^{9}$, both are even).

Output: For each test case, print a single integer $n$ ($1 \le n \le 2 \cdot 10^{18}$) that satisfies the condition mentioned in the statement. If there are multiple such integers, output any. It can be shown that such an integer always exists under the given constraints.

Note: In the first test case, $4 \bmod 4 = 8 \bmod 4 = 0$.

In the second test case, $10 \bmod 4 = 2 \bmod 10 = 2$.

In the third test case, $420 \bmod 420 = 420 \bmod 420 = 0$.}
\BREAKDOWN{We must construct $n$ in range such that the congruences match. Two regimes suffice: when $y < x$, choose $n > y$ so $y \bmod n = y$; when $y \ge x$, choose $n$ just below $y$ so $y \bmod n = y - n$. Evenness of $x$ and $y$ guarantees divisibility needed to balance both sides.}
\ELI{Pick $n$ so that both sides equal the same small remainder: either $y$ itself (if $y<x$) or half of $y \bmod x$ (if $y \ge x$).}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer $t$ with $1 \le t \le 10^{5}$. Then $t$ lines follow; each line has even integers $x, y$ with $2 \le x, y \le 10^{9}$.}
\OUTPUTS{For each test case, output a single integer $n$ with $1 \le n \le 2 \cdot 10^{18}$ satisfying $n \bmod x = y \bmod n$. Any valid $n$ is accepted.}
\SAMPLES{Example 1: $x=4, y=4 \Rightarrow n=4$ works since $4 \bmod 4 = 4 \bmod 4 = 0$.

Example 2: $x=4, y=10 \Rightarrow n=8$ works since $8 \bmod 4 = 10 \bmod 8 = 2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given even $x,y \in \mathbb{Z}_{>0}$, find $n \in \mathbb{Z}$ such that $1 \le n \le 2 \cdot 10^{18}$ and
\begin{BreakableEquation*}
n \bmod x = y \bmod n.
\end{BreakableEquation*}
A constructive solution is sought.}
\varmapStart
\var{x}{even modulus target, $2 \le x \le 10^{9}$}
\var{y}{even reference value, $2 \le y \le 10^{9}$}
\var{n}{constructed integer to output}
\var{r_0}{the remainder $y \bmod x$}
\varmapEnd
\GOVERN{
\[
\text{Choose } n =
\begin{cases}
x+y, & \text{if } y < x,\\
y - \dfrac{y \bmod x}{2}, & \text{if } y \ge x,
\end{cases}
\]
\[
\text{then } n \bmod x =
\begin{cases}
y, & y < x,\\
\dfrac{y \bmod x}{2}, & y \ge x,
\end{cases}
\quad\text{and}\quad
y \bmod n =
\begin{cases}
y, & y < n,\\
y-n, & n \in \left(\dfrac{y}{2}, y\right],
\end{cases}
\]
which matches in each case.}
\ASSUMPTIONS{Both $x$ and $y$ are even. This implies $r_0 = y \bmod x$ is even, ensuring $\tfrac{r_0}{2}$ is integral. Standard modulo semantics with $0 \le a \bmod b < b$.}
\INVARIANTS{For $y<x$, $n=x+y>y \implies y \bmod n = y$. For $y \ge x$, $n=y-\tfrac{r_0}{2} \in (\tfrac{y}{2}, y] \implies y \bmod n = y-n = \tfrac{r_0}{2}$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try a couple of natural candidates that make one side easy: $n=x+y$ (so $y \bmod n = y$) and $n=y-\tfrac{(y \bmod x)}{2}$ (so $y \bmod n = y-n$). Verify and pick the first valid.}
\ASSUMPTIONS{We rely only on evenness of $x$ and $y$ so that $(y \bmod x)/2$ is integral.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $r_0 = y \bmod x$.
\item If $y < x$, return $n = x + y$.
\item Else compute $n = y - \tfrac{r_0}{2}$ and return it.
\end{algosteps}
\COMPLEXITY{O(1) per test case, O(1) extra space.}
\[
\begin{aligned}
T(t) &= \Theta(t), \quad S(t) = \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Case $y<x$: then $n=x+y>y$ so $y \bmod n = y$ and $n \bmod x = (x+y)\bmod x = y$. Case $y \ge x$: write $y=kx+r_0$ with even $r_0$. Then $n=y-\tfrac{r_0}{2}\in(\tfrac{y}{2},y]$, so $y \bmod n = y-n=\tfrac{r_0}{2}$, and $n \bmod x \equiv y - \tfrac{r_0}{2} \equiv r_0 - \tfrac{r_0}{2} = \tfrac{r_0}{2} \pmod{x}$ with $0 \le \tfrac{r_0}{2} < x$, hence equality holds.}
\EDGECASES{When $y=x$, $r_0=0$ and $n=y$ works. Minimal inputs $x=y=2$ give $n=2$. Large inputs still yield $n \le x+y \le 2\cdot 10^{9} \ll 2\cdot 10^{18}$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        x = int(next(it)); y = int(next(it))
        cases.append((x, y))
    return cases

def solve_case(x, y):
    # Baseline: two-case constructive solution
    if y < x:
        n = x + y
    else:
        r0 = y % x  # even since x,y are even
        n = y - (r0 // 2)
    # Sanity checks
    assert 1 <= n <= 2 * 10**18
    assert n % x == y % n
    return n

def solve_all(cases):
    return [solve_case(x, y) for (x, y) in cases]

def main():
    cases = read_input()
    ans = solve_all(cases)
    out = "\n".join(str(v) for v in ans)
    if out:
        print(out)

def _self_test():
    # Deterministic small checks
    tests = [
        (4, 4),   # y == x
        (4, 10),  # sample-like
        (420, 420),
        (8, 2),   # y < x
        (100, 1000000000),
        (2, 2),
        (2, 10),
        (10, 2),
    ]
    for x, y in tests:
        n = solve_case(x, y)
        assert 1 <= n <= 2 * 10**18
        assert n % x == y % n
    # Exhaustive small evens (subset)
    small = list(range(2, 22, 2))
    for x in small:
        for y in small:
            n = solve_case(x, y)
            assert n % x == y % n

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "TEST":
        _self_test()
    else:
        main()
\end{minted}
\VALIDATION{Checked both regimes: $y<x$ (e.g., $(8,2)$) and $y\ge x$ (e.g., $(4,10)$). Exhaustive sweep on small even pairs confirms the congruence.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Exploit the interval $(\tfrac{y}{2}, y]$: if $n$ lies here, then $y \bmod n = y-n$. We want $n \bmod x = y-n$, i.e., $2n \equiv y \pmod{x}$. Since $x$ is even, divide by $2$ to get $n \equiv \tfrac{y}{2} \pmod{x/2}$ and choose the representative that lands in $(\tfrac{y}{2}, y]$.}
\ASSUMPTIONS{Evenness of $x$ and $y$ ensures $2$ is not invertible modulo $x$ but the congruence reduces modulo $x/2$. The chosen representative will also make $y-n = \tfrac{(y \bmod x)}{2}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $r_0 = y \bmod x$ (even).
\item Let $n = y - \tfrac{r_0}{2}$, which lies in $(\tfrac{y}{2}, y]$.
\item Output $n$; it satisfies $n \bmod x = \tfrac{r_0}{2} = y \bmod n$.
\end{algosteps}
\COMPLEXITY{Same O(1) time and O(1) space per test.}
\[
\begin{aligned}
T(t) &= \Theta(t) \quad\text{and}\quad S(t) = \Theta(1).
\end{aligned}
\]
\CORRECTNESS{Writing $y=kx+r_0$ with $0 \le r_0 < x$ and even, we get $n=y-\tfrac{r_0}{2} \Rightarrow y \bmod n = y-n=\tfrac{r_0}{2}$ and $n \bmod x \equiv y-\tfrac{r_0}{2} \equiv \tfrac{r_0}{2} \pmod{x}$ with $0 \le \tfrac{r_0}{2} < x$, hence equality.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        x = int(next(it)); y = int(next(it))
        cases.append((x, y))
    return cases

def solve_case(x, y):
    if y < x:
        return x + y
    r0 = y % x  # even
    n = y - (r0 // 2)
    assert n % x == y % n
    return n

def solve_all(cases):
    return [solve_case(x, y) for (x, y) in cases]

def main():
    cases = read_input()
    ans = solve_all(cases)
    if ans:
        print("\n".join(map(str, ans)))

def _self_test():
    for x, y in [(4, 4), (4, 10), (8, 2), (100, 1000000000)]:
        n = solve_case(x, y)
        assert n % x == y % n
    # Boundary behavior
    for x in range(2, 52, 2):
        for y in range(2, 52, 2):
            n = solve_case(x, y)
            assert 1 <= n <= 2 * 10**18
            assert n % x == y % n

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "TEST":
        _self_test()
    else:
        main()
\end{minted}
\VALIDATION{Validated with small exhaustive sweep on even inputs up to $50$, and specific boundary-like $(x,y)$ including $y<x$, $y=x$, and large $y$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Final constructive rule:
\[
n =
\begin{cases}
x+y, & \text{if } y<x,\\
y - \dfrac{(y \bmod x)}{2}, & \text{otherwise.}
\end{cases}
\]
This directly satisfies $n \bmod x = y \bmod n$.}
\ASSUMPTIONS{Only that $x$ and $y$ are even.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $y < x$, set $n = x + y$.
\item Else write $y = kx + r_0$ with $0 \le r_0 < x$ (even) and set $n = y - \tfrac{r_0}{2}$.
\item Output $n$.
\end{algosteps}
\OPTIMALITY{The solution is O(1) and uses minimal arithmetic. The parity constraint is fully exploited; no iteration or search is needed.}
\COMPLEXITY{O(1) per test, O(1) memory.}
\[
\begin{aligned}
T(t) &= \Theta(t).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        x = int(next(it)); y = int(next(it))
        cases.append((x, y))
    return cases

def solve_case(x: int, y: int) -> int:
    if y < x:
        n = x + y
    else:
        r0 = y % x  # even
        n = y - (r0 // 2)
    # Final safety checks (true for given constraints)
    assert 1 <= n <= 2 * 10**18
    assert n % x == y % n
    return n

def solve_all(cases):
    return [solve_case(x, y) for (x, y) in cases]

def main():
    cases = read_input()
    ans = solve_all(cases)
    if ans:
        print("\n".join(map(str, ans)))

def _self_test():
    # Exactly 3 asserts
    assert solve_case(4, 4) % 4 == 4 % solve_case(4, 4)
    assert (lambda x, y, n: (n % x) == (y % n))(4, 10, solve_case(4, 10))
    assert (lambda x, y, n: (n % x) == (y % n))(8, 2, solve_case(8, 2))

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "TEST":
        _self_test()
    else:
        main()
\end{minted}
\VALIDATION{Three asserts cover $y<x$, $y=x$, and $y>x$ regimes.}
\RESULT{For each test case, a single integer $n$ meeting $n \bmod x = y \bmod n$, constructed in O(1) time; any valid $n$ is acceptable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover both regimes ($y<x$ and $y\ge x$), plus boundary values and a sweep over small even pairs. Property checked: $n \bmod x = y \bmod n$ and range bound $1 \le n \le 2\cdot 10^{18}$.}
\LINE{CROSS-CHECKS}{Compare the candidate $x+y$ vs $y - \tfrac{(y \bmod x)}{2}$ where both are admissible; either should satisfy the predicate, enhancing confidence.}
\LINE{EDGE-CASE GENERATOR}{Generate even pairs $(x,y)$ from a small grid (e.g., $2$ to $100$ step $2$) and verify the property for all.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_small_evens(limit=100):
    xs = list(range(2, limit + 1, 2))
    ys = list(range(2, limit + 1, 2))
    for x in xs:
        for y in ys:
            yield x, y

def check_property(x, y, n):
    return (1 <= n <= 2 * 10**18) and ((n % x) == (y % n))

def run_grid_test(solve_case_func, limit=100):
    for x, y in gen_small_evens(limit):
        n = solve_case_func(x, y)
        assert check_property(x, y, n)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        x = int(next(it)); y = int(next(it))
        cases.append((x, y))
    return cases

def solve_case(x: int, y: int) -> int:
    if y < x:
        n = x + y
    else:
        r0 = y % x  # even since x,y even
        n = y - (r0 // 2)
    # Contract checks (guaranteed by construction)
    assert 1 <= n <= 2 * 10**18
    assert n % x == y % n
    return n

def solve_all(cases):
    return [solve_case(x, y) for (x, y) in cases]

def main():
    cases = read_input()
    ans = solve_all(cases)
    if ans:
        print("\n".join(map(str, ans)))

def _self_test():
    # Basic directed tests
    pairs = [(4, 4), (4, 10), (8, 2), (2, 2), (100, 1000000000)]
    for x, y in pairs:
        n = solve_case(x, y)
        assert n % x == y % n
    # Grid checks on small evens
    for x in range(2, 102, 2):
        for y in range(2, 102, 2):
            n = solve_case(x, y)
            assert 1 <= n <= 2 * 10**18
            assert n % x == y % n

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "TEST":
        _self_test()
    else:
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Construct $n$ via two simple cases: $n=x+y$ if $y<x$, else $n=y-\tfrac{(y \bmod x)}{2}$.}
\WHY{This problem tests modular reasoning and constructive thinking, common in mid-level interviews and contests.}
\CHECKLIST{%
\begin{bullets}
\item Compute $r_0 = y \bmod x$.
\item If $y<x$, output $x+y$.
\item Else output $y - \tfrac{r_0}{2}$.
\item Optionally assert $n \bmod x = y \bmod n$.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $y=x$ yields $n=y$.
\item $y=x+2$ yields $r_0=2$, $n=y-1$; check $y \bmod n = 1$.
\item Minimal $x=y=2$ gives $n=2$.
\item Large $x,y$ still keep $n \le x+y \le 2\cdot 10^{9}$.
\item $r_0=0$ branch: $n=y$ is valid.
\item $r_0=x-2$ branch still ensures $n>y/2$.
\item Ensure $n$ strictly positive.
\item Respect modulo definition $0 \le a \bmod b < b$.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting that $x$ and $y$ are even; for odd inputs the formula needs adjustment.
\item Dividing $r_0$ by $2$ when $r_0$ is odd (cannot happen here but easy to overlook in generalizations).
\item Assuming $y \bmod n = y$ when $n=y$ (here it is $0$).
\item Picking $n \le y/2$ and mistakenly using $y-n$ instead of $y \bmod n$.
\item Overflow concerns in other languages; here Python integers are unbounded.
\item Printing extra debug lines that break judge format.
\item Mishandling whitespace or not reading all test cases.
\end{bullets}
}
\FAILMODES{Naive search over $n$ fails due to the huge bound $2\cdot 10^{18}$. The constructive approach sidesteps search by algebraic reasoning, guaranteed by parity.}
\ELI{Make both remainders equal to the same small number. If $y<x$, choose $n$ big so $y \bmod n$ stays $y$. Otherwise choose $n$ just below $y$ so $y \bmod n$ becomes half of $y \bmod x$, which matches $n \bmod x$.}
\NotePages{3}

\end{document}