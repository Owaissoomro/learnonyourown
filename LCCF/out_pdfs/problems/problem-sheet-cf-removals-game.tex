% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Removals Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2002/B}}
\LINE{DIFFICULTY / RATING}{1000}
\STATEMENT{Alice got a permutation $a_1, a_2, \ldots, a_n$ of $[1,2,\ldots,n]$, and Bob got another permutation $b_1, b_2, \ldots, b_n$ of $[1,2,\ldots,n]$. They are going to play a game with these arrays.

In each turn, the following events happen in order:
\begin{bullets}
\item Alice chooses either the first or the last element of her array and removes it from the array;
\item Bob chooses either the first or the last element of his array and removes it from the array.
\end{bullets}
The game continues for $n-1$ turns, after which both arrays will have exactly one remaining element: $x$ in the array $a$ and $y$ in the array $b$.

If $x=y$, Bob wins; otherwise, Alice wins. Find which player will win if both players play optimally.

Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1\le t\le 10^4$). The description of the test cases follows.

The first line of each test case contains a single integer $n$ ($1\le n\le 3\cdot 10^5$).

The next line contains $n$ integers $a_1,a_2,\ldots,a_n$ ($1\le a_i\le n$, all $a_i$ are distinct) — the permutation of Alice.

The next line contains $n$ integers $b_1,b_2,\ldots,b_n$ ($1\le b_i\le n$, all $b_i$ are distinct) — the permutation of Bob.

It is guaranteed that the sum of all $n$ does not exceed $3\cdot 10^5$.

Output: For each test case, print a single line with the name of the winner, assuming both players play optimally. If Alice wins, print \texttt{Alice}; otherwise, print \texttt{Bob}.

Note: In the first test case, Bob can win the game by deleting the same element as Alice did.

In the second test case, Alice can delete $3$ in the first turn, and then in the second turn, delete the element that is different from the one Bob deleted in the first turn to win the game.}
\BREAKDOWN{On each move, a player deletes an end; after $n-2$ full turns both arrays have two elements left. Alice then picks one element; Bob then picks one from his two. Reduce the game to adjacency of values: the final two candidates in each array must be adjacent in that array's permutation.}
\ELI{Alice wins iff she can end with two adjacent values that are not adjacent in Bob's array; otherwise Bob can mirror her last pick.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case:
\begin{bullets}
\item Integer $n$ ($1\le n\le 3\cdot 10^5$).
\item Array $a$ of length $n$, a permutation of $[1..n]$.
\item Array $b$ of length $n$, a permutation of $[1..n]$.
\end{bullets}
Total $\sum n\le 3\cdot 10^5$.}
\OUTPUTS{For each test case, a single line: \texttt{Alice} if Alice has a winning strategy, otherwise \texttt{Bob}.}
\SAMPLES{Examples (single test cases shown; CF uses multiple test cases format):
\begin{bullets}
\item $n=2$, $a=[1,2]$, $b=[2,1]$ $\to$ \texttt{Bob}.
\item $n=3$, $a=[1,2,3]$, $b=[1,3,2]$ $\to$ \texttt{Alice}.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=(a_1,\ldots,a_n)$ and $B=(b_1,\ldots,b_n)$ be permutations of $[n]$. Each player's remaining candidates after $k$ deletions form a contiguous interval in their permutation. Before the final moves, both intervals have size $2$. Alice picks one of her adjacent pair; Bob then picks one of his.}
\varmapStart
\var{A}{Alice's permutation}
\var{B}{Bob's permutation}
\var{\mathrm{Adj}(P)}{set of unordered adjacent pairs $\{\{P_i,P_{i+1}\}\mid 1\le i\le n-1\}$}
\var{\mathrm{pos}_B(x)}{position of value $x$ in $B$ (from $1$ to $n$)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Bob wins} \iff \forall i\in[1,n-1]:~\bigl|\mathrm{pos}_B(a_i)-\mathrm{pos}_B(a_{i+1})\bigr|=1
\end{BreakableEquation*}
Equivalently, $\mathrm{Adj}(A)\subseteq \mathrm{Adj}(B)$ (as sets of unordered pairs).
}
\ASSUMPTIONS{Both arrays are permutations (distinct elements), and the players have perfect information and optimal play. Removing from ends preserves the ``interval'' structure of remaining candidates.}
\INVARIANTS{
\begin{bullets}
\item After each move, each player's remaining elements form a contiguous block in their own permutation.
\item After $n-2$ full turns, each block has size $2$ (an adjacent pair).
\item Bob moves last and can match Alice's final pick iff that value lies in his final pair.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Check adjacency as sets: build all unordered adjacent pairs from $B$, then verify every adjacent pair in $A$ is present.}
\ASSUMPTIONS{Adjacency is unordered: the final pair is a set $\{u,v\}$, order irrelevant.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a hash set $S_B$ of unordered pairs $\{b_i,b_{i+1}\}$ for $i=1..n-1$.
\item For each $i=1..n-1$, form pair $\{a_i,a_{i+1}\}$ and check membership in $S_B$.
\item If all checks pass, print \texttt{Bob}; otherwise print \texttt{Alice}.
\end{algosteps}
\COMPLEXITY{Linear in $n$ per test case; hash operations are $O(1)$ average.}
\[
\begin{aligned}
T(n) &= O(n)\quad\text{(build $S_B$ and check $n-1$ pairs)} \\
S(n) &= O(n)\quad\text{(store $n-1$ pairs)}
\end{aligned}
\]
\CORRECTNESS{The only possible final states are adjacent pairs in each permutation. If any adjacent pair of $A$ is not adjacent in $B$, Alice can force that pair and then pick the element not in Bob's final pair, preventing equality. If all adjacent pairs of $A$ are also adjacent in $B$, Bob mirrors Alice's final pair and picks the same element to win.}
\EDGECASES{
\begin{bullets}
\item $n=1$: vacuously all checks pass; permutations must match, so \texttt{Bob}.
\item $n=2$: the only pair is $\{1,2\}$ in both; \texttt{Bob}.
\item Reversed arrays: still all adjacent sets match; \texttt{Bob}.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def solve_case_baseline(a: List[int], b: List[int]) -> str:
    n = len(a)
    # Build set of unordered adjacent pairs from b
    sb = set()
    for i in range(n - 1):
        u, v = b[i], b[i + 1]
        if u > v:
            u, v = v, u
        sb.add((u, v))
    # Check all adjacent pairs in a
    for i in range(n - 1):
        u, v = a[i], a[i + 1]
        if u > v:
            u, v = v, u
        if (u, v) not in sb:
            return "Alice"
    return "Bob"

def read_input_tokens(tokens: List[str]) -> List[Tuple[List[int], List[int]]]:
    it = iter(tokens)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        cases.append((a, b))
    return cases

def solve_all_baseline(cases: List[Tuple[List[int], List[int]]]) -> List[str]:
    return [solve_case_baseline(a, b) for a, b in cases]

def main():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        _test_baseline()
        return
    cases = read_input_tokens(data)
    ans = solve_all_baseline(cases)
    sys.stdout.write("\n".join(ans))

def _test_baseline():
    # Tiny unit tests
    assert solve_case_baseline([1], [1]) == "Bob"
    assert solve_case_baseline([1, 2], [2, 1]) == "Bob"
    assert solve_case_baseline([1, 2, 3], [1, 3, 2]) == "Alice"
    assert solve_case_baseline([2, 1, 3], [1, 2, 3]) == "Alice"
    # Random sanity: if a == b, Bob always wins
    for n in range(1, 8):
        p = list(range(1, n + 1))
        assert solve_case_baseline(p, p) == "Bob"

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked $n=1$, $n=2$, and crafted $n=3$ cases. Also property: if $a=b$, answer is always \texttt{Bob}.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Position Map Check}
\WHICHFORMULA{Replace set of pairs with a position map for $B$: for each adjacent pair in $A$, verify positions differ by $1$.}
\ASSUMPTIONS{Hashable integers with array indexing; positions are $0$-based internally.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build array $\mathrm{pos}_B$ such that $\mathrm{pos}_B[x]$ is index of $x$ in $B$.
\item For each $i=1..n-1$, compute $\Delta = \bigl|\mathrm{pos}_B[a_i]-\mathrm{pos}_B[a_{i+1}]\bigr|$.
\item If all $\Delta=1$ then \texttt{Bob}, else \texttt{Alice}.
\end{algosteps}
\COMPLEXITY{Same $O(n)$ time, but fewer allocations versus set of pairs.}
\[
\begin{aligned}
T(n) &= O(n) \\
S(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{Equivalent predicate to Approach A: adjacency in $B$ is exactly positions differing by $1$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

def solve_case_pos(a: List[int], b: List[int]) -> str:
    n = len(a)
    pos = [0] * (n + 1)
    for i, val in enumerate(b):
        pos[val] = i
    for i in range(n - 1):
        if abs(pos[a[i]] - pos[a[i + 1]]) != 1:
            return "Alice"
    return "Bob"

def read_input_tokens(tokens: List[str]) -> List[Tuple[List[int], List[int]]]:
    it = iter(tokens)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        cases.append((a, b))
    return cases

def solve_all_pos(cases: List[Tuple[List[int], List[int]]]) -> List[str]:
    return [solve_case_pos(a, b) for a, b in cases]

def main():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        _test_pos()
        return
    cases = read_input_tokens(data)
    ans = solve_all_pos(cases)
    sys.stdout.write("\n".join(ans))

def _test_pos():
    assert solve_case_pos([1], [1]) == "Bob"
    assert solve_case_pos([1, 2], [2, 1]) == "Bob"
    assert solve_case_pos([1, 2, 3], [1, 3, 2]) == "Alice"
    assert solve_case_pos([1, 3, 2], [2, 1, 3]) == "Alice"
    # If every adjacent pair in a is adjacent in b -> Bob
    assert solve_case_pos([3, 1, 2, 4], [1, 2, 4, 3]) == "Alice"  # pair {3,1} not adjacent in b
    assert solve_case_pos([3, 1, 2, 4], [3, 1, 2, 4]) == "Bob"

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge inputs validated; cross-checks with baseline on small cases (see next section for generator).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Final Pair Intersection Characterization}
\WHICHFORMULA{Bob wins iff $\forall i\in[1,n-1]$, $| \mathrm{pos}_B(a_i)-\mathrm{pos}_B(a_{i+1})|=1$. Implement with a single scan using a position map.}
\ASSUMPTIONS{Both play optimally; each can force any adjacent pair as the final size-$2$ interval before the last move.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $\mathrm{pos}_B$ in $O(n)$.
\item Scan adjacent pairs of $A$ and test $| \mathrm{pos}_B[a_i]-\mathrm{pos}_B[a_{i+1}]|=1$.
\item Output \texttt{Bob} iff all tests pass; else \texttt{Alice}.
\end{algosteps}
\OPTIMALITY{The decision predicate is necessary and sufficient; any algorithm must at least inspect all $n-1$ adjacencies of $A$, yielding a tight $\Theta(n)$ time bound.}
\COMPLEXITY{Linear time and space.}
\[
\begin{aligned}
T(n) &= \Theta(n) \\
S(n) &= \Theta(n)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

def solve_case(a: List[int], b: List[int]) -> str:
    n = len(a)
    pos = [0] * (n + 1)
    for i, v in enumerate(b):
        pos[v] = i
    for i in range(n - 1):
        if abs(pos[a[i]] - pos[a[i + 1]]) != 1:
            return "Alice"
    return "Bob"

def read_input() -> List[Tuple[List[int], List[int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        cases.append((a, b))
        # Sanity: permutations
        assert len(set(a)) == n and len(set(b)) == n
    return cases

def solve_all(cases: List[Tuple[List[int], List[int]]]) -> List[str]:
    return [solve_case(a, b) for a, b in cases]

def _test():
    # Exactly 3 asserts as required
    assert solve_case([1], [1]) == "Bob"
    assert solve_case([1, 2, 3], [1, 3, 2]) == "Alice"
    assert solve_case([2, 3, 1, 4], [3, 1, 2, 4]) == "Alice"

def main():
    cases = read_input()
    if not cases:
        _test()
        return
    out = solve_all(cases)
    import sys
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts included in \texttt{\_test()}: trivial $n=1$, and two crafted cases for $n=3$ and $n=4$.}
\RESULT{Print \texttt{Bob} iff every adjacent pair in $A$ is adjacent in $B$; otherwise print \texttt{Alice}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for hand-picked cases; randomized cross-check between baseline (set-of-pairs) and optimal (position map) for many permutations; I/O mini-tests for multiple test cases.}
\LINE{CROSS-CHECKS}{For random $n\le 8$, generate permutations $a,b$, ensure baseline and optimal agree.}
\LINE{EDGE-CASE GENERATOR}{Covers $n=1$, $n=2$, identical arrays, reversed arrays, and arrays differing by a single swap.}
\begin{minted}{python}
import random
from typing import List, Tuple

def solve_case_baseline(a: List[int], b: List[int]) -> str:
    sb = set()
    for i in range(len(b) - 1):
        u, v = b[i], b[i + 1]
        if u > v: u, v = v, u
        sb.add((u, v))
    for i in range(len(a) - 1):
        u, v = a[i], a[i + 1]
        if u > v: u, v = v, u
        if (u, v) not in sb:
            return "Alice"
    return "Bob"

def solve_case_opt(a: List[int], b: List[int]) -> str:
    n = len(a)
    pos = [0] * (n + 1)
    for i, v in enumerate(b):
        pos[v] = i
    for i in range(n - 1):
        if abs(pos[a[i]] - pos[a[i + 1]]) != 1:
            return "Alice"
    return "Bob"

def random_perm(n: int) -> List[int]:
    p = list(range(1, n + 1))
    random.shuffle(p)
    return p

def cross_check(trials: int = 2000):
    for n in range(1, 9):
        for _ in range(trials):
            a = random_perm(n)
            b = random_perm(n)
            r1 = solve_case_baseline(a, b)
            r2 = solve_case_opt(a, b)
            assert r1 == r2, (n, a, b, r1, r2)
    # Edge constructions
    assert solve_case_opt([1], [1]) == "Bob"
    assert solve_case_opt([1,2], [2,1]) == "Bob"
    assert solve_case_opt([1,2,3], [1,3,2]) == "Alice"
    assert solve_case_opt([3,2,1], [1,2,3]) == "Bob"

if __name__ == "__main__":
    cross_check(200)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

def solve_case(a: List[int], b: List[int]) -> str:
    n = len(a)
    pos = [0] * (n + 1)
    for i, v in enumerate(b):
        pos[v] = i
    for i in range(n - 1):
        if abs(pos[a[i]] - pos[a[i + 1]]) != 1:
            return "Alice"
    return "Bob"

def read_input() -> List[Tuple[List[int], List[int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        cases.append((a, b))
    return cases

def solve_all(cases: List[Tuple[List[int], List[int]]]) -> List[str]:
    return [solve_case(a, b) for a, b in cases]

def _self_tests():
    # Deterministic small asserts
    assert solve_case([1], [1]) == "Bob"
    assert solve_case([1, 2, 3], [1, 3, 2]) == "Alice"
    assert solve_case([2, 1, 3], [1, 2, 3]) == "Alice"

def main():
    cases = read_input()
    if not cases:
        _self_tests()
        return
    out = solve_all(cases)
    import sys
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to checking whether all adjacent pairs in Alice's permutation are also adjacent in Bob's permutation.}
\WHY{In interviews, end-removal games often reduce to interval invariants and endgame states; recognizing adjacency compression is key.}
\CHECKLIST{
\begin{bullets}
\item Build $\mathrm{pos}_B$ or adjacency set of $B$.
\item Scan adjacent pairs in $A$.
\item If any pair not adjacent in $B$ $\Rightarrow$ \texttt{Alice}; else \texttt{Bob}.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$: trivial, \texttt{Bob}.
\item $n=2$: always \texttt{Bob}.
\item Identical permutations: \texttt{Bob}.
\item Reversed permutations: \texttt{Bob} (unordered adjacency).
\item Single non-adjacent pair between $A$ and $B$: \texttt{Alice}.
\item Large $n$ with $\sum n\le 3\cdot 10^5$: linear scan safe.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Treating adjacency as ordered; it is unordered on the last move.
\item Forgetting $0$- vs $1$-based positions when computing differences.
\item Building full $n\times n$ structures; unnecessary and slow.
\item Misreading that players interact across arrays; they do not.
\item Assuming Bob can always pick any value in his array at the end; he can only pick from his final pair.
\item Overcomplicating with DP; interval invariant suffices.
\end{bullets}}
\FAILMODES{
\begin{bullets}
\item Simulation per turn will TLE or be buggy; final-pair logic avoids this.
\item Greedy matching of values mid-game is irrelevant; only adjacency matters.
\end{bullets}}
\ELI{Both shrink their arrays to two neighbors. Alice picks one; Bob can mirror it only if that value is among his two neighbors. If Alice can ensure her final two are not neighbors in Bob's array, she can avoid Bob's pick and win. Otherwise, Bob always mirrors and wins.}
\NotePages{3}

\end{document}