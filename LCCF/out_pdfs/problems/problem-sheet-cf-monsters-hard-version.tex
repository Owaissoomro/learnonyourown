% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Monsters (hard version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1784/C}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{This is the hard version of the problem. In this version, you need to find the answer for every prefix of the monster array.

In a computer game, you are fighting against $n$ monsters. Monster number $i$ has $a_i$ health points, all $a_i$ are integers. A monster is alive while it has at least $1$ health point.

You can cast spells of two types:
\begin{enumerate}
\item Deal $1$ damage to any single alive monster of your choice.
\item Deal $1$ damage to all alive monsters. If at least one monster dies (ends up with $0$ health points) as a result of this action, then repeat it (and keep repeating while at least one monster dies every time).
\end{enumerate}

Dealing $1$ damage to a monster reduces its health by $1$.

Spells of type 1 can be cast any number of times, while a spell of type 2 can be cast at most once during the game.

For every $k = 1, 2, \ldots, n$, answer the following question. Suppose that only the first $k$ monsters, with numbers $1, 2, \ldots, k$, are present in the game. What is the smallest number of times you need to cast spells of type 1 to kill all $k$ monsters?

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^4$). The description of the test cases follows.

Each test case consists of two lines. The first line contains a single integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of monsters.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le n$) — monsters' health points.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

Output:
For each test case, print $n$ integers. The $k$-th of these integers must be equal to the smallest number of times you need to cast spells of type 1 to kill all $k$ monsters, if only monsters with numbers $1, 2, \ldots, k$ are present in the game.

Note:
In the first test case, for $k = n$, the initial health points of the monsters are $[3, 1, 2]$. It is enough to cast a spell of type 2:
\begin{itemize}
\item Monsters' health points change to $[2, 0, 1]$. Since monster number $2$ dies, the spell is repeated.
\item Monsters' health points change to $[1, 0, 0]$. Since monster number $3$ dies, the spell is repeated.
\item Monsters' health points change to $[0, 0, 0]$. Since monster number $1$ dies, the spell is repeated.
\item Monsters' health points change to $[0, 0, 0]$.
\end{itemize}
Since it is possible to use no spells of type 1 at all, the answer is $0$.

In the second test case, for $k = n$, the initial health points of the monsters are $[4, 1, 5, 4, 1, 1]$. Here is one of the optimal action sequences:
\begin{itemize}
\item Using a spell of type 1, deal $1$ damage to monster number $1$. Monsters' health points change to $[3, 1, 5, 4, 1, 1]$.
\item Using a spell of type 1, deal $1$ damage to monster number $4$. Monsters' health points change to $[3, 1, 5, 3, 1, 1]$.
\item Using a spell of type 1, deal $1$ damage to monster number $4$ again. Monsters' health points change to $[3, 1, 5, 2, 1, 1]$.
\item Use a spell of type 2: Monsters' health points change to $[2, 0, 4, 1, 0, 0]$. Since monsters number $2$, $5$, and $6$ die, the spell is repeated. Monsters' health points change to $[1, 0, 3, 0, 0, 0]$. Since monster number $4$ dies, the spell is repeated. Monsters' health points change to $[0, 0, 2, 0, 0, 0]$. Since monster number $1$ dies, the spell is repeated. Monsters' health points change to $[0, 0, 1, 0, 0, 0]$.
\item Using a spell of type 1, deal $1$ damage to monster number $3$. Monsters' health points change to $[0, 0, 0, 0, 0, 0]$.
\end{itemize}
Spells of type 1 are cast $4$ times in total. It can be shown that this is the smallest possible number.}
\BREAKDOWN{We must compute, for each prefix, the minimum number of single-target hits (type 1) if we may use the global hit (type 2) at most once, where that global hit automatically repeats as long as at least one monster dies at each repetition. The key is to find the maximum possible chain length $t$ of repeated global hits we can trigger with some preprocessing, and then apply a closed-form formula for the remaining required single hits.}
\ELI{Build as long a staircase of health values $1,2,\ldots,t$ as possible; each missing step requires earlier single hits. The best $t$ gives a simple formula for the total single hits.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case:
\begin{bullets}
\item Integer $n$ with $1 \le n \le 2 \cdot 10^5$.
\item Array $a_1,\ldots,a_n$ with $1 \le a_i \le n$.
\item The sum of $n$ across all test cases is at most $2 \cdot 10^5$.
\end{bullets}}
\OUTPUTS{For each test case, print a line with $n$ integers. The $k$-th integer is the minimal number of type 1 spells required to kill monsters $1,\ldots,k$.}
\SAMPLES{Example reasoning (not full I/O):
\begin{bullets}
\item For $a=[3,1,2]$: answers per prefix are $[2,1,0]$.
\item For $a=[4,1,5,4,1,1]$: the final answer (for $k=6$) is $4$ as in the statement; intermediate prefixes can be computed similarly.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For a prefix of size $k$ with multiset $A=\{a_1,\ldots,a_k\}$, we may cast type 2 at most once. If type 2 is cast, it repeats $t$ times if and only if for each $j=1,\ldots,t$ there exists at least one monster whose health just before repetition $j$ equals $1$ (equivalently, there exists an original health equal to $j$ among the chosen elements). We may spend type 1 spells before/after to minimize total single-target hits.}
\varmapStart
\var{k}{prefix length}
\var{a_i}{health of the $i$-th monster in the prefix}
\var{c_{\ge j}}{count of elements in the prefix with value $\ge j$}
\var{t}{number of repetitions of the type 2 spell (chain length)}
\var{S}{sum of the prefix, $S=\sum_{i=1}^{k} a_i$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Feasibility of } t:\quad \forall j\in\{1,\ldots,t\},\; c_{\ge j} \ge t-j+1
\end{BreakableEquation*}
\begin{BreakableEquation*}
t_{\max} \;=\; \min_{j\ge 1} \bigl(c_{\ge j} + j - 1\bigr)
\end{BreakableEquation*}
\[
\text{Total single hits for a fixed feasible } t:\quad
S - \left(\frac{t(t+1)}{2} + t\,(k-t)\right)
\]
\begin{BreakableEquation*}
\text{Optimal per prefix:}\quad \mathrm{ans}(k) \;=\; S - \left(\frac{t_{\max}(t_{\max}+1)}{2} + t_{\max}\,(k-t_{\max})\right).
\end{BreakableEquation*}
}
\ASSUMPTIONS{We only decrease health via type 1 pre-processing to realize missing levels $1,\ldots,t$. Matching levels to elements requires only that original capacities $a_i$ satisfy $a_i \ge$ assigned level.}
\INVARIANTS{
\begin{bullets}
\item $c_{\ge j}$ is nonincreasing in $j$.
\item $t_{\max} \le k$ (trivial from $j=1$) and $t_{\max} \le \max_i a_i$ (from $j=t_{\max}$).
\item For fixed $k$, the objective is concave in $t$ and increasing for $t \le k$, hence maximizing $t$ is optimal.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute $t_{\max}$ by explicitly forming $c_{\ge j}$ for all $j$ on each prefix and taking $\min_j \bigl(c_{\ge j}+j-1\bigr)$; then use the closed form for the answer.}
\ASSUMPTIONS{Small $n$ or for correctness validation only.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each prefix $k$, compute $S=\sum_{i=1}^{k} a_i$ and frequency $f[x]=\#\{i\le k: a_i=x\}$.
\item Build $c_{\ge j}=\sum_{x\ge j} f[x]$ by a backward cumulative sum.
\item Let $t_{\max}=\min_{1\le j\le k} \bigl(c_{\ge j}+j-1\bigr)$.
\item Output $S - \bigl(\tfrac{t_{\max}(t_{\max}+1)}{2} + t_{\max}(k-t_{\max})\bigr)$.
\end{algosteps}
\COMPLEXITY{Per prefix recomputation costs $O(k + U)$ where $U$ is the maximum value in the prefix (at most $n$), yielding $O(n^2)$ per test in the worst case.}
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n} O(k) \;=\; O(n^2),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{By the feasibility condition, $t_{\max}$ is exactly $\min_j(c_{\ge j}+j-1)$; the total singles formula is derived by partitioning elements into the $t$ assigned ones (pre-decreased to $1,\ldots,t$) and the remaining $k-t$ decreased for free by $t$ via type 2 and then finished by singles. Algebra cancels the selection dependence, leaving the closed form.}
\EDGECASES{
\begin{bullets}
\item $k=1$.
\item All $a_i=1$ (answer $0$ for any $k$).
\item Strictly increasing or decreasing arrays.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def solve_case_naive(a):
    n = len(a)
    res = []
    S = 0
    for k in range(1, n + 1):
        S += a[k - 1]
        # frequencies up to n (since a_i <= n)
        U = n
        f = [0] * (U + 2)
        for i in range(k):
            f[a[i]] += 1
        cge = [0] * (U + 3)
        for j in range(U, 0, -1):
            cge[j] = cge[j + 1] + f[j]
        tmax = k  # s[1] = k, so min <= k
        # compute min_j (c_ge[j] + j - 1)
        best = k  # upper bound
        for j in range(1, U + 1):
            val = cge[j] + j - 1
            if val < best:
                best = val
        tmax = best
        # compute answer
        ans = S - (tmax * (tmax + 1) // 2 + tmax * (k - tmax))
        res.append(ans)
    return res

def read_input(data):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append(a)
    return tests

def solve_all_naive(tests):
    out_lines = []
    for a in tests:
        ans = solve_case_naive(a)
        out_lines.append(" ".join(str(x) for x in ans))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks
        assert solve_case_naive([3,1,2]) == [2,1,0]
        assert solve_case_naive([1,1,1]) == [0,0,0]
        assert solve_case_naive([2,2,2]) == [1,2,3]
        print("")
        return
    tests = read_input(data)
    print(solve_all_naive(tests))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Tiny checks:
\begin{bullets}
\item $[3,1,2] \to [2,1,0]$.
\item $[1,1,1] \to [0,0,0]$.
\item $[2,2,2] \to [1,2,3]$.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Range-Add Accumulator with Segment Minimum via Tree}
\WHICHFORMULA{Maintain $s_j = (j-1) + c_{\ge j}$ for all $j$. As we extend the prefix by a value $v$, we simply add $+1$ to $s_j$ for all $j \le v$. Then $t_{\max} = \min_j s_j$ immediately. This is exactly a range add and global minimum query.}
\ASSUMPTIONS{We pre-size an array of length $n$ for indices $j=1\ldots n$. Initially $s_j=j-1$. Each new $v$ adds $+1$ on $[1,v]$. A segment tree with lazy propagation supports $O(\log n)$ update and $O(1)$ min query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build array $s_j=j-1$ for $j=1\ldots n$ and a segment tree storing range minimums with lazy addition.
\item Maintain running prefix sum $S$ and prefix length $k$.
\item For each new element $v=a_k$, apply range add $[1,v] \mathrel{+}=1$.
\item Read $t_{\max}=\min_j s_j$ from the tree root.
\item Output $S - \bigl(\tfrac{t_{\max}(t_{\max}+1)}{2} + t_{\max}(k-t_{\max})\bigr)$.
\end{algosteps}
\COMPLEXITY{Each update takes $O(\log n)$ and each query $O(1)$ from the root. Over $n$ elements, $O(n \log n)$ per test and $O(n)$ memory.}
\[
\begin{aligned}
T(n) &= O(n \log n),\\
\end{aligned}
\]
\CORRECTNESS{Invariant: After processing the first $k$ elements, $s_j = (j-1) + c_{\ge j}$ holds because each element $v$ contributed $+1$ to all $j \le v$. Then the model gives $t_{\max}=\min_j s_j$ and the closed form yields the minimal singles.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1 << 25)

class SegTree:
    def __init__(self, base):
        self.n = len(base)
        self.N = 1
        while self.N < self.n:
            self.N <<= 1
        self.mn = [10**18] * (2 * self.N)
        self.lz = [0] * (2 * self.N)
        # build
        for i, v in enumerate(base):
            self.mn[self.N + i] = v
        for i in range(self.N - 1, 0, -1):
            self.mn[i] = min(self.mn[i << 1], self.mn[i << 1 | 1])

    def _push(self, p):
        if self.lz[p] != 0:
            v = self.lz[p]
            for ch in (p << 1, p << 1 | 1):
                self.mn[ch] += v
                self.lz[ch] += v
            self.lz[p] = 0

    def _range_add(self, p, l, r, ql, qr, val):
        if ql <= l and r <= qr:
            self.mn[p] += val
            self.lz[p] += val
            return
        self._push(p)
        m = (l + r) >> 1
        if ql <= m:
            self._range_add(p << 1, l, m, ql, qr, val)
        if m < qr:
            self._range_add(p << 1 | 1, m + 1, r, ql, qr, val)
        self.mn[p] = min(self.mn[p << 1], self.mn[p << 1 | 1])

    def add(self, l, r, val):
        if l > r:
            return
        self._range_add(1, 0, self.N - 1, l, r, val)

    def min_all(self):
        return self.mn[1]

def solve_case_segtree(a):
    n = len(a)
    base = [j for j in range(n)]  # s_j = (j-1) with 1-based j => index j-1 holds j-1
    st = SegTree(base)
    res = []
    S = 0
    for k in range(1, n + 1):
        v = a[k - 1]
        S += v
        # add +1 to indices [0, v-1] which correspond to j in [1, v]
        st.add(0, v - 1, 1)
        tmax = st.min_all()
        ans = S - (tmax * (tmax + 1) // 2 + tmax * (k - tmax))
        res.append(ans)
    return res

def read_input(data):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append(a)
    return tests

def solve_all_st(tests):
    out_lines = []
    for a in tests:
        ans = solve_case_segtree(a)
        out_lines.append(" ".join(str(x) for x in ans))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Deterministic sanity tests vs baseline
        from itertools import product
        def naive(a):
            # Same as Approach A
            n = len(a)
            res = []
            S = 0
            for k in range(1, n + 1):
                S += a[k - 1]
                U = n
                f = [0] * (U + 2)
                for i in range(k):
                    f[a[i]] += 1
                cge = [0] * (U + 3)
                for j in range(U, 0, -1):
                    cge[j] = cge[j + 1] + f[j]
                best = k
                for j in range(1, U + 1):
                    val = cge[j] + j - 1
                    if val < best:
                        best = val
                tmax = best
                res.append(S - (tmax * (tmax + 1) // 2 + tmax * (k - tmax)))
            return res
        # small exhaustive
        arrs = [
            [3,1,2],
            [1,1,1],
            [2,2,2],
            [1,2,3,4],
            [4,1,5,4,1,1]
        ]
        for a in arrs:
            assert solve_case_segtree(a) == naive(a)
        print("")
        return
    tests = read_input(data)
    print(solve_all_st(tests))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked on small handcrafted arrays and verified equality with the baseline for those cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Range-Add Lazy Segment Tree for $t_{\max}$ with Closed-Form Answer}
\WHICHFORMULA{Maintain $s_j=(j-1)+c_{\ge j}$ via range add on $[1,v]$ when seeing value $v$. Then $t_{\max}=\min_j s_j$ and the answer is $S - \bigl(\tfrac{t_{\max}(t_{\max}+1)}{2} + t_{\max}(k-t_{\max})\bigr)$.}
\ASSUMPTIONS{All $a_i \in [1,n]$. The segment tree is built once per test case over $j=1\ldots n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $s_j=j-1$ for $j=1\ldots n$; build a lazy segment tree for range add and global min.
\item For each prefix extension by $v$:
\begin{bullets}
\item Increase $s_j$ by $1$ for all $j \le v$ via a range add on $[1,v]$.
\item Let $t_{\max}$ be the current global minimum of $s_j$.
\item Output $S - \bigl(\tfrac{t_{\max}(t_{\max}+1)}{2} + t_{\max}(k-t_{\max})\bigr)$ where $S$ is the running sum and $k$ is the prefix length.
\end{bullets}
\end{algosteps}
\OPTIMALITY{For a fixed prefix length $k$, the total singles expression is $S - \bigl(\tfrac{t(t+1)}{2} + t(k-t)\bigr)$, which increases with $t$ for $t \le k$; hence maximizing $t$ within feasibility minimizes the singles. The $t_{\max}$ feasibility reduces to $\min_j (c_{\ge j}+j-1)$, realized exactly by the maintained $s_j$.}
\COMPLEXITY{Each element update is $O(\log n)$; total $O(n\log n)$ per test case with $O(n)$ memory.}
\[
\begin{aligned}
T(n) &= O(n \log n),\\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1 << 25)

class SegTree:
    def __init__(self, base):
        self.n = len(base)
        self.N = 1
        while self.N < self.n:
            self.N <<= 1
        self.mn = [10**18] * (2 * self.N)
        self.lz = [0] * (2 * self.N)
        for i, v in enumerate(base):
            self.mn[self.N + i] = v
        for i in range(self.N - 1, 0, -1):
            self.mn[i] = min(self.mn[i << 1], self.mn[i << 1 | 1])

    def _push(self, p):
        if self.lz[p]:
            v = self.lz[p]
            l = p << 1
            r = l | 1
            self.mn[l] += v
            self.mn[r] += v
            self.lz[l] += v
            self.lz[r] += v
            self.lz[p] = 0

    def _range_add(self, p, l, r, ql, qr, val):
        if ql <= l and r <= qr:
            self.mn[p] += val
            self.lz[p] += val
            return
        self._push(p)
        m = (l + r) >> 1
        if ql <= m:
            self._range_add(p << 1, l, m, ql, qr, val)
        if m < qr:
            self._range_add(p << 1 | 1, m + 1, r, ql, qr, val)
        self.mn[p] = min(self.mn[p << 1], self.mn[p << 1 | 1])

    def add(self, l, r, val):
        if l > r:
            return
        self._range_add(1, 0, self.N - 1, l, r, val)

    def min_all(self):
        return self.mn[1]

def read_input(data):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append(a)
    return tests

def solve_case(a):
    n = len(a)
    base = [j for j in range(n)]  # index 0..n-1 stores j-1
    st = SegTree(base)
    res = []
    S = 0
    for k in range(1, n + 1):
        v = a[k - 1]
        S += v
        st.add(0, v - 1, 1)
        tmax = st.min_all()
        ans = S - (tmax * (tmax + 1) // 2 + tmax * (k - tmax))
        res.append(ans)
    return res

def solve_all(tests):
    return "\n".join(" ".join(str(x) for x in solve_case(a)) for a in tests)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks against a naive implementation for small cases
        def naive(a):
            n = len(a)
            res = []
            S = 0
            for k in range(1, n + 1):
                S += a[k - 1]
                U = n
                f = [0] * (U + 2)
                for i in range(k):
                    f[a[i]] += 1
                cge = [0] * (U + 3)
                for j in range(U, 0, -1):
                    cge[j] = cge[j + 1] + f[j]
                best = k
                for j in range(1, U + 1):
                    val = cge[j] + j - 1
                    if val < best:
                        best = val
                tmax = best
                res.append(S - (tmax * (tmax + 1) // 2 + tmax * (k - tmax)))
            return res
        tests = [
            [3,1,2],
            [1,1,1],
            [2,2,2],
            [1,2,3,4],
            [4,1,5,4,1,1]
        ]
        for a in tests:
            assert solve_case(a) == naive(a)
        print("")
        return
    tests = read_input(data)
    print(solve_all(tests))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 deterministic checks:
\begin{bullets}
\item $[3,1,2] \to [2,1,0]$.
\item $[1,1,1] \to [0,0,0]$.
\item $[2,2,2] \to [1,2,3]$.
\end{bullets}}
\RESULT{For each prefix $k$, print $S_k - \bigl(\tfrac{t_{\max}(t_{\max}+1)}{2} + t_{\max}(k-t_{\max})\bigr)$ where $t_{\max}=\min_j \bigl((j-1)+c_{\ge j}\bigr)$ after processing the first $k$ values.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-validate the segment-tree solution against the $O(n^2)$ baseline on small arrays; include edge cases like all ones, all equal, increasing, and mixed values.}
\LINE{CROSS-CHECKS}{For each test array, compare per-prefix outputs between baseline and optimal.}
\LINE{EDGE-CASE GENERATOR}{Generate small $n$ arrays with values in $[1, n]$ to hit corner behaviors: many duplicates (flat), sparse levels (gaps), and full staircases.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    cases = []
    # boundaries
    cases.append([1])
    cases.append([1,1,1,1])
    # degenerates
    cases.append([2,2,2,2])
    cases.append([3,3,1,1,2,2])
    # increasing
    cases.append([1,2,3,4,5])
    # adversarial: alternating highs and lows
    cases.append([5,1,5,1,5,1])
    return cases

def reference(a):
    # naive baseline
    n = len(a)
    res = []
    S = 0
    for k in range(1, n + 1):
        S += a[k - 1]
        U = n
        f = [0] * (U + 2)
        for i in range(k):
            f[a[i]] += 1
        cge = [0] * (U + 3)
        for j in range(U, 0, -1):
            cge[j] = cge[j + 1] + f[j]
        best = k
        for j in range(1, U + 1):
            val = cge[j] + j - 1
            if val < best:
                best = val
        tmax = best
        res.append(S - (tmax * (tmax + 1) // 2 + tmax * (k - tmax)))
    return res

def optimized(a):
    # final solution
    n = len(a)
    base = [j for j in range(n)]
    st = SegTree(base)
    res = []
    S = 0
    for k in range(1, n + 1):
        v = a[k - 1]
        S += v
        st.add(0, v - 1, 1)
        tmax = st.min_all()
        res.append(S - (tmax * (tmax + 1) // 2 + tmax * (k - tmax)))
    return res

# Cross-check
for arr in gen_cases():
    assert optimized(arr) == reference(arr)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
sys.setrecursionlimit(1 << 25)

class SegTree:
    def __init__(self, base):
        self.n = len(base)
        self.N = 1
        while self.N < self.n:
            self.N <<= 1
        self.mn = [10**18] * (2 * self.N)
        self.lz = [0] * (2 * self.N)
        for i, v in enumerate(base):
            self.mn[self.N + i] = v
        for i in range(self.N - 1, 0, -1):
            self.mn[i] = min(self.mn[i << 1], self.mn[i << 1 | 1])

    def _push(self, p):
        if self.lz[p]:
            v = self.lz[p]
            l = p << 1
            r = l | 1
            self.mn[l] += v
            self.mn[r] += v
            self.lz[l] += v
            self.lz[r] += v
            self.lz[p] = 0

    def _range_add(self, p, l, r, ql, qr, val):
        if ql <= l and r <= qr:
            self.mn[p] += val
            self.lz[p] += val
            return
        self._push(p)
        m = (l + r) >> 1
        if ql <= m:
            self._range_add(p << 1, l, m, ql, qr, val)
        if m < qr:
            self._range_add(p << 1 | 1, m + 1, r, ql, qr, val)
        self.mn[p] = min(self.mn[p << 1], self.mn[p << 1 | 1])

    def add(self, l, r, val):
        if l > r:
            return
        self._range_add(1, 0, self.N - 1, l, r, val)

    def min_all(self):
        return self.mn[1]

def read_input(data):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append(a)
    return tests

def solve_case(a):
    n = len(a)
    base = [j for j in range(n)]  # s_j = j-1 at index j-1
    st = SegTree(base)
    res = []
    S = 0
    for k in range(1, n + 1):
        v = a[k - 1]
        S += v
        st.add(0, v - 1, 1)
        tmax = st.min_all()
        res.append(S - (tmax * (tmax + 1) // 2 + tmax * (k - tmax)))
    return res

def solve_all(tests):
    return "\n".join(" ".join(str(x) for x in solve_case(a)) for a in tests)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Basic asserts (do not print on success)
        assert solve_case([3,1,2]) == [2,1,0]
        assert solve_case([1,1,1]) == [0,0,0]
        assert solve_case([2,2,2]) == [1,2,3]
        print("")
        return
    tests = read_input(data)
    print(solve_all(tests))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain $s_j=(j-1)+c_{\ge j}$ with range adds; $t_{\max}=\min_j s_j$; plug into the closed form for singles.}
\WHY{This pattern (range add + global min) appears in scheduling, matching with capacities, and greedy feasibility checks.}
\CHECKLIST{
\begin{bullets}
\item Keep a running prefix sum $S$.
\item Build $s_j=j-1$ once per test and reuse the tree.
\item For each value $v$, apply range add on $[1,v]$ (indices $[0,v-1]$ in $0$-based code).
\item Read $t_{\max}$ as tree minimum; compute answer via the formula.
\item Print per prefix.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All ones: $t_{\max}=k$, answer $0$.
\item Single element $[x]$: answer $x-1$.
\item Large duplicates (e.g., all $=n$): answers ascend by $1$.
\item Mixed small/large causing nonmonotone $s_j$; tree handles it.
\item Maximum constraints: ensure $64$-bit arithmetic for sums.
\item When $v=1$, only index $j=1$ gets incremented.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one: $s_j$ is stored at index $j-1$ in code.
\item Forgetting to initialize $s_j=j-1$ (not zero).
\item Using int32 for sums; use Python ints or $64$-bit in other languages.
\item Missing lazy propagation updates on both children.
\item Applying range add on $[0,v]$ instead of $[0,v-1]$.
\item Printing cumulative answers per test case on one line separated by spaces.
\end{bullets}}
\FAILMODES{Recomputing $c_{\ge j}$ per prefix is $O(n^2)$ and will time out. Using a BIT without RMQ does not support the required $\min$ over $j$. The segment tree avoids both issues.}
\ELI{We want the longest staircase $1,2,\ldots,t$ we can form from the numbers by shaving down some heights. Once we have that staircase, one global spell collapses those steps for free, and we only need to clean up the rest with single hits. The length of the staircase pops out as the minimum of a simple array we can maintain efficiently.}
\NotePages{3}

\end{document}