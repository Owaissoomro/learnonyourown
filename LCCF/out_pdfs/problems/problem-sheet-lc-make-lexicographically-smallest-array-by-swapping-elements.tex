% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Make Lexicographically Smallest Array by Swapping Elements}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/make-lexicographically-smallest-array-by-swapping-elements/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given a 0-indexed array of positive integers nums and a positive integer limit. In one operation, you can choose any two indices $i$ and $j$ and swap $\,\text{nums}[i]$ and $\,\text{nums}[j]$ if $\lvert \text{nums}[i]-\text{nums}[j]\rvert \le \text{limit}$. Return the lexicographically smallest array that can be obtained by performing the operation any number of times.

An array $a$ is lexicographically smaller than an array $b$ if in the first position where $a$ and $b$ differ, array $a$ has an element that is less than the corresponding element in $b$. For example, the array $[2,10,3]$ is lexicographically smaller than the array $[10,2,3]$ because they differ at index $0$ and $2<10$.

Examples:
\begin{itemize}
\item Input: nums $=$ $[1,5,3,9,8]$, limit $=2$. Output: $[1,3,5,8,9]$. Explanation: Swap indices $(1,2)$ then $(3,4)$.
\item Input: nums $=$ $[1,7,6,18,2,1]$, limit $=3$. Output: $[1,6,7,18,1,2]$. One valid sequence: $(1,2)$, $(0,4)$, $(0,5)$.
\item Input: nums $=$ $[1,7,28,19,10]$, limit $=3$. Output: $[1,7,28,19,10]$. No swaps allowed.
\end{itemize}

Constraints:
\begin{itemize}
\item $1 \le \text{nums.length} \le 10^5$
\item $1 \le \text{nums}[i] \le 10^9$
\item $1 \le \text{limit} \le 10^9$
\end{itemize}}
\BREAKDOWN{Swaps are allowed only when the values differ by at most limit. This induces groups of values connected through a sequence of within-limit hops; within each such group, values can be permuted arbitrarily. To minimize lexicographic order, place the smallest available values of a group into the smallest indices containing members of that group.}
\ELI{Values that are close enough can travel together; sort each travel group and seat smaller numbers earlier.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function signature (LC): \texttt{def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]}

nums: list of $n$ positive integers; limit: positive integer.

Valid ranges: $1 \le n \le 10^5$, $1 \le \text{nums}[i], \text{limit} \le 10^9$.}
\OUTPUTS{Return a list of length $n$ representing the lexicographically smallest array achievable under the swap rule.}
\SAMPLES{
\begin{itemize}
\item nums $=[3,1,2]$, limit $=1$ $\to$ $[1,2,3]$.
\item nums $=[4,1,10]$, limit $=2$ $\to$ $[1,4,10]$.
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=(a_0,\ldots,a_{n-1})\in \mathbb{Z}_{>0}^n$, and $L\in \mathbb{Z}_{>0}$. Consider the multiset $M$ of the values in $A$. Define a graph $G$ whose vertices are the distinct values in $M$ and whose edges connect $x,y$ if $\lvert x-y\rvert \le L$. Let $\mathcal{C}$ be the set of connected components of $G$.

For each component $C\in \mathcal{C}$, let $I_C=\{i : a_i \in C\}$ (indices whose values lie in $C$) and $V_C$ be the multiset of values $\{a_i : i\in I_C\}$. Any sequence of allowed swaps can only permute values within each $I_C$. The lexicographically smallest array is obtained by sorting $I_C$ ascending and $V_C$ ascending and assigning the $k$-th smallest value of $V_C$ to the $k$-th smallest index in $I_C$, independently for each $C$.}
\varmapStart
\var{n}{array length}
\var{A=(a_i)}{input values}
\var{L}{swap limit}
\var{G}{value graph with edges $\lvert x-y\rvert \le L$}
\var{\mathcal{C}}{connected components of $G$}
\var{I_C}{indices carrying values in component $C$}
\var{V_C}{multiset of values from component $C$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall C\in \mathcal{C}:\quad \text{let }(i_1\le \cdots \le i_{m_C})=\text{sort}(I_C),\ (v_1\le \cdots \le v_{m_C})=\text{sort}(V_C).
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Then the optimal array }A^\star\text{ satisfies }A^\star[i_k]=v_k\text{ for }k=1,\ldots,m_C,\text{ for all }C\in \mathcal{C}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are 0-based. The component relation uses only values that appear in the array. Ties within a component are resolved by stable sorting but any consistent ascending assignment yields the same lexicographic result.}
\INVARIANTS{
\begin{itemize}
\item Swaps preserve the multiset of values in each $I_C$.
\item Values from different components can never cross components because any pair from different components differs by more than $L$ along every step.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Build a graph on indices: connect $i$ and $j$ if $\lvert a_i-a_j\rvert \le L$ (using all $O(n^2)$ pairs). Each connected component of indices can permute arbitrarily. Then sort values within each component and place them on sorted indices.}
\ASSUMPTIONS{This over-builds edges but is correct and simple for reasoning; complexity is quadratic.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Create DSU over indices $\{0,\ldots,n-1\}$.
\item For every pair $0\le i<j<n$, if $\lvert a_i-a_j\rvert \le L$, union $i$ and $j$.
\item Group indices by DSU root. For each group, collect its values, sort both indices and values, and assign smallest values to smallest indices.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(n^2)$ to scan all pairs plus $O(n\log n)$ for sorting within components; space $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= \binom{n}{2} + \sum_{C} \bigl(\lvert I_C\rvert \log \lvert I_C\rvert\bigr) = \Theta(n^2) \\
S(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{Any two indices in the same connected component are linked by a path of edges, each edge being an allowed swap; composing swaps allows arbitrary permutations within that component. Sorting values and placing them onto the smallest indices yields the lexicographically smallest arrangement per component, and components are independent.}
\EDGECASES{All values equal; no pair within limit; single element; duplicates spread across components; large limits that connect everything.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Dict, DefaultDict
from collections import defaultdict

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1

class Solution:
    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:
        n = len(nums)
        if n <= 1:
            return nums[:]
        dsu = DSU(n)
        for i in range(n):
            ai = nums[i]
            for j in range(i+1, n):
                if abs(ai - nums[j]) <= limit:
                    dsu.union(i, j)
        groups: DefaultDict[int, List[int]] = defaultdict(list)
        for i in range(n):
            groups[dsu.find(i)].append(i)
        ans = nums[:]
        for root, idxs in groups.items():
            vals = [nums[i] for i in idxs]
            idxs.sort()
            vals.sort()
            for k, i in enumerate(idxs):
                ans[i] = vals[k]
        return ans

if __name__ == "__main__":
    s = Solution()
    assert s.lexicographicallySmallestArray([1,5,3,9,8], 2) == [1,3,5,8,9]
    assert s.lexicographicallySmallestArray([1,7,6,18,2,1], 3) == [1,6,7,18,1,2]
    assert s.lexicographicallySmallestArray([1,7,28,19,10], 3) == [1,7,28,19,10]
    assert s.lexicographicallySmallestArray([3], 100) == [3]
\end{minted}
\VALIDATION{Checked against the three examples and a singleton.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Union-Find on Values (compress by distinct values)}
\WHICHFORMULA{Instead of $O(n^2)$ index pairs, sort unique values and union only consecutive values whose difference $\le L$. Indices inherit the component of their value. Sort per-component indices and values to assign.}
\ASSUMPTIONS{Only values present in the array matter. Consecutive differences on the sorted unique list characterize connectivity in the value graph.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute sorted unique values $U$ from nums.
\item DSU over $U$; for each adjacent pair $(U[i-1],U[i])$, if $U[i]-U[i-1]\le L$, union them.
\item Map each value $v$ to its component id; group indices and values by this id.
\item For every component: sort indices and values and assign smallest values to smallest indices.
\end{algosteps}
\COMPLEXITY{Sorting $U$ costs $O(m\log m)$ where $m\le n$. Group sorting totals $O(n\log n)$. Overall $O(n\log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(m\log m) + O(n\log n),\quad m\le n \\
\end{aligned}
\]
\CORRECTNESS{The value graph over present values has edges only between consecutive sorted values within distance $L$. Its connected components characterize exactly which values can be interchanged via sequences of allowed swaps. Assigning sorted values to sorted indices per component minimizes lexicographic order.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Dict
from collections import defaultdict

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0]*n
    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1

class Solution:
    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:
        n = len(nums)
        if n <= 1:
            return nums[:]
        uniq = sorted(set(nums))
        m = len(uniq)
        dsu = DSU(m)
        for i in range(1, m):
            if uniq[i] - uniq[i-1] <= limit:
                dsu.union(i, i-1)
        rep_index = {v: dsu.find(i) for i, v in enumerate(uniq)}
        comp_to_indices: Dict[int, List[int]] = defaultdict(list)
        comp_to_values: Dict[int, List[int]] = defaultdict(list)
        for i, v in enumerate(nums):
            c = rep_index[v]
            comp_to_indices[c].append(i)
            comp_to_values[c].append(v)
        ans = nums[:]
        for c in comp_to_indices.keys():
            idxs = comp_to_indices[c]
            vals = comp_to_values[c]
            idxs.sort()
            vals.sort()
            for k, i in enumerate(idxs):
                ans[i] = vals[k]
        return ans

if __name__ == "__main__":
    s = Solution()
    assert s.lexicographicallySmallestArray([1,5,3,9,8], 2) == [1,3,5,8,9]
    assert s.lexicographicallySmallestArray([1,7,6,18,2,1], 3) == [1,6,7,18,1,2]
    assert s.lexicographicallySmallestArray([1,7,28,19,10], 3) == [1,7,28,19,10]
    assert s.lexicographicallySmallestArray([3,1,2], 1) == [1,2,3]
\end{minted}
\VALIDATION{Validated on examples and an extra case tying two small values while isolating a large value.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-Pass Grouping on Sorted Pairs}
\WHICHFORMULA{Sort pairs $(\text{value},\text{index})$ by value. Values form contiguous groups where successive differences $\le L$. For each group, indices are arbitrary; sort indices and place the group's sorted values accordingly.}
\ASSUMPTIONS{Connectivity in the value graph equals contiguity under sorted order by value using the threshold $L$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Create pairs $P=\{(a_i,i)\}$ and sort by value.
\item Sweep $P$ and form maximal groups where consecutive values differ by at most $L$.
\item For each group: extract the group's values (already sorted) and the group's indices; sort indices and assign the sorted values to these indices from smallest to largest.
\end{algosteps}
\OPTIMALITY{Any solution must respect value-component boundaries, and lexicographic minimality per component requires assigning the smallest available values to the smallest indices. The grouping found by the sweep is exactly the component partition; sorting indices is necessary and sufficient.}
\COMPLEXITY{Sorting pairs costs $O(n\log n)$. Each index appears in exactly one group; sorting indices per group sums to $O(n\log n)$ in the worst case. Space $O(n)$.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n)=O(n)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:
        n = len(nums)
        if n <= 1:
            return nums[:]
        pairs = sorted((v, i) for i, v in enumerate(nums))
        ans = nums[:]
        start = 0
        while start < n:
            end = start
            # grow group while adjacent values differ by at most limit
            while end + 1 < n and pairs[end+1][0] - pairs[end][0] <= limit:
                end += 1
            # group is pairs[start:end+1]
            group_vals = [pairs[k][0] for k in range(start, end+1)]  # already sorted
            group_idxs = [pairs[k][1] for k in range(start, end+1)]
            group_idxs.sort()
            for val, idx in zip(group_vals, group_idxs):
                ans[idx] = val
            start = end + 1
        return ans

if __name__ == "__main__":
    s = Solution()
    assert s.lexicographicallySmallestArray([1,5,3,9,8], 2) == [1,3,5,8,9]
    assert s.lexicographicallySmallestArray([1,7,6,18,2,1], 3) == [1,6,7,18,1,2]
    assert s.lexicographicallySmallestArray([1,7,28,19,10], 3) == [1,7,28,19,10]
\end{minted}
\VALIDATION{Exactly the three official-style examples are asserted.}
\RESULT{Return the lexicographically smallest achievable array; ties within a value component are resolved by assigning smaller values to smaller indices.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on diverse patterns: all-equal; strictly increasing with small limit; separated clusters; alternating close/far values; duplicates crossing component boundaries. Property: the multiset of output equals input; within each value-component, indices receive the sorted values.}
\LINE{CROSS-CHECKS}{For small $n\le 9$, compare Approach A (quadratic DSU on indices) vs Approach C (group sweep) on random arrays and random limits; they must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with repeated blocks, extreme limits ($L=0$ and very large), and gaps just above and just below $L$ to exercise boundary grouping.}
\begin{minted}{python}
import random
from typing import List

def brute_indices(nums: List[int], limit: int) -> List[int]:
    # Approach A reference for cross-checks (quadratic)
    n = len(nums)
    parent = list(range(n))
    rank = [0]*n
    def find(x):
        while parent[x] != x:
            parent[x] = parent[parent[x]]
            x = parent[x]
        return x
    def union(a,b):
        ra, rb = find(a), find(b)
        if ra == rb: return
        if rank[ra] < rank[rb]:
            ra, rb = rb, ra
        parent[rb] = ra
        if rank[ra] == rank[rb]:
            rank[ra] += 1
    for i in range(n):
        for j in range(i+1, n):
            if abs(nums[i]-nums[j]) <= limit:
                union(i,j)
    groups = {}
    for i in range(n):
        r = find(i)
        groups.setdefault(r, []).append(i)
    ans = nums[:]
    for g, idxs in groups.items():
        vals = [nums[i] for i in idxs]
        idxs.sort(); vals.sort()
        for k, i in enumerate(idxs):
            ans[i] = vals[k]
    return ans

def sweep_groups(nums: List[int], limit: int) -> List[int]:
    n = len(nums)
    pairs = sorted((v,i) for i,v in enumerate(nums))
    ans = nums[:]
    start = 0
    while start < n:
        end = start
        while end+1 < n and pairs[end+1][0] - pairs[end][0] <= limit:
            end += 1
        vals = [pairs[k][0] for k in range(start, end+1)]
        idxs = sorted(pairs[k][1] for k in range(start, end+1))
        for v,i in zip(vals, idxs):
            ans[i] = v
        start = end + 1
    return ans

def run_cross_checks():
    random.seed(0)
    for n in range(1, 10):
        for _ in range(200):
            nums = [random.randint(1, 20) for _ in range(n)]
            limit = random.randint(0, 10)
            a = brute_indices(nums, limit)
            c = sweep_groups(nums, limit)
            assert a == c, (nums, limit, a, c)
    print("Cross-checks passed")

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:
        n = len(nums)
        if n <= 1:
            return nums[:]
        # Sort (value, index) pairs by value
        pairs = sorted((v, i) for i, v in enumerate(nums))
        ans = nums[:]
        start = 0
        while start < n:
            end = start
            # Grow the contiguous value group where adjacent diffs <= limit
            while end + 1 < n and pairs[end+1][0] - pairs[end][0] <= limit:
                end += 1
            # Extract group's sorted values and sort the group's indices
            group_vals = [pairs[k][0] for k in range(start, end+1)]
            group_idxs = [pairs[k][1] for k in range(start, end+1)]
            group_idxs.sort()
            # Assign smallest values to smallest indices
            for val, idx in zip(group_vals, group_idxs):
                ans[idx] = val
            start = end + 1
        return ans

if __name__ == "__main__":
    s = Solution()
    assert s.lexicographicallySmallestArray([1,5,3,9,8], 2) == [1,3,5,8,9]
    assert s.lexicographicallySmallestArray([1,7,6,18,2,1], 3) == [1,6,7,18,1,2]
    assert s.lexicographicallySmallestArray([1,7,28,19,10], 3) == [1,7,28,19,10]
    # Additional sanity checks
    assert s.lexicographicallySmallestArray([3,1,2], 1) == [1,2,3]
    assert s.lexicographicallySmallestArray([4,1,10], 2) == [1,4,10]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Group values by within-limit connectivity and place the group's smallest values at the group's smallest indices.}
\WHY{This pattern appears in interview problems where the allowed operation implies an equivalence relation; recognizing components reduces the problem to sorting within buckets.}
\CHECKLIST{
\begin{itemize}
\item Build connectivity on values, not on positions of the final array.
\item Partition indices by their value component.
\item For each component, sort indices and the component's values.
\item Assign in lockstep: smallest value to smallest index.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item Limit $=0$ (only equal values can swap).
\item Very large limit that connects all values.
\item Duplicates that span multiple indices inside one component.
\item Single element array.
\item Non-overlapping clusters like $[1,5,9]$ with $L=3$ vs $L=4$.
\item Values near integer boundaries.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Grouping by positions rather than by values may miss transitive swaps via intermediates.
\item Forgetting to sort indices before assignment breaks lexicographic minimality.
\item Using value differences across non-consecutive sorted values without ensuring a chain exists.
\item Not handling duplicates correctly inside a component.
\item In-place overwrites without copying can cause reuse of updated values.
\item Integer overflow is not a concern in Python, but watch for absolute difference comparisons.
\end{itemize}
}
\FAILMODES{Greedy left-to-right swapping without global grouping can get stuck in suboptimal states when a smaller value needs to traverse multiple intermediates. The grouping approach avoids local traps.}
\ELI{Think of values as train cars that can couple only if their numbers are within $L$. All cars that can connect form a train. Within each train, sort the car numbers, then place them into the earliest available stations (indices).}
\NotePages{3}

\end{document}