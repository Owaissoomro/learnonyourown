% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Design Bitset}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/design-bitset/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{A Bitset is a data structure that compactly stores bits.

Implement the \texttt{Bitset} class:
\begin{bullets}
\item \texttt{Bitset(int size)} Initializes the Bitset with \texttt{size} bits, all of which are \texttt{0}.
\item \texttt{void fix(int idx)} Updates the value of the bit at the index \texttt{idx} to \texttt{1}. If the value was already \texttt{1}, no change occurs.
\item \texttt{void unfix(int idx)} Updates the value of the bit at the index \texttt{idx} to \texttt{0}. If the value was already \texttt{0}, no change occurs.
\item \texttt{void flip()} Flips the values of each bit in the Bitset. In other words, all bits with value \texttt{0} will now have value \texttt{1} and vice versa.
\item \texttt{boolean all()} Checks if the value of each bit in the Bitset is \texttt{1}. Returns \texttt{true} if it satisfies the condition, \texttt{false} otherwise.
\item \texttt{boolean one()} Checks if there is at least one bit in the Bitset with value \texttt{1}. Returns \texttt{true} if it satisfies the condition, \texttt{false} otherwise.
\item \texttt{int count()} Returns the total number of bits in the Bitset which have value \texttt{1}.
\item \texttt{String toString()} Returns the current composition of the Bitset. In the resultant string, the character at the \texttt{i}th index should coincide with the value at the \texttt{i}th bit of the Bitset.
\end{bullets}

Example 1:

Input

\texttt{["Bitset", "fix", "fix", "flip", "all", "unfix", "flip", "one", "unfix", "count", "toString"]}

\texttt{[[5], [3], [1], [], [], [0], [], [], [0], [], []]}

Output

\texttt{[null, null, null, null, false, null, null, true, null, 2, "01010"]}

Explanation

\texttt{Bitset bs = new Bitset(5);} bitset $=$ \texttt{"00000"}.

\texttt{bs.fix(3);} the value at \texttt{idx = 3} is updated to \texttt{1}, so bitset $=$ \texttt{"00010"}.

\texttt{bs.fix(1);} the value at \texttt{idx = 1} is updated to \texttt{1}, so bitset $=$ \texttt{"01010"}.

\texttt{bs.flip();} the value of each bit is flipped, so bitset $=$ \texttt{"10101"}.

\texttt{bs.all();} return \texttt{false}, as not all values of the bitset are \texttt{1}.

\texttt{bs.unfix(0);} the value at \texttt{idx = 0} is updated to \texttt{0}, so bitset $=$ \texttt{"00101"}.

\texttt{bs.flip();} the value of each bit is flipped, so bitset $=$ \texttt{"11010"}.

\texttt{bs.one();} return \texttt{true}, as there is at least one index with value \texttt{1}.

\texttt{bs.unfix(0);} the value at \texttt{idx = 0} is updated to \texttt{0}, so bitset $=$ \texttt{"01010"}.

\texttt{bs.count();} return \texttt{2}, as there are 2 bits with value \texttt{1}.

\texttt{bs.toString();} return \texttt{"01010"}, which is the composition of bitset.

Constraints:
\begin{bullets}
\item $1 \le \text{size} \le 10^{5}$.
\item $0 \le \text{idx} \le \text{size} - 1$.
\item At most $10^{5}$ calls will be made in total to \texttt{fix}, \texttt{unfix}, \texttt{flip}, \texttt{all}, \texttt{one}, \texttt{count}, and \texttt{toString}.
\item At least one call will be made to \texttt{all}, \texttt{one}, \texttt{count}, or \texttt{toString}.
\item At most $5$ calls will be made to \texttt{toString}.
\end{bullets}
}
\BREAKDOWN{Design a bitset that supports point set/reset, global flip, and queries \texttt{all}, \texttt{one}, \texttt{count}, and \texttt{toString} efficiently. Aim to avoid $O(n)$ time per operation except possibly \texttt{toString}.}
\ELI{Keep an array of bits and a lazy flip flag with a running count of ones so that most operations are $O(1)$ and \texttt{toString} can be built on demand.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode driver provides:
\begin{bullets}
\item \texttt{Bitset(int size)} constructor.
\item Methods: \texttt{fix(int idx)}, \texttt{unfix(int idx)}, \texttt{flip()}, \texttt{boolean all()}, \texttt{boolean one()}, \texttt{int count()}, \texttt{String toString()}.
\item Internally, tests call a sequence of operations and compare returned values.
\end{bullets}}
\OUTPUTS{Each method returns as specified: \texttt{void} for mutators; booleans for \texttt{all}/\texttt{one}; integer for \texttt{count}; string of length \texttt{size} for \texttt{toString}.}
\SAMPLES{Example:
\begin{minted}{python}
# Operations
# ["Bitset","fix","fix","flip","all","unfix","flip","one","unfix","count","toString"]
# [[5],      [3],   [1],   [],    [],    [0],     [],   [],    [0],    [],    []]
\end{minted}
Another tiny example:
\begin{minted}{python}
# ["Bitset","one","all","count","toString"]
# [[2],      [],    [],    [],     []] -> [None, False, False, 0, "00"]
\end{minted}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Maintain a bit vector $b \in \{0,1\}^{n}$ of length $n$, with operations:
\begin{bullets}
\item $\mathrm{fix}(i): b_i \leftarrow 1$.
\item $\mathrm{unfix}(i): b_i \leftarrow 0$.
\item $\mathrm{flip}(): b_i \leftarrow 1 - b_i$ for all $i$.
\item $\mathrm{all}(): \bigwedge_{i=0}^{n-1} (b_i = 1)$.
\item $\mathrm{one}(): \bigvee_{i=0}^{n-1} (b_i = 1)$.
\item $\mathrm{count}(): \sum_{i=0}^{n-1} b_i$.
\item $\mathrm{toString}():$ the concatenation of $b_0 b_1 \ldots b_{n-1}$ as characters.
\end{bullets}}
\varmapStart
\var{n}{bitset length (size)}
\var{b_i}{stored bit at index $i$ in base orientation}
\var{f}{flip flag ($f=0$ means base, $f=1$ means complemented view)}
\var{c}{current number of ones in the viewed bitset}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{view}(i) &= b_i \oplus f, \\
c &= \sum_{i=0}^{n-1} \text{view}(i), \\
\mathrm{fix}(i)&:\ \text{if }\text{view}(i)=0\text{ then }b_i\leftarrow 1\oplus f,\ c\leftarrow c+1, \\
\mathrm{unfix}(i)&:\ \text{if }\text{view}(i)=1\text{ then }b_i\leftarrow 0\oplus f,\ c\leftarrow c-1, \\
\mathrm{flip}()&:\ f\leftarrow 1-f,\ c\leftarrow n-c.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are zero-based; $0 \le i < n$. At most $10^{5}$ operations.}
\INVARIANTS{
\begin{bullets}
\item $0 \le c \le n$ always.
\item $\text{view}(i) = b_i \oplus f$ for all $i$; \texttt{flip} never mutates $b$ in the lazy approach.
\item After any operation, $c = \sum_i \text{view}(i)$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Represent bits explicitly in a list of integers. Implement \texttt{flip()} by iterating all $n$ bits and toggling each. \texttt{count()}, \texttt{all()}, \texttt{one()} iterate as needed.}
\ASSUMPTIONS{Simple list of $0/1$ integers; no lazy state.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Store \texttt{a = [0]*n}.
\item \texttt{fix}/\texttt{unfix}: set \texttt{a[idx]} accordingly.
\item \texttt{flip}: for each $i$, set \texttt{a[i] ^= 1}. Queries iterate \texttt{a}.
\end{algosteps}
\COMPLEXITY{Let $n$ be the size.
\[
\begin{aligned}
\text{fix/unfix} &: O(1), \\
\text{flip} &: O(n), \\
\text{all/one/count} &: O(n), \\
\text{toString} &: O(n), \\
\text{space} &: O(n).
\end{aligned}
\]}
\CORRECTNESS{Directly mutating and reading the explicit array agrees with the specification.}
\EDGECASES{Repeated \texttt{fix} on the same index; repeated \texttt{unfix}; flipping empty vs. full; boundary indices $0$ and $n-1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Bitset:
    def __init__(self, size: int):
        self.n = size
        self.a = [0] * size

    def fix(self, idx: int) -> None:
        if self.a[idx] == 0:
            self.a[idx] = 1

    def unfix(self, idx: int) -> None:
        if self.a[idx] == 1:
            self.a[idx] = 0

    def flip(self) -> None:
        for i in range(self.n):
            self.a[i] ^= 1

    def all(self) -> bool:
        # True if all are 1
        return all(x == 1 for x in self.a)

    def one(self) -> bool:
        # True if any is 1
        return any(self.a)

    def count(self) -> int:
        return sum(self.a)

    def toString(self) -> str:
        return "".join("1" if x else "0" for x in self.a)


# LeetCode harness typically does not require a Solution class for design problems,
# but we include an empty one to satisfy the "LC class Solution" presence contract.
class Solution:
    pass


def _run_sample_baseline():
    out = []
    bs = Bitset(5); out.append(None)
    bs.fix(3); out.append(None)
    bs.fix(1); out.append(None)
    bs.flip(); out.append(None)
    out.append(bs.all())
    bs.unfix(0); out.append(None)
    bs.flip(); out.append(None)
    out.append(bs.one())
    bs.unfix(0); out.append(None)
    out.append(bs.count())
    out.append(bs.toString())
    exp = [None, None, None, None, False, None, None, True, None, 2, "01010"]
    assert out == exp, (out, exp)

    # Additional small checks
    bs2 = Bitset(2)
    assert bs2.toString() == "00"
    bs2.flip()
    assert bs2.toString() == "11"
    bs2.unfix(1)
    assert bs2.toString() == "10"


if __name__ == "__main__":
    _run_sample_baseline()
\end{minted}
\VALIDATION{Checks include the given sample sequence and simple flips on size $2$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Lazy Flip Flag + Ones Counter}
\WHICHFORMULA{Maintain a base bit array, a flip flag $f$, and a running count $c$ of ones in the viewed bitset. This makes \texttt{flip} $O(1)$ and queries $O(1)$.}
\ASSUMPTIONS{Use \texttt{bits[i]} to store base value; observed value is \texttt{bits[i] ^ flipped}. Maintain \texttt{ones} as the current number of observed ones.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{bits = [0]*n}, \texttt{flipped = False}, \texttt{ones = 0}.
\item For \texttt{fix(idx)}: if observed bit is $0$, set base bit to $1 \oplus f$ and increment \texttt{ones}.
\item For \texttt{unfix(idx)}: if observed bit is $1$, set base bit to $0 \oplus f$ and decrement \texttt{ones}.
\item For \texttt{flip()}: toggle \texttt{flipped} and set \texttt{ones = n - ones}.
\item \texttt{all/one/count}: compare \texttt{ones} to $n$ or $0$.
\item \texttt{toString}: build string by reading observed bits \texttt{bits[i] ^ flipped}.
\end{algosteps}
\COMPLEXITY{All updates and boolean/count queries are $O(1)$; \texttt{toString} is $O(n)$ (at most $5$ times per constraints). Space $O(n)$.}
\[
\begin{aligned}
T_{\text{fix}} &= O(1),\quad T_{\text{unfix}} = O(1),\quad T_{\text{flip}} = O(1), \\
T_{\text{all/one/count}} &= O(1),\quad T_{\text{toString}} = O(n).
\end{aligned}
\]
\CORRECTNESS{By maintaining the invariant \texttt{observed = base xor flipped} and updating \texttt{ones} consistently, each method matches the formal model.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Bitset:
    def __init__(self, size: int):
        self.n = size
        self.bits = [0] * size  # base orientation
        self.flipped = False
        self.ones = 0

    def _view(self, idx: int) -> int:
        return self.bits[idx] ^ (1 if self.flipped else 0)

    def fix(self, idx: int) -> None:
        if self._view(idx) == 0:
            # Need observed 1 -> base must be 1 ^ flipped
            self.bits[idx] = 1 ^ (1 if self.flipped else 0)
            self.ones += 1

    def unfix(self, idx: int) -> None:
        if self._view(idx) == 1:
            # Need observed 0 -> base must be 0 ^ flipped == flipped
            self.bits[idx] = (1 if self.flipped else 0)
            self.ones -= 1

    def flip(self) -> None:
        self.flipped = not self.flipped
        self.ones = self.n - self.ones

    def all(self) -> bool:
        return self.ones == self.n

    def one(self) -> bool:
        return self.ones > 0

    def count(self) -> int:
        return self.ones

    def toString(self) -> str:
        f = 1 if self.flipped else 0
        return "".join("1" if (b ^ f) else "0" for b in self.bits)


class Solution:
    pass


def _run_checks_improved():
    out = []
    bs = Bitset(5); out.append(None)
    bs.fix(3); out.append(None)
    bs.fix(1); out.append(None)
    bs.flip(); out.append(None)
    out.append(bs.all())
    bs.unfix(0); out.append(None)
    bs.flip(); out.append(None)
    out.append(bs.one())
    bs.unfix(0); out.append(None)
    out.append(bs.count())
    out.append(bs.toString())
    exp = [None, None, None, None, False, None, None, True, None, 2, "01010"]
    assert out == exp

    # Edge: repeated fixes/unfixes
    bs2 = Bitset(3)
    bs2.fix(0); bs2.fix(0); assert bs2.count() == 1
    bs2.unfix(0); bs2.unfix(0); assert bs2.count() == 0
    bs2.flip(); assert bs2.all() is False and bs2.one() is True and bs2.count() == 3 - 0


if __name__ == "__main__":
    _run_checks_improved()
\end{minted}
\VALIDATION{Covers the sample sequence, idempotent \texttt{fix}/\texttt{unfix}, and post-flip counts.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Lazy Complement with Count Tracking}
\WHICHFORMULA{This is the same as Approach B and is optimal under the constraints: all updates and boolean/count queries in $O(1)$, \texttt{toString} in $O(n)$ at most $5$ times.}
\ASSUMPTIONS{Constraints allow $O(n)$ string building. No need for heavier data structures.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep base bits, flip flag, and ones counter.
\item Adjust base bit and ones on \texttt{fix}/\texttt{unfix} only when observed value changes.
\item Toggle flag and recompute ones as $n - \text{ones}$ on \texttt{flip}.
\end{algosteps}
\OPTIMALITY{Any implementation must read all $n$ bits to output \texttt{toString}; boolean/count queries can be $O(1)$ via the maintained counter, which is tight.}
\COMPLEXITY{$T_{\text{fix/unfix/flip/all/one/count}} = O(1)$; $T_{\text{toString}} = O(n)$; space $O(n)$.}
\[
\begin{aligned}
T(n) &= O(1) \text{ per update/query except } O(n) \text{ for toString}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Bitset:
    def __init__(self, size: int):
        self.n = size
        self.bits = [0] * size  # base storage
        self.flipped = False
        self.ones = 0

    def _view(self, idx: int) -> int:
        return self.bits[idx] ^ (1 if self.flipped else 0)

    def fix(self, idx: int) -> None:
        if self._view(idx) == 0:
            self.bits[idx] = 1 ^ (1 if self.flipped else 0)
            self.ones += 1

    def unfix(self, idx: int) -> None:
        if self._view(idx) == 1:
            self.bits[idx] = (1 if self.flipped else 0)
            self.ones -= 1

    def flip(self) -> None:
        self.flipped = not self.flipped
        self.ones = self.n - self.ones

    def all(self) -> bool:
        return self.ones == self.n

    def one(self) -> bool:
        return self.ones > 0

    def count(self) -> int:
        return self.ones

    def toString(self) -> str:
        f = 1 if self.flipped else 0
        return "".join("1" if (b ^ f) else "0" for b in self.bits)


class Solution:
    pass


def _tests_final():
    # 1) Provided sample
    out = []
    bs = Bitset(5); out.append(None)
    bs.fix(3); out.append(None)
    bs.fix(1); out.append(None)
    bs.flip(); out.append(None)
    out.append(bs.all())
    bs.unfix(0); out.append(None)
    bs.flip(); out.append(None)
    out.append(bs.one())
    bs.unfix(0); out.append(None)
    out.append(bs.count())
    out.append(bs.toString())
    assert out == [None, None, None, None, False, None, None, True, None, 2, "01010"]

    # 2) Boundary indices and idempotency
    n = 4
    bs2 = Bitset(n)
    bs2.fix(0); bs2.fix(n-1); bs2.fix(0)
    assert bs2.toString() == "1001"
    assert bs2.count() == 2
    bs2.unfix(0); bs2.unfix(0); assert bs2.toString() == "0001"

    # 3) Multiple flips consistency
    bs3 = Bitset(3)
    bs3.flip(); bs3.flip(); bs3.fix(1)
    assert bs3.count() == 1 and bs3.one() and not bs3.all()
    assert bs3.toString() == "010"


if __name__ == "__main__":
    _tests_final()
\end{minted}
\VALIDATION{Exactly three assert groups: sample sequence, boundary/idempotency, and multi-flip consistency.}
\RESULT{Implements \texttt{Bitset} with $O(1)$ updates/queries (except \texttt{toString} $O(n)$), returning boolean results and a correct composition string.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests mirror the platform's operation arrays; verify transitions across \texttt{fix}/\texttt{unfix}/\texttt{flip} and invariants on \texttt{ones}. Include idempotent operations and boundary indices.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs. Improved on random short sequences to ensure behavioral equivalence.}
\LINE{EDGE-CASE GENERATOR}{Generate sequences stressing: repeated operations on same index, many flips, alternating fix/unfix at ends, and minimal/maximal sizes.}
\begin{minted}{python}
import random

def gen_ops(n_ops: int, n: int, seed: int = 0):
    random.seed(seed)
    ops = []
    for _ in range(n_ops):
        t = random.randint(0, 5)
        if t == 0:
            ops.append(("fix", random.randrange(n)))
        elif t == 1:
            ops.append(("unfix", random.randrange(n)))
        elif t == 2:
            ops.append(("flip",))
        elif t == 3:
            ops.append(("all",))
        elif t == 4:
            ops.append(("one",))
        else:
            ops.append(("count",))
    return ops

def run_ops(bitset, ops):
    out = []
    for op in ops:
        name = op[0]
        if name == "fix":
            bitset.fix(op[1]); out.append(None)
        elif name == "unfix":
            bitset.unfix(op[1]); out.append(None)
        elif name == "flip":
            bitset.flip(); out.append(None)
        elif name == "all":
            out.append(bitset.all())
        elif name == "one":
            out.append(bitset.one())
        elif name == "count":
            out.append(bitset.count())
        else:
            raise AssertionError("unknown op")
    out.append(bitset.toString())
    return out

def cross_check():
    from copy import deepcopy

    class BitsetA:
        def __init__(self, size: int):
            self.n = size
            self.a = [0] * size
        def fix(self, idx: int) -> None:
            if self.a[idx] == 0: self.a[idx] = 1
        def unfix(self, idx: int) -> None:
            if self.a[idx] == 1: self.a[idx] = 0
        def flip(self) -> None:
            for i in range(self.n): self.a[i] ^= 1
        def all(self) -> bool:
            return all(x == 1 for x in self.a)
        def one(self) -> bool:
            return any(self.a)
        def count(self) -> int:
            return sum(self.a)
        def toString(self) -> str:
            return "".join("1" if x else "0" for x in self.a)

    class BitsetB:
        def __init__(self, size: int):
            self.n = size
            self.bits = [0] * size
            self.flipped = False
            self.ones = 0
        def _view(self, idx: int) -> int:
            return self.bits[idx] ^ (1 if self.flipped else 0)
        def fix(self, idx: int) -> None:
            if self._view(idx) == 0:
                self.bits[idx] = 1 ^ (1 if self.flipped else 0)
                self.ones += 1
        def unfix(self, idx: int) -> None:
            if self._view(idx) == 1:
                self.bits[idx] = (1 if self.flipped else 0)
                self.ones -= 1
        def flip(self) -> None:
            self.flipped = not self.flipped
            self.ones = self.n - self.ones
        def all(self) -> bool:
            return self.ones == self.n
        def one(self) -> bool:
            return self.ones > 0
        def count(self) -> int:
            return self.ones
        def toString(self) -> str:
            f = 1 if self.flipped else 0
            return "".join("1" if (b ^ f) else "0" for b in self.bits)

    for n in [1, 2, 5, 8]:
        for seed in range(5):
            ops = gen_ops(50, n, seed=seed)
            a, b = BitsetA(n), BitsetB(n)
            outA = run_ops(a, ops)
            outB = run_ops(b, ops)
            assert outA == outB, (n, seed, ops, outA, outB)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Bitset:
    def __init__(self, size: int):
        self.n = size
        self.bits = [0] * size  # base storage; observed is bits[i] ^ flipped
        self.flipped = False
        self.ones = 0

    def _view(self, idx: int) -> int:
        return self.bits[idx] ^ (1 if self.flipped else 0)

    def fix(self, idx: int) -> None:
        if self._view(idx) == 0:
            self.bits[idx] = 1 ^ (1 if self.flipped else 0)
            self.ones += 1

    def unfix(self, idx: int) -> None:
        if self._view(idx) == 1:
            self.bits[idx] = (1 if self.flipped else 0)
            self.ones -= 1

    def flip(self) -> None:
        self.flipped = not self.flipped
        self.ones = self.n - self.ones

    def all(self) -> bool:
        return self.ones == self.n

    def one(self) -> bool:
        return self.ones > 0

    def count(self) -> int:
        return self.ones

    def toString(self) -> str:
        f = 1 if self.flipped else 0
        return "".join("1" if (b ^ f) else "0" for b in self.bits)


class Solution:
    pass


def _ref_tests():
    # Basic correctness
    b = Bitset(3)
    assert b.toString() == "000"
    b.fix(1); assert b.toString() == "010" and b.count() == 1
    b.flip(); assert b.toString() == "101" and b.count() == 2
    b.unfix(0); assert b.toString() == "001" and b.count() == 1
    assert b.one() and not b.all()

    # Idempotent ops
    b2 = Bitset(2)
    b2.unfix(0); b2.fix(1); b2.fix(1)
    assert b2.toString() == "01" and b2.count() == 1
    b2.flip(); b2.flip(); assert b2.toString() == "01"

    # Sample from prompt
    out = []
    bs = Bitset(5); out.append(None)
    bs.fix(3); out.append(None)
    bs.fix(1); out.append(None)
    bs.flip(); out.append(None)
    out.append(bs.all())
    bs.unfix(0); out.append(None)
    bs.flip(); out.append(None)
    out.append(bs.one())
    bs.unfix(0); out.append(None)
    out.append(bs.count())
    out.append(bs.toString())
    assert out == [None, None, None, None, False, None, None, True, None, 2, "01010"]


if __name__ == "__main__":
    _ref_tests()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Use a lazy flip flag plus a running ones counter to get $O(1)$ updates and queries, and build the string on demand.}
\WHY{A common design question testing state invariants, lazy propagation ideas, and time bound awareness for \texttt{toString}.}
\CHECKLIST{
\begin{bullets}
\item Track \texttt{n}, \texttt{flipped}, and \texttt{ones}.
\item Compute observed bit as \texttt{base ^ flipped}.
\item Update \texttt{ones} only when observed value changes.
\item On \texttt{flip}, toggle flag and set \texttt{ones = n - ones}.
\item Build \texttt{toString} by observing each bit.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Repeated \texttt{fix} or \texttt{unfix} on same index.
\item Flipping an all-zero or all-one bitset.
\item \texttt{n = 1} minimal size.
\item Operations at indices $0$ and $n-1$.
\item No-op sequences (e.g., flip twice).
\item At most $5$ \texttt{toString} calls — safe to use $O(n)$ build.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to update \texttt{ones} on \texttt{fix}/\texttt{unfix}.
\item Double-counting when \texttt{fix} called on an already-1 observed bit.
\item Implementing \texttt{flip} by touching all bits (slow).
\item Building \texttt{toString} from base bits without XOR with \texttt{flipped}.
\item Off-by-one indices.
\item Using Python truthiness carelessly; prefer explicit \texttt{0/1}.
\end{bullets}}
\FAILMODES{A naive \texttt{flip} that is $O(n)$ combined with many flips leads to $O(n \cdot q)}$ time. The lazy method avoids this by toggling a flag.}
\ELI{Think of wearing color-inverting glasses: instead of repainting all bulbs, just flip the glasses on and off. Keep a tally of how many lit bulbs you currently see, and update it only when something actually changes.}
\NotePages{3}

\end{document}