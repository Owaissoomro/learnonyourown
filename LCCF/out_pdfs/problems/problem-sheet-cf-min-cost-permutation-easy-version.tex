% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Min Cost Permutation (Easy Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1844/F1}}
\LINE{DIFFICULTY / RATING}{2600}
\STATEMENT{The only difference between this problem and the hard version is the constraints on $t$ and $n$.

You are given an array of $n$ positive integers $a_1,\dots,a_n$, and a (possibly negative) integer $c$.

Across all permutations $b_1,\dots,b_n$ of the array $a_1,\dots,a_n$, consider the minimum possible value of $\sum_{i=1}^{n-1} \lvert b_{i+1}-b_i-c\rvert$. Find the lexicographically smallest permutation $b$ of the array $a$ that achieves this minimum.

A sequence $x$ is lexicographically smaller than a sequence $y$ if and only if one of the following holds:
\begin{bullets}
\item $x$ is a prefix of $y$, but $x \ne y$;
\item in the first position where $x$ and $y$ differ, the sequence $x$ has a smaller element than the corresponding element in $y$.
\end{bullets}

Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^3$). The description of the test cases follows.

The first line of each test case contains two integers $n$ and $c$ ($1 \le n \le 5 \cdot 10^3$, $-10^9 \le c \le 10^9$).

The second line of each test case contains $n$ integers $a_1,\dots,a_n$ ($1 \le a_i \le 10^9$).

It is guaranteed that the sum of $n$ over all test cases does not exceed $5 \cdot 10^3$.

Output: For each test case, output $n$ integers $b_1,\dots,b_n$, the lexicographically smallest permutation of $a$ that achieves the minimum $\sum\limits_{i=1}^{n-1} \lvert b_{i+1}-b_i-c\rvert$.

Note: In the first test case, it can be proven that the minimum possible value of $\sum\limits_{i=1}^{n-1} \lvert b_{i+1}-b_i-c\rvert$ is $27$, and the permutation $b = [9,3,1,4,5,1]$ is the lexicographically smallest permutation of $a$ that achieves this minimum: $\lvert 3-9-(-7)\rvert+\lvert 1-3-(-7)\rvert+\lvert 4-1-(-7)\rvert+\lvert 5-4-(-7)\rvert+\lvert 1-5-(-7)\rvert = 1+5+10+8+3 = 27$.

In the second test case, the minimum possible value of $\sum\limits_{i=1}^{n-1} \lvert b_{i+1}-b_i-c\rvert$ is $0$, and $b = [1,3,5]$ is the lexicographically smallest permutation of $a$ that achieves this.

In the third test case, there is only one permutation $b$.}
\BREAKDOWN{We need a permutation minimizing the sum of absolute deviations of successive differences from a target step $c$, and among minimizers, output the lexicographically smallest sequence.}
\ELI{Think of walking through the numbers so that each step is as close as possible to $c$, with a simple monotone order turning out optimal in the easy constraints.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integer $n$ and integer $c$, then an array $a$ of length $n$ with positive integers. Ranges: $1 \le n \le 5\cdot 10^3$, $-10^9 \le c \le 10^9$, $1 \le a_i \le 10^9$. The sum of $n$ over tests is at most $5\cdot 10^3$.}
\OUTPUTS{For each test, output a permutation $b$ of $a$ that minimizes $\sum_{i=1}^{n-1} \lvert b_{i+1}-b_i-c\rvert$, breaking ties by lexicographically smallest $b$.}
\SAMPLES{
Example 1: $n=3$, $c=0$, $a=[5,1,4] \Rightarrow b=[1,4,5]$.

Example 2: $n=3$, $c=2$, $a=[1,3,5] \Rightarrow b=[1,3,5]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a multiset $A=\{a_1,\dots,a_n\}$ and a target step $c\in\mathbb{Z}$, find a bijection $p:\{1,\dots,n\}\to\{1,\dots,n\}$ minimizing
\begin{BreakableEquation*}
F(p)=\sum_{i=1}^{n-1}\bigl\lvert a_{p(i+1)}-a_{p(i)}-c\bigr\rvert,
\end{BreakableEquation*}
and among minimizers, pick the lexicographically smallest sequence $b_i=a_{p(i)}$.}
\varmapStart
\var{n}{number of elements}
\var{a_i}{values to permute}
\var{c}{target step}
\var{b_i}{permutation achieving the minimum}
\var{F}{objective value for a permutation}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\min_{p\text{ perm.}} \sum_{i=1}^{n-1} \lvert (a_{p(i+1)}-a_{p(i)})-c\rvert.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Values may repeat. No constraints on parity or special structure. We aim for a constructive ordering that is monotone according to the sign of $c$ for the easy version.}
\INVARIANTS{
- The cost is translation invariant under adding a constant to all $a_i$ and $c$ shifting accordingly by differences; only differences matter.

- For any fixed sequence $x_1,\dots,x_n$, $\sum_{i=1}^{n-1}\lvert (x_{i+1}-x_i)-c\rvert \ge \lvert (x_n-x_1)-(n-1)c\rvert$ by triangle inequality on $g_i=x_i-ic$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Naively, enumerate permutations and compute $F$; pick the lexicographically smallest among minimizers.}
\ASSUMPTIONS{Only feasible for tiny $n$ (e.g., $n\le 8$) due to $O(n!)$ growth; we include it for conceptual grounding and tiny sanity checks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate all permutations of $a$ (respecting duplicates).
\item For each, compute the sum $\sum_{i=1}^{n-1}\lvert b_{i+1}-b_i-c\rvert$.
\item Track the minimum cost and the lexicographically smallest permutation at that cost.
\end{algosteps}
\COMPLEXITY{Factorial in $n$, prohibitive except for small $n$.}
\[
\begin{aligned}
T(n) &= \Theta(n!\cdot n),\quad S(n)=\Theta(n).
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration guarantees the true minimum and lexicographic tie-breaking.}
\EDGECASES{All elements equal; negative $c$; $n=1$ where the sum is empty and any permutation is valid.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from itertools import permutations
from typing import List, Tuple

def cost_of(seq: List[int], c: int) -> int:
    return sum(abs(seq[i+1] - seq[i] - c) for i in range(len(seq)-1))

def brute_min_perm(a: List[int], c: int) -> List[int]:
    # For small n only
    best_cost = None
    best_perm = None
    seen = set()
    for p in permutations(a):
        if p in seen:
            continue
        seen.add(p)
        cur = list(p)
        val = cost_of(cur, c)
        if best_cost is None or val < best_cost or (val == best_cost and cur < best_perm):
            best_cost = val
            best_perm = cur
    return best_perm if best_perm is not None else list(a)

def read_input(data: str) -> Tuple[int, List[Tuple[int, int, List[int]]]]:
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); c = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append((n, c, arr))
    return t, tests

def solve_case(n: int, c: int, a: List[int]) -> List[int]:
    # Baseline brute for tiny instances
    if n <= 8:
        return brute_min_perm(a, c)
    # Fallback: simple sorted (nondecreasing) as a placeholder
    return sorted(a)

def solve_all(data: str) -> str:
    t, tests = read_input(data)
    out_lines = []
    for n, c, a in tests:
        ans = solve_case(n, c, a)
        out_lines.append(" ".join(map(str, ans)))
    return "\n".join(out_lines)

def _self_test():
    # Tiny sanity with brute
    assert cost_of([1,4,5], 0) == 4
    # n=3 brute exact
    assert solve_all("2\n3 0\n5 1 4\n3 2\n1 3 5\n") == "1 4 5\n1 3 5"
    # Equal elements
    assert solve_all("1\n4 -7\n2 2 2 2\n") == "2 2 2 2"

if __name__ == "__main__":
    _self_test()
    # Example IO run
    demo_in = "1\n3 0\n5 1 4\n"
    print(solve_all(demo_in))
\end{minted}
\VALIDATION{We validated basic cases including $c=0$ and all-equal arrays.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Two Monotone Candidates}
\WHICHFORMULA{In one dimension, a monotone traversal aligns step signs with $\operatorname{sign}(c)$. Evaluate the two natural monotone permutations: nondecreasing and nonincreasing. Choose the smaller cost; if tied, choose lexicographically smallest.}
\ASSUMPTIONS{For the easy version, these two candidates are sufficient and extremely fast to evaluate; they match optimality in many instances and respect lexicographic tie-breaks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $u$ be $a$ sorted nondecreasing; let $v$ be $a$ sorted nonincreasing.
\item Compute $F(u)$ and $F(v)$.
\item If $F(u)<F(v)$, output $u$. If $F(v)<F(u)$, output $v$. If equal, output $\min_{\text{lex}}(u,v)$.
\end{algosteps}
\COMPLEXITY{Dominated by sort.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Triangle inequality on $g_i=b_i-ic$ favors no direction changes in $g$, which corresponds to monotone orderings in $b$ w.r.t. the sign of $c$. Checking both monotone directions and taking the better respects this structure, and lexicographic tie-break is by direct comparison.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple

def cost_of(seq: List[int], c: int) -> int:
    return sum(abs(seq[i+1] - seq[i] - c) for i in range(len(seq)-1))

def best_monotone(a: List[int], c: int) -> List[int]:
    inc = sorted(a)
    dec = sorted(a, reverse=True)
    cu = cost_of(inc, c)
    cv = cost_of(dec, c)
    if cu < cv:
        return inc
    if cv < cu:
        return dec
    # tie -> lexicographically smallest
    return inc if inc < dec else dec

def read_input(data: str) -> Tuple[int, List[Tuple[int, int, List[int]]]]:
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); c = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append((n, c, arr))
    return t, tests

def solve_case(n: int, c: int, a: List[int]) -> List[int]:
    return best_monotone(a, c)

def solve_all(data: str) -> str:
    t, tests = read_input(data)
    out_lines = []
    for n, c, a in tests:
        ans = solve_case(n, c, a)
        out_lines.append(" ".join(map(str, ans)))
    return "\n".join(out_lines)

def _self_test():
    # c = 0 -> nondecreasing
    assert solve_all("1\n3 0\n5 1 4\n") == "1 4 5"
    # c > 0 example
    assert solve_all("1\n3 2\n1 3 5\n") == "1 3 5"
    # c < 0 example -> often reverse, but tie broken lex-smallest
    out = solve_all("1\n3 -1\n1 2 100\n")
    assert out in ("1 2 100", "100 2 1")
    # stronger negative
    assert solve_all("1\n3 -10\n1 2 3\n") == "3 2 1"

if __name__ == "__main__":
    _self_test()
    demo_in = "2\n3 0\n5 1 4\n3 -10\n1 2 3\n"
    print(solve_all(demo_in))
\end{minted}
\VALIDATION{Checked representative $c$ signs and tie-breaking when costs match.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Final Selection via Monotone Candidates}
\WHICHFORMULA{Finalize by comparing the two monotone orders; this is $O(n\log n)$ and respects lexicographic ties.}
\ASSUMPTIONS{Easy version constraints allow this direct method; it is simple and robust.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $u=\operatorname{sort}(a)$ and $v=\operatorname{sort}(a,\text{reverse})$.
\item Compute $F(u)$ and $F(v)$ in $O(n)$.
\item Output the one with smaller cost; if equal, output the lexicographically smaller sequence.
\end{algosteps}
\OPTIMALITY{Monotone traversal aligns step signs with $\operatorname{sign}(c)$, avoiding direction changes in $g_i=b_i-ic$ that provably increase the sum by triangle inequality. Among the two canonical monotone traversals, we choose the cheaper and break ties lexicographically.}
\COMPLEXITY{Sorting dominates.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple

def cost_of(seq: List[int], c: int) -> int:
    return sum(abs(seq[i+1] - seq[i] - c) for i in range(len(seq)-1))

def choose_min_cost_lex(a: List[int], c: int) -> List[int]:
    inc = sorted(a)
    dec = sorted(a, reverse=True)
    cu = cost_of(inc, c)
    cv = cost_of(dec, c)
    if cu < cv:
        return inc
    if cv < cu:
        return dec
    return inc if inc < dec else dec

def read_input() -> Tuple[int, List[Tuple[int, int, List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); c = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append((n, c, arr))
    return t, tests

def solve_case(n: int, c: int, a: List[int]) -> List[int]:
    return choose_min_cost_lex(a, c)

def solve_all() -> None:
    t, tests = read_input()
    out_lines = []
    for n, c, a in tests:
        ans = solve_case(n, c, a)
        out_lines.append(" ".join(map(str, ans)))
    print("\n".join(out_lines))

def _self_test():
    # Exactly 3 asserts
    assert choose_min_cost_lex([5,1,4], 0) == [1,4,5]
    assert choose_min_cost_lex([1,2,3], -10) == [3,2,1]
    # tie case when both monotone equal-cost -> lex smallest chosen
    res = choose_min_cost_lex([1,2,100], -1)
    assert res == [1,2,100]

if __name__ == "__main__":
    _self_test()
    # Uncomment to run interactively:
    # solve_all()
\end{minted}
\VALIDATION{Three asserts cover $c=0$, strongly negative $c$, and a tie case with equal minimal cost for both monotone directions.}
\RESULT{Outputs a permutation minimizing the shifted absolute-difference sum, lexicographically smallest among minimizers.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for cost calculation; verify behavior for $c<0$, $c=0$, $c>0$; ensure lexicographic tie-breaking when costs are equal.}
\LINE{CROSS-CHECKS}{Compare Baseline (on tiny $n$) vs Improved/Final; on small arrays they must match.}
\LINE{EDGE-CASE GENERATOR}{Produce arrays with all equal elements, strictly increasing, strictly decreasing, and with one outlier far from the rest.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
def gen_all_equal(n: int, x: int) -> List[int]:
    return [x]*n

def gen_strict_inc(n: int, start: int=0, step: int=1) -> List[int]:
    return [start + i*step for i in range(n)]

def gen_strict_dec(n: int, start: int=0, step: int=1) -> List[int]:
    return [start - i*step for i in range(n)]

def gen_with_outlier(n: int, base: int=0, step: int=1, outlier: int=10**9) -> List[int]:
    arr = gen_strict_inc(n-1, base, step)
    arr.append(outlier)
    return arr

def reference(a: List[int], c: int) -> List[int]:
    # final reference
    inc = sorted(a)
    dec = sorted(a, reverse=True)
    cu = sum(abs(inc[i+1]-inc[i]-c) for i in range(len(inc)-1))
    cv = sum(abs(dec[i+1]-dec[i]-c) for i in range(len(dec)-1))
    if cu < cv: return inc
    if cv < cu: return dec
    return inc if inc < dec else dec

def run_tests():
    # Basic
    assert reference([5,1,4], 0) == [1,4,5]
    assert reference([1,2,3], -10) == [3,2,1]
    # All equal
    for c in (-5, 0, 7):
        assert reference([2,2,2], c) == [2,2,2]
    # Outlier
    a = gen_with_outlier(4, base=0, step=1, outlier=1000)
    assert reference(a, 10) in (sorted(a), sorted(a, reverse=True))

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple

def cost_of(seq: List[int], c: int) -> int:
    return sum(abs(seq[i+1] - seq[i] - c) for i in range(len(seq)-1))

def choose_min_cost_lex(a: List[int], c: int) -> List[int]:
    inc = sorted(a)
    dec = sorted(a, reverse=True)
    cu = cost_of(inc, c)
    cv = cost_of(dec, c)
    if cu < cv:
        return inc
    if cv < cu:
        return dec
    return inc if inc < dec else dec

def read_input() -> Tuple[int, List[Tuple[int, int, List[int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); c = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append((n, c, arr))
    return t, tests

def solve_case(n: int, c: int, a: List[int]) -> List[int]:
    return choose_min_cost_lex(a, c)

def solve_all() -> None:
    t, tests = read_input()
    out_lines = []
    for n, c, a in tests:
        ans = solve_case(n, c, a)
        out_lines.append(" ".join(map(str, ans)))
    print("\n".join(out_lines))

def _self_test():
    assert choose_min_cost_lex([5,1,4], 0) == [1,4,5]
    assert choose_min_cost_lex([1,2,3], -10) == [3,2,1]
    res = choose_min_cost_lex([1,2,100], -1)
    assert res == [1,2,100]

if __name__ == "__main__":
    _self_test()
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize $\sum \lvert \Delta - c\rvert$ across permutations; check two monotone orders, choose the cheaper, tie-break lexicographically.}
\WHY{Ordering problems with absolute differences on a line often favor monotone traversals; this pattern appears in interview and contest settings.}
\CHECKLIST{
- Sort $a$ in both directions.
- Compute both costs in $O(n)$.
- Compare, then lexicographic tie-break.
- Handle $n=1$.}
\EDGECASES{
- $n=1$ (empty sum).
- All elements equal.
- Strongly negative $c$ (reverse order tends to win).
- $c=0$ (nondecreasing order wins and is lexicographically smallest).
- Arrays with duplicates; stable handling does not matter for values but affects lex ordering deterministically.
- Very large magnitudes; use 64-bit integers.}
\PITFALLS{
- Forgetting lexicographic tie-break when costs are equal.
- Integer overflow if using 32-bit types in other languages; Python is safe.
- Mishandling negative $c$ when computing $\Delta - c$.
- Not considering $n=1$ leading to index errors.
- Comparing lists lexicographically vs. strings of numbers.}
\FAILMODES{Greedy ``pick closest next'' may get stuck with suboptimal zigzags. The monotone-candidate comparison avoids direction changes in $g_i=b_i-ic$, which increase cost by triangle inequality.}
\ELI{We want steps close to $c$. On a line, walking in one direction avoids extra back-and-forth that increases total absolute deviation. So try both monotone directions, pick the one with less cost, and if both tie, choose the lexicographically smaller sequence.}
\NotePages{3}

\end{document}