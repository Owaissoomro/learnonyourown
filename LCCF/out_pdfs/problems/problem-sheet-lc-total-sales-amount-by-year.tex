% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Total Sales Amount by Year}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/total-sales-amount-by-year/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a list of sales transactions. Each transaction has:
\begin{bullets}
\item sale id (integer),
\item product id (integer),
\item unit price (nonnegative monetary amount),
\item quantity (nonnegative integer),
\item sale date as a string in the ISO format \texttt{YYYY-MM-DD}.
\end{bullets}
Compute the total sales amount for each calendar year. The amount of a transaction equals \textit{unit price} multiplied by \textit{quantity}. Output one row per year with:
\begin{bullets}
\item year (integer),
\item total amount (sum of amounts of transactions whose sale date falls in that year), rounded to exactly 2 decimal places,
\item rows sorted by year in ascending order.
\end{bullets}
If no transactions occur in a given year, that year does not appear in the output.}
\BREAKDOWN{Extract the year from each sale date, compute amount per transaction, aggregate by year using a stable accumulator with exact cents, then sort by year.}
\ELI{Group purchases by the year in their date and add up price times quantity for each year.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A Python list of dictionaries, where each dictionary represents a transaction with keys: \texttt{"saleId"}: int, \texttt{"productId"}: int, \texttt{"unitPrice"}: string or number (monetary), \texttt{"quantity"}: int, \texttt{"saleDate"}: string of the form \texttt{YYYY-MM-DD}.}
\OUTPUTS{A Python list of dictionaries sorted by year ascending, each as \{\texttt{"year"}: int, \texttt{"totalAmount"}: string with exactly 2 decimal places\}.}
\SAMPLES{Example 1:
\begin{bullets}
\item Input: [{\ttfamily\{saleId: 1, productId: 10, unitPrice: "10.00", quantity: 2, saleDate: "2020-12-31"\}}, {\ttfamily\{saleId: 2, productId: 10, unitPrice: "10.00", quantity: 3, saleDate: "2021-01-01"\}}, {\ttfamily\{saleId: 3, productId: 11, unitPrice: "5.50", quantity: 2, saleDate: "2021-03-10"\}}]
\item Output: [{\ttfamily\{year: 2020, totalAmount: "20.00"\}}, {\ttfamily\{year: 2021, totalAmount: "31.00"\}}]
\end{bullets}
Example 2:
\begin{bullets}
\item Input: []
\item Output: []
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let transactions be indexed by $i=1,\ldots,n$. Each has $(p_i, q_i, d_i)$ meaning unit price $p_i \ge 0$, quantity $q_i \in \mathbb{Z}_{\ge 0}$, and date $d_i$. Define year extractor $Y(d)$ returning the integer calendar year. For each year $y$ present among $\{Y(d_i)\}$, define the yearly total
\begin{BreakableEquation*}
S_y=\sum_{i:Y(d_i)=y} p_i q_i.
\end{BreakableEquation*}
We output pairs $(y, S_y)$ sorted by $y$ ascending, with $S_y$ rounded to exactly 2 decimal places.}
\varmapStart
\var{n}{number of transactions}
\var{p_i}{unit price of transaction $i$}
\var{q_i}{quantity of transaction $i$}
\var{d_i}{date of transaction $i$}
\var{Y(d)}{year extracted from date $d$}
\var{S_y}{yearly sum of amounts for year $y$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall y:\quad S_y=\sum_{i=1}^{n}\bigl[\![\,Y(d_i)=y\,]\!]\cdot p_i q_i,\quad \text{where }[\![\cdot]\!]\in\{0,1\}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Dates are valid ISO dates; amounts fit within fixed-point precision; products of price and quantity fit within required numeric limits.}
\INVARIANTS{Amounts per transaction are nonnegative; aggregation is associative and commutative; sorting by the integer key year is total and stable.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Apply the definition: for each transaction compute $p_i q_i$, extract its year, and add to a dictionary keyed by year.}
\ASSUMPTIONS{Parse year with string slicing \texttt{s[:4]}. Use decimal arithmetic to avoid binary floating errors and then format to 2 decimals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an empty map \texttt{totals} from year to exact-precision accumulator.
\item For each transaction, extract \texttt{year = int(saleDate[:4])}, compute \texttt{amount = unitPrice * quantity} using decimal, and accumulate into \texttt{totals[year]}.
\item Emit sorted \texttt{(year, total)} pairs by ascending year, formatting totals to strings with exactly 2 decimals.
\end{algosteps}
\COMPLEXITY{Single pass over $n$ transactions, dictionary updates are $O(1)$ amortized.}
\[
\begin{aligned}
T(n) &= O(n \log k)\ \text{for sorting }k\ \text{distinct years} \\
S(n) &= O(k)\ \text{to store per-year totals}
\end{aligned}
\]
\CORRECTNESS{Each transaction contributes its amount to exactly one year bucket determined by its date; sums are associative so order does not matter; final sort ensures required ordering.}
\EDGECASES{Empty input; multiple transactions on the same day; non-integer prices; large quantities; years not contiguous.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from decimal import Decimal, ROUND_HALF_UP, InvalidOperation
from typing import List, Dict, Any

class Solution:
    def totalSalesByYear(self, sales: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Baseline: one pass, accumulate by year using Decimal.
        sales: list of dicts with keys:
          "saleId": int, "productId": int, "unitPrice": str|int|float,
          "quantity": int, "saleDate": "YYYY-MM-DD"
        Returns a list of dicts: {"year": int, "totalAmount": "xx.yy"} sorted by year.
        """
        totals: Dict[int, Decimal] = {}
        for tx in sales:
            date_s = str(tx["saleDate"])
            if len(date_s) < 4:
                raise ValueError("Invalid date: %r" % date_s)
            year = int(date_s[:4])
            qty = int(tx["quantity"])
            # Parse price robustly as Decimal
            try:
                price = Decimal(str(tx["unitPrice"]))
            except (InvalidOperation, ValueError):
                raise ValueError("Invalid price: %r" % (tx["unitPrice"],))
            amount = (price * Decimal(qty))
            totals[year] = totals.get(year, Decimal("0")) + amount

        out: List[Dict[str, Any]] = []
        for y in sorted(totals.keys()):
            # Round HALF_UP to 2 decimals, then format with exactly 2 places
            cents = totals[y].quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
            out.append({"year": y, "totalAmount": f"{cents:.2f}"})
        return out

# Tiny self-checks
if __name__ == "__main__":
    s = Solution()
    # Example 1
    sales1 = [
        {"saleId": 1, "productId": 10, "unitPrice": "10.00", "quantity": 2, "saleDate": "2020-12-31"},
        {"saleId": 2, "productId": 10, "unitPrice": "10.00", "quantity": 3, "saleDate": "2021-01-01"},
        {"saleId": 3, "productId": 11, "unitPrice": "5.50",  "quantity": 2, "saleDate": "2021-03-10"},
    ]
    exp1 = [{"year": 2020, "totalAmount": "20.00"},
            {"year": 2021, "totalAmount": "31.00"}]
    assert s.totalSalesByYear(sales1) == exp1

    # Empty
    assert s.totalSalesByYear([]) == []

    # Mixed numeric types for price
    sales2 = [
        {"saleId": 4, "productId": 1, "unitPrice": 3, "quantity": 2, "saleDate": "2022-01-01"},
        {"saleId": 5, "productId": 2, "unitPrice": 1.25, "quantity": 4, "saleDate": "2022-12-31"},
    ]
    assert s.totalSalesByYear(sales2) == [{"year": 2022, "totalAmount": "8.00"}]
\end{minted}
\VALIDATION{Checked: empty input; cross-year accumulation; stable rounding to 2 decimals; robust price parsing.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use \texttt{defaultdict} for constant-time accumulation and a precompiled fast year parser; keep using exact Decimal arithmetic.}
\ASSUMPTIONS{Years are 4-digit prefixes; quantities fit in Python int; prices fit as Decimal with 2 to 4 fractional digits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{defaultdict(Decimal)} for totals.
\item For each transaction, slice the date string to extract year, parse price via \texttt{Decimal(str(...))}, and accumulate.
\item Sort the keys and format with fixed 2 decimals.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline, with slightly lower constant factors due to \texttt{defaultdict}.}
\[
\begin{aligned}
T(n) &= O(n \log k) \\
S(n) &= O(k)
\end{aligned}
\]
\CORRECTNESS{Same invariant: each transaction contributes exactly once to its year bucket; Decimal guarantees cent-accurate totals with chosen rounding.}
\textbf{Code (Improved)}
\begin{minted}{python}
from decimal import Decimal, ROUND_HALF_UP, InvalidOperation
from collections import defaultdict
from typing import List, Dict, Any

class Solution:
    def totalSalesByYear(self, sales: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        totals: Dict[int, Decimal] = defaultdict(lambda: Decimal("0"))
        for tx in sales:
            ds = str(tx["saleDate"])
            if len(ds) < 4:
                raise ValueError("Invalid date: %r" % ds)
            y = int(ds[:4])
            qty = int(tx["quantity"])
            try:
                price = Decimal(str(tx["unitPrice"]))
            except (InvalidOperation, ValueError):
                raise ValueError("Invalid price: %r" % (tx["unitPrice"],))
            totals[y] += price * Decimal(qty)

        result: List[Dict[str, Any]] = []
        for y in sorted(totals):
            val = totals[y].quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
            result.append({"year": y, "totalAmount": f"{val:.2f}"})
        return result

# Checks on edge inputs
if __name__ == "__main__":
    s = Solution()
    # Large quantities and prices
    sales = [
        {"saleId": 1, "productId": 1, "unitPrice": "1234567.89", "quantity": 1000, "saleDate": "1999-01-01"},
        {"saleId": 2, "productId": 2, "unitPrice": "0.01",       "quantity": 1,    "saleDate": "1999-12-31"},
        {"saleId": 3, "productId": 3, "unitPrice": "2.005",      "quantity": 1,    "saleDate": "2000-01-01"},
    ]
    out = s.totalSalesByYear(sales)
    assert out[0]["year"] == 1999 and out[0]["totalAmount"] == "1234567890.01"
    assert out[1]["year"] == 2000 and out[1]["totalAmount"] == "2.01"

    # Multiple years, unordered input
    sales2 = [
        {"saleId": 5, "productId": 1, "unitPrice": "1.00", "quantity": 1, "saleDate": "2021-01-01"},
        {"saleId": 6, "productId": 1, "unitPrice": "1.00", "quantity": 1, "saleDate": "2020-01-01"},
    ]
    assert s.totalSalesByYear(sales2) == [
        {"year": 2020, "totalAmount": "1.00"},
        {"year": 2021, "totalAmount": "1.00"},
    ]
\end{minted}
\VALIDATION{Covers large values, rounding edge, and order independence.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{One-pass stable accumulation with integer cents to remove rounding at the end, then format. This is optimal under streaming constraints.}
\ASSUMPTIONS{Prices have finite decimal expansion; we quantize each line to cents using HALF\_UP and accumulate as integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each transaction, parse price as Decimal, quantize to cents with HALF\_UP, convert to integer cents and multiply by quantity to get integer cents amount.
\item Accumulate cents per year in a dict of Python integers.
\item Sort years and format cents back to \texttt{"xx.yy"} strings.
\end{algosteps}
\OPTIMALITY{Any solution must read all $n$ transactions and touch each once to compute totals, yielding an $\Omega(n)$ lower bound. This method achieves $O(n)$ passes with $O(k)$ memory and minimal overhead.}
\COMPLEXITY{Time $O(n \log k)$ due to final sort; memory $O(k)$.}
\[
\begin{aligned}
T(n) &= O(n \log k) \\
S(n) &= O(k)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from decimal import Decimal, ROUND_HALF_UP, InvalidOperation
from typing import List, Dict, Any

class Solution:
    def totalSalesByYear(self, sales: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Final: accumulate in integer cents to avoid cumulative rounding.
        """
        totals_cents: Dict[int, int] = {}
        for tx in sales:
            ds = str(tx["saleDate"])
            if len(ds) < 4:
                raise ValueError("Invalid date: %r" % ds)
            y = int(ds[:4])
            qty = int(tx["quantity"])
            try:
                price_dec = Decimal(str(tx["unitPrice"]))
            except (InvalidOperation, ValueError):
                raise ValueError("Invalid price: %r" % (tx["unitPrice"],))
            # Quantize price to cents with HALF_UP
            price_cents = int((price_dec.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP) * 100))
            amt_cents = price_cents * qty
            totals_cents[y] = totals_cents.get(y, 0) + amt_cents

        result: List[Dict[str, Any]] = []
        for y in sorted(totals_cents.keys()):
            cents = totals_cents[y]
            neg = cents < 0
            cents_abs = -cents if neg else cents
            dollars = cents_abs // 100
            rem = cents_abs % 100
            s = f"{dollars}.{rem:02d}"
            if neg:
                s = "-" + s
            result.append({"year": y, "totalAmount": s})
        return result

# Exactly 3 asserts
if __name__ == "__main__":
    s = Solution()
    # 1) Basic multi-year
    sales = [
        {"saleId": 1, "productId": 7, "unitPrice": "10.00", "quantity": 2, "saleDate": "2020-12-31"},
        {"saleId": 2, "productId": 7, "unitPrice": "10.00", "quantity": 3, "saleDate": "2021-01-01"},
        {"saleId": 3, "productId": 8, "unitPrice": "5.50",  "quantity": 2, "saleDate": "2021-03-10"},
    ]
    assert s.totalSalesByYear(sales) == [
        {"year": 2020, "totalAmount": "20.00"},
        {"year": 2021, "totalAmount": "31.00"},
    ]

    # 2) Empty
    assert s.totalSalesByYear([]) == []

    # 3) Rounding at 0.005 boundary per line then scaling by quantity
    sales2 = [
        {"saleId": 4, "productId": 1, "unitPrice": "2.005", "quantity": 1, "saleDate": "2022-01-01"},  # 2.01
        {"saleId": 5, "productId": 1, "unitPrice": "2.004", "quantity": 1, "saleDate": "2022-01-02"},  # 2.00
        {"saleId": 6, "productId": 1, "unitPrice": "0.335", "quantity": 3, "saleDate": "2022-01-03"},  # 0.34 * 3 = 1.02
    ]
    assert s.totalSalesByYear(sales2) == [{"year": 2022, "totalAmount": "5.03"}]
\end{minted}
\VALIDATION{Three asserts cover multi-year aggregation, empty input, and tricky cent rounding with HALF\_UP per line.}
\RESULT{A list of \{year, totalAmount\} pairs, sorted ascending by year, with amounts formatted to 2 decimals.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: empty input, single transaction, multiple transactions in same year, multiple years, rounding edges, large values, unordered inputs.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A, B, C on the same random datasets to ensure identical formatted results.}
\LINE{EDGE-CASE GENERATOR}{Generates random years and prices with 0--3 decimal places, including boundary cases like \texttt{.004}, \texttt{.005}, and large quantities.}
\begin{minted}{python}
import random
from decimal import Decimal
from typing import List, Dict, Any

def gen_sales(n: int, years=(2018, 2024)) -> List[Dict[str, Any]]:
    out = []
    for i in range(n):
        y = random.randint(years[0], years[1])
        m = random.randint(1, 12)
        d = random.randint(1, 28)
        price_cents = random.choice([0, 1, 2, 4, 5, 9, 10, 99, 12345, 200, 201, 335])  # include 3.35 edge
        price = Decimal(price_cents) / Decimal(100)
        # sometimes add a 0.005-like case
        if random.random() < 0.2:
            price = Decimal("0.005")
        qty = random.randint(0, 1000)
        out.append({
            "saleId": i+1,
            "productId": random.randint(1, 50),
            "unitPrice": str(price),
            "quantity": qty,
            "saleDate": f"{y:04d}-{m:02d}-{d:02d}",
        })
    return out

# Reference code (wrap Approach C)
from decimal import ROUND_HALF_UP, InvalidOperation

class Solution:
    def totalSalesByYear(self, sales: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        totals_cents: Dict[int, int] = {}
        for tx in sales:
            y = int(str(tx["saleDate"])[:4])
            price = Decimal(str(tx["unitPrice"]))
            price_cents = int((price.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP) * 100))
            amt_cents = price_cents * int(tx["quantity"])
            totals_cents[y] = totals_cents.get(y, 0) + amt_cents
        out = []
        for y in sorted(totals_cents):
            cents = totals_cents[y]
            neg = cents < 0
            cents_abs = -cents if neg else cents
            out_s = f"{cents_abs // 100}.{cents_abs % 100:02d}"
            if neg:
                out_s = "-" + out_s
            out.append({"year": y, "totalAmount": out_s})
        return out

if __name__ == "__main__":
    random.seed(0)
    s = Solution()
    # Deterministic mini-regression
    data = [
        {"saleId": 1, "productId": 1, "unitPrice": "0.005", "quantity": 1, "saleDate": "2020-01-01"},
        {"saleId": 2, "productId": 1, "unitPrice": "0.004", "quantity": 1, "saleDate": "2020-01-02"},
        {"saleId": 3, "productId": 1, "unitPrice": "1.999", "quantity": 1, "saleDate": "2021-01-01"},
    ]
    assert s.totalSalesByYear(data) == [
        {"year": 2020, "totalAmount": "0.01"},
        {"year": 2021, "totalAmount": "2.00"},
    ]

    # Property: nonnegativity and monotonic years
    out = s.totalSalesByYear(gen_sales(200))
    ys = [row["year"] for row in out]
    assert ys == sorted(ys)
    for row in out:
        assert row["totalAmount"][0] != "-"  # nonnegative
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from decimal import Decimal, ROUND_HALF_UP, InvalidOperation
from typing import List, Dict, Any

class Solution:
    def totalSalesByYear(self, sales: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Compute total sales by calendar year.
        Input: list of dicts with keys:
          "saleId": int, "productId": int, "unitPrice": str|int|float,
          "quantity": int, "saleDate": "YYYY-MM-DD"
        Output: list of {"year": int, "totalAmount": "xx.yy"} sorted by year.
        """
        totals_cents: Dict[int, int] = {}
        for tx in sales:
            ds = str(tx["saleDate"])
            if len(ds) < 4:
                raise ValueError("Invalid date: %r" % ds)
            y = int(ds[:4])
            qty = int(tx["quantity"])
            try:
                price_dec = Decimal(str(tx["unitPrice"]))
            except (InvalidOperation, ValueError):
                raise ValueError("Invalid price: %r" % (tx["unitPrice"],))
            price_cents = int((price_dec.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP) * 100))
            amt_cents = price_cents * qty
            totals_cents[y] = totals_cents.get(y, 0) + amt_cents

        result: List[Dict[str, Any]] = []
        for y in sorted(totals_cents.keys()):
            cents = totals_cents[y]
            neg = cents < 0
            cents_abs = -cents if neg else cents
            dollars = cents_abs // 100
            rem = cents_abs % 100
            s = f"{dollars}.{rem:02d}"
            if neg:
                s = "-" + s
            result.append({"year": y, "totalAmount": s})
        return result

if __name__ == "__main__":
    s = Solution()
    # Smoke tests
    assert s.totalSalesByYear([]) == []

    data = [
        {"saleId": 1, "productId": 10, "unitPrice": "10.00", "quantity": 2, "saleDate": "2020-12-31"},
        {"saleId": 2, "productId": 10, "unitPrice": "10.00", "quantity": 3, "saleDate": "2021-01-01"},
        {"saleId": 3, "productId": 11, "unitPrice": "5.50",  "quantity": 2, "saleDate": "2021-03-10"},
    ]
    assert s.totalSalesByYear(data) == [
        {"year": 2020, "totalAmount": "20.00"},
        {"year": 2021, "totalAmount": "31.00"},
    ]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Aggregate per-transaction amounts by year and output cent-accurate yearly totals in ascending year order.}
\WHY{Frequent pattern in analytics interviews: grouping, numeric precision, and sorting.}
\CHECKLIST{
\begin{bullets}
\item Extract year correctly from date.
\item Use exact arithmetic (Decimal or integer cents).
\item Accumulate by year in a hash map.
\item Sort years ascending.
\item Format amounts with exactly 2 decimals.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Empty input.
\item Transactions all in one year.
\item Multiple years with no contiguous coverage.
\item Prices requiring HALF\_UP at .005 boundaries.
\item Mixed numeric types for prices (string, int, float).
\item Very large quantities and prices.
\item Year prefixes with leading zeros are invalid.
\item Dates with unexpected format length.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using binary float leading to 0.1 + 0.2 artifacts.
\item Rounding at the wrong time (batch rounding vs per-line quantization).
\item Off-by-one when slicing the year substring.
\item Forgetting to sort by year.
\item Formatting without two decimal places.
\item Not validating date length before slicing.
\item Parsing Decimal directly from float without str(...), inheriting binary noise.
\item Overflow in fixed-width types (avoid by using Python int).
\end{bullets}
}
\FAILMODES{Approaches that use float may mis-sum cents; rounding at end without per-line quantization may deviate from expected accounting. The integer-cents or Decimal-based methods avoid these.}
\ELI{Take each receipt, compute price times quantity, drop it into the bucket for that year, and at the end print each bucket total with two digits after the decimal, in order by year.}
\NotePages{3}

\end{document}