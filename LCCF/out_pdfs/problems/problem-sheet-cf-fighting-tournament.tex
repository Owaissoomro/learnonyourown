% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Fighting Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1719/C}}
\LINE{DIFFICULTY / RATING}{1400}
\STATEMENT{Burenka is about to watch the most interesting sporting event of the year — a fighting tournament organized by her friend Tonya.

$n$ athletes participate in the tournament, numbered from $1$ to $n$. Burenka determined the strength of the $i$-th athlete as an integer $a_i$, where $1 \le a_i \le n$. All the strength values are different, that is, the array $a$ is a permutation of length $n$. We know that in a fight, if $a_i > a_j$, then the $i$-th participant always wins the $j$-th.

The tournament goes like this: initially, all $n$ athletes line up in ascending order of their ids, and then there are infinitely many fighting rounds. In each round there is exactly one fight: the first two people in line come out and fight. The winner goes back to the front of the line, and the loser goes to the back.

Burenka decided to ask Tonya $q$ questions. In each question, Burenka asks how many victories the $i$-th participant gets in the first $k$ rounds of the competition for some given numbers $i$ and $k$. Tonya is not very good at analytics, so he asks you to help him answer all the questions.

Input:
The first line contains one integer $t$ ($1 \le t \le 10^4$) — the number of test cases. Description of the test cases follows.

The first line of each test case contains two integers $n$ and $q$ ($2 \le n \le 10^5$, $1 \le q \le 10^5$) — the number of tournament participants and the number of questions.

The second line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le n$) — the array $a$, which is a permutation.

The next $q$ lines of a test case contain questions. Each line contains two integers $i$ and $k$ ($1 \le i \le n$, $1 \le k \le 10^9$) — the number of the participant and the number of rounds.

It is guaranteed that the sum of $n$ and the sum of $q$ over all test cases do not exceed $10^5$.

Output:
For each Burenka's question, print a single line containing one integer — the answer to the question.

Note:
In the first test case, the first numbered athlete has the strength of $3$, in the first round he will defeat the athlete with the number $2$ and the strength of $1$, and in the second round, the athlete with the number $3$ and the strength of $2$.

In the second test case, we list the strengths of the athletes fighting in the first $5$ fights: $1$ and $3$, $3$ and $4$, $4$ and $2$, $4$ and $1$, $4$ and $3$. The participant with the number $4$ in the first $5$ rounds won $0$ times (his strength is $2$). The participant with the number $3$ has a strength of $4$ and won $1$ time in the first two fights by fighting $1$ time.}
\BREAKDOWN{Simulate the deterministic queue of fights until the strongest athlete reaches the front; before that, record at which round each athlete wins. After the strongest reaches the front, that athlete wins every subsequent round. Answer queries by counting wins $\le k$ from precomputed rounds, with a special formula for the strongest.}
\ELI{Everyone keeps fighting the front champion; once the absolute strongest gets to the front, they win forever.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test:
\begin{bullets}
\item $n$ (participants), $q$ (queries).
\item Permutation $a_1,\ldots,a_n$ of $\{1,\ldots,n\}$, where $a_i$ is strength of participant $i$.
\item $q$ queries; each is $(i,k)$ asking how many wins participant $i$ gets in the first $k$ rounds.
\end{bullets}
Constraints: $2 \le n \le 10^5$, $1 \le q \le 10^5$, $1 \le k \le 10^9$, total $\sum n \le 10^5$, total $\sum q \le 10^5$.}
\OUTPUTS{For each query, print a single integer on its own line: the number of wins of participant $i$ within the first $k$ rounds. Maintain input order across test cases.}
\SAMPLES{Example 1
\begin{tcolorbox}
Input
\begin{verbatim}
1
3 3
3 1 2
1 1
1 2
3 5
\end{verbatim}
Output
\begin{verbatim}
1
2
0
\end{verbatim}
\end{tcolorbox}
Example 2
\begin{tcolorbox}
Input
\begin{verbatim}
1
4 4
1 3 4 2
4 5
3 2
2 1
2 10
\end{verbatim}
Output
\begin{verbatim}
0
1
1
1
\end{verbatim}
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the initial queue be $Q_0=(1,2,\ldots,n)$. At round $r\ge 1$, the first two indices $(x_r,y_r)$ fight; the winner $w_r=\arg\max(a_{x_r},a_{y_r})$ stays in front and the loser goes to the back, producing $Q_r$. Define $R_i=\{r : w_r=i\}$ the set of rounds in which participant $i$ wins. Let $p^\star=\arg\max_j a_j$ (unique). Then once $p^\star$ wins the first time at round $r^\star=\min R_{p^\star}$, we have $w_r=p^\star$ for all $r \ge r^\star$. Queries ask for $|R_i \cap \{1,\ldots,k\}|$.}
\varmapStart
\var{n}{number of athletes}
\var{a_i}{strength of athlete $i$; permutation of $1..n$}
\var{p^\star}{index of the strongest athlete ($a_{p^\star}=n$)}
\var{R_i}{sorted list of win rounds for athlete $i$ before $p^\star$ dominates}
\var{r^\star}{first win round of $p^\star$}
\var{k}{query horizon (rounds prefix length)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
R_i &= \{\, r \ge 1 : \text{winner at round } r \text{ is } i \,\}, \\
r^\star &= \min R_{p^\star}, \\
\forall r \ge r^\star&:~ w_r = p^\star, \\
\text{Ans}(i,k) &= 
\begin{cases}
|R_i \cap \{1,\ldots,k\}|, & i \ne p^\star, \\
0, & i=p^\star,~k<r^\star, \\
k-r^\star+1, & i=p^\star,~k \ge r^\star~.
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{Strengths are a strict total order; no ties. The process is deterministic.}
\INVARIANTS{
\begin{bullets}
\item The front element after each round is the maximum strength among all athletes seen at front up to that time.
\item Once the global maximum reaches the front, it never loses thereafter.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the queue round by round until the strongest reaches front, recording the round indices each athlete wins. Use binary search on those rounds to answer queries.}
\ASSUMPTIONS{We can simulate in $O(n)$ per test case; this is feasible because $\sum n \le 10^5$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Identify $p^\star=\arg\max a_i$.
\item Use a deque of indices $[1,2,\ldots,n]$; at each round, pop the first two, compare strengths, push winner to front and loser to back.
\item Record the round number for the winner; stop when the winner is $p^\star$ (its first win).
\item For query $(i,k)$: if $i \ne p^\star$, answer is number of recorded wins $\le k$; else answer is $\max(0, k-r^\star+1)$.
\end{algosteps}
\COMPLEXITY{Precompute in $O(n)$ per test. Each query answered in $O(\log n)$ via upper\_bound; total $O(n+q\log n)$ per test.}
\[
\begin{aligned}
T(n,q) &= O(n) + O(q\log n), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{All wins before $p^\star$ reaches front are explicitly recorded. After that, no one else can win, and $p^\star$ wins every round; the closed form $\max(0,k-r^\star+1)$ counts wins in $\{r^\star,\ldots,k\}$.}
\EDGECASES{Participant is already strongest at index $1$ ($r^\star=1$); queries with large $k$; participants that never win; $n=2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque
import sys
from bisect import bisect_right

def read_input():
    return sys.stdin.buffer.read().split()

def solve_case(n, q, a, queries):
    # a is 1-indexed conceptually; store as 0-indexed list but refer by 1-based ids.
    # Find index of strongest (value n)
    pmax = a.index(max(a)) + 1  # 1-based id
    dq = deque(range(1, n + 1))
    wins = [[] for _ in range(n + 1)]
    r = 1
    rstar = None
    while True:
        i = dq[0]
        j = dq[1]
        if a[i - 1] > a[j - 1]:
            w, l = i, j
        else:
            w, l = j, i
        dq.popleft()
        dq.popleft()
        dq.appendleft(w)
        dq.append(l)
        wins[w].append(r)
        if w == pmax:
            rstar = r
            break
        r += 1
    # Answer queries
    ans = []
    for (i, k) in queries:
        if i == pmax:
            if k < rstar:
                ans.append(0)
            else:
                ans.append(k - rstar + 1)
        else:
            # Only wins before rstar exist for others
            cnt = bisect_right(wins[i], k)
            ans.append(cnt)
    return ans

def solve_all(tokens):
    it = iter(tokens)
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        queries = [(int(next(it)), int(next(it))) for _ in range(q)]
        res = solve_case(n, q, a, queries)
        out_lines.extend(str(x) for x in res)
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    # Test 1
    n, q = 3, 3
    a = [3, 1, 2]
    queries = [(1, 1), (1, 2), (3, 5)]
    assert solve_case(n, q, a, queries) == [1, 2, 0]
    # Test 2 (from statement narrative)
    n, q = 4, 4
    a = [1, 3, 4, 2]
    queries = [(4, 5), (3, 2), (2, 1), (2, 10)]
    assert solve_case(n, q, a, queries) == [0, 1, 1, 1]
    # Edge: n=2
    n, q = 2, 4
    a = [2, 1]
    queries = [(1, 1), (1, 5), (2, 1), (2, 5)]
    assert solve_case(n, q, a, queries) == [1, 5, 0, 0]

def main():
    tokens = read_input()
    if not tokens:
        return
    solve_all(tokens)

if __name__ == "__main__":
    _self_test()
    main()
\end{minted}
\VALIDATION{Checked on two crafted examples and an $n=2$ edge case via asserts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prefix Maximum Champion and Win Indices}
\WHICHFORMULA{The champion at the front after each round is exactly the prefix maximum of strengths observed in order. Therefore, we only need to simulate until the global maximum appears at the front, recording win rounds for each temporary champion.}
\ASSUMPTIONS{Permutation strengths imply a unique global maximum; queue operations are $O(1)$ via deque; win rounds are strictly increasing for each participant.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $p^\star$ and simulate as in Approach A until its first win $r^\star$.
\item For each $i \ne p^\star$, keep a sorted list $R_i$ of win rounds; for each query, return $|R_i \cap \{1,\ldots,k\}|$ by upper\_bound.
\item For $i=p^\star$, return $\max(0,k-r^\star+1)$ directly.
\end{algosteps}
\COMPLEXITY{Same as Approach A but with clear invariant use: $O(n+q\log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n,q) &= O(n) + O(q\log n).
\end{aligned}
\]
\CORRECTNESS{The prefix-maximum champion is the only possible multi-winner before $p^\star$; once $p^\star$ is in front, it deterministically wins all future rounds.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque
import sys
from bisect import bisect_right

def read_input():
    return sys.stdin.buffer.read().split()

def solve_case(n, q, a, queries):
    pmax = a.index(n) + 1
    dq = deque(range(1, n + 1))
    wins = [[] for _ in range(n + 1)]
    r = 1
    while True:
        x, y = dq[0], dq[1]
        if a[x - 1] > a[y - 1]:
            w, l = x, y
        else:
            w, l = y, x
        dq.popleft(); dq.popleft()
        dq.appendleft(w); dq.append(l)
        wins[w].append(r)
        if w == pmax:
            rstar = r
            break
        r += 1
    ans = []
    for i, k in queries:
        if i == pmax:
            ans.append(0 if k < rstar else k - rstar + 1)
        else:
            ans.append(bisect_right(wins[i], k))
    return ans

def solve_all(tokens):
    it = iter(tokens)
    t = int(next(it))
    out = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        queries = [(int(next(it)), int(next(it))) for _ in range(q)]
        out.extend(map(str, solve_case(n, q, a, queries)))
    sys.stdout.write("\n".join(out))

def _self_test():
    # Same checks as baseline to ensure identical behavior
    assert solve_case(3, 3, [3,1,2], [(1,1),(1,2),(3,5)]) == [1,2,0]
    assert solve_case(4, 4, [1,3,4,2], [(4,5),(3,2),(2,1),(2,10)]) == [0,1,1,1]
    assert solve_case(2, 4, [2,1], [(1,1),(1,5),(2,1),(2,5)]) == [1,5,0,0]

def main():
    tokens = read_input()
    if not tokens:
        return
    solve_all(tokens)

if __name__ == "__main__":
    _self_test()
    main()
\end{minted}
\VALIDATION{Mirrors Approach A's asserts to confirm identical outputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Precompute Win Rounds and Closed Form for the Strongest}
\WHICHFORMULA{Same as Approach B, which is already optimal for constraints: simulate $O(n)$ rounds once, store per-athlete win rounds, answer queries via binary search and a closed form for the strongest.}
\ASSUMPTIONS{Permutation, unique $p^\star$, and $\sum(n+q) \le 10^5$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Single pass simulation until $p^\star$ wins first time; record $R_i$.
\item Answer $(i,k)$ by $\text{upper\_bound}(R_i,k)$ if $i\ne p^\star$, else $\max(0,k-r^\star+1)$.
\item Output answers in input order.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must, in the worst case, examine the permutation ($\Omega(n)$) and read all queries ($\Omega(q)$). Per-query $O(\log n)$ is optimal here given arbitrary $k$ without precomputing a full prefix array for every $i$.}
\COMPLEXITY{Time $O(n+q\log n)$; space $O(n)$.}
\[
\begin{aligned}
T(n,q) &= O(n) + O(q\log n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import deque
from bisect import bisect_right
import sys

def read_input():
    return sys.stdin.buffer.read().split()

def solve_case(n, q, a, queries):
    pmax = a.index(n) + 1
    dq = deque(range(1, n + 1))
    wins = [[] for _ in range(n + 1)]
    r = 1
    while True:
        i, j = dq[0], dq[1]
        if a[i - 1] > a[j - 1]:
            w, l = i, j
        else:
            w, l = j, i
        dq.popleft(); dq.popleft()
        dq.appendleft(w); dq.append(l)
        wins[w].append(r)
        if w == pmax:
            rstar = r
            break
        r += 1
    out = []
    for i, k in queries:
        if i == pmax:
            out.append(0 if k < rstar else k - rstar + 1)
        else:
            out.append(bisect_right(wins[i], k))
    return out

def solve_all(tokens):
    it = iter(tokens)
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        queries = [(int(next(it)), int(next(it))) for _ in range(q)]
        out_lines.extend(str(x) for x in solve_case(n, q, a, queries))
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    # Exactly 3 asserts
    assert solve_case(3, 3, [3,1,2], [(1,1),(1,2),(3,5)]) == [1,2,0]
    assert solve_case(4, 4, [1,3,4,2], [(4,5),(3,2),(2,1),(2,10)]) == [0,1,1,1]
    assert solve_case(5, 5, [2,5,3,1,4], [(2,1),(2,3),(2,10),(5,1),(1,100)]) == [0,1,9,0,0]

def main():
    tokens = read_input()
    if not tokens:
        return
    solve_all(tokens)

if __name__ == "__main__":
    _self_test()
    main()
\end{minted}
\VALIDATION{Three asserts covering: strongest at front, strongest in middle, and a mix of queries with large $k$.}
\RESULT{For each query $(i,k)$, output the number of wins participant $i$ accumulates within the first $k$ rounds. No tie-breaking; results are unique integers per query.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for cases: strongest initially at front; strongest deep in the queue; $n=2$; participants that never win; very large $k$; multiple test cases aggregation.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A/B/C on small random permutations for modest $n$ where a full simulation up to, say, $2n$ rounds is feasible.}
\LINE{EDGE-CASE GENERATOR}{Produce deterministic permutations with extremes: increasing strengths, decreasing strengths, and a single peak, to stress champion replacement order.}
\begin{minted}{python}
import random

def brute_force_answers(n, a, queries, max_rounds):
    from collections import deque
    dq = deque(range(1, n + 1))
    wins = []
    # simulate up to max_rounds
    for r in range(1, max_rounds + 1):
        i, j = dq[0], dq[1]
        if a[i - 1] > a[j - 1]:
            w, l = i, j
        else:
            w, l = j, i
        dq.popleft(); dq.popleft()
        dq.appendleft(w); dq.append(l)
        wins.append(w)
    # prefix counts for answering queries up to max_rounds
    pref = [[0]*(max_rounds+1) for _ in range(n+1)]
    for r in range(1, max_rounds+1):
        w = wins[r-1]
        for i in range(1, n+1):
            pref[i][r] = pref[i][r-1] + (1 if i == w else 0)
    out = []
    for i, k in queries:
        kk = min(k, max_rounds)
        out.append(pref[i][kk])
    return out

def reference_solve_case(n, q, a, queries):
    # reuse final solve_case
    from collections import deque
    from bisect import bisect_right
    pmax = a.index(n) + 1
    dq = deque(range(1, n + 1))
    wins = [[] for _ in range(n + 1)]
    r = 1
    while True:
        i, j = dq[0], dq[1]
        if a[i - 1] > a[j - 1]:
            w, l = i, j
        else:
            w, l = j, i
        dq.popleft(); dq.popleft()
        dq.appendleft(w); dq.append(l)
        wins[w].append(r)
        if w == pmax:
            rstar = r
            break
        r += 1
    out = []
    for i, k in queries:
        if i == pmax:
            out.append(0 if k < rstar else k - rstar + 1)
        else:
            out.append(bisect_right(wins[i], k))
    return out

def deterministic_tests():
    # Small permutations for cross-check
    cases = [
        (3, [3,1,2], [(1,1),(1,2),(3,5)]),
        (4, [1,3,4,2], [(4,5),(3,2),(2,1),(2,10)]),
        (2, [2,1], [(1,1),(1,5),(2,1),(2,5)])
    ]
    for n, a, qs in cases:
        bf = brute_force_answers(n, a, qs, max_rounds=20)
        ref = reference_solve_case(n, len(qs), a, qs)
        assert all((b == r) or (qs[i][1] > 20 and r >= b) for i,(b,r) in enumerate(zip(bf, ref)))

if __name__ == "__main__":
    deterministic_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference implementation (CF-ready)
from collections import deque
from bisect import bisect_right
import sys

def read_input():
    return sys.stdin.buffer.read().split()

def solve_case(n, q, a, queries):
    pmax = a.index(n) + 1
    dq = deque(range(1, n + 1))
    wins = [[] for _ in range(n + 1)]
    r = 1
    while True:
        i, j = dq[0], dq[1]
        if a[i - 1] > a[j - 1]:
            w, l = i, j
        else:
            w, l = j, i
        dq.popleft(); dq.popleft()
        dq.appendleft(w); dq.append(l)
        wins[w].append(r)
        if w == pmax:
            rstar = r
            break
        r += 1
    out = []
    for i, k in queries:
        if i == pmax:
            out.append(0 if k < rstar else k - rstar + 1)
        else:
            out.append(bisect_right(wins[i], k))
    return out

def solve_all(tokens):
    it = iter(tokens)
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        queries = [(int(next(it)), int(next(it))) for _ in range(q)]
        out_lines.extend(str(x) for x in solve_case(n, q, a, queries))
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    assert solve_case(3, 3, [3,1,2], [(1,1),(1,2),(3,5)]) == [1,2,0]
    assert solve_case(4, 4, [1,3,4,2], [(4,5),(3,2),(2,1),(2,10)]) == [0,1,1,1]
    assert solve_case(2, 4, [2,1], [(1,1),(1,5),(2,1),(2,5)]) == [1,5,0,0]

def main():
    tokens = read_input()
    if not tokens:
        return
    solve_all(tokens)

if __name__ == "__main__":
    _self_test()
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Simulate until the strongest reaches front, record win rounds, and answer queries with binary search and a closed form for the strongest.}
\WHY{Queue simulations with a dominating element often appear; recognizing when the process stabilizes is key to efficiency.}
\CHECKLIST{
\begin{bullets}
\item Find the strongest index $p^\star$.
\item Simulate with a deque; record winner rounds.
\item Stop at first win of $p^\star$; store $r^\star$.
\item For $i\ne p^\star$: count wins $\le k$; for $i=p^\star$: use $\max(0,k-r^\star+1)$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Strongest initially at position $1$ ($r^\star=1$).
\item $n=2$ minimal case.
\item Participants that never win.
\item Very large $k$ far beyond $n$.
\item Queries for $i$ after $p^\star$ dominates.
\item Multiple test cases with cumulative limits.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in round counting ($r$ starts at $1$).
\item Double-counting $p^\star$'s first win if also adding tail.
\item Using indices $0$- vs $1$-based inconsistently.
\item Forgetting to stop simulation at $p^\star$'s first win.
\item Incorrectly handling $k<r^\star$ for $p^\star$.
\item Not using fast I/O for large input.
\end{bullets}}
\FAILMODES{Naive per-query simulation up to $k$ is infeasible when $k$ can be $10^9$. The proposed method avoids this by truncating simulation and using arithmetic for the tail.}
\ELI{Before the strongest reaches the front, only a few swaps happen and we can log who wins when. After the strongest gets there, they win every single time, so we can count those wins with a simple formula.}
\NotePages{3}

\end{document}