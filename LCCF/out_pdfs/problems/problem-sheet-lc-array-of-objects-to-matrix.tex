% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Array of Objects to Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/array-of-objects-to-matrix/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an array $A$ of $n$ JSON-like ``objects'' (records). Each record is a mapping from string keys to values. Values can be primitives (number, boolean, string, or null), or nested containers (object/dictionary or array/list). Arrays may contain nested containers or primitives; objects may contain arbitrary keys.

Transform $A$ into a matrix with the following rules:
\begin{bullets}
\item Flatten each record into key paths using dot notation:
  \begin{bullets}
  \item For an object value at key $k$, recurse into its entries; if a child path is $p$, the combined path is $k.p$.
  \item For an array value at key $k$, recurse into each index $i$; the path becomes $k.i$ (where $i$ is the decimal index).
  \item Only leaf primitives produce entries. Empty objects/arrays contribute no entries for their parent paths.
  \end{bullets}
\item The set of matrix columns is the union of all flattened paths across all records. Sort the column names lexicographically by their ASCII order.
\item The first row of the matrix is the list of sorted column names.
\item For each record (in the original order), create a row whose $j$-th cell is:
  \begin{bullets}
  \item The record's leaf value at the column's path, if it exists,
  \item Otherwise the empty string \texttt{""}.
  \end{bullets}
\item If a path is a primitive in one record (e.g., key \texttt{"a"} is a number) and an object/array in another, both the primitive path (e.g., \texttt{"a"}) and any deeper paths (e.g., \texttt{"a.b"}, \texttt{"a.0"}) may appear as columns. Missing values are filled with \texttt{""}.
\end{bullets}
Return the matrix as a 2D array: the first row contains column names (strings), and each subsequent row contains the corresponding values (primitives) or \texttt{""} where absent.}
\BREAKDOWN{Flatten nested objects and arrays into dot-separated key paths; take the union of paths as columns (sorted); then, for each original object, populate a row with values or \texttt{""} for missing paths.}
\ELI{Turn nested records into flat spreadsheets by naming each leaf with a dot path, union all column names, sort them, and fill rows with values or blanks.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array/list $A$ of length $n \ge 0$ where each element is a JSON-like record:
\begin{bullets}
\item Keys: strings consisting of ASCII characters.
\item Values: primitives (number, boolean, string, null) or containers (object/dictionary or array/list).
\item Nesting depth is finite; arrays are indexed from $0$ upward.
\end{bullets}}
\OUTPUTS{A matrix $M$ as a list of lists. $M[0]$ is a list of strings (column names sorted lexicographically). For each $i$ from $1$ to $n$, $M[i]$ is a list of length $\lvert M[0]\rvert$ where each entry is either a primitive value or the empty string \texttt{""}.}
\SAMPLES{
Example 1:
\[
\begin{aligned}
A &= [\{ \text{"a"}:2, \text{"b"}:1\},\ \{ \text{"b"}:3, \text{"a"}:4\}] \\
\text{Columns} &= [\text{"a"}, \text{"b"}] \\
M &= \bigl[\,[\text{"a"}, \text{"b"}],\ [2, 1],\ [4, 3]\,\bigr].
\end{aligned}
\]
Example 2 (mixed nesting):
\[
\begin{aligned}
A &= [\{ \text{"a"}:\{ \text{"b"}:1\}\},\ \{ \text{"a"}:[1,2]\},\ \{ \text{"a"}:5\}] \\
\text{Columns} &= [\text{"a"}, \text{"a.0"}, \text{"a.1"}, \text{"a.b"}] \\
M &= \bigl[\,[\text{"a"}, \text{"a.0"}, \text{"a.1"}, \text{"a.b"}],\\
&\quad [\text{""}, \text{""}, \text{""}, 1],\\
&\quad [\text{""}, 1, 2, \text{""}],\\
&\quad [5, \text{""}, \text{""}, \text{""}]\,\bigr].
\end{aligned}
\]}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For each record $r$ in $A$, define a partial function $f_r:\Sigma^\ast \rightharpoonup V$ from path strings to primitive values, obtained by recursively flattening $r$ with the dot-path rules. Let $C = \bigcup_{r \in A} \mathrm{dom}(f_r)$ be the finite set of column names. The matrix is
\[
M = \begin{bmatrix}
\text{sorted}(C)\\
\left(f_{A[0]}(c_1) \mathrel{\|\|} \text{""}\right) & \cdots & \left(f_{A[0]}(c_m) \mathrel{\|\|} \text{""}\right)\\
\vdots & \ddots & \vdots\\
\left(f_{A[n-1]}(c_1) \mathrel{\|\|} \text{""}\right) & \cdots & \left(f_{A[n-1]}(c_m) \mathrel{\|\|} \text{""}\right)
\end{bmatrix},
\]
where $m = \lvert C\rvert$, $(c_1,\ldots,c_m)$ is $C$ in lexicographic order, and $x \mathrel{\|\|} y$ means ``$x$ if defined, else $y$''.}
\varmapStart
\var{A}{input array of records}
\var{r}{one record from $A$}
\var{f_r}{flattened mapping from dot-paths to primitive values}
\var{C}{union of keys over all $f_r$}
\var{m}{number of columns, $m=\lvert C\rvert$}
\var{M}{output matrix}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
f_r(\epsilon) &\text{ is undefined (no empty path cells);} \\
f_r(p.k) &= f_{r[k]}(p) \quad \text{if } r[k] \text{ is an object and } p \text{ continues into it;} \\
f_r(p.i) &= f_{r[i]}(p) \quad \text{if } r \text{ is an array and } i \in \mathbb{Z}_{\ge 0}; \\
f_r(p) &= v \quad \text{if } p \text{ reaches a primitive leaf } v; \\
C &= \bigcup_{r \in A} \mathrm{dom}(f_r), \quad (c_1,\ldots,c_m)=\text{sorted}(C); \\
M[0] &= [c_1,\ldots,c_m]; \\
M[i+1][j] &= \begin{cases}
f_{A[i]}(c_j), & \text{if } c_j \in \mathrm{dom}(f_{A[i]});\\
\text{""}, & \text{otherwise}.
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{Keys are finite strings; arrays are finite; recursion terminates; lexicographic order is the standard ASCII order on strings.}
\INVARIANTS{
\begin{bullets}
\item Flattening preserves leaves: each primitive appears exactly once at its unique dot-path.
\item Columns are stable: the header row uniquely determines every row's length and order.
\item Missing paths never introduce values; blanks only appear where a path is absent.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Two-pass construction: flatten each record, union all keys, sort, then fill rows by direct lookup with blanks for missing.}
\ASSUMPTIONS{Depth-first flatten with dot-paths; treat lists by numeric indices; primitives are numbers, booleans, strings, or null.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each record $r$, recursively flatten into a dict map$[$path$\to$value$]$; collect all keys into a global set $C$.
\item After scanning all records, sort $C$ to form the header row.
\item For each flattened record map, create a row by reading values for each header key or \texttt{""} if absent.
\end{algosteps}
\COMPLEXITY{Let $N$ be total nodes across all inputs and $L$ the total number of leaf primitives. Let $m=\lvert C\rvert$ and $n=\lvert A\rvert$.}
\[
\begin{aligned}
T(n) &\approx \Theta(N) \text{ (flatten)} + \Theta(m\log m) \text{ (sort)} + \Theta(nm) \text{ (fill)};\\
S(n) &\approx \Theta(L + m + nm) \text{ for flattened maps, header, and output matrix.}
\end{aligned}
\]
\CORRECTNESS{Flattening enumerates every primitive leaf exactly once with its unique path; the union and sort give a canonical header; row filling respects header order and inserts \texttt{""} where a path is missing.}
\EDGECASES{Empty input $A=[\,]$ gives $M=[\,]$; empty objects/arrays contribute no keys; path collisions across types create multiple columns (e.g., \texttt{"a"} and \texttt{"a.b"}).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import Any, Dict, List, Union

Primitive = Union[None, bool, int, float, str]

class Solution:
    def jsonToMatrix(self, arr: List[Any]) -> List[List[Any]]:
        """
        Baseline: flatten each record to a dict[path->primitive], union keys,
        sort keys, then build matrix with "" for missing.
        """
        def is_primitive(x: Any) -> bool:
            return x is None or isinstance(x, (bool, int, float, str))

        def flatten(x: Any, prefix: str, out: Dict[str, Primitive]) -> None:
            if is_primitive(x):
                out[prefix] = x
                return
            if isinstance(x, dict):
                for k, v in x.items():
                    if prefix:
                        flatten(v, f"{prefix}.{k}", out)
                    else:
                        flatten(v, f"{k}", out)
                return
            if isinstance(x, list):
                for i, v in enumerate(x):
                    if prefix:
                        flatten(v, f"{prefix}.{i}", out)
                    else:
                        flatten(v, f"{i}", out)
                return
            # Unsupported types are ignored (do not create entries).

        flattened: List[Dict[str, Primitive]] = []
        columns: set[str] = set()

        for rec in arr:
            mp: Dict[str, Primitive] = {}
            if isinstance(rec, dict):
                for k, v in rec.items():
                    flatten(v, k, mp)
            else:
                # Non-dict records: treat the whole item as a primitive leaf under path "value"
                # (optional choice; keeps behavior defined).
                flatten(rec, "value", mp)
            flattened.append(mp)
            columns.update(mp.keys())

        if not flattened:
            return []

        headers = sorted(columns)
        matrix: List[List[Any]] = [headers]
        for mp in flattened:
            row = [mp.get(h, "") for h in headers]
            matrix.append(row)
        return matrix

# --- basic asserts ---
sol = Solution()
assert sol.jsonToMatrix([]) == []

ex1 = [{"a": 2, "b": 1}, {"b": 3, "a": 4}]
out1 = [["a", "b"], [2, 1], [4, 3]]
assert sol.jsonToMatrix(ex1) == out1

ex2 = [{"a": {"b": 1}}, {"a": [1, 2]}, {"a": 5}]
out2 = [["a", "a.0", "a.1", "a.b"], ["", "", "", 1], ["", 1, 2, ""], [5, "", "", ""]]
assert sol.jsonToMatrix(ex2) == out2
\end{minted}
\VALIDATION{Checked: empty input; flat keys union; mixed nesting with object vs. array vs. primitive under the same parent key.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use an iterative DFS with an explicit stack to avoid recursion overhead, and build a column index map to avoid repeated dictionary lookups during row construction.}
\ASSUMPTIONS{Same flattening rules; a two-phase process: discover columns and store per-record flattened maps; then precompute column index map and fill rows in $O(m)$ per record with direct indexing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Iteratively flatten each record with a stack of (value, path) pairs; store maps and union columns.
\item Sort columns once; build a map col\_to\_idx.
\item For each record map, allocate a list of length $m$ and fill values by direct index assignments; leave others as \texttt{""}.
\end{algosteps}
\COMPLEXITY{Asymptotically the same $T(n)$ as baseline, but with lower constants (no Python recursion, fewer dict lookups when filling rows).}
\[
\begin{aligned}
T(n) &= \Theta(N) + \Theta(m\log m) + \Theta(L + nm) \\
\end{aligned}
\]
\CORRECTNESS{Equivalent key generation and ordering; using an index map preserves the header order while filling exactly the present keys.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import Any, Dict, List, Union

Primitive = Union[None, bool, int, float, str]

class Solution:
    def jsonToMatrix(self, arr: List[Any]) -> List[List[Any]]:
        def is_primitive(x: Any) -> bool:
            return x is None or isinstance(x, (bool, int, float, str))

        def flatten_iter(item: Any) -> Dict[str, Primitive]:
            out: Dict[str, Primitive] = {}
            stack: List[tuple[Any, str]] = []
            if isinstance(item, dict):
                for k, v in item.items():
                    stack.append((v, k))
            else:
                # Non-dict top-level: map under "value"
                stack.append((item, "value"))
            while stack:
                val, path = stack.pop()
                if is_primitive(val):
                    out[path] = val
                elif isinstance(val, dict):
                    for k, v in val.items():
                        stack.append((v, f"{path}.{k}"))
                elif isinstance(val, list):
                    for i, v in enumerate(val):
                        stack.append((v, f"{path}.{i}"))
                else:
                    # ignore unsupported types
                    pass
            return out

        flattened: List[Dict[str, Primitive]] = []
        cols: set[str] = set()
        for rec in arr:
            mp = flatten_iter(rec)
            flattened.append(mp)
            cols.update(mp.keys())

        if not flattened:
            return []

        headers = sorted(cols)
        idx = {h: i for i, h in enumerate(headers)}
        m = len(headers)

        matrix: List[List[Any]] = [headers]
        for mp in flattened:
            row: List[Any] = ["" for _ in range(m)]
            for k, v in mp.items():
                row[idx[k]] = v
            matrix.append(row)
        return matrix

# --- asserts on edge inputs ---
sol = Solution()
assert sol.jsonToMatrix([]) == []

# mixed types and sparse keys
ex = [{"x": None, "y": True}, {"y": False}, {"z": [10]}, {"z": {"0": "ten"}}]
res = sol.jsonToMatrix(ex)
assert res[0] == ["x", "y", "z.0"]  # union + sorted
assert res[1] == [None, True, ""]
assert res[2] == ["", False, ""]
\end{minted}
\VALIDATION{Verified header stability; tested null/boolean; tested array and object under the same parent creating the same path \texttt{"z.0"}.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Two-phase canonicalization: (1) single pass to flatten and collect columns; (2) stable header and direct-index fill. This matches information-theoretic lower bounds: you must visit each node once, sort unique columns, and write each cell.}
\ASSUMPTIONS{All inputs are finite; sorting cost $\Omega(m\log m)$ is unavoidable for canonical ordering; writing the $nm$ output cells is $\Omega(nm)$ in the worst case.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item DFS flatten each record once to produce its leaf map and collect column names.
\item Sort columns; build index map.
\item Fill rows with direct indexed writes; no redundant lookups.
\end{algosteps}
\OPTIMALITY{Any algorithm must read every input node ($\Omega(N)$), determine column order (at least $\Omega(m\log m)$ under comparison sorting), and produce an $n\times m$ matrix ($\Omega(nm)$ writes in worst case). Our method meets these lower bounds up to constant factors.}
\COMPLEXITY{$T(n)=\Theta(N+m\log m+nm)$, $S(n)=\Theta(L+m+nm)$ as argued above.}
\[
\begin{aligned}
T(n) &= \Theta(N) + \Theta(m\log m) + \Theta(nm) \\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import Any, Dict, List, Union

Primitive = Union[None, bool, int, float, str]

class Solution:
    def jsonToMatrix(self, arr: List[Any]) -> List[List[Any]]:
        def is_primitive(x: Any) -> bool:
            return x is None or isinstance(x, (bool, int, float, str))

        def flatten(record: Any) -> Dict[str, Primitive]:
            out: Dict[str, Primitive] = {}
            stack: List[tuple[Any, str]] = []
            if isinstance(record, dict):
                for k, v in record.items():
                    stack.append((v, k))
            else:
                stack.append((record, "value"))
            while stack:
                v, path = stack.pop()
                if is_primitive(v):
                    out[path] = v
                elif isinstance(v, dict):
                    for k, vv in v.items():
                        stack.append((vv, f"{path}.{k}"))
                elif isinstance(v, list):
                    for i, vv in enumerate(v):
                        stack.append((vv, f"{path}.{i}"))
                else:
                    # ignore unsupported types
                    pass
            return out

        maps: List[Dict[str, Primitive]] = []
        colset: set[str] = set()
        for rec in arr:
            mp = flatten(rec)
            maps.append(mp)
            colset.update(mp.keys())

        if not maps:
            return []

        header = sorted(colset)
        index = {h: i for i, h in enumerate(header)}
        m = len(header)
        matrix: List[List[Any]] = [header]
        for mp in maps:
            row = ["" for _ in range(m)]
            for k, v in mp.items():
                row[index[k]] = v
            matrix.append(row)
        return matrix

# --- exactly 3 asserts ---
sol = Solution()
assert sol.jsonToMatrix([]) == []

case1 = [{"a": 2, "b": 1}, {"b": 3, "a": 4}]
expect1 = [["a", "b"], [2, 1], [4, 3]]
assert sol.jsonToMatrix(case1) == expect1

case2 = [{"a": {"b": 1}}, {"a": [1, 2]}, {"a": 5}]
expect2 = [["a", "a.0", "a.1", "a.b"], ["", "", "", 1], ["", 1, 2, ""], [5, "", "", ""]]
assert sol.jsonToMatrix(case2) == expect2
\end{minted}
\VALIDATION{Three asserts: empty input; flat records; mixed nesting (object, array, primitive under the same key).}
\RESULT{Return a 2D array whose first row is sorted dot-path column names and subsequent rows contain primitive values or \texttt{""} for missing entries.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: empty input; flat objects with identical keys; heterogeneous schemas; nested objects; arrays (including empty); collisions where a key is both a primitive and a container across records; stability of header order.}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A, B, C on randomly generated small nested structures; verify headers equal and row-by-row equality.}
\LINE{EDGE-CASE GENERATOR}{Generate random trees where leaves are primitives and internal nodes are dicts/lists; randomly choose to introduce collisions (same parent key used as primitive in some records).}
\begin{minted}{python}
import random
from typing import Any, Dict, List, Union

Primitive = Union[None, bool, int, float, str]

def rand_primitive() -> Primitive:
    kinds = ["none", "bool", "int", "float", "str"]
    t = random.choice(kinds)
    if t == "none":
        return None
    if t == "bool":
        return random.choice([True, False])
    if t == "int":
        return random.randint(-3, 3)
    if t == "float":
        return round(random.uniform(-3, 3), 2)
    return random.choice(["x", "y", "z"])

def rand_tree(depth: int, breadth: int = 2) -> Any:
    if depth == 0 or random.random() < 0.4:
        return rand_primitive()
    node_type = random.choice(["dict", "list"])
    if node_type == "dict":
        d: Dict[str, Any] = {}
        for i in range(random.randint(0, breadth)):
            k = chr(ord('a') + random.randint(0, 3))
            d[k] = rand_tree(depth - 1, breadth)
        return d
    else:
        lst: List[Any] = []
        for _ in range(random.randint(0, breadth)):
            lst.append(rand_tree(depth - 1, breadth))
        return lst

# Cross-check A vs C on small randoms by reusing class Solution from section C.
from typing import Any

class RefA:
    def jsonToMatrix(self, arr: List[Any]) -> List[List[Any]]:
        sol = Solution()
        return sol.jsonToMatrix(arr)

def cross_check(trials: int = 20) -> None:
    for _ in range(trials):
        n = random.randint(0, 5)
        arr = [rand_tree(depth=3) if random.random() < 0.2 else {"root": rand_tree(2)} for _ in range(n)]
        A = RefA().jsonToMatrix(arr)
        C = Solution().jsonToMatrix(arr)
        assert A == C

# Run cross-checks deterministically
random.seed(0)
cross_check(10)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import Any, Dict, List, Union

Primitive = Union[None, bool, int, float, str]

class Solution:
    def jsonToMatrix(self, arr: List[Any]) -> List[List[Any]]:
        def is_primitive(x: Any) -> bool:
            return x is None or isinstance(x, (bool, int, float, str))

        def flatten(record: Any) -> Dict[str, Primitive]:
            out: Dict[str, Primitive] = {}
            stack: List[tuple[Any, str]] = []
            if isinstance(record, dict):
                for k, v in record.items():
                    stack.append((v, k))
            else:
                stack.append((record, "value"))
            while stack:
                v, path = stack.pop()
                if is_primitive(v):
                    out[path] = v
                elif isinstance(v, dict):
                    for k, vv in v.items():
                        stack.append((vv, f"{path}.{k}"))
                elif isinstance(v, list):
                    for i, vv in enumerate(v):
                        stack.append((vv, f"{path}.{i}"))
                else:
                    # ignore unsupported types
                    pass
            return out

        maps: List[Dict[str, Primitive]] = []
        colset: set[str] = set()
        for rec in arr:
            mp = flatten(rec)
            maps.append(mp)
            colset.update(mp.keys())

        if not maps:
            return []

        header = sorted(colset)
        index = {h: i for i, h in enumerate(header)}
        m = len(header)
        matrix: List[List[Any]] = [header]
        for mp in maps:
            row = ["" for _ in range(m)]
            for k, v in mp.items():
                row[index[k]] = v
            matrix.append(row)
        return matrix

# Sanity tests
sol = Solution()
assert sol.jsonToMatrix([]) == []
assert sol.jsonToMatrix([{"a": 1}, {"b": 2}])[0] == ["a", "b"]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Flatten each record into dot-paths, union and sort columns, then fill a matrix with values or blanks.}
\WHY{Common in data engineering interviews: normalizing semi-structured JSON into tabular form with stable, deterministic schemas.}
\CHECKLIST{
\begin{bullets}
\item Implement robust flattening for dicts and lists; only leaves become entries.
\item Build the union of keys; sort headers deterministically.
\item Use an index map to fill rows efficiently.
\item Handle empty inputs and empty containers.
\item Treat mixed types under the same key by allowing both shallow and deep columns.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $A=[\,]$ returns $[\,]$.
\item Records with no primitive leaves yield a row of all \texttt{""}.
\item Empty objects/arrays produce no keys.
\item Arrays of arrays and objects of arrays at various depths.
\item Keys that differ only by ASCII order; ensure lexicographic sort.
\item Collisions: \texttt{"a"} as primitive in one record and as object/array in another.
\item Numeric indices as strings in dictionaries vs. array indices (e.g., \texttt{"z.0"}).
\item Null and boolean values preserved.
\item Very deep nesting within recursion limits.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Emitting non-leaf entries (e.g., adding \texttt{"a"} when \texttt{"a"} is an object) is incorrect.
\item Forgetting to sort headers leads to non-deterministic output.
\item Using natural numeric order for indices instead of string lex order changes column order.
\item Overwriting values when duplicate paths appear in a record; last write wins but inputs should not duplicate keys along a path.
\item Stack overflow with recursion on deep inputs; prefer iterative DFS.
\item Treating missing values as \texttt{None} instead of \texttt{""} in the matrix.
\item Mishandling types (e.g., converting booleans to integers).
\end{bullets}}
\FAILMODES{A naive single-pass row fill without a precomputed header cannot place values consistently; approaches that stringify whole subtrees lose leaf-level columns; forgetting arrays or indices yields missing columns. The proposed method flattens with explicit array indices and creates a stable schema.}
\ELI{We give every leaf value a full name like \texttt{"a.b.0"}, collect all such names as column headers, sort them, and then write each row by looking up each name. Missing names get blanks.}
\NotePages{3}

\end{document}