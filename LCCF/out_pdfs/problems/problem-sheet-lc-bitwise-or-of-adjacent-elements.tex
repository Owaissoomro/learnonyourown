% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Bitwise OR of Adjacent Elements}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/bitwise-or-of-adjacent-elements/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Bitwise OR of Adjacent Elements — LeetCode.

You are given an integer array $A$ of length $n$ with $n \ge 2$. Construct an array $B$ of length $n-1$ such that for every index $i$ with $0 \le i < n-1$,
\begin{BreakableEquation*}
B[i] = A[i] \lor A[i+1],
\end{BreakableEquation*}
where $\lor$ denotes the bitwise OR operation. Return the array $B$.

Constraints (typical and sufficient for an efficient linear pass):
\begin{BreakableEquation*}
2 \le n \le 10^{5},\quad 0 \le A[i] \le 10^{9}.
\end{BreakableEquation*}%
}
\BREAKDOWN{Compute the bitwise OR for each adjacent pair and collect results. Ensure correct indexing and handle minimal length $n=2$.}
\ELI{Slide a window of size 2 along the array and record the bitwise OR of each pair.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode style:
\begin{bullets}
\item Input: integer array $A$ with $2 \le \lvert A \rvert$ and elements in $[0, 10^{9}]$.
\end{bullets}
}
\OUTPUTS{
\begin{bullets}
\item Return an integer array $B$ of length $n-1$ with $B[i] = A[i] \lor A[i+1]$ for $0 \le i < n-1$.
\end{bullets}
}
\SAMPLES{
\begin{bullets}
\item Example 1: $A = [1, 2, 3] \Rightarrow B = [1 \lor 2, 2 \lor 3] = [3, 3]$.
\item Example 2: $A = [0, 7] \Rightarrow B = [0 \lor 7] = [7]$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $A \in \mathbb{Z}_{\ge 0}^{n}$, define $B \in \mathbb{Z}_{\ge 0}^{n-1}$ by $B[i] = A[i] \lor A[i+1]$ for $i=0,\ldots,n-2$.}
\varmapStart
\var{A}{input array of nonnegative integers}
\var{n}{length of $A$}
\var{B}{output array of length $n-1$ with adjacent bitwise ORs}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i \in \{0,\ldots,n-2\}:\quad B[i] = A[i] \lor A[i+1].
\end{BreakableEquation*}
}
\ASSUMPTIONS{
\begin{bullets}
\item $n \ge 2$ so that $n-1 \ge 1$.
\item Elements fit in standard integer range; bitwise OR is well defined.
\end{bullets}
}
\INVARIANTS{
\begin{bullets}
\item For each bit position $k$, the $k$th bit of $B[i]$ is $1$ iff at least one of $A[i]$ or $A[i+1]$ has that bit $1$.
\item $0 \le B[i] \le \max(A[i], A[i+1])$ in terms of set bits; numerically $B[i] \le A[i] + A[i+1]$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the definition directly: for each $i$ compute $A[i] \lor A[i+1]$ and append to $B$.}
\ASSUMPTIONS{Single left-to-right pass over the array; no extra structure needed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize empty list $B$.
\item For $i$ from $0$ to $n-2$, compute $v \gets A[i] \lor A[i+1]$ and append $v$ to $B$.
\item Return $B$.
\end{algosteps}
\COMPLEXITY{Single pass does constant work per index: $T(n) = \Theta(n)$ and $S(n) = \Theta(1)$ auxiliary beyond output.}
\[
\begin{aligned}
T(n) &= \sum_{i=0}^{n-2} O(1) = O(n), \\
S_{\text{aux}}(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{By construction, each $B[i]$ equals the required bitwise OR of the adjacent pair, satisfying the governing equation for all $i$.}
\EDGECASES{
\begin{bullets}
\item Minimal size $n=2$ yields a single output element.
\item Zeros: OR with zero leaves the other operand unchanged.
\item Large values: still $O(1)$ per pair; no overflow in Python integers.
\end{bullets}
}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def adjacentBitwiseOR(self, nums: List[int]) -> List[int]:
        n = len(nums)
        assert n >= 2
        out: List[int] = []
        for i in range(n - 1):
            out.append(nums[i] | nums[i + 1])
        return out

if __name__ == "__main__":
    sol = Solution()
    assert sol.adjacentBitwiseOR([1, 2, 3]) == [3, 3]
    assert sol.adjacentBitwiseOR([0, 7]) == [7]
    assert sol.adjacentBitwiseOR([5, 5, 0]) == [5, 5]
\end{minted}
\VALIDATION{The asserts cover a general case, the minimal length, and a case with identical numbers and zeros.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Leverage Python list comprehension for concise, vector-like iteration; still linear but with minimal overhead.}
\ASSUMPTIONS{Same as baseline; no additional data structures.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Return $[A[i] \lor A[i+1] \text{ for } i \in [0,n-2]]$ computed via comprehension.
\item Python evaluates bitwise OR in constant time per pair.
\item The result list is allocated once with length $n-1$.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline but typically faster in practice due to tight loops in CPython.}
\[
\begin{aligned}
T(n) &= O(n), \quad S_{\text{aux}}(n) = O(1) \text{ beyond the output}.
\end{aligned}
\]
\CORRECTNESS{The list comprehension enumerates exactly the required indices and applies the same OR operation, preserving the invariant definition of $B[i]$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def adjacentBitwiseOR(self, nums: List[int]) -> List[int]:
        n = len(nums)
        assert n >= 2
        return [nums[i] | nums[i + 1] for i in range(n - 1)]

if __name__ == "__main__":
    sol = Solution()
    assert sol.adjacentBitwiseOR([1, 2, 3]) == [3, 3]
    assert sol.adjacentBitwiseOR([8, 1, 2, 4]) == [9, 3, 6]
    assert sol.adjacentBitwiseOR([0, 0]) == [0]
\end{minted}
\VALIDATION{Covers typical, mixed bits, and all-zero cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{The problem is inherently local and linear; a single pass applying $|$ is optimal under the comparison and bitwise operation model.}
\ASSUMPTIONS{Random access to array elements; bitwise OR is $O(1)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pre-size the output list of length $n-1$ for slightly improved constant factors.
\item For $i$ from $0$ to $n-2$, set $B[i] \gets A[i] \lor A[i+1]$.
\item Return $B$.
\end{algosteps}
\OPTIMALITY{Any algorithm must inspect each adjacent pair at least once to decide each $B[i]$, implying an $\Omega(n)$ time lower bound. The algorithm achieves $O(n)$ time and $O(1)$ extra space beyond the output, which is optimal.}
\COMPLEXITY{Linear time and optimal auxiliary space.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S_{\text{aux}}(n) = \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def adjacentBitwiseOR(self, nums: List[int]) -> List[int]:
        n = len(nums)
        assert n >= 2
        out = [0] * (n - 1)
        # Fill iteratively for optimal constant factors
        prev = nums[0]
        for i in range(n - 1):
            cur = nums[i + 1]
            out[i] = prev | cur
            prev = cur
        return out

if __name__ == "__main__":
    sol = Solution()
    assert sol.adjacentBitwiseOR([1, 2, 3]) == [3, 3]
    assert sol.adjacentBitwiseOR([0, 7]) == [7]
    assert sol.adjacentBitwiseOR([1, 3, 5, 7]) == [3, 7, 7]
\end{minted}
\VALIDATION{Exactly three asserts confirming general, minimal, and multi-step propagation of set bits.}
\RESULT{Return the array of length $n-1$ where each entry is the bitwise OR of a consecutive pair in the input.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests over:
\begin{bullets}
\item Random arrays to compare with a trusted oracle (comprehension).
\item Edge cases: $n=2$, all zeros, all equal, alternating bits, powers of two.
\item Large arrays to ensure linear performance.
\end{bullets}
}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A, B, and C on the same random inputs to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Produce arrays with specific bit patterns (e.g., single-bit masks, complements) to stress bitwise behavior.}
\begin{minted}{python}
from typing import List
import random

def oracle(nums: List[int]) -> List[int]:
    return [nums[i] | nums[i + 1] for i in range(len(nums) - 1)]

def gen_alternating(n: int, a: int, b: int) -> List[int]:
    out = [0] * n
    for i in range(n):
        out[i] = a if i % 2 == 0 else b
    return out

def run_cross_checks():
    As = [
        [1, 2, 3],
        [0, 7],
        [5, 5, 0],
        gen_alternating(6, 0b1010, 0b0101),
        [1 << k for k in range(10)],
    ]
    # Random cases
    random.seed(0)
    for _ in range(5):
        n = random.randint(2, 20)
        arr = [random.randint(0, (1 << 12) - 1) for _ in range(n)]
        As.append(arr)

    # Implementations from approaches A, B, C (duplicated minimal logic here)
    def A(nums: List[int]) -> List[int]:
        out: List[int] = []
        for i in range(len(nums) - 1):
            out.append(nums[i] | nums[i + 1])
        return out

    def B(nums: List[int]) -> List[int]:
        return [nums[i] | nums[i + 1] for i in range(len(nums) - 1)]

    def C(nums: List[int]) -> List[int]:
        n = len(nums)
        out = [0] * (n - 1)
        prev = nums[0]
        for i in range(n - 1):
            cur = nums[i + 1]
            out[i] = prev | cur
            prev = cur
        return out

    for arr in As:
        expect = oracle(arr)
        assert A(arr) == expect
        assert B(arr) == expect
        assert C(arr) == expect

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def adjacentBitwiseOR(self, nums: List[int]) -> List[int]:
        # Linear pass; preallocated result for optimal constants
        n = len(nums)
        assert n >= 2
        res = [0] * (n - 1)
        prev = nums[0]
        for i in range(n - 1):
            cur = nums[i + 1]
            res[i] = prev | cur
            prev = cur
        return res

if __name__ == "__main__":
    sol = Solution()
    # Smoke tests
    assert sol.adjacentBitwiseOR([1, 2, 3]) == [3, 3]
    assert sol.adjacentBitwiseOR([0, 0]) == [0]
    assert sol.adjacentBitwiseOR([8, 1, 2, 4]) == [9, 3, 6]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute the bitwise OR of each adjacent pair in the array in one pass.}
\WHY{Bit-manipulation warm-ups appear frequently and test careful indexing and understanding of bitwise semantics.}
\CHECKLIST{
\begin{bullets}
\item Verify $n \ge 2$.
\item Iterate indices $i=0$ to $n-2$ exactly.
\item Use the bitwise operator $|$, not logical OR.
\item Preallocate result if optimizing constants.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=2$.
\item All zeros.
\item All identical numbers.
\item Alternating high and low bit patterns.
\item Maximal values near $2^{31}-1$.
\item Presence of a zero between large numbers.
\item Single-bit masks that shift between positions.
\item Already nondecreasing in terms of set bits.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one: iterating to $n-1$ instead of $n-2$.
\item Using logical OR instead of bitwise OR.
\item Mutating the input inadvertently.
\item Allocating output with wrong length.
\item Forgetting minimal length guard.
\item Integer overflow concerns in languages with fixed widths (not an issue in Python but relevant in others).
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item Approaches that skip pairs will return incorrect $B[i]$.
\item Misusing addition or max instead of OR breaks bit-level semantics.
\end{bullets}
}
\ELI{Walk along the list, take each pair of neighbors, turn on any bit that is on in either number, and record it. Do this for all pairs and return the results.}
\NotePages{3}

\end{document}