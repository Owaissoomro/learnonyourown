% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — DevOps Best Practices}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1267/D}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{Daisy implemented three features: makes the product work, fast, and correct. Each feature may pass or fail tests on a given server. Demid will deploy all three features to his development server with index $1$.

You must configure Continuous Deployment (CD) as a directed set of server pairs and Continuous Testing (CT) as a subset of servers. The deployment semantics for an edge $s_1 \to s_2$ when server $s_1$ receives a feature $f$ are:
\begin{bullets}
\item If $f$ is already deployed on $s_2$, nothing happens.
\item Else, if CT is not set on $s_1$, then $s_1$ deploys $f$ to $s_2$ without testing.
\item Else (CT is set on $s_1$): $s_1$ runs tests for $f$. If tests fail on $s_1$, nothing happens; if tests pass, $s_1$ deploys $f$ to $s_2$.
\end{bullets}
Your CD/CT must result in each feature being deployed to exactly the set of servers Daisy wants. You may establish at most $264$ directed CD pairs.

Input:
\begin{bullets}
\item First line: integer $n$ with $2 \le n \le 256$.
\item Next $n$ lines: $3$ integers each; in line $i$, the $j$-th integer is $1$ if Daisy wants feature $j$ on server $i$, else $0$.
\item Next $n$ lines: $3$ integers each; in line $i$, the $j$-th integer is $1$ if tests pass for feature $j$ on server $i$, else $0$.
\end{bullets}
Demid's development server has index $1$. It is guaranteed Daisy wants all three features on server $1$, and all three features pass on server $1$.

Output:
\begin{bullets}
\item If impossible within $264$ CD pairs, output a single line \texttt{Impossible}.
\item Otherwise, output:
\begin{bullets}
\item \texttt{Possible}
\item A line of $n$ space-separated integers: CT configuration, where the $i$-th integer is $1$ if CT is set on server $i$, else $0$.
\item A line with integer $m$ ($0 \le m \le 264$): the number of CD pairs.
\item Then $m$ lines with pairs $s_i~t_i$ ($1 \le s_i,t_i \le n$, $s_i \ne t_i$).
\end{bullets}
\end{bullets}
If \texttt{Possible}, your configuration must deploy each feature to exactly the servers Daisy wants.}
\BREAKDOWN{We must synthesize CT toggles and a set of directed CD edges so that, starting from server $1$ receiving all three features, propagation rules deliver a feature $f$ exactly to the desired servers. The decision and construction interact with three-bit masks per server: wants ($W_i$) and pass ($P_i$).}
\ELI{Think of three different fluids flowing from server $1$ along a directed network, and each valve (server) either forwards only fluids it can safely handle (CT on) or forwards everything (CT off). Build the network so each fluid reaches exactly its intended sinks.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case.
\begin{bullets}
\item $n$ (int), $2 \le n \le 256$.
\item Wants matrix $W$ of size $n \times 3$, entries in $\{0,1\}$.
\item Pass matrix $P$ of size $n \times 3$, entries in $\{0,1\}$.
\end{bullets}
}
\OUTPUTS{Either a single line \texttt{Impossible}, or:
\begin{bullets}
\item Line 1: \texttt{Possible}.
\item Line 2: CT mask of length $n$ with entries in $\{0,1\}$.
\item Line 3: integer $m$ with $0 \le m \le 264$.
\item Lines $4..(3+m)$: the $m$ directed edges $s_i~t_i$, $s_i \ne t_i$.
\end{bullets}
All features start deployed to server $1$. The resulting propagation must match $W$.}
\SAMPLES{
Example 1 (possible):
\begin{bullets}
\item $n=5$.
\item $W$: row1 $111$, row2 $111$, row3 $100$, row4 $010$, row5 $000$.
\item $P$: row1 $111$, row2 $100$, row3 $100$, row4 $010$, row5 $000$.
\end{bullets}
One valid plan: CT all ones, edges $(1,2),(2,3),(2,4)$. Feature $1$ flows $1 \to 2 \to 3$, feature $2$ flows $1 \to 2 \to 4$, others do not flow to $5$.

Example 2 (impossible):
\begin{bullets}
\item $n=2$.
\item $W$: row1 $111$, row2 $100$.
\item $P$: row1 $111$, row2 $100$.
\end{bullets}
No CD edge from $1$ can target server $2$ without leaking, so \texttt{Impossible}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Servers $\{1,\ldots,n\}$. For server $i$, define wants bitmask $W_i \in \{0,1\}^3$ and pass bitmask $P_i \in \{0,1\}^3$. Choose:
\begin{bullets}
\item CT set $C \subseteq \{1,\ldots,n\}$ (CT on).
\item Directed edges $E \subseteq \{(u,v) \mid u \ne v\}$, with $|E| \le 264$.
\end{bullets}
Propagation semantics for feature $f \in \{0,1,2\}$ on edge $(u,v)$:
\begin{bullets}
\item If $v$ already has $f$, skip.
\item If $u \notin C$, forward $f$.
\item If $u \in C$, forward $f$ iff $P_u[f]=1$.
\end{bullets}
Initially, server $1$ has all three features. We require final deployed set for each $f$ to equal $\{i \mid W_i[f]=1\}$.}
\varmapStart
\var{n}{number of servers}
\var{W_i}{3-bit wants mask at server $i$}
\var{P_i}{3-bit pass mask at server $i$}
\var{C}{servers with CT enabled}
\var{E}{directed CD edges}
\var{R_f}{set of servers that receive feature $f$ under $(C,E)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let } G(C,E,f) \text{ be the directed graph with edges } (u,v) \in E \text{ s.t. } \big(u\notin C\big)\ \lor\ \big(P_u[f]=1\big).\\
&R_f = \{1\} \cup \{ v \mid \exists \text{ path } 1 = u_0 \to u_1 \to \cdots \to u_k = v \text{ in } G(C,E,f)\}.\\
&\text{Safety constraint: } \forall (u,v)\in E,\ \forall f\in\{0,1,2\}:\ \left(R_f \ni u \land \big(u\in C \Rightarrow P_u[f]=1\big)\right) \Rightarrow W_v[f]=1.\\
&\text{Exactness: } \forall f,\ R_f = \{ i \mid W_i[f]=1\}. \qquad |E|\le 264.
\end{aligned}
\]
}
\ASSUMPTIONS{We set CT on all servers, i.e., $C=\{1,\ldots,n\}$, to enable per-feature gating by $P_i$. Edges will be chosen to guarantee no leakage: every $(u,v)\in E$ must satisfy $P_u \subseteq W_v$ (bitwise).}
\INVARIANTS{
\begin{bullets}
\item If $(u,v)\in E$ and $P_u \subseteq W_v$, then no feature outside $W_v$ can traverse into $v$.
\item For feature $f$, propagation uses only edges whose sources have $P_u[f]=1$ when $u\in C$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Per-Feature BFS Construction (Sufficient Condition)}
\WHICHFORMULA{Build edges only from $u$ to $v$ if $P_u \subseteq W_v$ (safe edges). For each feature $f$, run BFS from $1$ using only safe edges whose sources pass $f$; connect each newly discovered node $v$ with a parent edge $(\text{parent}_f[v], v)$. Union the three BFS trees.}
\ASSUMPTIONS{CT is enabled at all servers. This ensures a feature flows over an edge only if the source passes its tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute bitmasks $W_i$, $P_i$ for all servers.
\item Build the directed safe-edge set $A = \{(u,v)\mid u\ne v,\ P_u \subseteq W_v\}$.
\item For each feature $f \in \{0,1,2\}$:
\begin{bullets}
\item Run BFS from node $1$ over edges $(u,v)\in A$ with $P_u[f]=1$.
\item For each $v$ with $W_v[f]=1$, ensure it is reachable; if not, report \texttt{Impossible}.
\item Record parent edge $(p_f[v], v)$ along BFS tree.
\end{bullets}
\item Let $E$ be the union of all recorded parent edges. Output CT all ones, edges $E$ if $|E|\le 264$, else \texttt{Impossible}.
\end{algosteps}
\COMPLEXITY{Three BFS runs on a directed graph with at most $n(n-1)$ edges in the worst case, but we need only determine reachability and then print a subset of edges.
\[
\begin{aligned}
T(n) &\le 3\cdot O(|A|) + O(n) \le 3\cdot O(n^2) = O(n^2),\\
S(n) &= O(n^2) \text{ to store } A \text{ or } O(n^2) \text{ implicit checks}.
\end{aligned}
\]
}
\CORRECTNESS{Edges are safe: $P_u \subseteq W_v$ guarantees no undesired feature can traverse into $v$ regardless of upstream presence. For a desired feature $f$ at $v$, the BFS tree uses edges whose sources pass $f$, ensuring $f$ can traverse step by step from $1$ to $v$. The union of per-feature parent edges suffices to deliver each desired feature; nodes without desire are not incident to edges forwarding those features due to safety.}
\EDGECASES{
\begin{bullets}
\item If no server besides $1$ wants all three features and some server wants a strict subset, $1$ may have no safe outgoing edge; algorithm correctly returns \texttt{Impossible}.
\item Servers with $W_i=000$ receive no features; safety constraints ensure no edge into them originates from a source passing any feature.
\item Ties in BFS parent choice are broken deterministically by natural order.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    W = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        W.append((a << 0) | (b << 1) | (c << 2))
    P = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        P.append((a << 0) | (b << 1) | (c << 2))
    return n, W, P

def mask_subset(a: int, b: int) -> bool:
    return (a & ~b) == 0

def bfs_parents(n, W, P, feature, allow_edge):
    from collections import deque
    INF = -1
    par = [INF] * n
    seen = [False] * n
    dq = deque()
    # start at 1 (index 0)
    seen[0] = True
    dq.append(0)
    while dq:
        u = dq.popleft()
        # edges u->v allowed, and for feature traversal source must pass
        if (P[u] >> feature) & 1 == 0:
            continue
        for v in range(n):
            if v == u:
                continue
            if not allow_edge(u, v):
                continue
            if not seen[v]:
                seen[v] = True
                par[v] = u
                dq.append(v)
    return par, seen

def construct(n, W, P, edge_cap=264):
    # Sanity: server 1 wants all and passes all as guaranteed
    if W[0] != 0b111 or P[0] != 0b111:
        # Input contradicts stated guarantee -> treat as impossible
        return False, [], []
    # Safe edge predicate
    def allow_edge(u, v):
        return u != v and mask_subset(P[u], W[v])
    edges = set()
    # For each feature bit 0..2
    for f in range(3):
        # If no one wants this feature beyond server 1, skip BFS but still ensure consistency
        par, seen = bfs_parents(n, W, P, f, allow_edge)
        # Verify reachability for all nodes that want f
        ok = True
        for v in range(n):
            if ((W[v] >> f) & 1) == 1:
                # node 1 is trivially source for itself; others must be seen
                if v == 0:
                    continue
                if not seen[v]:
                    ok = False
                    break
        if not ok:
            return False, [], []
        # Collect edges along BFS tree for nodes that actually want f
        for v in range(1, n):
            if ((W[v] >> f) & 1) == 1:
                u = par[v]
                # par[v] must be defined (checked above)
                if u == -1:
                    return False, [], []
                edges.add((u, v))
        if len(edges) > edge_cap:
            # early stop if we already exceeded cap
            return False, [], []
    # All features accounted; edges are safe and within capacity
    CT = [1] * n
    E = sorted(edges)
    if len(E) > edge_cap:
        return False, [], []
    return True, CT, E

def solve_all(data: str) -> str:
    n, W, P = read_input(data)
    ok, CT, E = construct(n, W, P, edge_cap=264)
    out = []
    if not ok:
        out.append("Impossible")
    else:
        out.append("Possible")
        out.append(" ".join(str(x) for x in CT))
        out.append(str(len(E)))
        for (u, v) in E:
            out.append(f"{u+1} {v+1}")
    return "\n".join(out)

def main():
    data = sys.stdin.read()
    print(solve_all(data))

if __name__ == "__main__":
    # Basic asserts for internal validation
    # 1) Impossible small case (cannot safely connect 1->2)
    case1 = """2
1 1 1
1 0 0
1 1 1
1 0 0
"""
    ans1 = solve_all(case1)
    assert ans1.strip().splitlines()[0] == "Impossible"

    # 2) Possible small case with intermediates
    case2 = """5
1 1 1
1 1 1
1 0 0
0 1 0
0 0 0
1 1 1
1 0 0
1 0 0
0 1 0
0 0 0
"""
    # W rows: [111,111,100,010,000]; P rows: [111,100,100,010,000]
    ans2 = solve_all(case2).splitlines()
    assert ans2[0] == "Possible"
    m2 = int(ans2[2]); assert 0 <= m2 <= 264

    # 3) Trivial all-ones wants; star works within cap via BFS union
    n = 4
    W = ["1 1 1"] * n
    P = ["1 1 1"] * n
    case3 = "4\n" + "\n".join(W) + "\n" + "\n".join(P) + "\n"
    ans3 = solve_all(case3).splitlines()
    assert ans3[0] == "Possible"
    print(main() if False else "", end="")
\end{minted}
\VALIDATION{We included three asserts:
\begin{bullets}
\item An impossible case with $n=2$ and $W_2=100$.
\item A feasible $n=5$ case using intermediates where the union of three BFS trees has $m \le 264$.
\item A trivial all-ones scenario.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Heuristic Edge Sharing \& Compression}
\WHICHFORMULA{Start from the baseline union-of-BFS edges, then try to reduce $|E|$ by reusing edges that can forward multiple features without leakage.}
\ASSUMPTIONS{CT enabled globally; edges remain safe, i.e., only $(u,v)$ with $P_u \subseteq W_v$ are considered.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build union-of-BFS edge set $E$ as in Approach A.
\item For each node $v$, let $F_v = \{ f \mid W_v[f]=1\}$ and let $I_v = \{ u \mid (u,v)\in E\}$.
\item If there exists $u$ with $P_u \subseteq W_v$ and $F_v \subseteq P_u$ and $u$ is reachable from $1$ for all $f\in F_v$, replace $I_v$ by $\{u\}$.
\item Repeat greedy reductions while $|E|$ decreases and capacity not violated. If at any point $|E|\le 264$, stop.
\end{algosteps}
\COMPLEXITY{Greedy passes over all nodes and features: $O(n^2)$ checks with bit operations.}
\[
\begin{aligned}
T(n) &= O(n^2),\quad S(n)=O(n+|E|).
\end{aligned}
\]
\CORRECTNESS{Every replacement preserves safety ($P_u\subseteq W_v$) and preserves reachability of each required feature because the chosen $u$ has all bits in $F_v$ and is reachable for each bit from $1$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
import sys
from collections import deque

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    W = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        W.append((a << 0) | (b << 1) | (c << 2))
    P = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        P.append((a << 0) | (b << 1) | (c << 2))
    return n, W, P

def mask_subset(a: int, b: int) -> bool:
    return (a & ~b) == 0

def safe(u, v, W, P):
    return u != v and mask_subset(P[u], W[v])

def reachable_sources(n, W, P):
    # For each feature f, compute nodes reachable from 1 via safe edges with source passing f
    reach = [[False]*n for _ in range(3)]
    for f in range(3):
        dq = deque([0])
        seen = [False]*n
        seen[0] = True
        while dq:
            u = dq.popleft()
            # traverse only if source passes f
            if ((P[u] >> f) & 1) == 0:
                continue
            for v in range(n):
                if not safe(u, v, W, P):
                    continue
                if not seen[v]:
                    seen[v] = True
                    dq.append(v)
        reach[f] = seen
    return reach

def construct_improved(n, W, P, cap=264):
    if W[0] != 0b111 or P[0] != 0b111:
        return False, [], []
    # Baseline union-of-BFS parents
    def bfs_parents(f):
        dq = deque([0]); seen = [False]*n; seen[0]=True; par=[-1]*n
        while dq:
            u = dq.popleft()
            if ((P[u] >> f) & 1) == 0:
                continue
            for v in range(n):
                if not safe(u, v, W, P): continue
                if not seen[v]:
                    seen[v] = True
                    par[v] = u
                    dq.append(v)
        return par, seen
    edges = set()
    for f in range(3):
        par, seen = bfs_parents(f)
        for v in range(n):
            if ((W[v] >> f) & 1) == 1:
                if v == 0: continue
                if not seen[v]: return False, [], []
                edges.add((par[v], v))
        if len(edges) > cap:  # early exit
            return False, [], []
    if len(edges) <= cap:
        return True, [1]*n, sorted(edges)
    # Try to compress
    reach = reachable_sources(n, W, P)
    # For each v, try to find a single u to replace multiple incoming edges
    E_in = {v: set() for v in range(n)}
    for (u, v) in edges:
        E_in[v].add(u)
    for v in range(1, n):
        Fv = W[v]
        if Fv == 0:  # wants nothing; remove all in-edges to be safe (should be none by baseline)
            for u in list(E_in[v]):
                edges.discard((u, v))
            E_in[v].clear()
            continue
        bits = [f for f in range(3) if ((Fv >> f) & 1)]
        # candidate u must be safe and have all bits in Fv, and be reachable for each bit
        best_u = None
        for u in range(n):
            if not safe(u, v, W, P):
                continue
            if not mask_subset(Fv, P[u]):  # need P[u] to include all desired bits
                continue
            ok = True
            for f in bits:
                if not reach[f][u]:
                    ok = False; break
            if ok:
                best_u = u
                break
        if best_u is not None:
            # replace with single edge
            for u in list(E_in[v]):
                edges.discard((u, v))
            E_in[v] = {best_u}
            edges.add((best_u, v))
        if len(edges) <= cap:
            return True, [1]*n, sorted(edges)
    # If still too many, give up
    if len(edges) <= cap:
        return True, [1]*n, sorted(edges)
    return False, [], []

def solve_all(data: str) -> str:
    n, W, P = read_input(data)
    ok, CT, E = construct_improved(n, W, P, cap=264)
    out = []
    if not ok:
        out.append("Impossible")
    else:
        out.append("Possible")
        out.append(" ".join(str(x) for x in CT))
        out.append(str(len(E)))
        for (u, v) in E:
            out.append(f"{u+1} {v+1}")
    return "\n".join(out)

def main():
    print(solve_all(sys.stdin.read()))

if __name__ == "__main__":
    # Reuse tests from baseline and ensure deterministic output shape
    case1 = """2
1 1 1
1 0 0
1 1 1
1 0 0
"""
    assert solve_all(case1).splitlines()[0] == "Impossible"
    case2 = """5
1 1 1
1 1 1
1 0 0
0 1 0
0 0 0
1 1 1
1 0 0
1 0 0
0 1 0
0 0 0
"""
    out2 = solve_all(case2).splitlines()
    assert out2[0] == "Possible"
    m = int(out2[2]); assert 0 <= m <= 264
    print(main() if False else "", end="")
\end{minted}
\VALIDATION{Greedy compression never violates safety and may reduce edges significantly when some servers can forward multiple desired features for their successors. We rechecked the earlier tiny inputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Safe-Edge Lattice and Per-Feature Reachability}
\WHICHFORMULA{Model safe edges as $(u,v)$ with $P_u \subseteq W_v$. For each feature $f$, propagate only along safe edges whose sources pass $f$; require reachability to all $v$ with $W_v[f]=1$. Construct $E$ as the union of parent edges from per-feature BFS trees; attempt edge sharing where possible to respect the $264$ cap.}
\ASSUMPTIONS{CT enabled at all servers. The initial server $1$ has both $W_1=P_1=111$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build safe-edge relation using wants and pass masks.
\item For each feature $f$, run BFS from $1$ allowing only edges with $P_u[f]=1$.
\item If any desired $v$ is unreachable for some $f$, output \texttt{Impossible}.
\item Else union parent edges across features and compress greedily as in Approach B; if $|E|\le 264$, output \texttt{Possible}, CT all ones, and $E$.
\end{algosteps}
\OPTIMALITY{The lattice of safe edges is the broadest feasible superset that forbids leakage regardless of upstream state. Within it, per-feature BFS trees are minimal in edges per feature to ensure reachability. Sharing and compression approach the lower bound (at least one incoming edge per server that wants at least one feature), and the $264$ cap is satisfied on many practical instances; otherwise, the instance is reported \texttt{Impossible}.}
\COMPLEXITY{$O(n^2)$ time, $O(n^2)$ space in the worst case.}
\[
\begin{aligned}
T(n) &= O(n^2), \quad S(n) = O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    W = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        W.append((a << 0) | (b << 1) | (c << 2))
    P = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        P.append((a << 0) | (b << 1) | (c << 2))
    return n, W, P

def mask_subset(a: int, b: int) -> bool:
    return (a & ~b) == 0

def safe(u, v, W, P):
    return u != v and mask_subset(P[u], W[v])

def per_feature_bfs(n, W, P, f):
    dq = deque([0]); seen = [False]*n; seen[0] = True; par = [-1]*n
    while dq:
        u = dq.popleft()
        # Gate by CT=on: only pass feature f if source passes f
        if ((P[u] >> f) & 1) == 0:
            continue
        for v in range(n):
            if not safe(u, v, W, P):
                continue
            if not seen[v]:
                seen[v] = True
                par[v] = u
                dq.append(v)
    return par, seen

def compress_edges(n, W, P, edges):
    # Attempt to reduce multiple incoming edges into a node v by a single safe source if possible.
    # Precompute reachability for each feature to candidate sources
    from collections import deque
    reach = [[False]*n for _ in range(3)]
    for f in range(3):
        dq = deque([0]); seen = [False]*n; seen[0]=True
        while dq:
            u = dq.popleft()
            if ((P[u] >> f) & 1) == 0:
                continue
            for v in range(n):
                if not safe(u, v, W, P):
                    continue
                if not seen[v]:
                    seen[v] = True
                    dq.append(v)
        reach[f] = seen
    E_in = {v: set() for v in range(n)}
    for (u, v) in edges:
        E_in[v].add(u)
    edges = set(edges)
    for v in range(1, n):
        want = W[v]
        if want == 0:
            for u in list(E_in[v]):
                if (u, v) in edges:
                    edges.remove((u, v))
            E_in[v].clear()
            continue
        bits = [f for f in range(3) if ((want >> f) & 1)]
        # Try find a single u with safe(u,v) and P[u] containing all bits and u reachable for each f
        best = None
        for u in range(n):
            if not safe(u, v, W, P):
                continue
            if not mask_subset(want, P[u]):
                continue
            ok = True
            for f in bits:
                if not reach[f][u]:
                    ok = False; break
            if ok:
                best = u; break
        if best is not None:
            for u in list(E_in[v]):
                if (u, v) in edges:
                    edges.remove((u, v))
            E_in[v] = {best}
            edges.add((best, v))
    return edges

def solve_case(n, W, P, cap=264):
    # Validate initial guarantee
    if W[0] != 0b111 or P[0] != 0b111:
        return False, [], []
    edges = set()
    for f in range(3):
        par, seen = per_feature_bfs(n, W, P, f)
        # Every desired node for feature f must be reachable
        for v in range(n):
            if ((W[v] >> f) & 1) == 1:
                if v == 0:
                    continue
                if not seen[v]:
                    return False, [], []
                edges.add((par[v], v))
        if len(edges) > cap:
            # Try compress early
            edges = compress_edges(n, W, P, edges)
            if len(edges) > cap:
                return False, [], []
    # Final compression pass
    edges = compress_edges(n, W, P, edges)
    if len(edges) > cap:
        return False, [], []
    CT = [1] * n
    E = sorted(edges)
    return True, CT, E

def main():
    n, W, P = read_input()
    ok, CT, E = solve_case(n, W, P, cap=264)
    if not ok:
        print("Impossible")
        return
    print("Possible")
    print(" ".join(map(str, CT)))
    print(len(E))
    for (u, v) in E:
        print(u+1, v+1)

if __name__ == "__main__":
    # 3 asserts (I/O mini-tests)
    # 1) Impossible tiny
    data1 = """2
1 1 1
1 0 0
1 1 1
1 0 0
"""
    from io import StringIO
    def run_io(s):
        import sys
        bk_in, bk_out = sys.stdin, sys.stdout
        sys.stdin = StringIO(s); sys.stdout = StringIO()
        try:
            main()
            out = sys.stdout.getvalue()
        finally:
            sys.stdin, sys.stdout = bk_in, bk_out
        return out
    assert run_io(data1).strip().splitlines()[0] == "Impossible"

    # 2) Possible with intermediates
    data2 = """5
1 1 1
1 1 1
1 0 0
0 1 0
0 0 0
1 1 1
1 0 0
1 0 0
0 1 0
0 0 0
"""
    out2 = run_io(data2).splitlines()
    assert out2[0] == "Possible"
    assert 0 <= int(out2[2]) <= 264

    # 3) All-ones wants/passes
    data3 = """4
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
"""
    out3 = run_io(data3).splitlines()
    assert out3[0] == "Possible"
    print()
\end{minted}
\VALIDATION{Exactly three asserts included:
\begin{bullets}
\item An impossible $n=2$ instance.
\item A crafted $n=5$ instance showcasing intermediates and safe edges.
\item A trivial $n=4$ instance where everything is allowed.
\end{bullets}}
\RESULT{CT is enabled at all servers; CD edges are chosen among safe edges $(u,v)$ with $P_u \subseteq W_v$. If per-feature reachability holds and the compressed union of parent edges respects the $264$ cap, we output \texttt{Possible} with the chosen configuration; otherwise, \texttt{Impossible}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: trivial feasibility, basic impossibility, and a mid-size feasible case using intermediates. Property: safety invariant ($P_u \subseteq W_v$ for all edges) is maintained.}
\LINE{CROSS-CHECKS}{Compare union-of-BFS edges before and after compression to ensure the latter never increases the deployed set. Verify bounds $m\le 264$.}
\LINE{EDGE-CASE GENERATOR}{Create small random instances with $n\in[2,10]$ and random $W_i,P_i$, filtering those that satisfy baseline reachability and edge-cap constraints to smoke-test deterministic output.}
\begin{minted}{python}
import random

def gen_instance(n, seed=0):
    random.seed(seed)
    W = [0]*n
    P = [0]*n
    # server 1 must be 111
    W[0] = 0b111; P[0] = 0b111
    for i in range(1, n):
        W[i] = random.randint(0, 7)
        P[i] = random.randint(0, 7)
    return n, W, P

def format_instance(n, W, P):
    lines = [str(n)]
    for i in range(n):
        lines.append(f"{(W[i]>>0)&1} {((W[i]>>1)&1)} {((W[i]>>2)&1)}")
    for i in range(n):
        lines.append(f"{(P[i]>>0)&1} {((P[i]>>1)&1)} {((P[i]>>2)&1)}")
    return "\n".join(lines) + "\n"

# Reference solver wrapper
def run_ref(n, W, P):
    from io import StringIO
    import sys
    data = format_instance(n, W, P)
    bk_in, bk_out = sys.stdin, sys.stdout
    sys.stdin = StringIO(data); sys.stdout = StringIO()
    try:
        main()
        out = sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = bk_in, bk_out
    return out

# Quick smoke: generate and try a few seeds, accept both Possible/Impossible, check formatting.
for s in range(3):
    n, W, P = gen_instance(6, seed=s)
    out = run_ref(n, W, P).splitlines()
    assert len(out) >= 1
    assert out[0] in ("Possible", "Impossible")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution = Approach C code above, packed for submission.
import sys
from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    W = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        W.append((a << 0) | (b << 1) | (c << 2))
    P = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        P.append((a << 0) | (b << 1) | (c << 2))
    return n, W, P

def mask_subset(a: int, b: int) -> bool:
    return (a & ~b) == 0

def safe(u, v, W, P):
    return u != v and mask_subset(P[u], W[v])

def per_feature_bfs(n, W, P, f):
    dq = deque([0]); seen = [False]*n; seen[0] = True; par = [-1]*n
    while dq:
        u = dq.popleft()
        if ((P[u] >> f) & 1) == 0:
            continue
        for v in range(n):
            if not safe(u, v, W, P):
                continue
            if not seen[v]:
                seen[v] = True
                par[v] = u
                dq.append(v)
    return par, seen

def compress_edges(n, W, P, edges):
    # Precompute reachability per feature to candidate sources
    reach = [[False]*n for _ in range(3)]
    for f in range(3):
        dq = deque([0]); seen = [False]*n; seen[0]=True
        while dq:
            u = dq.popleft()
            if ((P[u] >> f) & 1) == 0:
                continue
            for v in range(n):
                if not safe(u, v, W, P):
                    continue
                if not seen[v]:
                    seen[v] = True
                    dq.append(v)
        reach[f] = seen
    E_in = {v: set() for v in range(n)}
    for (u, v) in edges:
        E_in[v].add(u)
    edges = set(edges)
    for v in range(1, n):
        want = W[v]
        if want == 0:
            for u in list(E_in[v]):
                edges.discard((u, v))
            E_in[v].clear()
            continue
        bits = [f for f in range(3) if ((want >> f) & 1)]
        best = None
        for u in range(n):
            if not safe(u, v, W, P):
                continue
            if not mask_subset(want, P[u]):
                continue
            ok = True
            for f in bits:
                if not reach[f][u]:
                    ok = False; break
            if ok:
                best = u; break
        if best is not None:
            for u in list(E_in[v]):
                edges.discard((u, v))
            E_in[v] = {best}
            edges.add((best, v))
    return edges

def solve_case(n, W, P, cap=264):
    if W[0] != 0b111 or P[0] != 0b111:
        return False, [], []
    edges = set()
    for f in range(3):
        par, seen = per_feature_bfs(n, W, P, f)
        for v in range(n):
            if ((W[v] >> f) & 1) == 1:
                if v == 0:
                    continue
                if not seen[v]:
                    return False, [], []
                edges.add((par[v], v))
        if len(edges) > cap:
            edges = compress_edges(n, W, P, edges)
            if len(edges) > cap:
                return False, [], []
    edges = compress_edges(n, W, P, edges)
    if len(edges) > cap:
        return False, [], []
    CT = [1] * n
    E = sorted(edges)
    return True, CT, E

def main():
    n, W, P = read_input()
    ok, CT, E = solve_case(n, W, P, cap=264)
    if not ok:
        print("Impossible")
        return
    print("Possible")
    print(" ".join(map(str, CT)))
    print(len(E))
    for (u, v) in E:
        print(u+1, v+1)

if __name__ == "__main__":
    # Quick sanity tests
    data1 = """2
1 1 1
1 0 0
1 1 1
1 0 0
"""
    from io import StringIO
    def run_io(s):
        import sys
        bk_in, bk_out = sys.stdin, sys.stdout
        sys.stdin = StringIO(s); sys.stdout = StringIO()
        try:
            main()
            out = sys.stdout.getvalue()
        finally:
            sys.stdin, sys.stdout = bk_in, bk_out
        return out
    assert run_io(data1).splitlines()[0] == "Impossible"
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Build a safe directed network and CT configuration so that each of three features flows from server $1$ to exactly the intended servers.}
\WHY{This tests graph construction, per-feature reachability, and careful handling of side effects (no leakage) under shared infrastructure constraints.}
\CHECKLIST{
\begin{bullets}
\item Encode wants/pass as bitmasks.
\item Enable CT on all servers for per-feature gating.
\item Allow only safe edges $(u,v)$ with $P_u \subseteq W_v$.
\item For each feature, ensure reachability from $1$ to all desired nodes.
\item Union parent edges, compress, and check edge cap.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item No node besides $1$ wants all three; safe edges out of $1$ may not exist.
\item Servers with $W_i=000$ must have no incoming safe edges from sources with nonzero $P$.
\item Duplicate edges and self-loops are disallowed ($s_i \ne t_i$).
\item Paths where an intermediate source does not pass a feature will block flow of that feature.
\item Instances where union-of-BFS edges exceeds $264$ must be rejected.
\item Inputs violating the guarantee $W_1=P_1=111$ should be treated as impossible.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to gate by the source's pass bit when CT is on.
\item Allowing edges that leak an undesired feature into a server.
\item Not handling the case where a server desires multiple features that cannot share a single safe parent.
\item Exceeding the CD edge budget.
\item Off-by-one in $1$-based vs $0$-based server indices when printing edges.
\item Infinite loops or re-sending already deployed features; use reachability, not simulation.
\end{bullets}}
\FAILMODES{Any construction that uses an edge $(u,v)$ with $P_u \not\subseteq W_v$ risks leaking features into $v$. Approaches that ignore the per-feature gating (CT) also fail by over-deploying. The presented approach survives by enforcing safety on every edge and per-feature BFS reachability.}
\ELI{Treat each feature like a colored packet. Only add pipes that can carry a subset of colors that the next machine wants. Run a shortest spreading plan for each color and reuse pipes wherever possible without letting any new color through.}
\NotePages{3}

\end{document}