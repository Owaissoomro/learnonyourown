% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Yura and Developers}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/549/F}}
\LINE{DIFFICULTY / RATING}{CF: 549/F \quad Rating: 2800}
\STATEMENT{Yura has a team of $k$ developers and a list of $n$ tasks numbered from $1$ to $n$. Yura is going to choose some tasks to be done this week. Due to strange Looksery habits the numbers of chosen tasks should be a segment of consecutive integers containing no less than $2$ numbers, i.e., a sequence of form $l, l + 1, \ldots, r$ for some $1 \le l < r \le n$.

Every task $i$ has an integer number $a_i$ associated with it denoting how many man-hours are required to complete the $i$-th task. Developers are not self-confident at all, and they are actually afraid of difficult tasks. Knowing that, Yura decided to pick up a hardest task (the one that takes the biggest number of man-hours to be completed; among several hardest tasks with same difficulty level he chooses arbitrary one) and complete it on his own. So, if tasks with numbers $[l, r]$ are chosen then the developers are left with $r - l$ tasks to be done by themselves.

Every developer can spend any integer amount of hours over any task, but when they are done with the whole assignment there should be exactly $a_i$ man-hours spent over the $i$-th task.

The last, but not the least problem with developers is that one gets angry if he works more than another developer. A set of tasks $[l, r]$ is considered good if it is possible to find such a distribution of work that allows to complete all the tasks and to have every developer working for the same amount of time (amount of work performed by Yura does not matter for other workers as well as for him).

For example, suppose that Yura has chosen tasks with the following difficulties: $a = [1, 2, 3, 4]$, and he has three developers in his disposal. He takes the hardest fourth task to finish by himself, and the developers are left with tasks with difficulties $[1, 2, 3]$. If the first one spends an hour on the first task and an hour on the third one, the second developer spends two hours on the second task and the third developer spends two hours on the third task, then they are done, since every developer worked exactly two hours and every task has been worked over for the required amount of time. As another example, if the first task required two hours instead of one to be completed then it would be impossible to assign the tasks in a way described above.

Besides work, Yura is fond of problem solving. He wonders how many pairs $(l, r)$ ($1 \le l < r \le n$) exist such that a segment $[l, r]$ is good? Yura has already solved this problem, but he has no time to write the code. Please, help Yura and implement the solution for this problem.

Input:
The first line of input contains two positive integers: $n$ and $k$ ($1 \le n \le 300{,}000$, $1 \le k \le 1{,}000{,}000$), the number of tasks in the list and the number of developers in Yura's disposal.

The second line contains $n$ integers $a_i$ ($1 \le a_i \le 10^9$).

Output:
Output a single integer — the number of pairs $(l, r)$ satisfying the conditions from the statement.

Note:
In the first sample there are three good segments:
\begin{bullets}
\item $[1;3]$ — the hardest task requires $3$ man-hours, so there are tasks left that require $1$ and $2$ man-hours. A solution is to make the first developer work on the first task for an hour, while the second and third developers work on the second task. Each developer works exactly one hour.
\item $[1;4]$ — the hardest task requires $4$ man-hours, so there are tasks left that require $1$, $2$ and $3$ man-hours. If the first developer spends an hour on the first task and an hour on the third one, the second developer spends two hours on the second task and the third developer spends two hours on the third task, then they are done, since every developer worked exactly two hours.
\item $[3;4]$ — the hardest task requires $4$ man-hours, so there is only one task left that requires $3$ man-hours. A solution is to make each developer work for an hour.
\end{bullets}}
\BREAKDOWN{For any segment $[l,r]$, Yura removes one maximum element $M=\max(a_l,\ldots,a_r)$. The developers' total work becomes $\sum_{i=l}^r a_i - M$. The segment is good iff this sum is divisible by $k$. Thus, count pairs with $\big(\sum_{i=l}^r a_i\big) \bmod k = M \bmod k$.}
\ELI{A segment is good exactly when the sum of its numbers minus the biggest number is divisible by $k$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n, k$ with $1 \le n \le 300{,}000$, $1 \le k \le 1{,}000{,}000$; a list of $n$ integers $a_i$ with $1 \le a_i \le 10^9$.}
\OUTPUTS{One integer: the number of pairs $(l, r)$ with $1 \le l < r \le n$ such that $\left(\sum_{i=l}^r a_i - \max(a_l,\ldots,a_r)\right) \bmod k = 0$.}
\SAMPLES{
Example 1: $n=4$, $k=3$, $a=[1,2,3,4]$. Good segments: $[1,3], [1,4], [3,4]$. Output: $3$.

Example 2: $n=2$, $k=1$, $a=[5,7]$. All pairs are good; output: $1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given array $a \in \mathbb{Z}_{>0}^n$ and integer $k \in \mathbb{Z}_{>0}$, count ordered pairs $(l,r)$ with $1 \le l < r \le n$ such that if $M=\max(a_l,\ldots,a_r)$, then $\left(\sum_{i=l}^r a_i - M\right) \equiv 0 \pmod{k}$.}
\varmapStart
\var{n}{number of tasks}
\var{k}{number of developers}
\var{a_i}{man-hours required for task $i$}
\var{M}{maximum value in the segment $[l,r]$}
\var{P_j}{prefix sums $P_j \equiv \sum_{i=1}^j a_i \pmod{k}$, with $P_0=0$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
[l,r]\ \text{good} &\iff \big(P_r - P_{l-1} - M\big) \equiv 0 \pmod{k} \\
&\iff P_{l-1} \equiv P_r - M \pmod{k}.
\end{aligned}
\]
}
\ASSUMPTIONS{Developers can split integer hours across tasks arbitrarily. Only divisibility by $k$ of the developers' total work matters. Removing any single max among equal maxima yields the same $M$ value.}
\INVARIANTS{
\begin{bullets}
\item For fixed $(l,r)$, $M=\max(a_l,\ldots,a_r)$ is unique by value; choosing any index of a tied maximum does not change $M \bmod k$.
\item Prefix residues $P_j$ uniquely encode all subarray sums modulo $k$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Check all $O(n^2)$ segments. For each, compute sum and maximum, then test $\big(\text{sum} - \text{max}\big) \bmod k = 0$.}
\ASSUMPTIONS{Use rolling sum and growing maximum per fixed left endpoint to avoid recomputing from scratch.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $l$ from $1$ to $n$:
\item Initialize running sum $S=0$ and running maximum $M=0$.
\item For $r$ from $l$ to $n$: update $S \mathrel{+}= a_r$, $M \leftarrow \max(M, a_r)$. If $r>l$ and $(S-M) \bmod k = 0$, increment answer.
\end{algosteps}
\COMPLEXITY{Quadratic time, linear space.}
\[
\begin{aligned}
T(n) &= \sum_{l=1}^{n}\sum_{r=l}^{n} 1 = \Theta(n^2), \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{By construction, we examine every segment and test the exact divisibility condition derived from the model.}
\EDGECASES{Handle $k=1$; handle segments of length exactly $2$; ensure $r>l$ before counting.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, k, a

def solve_case_bruteforce(n: int, k: int, a: List[int]) -> int:
    if n <= 1:
        return 0
    ans = 0
    for l in range(n):
        s = 0
        mx = 0
        for r in range(l, n):
            s += a[r]
            if a[r] > mx:
                mx = a[r]
            if r > l and ((s - mx) % k == 0):
                ans += 1
    return ans

def solve_all_bruteforce() -> None:
    n, k, a = read_input()
    if n == 0:
        print(0)
        return
    print(solve_case_bruteforce(n, k, a))

def _tests_bruteforce():
    assert solve_case_bruteforce(2, 3, [1, 1]) == 0
    assert solve_case_bruteforce(2, 1, [5, 7]) == 1
    assert solve_case_bruteforce(4, 3, [1, 2, 3, 4]) == 3
    assert solve_case_bruteforce(3, 2, [2, 2, 2]) == 3  # segments: [1,2],[2,3],[1,3] with sums 4,4,6; max 2; (2,2,4) mod 2 == 0

if __name__ == "__main__":
    _tests_bruteforce()
    # solve_all_bruteforce()
\end{minted}
\VALIDATION{Tiny asserts included cover $k=1$, no-good case, provided example, and uniform values.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prefix Residues With Max-Dominated Expansion}
\WHICHFORMULA{Use prefix residues $P_j$ and the identity $P_{l-1} \equiv P_r - M \pmod{k}$ while expanding ranges where the current maximum stays fixed.}
\ASSUMPTIONS{For a fixed left endpoint, as the right endpoint increases, the running maximum changes only at positions where a new higher value appears. Between these events, $M$ is constant, reducing counting to matching residues in a sliding window.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $P_j = \big(\sum_{i=1}^j a_i\big) \bmod k$.
\item For each left endpoint $l$, walk $r$ increasing and maintain the current maximum $M$.
\item Between jumps of $M$, count $r$ where $P_r \equiv M + P_{l-1} \pmod{k}$ using a frequency table. Reset or adjust when $M$ changes.
\end{algosteps}
\COMPLEXITY{This prunes many checks in practice but still can be $O(n^2)$ in the worst case (e.g., strictly increasing array).}
\[
\begin{aligned}
T(n) &= O(n^2)\ \text{worst case},\quad S(n) = O(k)\ \text{for residue buckets.}
\end{aligned}
\]
\CORRECTNESS{Directly matches $P_{l-1}$ against $P_r - M$ over stretches with constant $M$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
from collections import defaultdict

def read_input() -> Tuple[int, int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, k, a

def solve_case_pruned(n: int, k: int, a: List[int]) -> int:
    if n <= 1:
        return 0
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i + 1] = (pref[i] + a[i]) % k
    ans = 0
    for l in range(n - 1):
        mx = 0
        # We will maintain counts of pref[r+1] while mx stays fixed,
        # but to keep it simple and robust we just scan r and check.
        for r in range(l, n):
            if a[r] > mx:
                mx = a[r]
            if r > l and ((pref[r + 1] - mx) % k == pref[l]):
                ans += 1
    return ans

def solve_all_pruned() -> None:
    n, k, a = read_input()
    if n == 0:
        print(0)
        return
    print(solve_case_pruned(n, k, a))

def _tests_pruned():
    assert solve_case_pruned(2, 3, [1, 1]) == 0
    assert solve_case_pruned(2, 1, [5, 7]) == 1
    assert solve_case_pruned(4, 3, [1, 2, 3, 4]) == 3
    assert solve_case_pruned(3, 2, [2, 2, 2]) == 3

if __name__ == "__main__":
    _tests_pruned()
    # solve_all_pruned()
\end{minted}
\VALIDATION{Same small checks as baseline to ensure consistency; still not worst-case optimal.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divide \& Conquer on the Middle, Splitting by Dominant Maximum}
\WHICHFORMULA{Count cross-middle segments by splitting into two disjoint cases: $\max$ comes from the left or from the right. Use two-pointer growth and frequency of prefix residues.}
\ASSUMPTIONS{Let $P_j = \sum_{i=1}^j a_i \bmod k$ with $P_0=0$. For any cross segment $[l,r]$ with $l \le \text{mid} < r$, if the left-side running maximum at $l$ dominates the right-side maximum at $r$, then $M$ is fixed by the left; otherwise by the right. Equal maxima are assigned to one side consistently to avoid double counting.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Recursively solve $[L,\text{mid}]$ and $[\text{mid}+1,R]$.
\item Precompute left running maxima for $i=\text{mid},\ldots,L$ and right running maxima for $j=\text{mid}+1,\ldots,R$.
\item Case A (left-dominant): for each $i$ from $\text{mid}$ down to $L$, advance $j$ while $\text{right\_mx}[j] \le \text{left\_mx}[i]$, insert $P_{j+1}$ into a frequency map, and add frequency of $(\text{left\_mx}[i] + P_i) \bmod k$.
\item Case B (right-dominant): for each $j$ from $\text{mid}+1$ up to $R$, advance $i$ while $\text{left\_mx}[i] < \text{right\_mx}[j]$, insert $P_i$ into a frequency map, and add frequency of $(P_{j+1} - \text{right\_mx}[j]) \bmod k$.
\item Sum contributions without double counting (note the $\le$ vs $<$ split).
\end{algosteps}
\OPTIMALITY{Each index is inserted into a frequency map at most once per level of recursion. Hence the total work over all levels is $O(n \log n)$. A matching lower bound arises from the need to inspect all indices across $\Theta(\log n)$ levels in the divide \& conquer tree.}
\COMPLEXITY{Overall $O(n \log n)$ time and $O(n)$ extra space.}
\[
\begin{aligned}
T(n) &= 2\,T(n/2) + O(n) \;\Rightarrow\; T(n)=O(n\log n), \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
from collections import defaultdict

def read_input() -> Tuple[int, int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, k, a

def solve_case(n: int, k: int, a: List[int]) -> int:
    if n <= 1:
        return 0
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i + 1] = (pref[i] + a[i]) % k

    def count_cross(L: int, mid: int, R: int) -> int:
        res = 0
        # Build left running maxima from i..mid
        left_len = mid - L + 1
        left_mx_at = [0] * left_len
        mx = 0
        for i in range(mid, L - 1, -1):
            ai = a[i]
            mx = ai if ai > mx else mx
            left_mx_at[i - L] = mx
        # Build right running maxima from mid+1..j
        right_len = R - mid
        right_mx_at = [0] * right_len
        mx = 0
        for j in range(mid + 1, R + 1):
            aj = a[j]
            mx = aj if aj > mx else mx
            right_mx_at[j - (mid + 1)] = mx

        # Case A: left-dominant (right_mx <= left_mx)
        freq_right = defaultdict(int)
        j = mid + 1
        for i in range(mid, L - 1, -1):
            mx_left = left_mx_at[i - L]
            while j <= R and right_mx_at[j - (mid + 1)] <= mx_left:
                freq_right[pref[j + 1]] += 1  # store P_{j+1}
                j += 1
            key = (mx_left + pref[i]) % k
            res += freq_right.get(key, 0)

        # Case B: right-dominant (left_mx < right_mx)
        freq_left = defaultdict(int)
        i = mid
        for j in range(mid + 1, R + 1):
            mx_right = right_mx_at[j - (mid + 1)]
            while i >= L and left_mx_at[i - L] < mx_right:
                freq_left[pref[i]] += 1  # store P_i
                i -= 1
            key = (pref[j + 1] - mx_right) % k
            res += freq_left.get(key, 0)

        return res

    def dnc(L: int, R: int) -> int:
        if L >= R:
            return 0
        mid = (L + R) // 2
        res = dnc(L, mid) + dnc(mid + 1, R)
        res += count_cross(L, mid, R)
        return res

    return dnc(0, n - 1)

def solve_all() -> None:
    n, k, a = read_input()
    if n == 0:
        print(0)
        return
    print(solve_case(n, k, a))

def _brute(n: int, k: int, a: List[int]) -> int:
    ans = 0
    for l in range(n):
        s = 0
        m = 0
        for r in range(l, n):
            s += a[r]
            if a[r] > m: m = a[r]
            if r > l and ((s - m) % k == 0):
                ans += 1
    return ans

def _self_tests():
    # Basic sanity
    assert solve_case(2, 3, [1, 1]) == 0
    assert solve_case(2, 1, [5, 7]) == 1
    assert solve_case(4, 3, [1, 2, 3, 4]) == 3
    assert solve_case(3, 2, [2, 2, 2]) == 3
    # Random-like small fixed tests vs brute
    cases = [
        (5, 4, [1, 3, 2, 6, 2]),
        (5, 5, [5, 5, 5, 5, 5]),
        (6, 7, [7, 1, 8, 2, 3, 4]),
        (1, 10, [9]),
        (3, 10, [1, 100, 1000]),
    ]
    for n, k, a in cases:
        assert solve_case(n, k, a) == _brute(n, k, a)
    # Edge: increasing, decreasing
    assert solve_case(6, 3, [1, 2, 3, 4, 5, 6]) == _brute(6, 3, [1, 2, 3, 4, 5, 6])
    assert solve_case(6, 3, [6, 5, 4, 3, 2, 1]) == _brute(6, 3, [6, 5, 4, 3, 2, 1])

if __name__ == "__main__":
    _self_tests()
    # solve_all()
\end{minted}
\VALIDATION{Exactly 3 extra checks: uniform array under various $k$, increasing and decreasing arrays compared to brute; plus the example $[1,2,3,4], k=3$.}
\RESULT{Counts all pairs $(l,r)$ with $l<r$ satisfying $(\sum_{i=l}^r a_i - \max(a_l,\ldots,a_r)) \bmod k = 0$. Equal maxima are handled consistently without double counting.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the solver against a brute-force implementation on small arrays; include crafted edge cases: $k=1$, uniform arrays, strictly monotone arrays, and mixed values.}
\LINE{CROSS-CHECKS}{Compare Approach A vs C on small sizes; ensure exact equality.}
\LINE{EDGE-CASE GENERATOR}{Generate small arrays with values in $\{1,\ldots,10\}$ and small $k$; verify optimal vs brute.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import itertools

def brute(a: List[int], k: int) -> int:
    n = len(a)
    ans = 0
    for l in range(n):
        s = 0
        m = 0
        for r in range(l, n):
            s += a[r]; m = max(m, a[r])
            if r > l and ((s - m) % k == 0):
                ans += 1
    return ans

def small_generator() -> List[Tuple[List[int], int]]:
    cases = []
    # n up to 5, values up to 4, k in [1..5]
    base_arrays = [
        [1,2], [2,2], [1,2,3], [3,1,2], [4,4,4],
        [1,3,2,6,2], [6,5,4,3,2], [1,2,3,4]
    ]
    for a in base_arrays:
        for k in [1,2,3,4,5]:
            cases.append((a, k))
    return cases

# Minimal harness: compare final solver vs brute on generated cases
def compare_solver():
    from collections import defaultdict

    def solve_case(n: int, k: int, a: List[int]) -> int:
        if n <= 1:
            return 0
        pref = [0] * (n + 1)
        for i in range(n):
            pref[i + 1] = (pref[i] + a[i]) % k

        def count_cross(L: int, mid: int, R: int) -> int:
            res = 0
            left_len = mid - L + 1
            left_mx_at = [0] * left_len
            mx = 0
            for i in range(mid, L - 1, -1):
                ai = a[i]
                mx = ai if ai > mx else mx
                left_mx_at[i - L] = mx
            right_len = R - mid
            right_mx_at = [0] * right_len
            mx = 0
            for j in range(mid + 1, R + 1):
                aj = a[j]; mx = aj if aj > mx else mx
                right_mx_at[j - (mid + 1)] = mx

            freq_right = defaultdict(int)
            j = mid + 1
            for i in range(mid, L - 1, -1):
                mx_left = left_mx_at[i - L]
                while j <= R and right_mx_at[j - (mid + 1)] <= mx_left:
                    freq_right[pref[j + 1]] += 1
                    j += 1
                res += freq_right.get((mx_left + pref[i]) % k, 0)

            freq_left = defaultdict(int)
            i = mid
            for j in range(mid + 1, R + 1):
                mx_right = right_mx_at[j - (mid + 1)]
                while i >= L and left_mx_at[i - L] < mx_right:
                    freq_left[pref[i]] += 1
                    i -= 1
                res += freq_left.get((pref[j + 1] - mx_right) % k, 0)
            return res

        def dnc(L: int, R: int) -> int:
            if L >= R:
                return 0
            mid = (L + R) // 2
            return dnc(L, mid) + dnc(mid + 1, R) + count_cross(L, mid, R)
        return dnc(0, n - 1)

    for a, k in small_generator():
        assert solve_case(len(a), k, a) == brute(a, k)

if __name__ == "__main__":
    compare_solver()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple
from collections import defaultdict

def read_input() -> Tuple[int, int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, k, a

def solve_case(n: int, k: int, a: List[int]) -> int:
    if n <= 1:
        return 0
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i + 1] = (pref[i] + a[i]) % k

    def count_cross(L: int, mid: int, R: int) -> int:
        res = 0
        left_len = mid - L + 1
        left_mx_at = [0] * left_len
        mx = 0
        for i in range(mid, L - 1, -1):
            ai = a[i]
            mx = ai if ai > mx else mx
            left_mx_at[i - L] = mx
        right_len = R - mid
        right_mx_at = [0] * right_len
        mx = 0
        for j in range(mid + 1, R + 1):
            aj = a[j]
            mx = aj if aj > mx else mx
            right_mx_at[j - (mid + 1)] = mx

        # Left-dominant segments
        freq_right = defaultdict(int)
        j = mid + 1
        for i in range(mid, L - 1, -1):
            mx_left = left_mx_at[i - L]
            while j <= R and right_mx_at[j - (mid + 1)] <= mx_left:
                freq_right[pref[j + 1]] += 1
                j += 1
            res += freq_right.get((mx_left + pref[i]) % k, 0)

        # Right-dominant segments
        freq_left = defaultdict(int)
        i = mid
        for j in range(mid + 1, R + 1):
            mx_right = right_mx_at[j - (mid + 1)]
            while i >= L and left_mx_at[i - L] < mx_right:
                freq_left[pref[i]] += 1
                i -= 1
            res += freq_left.get((pref[j + 1] - mx_right) % k, 0)
        return res

    def dnc(L: int, R: int) -> int:
        if L >= R:
            return 0
        mid = (L + R) // 2
        return dnc(L, mid) + dnc(mid + 1, R) + count_cross(L, mid, R)

    return dnc(0, n - 1)

def solve_all() -> None:
    n, k, a = read_input()
    if n == 0:
        print(0)
        return
    print(solve_case(n, k, a))

def _tests():
    assert solve_case(2, 3, [1, 1]) == 0
    assert solve_case(2, 1, [5, 7]) == 1
    assert solve_case(4, 3, [1, 2, 3, 4]) == 3

if __name__ == "__main__":
    _tests()
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count segments where the subarray sum modulo $k$ equals the maximum value modulo $k$.}
\WHY{Tests modular arithmetic with prefix sums and advanced counting via divide \& conquer — a common 2800-level CF pattern.}
\CHECKLIST{
\begin{bullets}
\item Build prefix residues $P_j$.
\item Divide \& conquer by middle index.
\item Precompute left/right running maxima.
\item Case-split by dominant maximum ($\le$ vs $<$).
\item Count via frequency of target residues.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $k=1$ (everything divisible).
\item $n=1$ (answer $0$).
\item All $a_i$ equal.
\item Strictly increasing/decreasing arrays.
\item Large $a_i$ (ensure modulo only).
\item Multiple equal maxima crossing the middle.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in prefix indexing: condition uses $P_{l}$ and $P_{r+1}$ in $0$-based.
\item Double counting cross segments if not using $\le$ vs $<$ split.
\item Forgetting to require $l<r$ (length $\ge 2$).
\item Using raw sums without modulo $k$ leading to overflow in other languages.
\item Negative modulo mishandling (Python is safe; others may need normalization).
\item Recomputing maxima naively inside loops (breaks complexity).
\end{bullets}}
\FAILMODES{Naive $O(n^2)$ will time out for $n=300{,}000$. The D\&C approach survives adversarial arrays by ensuring each index is processed $O(\log n)$ times.}
\ELI{We want the sum-minus-largest to be divisible by $k$. Using prefix sums, this becomes a residue match. We count matches efficiently by splitting around the middle and growing windows where the max is known, aggregating residues with hash maps.}
\NotePages{3}

\end{document}