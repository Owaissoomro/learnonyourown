% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Longest Common Suffix Queries}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/longest-common-suffix-queries/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given two arrays of strings \texttt{wordsContainer} and \texttt{wordsQuery}. For each \texttt{wordsQuery[i]}, you need to find a string from \texttt{wordsContainer} that has the \textbf{longest common suffix} with \texttt{wordsQuery[i]}. If there are two or more strings in \texttt{wordsContainer} that share the longest common suffix, find the string that is the \textbf{smallest} in length. If there are two or more such strings that have the \textbf{same} smallest length, find the one that occurred \textbf{earlier} in \texttt{wordsContainer}. Return an array of integers \texttt{ans}, where \texttt{ans[i]} is the index of the string in \texttt{wordsContainer} that has the longest common suffix with \texttt{wordsQuery[i]}. 

\textbf{Example 1:} Input: \texttt{wordsContainer = ["abcd","bcd","xbcd"]}, \texttt{wordsQuery = ["cd","bcd","xyz"]}. Output: \texttt{[1,1,1]}. Explanation: 
\begin{itemize}
\item For \texttt{wordsQuery[0] = "cd"}, strings from \texttt{wordsContainer} that share the longest common suffix \texttt{"cd"} are at indices 0, 1, and 2. Among these, the answer is the string at index 1 because it has the shortest length of 3.
\item For \texttt{wordsQuery[1] = "bcd"}, strings from \texttt{wordsContainer} that share the longest common suffix \texttt{"bcd"} are at indices 0, 1, and 2. Among these, the answer is the string at index 1 because it has the shortest length of 3.
\item For \texttt{wordsQuery[2] = "xyz"}, there is no string from \texttt{wordsContainer} that shares a common suffix. Hence the longest common suffix is \texttt{""}, that is shared with strings at index 0, 1, and 2. Among these, the answer is the string at index 1 because it has the shortest length of 3.
\end{itemize}

\textbf{Example 2:} Input: \texttt{wordsContainer = ["abcdefgh","poiuygh","ghghgh"]}, \texttt{wordsQuery = ["gh","acbfgh","acbfegh"]}. Output: \texttt{[2,0,2]}. Explanation:
\begin{itemize}
\item For \texttt{wordsQuery[0] = "gh"}, strings from \texttt{wordsContainer} that share the longest common suffix \texttt{"gh"} are at indices 0, 1, and 2. Among these, the answer is the string at index 2 because it has the shortest length of 6.
\item For \texttt{wordsQuery[1] = "acbfgh"}, only the string at index 0 shares the longest common suffix \texttt{"fgh"}. Hence it is the answer, even though the string at index 2 is shorter.
\item For \texttt{wordsQuery[2] = "acbfegh"}, strings from \texttt{wordsContainer} that share the longest common suffix \texttt{"gh"} are at indices 0, 1, and 2. Among these, the answer is the string at index 2 because it has the shortest length of 6.
\end{itemize}

\textbf{Constraints:}
\begin{itemize}
\item $1 \le \texttt{wordsContainer.length},~\texttt{wordsQuery.length} \le 10^{4}$.
\item $1 \le \texttt{wordsContainer[i].length} \le 5 \times 10^{3}$.
\item $1 \le \texttt{wordsQuery[i].length} \le 5 \times 10^{3}$.
\item \texttt{wordsContainer[i]} consists only of lowercase English letters.
\item \texttt{wordsQuery[i]} consists only of lowercase English letters.
\item Sum of \texttt{wordsContainer[i].length} is at most $5 \times 10^{5}$.
\item Sum of \texttt{wordsQuery[i].length} is at most $5 \times 10^{5}$.
\end{itemize}}
\BREAKDOWN{Compute, for each query, the maximum suffix-match length against all container words under a two-tier tie-break: shortest container word length, then earliest index. Preprocess to answer all queries within the total character budget.}
\ELI{Reverse words so suffixes become prefixes; store, for every reversed prefix, the best container index by tie-break, then walk each reversed query to the deepest matching prefix.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two arrays of strings: \texttt{wordsContainer} and \texttt{wordsQuery}. All strings are nonempty and lowercase English letters. Length bounds: $|\texttt{wordsContainer}|,|\texttt{wordsQuery}| \le 10^{4}$; individual string lengths $\le 5 \times 10^{3}$; total characters across each array $\le 5 \times 10^{5}$.}
\OUTPUTS{An integer array \texttt{ans} of length $|\texttt{wordsQuery}|$ where \texttt{ans[i]} is the index in \texttt{wordsContainer} that has the longest common suffix with \texttt{wordsQuery[i]}. Ties broken by shorter container word, then by smaller index.}
\SAMPLES{Example 1: \texttt{wordsContainer=["abcd","bcd","xbcd"]}, \texttt{wordsQuery=["cd","bcd","xyz"]} $\to$ \texttt{[1,1,1]}. Example 2: \texttt{wordsContainer=["abcdefgh","poiuygh","ghghgh"]}, \texttt{wordsQuery=["gh","acbfgh","acbfegh"]} $\to$ \texttt{[2,0,2]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $C=\{c_{0},\ldots,c_{n-1}\}$ be the container strings and $Q=\{q_{0},\ldots,q_{m-1}\}$ the queries. For a pair $(c,q)$ define $\operatorname{lcsuf}(c,q)$ as the length of their longest common suffix. For each $q_{i}$ we output
\[
\operatorname*{arg\,min}_{k \in A_{i}} \bigl(|c_{k}|,~k\bigr)
\quad\text{where}\quad
A_{i}=\operatorname*{arg\,max}_{0\le k<n}~\operatorname{lcsuf}(c_{k},q_{i}).
\]
Lexicographic minimization on the pair $(|c_{k}|,k)$ implements the specified tie-breaking.}
\varmapStart
\var{n}{number of container strings}
\var{m}{number of queries}
\var{c_k}{the $k$-th container string}
\var{q_i}{the $i$-th query string}
\var{\ell(c,q)}{the integer $\operatorname{lcsuf}(c,q)$}
\var{b(P)}{the best index under tie-break among indices in set $P$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\ell(c,q)=\max\{t\in\mathbb{Z}_{\ge 0}:\text{the suffix of }c\text{ of length }t\text{ equals that of }q\}.
\end{BreakableEquation*}
\[
\text{Answer}(q_{i})=\operatorname*{arg\,min}_{k \in A_{i}} \bigl(|c_{k}|,k\bigr),\quad
A_{i}=\{k:\ell(c_{k},q_{i})=\max_{j}\ell(c_{j},q_{i})\}.
\]
}
\ASSUMPTIONS{All strings use only lowercase letters a--z. Indices are 0-based. If multiple container strings are identical, the earliest index wins by the tie-breaking rule.}
\INVARIANTS{Reversing strings maps suffixes to prefixes. For any fixed reversed prefix $p$, the set of container words that have $p$ as prefix determines a unique best index under $(|c_{k}|,k)$ ordering. Along a walk down reversed-query characters, the best index is nonincreasing under the ordering depth-wise defined by exact prefix sets.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly compute $\ell(c_{k},q_{i})$ by scanning from the ends of both strings and pick the best index by the specified ordering.}
\ASSUMPTIONS{No preprocessing; handle each query independently.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each query $q$, initialize best index $ans=-1$, best suffix length $bestL=-1$, best container length $bestLen=+\infty$.
\item For each container $c$ with index $k$, compute $t=\ell(c,q)$ by scanning from the ends while characters match.
\item Update the current best if $t$ is larger; or if equal and $|c|$ is smaller; or if equal again and $k$ is smaller.
\end{algosteps}
\COMPLEXITY{Let $L_{C}=\sum |c_{k}|$ and $L_{Q}=\sum |q_{i}|$. Worst-case time is $O\!\left(\sum_{i=0}^{m-1}\sum_{k=0}^{n-1}\min(|q_{i}|,|c_{k}|)\right)$, which is too large in general. Space is $O(1)$ beyond inputs.}
\[
\begin{aligned}
T_{\text{baseline}} &\le \sum_{i=0}^{m-1}\sum_{k=0}^{n-1}\min(|q_{i}|,|c_{k}|) \\
&\le \left(\sum_{i}|q_{i}|\right)\cdot n = n\,L_{Q}\quad\text{(in worst case)}.
\end{aligned}
\]
\CORRECTNESS{By definition of $\ell$ and exhaustive comparison against every container string, the selected index matches the exact maximizer under the given tie-breaking.}
\EDGECASES{No matching characters implies longest common suffix length $0$; then the winner is the shortest container string, with earliest index on ties. Identical words prefer the earliest index.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:
        n = len(wordsContainer)

        def lcsuf_len(a: str, b: str) -> int:
            i, j = len(a) - 1, len(b) - 1
            cnt = 0
            while i >= 0 and j >= 0 and a[i] == b[j]:
                cnt += 1
                i -= 1
                j -= 1
            return cnt

        lens = [len(w) for w in wordsContainer]
        res = []
        for q in wordsQuery:
            bestL = -1
            bestLen = 10**18
            bestIdx = -1
            for k, w in enumerate(wordsContainer):
                t = lcsuf_len(w, q)
                if t > bestL:
                    bestL, bestLen, bestIdx = t, lens[k], k
                elif t == bestL:
                    if lens[k] < bestLen or (lens[k] == bestLen and k < bestIdx):
                        bestLen, bestIdx = lens[k], k
            res.append(bestIdx)
        return res

# Basic asserts for the baseline approach
def _test_baseline():
    sol = Solution()
    assert sol.stringIndices(["abcd","bcd","xbcd"], ["cd","bcd","xyz"]) == [1,1,1]
    assert sol.stringIndices(["abcdefgh","poiuygh","ghghgh"], ["gh","acbfgh","acbfegh"]) == [2,0,2]
    # Edge: no common suffix beyond empty
    assert sol.stringIndices(["a","bb","ccc"], ["zz"]) == [0]  # shortest is "a" at index 0
_test_baseline()
\end{minted}
\VALIDATION{Checked on both provided examples and an edge case with only empty-suffix matches.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prefix Map on Reversed Words}
\WHICHFORMULA{Reverse each container word so suffixes become prefixes. For each reversed prefix, store the best container index by tie-break. For each reversed query, scan its prefixes and use the best index of the deepest prefix found.}
\ASSUMPTIONS{Hash map from string prefix to best index. Total number of stored prefixes is at most the total characters across container words.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each container word $c_{k}$, compute $r=\operatorname{rev}(c_{k})$. For every prefix $p$ of $r$ (including empty), update $best[p]$ by comparing $(|c_{k}|,k)$.
\item For each query $q$, compute $s=\operatorname{rev}(q)$ and traverse its prefixes from left to right, maintaining the last seen $best[p]$; return the last seen index (or the empty-prefix best if none deeper).
\item The empty prefix represents longest common suffix length $0$.
\end{algosteps}
\COMPLEXITY{Building the map takes $O(L_{C})$ time and space. Answering queries scans prefixes of each reversed query in $O(|q|)$, totaling $O(L_{Q})$.}
\[
\begin{aligned}
T_{\text{build}} &= O\!\left(\sum_{k}|c_{k}|\right) = O(L_{C}),\\
T_{\text{query}} &= O\!\left(\sum_{i}|q_{i}|\right) = O(L_{Q}),\quad S=O(L_{C}).
\end{aligned}
\]
\CORRECTNESS{For any query, the deepest matching prefix of its reversed form corresponds exactly to the maximum-length common suffix. Storing the best index per prefix enforces the tie-breaking locally among exactly those container words that share that suffix.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:
        n = len(wordsContainer)
        lens = [len(w) for w in wordsContainer]

        def better(i: int, j: int) -> int:
            if j == -1:
                return i
            if lens[i] < lens[j]:
                return i
            if lens[i] > lens[j]:
                return j
            return i if i < j else j

        best = {}  # prefix -> best index
        global_best = -1
        for i, w in enumerate(wordsContainer):
            global_best = better(i, global_best)
            r = w[::-1]
            pref = ""
            # include empty prefix
            if "" not in best:
                best[""] = i
            else:
                best[""] = better(i, best[""])
            for ch in r:
                pref += ch
                if pref in best:
                    best[pref] = better(i, best[pref])
                else:
                    best[pref] = i

        res = []
        for q in wordsQuery:
            r = q[::-1]
            pref = ""
            ans = best.get("", -1)
            for ch in r:
                pref += ch
                if pref in best:
                    ans = best[pref]
                else:
                    break
            res.append(ans)
        return res

# Asserts for improved approach
def _test_improved():
    sol = Solution()
    assert sol.stringIndices(["abcd","bcd","xbcd"], ["cd","bcd","xyz"]) == [1,1,1]
    assert sol.stringIndices(["abcdefgh","poiuygh","ghghgh"], ["gh","acbfgh","acbfegh"]) == [2,0,2]
    # Tie on empty suffix: pick shortest, then earliest
    assert sol.stringIndices(["bbb","a","cc"], ["xyz"]) == [1]
_test_improved()
\end{minted}
\VALIDATION{Validated on samples and a case that forces the empty-suffix tie-break to choose the shortest, earliest container word.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Reversed Trie With Best-Index Per Node}
\WHICHFORMULA{Build a trie over reversed container words. Each node stores the best container index among words passing through that node, under the $(|c_{k}|,k)$ ordering. To answer a query, walk the trie along reversed query characters; the answer is the best index at the deepest reachable node.}
\ASSUMPTIONS{Children per node stored as sparse maps (dictionaries) keyed by characters a--z for memory efficiency.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a root node with best index set using the empty suffix rule.
\item For each container word $c_{k}$, traverse its reversed characters; create missing nodes; at each visited node, update the stored best index via the comparator.
\item For each query $q$, traverse reversed $q$ from the root; at each step, if the next edge exists, descend and update the current answer to the node's best; else stop. Return the last recorded best.
\end{algosteps}
\OPTIMALITY{Each character of each container word and each query is processed at most once, resulting in linear total time $O(L_{C}+L_{Q})$ and linear space in the number of trie nodes $O(L_{C})$. This matches information-theoretic lower bounds up to constant factors given arbitrary strings and the need to inspect characters.}
\COMPLEXITY{Time $T=O(L_{C}+L_{Q})$, space $S=O(L_{C})$.}
\[
\begin{aligned}
T &= \Theta\!\left(\sum_{k}|c_{k}| + \sum_{i}|q_{i}|\right),\quad
S = \Theta\!\left(\sum_{k}|c_{k}|\right).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Dict

class Solution:
    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:
        lens = [len(w) for w in wordsContainer]

        def better(i: int, j: int) -> int:
            if j == -1:
                return i
            if lens[i] < lens[j]:
                return i
            if lens[i] > lens[j]:
                return j
            return i if i < j else j

        children: List[Dict[str, int]] = []
        best: List[int] = []

        def new_node() -> int:
            children.append({})
            best.append(-1)
            return len(children) - 1

        root = new_node()
        # Build trie
        for idx, w in enumerate(wordsContainer):
            best[root] = better(idx, best[root])
            node = root
            for ch in reversed(w):
                nxt = children[node].get(ch, -1)
                if nxt == -1:
                    nxt = new_node()
                    children[node][ch] = nxt
                node = nxt
                best[node] = better(idx, best[node])

        # Answer queries
        ans = []
        for q in wordsQuery:
            node = root
            cur = best[root]
            for ch in reversed(q):
                if ch in children[node]:
                    node = children[node][ch]
                    cur = best[node]
                else:
                    break
            ans.append(cur)
        return ans

# Exact assertions (3 tests)
def _test_final():
    sol = Solution()
    assert sol.stringIndices(["abcd","bcd","xbcd"], ["cd","bcd","xyz"]) == [1,1,1]
    assert sol.stringIndices(["abcdefgh","poiuygh","ghghgh"], ["gh","acbfgh","acbfegh"]) == [2,0,2]
    # Mixed sizes and ties
    assert sol.stringIndices(["aaaa", "baaa", "c"], ["x", "aa", "aaa", "zaaa"]) == [2,0,0,1]
_test_final()
\end{minted}
\VALIDATION{Three asserts: both provided examples and a crafted case that exercises empty suffix, deeper matches, and tie-breaking on length then index.}
\RESULT{For each query, returns the index of the container string with the deepest shared suffix; among ties, the shortest container word wins, and among equal lengths, the earliest index wins.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: examples, no-shared-suffix scenarios, full-word matches, and tie-breaking on length and index. Property checks: increasing a query by adding the same trailing character cannot reduce the longest-common-suffix depth unless the character blocks traversal.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline, Improved, and Optimal implementations on small random cases to ensure identical answers.}
\LINE{EDGE-CASE GENERATOR}{Generate random strings over a--c with small lengths; include duplicates in container; include queries shorter, equal, and longer than container words; include characters absent from container tails.}
\begin{minted}{python}
from typing import List
import random

def gen_case(n: int, m: int, maxlen: int = 6, alpha: str = "abc") -> (List[str], List[str]):
    def rand_word():
        return "".join(random.choice(alpha) for _ in range(1, random.randint(1, maxlen+1)))
    wordsC = [rand_word() for _ in range(n)]
    wordsQ = [rand_word() for _ in range(m)]
    return wordsC, wordsQ

# Reference (trie-based) solution
class Solution:
    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:
        lens = [len(w) for w in wordsContainer]
        def better(i: int, j: int) -> int:
            if j == -1:
                return i
            if lens[i] < lens[j]:
                return i
            if lens[i] > lens[j]:
                return j
            return i if i < j else j
        children = []
        best = []
        def new_node():
            children.append({})
            best.append(-1)
            return len(children)-1
        root = new_node()
        for i, w in enumerate(wordsContainer):
            best[root] = better(i, best[root])
            node = root
            for ch in reversed(w):
                if ch not in children[node]:
                    children[node][ch] = new_node()
                node = children[node][ch]
                best[node] = better(i, best[node])
        ans = []
        for q in wordsQuery:
            node = root
            cur = best[root]
            for ch in reversed(q):
                if ch in children[node]:
                    node = children[node][ch]
                    cur = best[node]
                else:
                    break
            ans.append(cur)
        return ans

# Quick cross-check against the baseline on a few random seeds
def _cross_check():
    import itertools
    random.seed(0)
    class Baseline:
        def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:
            lens = [len(w) for w in wordsContainer]
            def lcs(a: str, b: str) -> int:
                i, j, cnt = len(a)-1, len(b)-1, 0
                while i >= 0 and j >= 0 and a[i] == b[j]:
                    cnt += 1; i -= 1; j -= 1
                return cnt
            res = []
            for q in wordsQuery:
                bestL, bestLen, bestIdx = -1, 10**9, -1
                for k, w in enumerate(wordsContainer):
                    t = lcs(w, q)
                    if t > bestL or (t == bestL and (lens[k] < bestLen or (lens[k] == bestLen and k < bestIdx))):
                        bestL, bestLen, bestIdx = t, lens[k], k
                res.append(bestIdx)
            return res
    for _ in range(50):
        C, Q = gen_case(5, 7, maxlen=5, alpha="abcd")
        ref = Solution().stringIndices(C, Q)
        bf = Baseline().stringIndices(C, Q)
        assert ref == bf, (C, Q, ref, bf)
_cross_check()

# Final reference sanity on the given examples
def _final_examples():
    sol = Solution()
    assert sol.stringIndices(["abcd","bcd","xbcd"], ["cd","bcd","xyz"]) == [1,1,1]
    assert sol.stringIndices(["abcdefgh","poiuygh","ghghgh"], ["gh","acbfgh","acbfegh"]) == [2,0,2]
_final_examples()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Dict

class Solution:
    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:
        lens = [len(w) for w in wordsContainer]

        def better(i: int, j: int) -> int:
            if j == -1:
                return i
            if lens[i] < lens[j]:
                return i
            if lens[i] > lens[j]:
                return j
            return i if i < j else j

        children: List[Dict[str, int]] = []
        best: List[int] = []

        def new_node() -> int:
            children.append({})
            best.append(-1)
            return len(children) - 1

        root = new_node()
        for idx, w in enumerate(wordsContainer):
            best[root] = better(idx, best[root])
            node = root
            for ch in reversed(w):
                nxt = children[node].get(ch, -1)
                if nxt == -1:
                    nxt = new_node()
                    children[node][ch] = nxt
                node = nxt
                best[node] = better(idx, best[node])

        ans = []
        for q in wordsQuery:
            node = root
            cur = best[root]
            for ch in reversed(q):
                if ch in children[node]:
                    node = children[node][ch]
                    cur = best[node]
                else:
                    break
            ans.append(cur)
        return ans

# Reference asserts
def _ref_asserts():
    sol = Solution()
    assert sol.stringIndices(["abcd","bcd","xbcd"], ["cd","bcd","xyz"]) == [1,1,1]
    assert sol.stringIndices(["abcdefgh","poiuygh","ghghgh"], ["gh","acbfgh","acbfegh"]) == [2,0,2]
    # Tie on length -> earliest index
    assert sol.stringIndices(["aa","bb","cc"], ["z"]) == [0]
_ref_asserts()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reverse strings and use a per-prefix best-index structure (trie or hash map) to answer longest common suffix queries in linear total time.}
\WHY{Suffix-based matching with lexicographic tie-breaking is common in tries, autocomplete, and string DP tasks; efficient preprocessing is essential under high total character budgets.}
\CHECKLIST{
\begin{bullets}
\item Reverse all container words once; maintain comparator by (length, index).
\item Store best index at root for empty suffix.
\item During build, update best at every traversed node.
\item For each query, traverse reversed characters until a missing edge.
\item Return the last node's stored best.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item No matching suffix beyond empty: must return shortest container, earliest on ties.
\item Multiple identical container strings: earliest index wins.
\item Query longer than any container: still matches by suffix depth.
\item Full-word match: deepest node equals full reversed word.
\item Single-character alphabets: deep chains stress traversal.
\item Mixed lengths with same suffixes: tie-break strictly by length then index.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to initialize root's best index for empty suffix.
\item Comparing by lexicographic order instead of length when breaking ties.
\item Not updating best at intermediate nodes during insertion.
\item Using dense 26-way arrays may blow memory; prefer sparse maps in Python.
\item Breaking traversal too late or returning first match instead of deepest.
\item Ignoring earliest-index tie after equal lengths.
\end{bullets}
}
\FAILMODES{Brute force will time out when $n$ and total lengths are large. Hash-only solutions that do not store all prefixes fail to capture intermediate suffix depths. The trie/map approach survives adversarial inputs because each character is processed at most once.}
\ELI{Flip words so that what used to be the end is now the beginning. Build a directory that, for every beginning chunk, tells you which container word is best. For each query, walk as far as possible in that directory and return the saved best index.}
\NotePages{3}

\end{document}