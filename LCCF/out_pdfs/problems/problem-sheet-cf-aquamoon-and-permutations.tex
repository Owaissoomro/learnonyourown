% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — AquaMoon and Permutations}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1545/C}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{Cirno has prepared $n$ arrays of length $n$ each. Each array is a permutation of $n$ integers from $1$ to $n$. These arrays are special: for all $1 \le i \le n$, if we take the $i$-th element of each array and form another array of length $n$ with these elements, the resultant array is also a permutation of $n$ integers from $1$ to $n$. In other words, if you put these $n$ arrays under each other to form a matrix with $n$ rows and $n$ columns, this matrix is a Latin square.

Afterwards, Cirno added additional $n$ arrays, each array is a permutation of $n$ integers from $1$ to $n$. For all $1 \le i \le n$, there exists at least one position $1 \le k \le n$, such that for the $i$-th array and the $(n + i)$-th array, the $k$-th element of both arrays is the same. Notice that the arrays indexed from $n + 1$ to $2n$ do not have to form a Latin square.

Also, Cirno made sure that for all $2n$ arrays, no two arrays are completely equal, i.e. for all pairs of indices $1 \le i < j \le 2n$, there exists at least one position $1 \le k \le n$, such that the $k$-th elements of the $i$-th and $j$-th array are different.

Finally, Cirno arbitrarily changed the order of $2n$ arrays.

AquaMoon calls a subset of all $2n$ arrays of size $n$ good if these arrays form a Latin square.

AquaMoon wants to know how many good subsets exist. Because this number may be particularly large, find it modulo $998{,}244{,}353$. Also, she wants to find any good subset. Can you help her?

Input:
The input consists of multiple test cases. The first line contains a single integer $t$ ($1 \le t \le 100$) — the number of test cases.

The first line of each test case contains a single integer $n$ ($5 \le n \le 500$).

Then $2n$ lines follow. The $i$-th of these lines contains $n$ integers, representing the $i$-th array.

It is guaranteed that the sum of $n$ over all test cases does not exceed $500$.

Output:
For each test case print two lines.

In the first line, print the number of good subsets modulo $998{,}244{,}353$.

In the second line, print $n$ indices from $1$ to $2n$ — indices of the $n$ arrays that form a good subset (you can print them in any order). If there are several possible answers — print any of them.

Note:
In the first test case, the number of good subsets is $1$. The only such subset is the set of arrays with indices $1$, $2$, $3$, $4$, $5$, $6$, $7$.

In the second test case, the number of good subsets is $2$. They are $1$, $3$, $5$, $6$, $10$ or $2$, $4$, $7$, $8$, $9$.}
\BREAKDOWN{We must pick $n$ rows out of $2n$ such that in each column the chosen values are all distinct (thus a permutation). Count all such subsets modulo $998{,}244{,}353$ and output one valid subset. A conflict graph approach and a bucket frequency trick per $(\text{column}, \text{value})$ pair yield a linear-time greedy with cycle components contributing a factor of $2$.}
\ELI{Treat each column--value pair as a constraint that exactly one chosen row can satisfy; pick forced rows when a constraint has only one candidate left; when no forces remain, each remaining component is a cycle with $2$ choices.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test:
- $n$: integer, $5 \le n \le 500$.
- $2n$ arrays $a_i$ of length $n$, entries in $\{1,\ldots,n\}$, each array is a permutation. The total $\sum n \le 500$.}
\OUTPUTS{For each test case:
- First line: the number of good subsets modulo $998{,}244{,}353$.
- Second line: $n$ distinct indices from $1$ to $2n$ forming one good subset (any order).}
\SAMPLES{Example 1 (schematic):
- Input: $t=1$, $n=5$, $10$ arrays (permutations).
- Output: a single number and $5$ indices forming a Latin square.

Example 2:
- Two different valid subsets exist; output count $2$ and either subset.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in [n]^{2n \times n}$ be the given matrix of $2n$ rows and $n$ columns, where each row is a permutation of $[n]=\{1,\ldots,n\}$. A subset $S \subseteq [2n]$ with $|S|=n$ is good iff for every column $c \in [n]$, the multiset $\{A_{r,c} : r \in S\}$ equals $[n]$ (i.e., all $n$ distinct values appear exactly once). Equivalently, for all $c$, the values are pairwise distinct across $S$.}
\varmapStart
\var{n}{order of permutations and number of rows in a good subset}
\var{A_{r,c}}{value in row $r$, column $c$}
\var{S}{set of selected rows (indices) with $|S|=n$}
\var{B(c,v)}{bucket of rows having value $v$ in column $c$}
\var{G}{conflict graph on rows: edge if two rows agree in some column}
\varmapEnd
\GOVERN{
\[
\forall c \in [n]:~\{A_{r,c}: r \in S\}\text{ are pairwise distinct}
\quad\Longleftrightarrow\quad
\forall r\ne r' \in S,~\forall c,~A_{r,c} \ne A_{r',c}.
\]
}
\ASSUMPTIONS{All rows are permutations; no two rows are identical. There exists a hidden pairing between the original Latin-square rows and the added rows, each pair sharing at least one equal cell.}
\INVARIANTS{
- If a bucket $B(c,v)$ has exactly one alive row, that row must be selected in any good subset.
- During selection, once a row $r$ is chosen, every row agreeing with $r$ in any column must be discarded; this maintains pairwise distinctness in each column among remaining candidates.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Model as a constraint satisfaction problem: for each column--value pair $(c,v)$, exactly one selected row must realize $A_{r,c}=v$. Try to search subsets with pruning using unit constraints.}
\ASSUMPTIONS{Suitable only for tiny $n$; we aggressively prune using forced picks (unit buckets).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build buckets $B(c,v)=\{r: A_{r,c}=v\}$ and counts $|B(c,v)|$.
\item Repeatedly select any row that is the unique candidate in some $B(c,v)$; discard all rows conflicting with it.
\item If no forced row exists, branch: choose an arbitrary remaining row and try including it (discarding conflicts) versus excluding it.
\end{algosteps}
\COMPLEXITY{Exponential in residual size after forcing, impractical for $n \ge 5$. For $m=2n$ rows:
\[
\begin{aligned}
T(m) &\approx 2^{k}\cdot \text{poly}(m n) \\
S(m) &= O(m n).
\end{aligned}
\]
}
\CORRECTNESS{Unit propagation preserves feasibility; once no forces remain, branching explores both choices for a pivot row, thereby covering all feasible subsets.}
\EDGECASES{Multiple buckets hitting the same row; columns with many duplicates; early contradictions when a bucket becomes empty.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

MOD = 998244353

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        rows = []
        for _ in range(2*n):
            row = [int(next(it)) for _ in range(n)]
            rows.append(row)
        tests.append((n, rows))
    return tests

def validate_subset(n, rows, pick):
    m = 2*n
    assert len(pick) == n
    assert all(1 <= i <= m for i in pick)
    S = [i-1 for i in pick]
    # Columns are permutations
    for c in range(n):
        seen = set()
        for r in S:
            v = rows[r][c]
            assert 1 <= v <= n
            assert v not in seen, f"duplicate in column {c}"
            seen.add(v)
        assert len(seen) == n

def solve_case_baseline(n, rows):
    m = 2*n
    # Build buckets
    buckets = [[[] for _ in range(n+1)] for _ in range(n)]
    for r in range(m):
        for c in range(n):
            v = rows[r][c]
            buckets[c][v].append(r)
    # Quick invariant: per column, total memberships equals m
    for c in range(n):
        tot = sum(len(buckets[c][v]) for v in range(1, n+1))
        assert tot == m

    alive = [True]*m
    chosen = [False]*m

    # Helper: remove a row from consideration (not chosen)
    def remove_row(x, force_queue):
        if not alive[x]:
            return
        alive[x] = False
        for c in range(n):
            v = rows[x][c]
            # Decrement count and if becomes 1, enqueue the sole alive candidate
            # We find it by scanning the small bucket.
            cnt_alive = 0
            last_alive = -1
            for y in buckets[c][v]:
                if alive[y]:
                    cnt_alive += 1
                    last_alive = y
                    if cnt_alive > 1:
                        break
            if cnt_alive == 1 and last_alive != -1:
                force_queue.append(last_alive)

    # Selection procedure returning one solution; count via backtracking (tiny only)
    def snapshot_state():
        return alive[:], chosen[:]

    def restore_state(snap):
        nonlocal alive, chosen
        alive, chosen = snap

    # Greedy force all unit buckets; return list of forced picks (order)
    def force_all():
        q = deque()
        in_q = [False]*m
        for c in range(n):
            for v in range(1, n+1):
                cnt_alive = 0
                last_alive = -1
                for y in buckets[c][v]:
                    if alive[y]:
                        cnt_alive += 1
                        last_alive = y
                        if cnt_alive > 1:
                            break
                if cnt_alive == 1 and last_alive != -1 and not in_q[last_alive]:
                    q.append(last_alive)
                    in_q[last_alive] = True
        forced = []
        while q:
            r = q.popleft()
            if not alive[r]:
                continue
            if chosen[r]:
                continue
            # Choose r
            chosen[r] = True
            # Remove conflicts (including r itself)
            remove_row(r, q)  # remove r
            for c in range(n):
                v = rows[r][c]
                for y in buckets[c][v]:
                    if alive[y]:
                        remove_row(y, q)
            forced.append(r)
        return forced

    def current_solution():
        return [i+1 for i, ok in enumerate(chosen) if ok]

    # Backtracking for tiny problem instances
    def backtrack():
        forced = force_all()
        sol = current_solution()
        if len(sol) == n:
            return (1, sol)
        # If impossible (some bucket empty), detect by checking any column-value with zero alive
        for c in range(n):
            for v in range(1, n+1):
                if all(not alive[y] for y in buckets[c][v]):
                    return (0, [])
        # Pick first alive, branch
        pivot = next(i for i in range(m) if alive[i])
        # Branch include pivot
        snap = snapshot_state()
        chosen[pivot] = True
        q = deque()
        remove_row(pivot, q)
        for c in range(n):
            v = rows[pivot][c]
            for y in buckets[c][v]:
                if alive[y]:
                    remove_row(y, q)
        cnt1, sol1 = backtrack()
        # Restore and branch exclude pivot
        restore_state(snap)
        q = deque()
        remove_row(pivot, q)
        cnt2, sol2 = backtrack()
        cnt = (cnt1 + cnt2) % MOD
        sol = sol1 if cnt1 > 0 else sol2
        return (cnt, sol)

    cnt, sol = backtrack()
    if not sol:
        # Fallback to empty (should not happen for valid inputs)
        sol = list(range(1, n+1))
    return cnt % MOD, sol

def solve_all_baseline(tests):
    out_lines = []
    for n, rows in tests:
        cnt, sol = solve_case_baseline(n, rows)
        # Validate picked subset
        validate_subset(n, rows, sol)
        out_lines.append(str(cnt % MOD))
        out_lines.append(" ".join(map(str, sol)))
    return "\n".join(out_lines)

def main():
    tests = read_input()
    print(solve_all_baseline(tests))

if __name__ == "__main__":
    # The baseline solver is exponential; do not run extra tests here.
    main()
\end{minted}
\VALIDATION{Asserts ensure per-column bucket memberships sum to $2n$ and the output subset forms column permutations. Use only for tiny handcrafted cases due to exponential behavior.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Bucket Forcing + Arbitrary Picks}
\WHICHFORMULA{Use buckets $B(c,v)$ and repeatedly pick forced rows where $|B(c,v)|=1$. When no forced rows remain, pick any alive row, multiply the answer by $2$, and continue.}
\ASSUMPTIONS{After exhaustive forcing, the remaining structure consists of disjoint even cycles; each contributes a factor $2$ (choose one of two alternating independent sets).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build buckets $B(c,v)$ and maintain alive counts per bucket.
\item While a bucket has count $1$, select its sole row; mark it chosen; remove it and all conflicting rows from all buckets, updating counts and enqueuing new forced rows.
\item If no forced row exists but rows remain, pick any alive row, multiply answer by $2$, then select it as above.
\item Continue until all rows are removed. The $n$ selected rows form a valid subset; the product gives the count modulo $998{,}244{,}353$.
\end{algosteps}
\COMPLEXITY{Each removal updates $n$ buckets; each bucket scan is small (average frequency $\approx 2$). Total time $O(n \cdot 2n \cdot \alpha)$ with a small constant; space $O(n \cdot 2n)$.
\[
\begin{aligned}
T &= O(n \cdot 2n + \text{total bucket scans}) \approx O(n^2) \\
S &= O(n^2).
\end{aligned}
\]
}
\CORRECTNESS{Forced selections are mandatory to satisfy exactly-one constraints. When no forces remain, every bucket has size either $0$ or $2$, and the residual conflict graph decomposes into even cycles; choosing any starting row fixes an alternating selection, giving $2$ choices per cycle.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque

MOD = 998244353

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        rows = []
        for _ in range(2*n):
            rows.append([int(next(it)) for _ in range(n)])
        tests.append((n, rows))
    return tests

def validate_subset(n, rows, pick):
    m = 2*n
    assert len(pick) == n
    S = [i-1 for i in pick]
    assert len(set(S)) == n
    for c in range(n):
        seen = set()
        for r in S:
            v = rows[r][c]
            assert 1 <= v <= n
            assert v not in seen
            seen.add(v)
        assert len(seen) == n

def solve_case_improved(n, rows):
    m = 2*n
    buckets = [[[] for _ in range(n+1)] for _ in range(n)]
    for r in range(m):
        for c in range(n):
            v = rows[r][c]
            buckets[c][v].append(r)
    # Quick invariant: per column sum is m
    for c in range(n):
        tot = sum(len(buckets[c][v]) for v in range(1, n+1))
        assert tot == m

    alive = [True]*m
    chosen = [False]*m
    ans_rows = []
    ans = 1

    q = deque()
    in_q = [False]*m

    # Helper: push the unique alive row of a bucket if any
    def push_if_unique(c, v):
        cnt = 0
        last = -1
        for r in buckets[c][v]:
            if alive[r]:
                cnt += 1
                last = r
                if cnt > 1:
                    break
        if cnt == 1 and last != -1 and not in_q[last]:
            q.append(last)
            in_q[last] = True

    # Remove a row from alive set, update buckets and queue
    def remove_row(x):
        if not alive[x]:
            return
        alive[x] = False
        for c in range(n):
            v = rows[x][c]
            # If bucket might become unique, check
            push_if_unique(c, v)

    # Select a row: choose it and remove all conflicts (including itself)
    def select_row(r):
        if not alive[r]:
            return
        chosen[r] = True
        ans_rows.append(r)
        remove_row(r)
        for c in range(n):
            v = rows[r][c]
            for y in buckets[c][v]:
                if alive[y]:
                    remove_row(y)

    # Seed initial forced rows
    for c in range(n):
        for v in range(1, n+1):
            push_if_unique(c, v)

    remaining = m
    while remaining > 0:
        # Pop forced selections
        progressed = False
        while q:
            r = q.popleft()
            in_q[r] = False
            if not alive[r]:
                continue
            progressed = True
            select_row(r)
        if progressed:
            # Recount remaining
            remaining = sum(1 for z in range(m) if alive[z])
            continue
        # No forced rows: start a new cycle component
        if remaining == 0:
            break
        # Pick any alive row
        r = next(i for i in range(m) if alive[i])
        ans = (ans * 2) % MOD
        select_row(r)
        remaining = sum(1 for z in range(m) if alive[z])

    # Convert to 1-based indices
    sol = [i+1 for i in ans_rows]
    assert len(sol) == n
    validate_subset(n, rows, sol)
    return ans % MOD, sol

def solve_all_improved(tests):
    out_lines = []
    for n, rows in tests:
        cnt, sol = solve_case_improved(n, rows)
        out_lines.append(str(cnt))
        out_lines.append(" ".join(map(str, sol)))
    return "\n".join(out_lines)

def main():
    tests = read_input()
    print(solve_all_improved(tests))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts check per-column memberships and final subset validity. Algorithm runs in near-quadratic time in practice for the given bounds.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Constraint Buckets + Cycle Decomposition}
\WHICHFORMULA{Maintain per $(c,v)$ bucket alive counts; greedily pick forced rows; when none exist, arbitrarily pick one row per residual cycle, multiplying the answer by $2$ for each cycle.}
\ASSUMPTIONS{Under the problem's promise, after exhausting unit buckets, each remaining bucket has size $2$, inducing a disjoint union of even cycles in the implicit conflict graph.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize buckets $B(c,v)$ from the $2n$ rows.
\item Repeatedly:
  - If some $B(c,v)$ has exactly one alive row $r$, select $r$ and remove $r$ and all its conflicts.
  - Else, pick any alive row $r$, set $\text{ans} \leftarrow 2 \cdot \text{ans} \bmod 998{,}244{,}353$, select $r$, and remove its conflicts.
\item The selected rows form a valid subset; $\text{ans}$ is the total number of good subsets modulo $998{,}244{,}353$.}
\OPTIMALITY{Each residual component is an even cycle contributing exactly two independent alternating choices; forced picks uniquely determined by constraints do not branch. Hence the product of $2$ over components is both a lower and upper bound, yielding the exact count.}
\COMPLEXITY{Each row is removed once, touching $n$ buckets; each uniqueness check scans small buckets. Overall:
\[
\begin{aligned}
T(n) &= O(n \cdot 2n) \approx O(n^2), \\
S(n) &= O(n \cdot 2n) \approx O(n^2).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

MOD = 998244353

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        rows = []
        for _ in range(2*n):
            rows.append([int(next(it)) for _ in range(n)])
        tests.append((n, rows))
    return tests

def validate_subset(n, rows, pick):
    m = 2*n
    assert len(pick) == n
    S = [i-1 for i in pick]
    assert len(set(S)) == n
    # Check Latin property: columns are permutations
    for c in range(n):
        seen = set()
        for r in S:
            v = rows[r][c]
            assert 1 <= v <= n
            assert v not in seen
            seen.add(v)
        assert len(seen) == n

def solve_case(n, rows):
    m = 2*n
    # Buckets: buckets[c][v] = list of row indices having value v in column c
    buckets = [[[] for _ in range(n+1)] for _ in range(n)]
    for r in range(m):
        for c in range(n):
            v = rows[r][c]
            buckets[c][v].append(r)
    # Sanity: per column total memberships = m
    for c in range(n):
        tot = sum(len(buckets[c][v]) for v in range(1, n+1))
        assert tot == m

    alive = [True]*m
    chosen = [False]*m
    ans_rows = []
    ans = 1

    q = deque()
    in_q = [False]*m

    # Push row if (c,v) bucket becomes unique
    def push_if_unique(c, v):
        cnt = 0
        last = -1
        for r in buckets[c][v]:
            if alive[r]:
                cnt += 1
                last = r
                if cnt > 1:
                    break
        if cnt == 1 and last != -1 and not in_q[last]:
            q.append(last)
            in_q[last] = True

    # Remove a row from alive candidates and update uniqueness
    def remove_row(x):
        if not alive[x]:
            return
        alive[x] = False
        for c in range(n):
            v = rows[x][c]
            push_if_unique(c, v)

    # Select a row: choose it and eliminate all conflicting rows
    def select_row(r):
        if not alive[r]:
            return
        chosen[r] = True
        ans_rows.append(r)
        # Remove r
        remove_row(r)
        # Remove conflicts: any row sharing any (c,v) with r
        for c in range(n):
            v = rows[r][c]
            for y in buckets[c][v]:
                if alive[y]:
                    remove_row(y)

    # Initialize queue with current unique buckets
    for c in range(n):
        for v in range(1, n+1):
            push_if_unique(c, v)

    remaining = m
    while remaining > 0:
        progressed = False
        while q:
            r = q.popleft()
            in_q[r] = False
            if not alive[r]:
                continue
            progressed = True
            select_row(r)
        if progressed:
            remaining = sum(1 for i in range(m) if alive[i])
            continue
        if remaining == 0:
            break
        # Start a new cycle: arbitrary pick, multiply answer by 2
        pivot = next(i for i in range(m) if alive[i])
        ans = (ans * 2) % MOD
        select_row(pivot)
        remaining = sum(1 for i in range(m) if alive[i])

    sol = [i+1 for i in ans_rows]
    assert len(sol) == n
    validate_subset(n, rows, sol)
    return ans % MOD, sol

def solve_all(tests):
    out_lines = []
    for n, rows in tests:
        cnt, sol = solve_case(n, rows)
        out_lines.append(str(cnt))
        out_lines.append(" ".join(map(str, sol)))
    return "\n".join(out_lines)

def main():
    tests = read_input()
    print(solve_all(tests))

if __name__ == "__main__":
    # Basic internal test on a tiny handcrafted instance
    def tiny_test():
        n = 5
        # Latin square rows
        base = [[(i+j) % n + 1 for j in range(n)] for i in range(n)]
        extra = []
        for i in range(n):
            r = base[i][:]
            # swap two positions to avoid identical rows, still share many positions
            r[0], r[1] = r[1], r[0]
            extra.append(r)
        rows = base + extra
        tests = [(n, rows)]
        res = solve_all(tests)
        cnt = int(res.split()[0])
        assert cnt > 0
    tiny_test()
    main()
\end{minted}
\VALIDATION{Exactly 3 validations:
- Per-column bucket membership equals $2n$.
- The final selected set has size $n$ and forms a Latin square by column.
- A tiny handcrafted instance passes with a strictly positive count.}
\RESULT{Outputs the total number of good subsets modulo $998{,}244{,}353$ and one valid subset of row indices (1-based). Any order is acceptable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks of structural invariants; randomized tiny instances from a Latin square with perturbed paired rows; verification that output subset is valid.}
\LINE{CROSS-CHECKS}{Compare counts from Approach B and C on tiny cases; both must match. Greedy selections should always produce a valid subset.}
\LINE{EDGE-CASE GENERATOR}{Generate instances where many buckets are initially unique (strong forcing) and instances with no initial unique buckets (pure cycles), ensuring both branches are exercised.}
\begin{minted}{python}
import random

def gen_instance(n, seed=0):
    random.seed(seed)
    # Base Latin square by cyclic shifts
    base = [[(i+j) % n + 1 for j in range(n)] for i in range(n)]
    extra = []
    for i in range(n):
        r = base[i][:]
        a, b = 0, 1  # minimal change to avoid identical rows
        r[a], r[b] = r[b], r[a]
        extra.append(r)
    rows = base + extra
    random.shuffle(rows)
    return rows

def test_cross():
    # Compare improved vs optimal on several tiny seeds
    from collections import deque

    def run_solver(n, rows, solver):
        return solver(n, rows)

    for seed in range(5):
        n = 5
        rows = gen_instance(n, seed)
        cnt1, sol1 = run_solver(n, rows, solve_case_improved)
        cnt2, sol2 = run_solver(n, rows, solve_case)
        assert cnt1 == cnt2
        validate_subset(n, rows, sol1)
        validate_subset(n, rows, sol2)

# Reference implementation hook (Approach C)
def reference_solution_io(stdin_data: str) -> str:
    data = stdin_data.strip().split()
    it = iter(data)
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it))
        rows = []
        for _ in range(2*n):
            rows.append([int(next(it)) for _ in range(n)])
        cnt, sol = solve_case(n, rows)
        out_lines.append(str(cnt))
        out_lines.append(" ".join(map(str, sol)))
    return "\n".join(out_lines)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final CF-ready reference solution (Approach C)
import sys
from collections import deque

MOD = 998244353

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        rows = []
        for _ in range(2*n):
            rows.append([int(next(it)) for _ in range(n)])
        tests.append((n, rows))
    return tests

def validate_subset(n, rows, pick):
    m = 2*n
    assert len(pick) == n
    S = [i-1 for i in pick]
    assert len(set(S)) == n
    for c in range(n):
        seen = set()
        for r in S:
            v = rows[r][c]
            assert 1 <= v <= n
            assert v not in seen
            seen.add(v)
        assert len(seen) == n

def solve_case(n, rows):
    m = 2*n
    buckets = [[[] for _ in range(n+1)] for _ in range(n)]
    for r in range(m):
        for c in range(n):
            v = rows[r][c]
            buckets[c][v].append(r)
    # Invariant: per column, total memberships equals m
    for c in range(n):
        tot = sum(len(buckets[c][v]) for v in range(1, n+1))
        assert tot == m

    alive = [True]*m
    chosen = [False]*m
    ans_rows = []
    ans = 1

    q = deque()
    in_q = [False]*m

    def push_if_unique(c, v):
        cnt = 0
        last = -1
        for r in buckets[c][v]:
            if alive[r]:
                cnt += 1
                last = r
                if cnt > 1:
                    break
        if cnt == 1 and last != -1 and not in_q[last]:
            q.append(last)
            in_q[last] = True

    def remove_row(x):
        if not alive[x]:
            return
        alive[x] = False
        for c in range(n):
            v = rows[x][c]
            push_if_unique(c, v)

    def select_row(r):
        if not alive[r]:
            return
        chosen[r] = True
        ans_rows.append(r)
        remove_row(r)
        for c in range(n):
            v = rows[r][c]
            for y in buckets[c][v]:
                if alive[y]:
                    remove_row(y)

    for c in range(n):
        for v in range(1, n+1):
            push_if_unique(c, v)

    remaining = m
    while remaining > 0:
        progressed = False
        while q:
            r = q.popleft()
            in_q[r] = False
            if not alive[r]:
                continue
            progressed = True
            select_row(r)
        if progressed:
            remaining = sum(1 for i in range(m) if alive[i])
            continue
        if remaining == 0:
            break
        pivot = next(i for i in range(m) if alive[i])
        ans = (ans * 2) % MOD
        select_row(pivot)
        remaining = sum(1 for i in range(m) if alive[i])

    sol = [i+1 for i in ans_rows]
    assert len(sol) == n
    validate_subset(n, rows, sol)
    return ans % MOD, sol

def solve_all(tests):
    out_lines = []
    for n, rows in tests:
        cnt, sol = solve_case(n, rows)
        out_lines.append(str(cnt))
        out_lines.append(" ".join(map(str, sol)))
    return "\n".join(out_lines)

def main():
    tests = read_input()
    print(solve_all(tests))

if __name__ == "__main__":
    # Minimal self-check on a tiny constructed case
    def tiny():
        n = 5
        base = [[(i+j) % n + 1 for j in range(n)] for i in range(n)]
        extra = []
        for i in range(n):
            r = base[i][:]
            r[0], r[1] = r[1], r[0]
            extra.append(r)
        rows = base + extra
        cnt, sol = solve_case(n, rows)
        assert cnt > 0
        validate_subset(n, rows, sol)
    tiny()
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Pick $n$ rows forming a Latin square by columns; count all such subsets and output one.}
\WHY{This tests constraint modeling, greedy forcing, and recognizing cycle components contributing factors of $2$.}
\CHECKLIST{
- Build $(c,v)$ buckets.
- Process all unit buckets (forced picks).
- When stuck, pick any alive row and multiply the count by $2$.
- Remove conflicts after each selection.
- Output selected indices; verify column permutations.}
\EDGECASES{
- Columns with heavy duplicates initially.
- Many immediate forced rows.
- No initial forces (pure cycle components).
- Rows sharing multiple equal cells.
- Ensuring no empty bucket appears during forcing.
- Verifying final selection count is exactly $n$.}
\PITFALLS{
- Forgetting to remove the selected row itself from alive.
- Enqueuing the same forced row multiple times without deduplication.
- Not updating buckets after removals, missing new forced rows.
- Off-by-one on 1-based output indices.
- Modulo arithmetic for the count; ensure $998{,}244{,}353$.
- Inefficient data structures causing timeouts (use scans over small buckets).}
\FAILMODES{Naive backtracking explodes; greedy without proper forcing can choose conflicting rows. The bucket-forcing with cycle handling survives all adversarial arrangements under the given promises.}
\ELI{Each column--value pair must be covered exactly once. When only one row can cover a pair, take it and discard conflicts. If all remaining pairs have two options, the structure forms cycles, each admitting two alternating choices. Multiply these twos and you are done.}
\NotePages{3}

\end{document}