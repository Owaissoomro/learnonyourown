% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximum Number of Removal Queries That Can Be Processed I}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximum-number-of-removal-queries-that-can-be-processed-i/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an integer $n$ (positions labeled $0,1,\ldots,n-1$) and an array of queries $\text{queries}$ where each query is a pair $[l,r]$ with $0 \le l \le r < n$. All positions are initially present (not removed).

You process the queries in order, starting from index $0$. To process a query $[l,r]$:
\begin{bullets}
\item If there exists at least one not-yet-removed position $i$ with $l \le i \le r$, you must remove exactly one such position; to be concrete and deterministic, remove the smallest available index $i$ in $[l,r]$.
\item Otherwise (i.e., all positions in $[l,r]$ are already removed), the process stops and no further queries can be processed.
\end{bullets}
Return the maximum number of queries that can be processed (equivalently, the length of the longest prefix of $\text{queries}$ you can process under the rule above).

Constraints:
\begin{bullets}
\item $1 \le n \le 2 \times 10^5$
\item $1 \le \lvert \text{queries} \rvert \le 2 \times 10^5$
\item $0 \le l \le r < n$
\end{bullets}
}
\BREAKDOWN{We must maintain a dynamic set of available indices. For each query interval $[l,r]$, find and remove the smallest available index in that interval; if none exists, stop and return how many queries were processed so far. Efficiently supporting ``find-first-available $\ge l$'' and removal suggests either a union-find ``next-pointer'' structure or a Fenwick tree with order-statistic search.}
\ELI{Keep crossing out the leftmost uncrossed number in each asked range; when a range has nothing left to cross out, you are done and count how many ranges you managed.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function inputs (LeetCode style):
\begin{bullets}
\item $n$ — integer, number of positions $0 \ldots n-1$.
\item $\text{queries}$ — list of pairs $[l,r]$ with inclusive bounds, $0 \le l \le r < n$.
\end{bullets}
}
\OUTPUTS{Return an integer $k$ equal to the number of queries processed from the beginning before the first failure (if any). If every query can be processed, return $\lvert \text{queries} \rvert$.}
\SAMPLES{
Example 1:

$n=5$, $\text{queries}=[[0,1],[1,3],[2,4],[0,4]]$.

Processing:
\begin{bullets}
\item $[0,1] \to$ remove $0$
\item $[1,3] \to$ remove $1$
\item $[2,4] \to$ remove $2$
\item $[0,4] \to$ remove $3$
\end{bullets}
All 4 processed; answer $=4$.

Example 2:

$n=2$, $\text{queries}=[[0,1],[0,0],[0,1]]$.

Processing:
\begin{bullets}
\item $[0,1] \to$ remove $0$
\item $[0,0]$ has no available positions; stop.
\end{bullets}
Answer $=1$.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $U=\{0,1,\ldots,n-1\}$ and $A_0=U$ be the set of available indices. For query $j$ with interval $[l_j,r_j]$, define
\begin{BreakableEquation*}
S_j = A_{j} \cap [l_j,r_j].
\end{BreakableEquation*}
If $S_j=\varnothing$, stop; otherwise remove $i_j=\min S_j$ and set $A_{j+1}=A_j \setminus \{i_j\}$. The output is the largest $t$ such that $S_0,S_1,\ldots,S_{t-1}$ are all nonempty.}
\varmapStart
\var{n}{number of positions}
\var{[l_j,r_j]}{the $j$-th query interval}
\var{A_j}{available indices after processing $j$ queries}
\var{i_j}{the removed index for query $j$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
A_0 &= \{0,1,\ldots,n-1\},\\
S_j &= A_j \cap [l_j,r_j],\\
\text{if }S_j=\varnothing &\text{ then stop at }t=j,\\
\text{else } i_j &= \min S_j,\quad A_{j+1}=A_j \setminus \{i_j\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $0$-based and intervals are inclusive. Each query removes at most one index.}
\INVARIANTS{
\begin{bullets}
\item Monotonicity: $A_{j+1} \subset A_j$ and $\lvert A_j \rvert = n-j$ as long as processing continues.
\item Uniqueness: Each index is removed at most once.
\item Determinism: The rule ``remove the smallest available index in $[l,r]$'' yields a unique trajectory.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Maintain a boolean array removed[]. For each query, linearly scan from $l$ to $r$ to find the first index with removed[i] = False; remove it if found; otherwise return the count so far.}
\ASSUMPTIONS{Sufficient when $n$ and the average interval length are small; demonstrates correctness but not efficiency.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize removed[i] = False for all $i \in [0,n-1]$, and count $c=0$.
\item For each $[l,r]$ in queries:
\begin{bullets}
\item Scan $i=l,l+1,\ldots,r$ until you find removed[i] = False.
\item If found, set removed[i] = True and increment $c$; else return $c$.
\end{bullets}
\item Return $c$ after processing all queries.
\end{algosteps}
\COMPLEXITY{Let $m=\lvert \text{queries} \rvert$. Worst-case time is $\Theta\!\big(\sum_{j=1}^{m}(r_j-l_j+1)\big)$, which is $O(nm)$ in the worst case; space is $O(n)$.}
\[
\begin{aligned}
T(n,m) &= \sum_{j=1}^{m} O(r_j-l_j+1) \\
       &\le m\cdot O(n) = O(nm),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{At each query, the algorithm finds the smallest index in $[l,r]$ that is not yet removed, exactly matching the model. If none exists, the process must stop.}
\EDGECASES{
\begin{bullets}
\item Single-element intervals $l=r$.
\item All intervals identical.
\item Disjoint consecutive intervals covering the whole domain.
\item Early failure at the second query.
\end{bullets}
}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxRemovalQueries(self, n: int, queries: List[List[int]]) -> int:
        removed = [False] * n
        done = 0
        for l, r in queries:
            found = -1
            for i in range(l, r + 1):
                if not removed[i]:
                    found = i
                    break
            if found == -1:
                return done
            removed[found] = True
            done += 1
        return done

# Basic asserts
sol = Solution()
assert sol.maxRemovalQueries(5, [[0,1],[1,3],[2,4],[0,4]]) == 4
assert sol.maxRemovalQueries(2, [[0,1],[0,0],[0,1]]) == 1
# Edge: identical intervals
assert sol.maxRemovalQueries(4, [[1,2],[1,2],[1,2]]) == 2
# Edge: singletons
assert sol.maxRemovalQueries(3, [[0,0],[1,1],[2,2],[2,2]]) == 3
\end{minted}
\VALIDATION{The asserts cover: full success, early failure, repeated intervals, and singleton ranges.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Fenwick Tree (BIT) + Order-Statistic Search}
\WHICHFORMULA{Maintain a Fenwick tree over an array alive[i] initialized to $1$. A query $[l,r]$ is processable iff $\text{sum}(l,r)>0$. The index to remove is the first $i \ge l$ with prefix sum $> \text{sum}(0,l-1)$, which we can find via the Fenwick lower\_bound method in $O(\log n)$.}
\ASSUMPTIONS{Fenwick tree supports point updates and prefix sums in $O(\log n)$. A standard bitwise lifting lower\_bound finds the smallest index with prefix sum at least a target.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build BIT of size $n$ with all ones.
\item For each query $[l,r]$:
\begin{bullets}
\item Let $sL=\text{sum}(0,l-1)$ and $sR=\text{sum}(0,r)$. If $sR-sL=0$, stop and return the count.
\item Else target prefix is $sL+1$; find $i=\text{lower\_bound}(sL+1)$.
\item Update $i$ by adding $-1$ to mark removal; increment count.
\end{bullets}
\item Return count at the end.
\end{algosteps}
\COMPLEXITY{Each query costs $O(\log n)$; space is $O(n)$.}
\[
\begin{aligned}
T(n,m) &= O((n+m)\log n),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{The invariant is that the BIT stores the number of alive positions up to any prefix. If a range $[l,r]$ contains any alive index, the first alive index in that range has order $sL+1$ in the global alive order; lower\_bound retrieves exactly that index. Removing it decrements the BIT, maintaining correctness for subsequent queries.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0] * (n + 1)

    def add(self, i: int, delta: int) -> None:
        i += 1
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i

    def sum(self, i: int) -> int:
        # prefix sum [0..i]
        if i < 0:
            return 0
        i += 1
        res = 0
        while i > 0:
            res += self.bit[i]
            i -= i & -i
        return res

    def range_sum(self, l: int, r: int) -> int:
        if r < l:
            return 0
        return self.sum(r) - self.sum(l - 1)

    def lower_bound(self, target: int) -> int:
        # Smallest idx with prefix sum >= target; assumes 1 <= target <= total
        idx = 0
        bitmask = 1 << (self.n.bit_length())
        while bitmask:
            t = idx + bitmask
            if t <= self.n and self.bit[t] < target:
                target -= self.bit[t]
                idx = t
            bitmask >>= 1
        return idx  # 0-based index because we ended at last < target; next is answer

class Solution:
    def maxRemovalQueries(self, n: int, queries: List[List[int]]) -> int:
        ft = Fenwick(n)
        for i in range(n):
            ft.add(i, 1)
        done = 0
        for l, r in queries:
            if ft.range_sum(l, r) == 0:
                return done
            sL = ft.sum(l - 1)
            idx = ft.lower_bound(sL + 1)
            # idx is actually position of last < target; the actual index is idx
            # because lower_bound returned the 0-based index directly by construction
            # Validate range; due to positive range_sum, idx <= r holds
            ft.add(idx, -1)
            done += 1
        return done

# Basic asserts
sol = Solution()
assert sol.maxRemovalQueries(5, [[0,1],[1,3],[2,4],[0,4]]) == 4
assert sol.maxRemovalQueries(2, [[0,1],[0,0],[0,1]]) == 1
# Repeated intervals
assert sol.maxRemovalQueries(4, [[1,2],[1,2],[1,2]]) == 2
# Singletons
assert sol.maxRemovalQueries(3, [[0,0],[1,1],[2,2],[2,2]]) == 3
\end{minted}
\VALIDATION{Checks match the baseline examples and edge behaviors.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Disjoint-Set Union of Next Pointers (Union-Find)}
\WHICHFORMULA{Maintain an array $\text{next}[i]$ that points to the smallest index $\ge i$ that is still available. Implement $\text{find}(i)$ with path compression so that after removing $x$, we set $\text{next}[x]=\text{find}(x+1)$. For query $[l,r]$, compute $x=\text{find}(l)$; if $x \le r$, remove $x$; otherwise stop.}
\ASSUMPTIONS{Use a sentinel at $n$ where $\text{find}(n)=n$ to indicate ``no available index''.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize parent array $p$ of size $n+1$ with $p[i]=i$ for all $i$.
\item Define $\text{find}(x)$ as the smallest available index $\ge x$ via path compression: if $p[x]\ne x$ then $p[x]=\text{find}(p[x])$; return $p[x]$.
\item For each query $[l,r]$:
\begin{bullets}
\item Let $x=\text{find}(l)$. If $x>r$ or $x=n$, stop and return the count.
\item Otherwise, remove $x$ by setting $p[x]=\text{find}(x+1)$; increment count.
\end{bullets}
\item Return the count after all queries processed.
\end{algosteps}
\OPTIMALITY{Each index is removed at most once; each union and find is inverse-Ackermann amortized time. Total time $O((n+m)\,\alpha(n))$ is optimal up to very small constants for this comparison-based setting.}
\COMPLEXITY{Amortized $T(n,m)=O((n+m)\alpha(n))$, space $S(n)=O(n)$.}
\[
\begin{aligned}
T(n,m) &= O(n) \text{ to init } + \sum_{j=1}^{m} O(\alpha(n)) \\
       &= O((n+m)\alpha(n)).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxRemovalQueries(self, n: int, queries: List[List[int]]) -> int:
        # parent[i] is the smallest available index >= i (representative)
        parent = list(range(n + 1))  # parent[n] == n is sentinel (no available)

        def find(x: int) -> int:
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        done = 0
        for l, r in queries:
            x = find(l)
            if x > r or x == n:
                return done
            # remove x: link to next available
            parent[x] = find(x + 1)
            done += 1
        return done

# Validations (exactly 3 asserts)
sol = Solution()
assert sol.maxRemovalQueries(5, [[0,1],[1,3],[2,4],[0,4]]) == 4
assert sol.maxRemovalQueries(2, [[0,1],[0,0],[0,1]]) == 1
assert sol.maxRemovalQueries(4, [[1,2],[1,2],[1,2]]) == 2
\end{minted}
\VALIDATION{Three asserts cover a full pass, early stop, and repeated-range behavior.}
\RESULT{Returns the count of queries processed before the first query with an empty interval of available indices; ties do not arise because each query outcome is deterministic.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-validate on small $n$ by brute force; include edge cases: singletons, identical ranges, disjoint ranges, and early failure. Ensure monotonic decrease of alive count and that each removal is unique.}
\LINE{CROSS-CHECKS}{For small $n$ and random queries, the brute-force baseline (Approach A) should match the DSU solution (Approach C).}
\LINE{EDGE-CASE GENERATOR}{Generate small $n \le 8$ and random $m \le 10$ with intervals uniformly sampled, plus crafted cases like repeated identical intervals and sequential partitions.}
\begin{minted}{python}
from typing import List
import random

def brute(n: int, queries: List[List[int]]) -> int:
    removed = [False]*n
    done = 0
    for l, r in queries:
        pick = -1
        for i in range(l, r+1):
            if not removed[i]:
                pick = i
                break
        if pick == -1:
            return done
        removed[pick] = True
        done += 1
    return done

class Solution:
    def maxRemovalQueries(self, n: int, queries: List[List[int]]) -> int:
        parent = list(range(n + 1))
        def find(x: int) -> int:
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        done = 0
        for l, r in queries:
            x = find(l)
            if x > r or x == n:
                return done
            parent[x] = find(x + 1)
            done += 1
        return done

# Deterministic tests
sol = Solution()
assert sol.maxRemovalQueries(5, [[0,1],[1,3],[2,4],[0,4]]) == 4
assert sol.maxRemovalQueries(2, [[0,1],[0,0],[0,1]]) == 1
assert sol.maxRemovalQueries(4, [[1,2],[1,2],[1,2]]) == 2
assert sol.maxRemovalQueries(3, [[0,0],[1,1],[2,2],[2,2]]) == 3

# Cross-check random small cases
random.seed(7)
for n in range(1, 9):
    for _ in range(200):
        m = random.randint(0, 10)
        qs = []
        for __ in range(m):
            l = random.randint(0, n-1)
            r = random.randint(l, n-1)
            qs.append([l, r])
        assert sol.maxRemovalQueries(n, qs) == brute(n, qs)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxRemovalQueries(self, n: int, queries: List[List[int]]) -> int:
        # Disjoint-set "next pointer" structure; parent[i] is smallest available >= i
        parent = list(range(n + 1))  # sentinel at n

        def find(x: int) -> int:
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        done = 0
        for l, r in queries:
            x = find(l)
            if x > r or x == n:
                return done
            parent[x] = find(x + 1)  # remove x
            done += 1
        return done

# Sanity checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxRemovalQueries(5, [[0,1],[1,3],[2,4],[0,4]]) == 4
    assert sol.maxRemovalQueries(2, [[0,1],[0,0],[0,1]]) == 1
    assert sol.maxRemovalQueries(4, [[1,2],[1,2],[1,2]]) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain a dynamic set of available indices; for each interval, remove the leftmost available index; stop when an interval has none.}
\WHY{This pattern appears in scheduling, resource allocation, and greedy matching with interval constraints; union-find ``next'' is a standard interview trick.}
\CHECKLIST{
\begin{bullets}
\item Clarify inclusive indexing and 0-based bounds.
\item Decide deterministic removal rule (leftmost).
\item Pick the right structure: DSU next-pointer or BIT.
\item Handle the sentinel correctly ($n$ means no available).
\item Early exit on failure.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Intervals of length $1$.
\item Repeated identical intervals.
\item Intervals covering the whole domain.
\item $m>n$; many queries must fail eventually.
\item Early failure at the second query.
\item $n=1$ with alternating $[0,0]$ queries.
\item Non-overlapping intervals in ascending order.
\item All queries identical to $[0,n-1]$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting the inclusive right endpoint.
\item Off-by-one on the DSU sentinel at $n$.
\item Missing path compression, causing timeouts.
\item In BIT, mis-implementing lower\_bound target as $sL$ instead of $sL+1$.
\item Attempting to remove outside $[l,r]$ when range is empty.
\item Not short-circuiting when a query fails.
\item Using $1$-based vs $0$-based indices inconsistently.
\item In Python, using a sorted list with $O(n)$ deletions causing TLE.
\end{bullets}
}
\FAILMODES{The baseline $O(nm)$ scan fails on adversarial inputs of many wide intervals; DSU and BIT survive due to $O(\alpha(n))$ or $O(\log n)$ operations per query.}
\ELI{Think of a row of seats; each request asks for any seat in a range, always taking the leftmost open seat. Keep going until a request targets a section with no seats left. Using pointers to the next open seat makes this fast.}
\NotePages{3}

\end{document}