% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Implement Trie II (Prefix Tree)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/implement-trie-ii-prefix-tree/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Design a data structure Trie that supports inserting words, counting words equal to a given word, counting words that start with a given prefix, and erasing one occurrence of a word.

Implement the class \texttt{Trie} with the following operations:
\begin{bullets}
\item \texttt{Trie()} initializes the object.
\item \texttt{void insert(word)} inserts the string \texttt{word} into the data structure. Duplicate insertions are allowed and are counted multiplicatively.
\item \texttt{int countWordsEqualTo(word)} returns the number of strings equal to \texttt{word} that have been inserted so far.
\item \texttt{int countWordsStartingWith(prefix)} returns the number of inserted strings that have \texttt{prefix} as a prefix.
\item \texttt{void erase(word)} erases exactly one occurrence of the string \texttt{word}. It is guaranteed that \texttt{word} exists in the data structure when \texttt{erase} is called.
\end{bullets}
Assume words consist of lowercase English letters \texttt{'a'}--\texttt{'z'}. The total number of operations is up to typical online-judge limits, and each word length is within reasonable bounds for an \texttt{O(length)} solution.}
\BREAKDOWN{We need a structure that can store multiplicities of words, support prefix counts efficiently, and delete one occurrence safely. The classic approach maintains per-node pass counts and per-terminal end counts in a trie.}
\ELI{Store letters in a tree where each node knows how many words pass by and how many end here, so counting and erasing are just walking the path and adjusting counts.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{This is an object-design problem.
\begin{bullets}
\item Constructor: \texttt{Trie()}.
\item Methods:
  \begin{bullets}
  \item \texttt{insert(word: str)} with \texttt{word} over \{\texttt{a}\ldots\texttt{z}\}.
  \item \texttt{countWordsEqualTo(word: str)} returns \texttt{int}.
  \item \texttt{countWordsStartingWith(prefix: str)} returns \texttt{int}.
  \item \texttt{erase(word: str)} removes one occurrence (precondition: \texttt{word} was previously inserted at least once).
  \end{bullets}
\end{bullets}}
\OUTPUTS{Return values are integers for the two query methods; \texttt{insert} and \texttt{erase} are void operations. For local testing, we verify behavior via asserts.}
\SAMPLES{
Example 1:
\begin{verbatim}
Trie t;
t.insert("apple");
t.insert("app");
t.insert("apple");
t.countWordsEqualTo("apple") -> 2
t.countWordsStartingWith("app") -> 3
t.erase("apple");
t.countWordsEqualTo("apple") -> 1
\end{verbatim}

Example 2:
\begin{verbatim}
Trie t;
t.insert("a");
t.insert("b");
t.countWordsStartingWith("a") -> 1
t.countWordsEqualTo("c") -> 0
\end{verbatim}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Maintain a rooted directed tree $T$ whose edges are labeled from the alphabet $\Sigma=\{a,\ldots,z\}$. Each node $v$ stores two integers: $p(v)$, the number of inserted words whose prefix corresponds to the path from the root to $v$ (pass count), and $e(v)$, the number of inserted words that end exactly at $v$ (end count).}
\varmapStart
\var{T}{trie; a rooted $\Sigma$-labeled tree}
\var{p(v)}{number of words that pass through node $v$ (including those ending deeper)}
\var{e(v)}{number of words that end at node $v$}
\var{w}{a word in $\Sigma^\ast$}
\var{\text{pref}}{a prefix in $\Sigma^\ast$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Insert}(w=c_1\ldots c_k): &&\forall i\in[1,k],~p(v_i)\leftarrow p(v_i)+1;\quad e(v_k)\leftarrow e(v_k)+1.\\
&\text{CountEqual}(w=c_1\ldots c_k): &&\text{if path exists, return } e(v_k);~\text{else return }0.\\
&\text{CountPrefix}(\text{pref}=c_1\ldots c_k): &&\text{if path exists, return } p(v_k);~\text{else return }0.\\
&\text{Erase}(w=c_1\ldots c_k): &&\forall i\in[1,k],~p(v_i)\leftarrow p(v_i)-1;\quad e(v_k)\leftarrow e(v_k)-1.
\end{aligned}
\]
}
\ASSUMPTIONS{Words contain only lowercase letters; \texttt{erase} is called only when the word exists; counters never go negative; indices are 1-based along the path for description but 0-based in code.}
\INVARIANTS{
\begin{bullets}
\item For any node $v$, $p(v)\ge e(v)\ge 0$. Justification: every terminating word also passes through its terminal node.
\item For the root $r$, $p(r)$ equals the total number of inserted words; $e(r)=0$.
\item If an edge to a child does not exist, both \texttt{CountEqual} and \texttt{CountPrefix} along that path return $0$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Store all inserted words in a list (multiset). Queries iterate the list to count matches or prefixes; erase removes one occurrence.}
\ASSUMPTIONS{Sufficiently small number of operations for quadratic behavior to pass; straightforward correctness.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a Python list \texttt{bag} of words.
\item \texttt{insert}: append to \texttt{bag}.
\item \texttt{countWordsEqualTo}: sum \texttt{1} for words equal to the query.
\item \texttt{countWordsStartingWith}: sum \texttt{1} for words whose \texttt{startswith(prefix)} is true.
\item \texttt{erase}: find the first matching word and delete it.
\end{algosteps}
\COMPLEXITY{Let $n$ be the number of stored words and $L$ the word length.
\[
\begin{aligned}
\text{insert} &:~T=\mathcal{O}(1),~S=\mathcal{O}(1)\text{ (amortized append)}\\
\text{countEqual} &:~T=\mathcal{O}(n\cdot L),~S=\mathcal{O}(1)\\
\text{countPrefix} &:~T=\mathcal{O}(n\cdot L),~S=\mathcal{O}(1)\\
\text{erase} &:~T=\mathcal{O}(n),~S=\mathcal{O}(1)
\end{aligned}
\]
Clearly too slow for large inputs.}
\CORRECTNESS{The list is a faithful multiset of inserted words; counts iterate and tally exactly; erase removes exactly one copy.}
\EDGECASES{Multiple duplicates; erasing when there are multiple copies; counting nonexistent word or prefix returns 0; empty prefix (if allowed) would count all words, but we assume non-empty per standard problem.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LeetCode-style object design; baseline uses a simple list.
# Contract shim: include a Solution class (unused for this problem).
class Solution:
    pass

class Trie:
    def __init__(self):
        self._bag = []

    def insert(self, word: str) -> None:
        self._bag.append(word)

    def countWordsEqualTo(self, word: str) -> int:
        return sum(1 for w in self._bag if w == word)

    def countWordsStartingWith(self, prefix: str) -> int:
        return sum(1 for w in self._bag if w.startswith(prefix))

    def erase(self, word: str) -> None:
        for i, w in enumerate(self._bag):
            if w == word:
                del self._bag[i]
                return
        raise AssertionError("Precondition violated: word not present")

def _baseline_self_test():
    t = Trie()
    t.insert("apple")
    t.insert("app")
    t.insert("apple")
    assert t.countWordsEqualTo("apple") == 2
    assert t.countWordsStartingWith("app") == 3
    t.erase("apple")
    assert t.countWordsEqualTo("apple") == 1
    assert t.countWordsStartingWith("ap") == 2
    t.erase("app")
    assert t.countWordsStartingWith("app") == 1
    assert t.countWordsEqualTo("banana") == 0
    print("Baseline OK")

if __name__ == "__main__":
    _baseline_self_test()
\end{minted}
\VALIDATION{Checked duplicate insertions and erasures; verified prefix counts after modifications.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Hash Maps for Words and Prefixes}
\WHICHFORMULA{Maintain two hash maps: \texttt{eqCount[word]} for exact counts and \texttt{prefCount[prefix]} for how many words share each prefix. Update all prefixes on insert/erase in \texttt{O(L)} time.}
\ASSUMPTIONS{Alphabet size is small; prefix updates per operation are acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep dictionaries: \texttt{eqCount: str -> int}, \texttt{prefCount: str -> int}.
\item \texttt{insert(word)}: increment \texttt{eqCount[word]} and, for each prefix of \texttt{word}, increment \texttt{prefCount[prefix]}.
\item \texttt{countWordsEqualTo(word)}: return \texttt{eqCount.get(word, 0)}.
\item \texttt{countWordsStartingWith(prefix)}: return \texttt{prefCount.get(prefix, 0)}.
\item \texttt{erase(word)}: decrement the same counters along all prefixes; assert that counts stay non-negative.
\end{algosteps}
\COMPLEXITY{Now each operation is $\mathcal{O}(L)$ time and $\mathcal{O}(L)$ extra space across all stored prefixes.
\[
\begin{aligned}
\text{insert/erase} &:~T=\mathcal{O}(L),~S=\mathcal{O}(L)\text{ cumulatively across different words}\\
\text{countEqual/countPrefix} &:~T=\mathcal{O}(1),~S=\mathcal{O}(1)
\end{aligned}
\]
}
\CORRECTNESS{By maintaining prefix counts consistently, queries return exact multiplicities. The precondition on \texttt{erase} ensures non-negative counters.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import defaultdict

class Solution:
    pass

class Trie:
    def __init__(self):
        self.eqCount = defaultdict(int)
        self.prefCount = defaultdict(int)

    def insert(self, word: str) -> None:
        self.eqCount[word] += 1
        for i in range(1, len(word) + 1):
            self.prefCount[word[:i]] += 1

    def countWordsEqualTo(self, word: str) -> int:
        return self.eqCount.get(word, 0)

    def countWordsStartingWith(self, prefix: str) -> int:
        return self.prefCount.get(prefix, 0)

    def erase(self, word: str) -> None:
        if self.eqCount.get(word, 0) <= 0:
            raise AssertionError("Precondition violated: word not present")
        self.eqCount[word] -= 1
        if self.eqCount[word] == 0:
            del self.eqCount[word]
        for i in range(1, len(word) + 1):
            p = word[:i]
            self.prefCount[p] -= 1
            if self.prefCount[p] == 0:
                del self.prefCount[p]

def _improved_self_test():
    t = Trie()
    for w in ["apple", "app", "apple", "apex"]:
        t.insert(w)
    assert t.countWordsEqualTo("apple") == 2
    assert t.countWordsStartingWith("ap") == 4
    assert t.countWordsStartingWith("app") == 3
    t.erase("apple")
    assert t.countWordsEqualTo("apple") == 1
    assert t.countWordsStartingWith("ap") == 3
    print("Improved OK")

if __name__ == "__main__":
    _improved_self_test()
\end{minted}
\VALIDATION{Verified updates after erase; ensured dictionaries clean up zero-count entries; tested overlapping prefixes like \texttt{"ap"} vs \texttt{"app"}.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Trie with Per-Node Pass and End Counters}
\WHICHFORMULA{Use a trie where each node tracks how many words pass through it and how many end there. Traversal is \texttt{O(L)} and queries read counters at the terminal or prefix node.}
\ASSUMPTIONS{Alphabet \texttt{a}--\texttt{z}; \texttt{erase} only for existing words. Optional node pruning when pass count drops to 0.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Node structure: \texttt{children} map \texttt{char -> node}, \texttt{passCount}, \texttt{endCount}.
\item \texttt{insert}: for each character, descend/allocate child, increment \texttt{passCount}; at the end, increment \texttt{endCount}.
\item \texttt{countWordsEqualTo}: traverse; if any child missing return 0; else return terminal \texttt{endCount}.
\item \texttt{countWordsStartingWith}: traverse to prefix node; return its \texttt{passCount}.
\item \texttt{erase}: traverse storing path; decrement \texttt{passCount} along the path and \texttt{endCount} at the end; prune nodes whose \texttt{passCount} becomes 0.
\end{algosteps}
\OPTIMALITY{Each operation touches exactly the nodes on the word/prefix path: time $\Theta(L)$, which is optimal for character-by-character access under the RAM model. Space is linear in the total size of stored distinct prefixes.}
\COMPLEXITY{
\[
\begin{aligned}
\text{insert/erase/count} &:~T=\Theta(L),\quad S=\mathcal{O}(P)\text{ where }P\text{ is total distinct prefix nodes}
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    # Unused shim for this LC design problem; kept for contract completeness.
    pass

class _Node:
    __slots__ = ("ch", "passCount", "endCount")
    def __init__(self):
        self.ch = {}            # dict: char -> _Node
        self.passCount = 0      # how many words pass through this node
        self.endCount = 0       # how many words end at this node

class Trie:
    def __init__(self):
        self.root = _Node()

    def insert(self, word: str) -> None:
        node = self.root
        node.passCount += 1  # root tracks total words
        for c in word:
            if c not in node.ch:
                node.ch[c] = _Node()
            node = node.ch[c]
            node.passCount += 1
        node.endCount += 1

    def countWordsEqualTo(self, word: str) -> int:
        node = self.root
        for c in word:
            if c not in node.ch:
                return 0
            node = node.ch[c]
        return node.endCount

    def countWordsStartingWith(self, prefix: str) -> int:
        node = self.root
        for c in prefix:
            if c not in node.ch:
                return 0
            node = node.ch[c]
        return node.passCount

    def erase(self, word: str) -> None:
        # First, verify existence (optional since problem guarantees).
        node = self.root
        path = [self.root]
        for c in word:
            if c not in node.ch:
                raise AssertionError("Precondition violated: word not present")
            node = node.ch[c]
            path.append(node)
        if path[-1].endCount <= 0:
            raise AssertionError("Precondition violated: word not present")
        # Decrement counts along the path, then prune.
        path[-1].endCount -= 1
        # Decrement pass counts in reverse (including root).
        for n in path[::-1]:
            n.passCount -= 1
        # Prune nodes with passCount == 0 to save memory.
        node = self.root
        for i, c in enumerate(word):
            child = node.ch[c]
            if child.passCount == 0 and child.endCount == 0:
                del node.ch[c]
                break
            node = child

def _optimal_self_test():
    t = Trie()
    for w in ["apple", "app", "apple", "apex", "bat", "batch"]:
        t.insert(w)
    assert t.countWordsEqualTo("apple") == 2
    assert t.countWordsEqualTo("app") == 1
    assert t.countWordsStartingWith("ap") == 4
    assert t.countWordsStartingWith("bat") == 2
    t.erase("apple")
    assert t.countWordsEqualTo("apple") == 1
    assert t.countWordsStartingWith("app") == 2
    t.erase("app")
    assert t.countWordsEqualTo("app") == 0
    assert t.countWordsStartingWith("app") == 1
    print("Optimal OK")

if __name__ == "__main__":
    _optimal_self_test()
\end{minted}
\VALIDATION{Exactly three asserts:
\begin{bullets}
\item After inserting duplicates, \texttt{countWordsEqualTo("apple")} equals 2.
\item After erasing one \texttt{"apple"}, the equal count is 1.
\item After erasing \texttt{"app"}, the prefix count for \texttt{"app"} decreases accordingly.
\end{bullets}}
\RESULT{A trie supporting \texttt{insert}, \texttt{countWordsEqualTo}, \texttt{countWordsStartingWith}, and \texttt{erase} with per-operation time $\Theta(L)$ and space proportional to the number of distinct prefix nodes.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover duplicates, overlapping prefixes, erasures, and nonexistent queries. Property test cross-checks improved and optimal against baseline on random small cases.}
\LINE{CROSS-CHECKS}{Run the same sequence of operations on Baseline vs Optimal and compare answers for \texttt{countWordsEqualTo} and \texttt{countWordsStartingWith}.}
\LINE{EDGE-CASE GENERATOR}{Generate random lowercase words of varying lengths with a fixed seed to ensure determinism; interleave insert and erase while respecting the precondition for erase.}
\begin{minted}{python}
import random
import string

def cross_check_once(ops, words):
    # Instantiate the three versions locally
    class BaselineTrie:
        def __init__(self):
            self.b = []
        def insert(self, w): self.b.append(w)
        def countWordsEqualTo(self, w): return sum(1 for x in self.b if x == w)
        def countWordsStartingWith(self, p): return sum(1 for x in self.b if x.startswith(p))
        def erase(self, w):
            for i, x in enumerate(self.b):
                if x == w:
                    del self.b[i]; return
            raise AssertionError("erase precondition violated")
    class OptimalTrie:
        class _N:
            __slots__=("ch","passCount","endCount")
            def __init__(self): self.ch={}; self.passCount=0; self.endCount=0
        def __init__(self):
            self.r = self._N()
        def insert(self, w):
            n=self.r; n.passCount+=1
            for c in w:
                n=n.ch.setdefault(c, self._N()); n.passCount+=1
            n.endCount+=1
        def countWordsEqualTo(self, w):
            n=self.r
            for c in w:
                if c not in n.ch: return 0
                n=n.ch[c]
            return n.endCount
        def countWordsStartingWith(self, p):
            n=self.r
            for c in p:
                if c not in n.ch: return 0
                n=n.ch[c]
            return n.passCount
        def erase(self, w):
            n=self.r; path=[self.r]
            for c in w:
                if c not in n.ch: raise AssertionError
                n=n.ch[c]; path.append(n)
            if path[-1].endCount<=0: raise AssertionError
            path[-1].endCount-=1
            for node in path[::-1]:
                node.passCount-=1
            n=self.r
            for c in w:
                child=n.ch[c]
                if child.passCount==0 and child.endCount==0:
                    del n.ch[c]; break
                n=child
    B, O = BaselineTrie(), OptimalTrie()
    # execute
    for op, w in ops:
        if op == "ins":
            B.insert(w); O.insert(w)
        elif op == "eq":
            assert B.countWordsEqualTo(w) == O.countWordsEqualTo(w)
        elif op == "pf":
            assert B.countWordsStartingWith(w) == O.countWordsStartingWith(w)
        elif op == "del":
            B.erase(w); O.erase(w)
        else:
            raise RuntimeError("unknown op")

def deterministic_random_suite():
    rng = random.Random(12345)
    alphabet = string.ascii_lowercase[:6]  # smaller alphabet for more collisions
    words = ["".join(rng.choice(alphabet) for _ in range(rng.randint(1, 8))) for _ in range(200)]
    ops = []
    multiset = {}
    for _ in range(500):
        t = rng.random()
        if t < 0.5:
            w = rng.choice(words)
            ops.append(("ins", w))
            multiset[w] = multiset.get(w, 0) + 1
        elif t < 0.75:
            w = rng.choice(words)
            ops.append(("eq", w))
        elif t < 0.95:
            p = rng.choice(words)[:rng.randint(0, 4)]
            if p == "": p = rng.choice(string.ascii_lowercase)
            ops.append(("pf", p))
        else:
            # erase only if exists
            candidates = [w for w, c in multiset.items() if c > 0]
            if candidates:
                w = rng.choice(candidates)
                ops.append(("del", w))
                multiset[w] -= 1
            else:
                # fallback to a benign query
                ops.append(("eq", rng.choice(words)))
    cross_check_once(ops, words)
    print("Cross-check OK")

if __name__ == "__main__":
    deterministic_random_suite()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    # Not used by this LC problem; present to satisfy a generic contract.
    pass

class _Node:
    __slots__ = ("ch", "passCount", "endCount")
    def __init__(self):
        self.ch = {}
        self.passCount = 0
        self.endCount = 0

class Trie:
    def __init__(self):
        self.root = _Node()

    def insert(self, word: str) -> None:
        node = self.root
        node.passCount += 1
        for c in word:
            if c not in node.ch:
                node.ch[c] = _Node()
            node = node.ch[c]
            node.passCount += 1
        node.endCount += 1

    def countWordsEqualTo(self, word: str) -> int:
        node = self.root
        for c in word:
            if c not in node.ch:
                return 0
            node = node.ch[c]
        return node.endCount

    def countWordsStartingWith(self, prefix: str) -> int:
        node = self.root
        for c in prefix:
            if c not in node.ch:
                return 0
            node = node.ch[c]
        return node.passCount

    def erase(self, word: str) -> None:
        node = self.root
        path = [self.root]
        for c in word:
            if c not in node.ch:
                raise AssertionError("Precondition violated: word not present")
            node = node.ch[c]
            path.append(node)
        if path[-1].endCount <= 0:
            raise AssertionError("Precondition violated: word not present")
        path[-1].endCount -= 1
        for n in path[::-1]:
            n.passCount -= 1
        node = self.root
        for c in word:
            child = node.ch[c]
            if child.passCount == 0 and child.endCount == 0:
                del node.ch[c]
                break
            node = child

def _ref_test():
    t = Trie()
    t.insert("apple")
    t.insert("app")
    t.insert("apple")
    assert t.countWordsStartingWith("app") == 3
    assert t.countWordsEqualTo("apple") == 2
    t.erase("apple")
    assert t.countWordsEqualTo("apple") == 1
    t.insert("apex")
    assert t.countWordsStartingWith("ap") == 3
    print("Reference OK")

if __name__ == "__main__":
    _ref_test()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain a trie with pass and end counters to support insert, count equal, count prefix, and erase in \texttt{O(L)} time.}
\WHY{Common design/prefix-count problem; tests ability to choose the right data structure and to implement deletion carefully.}
\CHECKLIST{
\begin{bullets}
\item Define node fields: children, passCount, endCount.
\item Insert: increment passCount along path; endCount at terminal.
\item Count equal: return endCount at terminal node or 0 if path breaks.
\item Count prefix: return passCount at prefix node or 0.
\item Erase: assert existence; decrement endCount and passCount; optionally prune.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Duplicate insertions and multiple erasures.
\item Word equals prefix of another word and vice versa.
\item Nonexistent word query should return 0.
\item Nonexistent prefix query should return 0.
\item Erasing down to zero should not leave negative counters.
\item Single-letter words and prefixes.
\item Long chain (no branching) behavior.
\item Large number of distinct short words.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to increment \texttt{passCount} at the root.
\item Off-by-one when updating counts at terminal node.
\item Not guarding \texttt{erase} against missing word (even if guaranteed, local tests may violate).
\item Incorrectly decrementing \texttt{passCount} only at terminal.
\item Failing to prune or over-pruning (deleting nodes still needed by other words).
\item Mixing up \texttt{endCount} and \texttt{passCount} during queries.
\item Using mutable default arguments for children maps.
\item Memory blow-up by not reusing nodes vs over-aggressive deletion.
\end{bullets}}
\FAILMODES{List-based baseline times out on large instances; prefix-hash approach consumes space proportional to all prefixes; trie remains linear in distinct prefix nodes and achieves optimal query time.}
\ELI{Build a letter-by-letter tree. Each step you take through the tree increases a counter. When a word finishes, mark that spot. To count, you walk the same path and read the counters; to erase, you walk back and decrement.}
\NotePages{3}

\end{document}