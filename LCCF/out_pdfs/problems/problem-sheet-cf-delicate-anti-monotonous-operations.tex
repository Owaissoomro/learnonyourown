% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Delicate Anti-monotonous Operations}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2053/H}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{There are always many repetitive tasks in life. Iris always dislikes them, so she refuses to repeat them. However, time cannot be turned back; we only have to move forward.

Formally, Iris has an integer sequence $a_1, a_2, \ldots, a_n$, where each number in the sequence is between $1$ and $w$, inclusive. It is guaranteed that $w \ge 2$.

Iris defines an operation as selecting two numbers $a_i, a_{i+1}$ satisfying $a_i = a_{i+1}$, and then changing them to two arbitrary integers within the range $[1, w]$. Iris does not like equality, so she must guarantee that $a_i \ne a_{i+1}$ after the operation. Two identical pairs $a_i, a_{i+1}$ can be selected multiple times.

Iris wants to know the maximum possible sum of all elements of $a$ after several (possible, zero) operations, as well as the minimum number of operations required to achieve this maximum value.

Input:
Each test contains multiple test cases. The first line contains an integer $t$ ($1 \le t \le 10^5$) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers $n$ and $w$ ($1 \le n \le 2\cdot 10^5$, $2 \le w \le 10^8$) — the length of the array, and the maximum allowed value of the elements.

The second line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le w$) — the elements in the array.

It is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.

Output:
For each test case, output two integers — the maximum possible sum of all elements of $a$ and the minimum number of operations required, respectively.

Note:
In the first test case, no operation can be performed so the answers are $\sum a_i = 15$ and $0$, respectively.

In the second test case, the operations can be performed as follows:
\[
[3, 1, 2, 3, 4, \underline{1, 1}]
\to
[3, 1, 2, 3, \underline{4, 4}, 5]
\to
[3, 1, 2, \underline{3, 3}, 5, 5]
\to
[3, 1, \underline{2, 2}, 5, 5, 5]
\to
[3, \underline{1, 1}, 5, 5, 5, 5]
\to
[\underline{3, 3}, 5, 5, 5, 5, 5]
\to
[4, 5, 5, 5, 5, 5, 5].
\]
It can be shown this is optimal, so we should output $\sum a_i = 34$ and the number of operations, $6$, respectively.}
\BREAKDOWN{Detect whether any adjacent equality exists. If none, no operation is possible and the sum remains the same. Otherwise, propagate changes to maximize the sum to a tight upper bound and count the minimal operations required.}
\ELI{If there is at least one adjacent equal pair, you can sweep through the array to set all entries to $w$ except one to $w-1$, which takes exactly $n-1$ operations; otherwise you cannot change anything.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n$, $w$; then an array $a$ of length $n$. Ranges: $1 \le n \le 2\cdot 10^5$, $2 \le w \le 10^8$, $1 \le a_i \le w$. Total $\sum n \le 10^6$.}
\OUTPUTS{For each test case, print two integers: the maximum possible sum of all elements after operations, and the minimum number of operations needed to achieve this maximum.}
\SAMPLES{- Example 1: $n=5$, $w=5$, $a=[1,2,3,4,5]$ has no equal adjacent, so output is $15$ and $0$.
- Example 2: $n=7$, $w=5$, $a=[3,1,2,3,4,1,1]$ has an equal adjacent at the end, so output is $34$ and $6$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $a \in [1,w]^n$, an operation applies to an index $i$ with $a_i=a_{i+1}$ and resets $(a_i,a_{i+1})$ to any $(x,y)\in[1,w]^2$ with $x\ne y$. We seek $\max$ final sum $\sum_j a_j$ and the minimum number of operations among those achieving the maximum.}
\varmapStart
\var{n}{array length}
\var{w}{upper bound on values}
\var{a}{initial array}
\var{S}{initial sum, $S=\sum_{i=1}^n a_i$}
\var{\mathrm{eq}}{indicator whether there exists $i$ with $a_i=a_{i+1}$}
\var{M}{maximum achievable sum}
\var{K}{minimum operations to reach $M$}
\varmapEnd
\GOVERN{
\[
M=
\begin{cases}
S, & \text{if } \neg\mathrm{eq},\\
n\cdot w - 1, & \text{if } \mathrm{eq},
\end{cases}
\qquad
K=
\begin{cases}
0, & \text{if } \neg\mathrm{eq},\\
n-1, & \text{if } \mathrm{eq}.
\end{cases}
\]
}
\ASSUMPTIONS{The operation only requires the selected pair to be unequal after the change; other adjacencies may remain equal. When at least one adjacent equality exists, a sweeping construction can propagate changes across the entire array.}
\INVARIANTS{- If there is no adjacent equality initially, no operation is applicable, so the state is fixed.
- With at least one adjacent equality, each operation can move or branch the locus of equality while raising touched values toward $w$, enabling a linear sweep that touches all indices in $n-1$ moves and leaves exactly one entry at $w-1$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Attempt to simulate local improvements: if any equal adjacent pair exists, greedily modify it to increase the sum, otherwise stop.}
\ASSUMPTIONS{Will terminate but is not efficient nor guaranteed minimal in operations; serves only as a conceptual baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan for an index $i$ with $a_i=a_{i+1}$.
\item If none, return $(\sum a_i, 0)$.
\item Otherwise apply at most $n-1$ modifications, each time setting the chosen pair to $(w,w-1)$ and continuing until no equal pair remains.}
\end{algosteps}
\COMPLEXITY{A naive simulation could be $O(n^2)$ in the worst case due to repeated rescans; space $O(1)$.}
\[
\begin{aligned}
T(n) &\le n \cdot O(n) = O(n^2).
\end{aligned}
\]
\CORRECTNESS{This greedy simulation may reach high sums but is not principled for minimal operations.}
\EDGECASES{All elements distinct; entire array equal; small $n \in \{1,2\}$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); w = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        cases.append((n, w, a))
    return t, cases

def can_operate(a):
    for i in range(len(a)-1):
        if a[i] == a[i+1]:
            return i
    return -1

def solve_case_baseline(n, w, a):
    s = sum(a)
    i = can_operate(a)
    if i == -1:
        return s, 0
    # crude upper bound attempt
    ops = 0
    # just apply up to n-1 operations
    for _ in range(max(0, n-1)):
        j = can_operate(a)
        if j == -1:
            break
        # set to (w, w-1) to gain
        a[j] = w
        a[j+1] = w-1
        ops += 1
    return sum(a), ops

def solve_all_baseline(cases):
    out = []
    for n, w, a in cases:
        S, K = solve_case_baseline(n, w, a[:])
        out.append((S, K))
    return out

def main():
    data = sys.stdin.read()
    t, cases = read_input(data)
    ans = solve_all_baseline(cases)
    print("\n".join(f"{x} {y}" for x, y in ans))

if __name__ == "__main__":
    # tiny asserts for baseline behavior (not necessarily optimal)
    t, cases = read_input("3\n5 5\n1 2 3 4 5\n2 3\n1 1\n3 4\n2 2 2\n")
    res = solve_all_baseline(cases)
    assert res[0][1] == 0
    assert res[1][1] >= 1
    assert res[2][1] >= 1
    # do not run main in tests
    pass
\end{minted}
\VALIDATION{This baseline is only for intuition; it does not guarantee optimality. The asserts check trivial behaviors.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Pattern Recognition and Closed Form}
\WHICHFORMULA{Observe a dichotomy: with no adjacent equality, no operation is possible. With at least one, a sweep can achieve a tight upper bound on the sum and requires exactly $n-1$ operations.}
\ASSUMPTIONS{Sweeping construction from any initial equal pair can visit all indices, setting values to $w$ except one entry which necessarily remains $w-1$ due to the pairwise inequality constraint on the last operation affecting two indices.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $S=\sum a_i$ and check if there exists an $i$ with $a_i=a_{i+1}$.
\item If not, return $(S, 0)$.
\item Otherwise, return $(n\cdot w - 1, n-1)$.}
\end{algosteps}
\COMPLEXITY{Time $O(n)$ per test to detect any adjacent equality; space $O(1)$.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Upper bound: in any operation, the two modified entries must be unequal; hence making all $n$ entries equal to $w$ is impossible when only one operation remains, leaving a deficit of at least $1$. Construction: starting from any existing equal pair, repeatedly operate to propagate the ability to modify across the array, setting new entries to $w$ and maintaining exactly one ``marker'' that ends at $w-1$. This sweep uses $n-1$ moves.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); w = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        cases.append((n, w, a))
    return t, cases

def solve_case_closed(n, w, a):
    S = sum(a)
    eq = any(a[i] == a[i+1] for i in range(n-1))
    if not eq:
        return S, 0
    return n*w - 1, n - 1

def solve_all_closed(cases):
    return [solve_case_closed(n, w, a) for (n, w, a) in cases]

def main():
    data = sys.stdin.read()
    t, cases = read_input(data)
    ans = solve_all_closed(cases)
    print("\n".join(f"{x} {y}" for x, y in ans))

if __name__ == "__main__":
    # deterministic checks
    # no equal adjacent -> unchanged
    assert solve_case_closed(5, 5, [1,2,3,4,5]) == (15, 0)
    # single equal adjacent (n=2)
    assert solve_case_closed(2, 10, [3,3]) == (2*10 - 1, 1)
    # sample-like
    assert solve_case_closed(7, 5, [3,1,2,3,4,1,1]) == (7*5 - 1, 6)
    pass
\end{minted}
\VALIDATION{Three checks: distinct array, minimal case $n=2$ with equality, and the illustrative sample pattern.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Proof-Backed Closed Form and Linear Scan}
\WHICHFORMULA{Final method: One linear scan checks the existence of any adjacent equality. If none, answer is $(\sum a_i, 0)$. Otherwise, answer is $(n\cdot w - 1, n-1)$.}
\ASSUMPTIONS{The operation constraint only forbids making the two modified entries equal in that operation. With at least one initial equal pair, one can perform a left-to-right (or right-to-left) sweep: at each step, modify the current equal pair to make one endpoint $w$ and create an equality with the next pair to continue. This requires exactly $n-1$ steps and leaves a single $w-1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Accumulate $S=\sum a_i$ in $O(n)$.
\item Check if $\exists i: a_i=a_{i+1}$ in $O(n)$.
\item If none, print $S$ and $0$; else print $n\cdot w - 1$ and $n-1$.}
\end{algosteps}
\OPTIMALITY{Tightness: $n\cdot w-1$ is an upper bound when at least one operation occurs, since an operation always affects a pair that must end unequal; the constructive sweep achieves this bound. Minimality of $n-1$ operations follows from the sweep construction and the necessity to advance the modification frontier across $n-1$ adjacencies.}
\COMPLEXITY{Linear in input size per test; constant extra space.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); w = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        cases.append((n, w, a))
    return t, cases

def solve_case(n, w, a):
    s = sum(a)
    has_eq = any(a[i] == a[i+1] for i in range(n-1))
    if not has_eq:
        return s, 0
    return n*w - 1, n - 1

def solve_all(cases):
    out_lines = []
    for n, w, a in cases:
        m, k = solve_case(n, w, a)
        out_lines.append(f"{m} {k}")
    return "\n".join(out_lines)

def main():
    t, cases = read_input()
    print(solve_all(cases))

if __name__ == "__main__":
    # Exact 3 asserts
    assert solve_case(5, 5, [1,2,3,4,5]) == (15, 0)
    assert solve_case(2, 3, [1,1]) == (5, 1)
    assert solve_case(7, 5, [3,1,2,3,4,1,1]) == (34, 6)
    # optional I/O mini-test
    sample_in = "2\n5 5\n1 2 3 4 5\n2 10\n3 3\n"
    sys.setrecursionlimit(1 << 25)
    print(solve_all([(5,5,[1,2,3,4,5]), (2,10,[3,3])]))
\end{minted}
\VALIDATION{Exactly three asserts, including the sample-like case.}
\RESULT{For each test: if no adjacent equality exists, output the original sum and $0$ operations. Otherwise, output $n\cdot w-1$ and $n-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests focus on: arrays with no equal adjacencies; arrays with exactly one equal pair; arrays fully equal; small $n=1,2$; random checks ensuring the closed-form outputs are consistent with the dichotomy.}
\LINE{CROSS-CHECKS}{Compare Approach B and C on random inputs: both must agree exactly; Approach A is non-authoritative.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with alternating values (no equalities) and with blocks creating at least one equality at varying positions.}
\begin{minted}{python}
import random

def gen_no_equal(n, w):
    a = []
    last = None
    for _ in range(n):
        x = random.randint(1, w)
        if x == last:
            x = (x % w) + 1
        a.append(x)
        last = x
    return a

def gen_with_equal(n, w):
    a = [random.randint(1, w) for _ in range(n)]
    if n >= 2:
        i = random.randint(0, n-2)
        a[i] = a[i+1] = random.randint(1, w)
    return a

def reference(n, w, a):
    S = sum(a)
    eq = any(a[i]==a[i+1] for i in range(n-1))
    return (S, 0) if not eq else (n*w - 1, n - 1)

def quick_check():
    for _ in range(200):
        n = random.randint(1, 20)
        w = random.randint(2, 20)
        a1 = gen_no_equal(n, w)
        assert reference(n, w, a1) == (sum(a1), 0)
        a2 = gen_with_equal(n, w)
        m, k = reference(n, w, a2)
        assert k == (0 if not any(a2[i]==a2[i+1] for i in range(n-1)) else n-1)
        assert m == (sum(a2) if k == 0 else n*w - 1)

if __name__ == "__main__":
    quick_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); w = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        cases.append((n, w, a))
    return t, cases

def solve_case(n, w, a):
    total = sum(a)
    has_equal = any(a[i] == a[i+1] for i in range(n-1))
    if not has_equal:
        return total, 0
    return n*w - 1, n - 1

def solve_all(cases):
    res = []
    for n, w, a in cases:
        m, k = solve_case(n, w, a)
        res.append(f"{m} {k}")
    return "\n".join(res)

def main():
    t, cases = read_input()
    print(solve_all(cases))

if __name__ == "__main__":
    # Simple regression tests
    assert solve_case(1, 100, [77]) == (77, 0)
    assert solve_case(2, 2, [1, 2]) == (3, 0)
    assert solve_case(2, 2, [2, 2]) == (3, 1)
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Check for the presence of any adjacent equal pair; this single bit decides both the maximum sum and the minimal number of operations.}
\WHY{Hard interview problems often hide a simple global invariant behind complex local rules; recognizing the invariant simplifies the solution.}
\CHECKLIST{- Compute sum $S$.
- Scan once for any $a_i=a_{i+1}$.
- If none: print $S$ and $0$.
- Else: print $n\cdot w-1$ and $n-1$.}
\EDGECASES{- $n=1$ (no pair).
- $n=2$ with equal vs. unequal.
- Entire array equal.
- Alternating values.
- Large $w$ with small $n$.
- Multiple test cases with $\sum n$ near $10^6$.}
\PITFALLS{- Forgetting to handle $n=1$.
- Integer overflow in languages without big integers (use 64-bit).
- Off-by-one scanning indices $i$ to $n-2$.
- Misinterpreting the inequality constraint as global (it applies only to the operated pair).
- Printing extra spaces or lines (I/O format strict).}
\FAILMODES{Any approach trying to simulate arbitrarily may be too slow or miss the optimal operation count. The closed-form avoids such pitfalls by using structural invariants.}
\ELI{Either you cannot start at all (no adjacent equals), or once you can start, you can sweep across the array, turning everything up to $w$ except for one unavoidable $-1$ deficit, needing exactly $n-1$ steps.}
\NotePages{3}

\end{document}