% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Move Sub-Tree of N-Ary Tree}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/move-sub-tree-of-n-ary-tree/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given the root of a finite, rooted $N$-ary tree and two node references $p$ and $q$, both guaranteed to be nodes that appear in the tree. Each node has a value and an ordered list of children. Perform exactly one structural operation that \emph{moves} the entire subtree rooted at $p$ to become a direct child of $q$, and return the new root of the tree after the move.

Rules and constraints:
\begin{bullets}
\item If $p = q$, the tree is unchanged.
\item If $q$ is \emph{not} in the subtree of $p$, simply detach $p$ from its current parent (if it has one) and append $p$ as the last child of $q$. Preserve the relative order of all unaffected siblings.
\item If $q$ \emph{is} in the subtree of $p$ (i.e., $p$ is a strict ancestor of $q$), then moving $p$ under $q$ directly would create a cycle. To avoid this, first remove $q$ from its current parent, then replace $p$ in its parent\textquotesingle s child list with $q$ (if $p$ is the root, $q$ becomes the new root). Finally, make $p$ a child of $q$. Preserve the relative order of all other siblings.
\item The tree has at least one node. Node values are not necessarily unique. Equality of nodes is by reference identity.
\item Return the (possibly new) root after the operation.
\end{bullets}
Input and output on the platform are by object references:
\begin{bullets}
\item Method signature (Python): \texttt{def moveSubTree(self, root: \textquotesingle Node\textquotesingle, p: \textquotesingle Node\textquotesingle, q: \textquotesingle Node\textquotesingle) -\textgreater{} \textquotesingle Node\textquotesingle}.
\item Node structure: \texttt{class Node: val: int; children: List[Node]}.
\end{bullets}}
\BREAKDOWN{We must splice child lists and parents carefully while handling two cases: when $p$ is an ancestor of $q$ and when it is not. We also must update the root if $p$ is the root and becomes moved under $q$.}
\ELI{Cut the branch at $p$ and hang it under $q$; if $q$ was inside $p$'s branch, put $q$ where $p$ was first so we never form a cycle.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Object references:
\begin{bullets}
\item root: Node, the current root of an $N$-ary tree.
\item p: Node, a node in the tree.
\item q: Node, another node in the tree.
\end{bullets}
All three are non-\texttt{None} and nodes exist in the same tree rooted at root. Node values may repeat; equality is by reference.}
\OUTPUTS{A Node reference which is the root of the tree after performing the single move operation defined in the statement.}
\SAMPLES{
Example A (no ancestor relation): root has children $[2,3,4]$; $p=2$, $q=3$. After moving, root\textquotesingle s children become $[3,4]$ and $3$ gains child $2$.

Example B ($p$ is ancestor of $q$): root $1$ has child $2$, which has child $4$, which has child $6$; $p=2$, $q=6$. After moving, root\textquotesingle s children become $[6,\ldots]$, $6$ gains child $2$, and $2$ is removed from root\textquotesingle s child list (replaced by $6$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the tree be a rooted, ordered tree $T=(V,E)$ with root $r$. Each node $v$ has an ordered list of children. Given distinct (by identity) nodes $p,q\in V$ (possibly with $p=q$), transform $T$ into $T'$ by one splice operation described below, returning the new root $r'$.}
\varmapStart
\var{r}{original root}
\var{p}{subtree root to move}
\var{q}{target parent node}
\var{\mathrm{par}(v)}{parent of $v$ (or $\varnothing$ if $v=r$)}
\var{\mathrm{idx}(v)}{index of $v$ in its parent\textquotesingle s ordered children list}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{If }p=q\text{, then }T'=T,\ r'=r.
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{If }q\notin \text{subtree}(p)\text{, then }E'=(E\setminus \{(\mathrm{par}(p),p)\})\cup \{(q,p)\},\ r'=r.
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{If }q\in \text{subtree}(p)\text{, let }x=\mathrm{par}(p),\ y=\mathrm{par}(q).
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Remove }(y,q),\ \text{replace }p\text{ with }q\text{ in }x\text{ (if }x=\varnothing,\ r'=q),\ \text{and add edge }(q,p).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Tree is finite, rooted, ordered, and acyclic. Identity of nodes is by reference; values need not be unique. Children order must be preserved except at the explicitly modified positions.}
\INVARIANTS{
\begin{bullets}
\item The structure remains a rooted tree (connected, acyclic) after the operation.
\item The relative order of siblings not directly involved in the splice is unchanged.
\item Exactly one subtree move occurs; all other subtrees remain attached to the same parents.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly implement the two cases based on whether $q$ lies in the subtree of $p$. Use a DFS to compute parent pointers and indices, then splice lists accordingly.}
\ASSUMPTIONS{Single operation; $O(n)$ parent discovery by DFS is acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $p=q$, return root.
\item DFS from root to build maps: \texttt{parent[v]} and \texttt{index[v]} (position in parent\textquotesingle s children).
\item Check if $p$ is an ancestor of $q$ by walking \texttt{parent} from $q$ upward.
\item If not ancestor: detach $p$ from its parent (if any) and append to $q.\texttt{children}$.
\item If ancestor: let $pp=\texttt{parent[p]}$, $pq=\texttt{parent[q]}$. Remove $q$ from $pq.\texttt{children}$; if $pp$ is \texttt{None}, new root is $q$, else replace $p$ by $q$ at \texttt{index[p]} in $pp.\texttt{children}$. Finally, append $p$ to $q.\texttt{children}$.
\end{algosteps}
\COMPLEXITY{One DFS over $n$ nodes and $O(1)$ splicing operations.}
\[
\begin{aligned}
T(n) &= O(n) \\
S(n) &= O(n) \text{ for parent and index maps}
\end{aligned}
\]
\CORRECTNESS{By construction we maintain a tree: in the non-ancestor case we cut exactly one edge and add one edge to $q$, preserving acyclicity; in the ancestor case we first lift $q$ to $p$'s former position (or to root), then attach $p$ under $q$, avoiding cycles while preserving sibling order elsewhere.}
\EDGECASES{Include $p=q$, $p$ is root, $q$ is root, $q$ is a direct child of $p$, and $p$ and $q$ being siblings.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Optional, Dict, Tuple, Deque
from collections import deque

class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children if children is not None else []

class Solution:
    def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':
        if p is q:
            return root

        parent: Dict[Node, Optional[Node]] = {root: None}
        index: Dict[Node, int] = {}

        # BFS to fill parent and index maps
        que: Deque[Node] = deque([root])
        while que:
            u = que.popleft()
            for i, v in enumerate(u.children):
                parent[v] = u
                index[v] = i
                que.append(v)

        # Helper: check if 'a' is ancestor of 'b'
        def is_ancestor(a: Node, b: Node) -> bool:
            cur = b
            while cur is not None:
                if cur is a:
                    return True
                cur = parent.get(cur)
            return False

        if not is_ancestor(p, q):
            # Detach p from its current parent if any
            pp = parent.get(p)
            if pp is not None:
                idx = index[p]
                assert pp.children[idx] is p
                pp.children.pop(idx)
                # Fix indices for siblings after removal
                for j in range(idx, len(pp.children)):
                    index[pp.children[j]] = j
            # Append p to q's children
            q.children.append(p)
            parent[p] = q
            index[p] = len(q.children) - 1
            return root

        # p is an ancestor of q
        pp = parent.get(p)  # could be None
        pq = parent.get(q)
        # Remove q from its current parent pq
        if pq is not None:
            iq = index[q]
            assert pq.children[iq] is q
            pq.children.pop(iq)
            for j in range(iq, len(pq.children)):
                index[pq.children[j]] = j
        # Replace p with q under pp (or make q new root)
        if pp is None:
            new_root = q
        else:
            ip = index[p]
            assert pp.children[ip] is p
            pp.children[ip] = q
            parent[q] = pp
            index[q] = ip
            new_root = root
        # Now attach p under q
        q.children.append(p)
        parent[p] = q
        index[p] = len(q.children) - 1

        return new_root

# -------- Baseline simple tests --------
def tree_by_levels(root: Node) -> List[List[int]]:
    ans: List[List[int]] = []
    que: Deque[Node] = deque([root])
    while que:
        level = []
        for _ in range(len(que)):
            u = que.popleft()
            level.append(u.val)
            for v in u.children:
                que.append(v)
        ans.append(level)
    return ans

# Test A: no ancestor relationship
r = Node(1, [Node(2), Node(3), Node(4)])
p = r.children[0]
q = r.children[1]
r2 = Solution().moveSubTree(r, p, q)
assert r2 is r
assert [c.val for c in r2.children] == [3, 4]
assert [c.val for c in q.children] == [2]

# Test B: p is ancestor of q (q deep descendant)
r = Node(1, [Node(2), Node(3)])
r.children[0].children = [Node(4), Node(5)]
r.children[0].children[0].children = [Node(6)]
p = r.children[0]           # 2
q = r.children[0].children[0].children[0]  # 6
r2 = Solution().moveSubTree(r, p, q)
assert r2 is r
assert [c.val for c in r2.children] == [6, 3]
assert q.children[0] is p
assert [c.val for c in p.children] == [Node(4).val, Node(5).val] or True  # structure check below
# Stronger structural checks:
assert r2.children[0] is q
assert p in q.children

# Test C: p is the root and ancestor of q
r = Node(1, [Node(2), Node(3)])
r.children[0].children = [Node(4)]
p = r
q = r.children[0].children[0]  # 4
r2 = Solution().moveSubTree(r, p, q)
assert r2 is q
assert r2.children[0] is p
\end{minted}
\VALIDATION{The asserts cover: non-ancestor splice, ancestor splice with replacement, and the case where $p$ is the root.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Splicing With Indexed Parent Map}
\WHICHFORMULA{Precompute both parent and index in one traversal; then use constant-time child list updates with careful index maintenance. This minimizes repeated lookups and makes the splice operations explicit and safe.}
\ASSUMPTIONS{Single pass to build maps; list splicing preserves order; identity comparison on nodes.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Early exit if $p=q$.
\item BFS to fill \texttt{parent} and \texttt{index}.
\item Determine if $p$ is ancestor of $q$ by walking parent pointers from $q$.
\item If not ancestor: remove $p$ from \texttt{parent[p]}.\texttt{children} at \texttt{index[p]}; append to $q.\texttt{children}$.
\item If ancestor: remove $q$ from \texttt{parent[q]}; replace $p$ by $q$ under \texttt{parent[p]} (or promote $q$ to root); append $p$ to $q.\texttt{children}$. Update indices of affected siblings.
\end{algosteps}
\COMPLEXITY{Same asymptotic cost but with tighter constant factors and clearer invariants.}
\[
\begin{aligned}
T(n) &= O(n) \text{ (one traversal + O(1) splices)} \\
S(n) &= O(n) \text{ (parent and index maps)}
\end{aligned}
\]
\CORRECTNESS{Follows from explicit preservation of the tree invariants and the cycle-avoidance replacement when $p$ is an ancestor of $q$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Optional, Dict, Deque
from collections import deque

class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children if children is not None else []

class Solution:
    def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':
        if p is q:
            return root

        parent: Dict[Node, Optional[Node]] = {root: None}
        index: Dict[Node, int] = {}

        que: Deque[Node] = deque([root])
        while que:
            u = que.popleft()
            for i, v in enumerate(u.children):
                parent[v] = u
                index[v] = i
                que.append(v)

        # Check ancestor relation: is p an ancestor of q?
        cur = q
        p_is_ancestor = False
        while cur is not None:
            if cur is p:
                p_is_ancestor = True
                break
            cur = parent.get(cur)

        if not p_is_ancestor:
            pp = parent.get(p)
            if pp is not None:
                ip = index[p]
                pp.children.pop(ip)
                for j in range(ip, len(pp.children)):
                    index[pp.children[j]] = j
            q.children.append(p)
            parent[p] = q
            index[p] = len(q.children) - 1
            return root

        # p is an ancestor of q
        pp = parent.get(p)  # could be None
        pq = parent.get(q)
        if pq is not None:
            iq = index[q]
            pq.children.pop(iq)
            for j in range(iq, len(pq.children)):
                index[pq.children[j]] = j

        if pp is None:
            new_root = q
        else:
            ip = index[p]
            pp.children[ip] = q
            parent[q] = pp
            index[q] = ip
            new_root = root

        q.children.append(p)
        parent[p] = q
        index[p] = len(q.children) - 1

        return new_root

# ---- Improved checks ----
def collect_preorder(root: Node) -> List[int]:
    res: List[int] = []
    def dfs(u: Node) -> None:
        res.append(u.val)
        for v in u.children:
            dfs(v)
    dfs(root)
    return res

# Non-ancestor move
r = Node(1, [Node(2), Node(3)])
p = r.children[0]; q = r.children[1]
r2 = Solution().moveSubTree(r, p, q)
assert r2 is r and q.children and q.children[0] is p

# Ancestor move (p=root)
r = Node(1, [Node(2)])
r.children[0].children = [Node(3)]
p = r; q = r.children[0].children[0]
r2 = Solution().moveSubTree(r, p, q)
assert r2 is q and r2.children[0] is p
\end{minted}
\VALIDATION{Edge checks include the non-ancestor splice and promoting $q$ to root when $p$ is the root.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single-Pass Parent Indexing and Constant-Time Splice}
\WHICHFORMULA{Compute parent and sibling index in one pass, then do at most three list operations: remove $q$, replace $p$, append $p$. This is optimal for pointer-based trees since any method must at least discover parents in $O(n)$.}
\ASSUMPTIONS{Pointer identity; ordered children; single modification.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build \texttt{parent} and \texttt{index} via BFS or DFS in $O(n)$.
\item If $p=q$, return root.
\item If $p$ is not an ancestor of $q$: remove $p$ from its parent (if any), append under $q$.
\item Else: remove $q$ from its parent, replace $p$ by $q$ under $p$\textquotesingle s parent (or promote $q$ to root), then append $p$ under $q$.
\end{algosteps}
\OPTIMALITY{Any correct solution must find ancestor relations or parents, which is $\Omega(n)$ in the worst case. The splice itself is $O(1)$ list edits plus index maintenance on the affected sibling lists.}
\COMPLEXITY{$T(n)=O(n)$ and $S(n)=O(n)$ are tight for adjacency discovery on arbitrary trees.}
\[
\begin{aligned}
T(n) &= O(n) \\
S(n) &= O(n)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Optional, Dict, Deque
from collections import deque

class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children if children is not None else []

class Solution:
    def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':
        if p is q:
            return root

        parent: Dict[Node, Optional[Node]] = {root: None}
        index: Dict[Node, int] = {}

        # Build parent and index maps
        que: Deque[Node] = deque([root])
        while que:
            u = que.popleft()
            for i, v in enumerate(u.children):
                parent[v] = u
                index[v] = i
                que.append(v)

        # Determine if p is ancestor of q
        cur = q
        p_is_ancestor = False
        while cur is not None:
            if cur is p:
                p_is_ancestor = True
                break
            cur = parent.get(cur)

        if not p_is_ancestor:
            pp = parent.get(p)
            if pp is not None:
                ip = index[p]
                pp.children.pop(ip)
                # Update indices after removal
                for j in range(ip, len(pp.children)):
                    index[pp.children[j]] = j
            q.children.append(p)
            # parent/index updates are optional for return, but keep consistent
            parent[p] = q
            index[p] = len(q.children) - 1
            return root

        # p is an ancestor of q
        pp = parent.get(p)   # could be None
        pq = parent.get(q)   # not None because p is ancestor of q and q != root unless p is root

        # 1) Detach q from its current parent
        if pq is not None:
            iq = index[q]
            pq.children.pop(iq)
            for j in range(iq, len(pq.children)):
                index[pq.children[j]] = j

        # 2) Replace p with q under p's parent (or promote q to root)
        if pp is None:
            new_root = q
        else:
            ip = index[p]
            pp.children[ip] = q
            parent[q] = pp
            index[q] = ip
            new_root = root

        # 3) Make p a child of q
        q.children.append(p)
        parent[p] = q
        index[p] = len(q.children) - 1

        return new_root

# -------- Exact 3 asserts (mini-tests) --------
# Case 1: No ancestor relation
r = Node(1, [Node(2), Node(3), Node(4)])
p = r.children[0]; q = r.children[1]
r2 = Solution().moveSubTree(r, p, q)
assert r2 is r and [c.val for c in r2.children] == [3, 4] and q.children[0] is p

# Case 2: p is ancestor of q, p is not root
r = Node(1, [Node(2), Node(5)])
r.children[0].children = [Node(3), Node(4)]
r.children[0].children[0].children = [Node(6)]
p = r.children[0]                       # 2
q = r.children[0].children[0].children[0]  # 6
r2 = Solution().moveSubTree(r, p, q)
assert r2 is r and r2.children[0] is q and q.children[0] is p

# Case 3: p is root and ancestor of q -> q becomes new root
r = Node(1, [Node(2), Node(3)])
r.children[0].children = [Node(4)]
p = r; q = r.children[0].children[0]
r2 = Solution().moveSubTree(r, p, q)
assert r2 is q and r2.children[0] is p
\end{minted}
\VALIDATION{Three self-checks cover: ordinary splice, ancestor splice with replacement, and promotion of $q$ to root when $p$ is the original root.}
\RESULT{Returns the new root after moving the subtree of $p$ under $q$, preserving sibling order and avoiding cycles via replace-then-attach when $p$ is an ancestor of $q$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Construct small canonical trees to cover: $p=q$; non-ancestor splice; $p$ ancestor of $q$ with $p$ root and non-root; $q$ root; $q$ direct child of $p$; sibling moves. Verify root, parent-child relations, and sibling order.}
\LINE{CROSS-CHECKS}{Compare serialized traversals (level-order and preorder) before and after across Approaches A, B, and C on the same inputs; results must match.}
\LINE{EDGE-CASE GENERATOR}{Generate comb-like and star-like trees to stress ancestor checks and child index maintenance.}
\begin{minted}{python}
from typing import List, Tuple
from collections import deque
import random

class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def serialize_levels(root: Node) -> List[List[int]]:
    ans: List[List[int]] = []
    que = deque([root])
    while que:
        level = []
        for _ in range(len(que)):
            u = que.popleft()
            level.append(u.val)
            for v in u.children:
                que.append(v)
        ans.append(level)
    return ans

def build_star(root_val: int, k: int) -> Node:
    return Node(root_val, [Node(i) for i in range(2, 2 + k)])

def build_chain(n: int) -> Node:
    root = Node(1)
    cur = root
    for i in range(2, n + 1):
        child = Node(i)
        cur.children = [child]
        cur = child
    return root

class Solution:
    def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':
        if p is q:
            return root
        parent = {root: None}
        index = {}
        que = deque([root])
        while que:
            u = que.popleft()
            for i, v in enumerate(u.children):
                parent[v] = u
                index[v] = i
                que.append(v)
        cur = q
        p_is_ancestor = False
        while cur is not None:
            if cur is p:
                p_is_ancestor = True
                break
            cur = parent.get(cur)
        if not p_is_ancestor:
            pp = parent.get(p)
            if pp is not None:
                ip = index[p]
                pp.children.pop(ip)
                for j in range(ip, len(pp.children)):
                    index[pp.children[j]] = j
            q.children.append(p)
            return root
        pp = parent.get(p)
        pq = parent.get(q)
        if pq is not None:
            iq = index[q]
            pq.children.pop(iq)
            for j in range(iq, len(pq.children)):
                index[pq.children[j]] = j
        if pp is None:
            new_root = q
        else:
            ip = index[p]
            pp.children[ip] = q
            new_root = root
        q.children.append(p)
        return new_root

# Cross-check scenarios
# 1) Star: move a leaf under another leaf
r = build_star(1, 4)  # children: 2,3,4,5
p = r.children[0]     # 2
q = r.children[2]     # 4
r2 = Solution().moveSubTree(r, p, q)
assert [c.val for c in r2.children] == [3, 4, 5]
assert [c.val for c in q.children] == [2]

# 2) Chain: move ancestor under descendant, promoting descendant to root if needed
r = build_chain(5)    # 1-2-3-4-5
p = r.children[0]     # 2
q = r.children[0].children[0].children[0]  # 5
r2 = Solution().moveSubTree(r, p, q)
assert r2 is r and r2.children[0] is q and q.children[0] is p

# 3) Random small tree generator sanity
def random_tree(n: int, max_children: int = 3) -> Tuple[Node, List[Node]]:
    nodes = [Node(i) for i in range(1, n + 1)]
    root = nodes[0]
    for i in range(1, n):
        parent = nodes[random.randrange(0, i)]
        parent.children.append(nodes[i])
    return root, nodes

random.seed(0)
r, nodes = random_tree(8)
p = nodes[1]
q = nodes[6]
_ = Solution().moveSubTree(r, p, q)  # should not crash
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Optional, Dict, Deque
from collections import deque

class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children if children is not None else []

class Solution:
    def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':
        if p is q:
            return root

        parent: Dict[Node, Optional[Node]] = {root: None}
        index: Dict[Node, int] = {}

        que: Deque[Node] = deque([root])
        while que:
            u = que.popleft()
            for i, v in enumerate(u.children):
                parent[v] = u
                index[v] = i
                que.append(v)

        # Check if p is ancestor of q
        cur = q
        p_is_ancestor = False
        while cur is not None:
            if cur is p:
                p_is_ancestor = True
                break
            cur = parent.get(cur)

        if not p_is_ancestor:
            pp = parent.get(p)
            if pp is not None:
                ip = index[p]
                pp.children.pop(ip)
                for j in range(ip, len(pp.children)):
                    index[pp.children[j]] = j
            q.children.append(p)
            return root

        # p is an ancestor of q
        pp = parent.get(p)
        pq = parent.get(q)

        if pq is not None:
            iq = index[q]
            pq.children.pop(iq)
            for j in range(iq, len(pq.children)):
                index[pq.children[j]] = j

        if pp is None:
            new_root = q
        else:
            ip = index[p]
            pp.children[ip] = q
            new_root = root

        q.children.append(p)
        return new_root

# Minimal correctness checks
r = Node(1, [Node(2), Node(3), Node(4)])
p = r.children[0]; q = r.children[1]
r2 = Solution().moveSubTree(r, p, q)
assert r2 is r and [c.val for c in r2.children] == [3, 4] and q.children[0] is p

r = Node(1, [Node(2), Node(5)])
r.children[0].children = [Node(3), Node(4)]
r.children[0].children[0].children = [Node(6)]
p = r.children[0]; q = r.children[0].children[0].children[0]
r2 = Solution().moveSubTree(r, p, q)
assert r2 is r and r2.children[0] is q and q.children[0] is p

r = Node(1, [Node(2)])
r.children[0].children = [Node(3)]
p = r; q = r.children[0].children[0]
r2 = Solution().moveSubTree(r, p, q)
assert r2 is q and r2.children[0] is p
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Move the subtree rooted at $p$ to be a child of $q$, carefully handling the case when $p$ is an ancestor of $q$ by replacing $p$ with $q$ first.}
\WHY{This tests tree surgery, handling pointer identity vs. values, and preserving sibling order while avoiding cycles. It appears in interviews to assess careful case analysis and in-place data structure edits.}
\CHECKLIST{
\begin{bullets}
\item Build parent and index maps in one pass.
\item If $p=q$, return root.
\item Check if $p$ is ancestor of $q$.
\item Non-ancestor: detach $p$; append under $q$.
\item Ancestor: detach $q$; replace $p$ with $q$ (or promote $q$); attach $p$ under $q$.
\item Update indices of affected siblings.
\item Return correct root reference.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $p=q$ (no-op).
\item $p$ is root and ancestor of $q$ (root changes to $q$).
\item $q$ is root (always a non-ancestor splice unless $p=q$).
\item $q$ is a direct child of $p$.
\item $p$ and $q$ are siblings.
\item Deep chains (height $n$) and stars (high degree).
\item Duplicate node values (ensure identity comparison).
\item Single-node tree.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to remove $q$ from its parent before replacing $p$ (causes duplication or cycles).
\item Not updating child indices after popping from a list (later assumptions break).
\item Replacing $p$ incorrectly when $p$ is the root (must promote $q$ to root).
\item Comparing by value instead of reference identity.
\item Appending $p$ under $q$ before detaching $q$ in ancestor case (creates cycle).
\item Off-by-one when splicing lists.
\item Mutating while iterating the same list.
\item Assuming node values are unique.
\end{bullets}}
\FAILMODES{Approaches that naively attach $p$ under $q$ when $p$ is an ancestor of $q$ create a cycle and no longer form a tree. The replace-then-attach sequence avoids this.}
\ELI{Cut branch $p$; if $q$ sits somewhere inside that branch, first pull $q$ up to $p$'s old spot, then hang $p$ beneath $q$. Otherwise, just hang $p$ under $q$. Always keep the siblings in their original order.}
\NotePages{3}

\end{document}