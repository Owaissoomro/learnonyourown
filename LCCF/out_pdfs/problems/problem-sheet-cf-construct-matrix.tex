% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Construct Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1917/E}}
\LINE{DIFFICULTY / RATING}{2500}
\STATEMENT{You are given an even integer $n$ and an integer $k$. Your task is to construct a matrix of size $n \times n$ consisting of numbers $0$ and $1$ in such a way that the following conditions are true, or report that it is impossible:
\begin{bullets}
\item the sum of all the numbers in the matrix is exactly $k$;
\item the bitwise \texttt{XOR} of all the numbers in the row $i$ is the same for each $i$;
\item the bitwise \texttt{XOR} of all the numbers in the column $j$ is the same for each $j$.
\end{bullets}
Input: Each test consists of multiple test cases. The first line contains a single integer $t$ ($1 \le t \le 130$) — the number of test cases. The description of the test cases follows.

Each test case is described by a single line, which contains two integers $n$ and $k$ ($2 \le n \le 1000$, $n$ is even, $0 \le k \le n^2$).

It is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.

Output: For each test case, output \texttt{Yes} if it is possible to construct a matrix that satisfies all of the problem's conditions, and \texttt{No} otherwise.

If it is possible to construct a matrix, the $i$-th of the next $n$ lines should contain $n$ integers representing the elements in the $i$-th row of the matrix.

Note: In the first example, all conditions are satisfied:
\begin{bullets}
\item the sum of all the numbers in the matrix is exactly $0$;
\item the bitwise \texttt{XOR} of all the numbers in the row $i$ is $0$ for each $i$;
\item the bitwise \texttt{XOR} of all the numbers in the column $j$ is $0$ for each $j$.
\end{bullets}
In the third example, it can be shown that it is impossible to find a matrix satisfying all the problem's conditions.}
\BREAKDOWN{We need to decide feasibility and construct a binary $n \times n$ matrix with exactly $k$ ones such that all row XORs are equal and all column XORs are equal. With $n$ even, it suffices to construct matrices where every row and every column has even sum (row XOR $=0$, column XOR $=0$), except for small excluded totals.}
\ELI{Think of ones as edges in a bipartite graph between rows and columns; we need every vertex to have even degree, and exactly $k$ edges. This is a union of even cycles; any even $k$ except $2$ (and by complement, $n^2-2$) can be made for $n \ge 4$, with a small special handling when $n=2$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: integers $n$ (even, $2 \le n \le 1000$) and $k$ ($0 \le k \le n^2$).}
\OUTPUTS{For each case: print \texttt{Yes} and an $n \times n$ $0/1$ matrix achieving the constraints, or \texttt{No} if impossible. Rows are printed on separate lines with space-separated entries.}
\SAMPLES{Example 1:
\begin{minted}{python}
Input
1
4 6
Output
Yes
1 1 0 0
0 1 1 0
0 0 1 1
1 0 0 1
\end{minted}
Example 2:
\begin{minted}{python}
Input
2
2 2
6 2
Output
Yes
1 0
0 1
No
\end{minted}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in \{0,1\}^{n \times n}$, $n$ even. Let $r_i = \bigoplus_{j=1}^n A_{ij}$ and $c_j = \bigoplus_{i=1}^n A_{ij}$. We need $r_i$ equal for all $i$ and $c_j$ equal for all $j$, and $\sum_{i,j} A_{ij} = k$.}
\varmapStart
\var{n}{matrix dimension (even)}
\var{k}{target number of ones}
\var{r}{common row XOR (will use $r=0$)}
\var{c}{common column XOR (will use $c=0$)}
\var{A}{binary matrix to construct}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\sum_{i=1}^n \sum_{j=1}^n A_{ij} = k, \\
&r_i = \bigoplus_{j=1}^n A_{ij} = r \quad \forall i, \\
&c_j = \bigoplus_{i=1}^n A_{ij} = c \quad \forall j.
\end{aligned}
\]
}
\ASSUMPTIONS{$n$ is even. We may choose to target $r=c=0$ by ensuring every row/column has even sum; for $n$ even, complementing also preserves $r$ and $c$.}
\INVARIANTS{Placing a $2\times 2$ all-ones block increases degrees of exactly two rows and two columns by $2$ each (parities unchanged). Placing a simple $6$-cycle on $3$ rows and $3$ columns increases those $6$ vertex degrees by $2$ (parities unchanged).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Start from the observation that with $n$ even, setting all row/column XORs to $0$ is sufficient. Use only disjoint $2\times2$ all-ones tiles to realize totals that are multiples of $4$.}
\ASSUMPTIONS{Only $k \equiv 0 \pmod{4}$ are attempted; choose any set of $\tfrac{k}{4}$ disjoint $2\times2$ tiles.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k \not\equiv 0 \pmod{4}$, report \texttt{No}.
\item Otherwise, iterate tiles $(i,i+1)\times(j,j+1)$ for $i,j \in \{1,3,5,\ldots,n-1\}$, filling with ones until $\tfrac{k}{4}$ tiles are placed.
\item Print \texttt{Yes} and the matrix.
\end{algosteps}
\COMPLEXITY{Linear in matrix size.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \\
S(n) &= \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{Each $2\times2$ all-ones block contributes $4$ ones while keeping every involved row and column sum even; disjointness ensures exact counting. Thus row XORs and column XORs are all $0$ and the total sum is $k$.}
\EDGECASES{If $k=0$, print all zeros. If $k=n^2$, print all ones.}
\textbf{Code (Baseline)}
\begin{minted}{python}
#!/usr/bin/env python3
from typing import List, Tuple

def read_input() -> List[Tuple[int,int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data: 
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        cases.append((n,k))
    return cases

def construct_baseline(n: int, k: int) -> Tuple[bool, List[List[int]]]:
    if k % 4 != 0:
        return (False, [])
    m = [[0]*n for _ in range(n)]
    need = k // 4
    for i in range(0, n, 2):
        for j in range(0, n, 2):
            if need == 0:
                break
            m[i][j] = m[i][j+1] = m[i+1][j] = m[i+1][j+1] = 1
            need -= 1
        if need == 0:
            break
    if need != 0:
        return (False, [])
    return (True, m)

def solve_case(n: int, k: int) -> Tuple[bool, List[List[int]]]:
    return construct_baseline(n, k)

def solve_all(cases: List[Tuple[int,int]]) -> str:
    out_lines = []
    for n, k in cases:
        ok, mat = solve_case(n, k)
        if not ok:
            out_lines.append("No")
        else:
            out_lines.append("Yes")
            for row in mat:
                out_lines.append(" ".join(map(str, row)))
    return "\n".join(out_lines)

def _check_rowcol_xor(mat: List[List[int]]) -> Tuple[bool, bool]:
    n = len(mat)
    if n == 0: 
        return True, True
    rx = [0]*n
    cx = [0]*n
    for i in range(n):
        for j in range(n):
            rx[i] ^= (mat[i][j] & 1)
            cx[j] ^= (mat[i][j] & 1)
    return all(x == rx[0] for x in rx), all(x == cx[0] for x in cx)

def _sum_mat(mat: List[List[int]]) -> int:
    return sum(sum(r) for r in mat)

def _self_test():
    # Simple tests for baseline multiples of 4
    for n in (2, 4, 6):
        for k in (0, 4, 8):
            ok, mat = construct_baseline(n, k)
            if k % 4 != 0:
                assert not ok
            else:
                assert ok
                assert _sum_mat(mat) == k
                rr, cc = _check_rowcol_xor(mat)
                assert rr and cc

if __name__ == "__main__":
    _self_test()
    print(solve_all(read_input()))
\end{minted}
\VALIDATION{Asserts verify sum equals $k$ and uniform row/column XOR for several sizes when $k$ is a multiple of $4$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Add a 6-cycle to reach $k \equiv 2 \ (\bmod\ 4)$}
\WHICHFORMULA{Any even-degree bipartite subgraph is a union of even cycles. To realize $k \equiv 2 \ (\bmod\ 4)$ with $k \ge 6$, place one $6$-cycle (adds $6$ ones) and fill the remainder using $2\times2$ all-ones blocks (adds multiples of $4$).}
\ASSUMPTIONS{$n \ge 4$ provides at least $3$ rows and $3$ columns to host a $6$-cycle. Overlaps with later $2\times2$ blocks are avoided to keep exact counts simple.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $k$ is odd, print \texttt{No}.
\item If $k \equiv 0 \pmod{4}$, use Approach A.
\item If $k \equiv 2 \pmod{4}$ and $k \ge 6$, place a fixed $6$-cycle on rows $1,2,3$ and cols $1,2,3$:
$(1,1),(1,2),(2,2),(2,3),(3,3),(3,1)$.
\item Reduce $k \leftarrow k-6$ and fill $\tfrac{k}{4}$ disjoint $2\times2$ blocks avoiding used cells.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline.}
\[
\begin{aligned}
T(n) &= \Theta(n^2) \\
\end{aligned}
\]
\CORRECTNESS{Row/column degrees remain even because each gadget adds degree $2$ to its incident vertices. Thus all row XORs and column XORs are $0$; the sum matches $k$.}
\textbf{Code (Improved)}
\begin{minted}{python}
#!/usr/bin/env python3
from typing import List, Tuple

def read_input() -> List[Tuple[int,int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data: 
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        cases.append((n,k))
    return cases

def _place_clean_tiles(mat: List[List[int]], need_tiles: int) -> int:
    """Place 'need_tiles' disjoint 2x2 all-ones tiles on currently-zero 2x2 faces."""
    n = len(mat)
    placed = 0
    for i in range(0, n, 2):
        for j in range(0, n, 2):
            if placed == need_tiles:
                return placed
            cells = [(i,j),(i,j+1),(i+1,j),(i+1,j+1)]
            if all(mat[x][y] == 0 for (x,y) in cells):
                for (x,y) in cells:
                    mat[x][y] = 1
                placed += 1
        if placed == need_tiles:
            break
    return placed

def construct_improved(n: int, k: int) -> Tuple[bool, List[List[int]]]:
    if k % 2 == 1:
        return (False, [])
    if n == 2:
        # Special exhaustive small case
        if k == 0:
            return (True, [[0,0],[0,0]])
        if k == 2:
            return (True, [[1,0],[0,1]])
        if k == 4:
            return (True, [[1,1],[1,1]])
        return (False, [])
    # n >= 4
    if k == 2 or k == n*n - 2:
        return (False, [])
    # Work with possibly complemented target to keep additions small
    inv = False
    t = k
    if t > (n*n)//2:
        inv = True
        t = n*n - t
    mat = [[0]*n for _ in range(n)]
    if t % 4 == 0:
        need = t // 4
        placed = _place_clean_tiles(mat, need)
        if placed != need:
            return (False, [])
    else:
        # t % 4 == 2, and t != 2 by earlier check => t >= 6
        # Place a 6-cycle on rows 0,1,2 and cols 0,1,2
        cyc = [(0,0),(0,1),(1,1),(1,2),(2,2),(2,0)]
        for (x,y) in cyc:
            mat[x][y] = 1
        t -= 6
        need = t // 4
        placed = _place_clean_tiles(mat, need)
        if placed != need:
            return (False, [])
    if inv:
        for i in range(n):
            for j in range(n):
                mat[i][j] ^= 1
    # Final sanity: sums and XOR uniform
    if sum(sum(r) for r in mat) != k:
        return (False, [])
    # Row XORs and col XORs same
    rx = [0]*n; cx = [0]*n
    for i in range(n):
        for j in range(n):
            rx[i] ^= mat[i][j]
            cx[j] ^= mat[i][j]
    if not all(x == rx[0] for x in rx):
        return (False, [])
    if not all(x == cx[0] for x in cx):
        return (False, [])
    return (True, mat)

def solve_case(n: int, k: int) -> Tuple[bool, List[List[int]]]:
    return construct_improved(n, k)

def solve_all(cases: List[Tuple[int,int]]) -> str:
    out_lines = []
    for n, k in cases:
        ok, mat = solve_case(n, k)
        if not ok:
            out_lines.append("No")
        else:
            out_lines.append("Yes")
            for row in mat:
                out_lines.append(" ".join(map(str, row)))
    return "\n".join(out_lines)

def _self_test():
    # n=2 exhaustive
    ok, m = construct_improved(2,0); assert ok and sum(sum(r) for r in m) == 0
    ok, m = construct_improved(2,2); assert ok and sum(sum(r) for r in m) == 2
    ok, m = construct_improved(2,4); assert ok and sum(sum(r) for r in m) == 4
    ok, _ = construct_improved(2,1); assert not ok
    # n=4: all even except 2 and 14
    for k in range(0,17):
        if k % 2 == 1 or k in (2, 14):
            ok, _ = construct_improved(4,k); assert not ok
        else:
            ok, m = construct_improved(4,k); 
            assert ok and sum(sum(r) for r in m) == k
    # Random small checks
    for n in (4,6):
        for k in range(0, n*n+1):
            ok, m = construct_improved(n,k)
            if ok:
                rr = [0]*n; cc=[0]*n
                for i in range(n):
                    for j in range(n):
                        rr[i] ^= m[i][j]; cc[j] ^= m[i][j]
                assert all(x == rr[0] for x in rr)
                assert all(x == cc[0] for x in cc)
                assert sum(sum(r) for r in m) == k

if __name__ == "__main__":
    _self_test()
    print(solve_all(read_input()))
\end{minted}
\VALIDATION{Includes self-tests: special $n=2$ cases, full sweep for $n=4$, and random checks for $n=4,6$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Full Feasibility Characterization and Construction}
\WHICHFORMULA{Characterize feasibility for even $n$:
\begin{bullets}
\item If $n=2$: feasible iff $k \in \{0,2,4\}$.
\item If $n \ge 4$ even: feasible iff $k$ is even and $k \notin \{2, n^2-2\}$.
\end{bullets}
Construction: build an even-degree subgraph (all row/column sums even). Use complement when $k > \tfrac{n^2}{2}$, one fixed $6$-cycle if needed for $k \equiv 2 \ (\bmod\ 4)$ and the rest from disjoint $2\times2$ all-ones blocks.}
\ASSUMPTIONS{Complement preserves uniform row/column XOR because $n$ is even. A $6$-cycle fits since $n \ge 4$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Handle $n=2$ explicitly: $k \in \{0,2,4\}$.
\item For $n \ge 4$:
  \begin{bullets}
  \item If $k$ is odd or $k \in \{2,n^2-2\}$, print \texttt{No}.
  \item Let $t=\min(k,n^2-k)$, maintain a flag whether to complement at the end.
  \item If $t \equiv 2 \pmod{4}$, place the fixed $6$-cycle and set $t\leftarrow t-6$.
  \item Fill $t/4$ disjoint $2\times 2$ all-ones blocks on clean tiles.
  \item Complement if needed; print \texttt{Yes} and the matrix.
  \end{bullets}
\end{algosteps}
\OPTIMALITY{The characterization is tight by parity and complement arguments: $k$ must be even (global XOR $=0$ for even $n$). $k=2$ is impossible for $n \ge 4$ (no $2$-edge even-degree bipartite subgraph), and $n^2-2$ follows by complement. All other even $k$ are reachable by unions of cycles (one $6$-cycle plus $4$-cycles).}
\COMPLEXITY{Linear in $n^2$.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \quad S(n)=\Theta(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
#!/usr/bin/env python3
from typing import List, Tuple

def read_input() -> List[Tuple[int,int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data: 
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        cases.append((n,k))
    return cases

def _place_clean_tiles(mat: List[List[int]], need_tiles: int) -> int:
    n = len(mat)
    placed = 0
    for i in range(0, n, 2):
        for j in range(0, n, 2):
            if placed == need_tiles:
                return placed
            cells = [(i,j),(i,j+1),(i+1,j),(i+1,j+1)]
            if all(mat[x][y] == 0 for (x,y) in cells):
                for (x,y) in cells:
                    mat[x][y] = 1
                placed += 1
        if placed == need_tiles:
            break
    return placed

def construct_matrix(n: int, k: int) -> Tuple[bool, List[List[int]]]:
    # Parity quick reject
    if k % 2 == 1:
        return (False, [])
    if n == 2:
        if k == 0:
            return (True, [[0,0],[0,0]])
        if k == 2:
            return (True, [[1,0],[0,1]])
        if k == 4:
            return (True, [[1,1],[1,1]])
        return (False, [])
    # n >= 4 even
    if k == 2 or k == n*n - 2:
        return (False, [])
    # Work with minimized target using complement (preserves XOR constraints for even n)
    inv = False
    t = k
    if t > (n*n)//2:
        inv = True
        t = n*n - t
    mat = [[0]*n for _ in range(n)]
    if t % 4 == 0:
        need = t // 4
        placed = _place_clean_tiles(mat, need)
        if placed != need:
            return (False, [])
    else:
        # t % 4 == 2 and t != 2 (ruled out by earlier check), hence t >= 6
        cyc = [(0,0),(0,1),(1,1),(1,2),(2,2),(2,0)]
        for (x,y) in cyc:
            mat[x][y] = 1
        t -= 6
        need = t // 4
        placed = _place_clean_tiles(mat, need)
        if placed != need:
            return (False, [])
    if inv:
        for i in range(n):
            for j in range(n):
                mat[i][j] ^= 1
    # Final verification
    total = sum(sum(r) for r in mat)
    if total != k:
        return (False, [])
    rx = [0]*n; cx = [0]*n
    for i in range(n):
        for j in range(n):
            rx[i] ^= mat[i][j]
            cx[j] ^= mat[i][j]
    if not all(x == rx[0] for x in rx): return (False, [])
    if not all(x == cx[0] for x in cx): return (False, [])
    return (True, mat)

def solve_case(n: int, k: int) -> Tuple[bool, List[List[int]]]:
    return construct_matrix(n, k)

def solve_all(cases: List[Tuple[int,int]]) -> str:
    out_lines = []
    for n, k in cases:
        ok, mat = solve_case(n, k)
        if not ok:
            out_lines.append("No")
        else:
            out_lines.append("Yes")
            for row in mat:
                out_lines.append(" ".join(map(str, row)))
    return "\n".join(out_lines)

def _check_uniform_xors(mat: List[List[int]]) -> bool:
    n = len(mat)
    rx = [0]*n; cx=[0]*n
    for i in range(n):
        for j in range(n):
            rx[i] ^= mat[i][j]
            cx[j] ^= mat[i][j]
    return all(x == rx[0] for x in rx) and all(x == cx[0] for x in cx)

def _self_test():
    # n=2 full
    for k in range(0,5):
        ok, mat = construct_matrix(2,k)
        if k in (0,2,4):
            assert ok and sum(sum(r) for r in mat) == k and _check_uniform_xors(mat)
        else:
            assert not ok
    # n=4: even except 2 and 14
    for k in range(0,17):
        ok, mat = construct_matrix(4,k)
        if k % 2 == 1 or k in (2,14):
            assert not ok
        else:
            assert ok and sum(sum(r) for r in mat) == k and _check_uniform_xors(mat)
    # Random spot checks
    for n in (4,6,8):
        for k in (0,4,6,8,n, n*n//2, n*n-6, n*n-4, n*n):
            ok, mat = construct_matrix(n,k)
            if k % 2 == 1 or (n>=4 and k in (2, n*n-2)) or (n==2 and k not in (0,2,4)):
                assert not ok
            else:
                assert ok
                assert sum(sum(r) for r in mat) == k
                assert _check_uniform_xors(mat)

if __name__ == "__main__":
    _self_test()
    print(solve_all(read_input()))
\end{minted}
\VALIDATION{Exactly 3 sanity groups: exhaustive $n=2$, complete sweep for $n=4$, and spot checks for larger even $n$.}
\RESULT{Feasible iff: $n=2$ with $k \in \{0,2,4\}$; or $n \ge 4$ even with $k$ even and $k \notin \{2, n^2-2\}$. Construction outputs all row XORs equal and all column XORs equal (both $0$).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test small sizes ($n=2,4$) exhaustively for $k$; spot test larger $n$ for representative $k$ including edges ($0, n, n^2/2, n^2-2, n^2$). Verify total ones and uniform XORs.}
\LINE{CROSS-CHECKS}{Compare counts against target $k$ and verify invariants: all row sums even, all column sums even. For complements, verify $n$ even preserves XOR uniformity.}
\LINE{EDGE-CASE GENERATOR}{Generate cases with $k \in \{0,2,4,6,n,n^2-2,n^2\}$ across even $n$.}
\begin{minted}{python}
#!/usr/bin/env python3
from typing import List, Tuple
import random

def construct_matrix(n: int, k: int) -> Tuple[bool, List[List[int]]]:
    # Final solver from Approach C (duplicated here for reference)
    if k % 2 == 1: return (False, [])
    if n == 2:
        if k == 0: return (True, [[0,0],[0,0]])
        if k == 2: return (True, [[1,0],[0,1]])
        if k == 4: return (True, [[1,1],[1,1]])
        return (False, [])
    if k == 2 or k == n*n - 2: return (False, [])
    inv = False
    t = k
    if t > (n*n)//2:
        inv = True
        t = n*n - t
    mat = [[0]*n for _ in range(n)]
    def place_clean_tiles(need: int) -> int:
        placed = 0
        for i in range(0, n, 2):
            for j in range(0, n, 2):
                if placed == need: return placed
                cells = [(i,j),(i,j+1),(i+1,j),(i+1,j+1)]
                if all(mat[x][y] == 0 for (x,y) in cells):
                    for (x,y) in cells: mat[x][y] = 1
                    placed += 1
            if placed == need: break
        return placed
    if t % 4 == 0:
        need = t // 4
        if place_clean_tiles(need) != need: return (False, [])
    else:
        for (x,y) in [(0,0),(0,1),(1,1),(1,2),(2,2),(2,0)]: mat[x][y] = 1
        t -= 6
        need = t // 4
        if place_clean_tiles(need) != need: return (False, [])
    if inv:
        for i in range(n):
            for j in range(n):
                mat[i][j] ^= 1
    return (True, mat)

def check_matrix(mat: List[List[int]], k: int) -> bool:
    n = len(mat)
    if sum(sum(r) for r in mat) != k: return False
    rx = [0]*n; cx=[0]*n
    for i in range(n):
        for j in range(n):
            rx[i] ^= mat[i][j]; cx[j] ^= mat[i][j]
    return all(x == rx[0] for x in rx) and all(x == cx[0] for x in cx)

def main():
    # Deterministic tests
    for n in (2,4,6,8):
        for k in (0,2,4,6,n, n*n//2, n*n-2, n*n):
            ok, mat = construct_matrix(n,k)
            if k % 2 == 1 or (n>=4 and k in (2,n*n-2)) or (n==2 and k not in (0,2,4)):
                assert not ok
            else:
                assert ok and check_matrix(mat, k)
    print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
#!/usr/bin/env python3
from typing import List, Tuple

def read_input() -> List[Tuple[int,int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        cases.append((n,k))
    return cases

def _place_clean_tiles(mat: List[List[int]], need_tiles: int) -> int:
    n = len(mat)
    placed = 0
    for i in range(0, n, 2):
        for j in range(0, n, 2):
            if placed == need_tiles:
                return placed
            cells = [(i,j),(i,j+1),(i+1,j),(i+1,j+1)]
            if all(mat[x][y] == 0 for (x,y) in cells):
                for (x,y) in cells:
                    mat[x][y] = 1
                placed += 1
        if placed == need_tiles:
            break
    return placed

def construct_matrix(n: int, k: int) -> Tuple[bool, List[List[int]]]:
    if k % 2 == 1:
        return (False, [])
    if n == 2:
        if k == 0: return (True, [[0,0],[0,0]])
        if k == 2: return (True, [[1,0],[0,1]])
        if k == 4: return (True, [[1,1],[1,1]])
        return (False, [])
    if k == 2 or k == n*n - 2:
        return (False, [])
    inv = False
    t = k
    if t > (n*n)//2:
        inv = True
        t = n*n - t
    mat = [[0]*n for _ in range(n)]
    if t % 4 == 0:
        need = t // 4
        if _place_clean_tiles(mat, need) != need:
            return (False, [])
    else:
        cyc = [(0,0),(0,1),(1,1),(1,2),(2,2),(2,0)]
        for (x,y) in cyc:
            mat[x][y] = 1
        t -= 6
        need = t // 4
        if _place_clean_tiles(mat, need) != need:
            return (False, [])
    if inv:
        for i in range(n):
            for j in range(n):
                mat[i][j] ^= 1
    # Verify
    s = sum(sum(r) for r in mat)
    if s != k:
        return (False, [])
    n2 = len(mat)
    rx = [0]*n2; cx=[0]*n2
    for i in range(n2):
        for j in range(n2):
            rx[i] ^= mat[i][j]; cx[j] ^= mat[i][j]
    if not all(x == rx[0] for x in rx): return (False, [])
    if not all(x == cx[0] for x in cx): return (False, [])
    return (True, mat)

def solve_case(n: int, k: int) -> Tuple[bool, List[List[int]]]:
    return construct_matrix(n, k)

def solve_all(cases: List[Tuple[int,int]]) -> str:
    out_lines = []
    for n, k in cases:
        ok, mat = solve_case(n, k)
        if not ok:
            out_lines.append("No")
        else:
            out_lines.append("Yes")
            for row in mat:
                out_lines.append(" ".join(map(str, row)))
    return "\n".join(out_lines)

def _self_test():
    # Basic asserts
    ok, m = construct_matrix(2,2); assert ok and sum(sum(r) for r in m) == 2
    ok, _ = construct_matrix(4,2); assert not ok
    ok, m = construct_matrix(4,6); assert ok and sum(sum(r) for r in m) == 6
    ok, m = construct_matrix(6,10); assert ok and sum(sum(r) for r in m) == 10
    ok, _ = construct_matrix(6,34); assert not ok  # n^2-2

if __name__ == "__main__":
    _self_test()
    print(solve_all(read_input()))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Construct a binary $n\times n$ matrix (even $n$) with exactly $k$ ones, equal row XORs, and equal column XORs.}
\WHY{Tests linear-algebraic parity reasoning, constructive combinatorics on bipartite graphs, and careful handling of complements and edge cases.}
\CHECKLIST{
\begin{bullets}
\item Check $n$ even; handle $n=2$ separately.
\item If $k$ odd, answer \texttt{No}.
\item If $n \ge 4$ and $k \in \{2, n^2-2\}$, answer \texttt{No}.
\item Reduce by complement if $k > \tfrac{n^2}{2}$.
\item If $t \equiv 2 \ (\bmod\ 4)$, place one $6$-cycle.
\item Fill remaining with disjoint $2\times2$ all-ones tiles on clean spots.
\item Verify sum and uniform XORs before printing.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=2$, $k \in \{0,2,4\}$.
\item $k=0$ (all zeros) and $k=n^2$ (all ones).
\item $k=2$ and $k=n^2-2$ for $n \ge 4$ (impossible).
\item Very small $k$ like $4,6$.
\item Very large $k$ near $n^2$ (use complement).
\item Minimal feasible odd-parity-per-row design not needed; we use even-parity construction.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Overlapping a $2\times2$ block with already set ones breaks exact counting; ensure clean placement for $+4$ increments.
\item Forgetting complement preserves XOR uniformity only for even $n$.
\item Printing format: exact \texttt{Yes}/\texttt{No}, rows space-separated.
\item Off-by-two when handling $t \equiv 2 \pmod{4}$ and excluding $t=2$.
\item Misinterpreting XOR with sum; use parity logic carefully.
\item Not validating final matrix before output.
\end{bullets}
}
\FAILMODES{Greedy per-cell fills that do not maintain even degrees per row/col will often break uniform XOR. Restrict to parity-safe gadgets (even cycles).}
\ELI{Treat ones as edges in a bipartite graph between rows and columns. We need every vertex to have an even degree; build the graph out of cycles. Use one $6$-cycle if you need $k \equiv 2 \ (\bmod\ 4)$, otherwise $2\times2$ squares suffice. Complement when there are many ones.}
\NotePages{3}

\end{document}