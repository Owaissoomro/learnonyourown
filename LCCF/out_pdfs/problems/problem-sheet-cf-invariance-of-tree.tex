% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Invariance of Tree}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/576/B}}
\LINE{DIFFICULTY / RATING}{CF: 576/B \quad Rating: 2100}
\STATEMENT{A tree of size $n$ is an undirected connected graph consisting of $n$ vertices without cycles.

Consider some tree with $n$ vertices. We call a tree invariant relative to permutation $p=p_1p_2\ldots p_n$, if for any two vertices of the tree $u$ and $v$ the condition holds: ``vertices $u$ and $v$ are connected by an edge if and only if vertices $p_u$ and $p_v$ are connected by an edge''.

You are given permutation $p$ of size $n$. Find some tree of size $n$, invariant relative to the given permutation.

Input:
The first line contains number $n$ ($1 \le n \le 10^5$) — the size of the permutation (also equal to the size of the sought tree).

The second line contains permutation $p_i$ ($1 \le p_i \le n$).

Output:
If the sought tree does not exist, print ``NO''.

Otherwise, print ``YES'', and then print $n-1$ lines, each of which contains two integers — the numbers of vertices connected by an edge of the tree you found. The vertices are numbered from $1$, the order of the edges and the order of the vertices within the edges does not matter.

If there are multiple solutions, output any of them.

Note:
In the first sample test a permutation transforms edge $(4, 1)$ into edge $(1, 4)$, edge $(4, 2)$ into edge $(1, 3)$ and edge $(1, 3)$ into edge $(4, 2)$. These edges all appear in the resulting tree.

It can be shown that in the second sample test no tree satisfies the given condition.}
\BREAKDOWN{Decompose the permutation into cycles. Characterize when a tree admits $p$ as an automorphism, and construct one if possible. Either use a fixed point to build a star, or use a transposition as a core and attach even cycles alternately.}
\ELI{If there is a fixed point, make a star centered there. Otherwise you need a 2-cycle and every other cycle must be even; hook vertices alternately to the two nodes of that 2-cycle.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item $n$ integer, $1\le n\le 10^5$.
\item A permutation $p_1,\ldots,p_n$ of $\{1,\ldots,n\}$.
\end{bullets}}
\OUTPUTS{
\begin{bullets}
\item If no invariant tree exists: print NO.
\item Else: print YES, then $n-1$ edges $u~v$ forming any valid invariant tree under $p$.
\end{bullets}}
\SAMPLES{
Example 1:
\begin{bullets}
\item Input:
\[
\begin{aligned}
3\\
1~3~2
\end{aligned}
\]
\item Output (one valid):
\[
\begin{aligned}
\text{YES}\\
1~2\\
1~3
\end{aligned}
\]
A star at fixed point $1$.
\end{bullets}

Example 2:
\begin{bullets}
\item Input:
\[
\begin{aligned}
4\\
2~1~4~3
\end{aligned}
\]
\item Output (one valid):
\[
\begin{aligned}
\text{YES}\\
1~2\\
3~1\\
4~2
\end{aligned}
\]
Use core edge $(1,2)$ (a $2$-cycle), attach cycle $(3,4)$ alternately to $1$ and $2$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $p\in S_n$ act on vertices $\{1,\ldots,n\}$. A simple graph $T=(V,E)$ with $V=[n]$ is a tree and is $p$-invariant iff for all unordered pairs $\{u,v\}$:
\begin{BreakableEquation*}
\{u,v\}\in E \iff \{p(u),p(v)\}\in E.
\end{BreakableEquation*}
We must decide existence and construct $E$ so that $T$ is connected, acyclic, has $n-1$ edges, and is $p$-invariant.}
\varmapStart
\var{p}{given permutation on $[n]$}
\var{\mathcal{C}}{cycle decomposition of $p$}
\var{F}{set of fixed points (cycles of length $1$)}
\var{C_2}{set of 2-cycles (transpositions)}
\var{E}{edge set to construct}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{$p$-invariance:}\quad \forall u<v:\; \mathbf{1}_{\{u,v\}\in E}=\mathbf{1}_{\{p(u),p(v)\}\in E}.\\
&\text{Tree constraints:}\quad |E|=n-1,\; \text{$(V,E)$ connected and acyclic}.
\end{aligned}
\]
}
\ASSUMPTIONS{Vertices are labeled $1$ to $n$. The input $p$ is a valid permutation.}
\INVARIANTS{
\begin{bullets}
\item Star at a fixed point is $p$-invariant: edges are exactly those incident to the fixed center, and are preserved by $p$.
\item With a $2$-cycle core $\{a,b\}$ and even cycles attached alternately to $a,b$, edge set is closed under $p$ and forms a tree.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the simplest sufficient condition: if $p$ has a fixed point $c$, connect every other vertex to $c$ to form a star.}
\ASSUMPTIONS{If there is no fixed point, declare impossibility (this is incomplete but fast).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan for an index $c$ with $p_c=c$.
\item If none found, output NO.
\item Else output YES and edges $(c,j)$ for all $j\ne c$.
\end{algosteps}
\COMPLEXITY{$T(n)=\mathcal{O}(n)$, $S(n)=\mathcal{O}(1)$ beyond output.}
\[
\begin{aligned}
T(n) &= \text{one scan for a fixed point} + \text{emit } (n-1)\text{ edges} \\
     &= \mathcal{O}(n).
\end{aligned}
\]
\CORRECTNESS{If $c$ is fixed, $p(c)=c$; edges are exactly all pairs $\{c,j\}$, which map to $\{c,p(j)\}$, still edges. Non-edges between non-center vertices map to non-edges.}
\EDGECASES{Handle $n=1$ (no edges), multiple fixed points (choose any).}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (baseline: star if a fixed point exists)
from typing import List, Tuple

def read_input() -> Tuple[int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = next(it)
    return n, p

def solve_case(n: int, p: List[int]) -> Tuple[bool, List[Tuple[int,int]]]:
    if n == 0:
        return False, []
    center = -1
    for i in range(1, n+1):
        if p[i] == i:
            center = i
            break
    if center == -1:
        return False, []
    edges: List[Tuple[int,int]] = []
    for j in range(1, n+1):
        if j != center:
            edges.append((center, j))
    return True, edges

def solve_all() -> None:
    n, p = read_input()
    ok, edges = solve_case(n, p)
    out_lines = []
    if not ok:
        out_lines.append("NO")
    else:
        out_lines.append("YES")
        for u, v in edges:
            out_lines.append(f"{u} {v}")
    import sys
    sys.stdout.write("\n".join(out_lines))

def _check_invariance(n: int, p: List[int], edges: List[Tuple[int,int]]) -> bool:
    adj = [[False]*(n+1) for _ in range(n+1)]
    for u, v in edges:
        adj[u][v] = adj[v][u] = True
    for u in range(1, n+1):
        for v in range(u+1, n+1):
            if adj[u][v] != adj[p[u]][p[v]]:
                return False
    return True

if __name__ == "__main__":
    # Baseline sanity tests
    ok, edges = solve_case(1, [0,1])
    assert ok and edges == []
    ok, edges = solve_case(3, [0,1,3,2])
    assert ok and _check_invariance(3, [0,1,3,2], edges)
    ok, edges = solve_case(3, [0,2,3,1])
    assert not ok  # baseline refuses when no fixed point
    # Uncomment next line to run on stdin:
    # solve_all()
\end{minted}
\VALIDATION{Checked invariance on a star; negative when no fixed point; trivial $n=1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use cycle decomposition. If there is no fixed point, we can still succeed when there exists a 2-cycle and all cycles have even length. Build a core edge from the 2-cycle and attach every other cycle alternately.}
\ASSUMPTIONS{Permutation decomposes into disjoint cycles; invariance must respect cycle shifts.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Decompose $p$ into cycles using a visited array.
\item If a fixed point exists, produce a star centered there.
\item Otherwise, find a 2-cycle $(a,b)$. If none, output NO. Ensure every cycle has even length; else NO.
\item Output $(a,b)$, and for each other cycle $v_0,\ldots,v_{L-1}$ (even $L$), output $(v_i,a)$ for even $i$ and $(v_i,b)$ for odd $i$.
\end{algosteps}
\COMPLEXITY{Linear time and space in $n$, dominated by cycle extraction and emitting $n-1$ edges.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(n) \text{ to decompose cycles } + \mathcal{O}(n) \text{ to emit edges},\\
S(n) &= \mathcal{O}(n) \text{ for visited and cycle storage}.
\end{aligned}
\]
\CORRECTNESS{Mapping advances indices along each cycle. Alternating attachments swap between $a$ and $b$, matching the image of $(v_i,a)$ to $(v_{i+1},b)$ and vice versa. The core $(a,b)$ maps to itself. This preserves adjacency exactly. Acyclicity holds since we attach each vertex by one edge to an existing tree.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple

def read_input() -> Tuple[int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = next(it)
    return n, p

def _cycle_decomp(n: int, p: List[int]) -> List[List[int]]:
    vis = [False]*(n+1)
    cycles: List[List[int]] = []
    for i in range(1, n+1):
        if not vis[i]:
            cur = []
            x = i
            while not vis[x]:
                vis[x] = True
                cur.append(x)
                x = p[x]
            cycles.append(cur)
    return cycles

def solve_case(n: int, p: List[int]) -> Tuple[bool, List[Tuple[int,int]]]:
    if n == 0:
        return False, []
    cycles = _cycle_decomp(n, p)
    fixed = -1
    for cyc in cycles:
        if len(cyc) == 1:
            fixed = cyc[0]
            break
    if fixed != -1:
        edges = [(fixed, j) for j in range(1, n+1) if j != fixed]
        return True, edges
    # No fixed point: need a 2-cycle and all cycles even
    core_a, core_b = -1, -1
    for cyc in cycles:
        if len(cyc) % 2 == 1:  # odd length cycle (>=3), impossible
            return False, []
    for cyc in cycles:
        if len(cyc) == 2 and core_a == -1:
            core_a, core_b = cyc[0], cyc[1]
            break
    if core_a == -1:
        return False, []
    edges: List[Tuple[int,int]] = [(core_a, core_b)]
    for cyc in cycles:
        if len(cyc) == 2 and set(cyc) == {core_a, core_b}:
            continue
        L = len(cyc)
        for i in range(L):
            if i % 2 == 0:
                edges.append((cyc[i], core_a))
            else:
                edges.append((cyc[i], core_b))
    return True, edges

def solve_all() -> None:
    n, p = read_input()
    ok, edges = solve_case(n, p)
    out = []
    if not ok:
        out.append("NO")
    else:
        out.append("YES")
        out.extend(f"{u} {v}" for u, v in edges)
    import sys
    sys.stdout.write("\n".join(out))

def _check_invariance(n: int, p: List[int], edges: List[Tuple[int,int]]) -> bool:
    adj = [[False]*(n+1) for _ in range(n+1)]
    for u, v in edges:
        adj[u][v] = adj[v][u] = True
    for u in range(1, n+1):
        for v in range(u+1, n+1):
            if adj[u][v] != adj[p[u]][p[v]]:
                return False
    return True

if __name__ == "__main__":
    # Valid with fixed point
    ok, edges = solve_case(4, [0,1,2,4,3])
    assert ok and _check_invariance(4, [0,1,2,4,3], edges)
    # Valid with 2-cycle core and all cycles even
    ok, edges = solve_case(6, [0,2,1,6,5,4,3])
    assert ok and _check_invariance(6, [0,2,1,6,5,4,3], edges)
    # Impossible: odd cycle and no fixed point
    ok, edges = solve_case(3, [0,2,3,1])
    assert not ok
    # Uncomment to run on stdin:
    # solve_all()
\end{minted}
\VALIDATION{Checked: fixed point star; even-only case with a 2-cycle core; rejection on a $3$-cycle.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Cycle-decomposition construction:
\begin{bullets}
\item If a fixed point exists, output a star centered at it.
\item Else require at least one 2-cycle and all cycles even; use one 2-cycle as core and attach others alternately.
\end{bullets}}
\ASSUMPTIONS{Permutation automorphisms of a tree are edge-bijections. Parity of cycle lengths governs alternation feasibility.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Decompose $p$ into cycles.
\item If any cycle has odd length other than $1$, return NO.
\item If there is a fixed point $c$, connect $(c,j)$ for all $j\ne c$.
\item Else choose any 2-cycle $(a,b)$, emit $(a,b)$.
\item For every remaining cycle $v_0,\ldots,v_{L-1}$ (even $L$), add $(v_i,a)$ for even $i$ and $(v_i,b)$ for odd $i$.
\end{algosteps}
\OPTIMALITY{The conditions are necessary and sufficient. Necessity: without a fixed point, centers must come in symmetric pairs; odd cycles cannot alternate consistently. Sufficiency: the construction yields a tree with exactly $n-1$ edges and is $p$-invariant by design.}
\COMPLEXITY{Linear:
\[
\begin{aligned}
T(n)&=\mathcal{O}(n),\quad S(n)=\mathcal{O}(n).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple

def read_input() -> Tuple[int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = next(it)
    return n, p

def _cycles(n: int, p: List[int]) -> List[List[int]]:
    vis = [False]*(n+1)
    res: List[List[int]] = []
    for i in range(1, n+1):
        if not vis[i]:
            cur = []
            x = i
            while not vis[x]:
                vis[x] = True
                cur.append(x)
                x = p[x]
            res.append(cur)
    return res

def solve_case(n: int, p: List[int]) -> Tuple[bool, List[Tuple[int,int]]]:
    if n == 0:
        return False, []
    cycles = _cycles(n, p)
    # If there's a fixed point, star works
    for cyc in cycles:
        if len(cyc) == 1:
            c = cyc[0]
            edges = [(c, j) for j in range(1, n+1) if j != c]
            return True, edges
    # No fixed point: all cycles must be even and at least one 2-cycle
    for cyc in cycles:
        if len(cyc) % 2 == 1:
            return False, []
    core = None
    for cyc in cycles:
        if len(cyc) == 2:
            core = (cyc[0], cyc[1])
            break
    if core is None:
        return False, []
    a, b = core
    edges: List[Tuple[int,int]] = [(a, b)]
    for cyc in cycles:
        if len(cyc) == 2 and set(cyc) == {a, b}:
            continue
        L = len(cyc)
        for i in range(L):
            if i % 2 == 0:
                edges.append((cyc[i], a))
            else:
                edges.append((cyc[i], b))
    return True, edges

def solve_all() -> None:
    n, p = read_input()
    ok, edges = solve_case(n, p)
    out_lines = []
    if not ok:
        out_lines.append("NO")
    else:
        out_lines.append("YES")
        out_lines.extend(f"{u} {v}" for (u, v) in edges)
    import sys
    sys.stdout.write("\n".join(out_lines))

def _check_tree(n: int, edges: List[Tuple[int,int]]) -> bool:
    if len(edges) != max(0, n-1):
        return False
    if n <= 1:
        return len(edges) == 0
    g = [[] for _ in range(n+1)]
    for u, v in edges:
        g[u].append(v); g[v].append(u)
    seen = [False]*(n+1)
    stack = [1]
    seen[1] = True
    cnt = 0
    while stack:
        u = stack.pop()
        cnt += 1
        for v in g[u]:
            if not seen[v]:
                seen[v] = True
                stack.append(v)
    return cnt == n

def _check_invariance(n: int, p: List[int], edges: List[Tuple[int,int]]) -> bool:
    adj = [[False]*(n+1) for _ in range(n+1)]
    for u, v in edges:
        adj[u][v] = adj[v][u] = True
    for u in range(1, n+1):
        for v in range(u+1, n+1):
            if adj[u][v] != adj[p[u]][p[v]]:
                return False
    return True

if __name__ == "__main__":
    # Exactly 3 asserts for validation
    ok, edges = solve_case(5, [0,1,2,3,4,5])
    assert ok and _check_tree(5, edges) and _check_invariance(5, [0,1,2,3,4,5], edges)
    ok, edges = solve_case(4, [0,2,1,4,3])
    assert ok and _check_tree(4, edges) and _check_invariance(4, [0,2,1,4,3], edges)
    ok, edges = solve_case(3, [0,2,3,1])
    assert not ok
    # Run on stdin if needed:
    # solve_all()
\end{minted}
\VALIDATION{Three asserts: identity permutation (star), even-only case with a 2-cycle core, and rejection for a $3$-cycle with no fixed point.}
\RESULT{Outputs either NO, or a valid invariant tree under $p$. Any ordering of edges and endpoints is accepted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks for invariance and tree properties on crafted permutations: identity, single transposition, multiple even cycles, and odd cycles.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach B and C on the same inputs; both implement the same logic and should match invariance checks. Baseline only for cases with fixed points.}
\LINE{EDGE-CASE GENERATOR}{Generate permutations with: all fixed points; exactly one fixed point; one 2-cycle; only even cycles; include a 3-cycle to force NO.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import itertools, random

def make_identity(n: int) -> List[int]:
    return [0] + list(range(1, n+1))

def make_two_cycle(n: int, a: int, b: int) -> List[int]:
    p = list(range(n+1))
    p[a], p[b] = b, a
    return p

def make_even_cycles(sizes: List[int]) -> List[int]:
    # sizes are even, sum = n
    n = sum(sizes)
    p = [0]*(n+1)
    cur = 1
    for L in sizes:
        cyc = list(range(cur, cur+L))
        for i in range(L):
            p[cyc[i]] = cyc[(i+1)%L]
        cur += L
    return p

def sample_tests():
    # Identity
    n = 6; p = make_identity(n)
    yield n, p
    # Single 2-cycle
    n = 5; p = make_two_cycle(n, 2, 5)
    yield n, p
    # Even cycles only
    p = make_even_cycles([2,4,6])
    yield len(p)-1, p
    # Force NO with a 3-cycle
    n = 5; p = [0,2,3,1,5,4]
    yield n, p

def run_reference():
    # Use final solver from Approach C
    def solve_case(n: int, p: List[int]) -> Tuple[bool, List[Tuple[int,int]]]:
        def _cycles(n: int, p: List[int]) -> List[List[int]]:
            vis = [False]*(n+1)
            res: List[List[int]] = []
            for i in range(1, n+1):
                if not vis[i]:
                    cur = []
                    x = i
                    while not vis[x]:
                        vis[x] = True
                        cur.append(x)
                        x = p[x]
                    res.append(cur)
            return res
        cycles = _cycles(n, p)
        for cyc in cycles:
            if len(cyc) == 1:
                c = cyc[0]
                edges = [(c, j) for j in range(1, n+1) if j != c]
                return True, edges
        for cyc in cycles:
            if len(cyc) % 2 == 1:
                return False, []
        core = None
        for cyc in cycles:
            if len(cyc) == 2:
                core = (cyc[0], cyc[1])
                break
        if core is None:
            return False, []
        a, b = core
        edges: List[Tuple[int,int]] = [(a, b)]
        for cyc in cycles:
            if len(cyc) == 2 and set(cyc) == {a, b}:
                continue
            for i, v in enumerate(cyc):
                edges.append((v, a) if i % 2 == 0 else (v, b))
        return True, edges

    def _check_tree(n: int, edges: List[Tuple[int,int]]) -> bool:
        if len(edges) != max(0, n-1):
            return False
        if n <= 1:
            return len(edges) == 0
        g = [[] for _ in range(n+1)]
        for u, v in edges:
            g[u].append(v); g[v].append(u)
        seen = [False]*(n+1)
        stack = [1]; seen[1] = True; cnt = 0
        while stack:
            u = stack.pop(); cnt += 1
            for v in g[u]:
                if not seen[v]:
                    seen[v] = True; stack.append(v)
        return cnt == n

    def _check_invariance(n: int, p: List[int], edges: List[Tuple[int,int]]) -> bool:
        adj = [[False]*(n+1) for _ in range(n+1)]
        for u, v in edges:
            adj[u][v] = adj[v][u] = True
        for u in range(1, n+1):
            for v in range(u+1, n+1):
                if adj[u][v] != adj[p[u]][p[v]]:
                    return False
        return True

    for n, p in sample_tests():
        ok, edges = solve_case(n, p)
        if ok:
            assert _check_tree(n, edges)
            assert _check_invariance(n, p, edges)
        else:
            # If not ok, ensure there is no fixed point and there exists an odd cycle
            has_fixed = any(p[i] == i for i in range(1, n+1))
            # quick odd detection
            vis = [False]*(n+1); odd = False
            for i in range(1, n+1):
                if not vis[i]:
                    cnt = 0; x = i
                    while not vis[x]:
                        vis[x] = True; cnt += 1; x = p[x]
                    if cnt % 2 == 1 and cnt != 1:
                        odd = True
            assert (not has_fixed) and (odd or all(p[i] != i for i in range(1, n+1)))

if __name__ == "__main__":
    run_reference()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
from typing import List, Tuple

def read_input() -> Tuple[int, List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(map(int, data))
    n = next(it)
    p = [0]*(n+1)
    for i in range(1, n+1):
        p[i] = next(it)
    return n, p

def _cycles(n: int, p: List[int]) -> List[List[int]]:
    vis = [False]*(n+1)
    res: List[List[int]] = []
    for i in range(1, n+1):
        if not vis[i]:
            cur = []
            x = i
            while not vis[x]:
                vis[x] = True
                cur.append(x)
                x = p[x]
            res.append(cur)
    return res

def solve_case(n: int, p: List[int]) -> Tuple[bool, List[Tuple[int,int]]]:
    if n == 0:
        return False, []
    cycles = _cycles(n, p)
    # Star if fixed point exists
    for cyc in cycles:
        if len(cyc) == 1:
            c = cyc[0]
            edges = [(c, j) for j in range(1, n+1) if j != c]
            return True, edges
    # Else require all cycles even and at least one 2-cycle
    for cyc in cycles:
        if len(cyc) % 2 == 1:
            return False, []
    core = None
    for cyc in cycles:
        if len(cyc) == 2:
            core = (cyc[0], cyc[1])
            break
    if core is None:
        return False, []
    a, b = core
    edges: List[Tuple[int,int]] = [(a, b)]
    for cyc in cycles:
        if len(cyc) == 2 and set(cyc) == {a, b}:
            continue
        for i, v in enumerate(cyc):
            edges.append((v, a) if i % 2 == 0 else (v, b))
    return True, edges

def solve_all() -> None:
    n, p = read_input()
    ok, edges = solve_case(n, p)
    out = []
    if not ok:
        out.append("NO")
    else:
        out.append("YES")
        out.extend(f"{u} {v}" for (u, v) in edges)
    import sys
    sys.stdout.write("\n".join(out))

def _check_tree(n: int, edges: List[Tuple[int,int]]) -> bool:
    if len(edges) != max(0, n-1):
        return False
    if n <= 1:
        return len(edges) == 0
    g = [[] for _ in range(n+1)]
    for u, v in edges:
        g[u].append(v); g[v].append(u)
    seen = [False]*(n+1)
    stack = [1]; seen[1] = True; cnt = 0
    while stack:
        u = stack.pop(); cnt += 1
        for v in g[u]:
            if not seen[v]:
                seen[v] = True; stack.append(v)
    return cnt == n

def _check_invariance(n: int, p: List[int], edges: List[Tuple[int,int]]) -> bool:
    adj = [[False]*(n+1) for _ in range(n+1)]
    for u, v in edges:
        adj[u][v] = adj[v][u] = True
    for u in range(1, n+1):
        for v in range(u+1, n+1):
            if adj[u][v] != adj[p[u]][p[v]]:
                return False
    return True

if __name__ == "__main__":
    # Minimal sanity asserts
    ok, edges = solve_case(2, [0,2,1])
    assert ok and _check_tree(2, edges) and _check_invariance(2, [0,2,1], edges)
    ok, edges = solve_case(5, [0,1,2,3,4,5])
    assert ok and _check_tree(5, edges) and _check_invariance(5, [0,1,2,3,4,5], edges)
    ok, edges = solve_case(3, [0,2,3,1])
    assert not ok
    # solve_all()  # Uncomment to integrate with CF I/O
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{A permutation $p$ is an automorphism of a tree iff either there is a fixed point (build a star), or there is a 2-cycle and all cycles are even (build a 2-center tree with alternating attachments).}
\WHY{Automorphism constraints frequently appear in symmetry problems. Recognizing cycle parity constraints is a standard trick in constructive CF problems.}
\CHECKLIST{
\begin{bullets}
\item Decompose $p$ into cycles.
\item If any odd cycle of length $\ge 3$, print NO.
\item If a fixed point exists, star at it.
\item Else find a 2-cycle; if none, NO.
\item Attach every other cycle alternately to the 2-cycle core.
\item Print exactly $n-1$ edges.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ (no edges; YES).
\item All fixed points (identity): any star is valid.
\item Exactly one 2-cycle and rest fixed points: core edge plus leaves attached alternately reduces to star split across two centers.
\item Multiple 2-cycles: pick one as core; attach others alternately.
\item Odd cycle present without fixed point: NO.
\item No fixed point and no 2-cycle: NO.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to skip the chosen core 2-cycle when attaching.
\item Attaching odd-length cycles alternately (breaks invariance).
\item Off-by-one in 1-indexed arrays.
\item Emitting not exactly $n-1$ edges.
\item Creating cycles by adding extra inter-leaf edges (must avoid).
\item Mishandling the case $n=1$.
\end{bullets}}
\FAILMODES{Brute-force graph search is infeasible for $n\le 10^5$. A naive star-only approach fails when there is no fixed point but an even-cycle construction exists. The optimal method survives by exact characterization.}
\ELI{Make the tree symmetric under $p$. If someone stays put under $p$, use them as the hub. Otherwise, you need a symmetric pair that swap under $p$, and every other cycle must have even size so you can alternate connections evenly between the pair.}
\NotePages{3}

\end{document}