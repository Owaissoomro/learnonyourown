% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — k-LCM (hard version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1497/C2}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{It is the hard version of the problem. The only difference is that in this version $3 \le k \le n$.

You are given a positive integer $n$. Find $k$ positive integers $a_1, a_2, \ldots, a_k$, such that:
\begin{bullets}
\item $a_1 + a_2 + \ldots + a_k = n$
\item $\mathrm{LCM}(a_1, a_2, \ldots, a_k) \le \tfrac{n}{2}$
\end{bullets}
Here $\mathrm{LCM}$ is the least common multiple of numbers $a_1, a_2, \ldots, a_k$.

We can show that for given constraints the answer always exists.

Input: The first line contains a single integer $t$ $(1 \le t \le 10^4)$ — the number of test cases.

The only line of each test case contains two integers $n$, $k$ ($3 \le n \le 10^9$, $3 \le k \le n$).

It is guaranteed that the sum of $k$ over all test cases does not exceed $10^5$.

Output: For each test case print $k$ positive integers $a_1, a_2, \ldots, a_k$, for which all conditions are satisfied.}
\BREAKDOWN{We must partition $n$ into $k$ positive integers whose least common multiple is at most $\tfrac{n}{2}$. A standard trick is to output $k-3$ ones and reduce the problem to constructing an admissible triple summing to the remaining value, which can be handled by simple parity cases.}
\ELI{Peel off $k-3$ ones, then split the leftover into three numbers chosen so their least common multiple stays small by matching their parity.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each case, integers $n$ and $k$ with $3 \le k \le n \le 10^9$. The number of test cases $t$ satisfies $1 \le t \le 10^4$, and the total sum of all $k$ does not exceed $10^5$.}
\OUTPUTS{For each test case, print $k$ positive integers whose sum is $n$ and whose least common multiple is at most $\tfrac{n}{2}$. Any valid partition is accepted.}
\SAMPLES{Example 1:
\begin{bullets}
\item Input:
\[
\begin{aligned}
t&=1\\
n&=8,\;k=3
\end{aligned}
\]
One valid output: $4\ 2\ 2$.
\end{bullets}
Example 2:
\begin{bullets}
\item Input:
\[
\begin{aligned}
t&=1\\
n&=10,\;k=5
\end{aligned}
\]
One valid output: $1\ 1\ 2\ 3\ 3$ (sum $=10$, and $\mathrm{LCM}(1,1,2,3,3)=6 \le 5$ is false, so choose $1\ 1\ 4\ 2\ 2$ instead; sum $=10$, $\mathrm{LCM}=4 \le 5$).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given integers $n \ge 3$ and $k \in \{3,\ldots,n\}$, find a vector $\mathbf{a}=(a_1,\ldots,a_k)\in \mathbb{Z}_{>0}^k$ such that $\sum_{i=1}^k a_i = n$ and $\mathrm{LCM}(a_1,\ldots,a_k) \le \tfrac{n}{2}$.}
\varmapStart
\var{n}{total sum to partition}
\var{k}{number of parts required}
\var{a_i}{the $i$-th positive part}
\var{m}{the reduced sum after emitting $k-3$ ones, i.e., $m=n-(k-3)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\sum_{i=1}^k a_i = n,\quad a_i \in \mathbb{Z}_{>0},\quad \mathrm{LCM}(a_1,\ldots,a_k) \le \frac{n}{2}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{We may set $a_1=\cdots=a_{k-3}=1$ without changing the $\mathrm{LCM}$, then solve a $k=3$ subproblem on the remaining sum $m=n-(k-3)\ge 3$.}
\INVARIANTS{
\begin{bullets}
\item Adding parts equal to $1$ does not change the $\mathrm{LCM}$.
\item The triple construction maintains $a_{k-2}+a_{k-1}+a_k=m$ while ensuring $\mathrm{LCM}(a_{k-2},a_{k-1},a_k)\le \tfrac{m}{2}\le \tfrac{n}{2}$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the parity-based $k=3$ construction after outputting $k-3$ ones. This leverages that $\mathrm{LCM}$ ignores ones.}
\ASSUMPTIONS{We only need a valid construction, not optimization. We rely on $m=n-(k-3)\ge 3$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Output $k-3$ copies of $1$.
\item Let $m=n-(k-3)$. If $m$ is odd, output $(1,\tfrac{m-1}{2},\tfrac{m-1}{2})$.
\item Else if $m \bmod 4=0$, output $(\tfrac{m}{2},\tfrac{m}{4},\tfrac{m}{4})$. Otherwise output $(2,\tfrac{m-2}{2},\tfrac{m-2}{2})$.
\end{algosteps}
\COMPLEXITY{Time $T(n)$ is linear in $k$ to print numbers; space is $O(1)$ beyond output.}
\[
\begin{aligned}
T(n,k) &= O(k),\quad S(n,k)=O(1).
\end{aligned}
\]
\CORRECTNESS{Each case preserves the sum and yields pairwise structure guaranteeing the $\mathrm{LCM}$ is at most half of $m$ (hence at most half of $n$). Appending ones keeps the $\mathrm{LCM}$ unchanged.}
\EDGECASES{Smallest $m=3$ yields $(1,1,1)$. For $m=6$, divisible by $4$ is false but even, so $(2,2,2)$. For $m=8$, use $(4,2,2)$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 1497C2 — k-LCM (hard version): Baseline implementation
from typing import List, Tuple
import sys, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        cases.append((n, k))
    return cases

def split_three(m: int) -> List[int]:
    # Returns a triple summing to m with LCM <= m/2
    if m % 2 == 1:
        return [1, m // 2, m // 2]
    if m % 4 == 0:
        return [m // 2, m // 4, m // 4]
    else:
        return [2, (m - 2) // 2, (m - 2) // 2]

def solve_case(n: int, k: int) -> List[int]:
    res = [1] * (k - 3)
    m = n - (k - 3)
    res += split_three(m)
    return res

def solve_all(cases: List[Tuple[int, int]]) -> List[str]:
    out = []
    for n, k in cases:
        ans = solve_case(n, k)
        out.append(" ".join(map(str, ans)))
    return out

def _lcm(a: int, b: int) -> int:
    return a // math.gcd(a, b) * b

def _lcm_list(arr: List[int]) -> int:
    cur = 1
    for x in arr:
        cur = _lcm(cur, x)
    return cur

def main():
    cases = read_input()
    if cases is None:
        # Tiny self-checks
        ans = solve_case(8, 3)
        assert sum(ans) == 8 and _lcm_list(ans) <= 8 // 2
        ans = solve_case(10, 5)
        assert sum(ans) == 10 and _lcm_list(ans) <= 10 // 2
        print("OK")
        return
    out = solve_all(cases)
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks: $(n,k)=(8,3)\Rightarrow 4\ 2\ 2$, $(n,k)=(10,5)\Rightarrow 1\ 1\ 2\ 3\ 3$ is invalid so code outputs a valid $(1,1,4,2,2)$. Random quick checks can be added to verify sum and $\mathrm{LCM}$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Branching and Helpers}
\WHICHFORMULA{Refactor into helper functions and avoid recomputation; identical asymptotics, clearer structure for proofs and testing.}
\ASSUMPTIONS{Same construction; ensure integer arithmetic and avoid overflow by ordering operations.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute the triple by parity logic in a dedicated helper.
\item Build the full answer by concatenating $k-3$ ones with the triple.
\item Validate in debug: sum matches and computed $\mathrm{LCM}$ is within bound.
\end{algosteps}
\COMPLEXITY{Same as baseline; linear output time.}
\[
\begin{aligned}
T(n,k) &= O(k).
\end{aligned}
\]
\CORRECTNESS{Functional decomposition does not change logic; the same invariants apply.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF 1497C2 — k-LCM (hard version): Improved structure with helpers
from typing import List, Tuple
import sys, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        cases.append((n, k))
    return cases

def triple_for_sum(m: int) -> List[int]:
    if m % 2 == 1:
        return [1, m // 2, m // 2]
    if m % 4 == 0:
        return [m // 2, m // 4, m // 4]
    return [2, (m - 2) // 2, (m - 2) // 2]

def solve_case(n: int, k: int) -> List[int]:
    ones = [1] * (k - 3)
    return ones + triple_for_sum(n - (k - 3))

def solve_all(cases: List[Tuple[int, int]]) -> List[str]:
    return [" ".join(map(str, solve_case(n, k))) for n, k in cases]

def _lcm(a: int, b: int) -> int:
    return a // math.gcd(a, b) * b

def _lcm_list(arr: List[int]) -> int:
    cur = 1
    for x in arr:
        cur = _lcm(cur, x)
    return cur

def main():
    cases = read_input()
    if cases is None:
        # Checks on edge inputs
        ans = solve_case(3, 3)
        assert ans == [1, 1, 1]
        ans = solve_case(6, 4)
        assert sum(ans) == 6 and _lcm_list(ans) <= 6 // 2
        print("OK")
        return
    print("\n".join(solve_all(cases)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge checks: $(3,3)\mapsto 1\ 1\ 1$; $(6,4)\mapsto 1\ 2\ 2\ 1$ or similar, always meeting the bound.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Construction via Parity Splitting}
\WHICHFORMULA{Emit $k-3$ ones, then use:
\[
m = n-(k-3),\quad
\begin{cases}
(1,\frac{m-1}{2},\frac{m-1}{2}), & m\ \text{odd},\\[4pt]
(\frac{m}{2},\frac{m}{4},\frac{m}{4}), & m \equiv 0 \pmod{4},\\[4pt]
(2,\frac{m-2}{2},\frac{m-2}{2}), & m \equiv 2 \pmod{4}.
\end{cases}
\]}
\ASSUMPTIONS{All divisions are integers; $m\ge 3$ since $k\le n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $m=n-(k-3)$.
\item Choose the triple as per the parity of $m$.
\item Output $k-3$ ones followed by the triple.
\end{algosteps}
\OPTIMALITY{This is the standard constructive solution. The $\mathrm{LCM}$ of the triple is at most $\tfrac{m}{2}$ in all cases; adding ones does not increase $\mathrm{LCM}$. Any solution cannot beat $O(k)$ output time.}
\COMPLEXITY{Linear in the number of parts.}
\[
\begin{aligned}
T(n,k) &= \Theta(k),\quad S(n,k)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF 1497C2 — k-LCM (hard version): Final reference submission
from typing import List, Tuple
import sys, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        cases.append((n, k))
    return cases

def split_three(m: int) -> List[int]:
    if m % 2 == 1:
        return [1, m // 2, m // 2]
    if m % 4 == 0:
        return [m // 2, m // 4, m // 4]
    return [2, (m - 2) // 2, (m - 2) // 2]

def solve_case(n: int, k: int) -> List[int]:
    cnt_ones = k - 3
    m = n - cnt_ones
    ans = [1] * cnt_ones
    ans.extend(split_three(m))
    return ans

def solve_all(cases: List[Tuple[int, int]]) -> List[str]:
    return [" ".join(map(str, solve_case(n, k))) for n, k in cases]

# --- tests (run only when no stdin) ---
def _lcm(a: int, b: int) -> int:
    return a // math.gcd(a, b) * b

def _lcm_list(v: List[int]) -> int:
    res = 1
    for x in v:
        res = _lcm(res, x)
    return res

def main():
    cases = read_input()
    if cases is None:
        # Exactly 3 asserts
        a = solve_case(9, 3); assert sum(a) == 9 and _lcm_list(a) <= 9 // 2
        b = solve_case(8, 6); assert sum(b) == 8 and _lcm_list(b) <= 8 // 2
        c = solve_case(10, 5); assert sum(c) == 10 and _lcm_list(c) <= 10 // 2
        print("OK")
        return
    print("\n".join(solve_all(cases)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts:
\begin{bullets}
\item $(n,k)=(9,3)$ triple case.
\item $(n,k)=(8,6)$ with many ones.
\item $(n,k)=(10,5)$ mixed parity.
\end{bullets}}
\RESULT{For each test case, prints any valid $k$-tuple of positive integers summing to $n$ with $\mathrm{LCM}$ at most $\tfrac{n}{2}$. No special tie-breaking is needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-check the construction on representative parity classes and boundary cases. Verify sum and $\mathrm{LCM}$ constraints.}
\LINE{CROSS-CHECKS}{Compare outputs across Approach A, B, and C for randomly chosen small $(n,k)$; they should all satisfy constraints, though not necessarily identical.}
\LINE{EDGE-CASE GENERATOR}{Generate small $n$ and extreme $k$ (e.g., $k=3$ and $k=n$) to stress the reduction and triple construction.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random, math

def gen_cases(limit: int = 50):
    cases = []
    for n in range(3, 21):
        for k in (3, 4, n // 2 if n // 2 >= 3 else 3, n):
            if 3 <= k <= n:
                cases.append((n, k))
    # add some deterministic "random-like" cases
    seed = 1234567
    for i in range(limit):
        seed = (1103515245 * seed + 12345) & 0x7fffffff
        n = 3 + (seed % 50)
        seed = (1103515245 * seed + 12345) & 0x7fffffff
        k = 3 + (seed % (n - 2))
        cases.append((n, k))
    return cases

def lcm(a, b): return a // math.gcd(a, b) * b
def lcm_list(arr):
    cur = 1
    for x in arr: cur = lcm(cur, x)
    return cur

# Reference solver (same as Approach C)
def split_three(m):
    if m % 2 == 1: return [1, m // 2, m // 2]
    if m % 4 == 0: return [m // 2, m // 4, m // 4]
    return [2, (m - 2) // 2, (m - 2) // 2]

def solve_case(n, k):
    return [1] * (k - 3) + split_three(n - (k - 3))

def test_all():
    for n, k in gen_cases():
        ans = solve_case(n, k)
        assert sum(ans) == n
        assert all(x > 0 for x in ans)
        assert lcm_list(ans) <= n // 2
    print("All tests passed.")

if __name__ == "__main__":
    test_all()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
from typing import List, Tuple
import sys, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        cases.append((n, k))
    return cases

def split_three(m: int) -> List[int]:
    if m % 2 == 1:
        return [1, m // 2, m // 2]
    if m % 4 == 0:
        return [m // 2, m // 4, m // 4]
    return [2, (m - 2) // 2, (m - 2) // 2]

def solve_case(n: int, k: int) -> List[int]:
    res = [1] * (k - 3)
    m = n - (k - 3)
    res += split_three(m)
    return res

def solve_all(cases: List[Tuple[int, int]]) -> List[str]:
    return [" ".join(map(str, solve_case(n, k))) for n, k in cases]

def _lcm(a: int, b: int) -> int:
    return a // math.gcd(a, b) * b

def _lcm_list(arr: List[int]) -> int:
    cur = 1
    for x in arr:
        cur = _lcm(cur, x)
    return cur

def main():
    cases = read_input()
    if cases is None:
        # Sanity asserts
        a = solve_case(3, 3); assert a == [1, 1, 1]
        b = solve_case(8, 3); assert sum(b) == 8 and _lcm_list(b) <= 4
        c = solve_case(100, 100); assert sum(c) == 100 and _lcm_list(c) <= 50
        print("OK")
        return
    print("\n".join(solve_all(cases)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to a $k=3$ construction by printing $k-3$ ones, then split the remainder by parity to keep the $\mathrm{LCM}$ small.}
\WHY{This constructive trick appears frequently in CF problems requiring partitions with bounded $\mathrm{LCM}$ or $\mathrm{GCD}$.}
\CHECKLIST{
\begin{bullets}
\item Compute $m=n-(k-3)$ correctly.
\item Choose the right triple based on $m \bmod 2$ and $m \bmod 4$.
\item Confirm integrality of divisions.
\item Ensure all outputs are positive and sum to $n$.
\item Validate $\mathrm{LCM}\le \tfrac{n}{2}$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=3, k=3 \Rightarrow (1,1,1)$.
\item $n=4, k=3 \Rightarrow (2,1,1)$ or $(2,1,1)$ via rules.
\item $m=6$ even but not divisible by $4 \Rightarrow (2,2,2)$.
\item $m=8$ divisible by $4 \Rightarrow (4,2,2)$.
\item $k=n$ many ones: $m=3$.
\item Large $n$ within $10^9$ still fits 64-bit; Python is arbitrary precision.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one when computing $m=n-(k-3)$.
\item Forgetting that ones do not change $\mathrm{LCM}$.
\item Using floating division instead of integer division.
\item Mishandling the $m \equiv 2 \pmod{4}$ branch.
\item Printing fewer or more than $k$ numbers.
\item Not preserving positivity of all parts.
\end{bullets}}
\FAILMODES{Brute-force search over partitions is infeasible. Ad-hoc splits can violate the $\mathrm{LCM}$ bound; the parity-based triple avoids this.}
\ELI{Print $k-3$ ones. For the last three numbers, pick them so two are equal and the third matches parity: either $(1,x,x)$, $(2,x,x)$, or $(\tfrac{m}{2},\tfrac{m}{4},\tfrac{m}{4})$. This keeps their least common multiple small.}
\NotePages{3}

\end{document}