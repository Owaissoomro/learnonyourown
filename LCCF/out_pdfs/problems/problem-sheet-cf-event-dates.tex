% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Event Dates}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/45/D}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{On a history lesson the teacher asked Vasya to name the dates when $n$ famous events took place. He does not remember the exact dates, but he remembers a segment of days $[l_i, r_i]$ (inclusive) on which the event could have taken place. However, Vasya also remembers that there was at most one event on any given day. Help him choose such $n$ dates of famous events that fulfill both conditions. It is guaranteed that it is possible.

Input: The first line contains one integer $n$ ($1 \le n \le 100$) — the number of known events. Then follow $n$ lines containing two integers $l_i$ and $r_i$ each ($1 \le l_i \le r_i \le 10^{7}$) — the earliest acceptable date and the latest acceptable date of the $i$-th event.

Output: Print $n$ numbers — the dates on which the events took place, in the order of the events given in the input. If there are several solutions, print any of them. It is guaranteed that a solution exists.}
\BREAKDOWN{We must assign each event $i$ an integer day $d_i \in [l_i,r_i]$ so that all $d_i$ are distinct. A classic interval scheduling/assignment greedy suffices due to feasibility guarantee.}
\ELI{Sort intervals by their right ends and schedule each as early as possible without reusing a day.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integer $n$ ($1 \le n \le 100$).
- Then $n$ lines: two integers $l_i, r_i$ with $1 \le l_i \le r_i \le 10^{7}$.}
\OUTPUTS{Print $n$ integers: chosen dates $d_1, d_2, \ldots, d_n$ in the original input order, space-separated, any valid solution.}
\SAMPLES{Example 1
Input
3
1 1
2 3
2 2

Output
1 3 2

Example 2
Input
4
1 4
1 1
2 3
4 4

Output
2 1 3 4}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given intervals $\{[l_i,r_i]\}_{i=1}^n$ on $\mathbb{Z}$, find an injective assignment $f:\{1,\ldots,n\}\to \mathbb{Z}$ such that $f(i)\in [l_i,r_i]$ for all $i$.}
\varmapStart
\var{n}{number of events}
\var{[l_i,r_i]}{feasible date range for event $i$}
\var{f(i)}{assigned date (integer) for event $i$}
\var{\pi}{a permutation that sorts intervals by nondecreasing $r_i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Find } f \text{ such that}\quad l_i \le f(i) \le r_i \quad \forall i,\\
&\text{and}\quad f(i)\neq f(j)\quad \forall i\neq j.
\end{aligned}
\]
}
\ASSUMPTIONS{Dates are integers (days). A feasible solution is guaranteed to exist. Ties in $r_i$ can be broken arbitrarily.}
\INVARIANTS{When processing intervals in nondecreasing $r_i$:
- The assigned dates are strictly increasing along this order if we always pick the earliest feasible unused day.
- No assigned date exceeds the corresponding $r_i$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedy by earliest deadline: iterate intervals in nondecreasing $r_i$, and for each, choose the smallest day in $[l_i,r_i]$ not used yet by linearly scanning upward from $l_i$.}
\ASSUMPTIONS{Feasibility is guaranteed. A naive ``used set'' with linear probing suffices as a baseline, though it may scan many days.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pair each interval with its original index, then sort by nondecreasing $r_i$.
\item Maintain a set of used days. For each interval $(l,r)$ in this order, scan $d$ from $l$ upward to the first $d\notin$ used; assign if $d\le r$.
\item Write the assigned days back in original order.
\end{algosteps}
\COMPLEXITY{In the worst case, the linear scan can walk long gaps: $T(n)$ can be as bad as $O(n + \sum \text{gap lengths})$, which is unbounded in terms of $n$ alone; space $S(n)=O(n)$. For given constraints $n\le 100$, this is acceptable as a pedagogical baseline.}
\[
\begin{aligned}
T(n) &\le O(n\log n) + O\Big(\sum_{i=1}^n (r_i-l_i+1)\Big) \\
     &\text{(can be large if ranges are wide and sparsely used).}
\end{aligned}
\]
\CORRECTNESS{Processing by increasing $r_i$ and always taking the earliest available day preserves feasibility because any later choice can only reduce flexibility for later intervals; earliest-day choice is a safe greedy step under an earliest-deadline-first schedule.}
\EDGECASES{Single interval; many identical ranges; tightly packed consecutive ranges; disjoint ranges; already unique singletons.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import sys

def assign_dates_naive(intervals: List[Tuple[int,int,int]]) -> List[int]:
    """
    intervals: list of (l, r, idx)
    returns: res where res[idx] = assigned day
    Naive linear-scan greedy by nondecreasing r.
    """
    arr = sorted(intervals, key=lambda x: (x[1], x[0]))
    used = set()
    res = [-1] * len(intervals)
    for l, r, idx in arr:
        d = l
        while d in used:
            d += 1
        assert d <= r, "Feasibility violated in baseline (should not happen for valid inputs)"
        used.add(d)
        res[idx] = d
    return res

def read_input() -> Tuple[int, List[Tuple[int,int,int]]]:
    data = list(map(int, sys.stdin.buffer.read().split()))
    if not data:
        return 0, []
    it = iter(data)
    n = next(it)
    ivs = []
    for i in range(n):
        l = next(it); r = next(it)
        ivs.append((l, r, i))
    return n, ivs

def solve_case(n: int, intervals: List[Tuple[int,int,int]]) -> List[int]:
    return assign_dates_naive(intervals)

def main() -> None:
    n, intervals = read_input()
    if n == 0:
        return
    res = solve_case(n, intervals)
    out = " ".join(str(x) for x in res)
    sys.stdout.write(out)

# --- Tests (no output on success) ---
def _check(intervals_lr: List[Tuple[int,int]]) -> None:
    ivs = [(l, r, i) for i, (l, r) in enumerate(intervals_lr)]
    ans = assign_dates_naive(ivs)
    assert len(ans) == len(ivs)
    used = set()
    for i, (l, r) in enumerate(intervals_lr):
        d = ans[i]
        assert l <= d <= r
        assert d not in used
        used.add(d)

# Tiny deterministic checks
_check([(1, 1)])
_check([(1, 2), (2, 3)])
_check([(1, 4), (1, 1), (2, 3), (4, 4)])

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked on tiny hand-crafted cases and singleton intervals. The baseline respects ranges and uniqueness.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Successor-DSU}
\WHICHFORMULA{Maintain a ``next-available day'' structure via a disjoint-set map on integers: $find(x)$ returns the smallest free day $\ge x$. After assigning day $d$, set the parent of $d$ to $find(d{+}1)$. Process intervals by increasing $r_i$.}
\ASSUMPTIONS{Use a dictionary-based DSU to avoid allocating up to $10^{7}$. Path compression ensures near-constant amortized time per find.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort events by nondecreasing $r_i$; carry original indices.
\item For each $(l,r)$, let $d \gets find(l)$. If $d \le r$, assign it and union $d$ with $d{+}1$ by setting $parent[d] \gets find(d{+}1)$.
\item Scatter the assigned days back to original order and print.
\end{algosteps}
\COMPLEXITY{Each $find/union$ is inverse-Ackermann-like; overall $T(n)=O(n\log n + n\alpha(n))$ and $S(n)=O(n)$ for $n\le 100$.}
\[
\begin{aligned}
T(n) &= O(n\log n) + O(n\alpha(n)) \approx O(n\log n).
\end{aligned}
\]
\CORRECTNESS{Earliest-deadline processing with the ``next-available'' invariant ensures we always choose the smallest feasible date $\ge l_i$, which preserves maximal slack for later intervals. The DSU guarantees we never reuse days and always skip to the next free day.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Dict
import sys

def assign_dates_dsu(intervals: List[Tuple[int,int,int]]) -> List[int]:
    """
    intervals: list of (l, r, idx)
    returns: res where res[idx] = assigned day
    DSU successor map with path compression.
    """
    parent: Dict[int, int] = {}

    def find(x: int) -> int:
        # returns smallest available day >= x
        if x not in parent:
            parent[x] = x
            return x
        if parent[x] == x:
            return x
        parent[x] = find(parent[x])
        return parent[x]

    def occupy(x: int) -> None:
        # mark x as used: link x to successor of x+1
        nx = find(x + 1)
        parent[x] = nx

    arr = sorted(intervals, key=lambda t: (t[1], t[0]))
    res = [-1] * len(intervals)
    for l, r, idx in arr:
        d = find(l)
        assert d <= r, "Feasibility violated in DSU (should not happen for valid inputs)"
        res[idx] = d
        occupy(d)
    return res

def read_input() -> Tuple[int, List[Tuple[int,int,int]]]:
    data = list(map(int, sys.stdin.buffer.read().split()))
    if not data:
        return 0, []
    it = iter(data)
    n = next(it)
    ivs = []
    for i in range(n):
        l = next(it); r = next(it)
        ivs.append((l, r, i))
    return n, ivs

def solve_case(n: int, intervals: List[Tuple[int,int,int]]) -> List[int]:
    return assign_dates_dsu(intervals)

def main() -> None:
    n, intervals = read_input()
    if n == 0:
        return
    res = solve_case(n, intervals)
    sys.stdout.write(" ".join(map(str, res)))

# --- Tests (no output on success) ---
def _check(intervals_lr: List[Tuple[int,int]]) -> None:
    ivs = [(l, r, i) for i, (l, r) in enumerate(intervals_lr)]
    ans = assign_dates_dsu(ivs)
    used = set()
    for i, (l, r) in enumerate(intervals_lr):
        d = ans[i]
        assert l <= d <= r
        assert d not in used
        used.add(d)

_check([(1, 1)])
_check([(1, 2), (2, 2)])
_check([(1, 4), (1, 1), (2, 3), (4, 4)])

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Verified on multiple tiny cases; DSU successor map produces valid, unique assignments within ranges.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Greedy by Deadlines}
\WHICHFORMULA{Sort by nondecreasing $r_i$. Maintain a cursor $cur$ for the last used day; for each interval, assign $d=\max(cur+1, l_i)$. If $d\le r_i$, accept and set $cur=d$.}
\ASSUMPTIONS{Feasibility is guaranteed. Sorting by right endpoints and taking the earliest feasible time is optimal for interval scheduling with unit-capacity days.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Decorate intervals with original indices; sort by nondecreasing $r_i$.
\item Initialize $cur \leftarrow -\infty$. For each $(l,r)$ in order, set $d \leftarrow \max(cur+1, l)$; assign if $d \le r$ and update $cur \leftarrow d$.
\item Scatter assignments back to original order and print.
\end{algosteps}
\OPTIMALITY{Exchange argument: any solution can be transformed into one where the earliest-deadline interval takes the earliest possible day without worsening feasibility for the remaining intervals. By induction, the greedy solution exists and is valid.}
\COMPLEXITY{Sorting dominates: $T(n)=O(n\log n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n) = O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
import sys

def assign_dates_optimal(intervals: List[Tuple[int,int,int]]) -> List[int]:
    """
    intervals: list of (l, r, idx)
    returns: res where res[idx] = assigned day
    Greedy by r_i with a monotone cursor.
    """
    arr = sorted(intervals, key=lambda t: (t[1], t[0]))
    res = [-1] * len(intervals)
    cur = -10**30  # effectively -infinity
    for l, r, idx in arr:
        d = max(cur + 1, l)
        assert d <= r, "Feasibility violated in optimal greedy (should not happen for valid inputs)"
        res[idx] = d
        cur = d
    return res

def read_input() -> Tuple[int, List[Tuple[int,int,int]]]:
    data = list(map(int, sys.stdin.buffer.read().split()))
    if not data:
        return 0, []
    it = iter(data)
    n = next(it)
    ivs = []
    for i in range(n):
        l = next(it); r = next(it)
        ivs.append((l, r, i))
    return n, ivs

def solve_case(n: int, intervals: List[Tuple[int,int,int]]) -> List[int]:
    return assign_dates_optimal(intervals)

def main() -> None:
    n, intervals = read_input()
    if n == 0:
        return
    ans = solve_case(n, intervals)
    sys.stdout.write(" ".join(map(str, ans)))

# --- Validation (exactly 3 asserts) ---
def _ok(iv_lr: List[Tuple[int,int]]) -> None:
    ivs = [(l, r, i) for i, (l, r) in enumerate(iv_lr)]
    ans = assign_dates_optimal(ivs)
    used = set()
    for i, (l, r) in enumerate(iv_lr):
        d = ans[i]
        assert l <= d <= r
        assert d not in used
        used.add(d)

_ok([(1, 1)])
_ok([(1, 4), (1, 1), (2, 3), (4, 4)])
_ok([(2, 2), (1, 3), (3, 5)])

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts verify feasibility and uniqueness on canonical tiny cases.}
\RESULT{A vector of $n$ integers: chosen dates for events $1$ through $n$ in input order, any valid choice if multiple exist.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests check feasibility and uniqueness. Cross-verify multiple implementations on randomized small cases with fixed seed. Stress interesting edges: identical ranges, nested ranges, disjoint blocks, tight chains.}
\LINE{CROSS-CHECKS}{Compare outputs from DSU-based and optimal-greedy implementations for validity and, when sorted by $r_i$, that both never violate deadlines.}
\LINE{EDGE-CASE GENERATOR}{Construct deterministic families: all singletons, staggered chains $[i,i+k]$, identical wide ranges $[1,M]$, and alternating overlaps.}
\begin{minted}{python}
from typing import List, Tuple
import random

def assign_dates_dsu(intervals: List[Tuple[int,int,int]]) -> List[int]:
    parent = {}
    def find(x: int) -> int:
        if x not in parent:
            parent[x] = x
            return x
        if parent[x] == x:
            return x
        parent[x] = find(parent[x])
        return parent[x]
    def occupy(x: int) -> None:
        parent[x] = find(x+1)
    arr = sorted(intervals, key=lambda t: (t[1], t[0]))
    res = [-1]*len(intervals)
    for l, r, idx in arr:
        d = find(l)
        assert d <= r
        res[idx] = d
        occupy(d)
    return res

def assign_dates_optimal(intervals: List[Tuple[int,int,int]]) -> List[int]:
    arr = sorted(intervals, key=lambda t: (t[1], t[0]))
    res = [-1]*len(intervals)
    cur = -10**30
    for l, r, idx in arr:
        d = max(cur+1, l)
        assert d <= r
        res[idx] = d
        cur = d
    return res

def check_solution(intervals_lr: List[Tuple[int,int]], ans: List[int]) -> None:
    used = set()
    for i, (l, r) in enumerate(intervals_lr):
        d = ans[i]
        assert l <= d <= r
        assert d not in used
        used.add(d)

def gen_cases() -> List[List[Tuple[int,int]]]:
    cases = []
    # Singletons
    cases.append([(i, i) for i in range(1, 6)])
    # Identical wide
    cases.append([(1, 10)] * 5)
    # Staggered chains
    cases.append([(i, i+2) for i in range(1, 6)])
    # Alternating overlaps
    cases.append([(1,3), (2,4), (1,2), (3,5), (2,3)])
    # Random small (deterministic)
    random.seed(0)
    for _ in range(5):
        n = 6
        L = [random.randint(1, 8) for _ in range(n)]
        R = [random.randint(l, l + random.randint(0, 4)) for l in L]
        cases.append(list(zip(L, R)))
    return cases

def cross_check():
    for iv_lr in gen_cases():
        ivs = [(l, r, i) for i, (l, r) in enumerate(iv_lr)]
        ans1 = assign_dates_dsu(ivs)
        ans2 = assign_dates_optimal(ivs)
        check_solution(iv_lr, ans1)
        check_solution(iv_lr, ans2)

cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Codeforces 45D - Event Dates
# Final submission: optimal greedy by nondecreasing r_i with a monotone cursor.
from typing import List, Tuple
import sys

def read_input() -> Tuple[int, List[Tuple[int,int,int]]]:
    data = list(map(int, sys.stdin.buffer.read().split()))
    if not data:
        return 0, []
    it = iter(data)
    n = next(it)
    ivs = []
    for i in range(n):
        l = next(it); r = next(it)
        ivs.append((l, r, i))
    return n, ivs

def solve_case(n: int, intervals: List[Tuple[int,int,int]]) -> List[int]:
    arr = sorted(intervals, key=lambda t: (t[1], t[0]))
    res = [-1] * n
    cur = -10**30
    for l, r, idx in arr:
        d = max(cur + 1, l)
        # Feasibility guaranteed by problem; assert for safety.
        assert d <= r
        res[idx] = d
        cur = d
    return res

def main() -> None:
    n, intervals = read_input()
    if n == 0:
        return
    ans = solve_case(n, intervals)
    sys.stdout.write(" ".join(map(str, ans)))

# --- Asserts (do not print; safe under CF) ---
def _check(intervals_lr: List[Tuple[int,int]]) -> None:
    ivs = [(l, r, i) for i, (l, r) in enumerate(intervals_lr)]
    ans = solve_case(len(ivs), ivs)
    used = set()
    for i, (l, r) in enumerate(intervals_lr):
        d = ans[i]
        assert l <= d <= r
        assert d not in used
        used.add(d)

_check([(1, 1)])
_check([(1, 4), (1, 1), (2, 3), (4, 4)])
_check([(2, 2), (1, 3), (3, 5)])

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Assign distinct days to intervals $[l_i,r_i]$ so that each event gets a day within its range.}
\WHY{This is a classic greedy-by-deadline scheduling pattern; appears frequently in interval assignment, matching simplifications, and CF tasks.}
\CHECKLIST{%
- Read $n$ and all intervals; keep original indices.
- Sort by nondecreasing $r_i$.
- Greedily assign $d=\max(cur{+}1, l_i)$ and update $cur$.
- Scatter results back to input order; print space-separated.}
\EDGECASES{%
- $n=1$.
- All $[l_i,r_i]$ identical.
- Tight chain: $[1,1],[1,2],[2,2],[2,3],\ldots$
- Disjoint blocks.
- Many intervals sharing the same $r_i$.
- Very large $r_i$ with small $n$.}
\PITFALLS{%
- Forgetting to output in input order.
- Not sorting by $r_i$ (can break greedy feasibility).
- Off-by-one in $cur{+}1$.
- Using a global ``used'' that allows reuse.
- Quadratic or worse scans on huge ranges (if not using cursor/DSU).
- Printing extra whitespace or newlines inconsistently.}
\FAILMODES{Approaches that sort by $l_i$ and pick earliest nonused can fail. The presented greedy by $r_i$ or successor-DSU sustains feasibility.}
\ELI{Pick deadlines that come first, give each the earliest day you can without colliding, and keep moving forward. Because we never delay an early deadline unnecessarily, later events still fit.}
\NotePages{3}

\end{document}