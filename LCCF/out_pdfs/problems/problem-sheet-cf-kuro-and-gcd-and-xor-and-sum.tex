% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Kuro and GCD and XOR and SUM}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/979/D}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{Kuro is currently playing an educational game about numbers. The game focuses on the greatest common divisor (GCD), the XOR value, and the sum of two numbers. Kuro loves the game so much that he solves levels by levels day by day.

Sadly, he is going on a vacation for a day, and he is not able to continue his solving streak on his own. As Katie is a reliable person, Kuro kindly asked her to come to his house on this day to play the game for him.

Initially, there is an empty array $a$. The game consists of $q$ tasks of two types. The first type asks Katie to add a number $u_i$ to $a$. The second type asks Katie to find a number $v$ existing in $a$ such that $k_i \mid \mathrm{GCD}(x_i, v)$, $x_i + v \le s_i$, and $x_i \oplus v$ is maximized, where $\oplus$ denotes the bitwise XOR operation, $\mathrm{GCD}(c, d)$ denotes the greatest common divisor of integers $c$ and $d$, and $y \mid x$ means $x$ is divisible by $y$, or report $-1$ if no such numbers are found.

Since you are a programmer, Katie needs you to automatically and accurately perform the tasks in the game to satisfy her dear friend Kuro. Let us help her!

Input:
The first line contains one integer $q$ ($2 \le q \le 10^{5}$) — the number of tasks the game wants you to perform.

$q$ lines follow, each line begins with an integer $t_i$ — the type of the task:
\begin{bullets}
\item If $t_i = 1$, an integer $u_i$ follows ($1 \le u_i \le 10^{5}$) — you have to add $u_i$ to the array $a$.
\item If $t_i = 2$, three integers $x_i$, $k_i$, and $s_i$ follow ($1 \le x_i, k_i, s_i \le 10^{5}$) — you must find a number $v$ existing in the array $a$ such that $k_i \mid \mathrm{GCD}(x_i, v)$, $x_i + v \le s_i$, and $x_i \oplus v$ is maximized, or report $-1$ if no such numbers are found.
\end{bullets}

It is guaranteed that the type of the first task is type $1$, and there exists at least one task of type $2$.

Output:
For each task of type $2$, output on one line the desired number $v$, or $-1$ if no such numbers are found.

Note:
In the first example, there are $5$ tasks:
\begin{bullets}
\item The first task requires you to add $1$ into $a$. $a$ is now $\{1\}$.
\item The second task requires you to add $2$ into $a$. $a$ is now $\{1, 2\}$.
\item The third task asks you a question with $x = 1$, $k = 1$ and $s = 3$. Taking both $1$ and $2$ as $v$ satisfies $1 \mid \mathrm{GCD}(1, v)$ and $1 + v \le 3$. Because $2 \oplus 1 = 3 > 1 \oplus 1 = 0$, $2$ is the answer to this task.
\item The fourth task asks you a question with $x = 1$, $k = 1$ and $s = 2$. Only $v = 1$ satisfies $1 \mid \mathrm{GCD}(1, v)$ and $1 + v \le 2$, so $1$ is the answer to this task.
\item The fifth task asks you a question with $x = 1$, $k = 1$ and $s = 1$. There are no elements in $a$ that satisfy the conditions, so we report $-1$ as the answer to this task.
\end{bullets}}
\BREAKDOWN{Maintain a dynamic multiset of integers, support insertions, and for queries filter by divisibility and sum constraint, then maximize XOR with $x$. The key observation: $k \mid \mathrm{GCD}(x, v)$ implies $k \mid x$ and $k \mid v$.}
\ELI{Answer queries over numbers multiple of $k$ and not exceeding $s-x$, choosing the one that makes the XOR with $x$ largest.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One integer $q$; then $q$ lines. For type $1$: one integer $u$ ($1 \le u \le 10^{5}$). For type $2$: three integers $x, k, s$ (each in $[1,10^{5}]$).}
\OUTPUTS{For each type $2$ query, print the maximizer $v$ that exists in the current array satisfying $k \mid \mathrm{GCD}(x, v)$ and $x+v \le s$ and maximizing $x \oplus v$; or $-1$ if none exists.}
\SAMPLES{Example:
\[
\begin{aligned}
\text{in: }& 5\\
& 1~1\\
& 1~2\\
& 2~1~1~3\\
& 2~1~1~2\\
& 2~1~1~1\\
\text{out: }& 2\\
& 1\\
& -1
\end{aligned}
\]
Another tiny example:
\[
\begin{aligned}
\text{in: }& 3\\
& 1~6\\
& 2~4~2~9\\
& 2~4~3~10\\
\text{out: }& -1\\
& -1
\end{aligned}
\]}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Maintain a multiset $A \subseteq \{1,\ldots,10^{5}\}$ under insertions. For a query $(x,k,s)$, define the feasible set
\begin{BreakableEquation*}
F(x,k,s) = \{v \in A : k \mid \mathrm{GCD}(x,v),~ x+v \le s\}.
\end{BreakableEquation*}
Return $\arg\max_{v \in F(x,k,s)}~ (x \oplus v)$, or $-1$ if $F = \varnothing$.}
\varmapStart
\var{A}{current multiset of inserted numbers}
\var{x}{query operand for XOR and sum}
\var{k}{divisibility constraint}
\var{s}{sum budget}
\var{v}{candidate answer from $A$}
\var{B_k}{subset of $A$ containing multiples of $k$}
\var{L}{limit $s-x$ for $v$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
k \mid \mathrm{GCD}(x,v) \iff (k \mid x) \wedge (k \mid v),
\end{BreakableEquation*}
\begin{BreakableEquation*}
v \in [1, L],\quad L = s-x,\quad \text{maximize } x \oplus v.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Numbers are nonnegative up to $10^{5}$; multiple insertions allowed; when ties in XOR occur, any maximizer is acceptable.}
\INVARIANTS{
\begin{bullets}
\item For each divisor $d$, the per-$d$ structure contains exactly the elements of $A$ divisible by $d$.
\item Each trie node maintains the minimum value in its subtree, enabling pruning by the limit $L$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly check all $v \in A$ that satisfy $k \mid \mathrm{GCD}(x,v)$ and $x+v \le s$, and keep the one maximizing $x \oplus v$.}
\ASSUMPTIONS{Maintain $A$ as a simple list (multiset).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item On type $1~u$: append $u$ to list $A$.
\item On type $2~x~k~s$: if $x \bmod k \ne 0$ or $x > s$, return $-1$.
\item Otherwise iterate all $v \in A$: if $v \bmod k = 0$ and $v \le s-x$, track the best by $x \oplus v$.
\end{algosteps}
\COMPLEXITY{Let $n$ be the number of insertions so far and $Q$ the number of queries.
\[
\begin{aligned}
\text{Insert: }& O(1).\\
\text{Query: }& O(n).\\
\text{Total worst-case: }& O\!\left(\sum \text{query time}\right) = O(Qn)\ \text{in the worst case}.
\end{aligned}
\]}
\CORRECTNESS{Exhaustive filtering and comparison guarantees the returned $v$ is feasible and maximizes the XOR among feasible candidates.}
\EDGECASES{No feasible $v$; $x \bmod k \ne 0$; $s < x$; duplicates in $A$ are harmless.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List

def solve_io_baseline(data: str) -> str:
    it = iter(map(int, data.strip().split()))
    q = next(it)
    A: List[int] = []
    out: List[str] = []
    for _ in range(q):
        t = next(it)
        if t == 1:
            u = next(it)
            A.append(u)
        else:
            x = next(it); k = next(it); s = next(it)
            if x % k != 0 or x > s:
                out.append("-1"); continue
            L = s - x
            best_v = -1
            best_xor = -1
            for v in A:
                if v % k == 0 and v <= L:
                    val = x ^ v
                    if val > best_xor:
                        best_xor = val
                        best_v = v
            out.append(str(best_v if best_v != -1 else -1))
    return "\n".join(out)

def read_input() -> str:
    return sys.stdin.buffer.read().decode()

def solve_all() -> None:
    data = read_input()
    if not data.strip():
        return
    print(solve_io_baseline(data))

def main():
    # Tiny self-checks
    sample_in = "5\n1 1\n1 2\n2 1 1 3\n2 1 1 2\n2 1 1 1\n"
    sample_out = "2\n1\n-1"
    assert solve_io_baseline(sample_in) == sample_out
    # Another quick check
    t2 = "3\n1 6\n2 4 2 9\n2 4 3 10\n"
    assert solve_io_baseline(t2) == "-1\n-1"
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Validated on the given example and a small custom scenario.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-divisor Binary Tries with Min-Value Pruning}
\WHICHFORMULA{Since $k \mid \mathrm{GCD}(x,v)$ iff $k \mid x$ and $k \mid v$, restrict to multiples of $k$. Maintain, for every divisor $d$, a bitwise trie of numbers divisible by $d$ and store at each node the minimum value in its subtree to enforce the $v \le s-x$ constraint during greedy XOR traversal.}
\ASSUMPTIONS{Fixed bit-length up to $17$ bits suffices for values $\le 10^{5}$. Precompute divisors for all numbers up to $10^{5}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\mathrm{divs}[v]$ for all $1 \le v \le 10^{5}$.
\item Maintain a dictionary $T$ mapping $d$ to its binary trie; each node stores $(\text{child}[0], \text{child}[1], \text{mn})$.
\item On insert $u$: for every $d \in \mathrm{divs}[u]$, insert $u$ into $T[d]$, updating node minima.
\item On query $(x,k,s)$: if $x \bmod k \ne 0$ or $x > s$, print $-1$. Else set $L=s-x$ and greedily walk $T[k]$ to maximize XOR with $x$, but only traversing children whose subtree minimum $\le L$.
\end{algosteps}
\COMPLEXITY{Let $B$ be the bit-length ($\approx 17$) and $\tau(u)$ be the number of divisors of $u$.
\[
\begin{aligned}
\text{Insert }u:&\ O\big(B \cdot \tau(u)\big),\quad \text{with } \mathbb{E}[\tau(u)] \approx O(\log u).\\
\text{Query: }& O(B).\\
\text{Total nodes: }& O\!\Big(B \sum_{u \in A} \tau(u)\Big) \approx O(B\,|A| \log \max A).
\end{aligned}
\]}
\CORRECTNESS{The trie stores exactly multiples of $d$. The greedy XOR choice is optimal in a complete binary trie; pruning by subtree-min ensures feasibility under $v \le L$. If root minimum exceeds $L$, no feasible value exists.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Dict

MAX_A = 100000
MAX_BIT = 16  # since 2^17 = 131072 > 1e5

def precompute_divisors(n: int) -> List[List[int]]:
    divs = [[] for _ in range(n + 1)]
    for d in range(1, n + 1):
        for m in range(d, n + 1, d):
            divs[m].append(d)
    return divs

class BitwiseTrie:
    __slots__ = ("ch0", "ch1", "mn")
    def __init__(self) -> None:
        self.ch0: List[int] = [-1]
        self.ch1: List[int] = [-1]
        self.mn: List[int] = [10**9]

    def _new(self) -> int:
        self.ch0.append(-1)
        self.ch1.append(-1)
        self.mn.append(10**9)
        return len(self.mn) - 1

    def insert(self, val: int) -> None:
        idx = 0
        if val < self.mn[idx]:
            self.mn[idx] = val
        for b in range(MAX_BIT, -1, -1):
            bit = (val >> b) & 1
            if bit == 0:
                if self.ch0[idx] == -1:
                    self.ch0[idx] = self._new()
                idx = self.ch0[idx]
            else:
                if self.ch1[idx] == -1:
                    self.ch1[idx] = self._new()
                idx = self.ch1[idx]
            if val < self.mn[idx]:
                self.mn[idx] = val

    def query(self, x: int, limit: int) -> int:
        if self.mn[0] > limit:
            return -1
        idx = 0
        ans = 0
        for b in range(MAX_BIT, -1, -1):
            xb = (x >> b) & 1
            prefer = 1 - xb
            # Try preferred branch
            if prefer == 0:
                nx = self.ch0[idx]
                if nx != -1 and self.mn[nx] <= limit:
                    idx = nx
                    # bit 0, ans unchanged at this position
                else:
                    nx = self.ch1[idx]
                    if nx == -1 or self.mn[nx] > limit:
                        return -1
                    idx = nx
                    ans |= (1 << b)
            else:
                nx = self.ch1[idx]
                if nx != -1 and self.mn[nx] <= limit:
                    idx = nx
                    ans |= (1 << b)
                else:
                    nx = self.ch0[idx]
                    if nx == -1 or self.mn[nx] > limit:
                        return -1
                    idx = nx
                    # bit 0
        return ans

def solve_io(data: str) -> str:
    it = iter(map(int, data.strip().split()))
    q = next(it)
    divs = precompute_divisors(MAX_A)
    tries: Dict[int, BitwiseTrie] = {}
    out: List[str] = []
    for _ in range(q):
        t = next(it)
        if t == 1:
            u = next(it)
            for d in divs[u]:
                if d not in tries:
                    tries[d] = BitwiseTrie()
                tries[d].insert(u)
        else:
            x = next(it); k = next(it); s = next(it)
            if x % k != 0 or x > s or k not in tries:
                out.append("-1"); continue
            L = s - x
            v = tries[k].query(x, L)
            out.append(str(v if v != -1 else -1))
    return "\n".join(out)

def read_input() -> str:
    return sys.stdin.buffer.read().decode()

def solve_all() -> None:
    data = read_input()
    if not data.strip():
        return
    print(solve_io(data))

def main():
    # Basic example from the statement
    sample_in = "5\n1 1\n1 2\n2 1 1 3\n2 1 1 2\n2 1 1 1\n"
    sample_out = "2\n1\n-1"
    assert solve_io(sample_in) == sample_out
    # Edge: x % k != 0
    t2 = "2\n1 6\n2 4 3 10\n"
    assert solve_io(t2) == "-1"
    # Edge: limit too small
    t3 = "2\n1 6\n2 4 2 9\n"
    assert solve_io(t3) == "-1"
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked on the sample and two edge scenarios (infeasible due to divisibility and due to sum limit).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Per-Divisor Tries with Subtree-Min for Budgeted XOR Maximization}
\WHICHFORMULA{Same as Approach B; this is the standard accepted solution on CF 979D: tries keyed by divisors, greedy XOR walk under a per-node minimum value budget.}
\ASSUMPTIONS{$k \mid x$ is necessary; values $\le 10^{5}$ fit in $17$ bits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute divisors for all values up to the maximum allowed.
\item On insertion of $u$, add $u$ to all tries corresponding to its divisors, updating subtree minima.
\item On query $(x,k,s)$, if $x \bmod k \ne 0$ or $x > s$ or the trie for $k$ is empty under the limit $L=s-x$, return $-1$; otherwise greedily traverse to maximize XOR.
\end{algosteps}
\OPTIMALITY{The greedy traversal on a binary trie yields the maximum XOR; pruning by subtree minima ensures feasibility. The per-divisor partitioning is necessary to enforce $k \mid v$ and yields near-linear construction over all operations.}
\COMPLEXITY{Per operation: insertion $O(\tau(u)\cdot B)$, query $O(B)$ with $B=17$. Total memory across all tries is $O(B \sum \tau(u)) \approx O(B\,|A|\log \max A)$.}
\[
\begin{aligned}
T_{\text{insert}}(u) &\le 17 \cdot \tau(u),\\
T_{\text{query}} &\le 17.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Dict

MAX_A = 100000
MAX_BIT = 16

def precompute_divisors(n: int) -> List[List[int]]:
    divs = [[] for _ in range(n + 1)]
    for d in range(1, n + 1):
        for m in range(d, n + 1, d):
            divs[m].append(d)
    return divs

class BitwiseTrie:
    __slots__ = ("ch0", "ch1", "mn")
    def __init__(self) -> None:
        self.ch0: List[int] = [-1]
        self.ch1: List[int] = [-1]
        self.mn: List[int] = [10**9]
    def _new(self) -> int:
        self.ch0.append(-1); self.ch1.append(-1); self.mn.append(10**9)
        return len(self.mn) - 1
    def insert(self, val: int) -> None:
        idx = 0
        if val < self.mn[idx]:
            self.mn[idx] = val
        for b in range(MAX_BIT, -1, -1):
            bit = (val >> b) & 1
            if bit == 0:
                if self.ch0[idx] == -1:
                    self.ch0[idx] = self._new()
                idx = self.ch0[idx]
            else:
                if self.ch1[idx] == -1:
                    self.ch1[idx] = self._new()
                idx = self.ch1[idx]
            if val < self.mn[idx]:
                self.mn[idx] = val
    def query(self, x: int, limit: int) -> int:
        if self.mn[0] > limit:
            return -1
        idx = 0
        ans = 0
        for b in range(MAX_BIT, -1, -1):
            xb = (x >> b) & 1
            prefer = 1 - xb
            if prefer == 1:
                nx = self.ch1[idx]
                if nx != -1 and self.mn[nx] <= limit:
                    idx = nx
                    ans |= (1 << b)
                else:
                    nx = self.ch0[idx]
                    if nx == -1 or self.mn[nx] > limit:
                        return -1
                    idx = nx
            else:
                nx = self.ch0[idx]
                if nx != -1 and self.mn[nx] <= limit:
                    idx = nx
                else:
                    nx = self.ch1[idx]
                    if nx == -1 or self.mn[nx] > limit:
                        return -1
                    idx = nx
                    ans |= (1 << b)
        return ans

def solve_io(data: str) -> str:
    it = iter(map(int, data.strip().split()))
    q = next(it)
    divs = precompute_divisors(MAX_A)
    tries: Dict[int, BitwiseTrie] = {}
    out: List[str] = []
    for _ in range(q):
        t = next(it)
        if t == 1:
            u = next(it)
            for d in divs[u]:
                tr = tries.get(d)
                if tr is None:
                    tr = tries[d] = BitwiseTrie()
                tr.insert(u)
        else:
            x = next(it); k = next(it); s = next(it)
            if x % k != 0 or x > s:
                out.append("-1"); continue
            tr = tries.get(k)
            if tr is None:
                out.append("-1"); continue
            L = s - x
            v = tr.query(x, L)
            out.append(str(v if v != -1 else -1))
    return "\n".join(out)

def read_input() -> str:
    return sys.stdin.buffer.read().decode()

def solve_all() -> None:
    data = read_input()
    if data.strip():
        print(solve_io(data))

def main():
    # Exactly 3 asserts / I/O mini-tests
    a = "5\n1 1\n1 2\n2 1 1 3\n2 1 1 2\n2 1 1 1\n"
    b = "2\n1\n-1"
    assert solve_io(a) == b
    c = "4\n1 4\n1 8\n2 6 2 12\n2 6 4 12\n"
    # For k=2, candidates {4,8} with L=6; only 4 fits -> v=4; for k=4, both fit and 6^8=14 > 6^4=2 -> v=8
    assert solve_io(c) == "4\n8"
    d = "3\n1 6\n2 5 5 20\n2 5 1 4\n"
    # First infeasible (x % k != 0), second L = -1
    assert solve_io(d) == "-1\n-1"
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts:
\begin{bullets}
\item Sample from the statement.
\item Mixed divisibility with two answers.
\item Two infeasible queries (divisibility and budget).
\end{bullets}}
\RESULT{For each query, the printed value $v$ is an existing number satisfying constraints and maximizing $x \oplus v$; if none exists, $-1$ is printed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test core solver on samples and crafted edge cases: divisibility violation ($x \bmod k \ne 0$), tight budgets, duplicates, and mixture of inserts and queries.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Optimal on random tiny sequences to ensure agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate short sequences where all queries are infeasible; where only one candidate fits; where ties in XOR occur.}
\begin{minted}{python}
import random

def gen_tiny(seed: int = 0) -> str:
    random.seed(seed)
    ops = []
    A = []
    q = 30
    ops.append(str(q))
    for _ in range(q):
        if not A or random.random() < 0.6:
            u = random.randint(1, 50)
            A.append(u)
            ops.append(f"1 {u}")
        else:
            x = random.randint(1, 50)
            k = random.randint(1, 12)
            s = random.randint(1, 100)
            ops.append(f"2 {x} {k} {s}")
    return "\n".join(ops) + "\n"

# Cross-check helpers by importing the three solve_io functions from the approaches if placed together.
# Here, we stub minimal local versions or assume availability when running externally.
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Dict

MAX_A = 100000
MAX_BIT = 16

def precompute_divisors(n: int) -> List[List[int]]:
    divs = [[] for _ in range(n + 1)]
    for d in range(1, n + 1):
        for m in range(d, n + 1, d):
            divs[m].append(d)
    return divs

class BitwiseTrie:
    __slots__ = ("ch0", "ch1", "mn")
    def __init__(self) -> None:
        self.ch0: List[int] = [-1]
        self.ch1: List[int] = [-1]
        self.mn: List[int] = [10**9]
    def _new(self) -> int:
        self.ch0.append(-1); self.ch1.append(-1); self.mn.append(10**9)
        return len(self.mn) - 1
    def insert(self, val: int) -> None:
        idx = 0
        if val < self.mn[idx]:
            self.mn[idx] = val
        for b in range(MAX_BIT, -1, -1):
            bit = (val >> b) & 1
            if bit == 0:
                if self.ch0[idx] == -1:
                    self.ch0[idx] = self._new()
                idx = self.ch0[idx]
            else:
                if self.ch1[idx] == -1:
                    self.ch1[idx] = self._new()
                idx = self.ch1[idx]
            if val < self.mn[idx]:
                self.mn[idx] = val
    def query(self, x: int, limit: int) -> int:
        if self.mn[0] > limit:
            return -1
        idx = 0
        ans = 0
        for b in range(MAX_BIT, -1, -1):
            xb = (x >> b) & 1
            prefer = 1 - xb
            if prefer == 1:
                nx = self.ch1[idx]
                if nx != -1 and self.mn[nx] <= limit:
                    idx = nx
                    ans |= (1 << b)
                else:
                    nx = self.ch0[idx]
                    if nx == -1 or self.mn[nx] > limit:
                        return -1
                    idx = nx
            else:
                nx = self.ch0[idx]
                if nx != -1 and self.mn[nx] <= limit:
                    idx = nx
                else:
                    nx = self.ch1[idx]
                    if nx == -1 or self.mn[nx] > limit:
                        return -1
                    idx = nx
                    ans |= (1 << b)
        return ans

def solve_io(data: str) -> str:
    it = iter(map(int, data.strip().split()))
    q = next(it)
    divs = precompute_divisors(MAX_A)
    tries: Dict[int, BitwiseTrie] = {}
    out: List[str] = []
    for _ in range(q):
        t = next(it)
        if t == 1:
            u = next(it)
            for d in divs[u]:
                tr = tries.get(d)
                if tr is None:
                    tr = tries[d] = BitwiseTrie()
                tr.insert(u)
        else:
            x = next(it); k = next(it); s = next(it)
            if x % k != 0 or x > s:
                out.append("-1"); continue
            tr = tries.get(k)
            if tr is None:
                out.append("-1"); continue
            L = s - x
            v = tr.query(x, L)
            out.append(str(v if v != -1 else -1))
    return "\n".join(out)

def read_input() -> str:
    return sys.stdin.buffer.read().decode()

def solve_all() -> None:
    data = read_input()
    if data.strip():
        print(solve_io(data))

def main():
    # Quick sanity tests
    a = "5\n1 1\n1 2\n2 1 1 3\n2 1 1 2\n2 1 1 1\n"
    b = "2\n1\n-1"
    assert solve_io(a) == b
    c = "4\n1 4\n1 8\n2 6 2 12\n2 6 4 12\n"
    assert solve_io(c) == "4\n8"
    d = "3\n1 6\n2 5 5 20\n2 5 1 4\n"
    assert solve_io(d) == "-1\n-1"
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to maximizing XOR over multiples of $k$ under a value limit $L=s-x$ using per-divisor tries with subtree minima.}
\WHY{This pattern tests combining number theory (divisors, GCD) with bitwise trie optimization under constraints.}
\CHECKLIST{
\begin{bullets}
\item Check $x \bmod k = 0$ early; otherwise answer is $-1$.
\item Compute $L = s - x$; if $L < 0$, answer is $-1$.
\item Use correct bit range ($0..16$ for values $\le 10^{5}$).
\item During trie walk, only traverse children with subtree-min $\le L$.
\item Reconstruct $v$ from the taken branches.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $x \bmod k \ne 0$.
\item $s < x$ (negative limit).
\item Trie for $k$ not created yet (no multiples inserted).
\item Only very large multiples exist, all $> L$.
\item Duplicates inserted; still valid.
\item $x=0$ not present here, but if it were, XOR equals $v$.
\item Max boundary values near $10^{5}$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using wrong bit cap (e.g., $15$ instead of $16$) silently loses correctness.
\item Forgetting to update node minima on every step of insertion.
\item Not short-circuiting when root-min $> L$.
\item Treating $k \mid \mathrm{GCD}(x,v)$ as $\mathrm{GCD}(x,v)=k$ instead of $k$ divides the GCD.
\item Mishandling input order or mixing insert and query states.
\item Returning XOR value instead of $v$ itself.
\item Failing to handle $-1$ when both branches are pruned.
\end{bullets}}
\FAILMODES{Brute force times out; per-value tries without pruning cannot enforce the $v \le L$ constraint efficiently; ignoring the $k \mid x$ pre-check produces wrong non-$-1$ answers.}
\ELI{Filter to multiples of $k$; among those not exceeding $s-x$, pick the one that flips as many high bits of $x$ as possible. A binary trie lets you do that greedily while ensuring some value under the budget exists in each chosen branch.}
\NotePages{3}

\end{document}