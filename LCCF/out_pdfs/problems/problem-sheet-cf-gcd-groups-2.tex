% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — GCD Groups 2}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1198/F}}
\LINE{DIFFICULTY / RATING}{2900}
\STATEMENT{You are given an array of $n$ integers. You need to split all integers into two groups so that the $\gcd$ of all integers in the first group is equal to one and the $\gcd$ of all integers in the second group is equal to one.

The $\gcd$ of a group of integers is the largest non-negative integer that divides all the integers in the group.

Both groups have to be non-empty.

Input:
The first line contains a single integer $n$ ($2 \le n \le 10^5$).

The second line contains $n$ integers $a_1$, $a_2$, $\ldots$, $a_n$ ($1 \le a_i \le 10^9$) — the elements of the array.

Output:
In the first line print ``YES'' (without quotes), if it is possible to split the integers into two groups as required, and ``NO'' (without quotes) otherwise.

If it is possible to split the integers, in the second line print $n$ integers, where the $i$-th integer is equal to $1$ if the integer $a_i$ should be in the first group, and $2$ otherwise.

If there are multiple solutions, print any.}
\BREAKDOWN{We must decide a 2-coloring of indices such that both color classes have $\gcd$ equal to $1$. It suffices to ensure each color contains some element that is coprime to the $\gcd$ of the rest within that color. We'll search over assignments of a small sampled subset and validate completion with the remaining elements.}
\ELI{Pick a small set, try all ways to split it while tracking the two $\gcd$s; then check if we can add one helper element to each side to make both $\gcd$s equal $1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case. Integer $n$ and array $a[1..n]$ with $2 \le n \le 10^5$, $1 \le a_i \le 10^9$.}
\OUTPUTS{If impossible, print NO. Otherwise print YES and a line of $n$ integers in $\{1,2\}$ indicating group assignments; both groups must be non-empty and each group's $\gcd$ must be $1$.}
\SAMPLES{Example 1: $n=5$, $a=[6,10,15,7,11]$ could output YES with assignment $[1,2,2,1,2]$ since group 1 has $\gcd(6,7)=1$ and group 2 has $\gcd(10,15,11)=1$.

Example 2: $n=3$, $a=[6,10,15]$ must output NO, since any non-empty partition leaves at least one group with $\gcd>1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=\{a_1,\ldots,a_n\}$. Find a partition $A=S \uplus T$ with $S,T \ne \varnothing$ such that $\gcd(S)=1$ and $\gcd(T)=1$.}
\varmapStart
\var{n}{number of elements}
\var{a_i}{value of element $i$}
\var{S,T}{two disjoint groups forming a partition of indices}
\var{g_1}{current $\gcd$ of numbers assigned to group 1}
\var{g_2}{current $\gcd$ of numbers assigned to group 2}
\varmapEnd
\GOVERN{
\[
\gcd(S)=\gcd\bigl(\{a_i:i\in S\}\bigr)=1,\quad
\gcd(T)=\gcd\bigl(\{a_i:i\in T\}\bigr)=1,\quad
S\cap T=\varnothing,\ S\cup T=\{1,\ldots,n\}.
\]
}
\ASSUMPTIONS{All arithmetic is over non-negative integers; $\gcd$ is associative and commutative with $\gcd(x,0)=x$.}
\INVARIANTS{Assigning a new element $x$ to a group updates its $\gcd$ to $\gcd(\text{old},x)$. Once a group's $\gcd$ becomes $1$, it remains $1$ after adding any elements.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all partitions or all assignments of a subset and brute force completion.}
\ASSUMPTIONS{Exponential exploration in $n$ is infeasible; even meet-in-the-middle over $n/2$ is too large for $n=10^5$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all partitions or 2-colorings (impossible for given $n$).
\item Check both group $\gcd$s for each partition.
\item Return the first valid partition if any.
\end{algosteps}
\COMPLEXITY{Exponential; intractable.}
\[
\begin{aligned}
T(n) &= \Theta(2^n)\quad\text{(checking each coloring)} \\
     &\text{which is infeasible for } n\le 10^5.
\end{aligned}
\]
\CORRECTNESS{Trivially correct but unusable.}
\EDGECASES{None manageable at this scale.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline omitted: exponential; infeasible for n up to 1e5.
\end{minted}
\VALIDATION{Not applicable.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Random Sampling + Pairwise GCD Seeds (Heuristic)}
\WHICHFORMULA{Pick two seeds s,t and attempt to ensure each has a coprime partner; fails on arrays like [6,10,15].}
\ASSUMPTIONS{Heuristic only; not reliable for corner cases; no formal guarantee.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Try a few candidate seed pairs $(s,t)$.
\item Assign each element to a group if it is coprime to that seed; otherwise anywhere.
\item Verify both group $\gcd$s become $1$.
\end{algosteps}
\COMPLEXITY{Linear per attempt, but not guaranteed to find a solution even if one exists.}
\[
\begin{aligned}
T(n) &= O(K n) \text{ per attempt, with small } K.
\end{aligned}
\]
\CORRECTNESS{Heuristic; can fail when no element is coprime to a chosen seed though a solution exists.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Heuristic version omitted in favor of the optimal approach below.
\end{minted}
\VALIDATION{Not applicable; replaced by the optimal randomized DP on a small subset.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Small-Subset DP over GCD Pairs + Deterministic Randomization}
\WHICHFORMULA{Use a small sampled subset B (e.g., size 18--22). Run DP over B to track all achievable pairs of group gcds $(g_1,g_2)$ while ensuring both groups are non-empty within B. For each reachable pair, check if the remaining elements can supply up to one ``witness'' per side that is coprime to the current $g_c$ to make it $1$.}
\ASSUMPTIONS{A small random subset suffices with very high probability because the number of distinct subset gcds is small. We use a fixed RNG seed for deterministic behavior.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If there are at least two ones, put one in each group and assign the rest arbitrarily.
\item Otherwise, for a bounded number of trials:
  \begin{bullets}
  \item Pick $K$ distinct indices $B$ (deterministic RNG seed).
  \item DP over $B$: states are $(g_1,g_2,f_1,f_2)$ with $f_c\in\{0,1\}$ indicating whether group $c$ is non-empty within $B$. Transitions assign each $b\in B$ to group 1 or 2, updating gcds and flags.
  \item For each terminal state with $f_1=f_2=1$, scan the complement $A\setminus B$ to find up to one coprime witness for each side needing it (i.e., with $g_c>1$). If both sides need a witness, ensure two distinct indices exist in the union.
  \item If feasible, reconstruct the assignment for $B$, add the witnesses, and place the remaining elements arbitrarily (they cannot increase a group's gcd above $1$).
  \end{bullets}
\item If no trial succeeds, answer NO.
\end{algosteps}
\OPTIMALITY{Given the hardness of the exact combinatorial search, the standard accepted solution uses the fact that the set of attainable gcds from a small subset is small; trying several small subsets suffices in practice and on official tests. Within a fixed subset, the DP is exact and guarantees correctness upon a successful completion check.}
\COMPLEXITY{With $K\approx 20$, the number of DP states is typically a few thousands due to gcd compression. Each feasibility check scans until at most two witnesses are found, so average time is near-linear.}
\[
\begin{aligned}
T(n) &\approx O(\text{trials}\cdot (K\cdot S + n)) \quad\text{with small } S=\#\text{states}, K\le 22. \\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from math import gcd
import random

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def compute_gcd_of_group(a, idxs):
    g = 0
    for i in idxs:
        g = gcd(g, a[i])
    return g

def reconstruct_assignment(B, parent, final_key):
    # Reconstruct assignment for indices in B from DP parents.
    assign = {}
    key = final_key
    while key in parent and parent[key] is not None:
        prev_key, which, idx = parent[key]
        assign[idx] = which
        key = prev_key
    return assign

def try_with_subset(a, B, trials_scanned_outside_limit=None):
    n = len(a)
    inB = [False] * n
    for i in B:
        inB[i] = True
    # DP over B: states are (g1, g2, f1, f2)
    states = { (0, 0, 0, 0): None }
    parent = {}
    for idx in B:
        new_states = {}
        for (g1, g2, f1, f2) in states.keys():
            # assign idx to group 1
            ng1 = a[idx] if g1 == 0 else gcd(g1, a[idx])
            k1 = (ng1, g2, 1, f2)
            if k1 not in new_states:
                new_states[k1] = ( (g1, g2, f1, f2), 1, idx )
            # assign idx to group 2
            ng2 = a[idx] if g2 == 0 else gcd(g2, a[idx])
            k2 = (g1, ng2, f1, 1)
            if k2 not in new_states:
                new_states[k2] = ( (g1, g2, f1, f2), 2, idx )
        states = new_states
        parent.update(new_states)
    # scan feasible terminal states
    outside = [i for i in range(n) if not inB[i]]
    for (g1, g2, f1, f2) in states.keys():
        if f1 != 1 or f2 != 1:
            continue  # both groups must be non-empty within B to avoid empty-group pitfalls
        need1 = 1 if g1 > 1 else 0
        need2 = 1 if g2 > 1 else 0
        needed = need1 + need2
        i1 = i2 = -1
        # If nothing needed, we have a feasible partition already.
        if needed == 0:
            # Build final assignment
            assignB = reconstruct_assignment(a, parent, (g1, g2, f1, f2))
            ans = [0] * n
            # Assign B
            for idx in B:
                ans[idx] = assignB[idx]
            # Others arbitrarily to group 1
            for i in outside:
                ans[i] = 1
            # Verify both gcds == 1
            gA = compute_gcd_of_group(a, [i for i in range(n) if ans[i] == 1])
            gB = compute_gcd_of_group(a, [i for i in range(n) if ans[i] == 2])
            if gA == 1 and gB == 1:
                return True, ans
            # else continue scanning states
            continue
        # Otherwise, need to find up to two distinct witnesses
        # Early exit threshold to avoid worst-case full scans repeatedly (optional)
        scanned = 0
        for i in outside:
            ok1 = (need1 == 1 and gcd(a[i], g1) == 1)
            ok2 = (need2 == 1 and gcd(a[i], g2) == 1)
            if ok1 and i1 == -1:
                i1 = i
            if ok2 and i2 == -1:
                i2 = i
            # If both needed and the same index satisfies both, we still need another distinct witness
            if needed == 2:
                if i1 != -1 and i2 != -1:
                    if i1 != i2:
                        break
                    # else keep searching for a second distinct index
            else:
                if (need1 == 1 and i1 != -1) or (need2 == 1 and i2 != -1):
                    break
            scanned += 1
            if trials_scanned_outside_limit is not None and scanned >= trials_scanned_outside_limit:
                # Optional bound; skip to next state
                pass
        # Validate witness availability
        if needed == 1:
            if need1 == 1 and i1 == -1:
                continue
            if need2 == 1 and i2 == -1:
                continue
        else:
            # needed == 2
            if i1 == -1 or i2 == -1:
                continue
            if i1 == i2:
                # try to find a second distinct witness in another pass
                second = -1
                for j in outside:
                    if j == i1:
                        continue
                    if gcd(a[j], g1) == 1 or gcd(a[j], g2) == 1:
                        second = j
                        break
                if second == -1:
                    continue
                # Decide which side gets i1 and which gets second, respecting need1/need2
                if gcd(a[i1], g1) == 1 and gcd(a[i1], g2) == 1:
                    # assign arbitrarily i1 to group1, second to group2
                    i2 = second
                elif gcd(a[i1], g1) == 1:
                    # i1 for group1; find any for group2
                    i2 = second
                else:
                    # i1 for group2; find any for group1
                    i1 = second
        # Build final assignment
        assignB = reconstruct_assignment(a, parent, (g1, g2, f1, f2))
        ans = [0] * n
        for idx in B:
            ans[idx] = assignB[idx]
        if need1 == 1:
            ans[i1] = 1
        if need2 == 1:
            ans[i2] = 2
        # Put everyone else anywhere (say group 1)
        for i in range(n):
            if ans[i] == 0:
                ans[i] = 1
        # Verify both gcds == 1 and both groups non-empty
        gA = compute_gcd_of_group(a, [i for i in range(n) if ans[i] == 1])
        gB = compute_gcd_of_group(a, [i for i in range(n) if ans[i] == 2])
        if gA == 1 and gB == 1:
            return True, ans
    return False, None

def solve_case(n, a):
    # Quick trivial case: at least two ones
    ones = [i for i, v in enumerate(a) if v == 1]
    if len(ones) >= 2:
        ans = [1] * n
        ans[ones[1]] = 2
        return True, ans
    # Deterministic RNG
    rnd = random.Random(123456789)
    idxs = list(range(n))
    trials = 35
    K = min(22, n)
    # Additionally include some deterministic subsets: first K, last K, spread K
    deterministic_sets = []
    if n > 0:
        deterministic_sets.append(list(range(0, min(K, n))))
        deterministic_sets.append(list(range(max(0, n - K), n)))
        if n >= K:
            step = max(1, n // K)
            deterministic_sets.append([min(i * step, n - 1) for i in range(K)])
    tried_B = set()
    # Try deterministic subsets first
    for B in deterministic_sets:
        tB = tuple(sorted(B))
        if tB in tried_B:
            continue
        tried_B.add(tB)
        ok, ans = try_with_subset(a, B)
        if ok:
            return True, ans
    # Try randomized subsets
    for _ in range(trials):
        B = rnd.sample(idxs, K)
        tB = tuple(sorted(B))
        if tB in tried_B:
            continue
        tried_B.add(tB)
        ok, ans = try_with_subset(a, B)
        if ok:
            return True, ans
    return False, None

def solve_all():
    n, a = read_input()
    if n == 0:
        return
    possible, ans = solve_case(n, a)
    if not possible:
        print("NO")
    else:
        print("YES")
        print(" ".join(str(x) for x in ans))

def main():
    solve_all()

if __name__ == "__main__":
    # Tiny self-checks
    def check(a):
        n = len(a)
        ok, ans = solve_case(n, a)
        if not ok:
            return False, None
        g1 = 0
        g2 = 0
        c1 = c2 = 0
        for i, v in enumerate(a):
            if ans[i] == 1:
                g1 = gcd(g1, v)
                c1 += 1
            else:
                g2 = gcd(g2, v)
                c2 += 1
        assert c1 > 0 and c2 > 0
        return (g1 == 1 and g2 == 1), ans

    # Known NO cases
    ok, _ = check([6, 10, 15])
    assert not ok
    ok, _ = check([1, 2])
    assert not ok
    # Known YES cases
    ok, ans = check([2, 3, 4, 9])
    assert ok
    ok, ans = check([6, 10, 15, 7, 11])
    assert ok

    main()
\end{minted}
\VALIDATION{The code asserts on small positive and negative examples. It also re-computes both group gcds after constructing the answer to guarantee correctness when it claims YES.}
\RESULT{Outputs YES and a valid 2-coloring, or NO if no partition making both gcds equal $1$ is found after exhaustive DP over several small subsets.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks on small crafted arrays; random stress with small $n$ can be added offline. Verification recomputes gcds of both groups.}
\LINE{CROSS-CHECKS}{Compare outcomes between different deterministic subsets $B$; early deterministic subsets and randomized ones should agree on feasibility for the same input.}
\LINE{EDGE-CASE GENERATOR}{Focus on arrays with pairwise non-coprime elements (e.g., products of small primes), many ones, and large repeated primes.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_pairs_non_coprime(n):
    # Build numbers that are products of small primes so that pairwise gcd > 1
    vals = []
    P = [2, 3, 5, 7, 11]
    for i in range(n):
        p = P[i % len(P)]
        q = P[(i + 1) % len(P)]
        vals.append(p * q)
    return vals

def gen_many_ones(n, k):
    # n total, k ones
    a = [1] * k + [2] * (n - k)
    return a

def gen_mixed(n):
    import random
    rnd = random.Random(42)
    a = []
    for _ in range(n):
        x = 1
        for p in [2,3,5,7,11,13,17,19,23,29]:
            if rnd.randrange(0, 4) == 0:
                x *= p
            if x > 10**9:
                break
        if x == 1:
            x = rnd.randint(2, 10**6)
        a.append(x)
    return a
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# The final solution is the same as in Approach C.
import sys
from math import gcd
import random

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def compute_gcd_of_group(a, idxs):
    g = 0
    for i in idxs:
        g = gcd(g, a[i])
    return g

def reconstruct_assignment(a, parent, final_key):
    assign = {}
    key = final_key
    while key in parent and parent[key] is not None:
        prev_key, which, idx = parent[key]
        assign[idx] = which
        key = prev_key
    return assign

def try_with_subset(a, B, trials_scanned_outside_limit=None):
    n = len(a)
    inB = [False] * n
    for i in B:
        inB[i] = True
    states = { (0, 0, 0, 0): None }
    parent = {}
    for idx in B:
        new_states = {}
        for (g1, g2, f1, f2) in states.keys():
            ng1 = a[idx] if g1 == 0 else gcd(g1, a[idx])
            k1 = (ng1, g2, 1, f2)
            if k1 not in new_states:
                new_states[k1] = ( (g1, g2, f1, f2), 1, idx )
            ng2 = a[idx] if g2 == 0 else gcd(g2, a[idx])
            k2 = (g1, ng2, f1, 1)
            if k2 not in new_states:
                new_states[k2] = ( (g1, g2, f1, f2), 2, idx )
        states = new_states
        parent.update(new_states)
    outside = [i for i in range(n) if not inB[i]]
    for (g1, g2, f1, f2) in states.keys():
        if f1 != 1 or f2 != 1:
            continue
        need1 = 1 if g1 > 1 else 0
        need2 = 1 if g2 > 1 else 0
        needed = need1 + need2
        if needed == 0:
            assignB = reconstruct_assignment(a, parent, (g1, g2, f1, f2))
            ans = [0] * n
            for idx in B:
                ans[idx] = assignB[idx]
            for i in outside:
                ans[i] = 1
            gA = compute_gcd_of_group(a, [i for i in range(n) if ans[i] == 1])
            gB = compute_gcd_of_group(a, [i for i in range(n) if ans[i] == 2])
            if gA == 1 and gB == 1:
                return True, ans
            continue
        i1 = i2 = -1
        scanned = 0
        for i in outside:
            ok1 = (need1 == 1 and gcd(a[i], g1) == 1)
            ok2 = (need2 == 1 and gcd(a[i], g2) == 1)
            if ok1 and i1 == -1:
                i1 = i
            if ok2 and i2 == -1:
                i2 = i
            if needed == 2:
                if i1 != -1 and i2 != -1 and i1 != i2:
                    break
            else:
                if (need1 == 1 and i1 != -1) or (need2 == 1 and i2 != -1):
                    break
            scanned += 1
            if trials_scanned_outside_limit is not None and scanned >= trials_scanned_outside_limit:
                pass
        if needed == 1:
            if need1 == 1 and i1 == -1:
                continue
            if need2 == 1 and i2 == -1:
                continue
        else:
            if i1 == -1 or i2 == -1:
                continue
            if i1 == i2:
                second = -1
                for j in outside:
                    if j == i1:
                        continue
                    if gcd(a[j], g1) == 1 or gcd(a[j], g2) == 1:
                        second = j
                        break
                if second == -1:
                    continue
                if gcd(a[i1], g1) == 1 and gcd(a[i1], g2) == 1:
                    i2 = second
                elif gcd(a[i1], g1) == 1:
                    i2 = second
                else:
                    i1 = second
        assignB = reconstruct_assignment(a, parent, (g1, g2, f1, f2))
        ans = [0] * n
        for idx in B:
            ans[idx] = assignB[idx]
        if need1 == 1:
            ans[i1] = 1
        if need2 == 1:
            ans[i2] = 2
        for i in range(n):
            if ans[i] == 0:
                ans[i] = 1
        gA = compute_gcd_of_group(a, [i for i in range(n) if ans[i] == 1])
        gB = compute_gcd_of_group(a, [i for i in range(n) if ans[i] == 2])
        if gA == 1 and gB == 1:
            return True, ans
    return False, None

def solve_case(n, a):
    ones = [i for i, v in enumerate(a) if v == 1]
    if len(ones) >= 2:
        ans = [1] * n
        ans[ones[1]] = 2
        return True, ans
    rnd = random.Random(123456789)
    idxs = list(range(n))
    trials = 35
    K = min(22, n)
    deterministic_sets = []
    if n > 0:
        deterministic_sets.append(list(range(0, min(K, n))))
        deterministic_sets.append(list(range(max(0, n - K), n)))
        if n >= K and K > 0:
            step = max(1, n // K)
            deterministic_sets.append([min(i * step, n - 1) for i in range(K)])
    tried_B = set()
    for B in deterministic_sets:
        tB = tuple(sorted(B))
        if tB in tried_B:
            continue
        tried_B.add(tB)
        ok, ans = try_with_subset(a, B)
        if ok:
            return True, ans
    for _ in range(trials):
        if K == 0:
            break
        B = rnd.sample(idxs, K)
        tB = tuple(sorted(B))
        if tB in tried_B:
            continue
        tried_B.add(tB)
        ok, ans = try_with_subset(a, B)
        if ok:
            return True, ans
    return False, None

def solve_all():
    n, a = read_input()
    if n == 0:
        return
    possible, ans = solve_case(n, a)
    if not possible:
        print("NO")
    else:
        print("YES")
        print(" ".join(str(x) for x in ans))

def main():
    solve_all()

if __name__ == "__main__":
    # Self-tests
    from math import gcd
    def check(a):
        n = len(a)
        ok, ans = solve_case(n, a)
        if not ok:
            return False
        g1 = g2 = 0
        c1 = c2 = 0
        for i, v in enumerate(a):
            if ans[i] == 1:
                g1 = gcd(g1, v); c1 += 1
            else:
                g2 = gcd(g2, v); c2 += 1
        assert c1 > 0 and c2 > 0
        return (g1 == 1 and g2 == 1)

    assert not check([6, 10, 15])
    assert not check([1, 2])
    assert check([2, 3, 4, 9])
    assert check([6, 10, 15, 7, 11])

    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Partition the array into two non-empty groups each with $\gcd=1$ by DP over a small subset and adding witnesses from the rest.}
\WHY{Intersections of prime factors create global constraints; a small-subset gcd DP efficiently explores the essential structure.}
\CHECKLIST{
\begin{bullets}
\item Handle trivial two-ones case fast.
\item Sample a small subset $B$ (deterministic seed).
\item DP states track $(g_1,g_2)$ and non-emptiness flags.
\item For each terminal state, find required coprime witnesses in $A\setminus B$.
\item Reconstruct assignment; verify both gcds are $1$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All numbers share a common factor $>1$ (global $\gcd>1$): impossible.
\item Pairwise non-coprime arrays like $[6,10,15]$: NO.
\item Many ones: if $\ge2$, immediate YES.
\item $n=2$: only solution is $[1,1]$.
\item Large repeated primes with a few breakers (coprime elements).
\item Arrays where only one element is coprime to a given gcd; need two distinct witnesses if both sides still have $g_c>1$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Allowing empty group in DP (avoid via flags).
\item Using the same outside element as witness for both sides when both need one.
\item Forgetting to verify final gcds.
\item Overly large $K$ causing DP blow-up; keep $K\le 22$.
\item Non-deterministic RNG; fix seed for reproducibility.
\item Excessive scanning of outside; break as soon as enough witnesses found.
\end{bullets}
}
\FAILMODES{Heuristics that only look at pairwise coprimality or single seeds fail on arrays where no two elements are coprime despite total gcd being $1$. The DP approach succeeds by considering combined gcd reductions.}
\ELI{Try all reasonable splits of a small, representative set and check if the rest can contribute one helper number on each side to make both gcds $1$. Once a group's gcd hits $1$, adding more numbers will keep it at $1$.}
\NotePages{3}

\end{document}