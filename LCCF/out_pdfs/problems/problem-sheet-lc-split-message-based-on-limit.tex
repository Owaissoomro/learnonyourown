% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Split Message Based on Limit}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/split-message-based-on-limit/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a string, \texttt{message}, and a positive integer, \texttt{limit}. You must \textbf{split} \texttt{message} into one or more \textbf{parts} based on \texttt{limit}. Each resulting part should have the suffix \texttt{"<a/b>"}, where \texttt{"b"} is to be \textbf{replaced} with the total number of parts and \texttt{"a"} is to be \textbf{replaced} with the index of the part, starting from \texttt{1} and going up to \texttt{b}. Additionally, the length of each resulting part (including its suffix) should be \textbf{equal} to \texttt{limit}, except for the last part whose length can be \textbf{at most} \texttt{limit}. The resulting parts should be formed such that when their suffixes are removed and they are all concatenated \textbf{in order}, they should be equal to \texttt{message}. Also, the result should contain as few parts as possible. Return the parts \texttt{message} would be split into as an array of strings. If it is impossible to split \texttt{message} as required, return an empty array.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{message = "this is really a very awesome message"}, \texttt{limit = 9}

\quad \textbf{Output:} \texttt{["thi<1/14>","s i<2/14>","s r<3/14>","eal<4/14>","ly <5/14>","a v<6/14>","ery<7/14>"," aw<8/14>","eso<9/14>","me<10/14>"," m<11/14>","es<12/14>","sa<13/14>","ge<14/14>"]}

\quad \textbf{Explanation:} The first 9 parts take 3 characters each from the beginning of message. The next 5 parts take 2 characters each to finish splitting message. In this example, each part, including the last, has length 9. It can be shown it is not possible to split message into less than 14 parts.

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{message = "short message"}, \texttt{limit = 15}

\quad \textbf{Output:} \texttt{["short mess<1/2>","age<2/2>"]}

\quad \textbf{Explanation:} Under the given constraints, the string can be split into two parts:
\begin{itemize}
\item The first part comprises of the first 10 characters, and has a length 15.
\item The next part comprises of the last 3 characters, and has a length 8.
\end{itemize}

\textbf{Constraints:}
\begin{itemize}
\item $1 \le \lvert \texttt{message} \rvert \le 10^4$
\item \texttt{message} consists only of lowercase English letters and \texttt{' '}.
\item $1 \le \texttt{limit} \le 10^4$
\end{itemize}}
\BREAKDOWN{Compute the minimum feasible number of parts $b$, then distribute characters across parts $1$ to $b$ so that each part $i$ has content length $c_i$ and suffix \texttt{"<i/b>"} with total length constraints satisfied. If no $b$ works, return an empty array.}
\ELI{Each chunk must save room for a counter suffix like \texttt{<2/14>}; find how many chunks you need so there is enough room for all characters, then fill chunks accordingly.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two inputs:
\begin{itemize}
\item \texttt{message}: string, only lowercase letters and spaces; $1 \le \lvert \texttt{message} \rvert \le 10^4$.
\item \texttt{limit}: integer; $1 \le \texttt{limit} \le 10^4$.
\end{itemize}}
\OUTPUTS{An array of strings representing the parts in order, or an empty array if impossible. Each part $i$ must end with suffix \texttt{"<i/b>"} where $b$ is the number of parts; every part length equals \texttt{limit} except the last whose length is at most \texttt{limit}. Concatenating all part contents (after removing suffixes) must equal \texttt{message}.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{message="short message"}, \texttt{limit=15}. Output: \texttt{["short mess<1/2>","age<2/2>"]}.
\item Input: \texttt{message="abc"}, \texttt{limit=6}. Output: \texttt{["abc<1/1>"]}.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n=\lvert \texttt{message} \rvert$. Choose the smallest integer $b \ge 1$ such that there exist nonnegative integers $c_1,\ldots,c_b$ with
\[
c_i + \bigl(\lvert \text{str}(i)\rvert + \lvert \text{str}(b)\rvert + 3\bigr) \le \texttt{limit}\quad\text{for all }i,\quad
\sum_{i=1}^{b} c_i = n,
\]
and additionally $c_i \ge 1$ for $i=1,\ldots,b-1$ (to ensure progress before the last part). Construct part $i$ as $\texttt{message}[p:p+c_i]\ \Vert\ \texttt{"<i/b>"}$, where $p$ advances by $c_i$.}
\varmapStart
\var{n}{length of \texttt{message}}
\var{b}{number of parts}
\var{c_i}{content length of part $i$ (without suffix)}
\var{\ell(x)}{digit length of integer $x$: $\ell(x)=\lvert \text{str}(x)\rvert$}
\varmapEnd
\GOVERN{
\[
\text{suffix\_len}(i,b) = \ell(i) + \ell(b) + 3,\qquad
\text{cap}(i,b) = \texttt{limit} - \text{suffix\_len}(i,b).
\]
\begin{BreakableEquation*}
\sum_{i=1}^{b} c_i = n,\quad 0 \le c_b \le \text{cap}(b,b),\quad 1 \le c_i \le \text{cap}(i,b)\ \ (1 \le i \le b-1).
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Find smallest }b\text{ with }\sum_{i=1}^{b} \text{cap}(i,b) \ge n\text{ and }\min_i \text{cap}(i,b) \ge 1.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices start at $1$. Digits are base-10. If no $b$ satisfies capacity and per-part positivity, the task is impossible and we return an empty array.}
\INVARIANTS{
\begin{itemize}
\item Suffix format is always \texttt{"<i/b>"}; thus suffix length monotone nondecreasing in $i$ and jumps when $\ell(i)$ or $\ell(b)$ increases.
\item For fixed $\ell(b)=d$, within that block $\text{cap}(i,b)$ decreases only when $\ell(i)$ increases.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Scan $b=1,2,\ldots,n$ and find the first $b$ such that the total capacity across $b$ parts accommodates all $n$ characters and every part has at least one content character. Then materialize the split deterministically.}
\ASSUMPTIONS{Because $n \le 10^4$, a linear scan over $b$ with $O(1)$ work per step is feasible in time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If \texttt{limit} $<5$ (shorter than minimal suffix \texttt{"<1/1>"}), return empty array.
\item Maintain $S(b)=\sum_{i=1}^{b} \ell(i)$ incrementally by adding $\ell(b)$.
\item For each $b=1$ to $n$:
\begin{itemize}
\item Let $d=\ell(b)$. If $\texttt{limit} < 2d+4$, skip (some part would have nonpositive capacity).
\item Total capacity $C(b)=b\cdot \texttt{limit} - \bigl(S(b) + b(d+3)\bigr)$.
\item If $C(b) \ge n$, stop; this $b$ is minimal by construction.
\end{itemize}
\item Construct parts $1$ to $b-1$ with exact capacity per part, and put the remaining characters into part $b$. Append suffix \texttt{"<i/b>"} for each.
\end{algosteps}
\COMPLEXITY{Let $n=\lvert \texttt{message} \rvert$. The scan runs at most $n$ iterations, with $O(1)$ work per iteration; construction is $O(n)$.}
\[
\begin{aligned}
T(n) &= O(n) + O(n) = O(n),\\
S(n) &= O(n)\ \text{to store the result strings}.
\end{aligned}
\]
\CORRECTNESS{We scan $b$ in increasing order and stop at the first feasible $b$, guaranteeing minimality per problem requirement. Capacity and per-part positivity ensure we can allocate exactly the needed characters and maintain required lengths.}
\EDGECASES{
\begin{itemize}
\item \texttt{limit} $<5$ implies impossible.
\item Jumps in digit lengths for $i$ or $b$.
\item Very small $n$ (e.g., $n=1$).
\end{itemize}}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        if limit < 5:
            return []
        def digits(x: int) -> int:
            return len(str(x))
        # Find minimal b by linear scan with incremental sum of digits(1..b)
        sdigits = 0
        found_b = None
        for b in range(1, n + 1):
            d = digits(b)
            # minimal per-part capacity occurs when i has d digits:
            # cap_min = limit - (d + d + 3) >= 1  <=>  limit >= 2d + 4
            sdigits += d
            if limit < 2 * d + 4:
                continue
            capacity = b * limit - (sdigits + b * (d + 3))
            if capacity >= n:
                found_b = b
                break
        if found_b is None:
            return []
        b = found_b
        db = len(str(b))
        parts: List[str] = []
        idx = 0
        for i in range(1, b + 1):
            di = len(str(i))
            suffix = f"<{i}/{b}>"
            cap = limit - (di + db + 3)
            if i < b:
                if cap <= 0:
                    return []
                take = cap
            else:
                take = n - idx
                if take < 0:
                    take = 0
                if take > cap:
                    # Should not happen because capacity >= n, but guard anyway
                    return []
            content = message[idx: idx + take]
            parts.append(content + suffix)
            idx += take
        if idx != n:
            return []
        return parts

# Baseline quick tests
s = Solution()
assert s.splitMessage("short message", 15) == ["short mess<1/2>", "age<2/2>"]
assert s.splitMessage("abc", 6) == ["abc<1/1>"]
assert s.splitMessage("a", 4) == []
\end{minted}
\VALIDATION{Sanity checks above include:
\begin{itemize}
\item Example 2 reproduced exactly.
\item Single-part case with ample limit.
\item Impossible case when \texttt{limit} $<5$.
\end{itemize}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Digit-Group Aware Scan}
\WHICHFORMULA{Group $b$ by digit length $d=\ell(b)$ and only consider groups where $\texttt{limit} \ge 2d+4$. Within a fixed $d$, capacity grows strictly with $b$; thus we can early-continue entire groups that fail the minimal per-part constraint.}
\ASSUMPTIONS{Within a fixed $d$, $\text{cap}(i,b) \ge 1$ if $\texttt{limit} \ge 2d+4$, and total capacity $C(b)$ increases strictly with $b$ (since each step adds at least one new content slot).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For digit length $d=1$ to $5$, if $\texttt{limit} < 2d+4$ then skip the whole group.
\item Otherwise, scan $b$ only within $[10^{d-1}, \min(10^{d}-1, n)]$ while maintaining $S(b)=\sum_{i=1}^{b} \ell(i)$ incrementally.
\item Stop at the first $b$ with $C(b) \ge n$, then construct parts as in Approach A.
\end{algosteps}
\COMPLEXITY{Still $O(n)$ time and $O(n)$ output space, but fewer constant-factor checks due to skipping ineligible digit groups up front.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n) = O(n).
\end{aligned}
\]
\CORRECTNESS{Skipping groups with $\texttt{limit} < 2d+4$ is safe because some part would have nonpositive capacity. The first found $b$ across increasing $d$ and $b$ is minimal.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        if limit < 5:
            return []
        def digits(x: int) -> int:
            return len(str(x))
        sdigits = 0
        b = 0
        found_b = None
        # We'll advance b while tracking sdigits = sum_{i=1}^b digits(i)
        while b < n:
            b += 1
            d = digits(b)
            sdigits += d
            if limit < 2 * d + 4:
                continue
            capacity = b * limit - (sdigits + b * (d + 3))
            if capacity >= n:
                found_b = b
                break
        if found_b is None:
            return []
        b = found_b
        db = len(str(b))
        parts: List[str] = []
        idx = 0
        for i in range(1, b + 1):
            di = len(str(i))
            cap = limit - (di + db + 3)
            suffix = f"<{i}/{b}>"
            if i < b:
                if cap <= 0:
                    return []
                take = cap
            else:
                take = n - idx
                if take > cap:
                    return []
            content = message[idx: idx + take]
            idx += take
            parts.append(content + suffix)
        if idx != n:
            return []
        return parts

# Improved tests
s = Solution()
assert s.splitMessage("short message", 15) == ["short mess<1/2>", "age<2/2>"]
assert s.splitMessage("this is really a very awesome message", 9)[0] == "thi<1/14>"
assert s.splitMessage("a", 6) == ["a<1/1>"]
\end{minted}
\VALIDATION{Checked example 2, the prefix of example 1, and a small single-part case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Capacity Accounting With Deterministic Construction}
\WHICHFORMULA{Use the accounting identity
\begin{BreakableEquation*}
C(b) = b\cdot \texttt{limit} - \Bigl(\sum_{i=1}^{b} \ell(i) + b\cdot(\ell(b)+3)\Bigr),
\end{BreakableEquation*}
scan $b$ upward, enforce $\texttt{limit} \ge 2\ell(b)+4$ for positivity, then split using exact per-part capacities $c_i=\texttt{limit}-\bigl(\ell(i)+\ell(b)+3\bigr)$ for $i<b$ and fill the remainder in the last.}
\ASSUMPTIONS{Feasible $b$ must satisfy both total capacity and per-part positivity. Minimal $b$ is required by the problem, hence increasing scan is appropriate.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If \texttt{limit} $<5$, return empty array.
\item Maintain $S(b)$ incrementally; for $b=1\ldots n$, check positivity $\texttt{limit} \ge 2\ell(b)+4$ and capacity $C(b) \ge n$.
\item Construct parts: for $i=1\ldots b-1$ take $c_i$ characters; put the remainder into part $b$; append suffix \texttt{"<i/b>"} each time.
\end{algosteps}
\OPTIMALITY{We return the first feasible $b$ in increasing order, hence the fewest parts. Within such $b$, per-part allocation is canonical and deterministic.}
\COMPLEXITY{Time $O(n)$; space $O(n)$ for the output array and substrings.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n) = O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        if limit < 5:
            return []
        def digits(x: int) -> int:
            return len(str(x))
        sdigits = 0  # sum_{i=1..b} digits(i)
        found_b = None
        for b in range(1, n + 1):
            d = digits(b)
            sdigits += d
            # Per-part positivity: min cap >= 1 when i has d digits
            if limit < 2 * d + 4:
                continue
            capacity = b * limit - (sdigits + b * (d + 3))
            if capacity >= n:
                found_b = b
                break
        if found_b is None:
            return []
        b = found_b
        db = len(str(b))
        parts: List[str] = []
        idx = 0
        for i in range(1, b + 1):
            di = len(str(i))
            cap = limit - (di + db + 3)
            if i < b:
                if cap <= 0:
                    return []
                take = cap
            else:
                take = n - idx
                if take > cap:
                    return []
                if take < 0:
                    take = 0
            suffix = f"<{i}/{b}>"
            content = message[idx: idx + take]
            parts.append(content + suffix)
            idx += take
        if idx != n:
            return []
        return parts

# Exactly 3 asserts (examples and a boundary)
s = Solution()
assert s.splitMessage("this is really a very awesome message", 9) == ["thi<1/14>","s i<2/14>","s r<3/14>","eal<4/14>","ly <5/14>","a v<6/14>","ery<7/14>"," aw<8/14>","eso<9/14>","me<10/14>"," m<11/14>","es<12/14>","sa<13/14>","ge<14/14>"]
assert s.splitMessage("short message", 15) == ["short mess<1/2>", "age<2/2>"]
assert s.splitMessage("a", 6) == ["a<1/1>"]
\end{minted}
\VALIDATION{The asserts reproduce the two provided examples and a minimal single-part boundary case.}
\RESULT{Returns the lexicographically natural parts sequence $[1..b]$ with suffix \texttt{"<i/b>"}. Among all valid answers, uses the smallest possible $b$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify:
\begin{itemize}
\item Examples from the statement.
\item Boundary limits: \texttt{limit} $=4$ (impossible), $=5$ (just suffix), and large limits.
\item Digit-boundary transitions: $b$ around $9 \to 10$, $99 \to 100$.
\end{itemize}}
\LINE{CROSS-CHECKS}{Compare outputs from Approach A, B, and C on random small cases to ensure identical arrays of parts.}
\LINE{EDGE-CASE GENERATOR}{Generate messages of repeated \texttt{'a'} with varying lengths, and random spaces, across limits in $[4,20]$ to hit feasibility thresholds and digit transitions.}
\begin{minted}{python}
import random
from typing import List

class A:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        if limit < 5:
            return []
        def digits(x: int) -> int:
            return len(str(x))
        sdigits = 0
        found_b = None
        for b in range(1, n + 1):
            d = digits(b)
            sdigits += d
            if limit < 2 * d + 4:
                continue
            capacity = b * limit - (sdigits + b * (d + 3))
            if capacity >= n:
                found_b = b
                break
        if found_b is None:
            return []
        b = found_b
        db = len(str(b))
        parts = []
        idx = 0
        for i in range(1, b + 1):
            di = len(str(i))
            cap = limit - (di + db + 3)
            take = cap if i < b else n - idx
            if i < b and cap <= 0:
                return []
            if i == b and take > cap:
                return []
            parts.append(message[idx:idx+take] + f"<{i}/{b}>")
            idx += take
        return parts if idx == n else []

class C:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        # Final reference (same as in Approach C)
        n = len(message)
        if limit < 5:
            return []
        def digits(x: int) -> int:
            return len(str(x))
        sdigits = 0
        found_b = None
        for b in range(1, n + 1):
            d = digits(b)
            sdigits += d
            if limit < 2 * d + 4:
                continue
            capacity = b * limit - (sdigits + b * (d + 3))
            if capacity >= n:
                found_b = b
                break
        if found_b is None:
            return []
        b = found_b
        db = len(str(b))
        parts = []
        idx = 0
        for i in range(1, b + 1):
            di = len(str(i))
            cap = limit - (di + db + 3)
            take = cap if i < b else n - idx
            if i < b and cap <= 0:
                return []
            if i == b and take > cap:
                return []
            parts.append(message[idx:idx+take] + f"<{i}/{b}>")
            idx += take
        return parts if idx == n else []

# Cross-check small randoms
ra = random.Random(0)
for n in range(1, 50):
    for limit in range(4, 21):
        msg = "".join(ra.choice("ab ") for _ in range(n))
        out_a = A().splitMessage(msg, limit)
        out_c = C().splitMessage(msg, limit)
        assert (out_a == out_c), (n, limit, out_a, out_c)

# Spot checks
ref = C()
assert ref.splitMessage("short message", 15) == ["short mess<1/2>", "age<2/2>"]
assert ref.splitMessage("abc", 6) == ["abc<1/1>"]
assert ref.splitMessage("a", 4) == []
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        if limit < 5:
            return []
        def digits(x: int) -> int:
            return len(str(x))
        sdigits = 0
        found_b = None
        for b in range(1, n + 1):
            d = digits(b)
            sdigits += d
            if limit < 2 * d + 4:
                continue
            capacity = b * limit - (sdigits + b * (d + 3))
            if capacity >= n:
                found_b = b
                break
        if found_b is None:
            return []
        b = found_b
        db = len(str(b))
        parts: List[str] = []
        idx = 0
        for i in range(1, b + 1):
            di = len(str(i))
            cap = limit - (di + db + 3)
            if i < b:
                if cap <= 0:
                    return []
                take = cap
            else:
                take = n - idx
                if take > cap:
                    return []
                if take < 0:
                    take = 0
            parts.append(message[idx: idx + take] + f"<{i}/{b}>")
            idx += take
        if idx != n:
            return []
        return parts

# Reference asserts
s = Solution()
assert s.splitMessage("this is really a very awesome message", 9) == ["thi<1/14>","s i<2/14>","s r<3/14>","eal<4/14>","ly <5/14>","a v<6/14>","ery<7/14>"," aw<8/14>","eso<9/14>","me<10/14>"," m<11/14>","es<12/14>","sa<13/14>","ge<14/14>"]
assert s.splitMessage("short message", 15) == ["short mess<1/2>", "age<2/2>"]
assert s.splitMessage("a", 6) == ["a<1/1>"]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the smallest number of parts $b$ so that the total content capacity (after reserving suffixes) fits the whole message, then split deterministically.}
\WHY{Combines string formatting with counting/greedy capacity reasoning; classic interview test of careful accounting and off-by-one handling.}
\CHECKLIST{
\begin{itemize}
\item Check \texttt{limit} $\ge 5$.
\item Iterate $b$ upward; maintain $S(b)=\sum_{i=1}^{b}\ell(i)$.
\item Enforce per-part positivity: $\texttt{limit} \ge 2\ell(b)+4$.
\item Compute capacity $C(b)$ and stop at first $C(b) \ge n$.
\item Build parts with $c_i=\texttt{limit}-\bigl(\ell(i)+\ell(b)+3\bigr)$ for $i<b$; remainder goes to last.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item \texttt{limit} $<5$ (suffix alone too long).
\item Transition $b=9\to 10$, $99\to 100$ where $\ell(b)$ increases.
\item Short messages $n=1,2$.
\item Limits just satisfying positivity, e.g., $\texttt{limit}=2\ell(b)+4$.
\item Many spaces in \texttt{message}.
\item Very tight limits where only the last part is shorter than \texttt{limit}.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Forgetting that suffix length is $\ell(i)+\ell(b)+3$ (angle brackets and slash).
\item Allowing zero or negative capacity parts.
\item Assuming feasibility monotonic in $b$ across digit jumps without checking positivity.
\item Misallocating remaining characters to the last part.
\item Off-by-one in $S(b)$ updates or substring slicing.
\item Not guarding against impossible construction after a feasible capacity check (should not happen if checks are correct).
\end{itemize}}
\FAILMODES{Approaches that binary-search $b$ assuming global monotonicity can fail at digit-length boundaries. The incremental scan with explicit positivity checks avoids this trap.}
\ELI{Save room for the numbering suffix in every chunk. Try $1$ chunk, then $2$, and so on, until you have enough room for all characters. Then fill the chunks in order and tag each with \texttt{<i/b>}.}
\NotePages{3}

\end{document}