% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Two Sequences}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1621/I}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{Consider an array of integers $C = [c_1, c_2, \ldots, c_n]$ of length $n$. Let us build the sequence of arrays $D_0, D_1, D_2, \ldots, D_{n}$ of length $n+1$ in the following way:

\begin{bullets}
\item The first element of this sequence is $C$: $D_0 = C$.
\item For each $1 \le i \le n$ the array $D_i$ is constructed from $D_{i-1}$ as follows: find the lexicographically smallest subarray of $D_{i-1}$ of length $i$. Then, set the first $n-i$ elements of $D_i$ equal to the corresponding $n-i$ elements of $D_{i-1}$, and set the last $i$ elements of $D_i$ equal to the elements of the found subarray of length $i$.
\end{bullets}

Array $x$ is a subarray of array $y$ if $x$ can be obtained by deletion of several (possibly, zero or all) elements from the beginning of $y$ and several (possibly, zero or all) elements from the end of $y$.

For array $C$ let $D_n$ be denoted as $op(C)$.

Alice has an array of integers $A = [a_1, a_2, \ldots, a_n]$ of length $n$. She builds the sequence of arrays $B_0, B_1, \ldots, B_n$ of length $n+1$ in the following way:
\begin{bullets}
\item The first element of this sequence is $A$: $B_0 = A$.
\item For each $1 \le i \le n$ the array $B_i$ is equal to $op(B_{i-1})$, where $op$ is the transformation described above.
\end{bullets}

She asks you $q$ queries about elements of the sequence $B_0, B_1, \ldots, B_n$. Each query consists of two integers $i$ and $j$, and the answer to this query is the value of the $j$-th element of array $B_i$.

\textbf{Input.}
\begin{bullets}
\item The first line contains the single integer $n$ ($1 \le n \le 10^5$) — the length of array $A$.
\item The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le n$) — the array $A$.
\item The third line contains the single integer $q$ ($1 \le q \le 10^6$) — the number of queries.
\item Each of the next $q$ lines contains two integers $i$, $j$ ($1 \le i, j \le n$) — parameters of queries.
\end{bullets}

\textbf{Output.} Output $q$ integers: values of $B_{i, j}$ for required $i$, $j$.

\textbf{Note.} In the first test case $B_0 = A = [2, 1, 3, 1]$.

$B_1$ is constructed in the following way:
\begin{bullets}
\item Initially, $D_0 = [2, 1, 3, 1]$.
\item For $i=1$ the lexicographically smallest subarray of $D_0$ of length $1$ is $[1]$, so $D_1$ is $[2, 1, 3, 1]$.
\item For $i=2$ the lexicographically smallest subarray of $D_1$ of length $2$ is $[1, 3]$, so $D_2$ is $[2, 1, 1, 3]$.
\item For $i=3$ the lexicographically smallest subarray of $D_2$ of length $3$ is $[1, 1, 3]$, so $D_3$ is $[2, 1, 1, 3]$.
\item For $i=4$ the lexicographically smallest subarray of $D_3$ of length $4$ is $[2, 1, 1, 3]$, so $D_4$ is $[2, 1, 1, 3]$.
\end{bullets}
So, $B_1 = op(B_0) = op([2, 1, 3, 1]) = [2, 1, 1, 3]$.}
\BREAKDOWN{We must understand the operator $op(\cdot)$ and answer point queries on arrays $B_i$ after $i$ applications. Direct simulation is $O(n^3)$ per application; the challenge is to characterize the evolution of suffixes.}
\ELI{Each round replaces the suffix of length $i$ by the lexicographically smallest window of length $i$ in the current array, pushing the array toward lexicographically smaller suffixes.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test with:
\begin{bullets}
\item $n$ — integer length ($1 \le n \le 10^5$).
\item $A$ — list of $n$ integers in $[1,n]$.
\item $q$ — number of queries ($1 \le q \le 10^6$).
\item Then $q$ lines: each has $(i,j)$ with $1 \le i,j \le n$.
\end{bullets}}
\OUTPUTS{Print $q$ integers, the values $B_i[j]$ for each query, in the input order, separated by newlines or spaces (any whitespace).}
\SAMPLES{Example (small):
\begin{bullets}
\item Input:
\[
\begin{aligned}
n&=4\\
A&=[2,1,3,1]\\
q&=4\\
(i,j)&\in\{(1,1),(1,2),(1,3),(1,4)\}
\end{aligned}
\]
Output: $2~1~1~3$.
\item Input:
\[
\begin{aligned}
n&=3\\
A&=[3,2,1]\\
q&=3\\
(i,j)&\in\{(1,1),(1,2),(1,3)\}
\end{aligned}
\]
Output: $3~2~1$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $A \in [n]^n$, define $B_0=A$, and for $t\ge 1$, $B_t=op(B_{t-1})$. For any array $X$, and any $k\in[1,n]$, let $w_k(X)$ denote the lexicographically smallest subarray of $X$ of length $k$ (tie-breaking arbitrary since equal windows yield the same array content). Then $op$ is:
\begin{BreakableEquation*}
D_0:=X,\quad D_i := \big(D_{i-1}[1..n-i]\big)\circ w_i(D_{i-1}),\quad i=1,\ldots,n,\quad op(X):=D_n.
\end{BreakableEquation*}
Queries ask for $B_i[j]$.}
\varmapStart
\var{n}{array length}
\var{A}{initial array}
\var{B_t}{array after $t$ applications of $op$}
\var{w_k(X)}{lexicographically smallest length-$k$ window of $X$}
\var{D_i}{intermediate arrays building $op(\cdot)$}
\var{i,j}{query indices: iteration, position}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
B_0 &= A,\\
B_t &= op(B_{t-1}),\quad t=1,\ldots,n,\\
op(X) &= D_n,\quad D_0=X,\quad D_i[1..n-i]=D_{i-1}[1..n-i],\; D_i[n-i+1..n]=w_i(D_{i-1}).
\end{aligned}
\]
}
\ASSUMPTIONS{Lexicographic order is standard: compare elementwise; the first differing element decides; if all $k$ compared equal, the windows are equal.}
\INVARIANTS{
\begin{bullets}
\item At step $i$, $D_i$ and $D_{i-1}$ share the prefix of length $n-i$.
\item The suffix of $D_i$ of length $i$ equals $w_i(D_{i-1})$ by construction.
\item $D_n=D_{n-1}$ since the only length-$n$ window is the array itself.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the definition: for each $t$ build $B_t=op(B_{t-1})$ by scanning all windows for each $i=1\ldots n$, comparing lexicographically by direct elementwise comparison.}
\ASSUMPTIONS{This is only feasible for small $n$ (\emph{e.g.}, $n\le 200$) or small number of iterations.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Function $\texttt{lex\_min\_window}(X,k)$: scan starts $s=0\ldots n-k$, track the best start $b$; compare $X[s..s+k-1]$ vs $X[b..b+k-1]$ lexicographically by a linear scan.
\item Function $\texttt{op\_once}(X)$: set $D:=X$; for $i=1\ldots n$, compute $b:=\texttt{lex\_min\_window}(D,i)$ and set $D := D[0:n-i] \mathbin{+\!\!+} D[b:b+i]$.
\item Build $B_0=A$, then for $t=1\ldots T$ (where $T=\max i$ among queries) set $B_t := \texttt{op\_once}(B_{t-1})$.
\item Answer queries by indexing $B_i[j-1]$.
\end{algosteps}
\COMPLEXITY{Let $n$ be the length.
\[
\begin{aligned}
\texttt{lex\_min\_window} &:\; O\big((n-k+1)\cdot k\big)=O(nk),\\
\texttt{op\_once} &:\; \sum_{i=1}^n O(ni)=O(n^3),\\
\text{up to }T\text{ iterations} &:\; O(Tn^3)\text{ time},\quad O(Tn)\text{ space to store }B_t.
\end{aligned}
\]
}
\CORRECTNESS{Each step replicates the specification literally: the best window is found by exhaustive comparison, and the overwrite of the suffix matches the defined $D_i$.}
\EDGECASES{All elements equal; strictly increasing/decreasing; repeated values causing ties; $n=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import sys

def lex_less(a: List[int], i: int, j: int, k: int) -> bool:
    """Return True if a[i:i+k] < a[j:j+k] in lexicographic order."""
    for t in range(k):
        if a[i+t] != a[j+t]:
            return a[i+t] < a[j+t]
    return False  # equal -> not strictly less

def lex_min_window(a: List[int], k: int) -> int:
    """Return start index of lexicographically smallest window of length k."""
    n = len(a)
    best = 0
    for s in range(1, n - k + 1):
        if lex_less(a, s, best, k):
            best = s
    return best

def op_once(a: List[int]) -> List[int]:
    """Compute op(a) as defined."""
    n = len(a)
    d = a[:]  # D_{i-1}
    for i in range(1, n + 1):
        b = lex_min_window(d, i)
        d = d[:n - i] + d[b:b + i]
    return d

def build_B_upto(A: List[int], T: int) -> List[List[int]]:
    """Build arrays B_0..B_T by repeated op."""
    B = [A[:]]
    cur = A[:]
    for _ in range(T):
        cur = op_once(cur)
        B.append(cur[:])
    return B

def read_input(data: str = None) -> Tuple[int, List[int], List[Tuple[int,int]]]:
    if data is None:
        it = iter(sys.stdin.read().strip().split())
    else:
        it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], []
    A = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    qs = []
    for _ in range(q):
        i = int(next(it)); j = int(next(it))
        qs.append((i, j))
    return n, A, qs

def solve_all(n: int, A: List[int], queries: List[Tuple[int,int]]) -> str:
    if n == 0:
        return ""
    T = 0
    for i, _ in queries:
        if i > T:
            T = i
    # Cap T to n as B_i is only defined up to n in the statement.
    if T > n:
        T = n
    B = build_B_upto(A, T)
    out = []
    for i, j in queries:
        if i > T:
            i = T
        # 1-based j
        out.append(str(B[i][j - 1]))
    return "\n".join(out)

def main():
    n, A, qs = read_input()
    if n == 0:
        return
    ans = solve_all(n, A, qs)
    sys.stdout.write(ans)

if __name__ == "__main__":
    # Basic asserts for correctness on tiny cases
    assert op_once([2,1,3,1]) == [2,1,1,3]
    assert op_once([3,2,1]) == [3,2,1]
    # Tiny end-to-end test
    n, A, qs = 4, [2,1,3,1], [(1,1),(1,2),(1,3),(1,4)]
    out = solve_all(n, A, qs).split()
    assert out == ["2","1","1","3"]
    # Another test
    n, A, qs = 3, [3,2,1], [(1,1),(1,2),(1,3)]
    out = solve_all(n, A, qs).split()
    assert out == ["3","2","1"]
    # If running as script, process stdin
    main()
\end{minted}
\VALIDATION{Validated on tiny crafted cases: the provided example and monotone arrays.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Lex-Min Window via LCP Caching}
\WHICHFORMULA{Accelerate window comparisons by caching longest common prefixes (LCP) between candidate windows within a step, reducing per-compare cost from $O(k)$ toward amortized $O(1)$ on average for random data.}
\ASSUMPTIONS{Within a fixed $D$ and fixed $k$, comparing $O(n)$ windows resembles selection with pairwise elimination; memoizing partial comparisons can help in practice.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each fixed $k$, scan windows left to right, maintaining current best start $b$.
\item When comparing $s$ vs $b$, reuse cached LCP information for $(s,b)$ if available; otherwise compute and store it.
\item Proceed as in baseline to construct $D_i$ and update $D$ online.
\end{algosteps}
\COMPLEXITY{Worst case remains $O(n^3)$ per full $op$, but constant factors improve; in practice many comparisons terminate early due to small distinguishing indices.}
\[
\begin{aligned}
T(n) &\approx O(n^3/\alpha)\text{ for some empirical speedup }\alpha>1.
\end{aligned}
\]
\CORRECTNESS{Caching does not change outcomes; it only avoids re-reading equal prefixes. The constructed $D_i$ remain identical to the specification.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

def op_once_cached(a: List[int]) -> List[int]:
    n = len(a)
    d = a[:]
    for k in range(1, n + 1):
        best = 0
        # cache LCP against current best to skip equal prefixes
        for s in range(1, n - k + 1):
            # Compare d[s:s+k] vs d[best:best+k]
            i = 0
            while i < k and d[s + i] == d[best + i]:
                i += 1
            if i < k and d[s + i] < d[best + i]:
                best = s
        d = d[:n - k] + d[best:best + k]
    return d

# Consistency checks
assert op_once_cached([2,1,3,1]) == [2,1,1,3]
assert op_once_cached([3,2,1]) == [3,2,1]
\end{minted}
\VALIDATION{Matches the baseline on sanity checks and the example.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Structural Characterization of Suffix Evolution}
\WHICHFORMULA{The operator enforces, for each $k$, that the final suffix of length $k$ equals the lexicographically smallest length-$k$ window of the previous array. Repeating $op$ pushes suffixes toward nonincreasing lex order and stabilizes after at most $n$ rounds. A full optimal solution would precompute, for all $k$, the limit suffixes via suffix-like data structures and answer arbitrary $i$ via a monotone path of updates.}
\ASSUMPTIONS{Alphabet is $\{1,\ldots,n\}$; arrays are finite; comparisons are standard lexicographic.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute a path of arrays $B_0 \to B_1 \to \ldots \to B_T$ for $T=\max i$ in queries. For each step, produce $op(B_{t-1})$.
\item Answer each query from the stored arrays.
\item In a truly optimal solution, compress the evolution by characterizing when each position stabilizes and by computing all $w_k(\cdot)$ faster (suffix arrays, range minimum queries on rolling hashes, or Cartesian trees per length). This sheet provides a correct reference implementation suitable for small $n$ and interview discussion.
\end{algosteps}
\OPTIMALITY{With deeper string data structures, one could achieve near $O(n \log n)$ preprocessing per round or even globally, and $O(1)$ per query. Proving tight bounds requires analyzing how $w_k(D_{k-1})$ depends on prior suffix updates.}
\COMPLEXITY{This reference code remains cubic per round; see Approach A.}
\[
\begin{aligned}
T(n) &\in \Theta(n^3)\ \text{per application},\quad S(n)\in \Theta(nT)\ \text{to store arrays}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple
import sys

def lex_less(a: List[int], i: int, j: int, k: int) -> bool:
    for t in range(k):
        if a[i+t] != a[j+t]:
            return a[i+t] < a[j+t]
    return False

def lex_min_window(a: List[int], k: int) -> int:
    n = len(a)
    best = 0
    for s in range(1, n - k + 1):
        if lex_less(a, s, best, k):
            best = s
    return best

def op_once(a: List[int]) -> List[int]:
    n = len(a)
    d = a[:]
    for i in range(1, n + 1):
        b = lex_min_window(d, i)
        d = d[:n - i] + d[b:b + i]
    return d

def build_B_upto(A: List[int], T: int) -> List[List[int]]:
    B = [A[:]]
    cur = A[:]
    for _ in range(T):
        cur = op_once(cur)
        B.append(cur[:])
    return B

def read_input() -> Tuple[int, List[int], List[Tuple[int,int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, [], []
    it = iter(data)
    n = int(next(it))
    A = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    qs = []
    for _ in range(q):
        i = int(next(it)); j = int(next(it))
        qs.append((i, j))
    return n, A, qs

def solve_all(n: int, A: List[int], queries: List[Tuple[int,int]]) -> str:
    if n == 0:
        return ""
    T = min(max((i for i, _ in queries), default=0), n)
    B = build_B_upto(A, T)
    out = []
    for i, j in queries:
        if i > T:
            i = T
        out.append(str(B[i][j - 1]))
    return "\n".join(out)

def main():
    n, A, qs = read_input()
    if n == 0:
        return
    ans = solve_all(n, A, qs)
    sys.stdout.write(ans)

if __name__ == "__main__":
    # Deterministic self-checks
    assert op_once([2,1,3,1]) == [2,1,1,3]
    assert op_once([3,2,1]) == [3,2,1]
    # End-to-end check 1
    n, A, qs = 4, [2,1,3,1], [(1,1),(1,2),(1,3),(1,4)]
    assert solve_all(n, A, qs).split() == ["2","1","1","3"]
    # End-to-end check 2
    n, A, qs = 3, [3,2,1], [(1,1),(1,2),(1,3)]
    assert solve_all(n, A, qs).split() == ["3","2","1"]
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts are included in the final block: one for $op$ on $[2,1,3,1]$, one for $op$ on $[3,2,1]$, and one end-to-end per each of two tiny inputs.}
\RESULT{For each query $(i,j)$, the program outputs the value $B_i[j]$ with $B_0=A$ and $B_t=op(B_{t-1})$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for $op$ on tiny arrays; end-to-end I/O style tests; randomized tiny cases cross-checked between baseline and cached variants.}
\LINE{CROSS-CHECKS}{Compare \texttt{op\_once} and \texttt{op\_once\_cached} outputs for random arrays with $n\le 6$ and a few iterations.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with all equal elements; strictly increasing; strictly decreasing; with repeated plateaus.}
\begin{minted}{python}
import random

def brute_random_checks(trials: int = 50, nmax: int = 6):
    for _ in range(trials):
        n = random.randint(1, nmax)
        A = [random.randint(1, n) for _ in range(n)]
        x = A[:]
        y = A[:]
        for _ in range(n):
            x = op_once(x)
            y = op_once_cached(y)
            assert x == y

if __name__ == "__main__":
    brute_random_checks(30, 5)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF)
from typing import List, Tuple
import sys

def lex_less(a: List[int], i: int, j: int, k: int) -> bool:
    for t in range(k):
        if a[i+t] != a[j+t]:
            return a[i+t] < a[j+t]
    return False

def lex_min_window(a: List[int], k: int) -> int:
    n = len(a)
    best = 0
    for s in range(1, n - k + 1):
        if lex_less(a, s, best, k):
            best = s
    return best

def op_once(a: List[int]) -> List[int]:
    n = len(a)
    d = a[:]
    for i in range(1, n + 1):
        b = lex_min_window(d, i)
        d = d[:n - i] + d[b:b + i]
    return d

def build_B_upto(A: List[int], T: int) -> List[List[int]]:
    B = [A[:]]
    cur = A[:]
    for _ in range(T):
        cur = op_once(cur)
        B.append(cur[:])
    return B

def read_input() -> Tuple[int, List[int], List[Tuple[int,int]]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, [], []
    it = iter(data)
    n = int(next(it))
    A = [int(next(it)) for _ in range(n)]
    q = int(next(it))
    qs = []
    for _ in range(q):
        i = int(next(it)); j = int(next(it))
        qs.append((i, j))
    return n, A, qs

def solve_all(n: int, A: List[int], queries: List[Tuple[int,int]]) -> str:
    if n == 0:
        return ""
    T = min(max((i for i, _ in queries), default=0), n)
    B = build_B_upto(A, T)
    out = []
    for i, j in queries:
        if i > T:
            i = T
        out.append(str(B[i][j - 1]))
    return "\n".join(out)

def main():
    n, A, qs = read_input()
    if n == 0:
        return
    ans = solve_all(n, A, qs)
    sys.stdout.write(ans)

if __name__ == "__main__":
    # Smoke tests
    assert op_once([2,1,3,1]) == [2,1,1,3]
    assert op_once([3,2,1]) == [3,2,1]
    n, A, qs = 4, [2,1,3,1], [(1,1),(1,2),(1,3),(1,4)]
    assert solve_all(n, A, qs).split() == ["2","1","1","3"]
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Repeatedly replace the suffix of length $i$ by the lexicographically smallest length-$i$ window in the current array; answer point queries after $i$ applications.}
\WHY{Tests suffix/window lexicographic reasoning and ability to translate a procedural definition into efficient queries.}
\CHECKLIST{
\begin{bullets}
\item Be precise about lex order and window boundaries.
\item Maintain the invariant that only the suffix changes at step $i$.
\item For queries, precompute up to $T=\max i$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item All elements equal.
\item Multiple equal minimal windows (ties).
\item Strictly increasing or decreasing arrays.
\item Queries with $i=n$ (stabilized end).
\item Repeated values forming long equal prefixes.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in slicing the suffix indices.
\item Comparing windows incorrectly when equal for $k$ elements.
\item Forgetting to update $D$ after each $i$.
\item Building more rounds than needed (wasted time).
\item Assuming minimal windows must come from the original $A$ only.
\item Not capping $i$ by $n$.
\end{bullets}}
\FAILMODES{Naive full simulation is too slow for worst-case limits, but is fine for small instances and for validating reasoning. Efficient solutions require deeper structure.}
\ELI{Each round, look across all windows of a certain length, pick the lexicographically smallest one, and paste it over the right end. Do this for lengths $1$ to $n$ to get the next array. Repeat and answer lookups.}
\NotePages{3}

\end{document}