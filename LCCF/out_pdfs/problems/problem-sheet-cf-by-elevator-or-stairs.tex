% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — By Elevator or Stairs?}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1249/E}}
\LINE{DIFFICULTY / RATING}{1700}
\STATEMENT{You are planning to buy an apartment in a $n$-floor building. The floors are numbered from $1$ to $n$ from the bottom to the top. At first for each floor you want to know the minimum total time to reach it from the first (the bottom) floor.

Let:
\begin{bullets}
\item $a_i$ for all $i$ from $1$ to $n-1$ be the time required to go from the $i$-th floor to the $(i+1)$-th one (and from the $(i+1)$-th to the $i$-th as well) using the stairs;
\item $b_i$ for all $i$ from $1$ to $n-1$ be the time required to go from the $i$-th floor to the $(i+1)$-th one (and from the $(i+1)$-th to the $i$-th as well) using the elevator, also there is a value $c$ — time overhead for elevator usage (you need to wait for it, the elevator doors are too slow!).
\end{bullets}

In one move, you can go from the floor you are staying at $x$ to any floor $y$ ($x \ne y$) in two different ways:
\begin{bullets}
\item If you are using the stairs, just sum up the corresponding values of $a_i$. Formally, it will take $\sum\limits_{i=\min(x, y)}^{\max(x, y) - 1} a_i$ time units.
\item If you are using the elevator, just sum up $c$ and the corresponding values of $b_i$. Formally, it will take $c + \sum\limits_{i=\min(x, y)}^{\max(x, y) - 1} b_i$ time units.
\end{bullets}

You can perform as many moves as you want (possibly zero).

So your task is for each $i$ to determine the minimum total time it takes to reach the $i$-th floor from the $1$-st (bottom) floor.

Input: The first line of the input contains two integers $n$ and $c$ ($2 \le n \le 2 \cdot 10^5, 1 \le c \le 1000$) — the number of floors in the building and the time overhead for the elevator rides.

The second line of the input contains $n - 1$ integers $a_1, a_2, \dots, a_{n-1}$ ($1 \le a_i \le 1000$), where $a_i$ is the time required to go from the $i$-th floor to the $(i+1)$-th one (and from the $(i+1)$-th to the $i$-th as well) using the stairs.

The third line of the input contains $n - 1$ integers $b_1, b_2, \dots, b_{n-1}$ ($1 \le b_i \le 1000$), where $b_i$ is the time required to go from the $i$-th floor to the $(i+1)$-th one (and from the $(i+1)$-th to the $i$-th as well) using the elevator.

Output: Print $n$ integers $t_1, t_2, \dots, t_n$, where $t_i$ is the minimum total time to reach the $i$-th floor from the first floor if you can perform as many moves as you want.}
\BREAKDOWN{Model this as shortest paths with two modes: stairs and elevator. Either run Dijkstra on a two-layer line graph or derive a linear-time DP with two states per floor capturing whether you are currently in elevator mode or not.}
\ELI{Keep two clocks: time if you are free to take stairs, and time if you are already in the elevator; update them floor by floor.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test. Integers $n$ and $c$ with $2 \le n \le 2 \cdot 10^5$, $1 \le c \le 1000$. Arrays $a[1..n-1]$ and $b[1..n-1]$ with $1 \le a_i, b_i \le 1000$.}
\OUTPUTS{Print $n$ integers $t_1, t_2, \ldots, t_n$ in one line, where $t_i$ is the minimum total time to reach floor $i$ from floor $1$.}
\SAMPLES{
Example 1:
\[
\begin{aligned}
n&=3,\quad c=1,\\
a&=[1,1],\quad b=[2,2] \\
\text{Output:}&\quad 0~1~2
\end{aligned}
\]
Example 2:
\[
\begin{aligned}
n&=5,\quad c=3,\\
a&=[4,1,4,1],\quad b=[1,3,1,3] \\
\text{Output:}&\quad 0~4~5~8~9
\end{aligned}
\]
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Two-state shortest path on a line graph with mode switching cost. For each floor $i$, maintain:
\begin{bullets}
\item $S_i$: minimum time to be at floor $i$ without being in the elevator (i.e., after possibly exiting it).
\item $E_i$: minimum time to be at floor $i$ and be in the elevator.
\end{bullets}
Answer $t_i = \min(S_i, E_i)$.}
\varmapStart
\var{n}{number of floors}
\var{c}{one-time overhead for boarding the elevator}
\var{a_i}{stairs time between floors $i$ and $i+1$}
\var{b_i}{elevator travel time between floors $i$ and $i+1$}
\var{S_i}{best time at floor $i$ not in elevator}
\var{E_i}{best time at floor $i$ in elevator}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
S_1 &= 0, \quad E_1 = c, \quad t_1 = 0, \\
S_i &= \min(S_{i-1},\, E_{i-1}) + a_{i-1}, \quad i \ge 2, \\
E_i &= \min(E_{i-1} + b_{i-1},\, S_{i-1} + c + b_{i-1}), \quad i \ge 2, \\
t_i &= \min(S_i, E_i).
\end{aligned}
\]
}
\ASSUMPTIONS{All edge weights are nonnegative; moving multiple floors at once is never better than accumulating adjacent moves due to additivity. Elevator overhead $c$ applies each time you start an elevator segment; exiting the elevator is free.}
\INVARIANTS{
\begin{bullets}
\item $S_i \le t_i \le S_i + c$ since elevator state cannot be more than one boarding ahead.
\item $t_i$ is nondecreasing in $i$ because all per-floor costs are nonnegative.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Run Dijkstra on a two-layer graph with $2n$ nodes representing $(i,\text{stairs})$ and $(i,\text{elevator})$. Edges encode stairs/elevator moves between adjacent floors and mode-switching edges at each floor.}
\ASSUMPTIONS{Nonnegative weights ensure Dijkstra correctness.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a graph with nodes $(i,0)$ for stairs-mode and $(i,1)$ for elevator-mode for each floor $i$.
\item Add edges of weight $a_i$ between $(i,0)\leftrightarrow(i+1,0)$; edges of weight $b_i$ between $(i,1)\leftrightarrow(i+1,1)$.
\item Add edges of weight $c$ from $(i,0)\to(i,1)$ (boarding) and $0$ from $(i,1)\to(i,0)$ (exiting).
\item Run Dijkstra from $(1,0)$ with initial distance $0$; record $t_i=\min(\text{dist}(i,0),\text{dist}(i,1))$.
\end{algosteps}
\COMPLEXITY{With $2n$ nodes and $O(n)$ edges, Dijkstra runs in $O(n \log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O((2n + O(n))\log(2n)) = O(n \log n), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{The two-layer graph exactly models costs: moving within a mode accumulates $a_i$ or $b_i$, boarding costs $c$, exiting is free. Shortest path distances to $(i,0)$ and $(i,1)$ give $S_i$ and $E_i$. Minimum yields $t_i$.}
\EDGECASES{Small $n=2$; very large $c$ (never board); very small $c$ (board immediately); equal $a_i$ and $b_i$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, heapq

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return None
    c = int(next(it))
    a = [int(next(it)) for _ in range(n-1)]
    b = [int(next(it)) for _ in range(n-1)]
    return n, c, a, b

def solve_case(n, c, a, b):
    # Build 2-layer graph: node id mapping: (i, mode) -> idx
    # idx = (i-1)*2 + mode ; i in [1..n], mode in {0: stairs, 1: elevator}
    N = n * 2
    g = [[] for _ in range(N)]
    def idx(i, mode):
        return (i-1)*2 + mode
    # Add edges between adjacent floors for stairs and elevator
    for i in range(1, n):
        # stairs edges
        u = idx(i, 0); v = idx(i+1, 0)
        g[u].append((v, a[i-1])); g[v].append((u, a[i-1]))
        # elevator edges
        ue = idx(i, 1); ve = idx(i+1, 1)
        g[ue].append((ve, b[i-1])); g[ve].append((ue, b[i-1]))
    # Add mode-switch edges at each floor
    for i in range(1, n+1):
        u0 = idx(i, 0); u1 = idx(i, 1)
        g[u0].append((u1, c))  # board elevator
        g[u1].append((u0, 0))  # exit elevator
    # Dijkstra from (1, stairs)
    INF = 10**30
    dist = [INF]*N
    start = idx(1, 0)
    dist[start] = 0
    pq = [(0, start)]
    while pq:
        d, u = heapq.heappop(pq)
        if d != dist[u]:
            continue
        for v, w in g[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                heapq.heappush(pq, (nd, v))
    ans = []
    for i in range(1, n+1):
        ans.append(min(dist[idx(i,0)], dist[idx(i,1)]))
    return ans

def solve_all():
    tpl = read_input()
    if tpl is None:
        return
    n, c, a, b = tpl
    res = solve_case(n, c, a, b)
    print(" ".join(str(x) for x in res))

def _unit_tests():
    # Sample 1
    n, c = 3, 1
    a = [1,1]; b = [2,2]
    assert solve_case(n, c, a, b) == [0,1,2]
    # Sample 2
    n, c = 5, 3
    a = [4,1,4,1]; b = [1,3,1,3]
    assert solve_case(n, c, a, b) == [0,4,5,8,9]
    # Edge small
    n, c = 2, 1000
    a = [1]; b = [1]
    assert solve_case(n, c, a, b) == [0,1]

if __name__ == "__main__":
    _unit_tests()
    solve_all()
\end{minted}
\VALIDATION{Checked two crafted examples and a degenerate case with $n=2$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Collapse Dijkstra to a linear DP using the two-state recurrence:
\begin{BreakableEquation*}
S_i = \min(S_{i-1},E_{i-1}) + a_{i-1},\quad E_i = \min(E_{i-1} + b_{i-1}, S_{i-1} + c + b_{i-1}).
\end{BreakableEquation*}
This exploits the line structure and nonnegative additivity.}
\ASSUMPTIONS{Boarding cost $c$ applies only when entering elevator; exiting is free; costs are nonnegative.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $S_1=0$, $E_1=c$, answer $t_1=0$.
\item For $i=2$ to $n$, update $S_i$ and $E_i$ by the recurrence above.
\item Output $t_i=\min(S_i,E_i)$ for each $i$.
\end{algosteps}
\COMPLEXITY{Single forward pass on arrays of size $n$.}
\[
\begin{aligned}
T(n) &= \Theta(n), \\
S(n) &= \Theta(1) \text{ extra (besides input and output arrays)}.
\end{aligned}
\]
\CORRECTNESS{The recurrence captures all optimal strategies: the last step to floor $i$ is via stairs or elevator. Starting an elevator segment exactly adds $c$, continuing does not. Due to additivity and nonnegativity, skipping floors is never beneficial; thus considering only adjacent transitions is sufficient.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return None
    c = int(next(it))
    a = [int(next(it)) for _ in range(n-1)]
    b = [int(next(it)) for _ in range(n-1)]
    return n, c, a, b

def solve_case(n, c, a, b):
    S = 0  # S_1
    E = c  # E_1
    ans = [0]*n
    ans[0] = 0
    for i in range(2, n+1):
        ai = a[i-2]
        bi = b[i-2]
        newS = min(S, E) + ai
        newE = min(E + bi, S + c + bi)
        S, E = newS, newE
        ans[i-1] = min(S, E)
    return ans

def solve_all():
    tpl = read_input()
    if tpl is None:
        return
    n, c, a, b = tpl
    res = solve_case(n, c, a, b)
    print(" ".join(str(x) for x in res))

def _unit_tests():
    # Compare with baseline logic on small examples
    def baseline(n, c, a, b):
        # Small Dijkstra explicitly
        import heapq
        N = n*2
        g = [[] for _ in range(N)]
        def idx(i, mode): return (i-1)*2 + mode
        for i in range(1, n):
            u = idx(i,0); v = idx(i+1,0)
            g[u].append((v,a[i-1])); g[v].append((u,a[i-1]))
            ue = idx(i,1); ve = idx(i+1,1)
            g[ue].append((ve,b[i-1])); g[ve].append((ue,b[i-1]))
        for i in range(1, n+1):
            u0 = idx(i,0); u1 = idx(i,1)
            g[u0].append((u1,c)); g[u1].append((u0,0))
        INF = 10**18
        dist = [INF]*N
        s = idx(1,0); dist[s]=0
        pq=[(0,s)]
        while pq:
            d,u = heapq.heappop(pq)
            if d!=dist[u]: continue
            for v,w in g[u]:
                nd = d+w
                if nd<dist[v]:
                    dist[v]=nd; heapq.heappush(pq,(nd,v))
        return [min(dist[idx(i,0)], dist[idx(i,1)]) for i in range(1,n+1)]
    # Randomized small tests
    import random
    random.seed(0)
    for _ in range(50):
        n = random.randint(2, 12)
        c = random.randint(1, 6)
        a = [random.randint(1, 6) for _ in range(n-1)]
        b = [random.randint(1, 6) for _ in range(n-1)]
        assert solve_case(n,c,a,b) == baseline(n,c,a,b)
    # Given examples
    assert solve_case(3,1,[1,1],[2,2]) == [0,1,2]
    assert solve_case(5,3,[4,1,4,1],[1,3,1,3]) == [0,4,5,8,9]

if __name__ == "__main__":
    _unit_tests()
    solve_all()
\end{minted}
\VALIDATION{Cross-checked against a baseline Dijkstra on dozens of random small cases; matched provided examples.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Stream the two-state DP in $O(1)$ memory, emitting answers as you go. This is optimal for a line with additive weights and a single switching overhead.}
\ASSUMPTIONS{Nonnegative $a_i, b_i, c$. Answer for floor $i$ depends only on floor $i-1$ states.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize running states $S=0$, $E=c$ and print $0$ for floor $1$.
\item For $i=2..n$, update $S, E$ via the recurrence and output $\min(S,E)$ immediately.
\item Use only $O(1)$ extra memory beyond input arrays.
\end{algosteps}
\OPTIMALITY{A matching lower bound $\Omega(n)$ holds for reading the input. The DP achieves $O(n)$ time and $O(1)$ extra space, which is optimal up to constant factors.}
\COMPLEXITY{One pass, constant memory.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n) = \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return None
    c = int(next(it))
    a = [int(next(it)) for _ in range(n-1)]
    b = [int(next(it)) for _ in range(n-1)]
    return n, c, a, b

def solve_case(n, c, a, b):
    S = 0  # best time at floor 1 when not in elevator
    E = c  # best time at floor 1 when in elevator
    ans = [0]*n
    ans[0] = 0
    for i in range(2, n+1):
        ai = a[i-2]
        bi = b[i-2]
        S, E = min(S, E) + ai, min(E + bi, S + c + bi - ai)  # careful: S on RHS is old S; we used ai; restore old S
        # The above line mixed updated S into E; fix by computing with temporaries
        # Let's rewrite correctly:
    # Recompute correctly:
def solve_case(n, c, a, b):
    S = 0
    E = c
    ans = [0]*n
    ans[0] = 0
    for i in range(2, n+1):
        ai = a[i-2]
        bi = b[i-2]
        newS = min(S, E) + ai
        newE = min(E + bi, S + c + bi)
        S, E = newS, newE
        ans[i-1] = min(S, E)
    return ans

def solve_all():
    tpl = read_input()
    if tpl is None:
        return
    n, c, a, b = tpl
    res = solve_case(n, c, a, b)
    print(" ".join(str(x) for x in res))

def _unit_tests():
    # Exactly 3 asserts
    assert solve_case(3,1,[1,1],[2,2]) == [0,1,2]
    assert solve_case(2,5,[3],[2]) == [0,3]
    assert solve_case(5,3,[4,1,4,1],[1,3,1,3]) == [0,4,5,8,9]

if __name__ == "__main__":
    _unit_tests()
    solve_all()
\end{minted}
\VALIDATION{Three direct asserts on small inputs.}
\RESULT{For each floor $i$, output the minimal total time from floor $1$, separated by spaces; $t_1=0$ always.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for correctness on hand-crafted cases; randomized small-case cross-check against Dijkstra; boundary checks for $n=2$, extreme $c$, and equal costs.}
\LINE{CROSS-CHECKS}{Compare Approach B DP vs Approach A Dijkstra on random small instances; they must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with $n$ in $[2,12]$, $c$ and $a_i,b_i$ in small ranges to fully enumerate diverse patterns; verify DP equals Dijkstra.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random, heapq

def gen_case(n, cmax=6, vmax=6, seed=0):
    random.seed(seed)
    c = random.randint(1, cmax)
    a = [random.randint(1, vmax) for _ in range(n-1)]
    b = [random.randint(1, vmax) for _ in range(n-1)]
    return c, a, b

def dijkstra_ref(n, c, a, b):
    N = n*2
    g = [[] for _ in range(N)]
    def idx(i, mode): return (i-1)*2 + mode
    for i in range(1, n):
        u = idx(i,0); v = idx(i+1,0)
        g[u].append((v,a[i-1])); g[v].append((u,a[i-1]))
        ue = idx(i,1); ve = idx(i+1,1)
        g[ue].append((ve,b[i-1])); g[ve].append((ue,b[i-1]))
    for i in range(1, n+1):
        u0 = idx(i,0); u1 = idx(i,1)
        g[u0].append((u1,c)); g[u1].append((u0,0))
    INF = 10**18
    dist = [INF]*N
    s = idx(1,0); dist[s]=0
    pq=[(0,s)]
    while pq:
        d,u = heapq.heappop(pq)
        if d!=dist[u]: continue
        for v,w in g[u]:
            nd = d+w
            if nd < dist[v]:
                dist[v]=nd; heapq.heappush(pq,(nd,v))
    return [min(dist[idx(i,0)], dist[idx(i,1)]) for i in range(1,n+1)]

def dp_solve(n, c, a, b):
    S, E = 0, c
    ans = [0]*n
    ans[0]=0
    for i in range(2, n+1):
        ai = a[i-2]; bi = b[i-2]
        newS = min(S, E) + ai
        newE = min(E + bi, S + c + bi)
        S, E = newS, newE
        ans[i-1] = min(S, E)
    return ans

# Cross-check suite
def cross_check():
    # Fixed samples
    assert dp_solve(3,1,[1,1],[2,2]) == [0,1,2]
    assert dp_solve(5,3,[4,1,4,1],[1,3,1,3]) == [0,4,5,8,9]
    # Randomized
    for seed in range(50):
        n = 2 + (seed % 11)
        c, a, b = gen_case(n, seed=seed)
        assert dp_solve(n,c,a,b) == dijkstra_ref(n,c,a,b)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        n = int(next(it))
    except StopIteration:
        return None
    c = int(next(it))
    a = [int(next(it)) for _ in range(n-1)]
    b = [int(next(it)) for _ in range(n-1)]
    return n, c, a, b

def solve_case(n, c, a, b):
    S = 0
    E = c
    ans = [0]*n
    ans[0] = 0
    for i in range(2, n+1):
        ai = a[i-2]
        bi = b[i-2]
        newS = min(S, E) + ai
        newE = min(E + bi, S + c + bi)
        S, E = newS, newE
        ans[i-1] = min(S, E)
    return ans

def solve_all():
    tpl = read_input()
    if tpl is None:
        return
    n, c, a, b = tpl
    res = solve_case(n, c, a, b)
    print(" ".join(str(x) for x in res))

def _unit_tests():
    # Sanity tests
    assert solve_case(3,1,[1,1],[2,2]) == [0,1,2]
    assert solve_case(2,1000,[1],[1]) == [0,1]
    assert solve_case(5,3,[4,1,4,1],[1,3,1,3]) == [0,4,5,8,9]

if __name__ == "__main__":
    _unit_tests()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Two-state DP over floors: keep best time when not in elevator and when in elevator; update with $a_{i-1}$ and $b_{i-1}$ plus optional $c$.}
\WHY{Shows up in interviews as a mode-switch DP or as a shortest path on a layered graph; tests modeling and translating to linear-time DP.}
\CHECKLIST{
\begin{bullets}
\item Define states $S_i$ and $E_i$ clearly.
\item Initialize $S_1=0$, $E_1=c$.
\item Update $S_i=\min(S_{i-1},E_{i-1})+a_{i-1}$.
\item Update $E_i=\min(E_{i-1}+b_{i-1},\,S_{i-1}+c+b_{i-1})$.
\item Output $t_i=\min(S_i,E_i)$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=2$ minimal instance.
\item Very large $c$ so elevator is never beneficial.
\item Very small $c$ so boarding early is best.
\item $a_i=b_i$ all equal.
\item Highly alternating $a_i$ and $b_i$.
\item All $b_i \ll a_i$ so elevator dominates after paying $c$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Double-counting $c$ when staying in elevator across multiple floors.
\item Forgetting that exiting the elevator is free.
\item Off-by-one: using $a_i$ and $b_i$ aligned to step from $i$ to $i+1$.
\item Printing $t_1$ as nonzero; it must be $0$.
\item Overflow if using too small integer types (use Python int or 64-bit).
\item Building an $O(n^2)$ graph unnecessarily; line structure allows $O(n)$ DP.
\end{bullets}
}
\FAILMODES{Greedy per-floor choice of stair vs elevator without carrying the elevator state fails when boarding now enables cheaper future moves; the two-state DP avoids this by remembering whether you are already in elevator.}
\ELI{Track two possibilities as you go up: are you in the elevator or not? Update both times with the costs of moving one floor and taking or skipping the one-time elevator fee when you board. The minimum of these two is always the best time to each floor.}
\NotePages{3}

\end{document}