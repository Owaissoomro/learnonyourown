% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — The kth Factor of n}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/the-kth-factor-of-n/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given two positive integers \texttt{n} and \texttt{k}. A factor of an integer \texttt{n} is defined as an integer \texttt{i} where \texttt{n \% i == 0}. Consider a list of all factors of \texttt{n} sorted in \textbf{ascending order}, return the \texttt{kth} factor in this list or return \texttt{-1} if \texttt{n} has less than \texttt{k} factors.

Examples:

1) Input: \texttt{n = 12, k = 3}. Output: \texttt{3}. Explanation: Factors list is \texttt{[1, 2, 3, 4, 6, 12]}, the 3rd factor is 3.

2) Input: \texttt{n = 7, k = 2}. Output: \texttt{7}. Explanation: Factors list is \texttt{[1, 7]}, the 2nd factor is 7.

3) Input: \texttt{n = 4, k = 4}. Output: \texttt{-1}. Explanation: Factors list is \texttt{[1, 2, 4]}, there are only 3 factors; return \texttt{-1}.

Constraints: \texttt{1 <= k <= n <= 1000}.

Follow up: Could you solve this problem in less than $O(n)$ complexity?}
\BREAKDOWN{Generate divisors of $n$ in sorted order and select the $k$th, or determine that fewer than $k$ divisors exist. Optimize from scanning all $1 \ldots n$ to scanning only up to $\lfloor \sqrt{n} \rfloor$ by pairing divisors.}
\ELI{Every divisor $i$ below $\sqrt{n}$ pairs with $n/i$ above $\sqrt{n}$; count in order and pick the $k$th.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers: $n$ and $k$ with $1 \le k \le n \le 1000$.}
\OUTPUTS{Return the $k$th smallest positive divisor of $n$ if it exists; otherwise return $-1$.}
\SAMPLES{Example A: $n=12,k=3 \Rightarrow 3$. Example B: $n=4,k=4 \Rightarrow -1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $D(n)=\{d\in\mathbb{Z}_{>0}\mid d\mid n\}$ and let $(d_1<d_2<\cdots<d_m)$ be $D(n)$ sorted ascending. We seek $d_k$ if $k\le m$, else $-1$.}
\varmapStart
\var{n}{given positive integer}
\var{k}{desired rank in ascending order of divisors}
\var{D(n)}{multiset of positive divisors of $n$}
\var{m}{number of divisors of $n$}
\var{\lfloor \sqrt{n} \rfloor}{largest integer $r$ with $r^2 \le n$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
D(n) &= \{\, d \in \mathbb{Z}_{>0} : \exists q \in \mathbb{Z}_{>0},~ n = d\cdot q \,\}, \\
(d_1,\ldots,d_m) &= \text{sorted}(D(n)), \\
\text{ans}(n,k) &= \begin{cases}
d_k, & 1 \le k \le m,\\
-1, & k>m~.
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{Standard integer arithmetic; divisibility is exact with no remainder. If $i \mid n$ and $i \le \sqrt{n}$, then $n/i \ge \sqrt{n}$ and is also a divisor. If $i^2=n$ we must not double-count $i$.}
\INVARIANTS{Counting divisors in increasing $i$ from $1$ to $\lfloor \sqrt{n} \rfloor$ yields them in ascending order for the first half. The complementary divisors $n/i$ enumerated with $i$ decreasing produce the second half in ascending order, skipping the square root when $i^2=n$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly scan all $i\in\{1,\ldots,n\}$; if $i\mid n$ increment a counter; return the $i$ where the counter hits $k$.}
\ASSUMPTIONS{None beyond constraints; $n\le 1000$ makes $O(n)$ trivial.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $c\gets 0$.
\item For $i=1$ to $n$: if $n \bmod i=0$, set $c\gets c+1$; if $c=k$, return $i$.
\item If loop ends, return $-1$.
\end{algosteps}
\COMPLEXITY{$T(n)=\Theta(n)$ trials of divisibility; $S(n)=\Theta(1)$ auxiliary space.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} 1 = n, \\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{The scan visits candidates in ascending order and counts exactly those dividing $n$. The $k$th such visit is the $k$th smallest divisor by construction.}
\EDGECASES{$k=1$ returns $1$; prime $n$ has exactly two divisors; if $k>m$ return $-1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LeetCode LC 1492 — The kth Factor of n
# Baseline: O(n) scan

class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        count = 0
        for i in range(1, n + 1):
            if n % i == 0:
                count += 1
                if count == k:
                    return i
        return -1

# Basic asserts (examples and a few edges)
s = Solution()
assert s.kthFactor(12, 3) == 3
assert s.kthFactor(7, 2) == 7
assert s.kthFactor(4, 4) == -1
assert s.kthFactor(1, 1) == 1
assert s.kthFactor(2, 1) == 1 and s.kthFactor(2, 2) == 2 and s.kthFactor(2, 3) == -1
\end{minted}
\VALIDATION{Checked examples; single-element case $n=1$; small primes and composites.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Divisor Pairing}
\WHICHFORMULA{Scan only up to $\lfloor \sqrt{n} \rfloor$ to collect ``small'' divisors; their complements $n/i$ yield the ``large'' divisors in reverse order.}
\ASSUMPTIONS{Use integer square root; take care to skip the duplicate when $i^2=n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build list $S=[\,i: 1\le i\le \lfloor \sqrt{n} \rfloor,~ i\mid n\,]$.
\item If $k\le |S|$, return $S[k-1]$.
\item Set $k'\gets k-|S|$. Iterate $i$ over $S$ in reverse, compute $j=n/i$; if $j\ne i$, decrement $k'$ and when $k'=0$, return $j$.
\item If exhausted, return $-1$.
\end{algosteps}
\COMPLEXITY{Building $S$ costs $O(\sqrt{n})$, and the reverse pass costs up to $|S| \le \sqrt{n}$. Overall $T(n)=O(\sqrt{n})$, $S(n)=O(\sqrt{n})$.}
\[
\begin{aligned}
T(n) &= O(\lfloor \sqrt{n} \rfloor) + O(|S|) = O(\sqrt{n})~. \\
\end{aligned}
\]
\CORRECTNESS{Small divisors are in ascending order; large complements enumerated from larger $i$ to smaller yield ascending large divisors. Skipping the square root avoids double counting in perfect squares.}
\textbf{Code (Improved)}
\begin{minted}{python}
# LeetCode LC 1492 — Improved: O(sqrt(n)) with small list + reverse complements

import math

class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        small = []
        r = math.isqrt(n)
        for i in range(1, r + 1):
            if n % i == 0:
                small.append(i)
        if k <= len(small):
            return small[k - 1]
        k -= len(small)
        for i in range(len(small) - 1, -1, -1):
            j = n // small[i]
            if j == small[i]:
                continue  # skip duplicate when i*i == n
            k -= 1
            if k == 0:
                return j
        return -1

# Asserts mirroring baseline plus more
s = Solution()
assert s.kthFactor(12, 1) == 1
assert s.kthFactor(12, 3) == 3
assert s.kthFactor(12, 6) == 12
assert s.kthFactor(4, 3) == 4 and s.kthFactor(4, 4) == -1  # perfect square handling
\end{minted}
\VALIDATION{Validated the middle element in a perfect square and first/last factor positions.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two-Pass, Zero-Allocation Counting}
\WHICHFORMULA{Count up to $\lfloor \sqrt{n} \rfloor$ and return immediately if the $k$th is within the small half; otherwise, continue counting complements from $\lfloor \sqrt{n} \rfloor$ down to $1$, skipping the duplicate when $i^2=n$.}
\ASSUMPTIONS{Integer square root exists; divisors pair uniquely across $\sqrt{n}$ except at the square root.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $r=\lfloor \sqrt{n} \rfloor$, $c\gets 0$.
\item For $i=1$ to $r$: if $i\mid n$, set $c\gets c+1$; if $c=k$, return $i$.
\item For $i=r$ down to $1$: if $i\mid n$ and $i\ne n/i$, set $c\gets c+1$; if $c=k$, return $n/i$.
\item Otherwise return $-1$.
\end{algosteps}
\OPTIMALITY{Any algorithm must examine at least all divisors or rule out non-divisors up to $\sqrt{n}$ to distinguish primes from composites; thus $O(\sqrt{n})$ is information-theoretically tight for worst-case $n$.}
\COMPLEXITY{$T(n)=\Theta(\sqrt{n})$ divisor tests, $S(n)=\Theta(1)$ auxiliary space.}
\[
\begin{aligned}
T(n) &= \underbrace{\sum_{i=1}^{\lfloor \sqrt{n} \rfloor} 1}_{\text{first pass}} + \underbrace{\sum_{i=1}^{\lfloor \sqrt{n} \rfloor} 1}_{\text{second pass}} = O(\sqrt{n})~. \\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# LeetCode LC 1492 — Optimal O(sqrt(n)) time, O(1) extra space

import math

class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        r = math.isqrt(n)
        count = 0
        # First half (ascending small factors)
        for i in range(1, r + 1):
            if n % i == 0:
                count += 1
                if count == k:
                    return i
        # Second half (ascending large factors via descending i)
        for i in range(r, 0, -1):
            if n % i == 0:
                j = n // i
                if j != i:  # skip duplicate when i*i == n
                    count += 1
                    if count == k:
                        return j
        return -1

# Exactly 3 asserts
s = Solution()
assert s.kthFactor(12, 5) == 6
assert s.kthFactor(36, 6) == 9  # perfect square mid-skip correctness
assert s.kthFactor(97, 3) == -1  # prime larger k
\end{minted}
\VALIDATION{Three targeted checks: middle of second half, perfect square handling, and infeasible $k$ on a prime.}
\RESULT{Returns the $k$th smallest factor if it exists; otherwise returns $-1$. Ties cannot occur because divisors are unique and totally ordered.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify against brute force for many small $n$, random $k$, and edge cases including perfect squares, primes, and $k$ out of range.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Optimal on a grid of inputs; any mismatch indicates an ordering or duplicate handling bug.}
\LINE{EDGE-CASE GENERATOR}{Generate $n$ across $\{1,\ldots,200\}$, with $k\in\{1,m, m+1\}$ where $m$ is the number of divisors, and several random $k$ within range.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

def brute_kth_factor(n: int, k: int) -> int:
    facts = [i for i in range(1, n + 1) if n % i == 0]
    return facts[k - 1] if 1 <= k <= len(facts) else -1

import math

class SolutionRef:
    def kthFactor(self, n: int, k: int) -> int:
        r = math.isqrt(n)
        count = 0
        for i in range(1, r + 1):
            if n % i == 0:
                count += 1
                if count == k:
                    return i
        for i in range(r, 0, -1):
            if n % i == 0:
                j = n // i
                if j != i:
                    count += 1
                    if count == k:
                        return j
        return -1

def run_grid():
    sol = SolutionRef()
    for n in range(1, 201):
        # test k in-range, out-of-range, and random picks
        divs = [i for i in range(1, n + 1) if n % i == 0]
        m = len(divs)
        tests = set([1, 2, m, m + 1])
        # a few spaced ks
        for t in range(1, m + 1, max(1, m // 3)):
            tests.add(t)
        for k in sorted(tests):
            assert sol.kthFactor(n, k) == brute_kth_factor(n, k)
    return True

assert run_grid()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference implementation (LC signature) + basic asserts

import math

class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        r = math.isqrt(n)
        count = 0
        for i in range(1, r + 1):
            if n % i == 0:
                count += 1
                if count == k:
                    return i
        for i in range(r, 0, -1):
            if n % i == 0:
                j = n // i
                if j != i:
                    count += 1
                    if count == k:
                        return j
        return -1

# Smoke tests
s = Solution()
assert s.kthFactor(1, 1) == 1
assert s.kthFactor(1000, 1) == 1
assert s.kthFactor(28, 6) == 28
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the $k$th smallest divisor of $n$ efficiently by pairing factors around $\sqrt{n}$.}
\WHY{Divisor-ordering and square-root scans are common in interviews for optimizing factor-related tasks.}
\CHECKLIST{
\begin{bullets}
\item Compute $r=\lfloor \sqrt{n} \rfloor$.
\item Count divisors for $i=1\ldots r$ and return early if $k$ is reached.
\item Walk $i=r\ldots 1$ and return complements $n/i$, skipping when $i^2=n$.
\item If none matched, return $-1$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1,k=1 \Rightarrow 1$.
\item Prime $n$: only two factors; $k>2 \Rightarrow -1$.
\item Perfect square: avoid double counting $\sqrt{n}$.
\item $k=1$: always $1$.
\item $k$ equals number of divisors: must return $n$.
\item $k$ out of range: return $-1$.
\item $n$ even vs odd: parity influences number of small divisors.
\item $n$ just below/above a square (e.g., $15,16,17$).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to skip $i^2=n$ in the second pass causes duplication.
\item Building complements in the wrong order yields descending outputs.
\item Off-by-one in $k$ indexing ($k-1$ vs $k$).
\item Using floating square root can introduce rounding error; prefer integer square root.
\item Returning $n/i$ in the first pass by mistake.
\item Not handling $k$ larger than total divisors.
\item Excess memory by storing all divisors when unnecessary.
\item Early return conditions placed after increment logic incorrectly.
\end{bullets}
}
\FAILMODES{Brute force $O(n)$ is fine for $n\le 1000$ but fails follow-up; naive storage of all divisors risks ordering mistakes. The two-pass method remains correct and fast.}
\ELI{Check numbers up to the square root for exact division. If we have not found the $k$th factor by then, walk back down and use pairs to produce the larger factors in order, skipping the square root if it repeats.}
\NotePages{3}

\end{document}