% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Access Levels}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1765/A}}
\LINE{DIFFICULTY / RATING}{Platform: CF \textbar{} CF: 1765/A \textbar{} Rating: 2400}
\STATEMENT{BerSoft is the biggest IT corporation in Berland, and Monocarp is the head of its security department. This time, he faced the most difficult task ever.

Basically, there are $n$ developers working at BerSoft, numbered from $1$ to $n$. There are $m$ documents shared on the internal network, numbered from $1$ to $m$. There is a table of access requirements $a$ such that $a_{i,j}$ (the $j$-th element of the $i$-th row) is $1$ if the $i$-th developer should have access to the $j$-th document, and $0$ if they should have no access to it.

In order to restrict the access, Monocarp is going to perform the following actions:
\begin{itemize}
\item choose the number of access groups $k \ge 1$;
\item assign each document an access group (an integer from $1$ to $k$) and the required access level (an integer from $1$ to $10^9$);
\item assign each developer $k$ integer values (from $1$ to $10^9$) — their access levels for each of the access groups.
\end{itemize}

The developer $i$ has access to the document $j$ if their access level for the access group of the document is greater than or equal to the required access level of the document.

What is the smallest number of access groups Monocarp can choose so that it is possible to assign access groups and access levels in order to satisfy the table of access requirements?

Input:
The first line contains two integers $n$ and $m$ ($1 \le n, m \le 500$) — the number of developers and the number of documents.

Each of the next $n$ lines contains a binary string of length $m$ — the table of access requirements. The $j$-th element of the $i$-th row is $1$ if the $i$-th developer should have access to the $j$-th document, and $0$ if they should have no access to it.

Output:
The first line should contain a single integer $k$ — the smallest number of access groups Monocarp can choose so that it is possible to assign access groups and access levels in order to satisfy the table of access requirements.

The second line should contain $m$ integers from $1$ to $k$ — the access groups of the documents.

The third line should contain $m$ integers from $1$ to $10^9$ — the required access levels of the documents.

The $i$-th of the next $n$ lines should contain $k$ integers from $1$ to $10^9$ — the access level of the $i$-th developer on each of the access groups.

If there are multiple solutions, print any of them.

Note:
In the first example, we assign the documents to different access groups. Both documents have level $2$ in their access group. This way, we can assign the developers, who need the access, level $2$, and the developers, who have to have no access, level $1$.

If they had the same access group, it would be impossible to assign access levels to developers $1$ and $3$. Developer $1$ should have had a lower level than developer $3$ in this group to not be able to access document $1$. At the same time, developer $3$ should have had a lower level than developer $1$ in this group to not be able to access document $2$. Since they cannot both have lower level than each other, it is impossible to have only one access group.

In the second example, it is possible to assign all documents to the same access group.}
\BREAKDOWN{Interpret each document column as a subset of developers. Within any single access group, all document subsets must be nested (totally ordered by inclusion) because a common per-group ranking with thresholds yields suffix sets. Thus we need the minimum number of chains to cover all columns under the inclusion partial order.}
\ELI{Group documents so that, within each group, the people who can access each document form a nested sequence; the fewest such groups equals the size of the largest set of mutually incomparable documents.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m$ with $1 \le n, m \le 500$; then $n$ binary strings of length $m$. Row $i$'s character $j$ is $a_{i,j} \in \{0,1\}$.}
\OUTPUTS{Print $k$ (minimal groups). Then $m$ integers in $[1,k]$ assigning each document to a group. Then $m$ required levels in $[1,10^9]$. Then $n$ lines, each with $k$ developer levels in $[1,10^9]$. The printed assignment must exactly realize the matrix: $a_{i,j}=1$ iff developer $i$'s level for document $j$'s group is at least the required level of document $j$.}
\SAMPLES{Example 1:
\begin{itemize}
\item Input:
\begin{verbatim}
3 2
10
01
10
\end{verbatim}
One valid minimal solution has $k=2$ (the two document columns are incomparable).
\end{itemize}
Example 2:
\begin{itemize}
\item Input:
\begin{verbatim}
3 3
111
111
111
\end{verbatim}
All documents can share one group, so $k=1$ is achievable.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $[n]=\{1,\ldots,n\}$ be developers and $[m]=\{1,\ldots,m\}$ documents. Define for each document $j$ the subset $S_j \subseteq [n]$ where $i \in S_j$ iff $a_{i,j}=1$. A group corresponds to a total order (ranking) $\prec$ on $[n]$ and per-document thresholds; in such a group the realized access sets are suffixes of $\prec$, hence are nested by inclusion. We must partition $\{S_j\}_{j=1}^m$ into the minimum number $k$ of chains under $\subseteq$.}
\varmapStart
\var{S_j}{set of developers that should access document $j$}
\var{\preceq}{partial order on documents: $j \preceq \ell$ iff $S_j \subseteq S_\ell$}
\var{k}{minimum number of chains that cover all documents under $\preceq$}
\var{\nu}{maximum matching size in the bipartite graph from Dilworth reduction}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{By Dilworth's theorem:}\quad k=\text{width}(\preceq)=\min\{\#\text{chains covering all }j\} = m - \nu,
\end{BreakableEquation*}
where $\nu$ is the size of a maximum matching in the bipartite graph on two copies of $[m]$ with an edge $j \to \ell$ iff $S_j \subseteq S_\ell$ and ($S_j \ne S_\ell$ or $j<\ell$) to break ties.
}
\ASSUMPTIONS{We allow equal columns; they are comparable and can be placed within one chain. Tie direction $j<\ell$ for equal sets ensures acyclicity in the reduction.}
\INVARIANTS{
\begin{itemize}
\item Within a group, document columns are totally ordered by inclusion.
\item A chain of sets $S_1 \supseteq S_2 \supseteq \cdots$ can be realized by a single developer ranking and per-document thresholds.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Assign each document to its own group: $k=m$. Then realize each column independently by using two levels.}
\ASSUMPTIONS{No optimization; always feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set $k \leftarrow m$, group of document $j$ is $j$.
\item Set each document level to $2$.
\item For each developer $i$ and document $j$: set the developer's level in group $j$ to $2$ if $a_{i,j}=1$, else $1$.
\end{algosteps}
\COMPLEXITY{Time $T(n,m)=\Theta(nm)$; space $S(n,m)=\Theta(nm)$ to print the matrix of levels.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm), \quad
S(n,m) = \Theta(nm).
\end{aligned}
\]
\CORRECTNESS{For document $j$, only the per-group $j$ level matters. With required level $2$, exactly those developers with level $2$ (set by $a_{i,j}=1$) will access it.}
\EDGECASES{Works for any $n,m \ge 1$, including all-zero or all-one columns.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
        m = int(next(it))
    except StopIteration:
        return None
    grid = []
    for _ in range(n):
        s = list(next(it).strip())
        assert len(s) == m
        grid.append(s)
    return n, m, grid

def solve_case_baseline(n, m, grid):
    k = m
    doc_group = list(range(1, m + 1))
    doc_level = [2] * m
    dev_levels = [[1] * k for _ in range(n)]
    for i in range(n):
        for j in range(m):
            dev_levels[i][j] = 2 if grid[i][j] == '1' else 1
    return k, doc_group, doc_level, dev_levels

def print_solution(n, m, k, doc_group, doc_level, dev_levels, out):
    print(k, file=out)
    print(" ".join(map(str, doc_group)), file=out)
    print(" ".join(map(str, doc_level)), file=out)
    for i in range(n):
        print(" ".join(map(str, dev_levels[i])), file=out)

def simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels):
    # Verify that for each (i,j), access matches grid
    for j in range(m):
        g = doc_group[j] - 1
        req = doc_level[j]
        for i in range(n):
            have = 1 if dev_levels[i][g] >= req else 0
            want = 1 if grid[i][j] == '1' else 0
            if have != want:
                return False
    return True

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    n, m, grid = parsed
    k, doc_group, doc_level, dev_levels = solve_case_baseline(n, m, grid)
    print_solution(n, m, k, doc_group, doc_level, dev_levels, sys.stdout)

def _run_io(inp: str, func):
    from io import StringIO
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    sys.stdin, sys.stdout = StringIO(inp), StringIO()
    try:
        func()
        out = sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout
    return out

if __name__ == "__main__":
    # Tiny asserts (unit checks)
    n, m, grid = 2, 2, [list("10"), list("01")]
    k, doc_group, doc_level, dev_levels = solve_case_baseline(n, m, grid)
    assert k == m
    assert simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels)

    n, m, grid = 3, 1, [list("1"), list("0"), list("1")]
    k, doc_group, doc_level, dev_levels = solve_case_baseline(n, m, grid)
    assert simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels)

    # I/O smoke test
    out = _run_io("3 2\n10\n01\n10\n", solve_all)
    assert out.strip().splitlines()[0].isdigit()
\end{minted}
\VALIDATION{Checked via simulation that the printed assignment reproduces the matrix on small cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy Chain Packing by Inclusion}
\WHICHFORMULA{Sort documents by decreasing $|S_j|$ and greedily place each into the first group whose last document has a superset of its set; otherwise open a new group. This respects nesting within each group.}
\ASSUMPTIONS{Greedy chain cover in a partially ordered set may not be optimal, but often reduces groups substantially versus the baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Convert columns to bit masks $S_j$.
\item Sort documents by nonincreasing $|S_j|$, breaking ties by index.
\item Maintain groups, each tracking the last set in its chain. Place a document into the first group whose last set is a superset; else start a new group.
\item After groups are formed, assign levels per group using a single ranking and thresholds (as in the optimal approach) to realize nested sets.
\end{algosteps}
\COMPLEXITY{Sorting $O(m \log m)$; each placement checks at most $k$ groups, worst $O(mk) \le O(m^2)$. Level assignment $O(nm)$. Overall $O(m^2 + nm)$.}
\[
\begin{aligned}
T(n,m) &= O(m^2 + nm) \\
\end{aligned}
\]
\CORRECTNESS{Within each group, sets are nested by construction, so a per-group ranking with thresholds realizes them. The number of groups is not guaranteed minimal.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return None
    grid = []
    for _ in range(n):
        s = list(next(it).strip())
        assert len(s) == m
        grid.append(s)
    return n, m, grid

def build_masks(n, m, grid):
    masks = [0] * m
    for j in range(m):
        mask = 0
        for i in range(n):
            if grid[i][j] == '1':
                mask |= (1 << i)
        masks[j] = mask
    return masks

def realize_chain_group(n, chain_docs, masks):
    # chain_docs ordered by decreasing inclusion
    t = len(chain_docs)
    Ms = [masks[j] for j in chain_docs]  # M0 ⊇ M1 ⊇ ...
    # Per-developer bucket as described
    # bucket 0: outside all; bucket b in 1..t: D_{t-b+1}
    in_M0 = Ms[0]
    Lidx = [-1] * n  # last index s where dev in Ms[s]
    for s in range(t):
        M = Ms[s]
        mm = M
        i = 0
        while mm:
            lb = mm & -mm
            pos = (lb.bit_length() - 1)
            Lidx[pos] = s
            mm ^= lb
        # Note: This sets last seen s; because M_{s+1} ⊆ M_s, later s overwrite earlier
    buckets = [[] for _ in range(t + 1)]
    for i in range(n):
        if (in_M0 >> i) & 1 == 0:
            b = 0
        else:
            s_last = Lidx[i]
            b = t - s_last
        buckets[b].append(i)
    order = []
    for b in range(t + 1):
        order.extend(buckets[b])
    # p values are 1..n according to order
    pos_in_order = [0] * n
    for idx, dev in enumerate(order):
        pos_in_order[dev] = idx + 1
    # Document levels L_j = n - |M_s| + 1
    req_levels = {}
    for idx, j in enumerate(chain_docs):
        pop = Ms[idx].bit_count()
        req_levels[j] = n - pop + 1
    return pos_in_order, req_levels

def solve_case_improved(n, m, grid):
    masks = build_masks(n, m, grid)
    docs = list(range(m))
    docs.sort(key=lambda j: (-masks[j].bit_count(), j))
    groups = []  # each group stores [last_mask, chain_docs (decreasing)]
    which_group = [-1] * m
    for j in docs:
        placed = False
        for gid, (last_mask, chain) in enumerate(groups):
            # last_mask is superset; need last_mask ⊇ masks[j]
            if (last_mask | masks[j]) == last_mask:
                chain.append(j)
                groups[gid][0] = masks[j]  # update last to the smallest set so far
                which_group[j] = gid
                placed = True
                break
        if not placed:
            groups.append([masks[j], [j]])
            which_group[j] = len(groups) - 1
    k = len(groups)
    # Build per-group developer levels and doc required levels
    dev_levels = [[1] * k for _ in range(n)]
    doc_level = [1] * m
    for gid, (last_mask, chain) in enumerate(groups):
        # Ensure chain is decreasing by inclusion: it already is
        pos_in_order, req_levels = realize_chain_group(n, chain, masks)
        for i in range(n):
            dev_levels[i][gid] = pos_in_order[i]
        for j in chain:
            doc_level[j] = req_levels[j]
    doc_group = [which_group[j] + 1 for j in range(m)]
    return k, doc_group, doc_level, dev_levels

def print_solution(n, m, k, doc_group, doc_level, dev_levels, out):
    print(k, file=out)
    print(" ".join(map(str, doc_group)), file=out)
    print(" ".join(map(str, doc_level)), file=out)
    for i in range(n):
        print(" ".join(map(str, dev_levels[i])), file=out)

def simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels):
    for j in range(m):
        g = doc_group[j] - 1
        req = doc_level[j]
        for i in range(n):
            have = 1 if dev_levels[i][g] >= req else 0
            want = 1 if grid[i][j] == '1' else 0
            if have != want:
                return False
    return True

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    n, m, grid = parsed
    k, doc_group, doc_level, dev_levels = solve_case_improved(n, m, grid)
    print_solution(n, m, k, doc_group, doc_level, dev_levels, sys.stdout)

def _run_io(inp: str, func):
    from io import StringIO
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    sys.stdin, sys.stdout = StringIO(inp), StringIO()
    try:
        func()
        out = sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout
    return out

if __name__ == "__main__":
    # Checks on edge inputs
    n, m, grid = 3, 3, [list("000"), list("000"), list("000")]
    k, doc_group, doc_level, dev_levels = solve_case_improved(n, m, grid)
    assert simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels)
    n, m, grid = 3, 3, [list("111"), list("111"), list("111")]
    k, doc_group, doc_level, dev_levels = solve_case_improved(n, m, grid)
    assert k == 1
    assert simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels)
\end{minted}
\VALIDATION{Validated on all-zero and all-one matrices; simulation ensures correctness.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Dilworth via Maximum Matching; Constructive Realization}
\WHICHFORMULA{Reduce minimum chain cover under inclusion to maximum matching in a bipartite graph on documents; $k = m - \nu$. Then build chains and realize each by a developer ranking and thresholds.}
\ASSUMPTIONS{Applies to any $n,m \le 500$. Equal columns handled by orienting ties from smaller index to larger to maintain acyclicity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build masks $S_j$ for columns.
\item Build bipartite graph with left and right copies of documents; add edge $j \to \ell$ if $S_j \subseteq S_\ell$ and ($S_j \ne S_\ell$ or $j<\ell$).
\item Compute maximum matching (Hopcroft–Karp). Then $k = m - \nu$.
\item Recover chains by following matched edges; chain starts are nodes unmatched on the right.
\item For each chain (reverse to get $S_1 \supseteq S_2 \supseteq \cdots$), construct a developer order by blocks:
outside all sets, then $S_t \setminus S_{t-1}$, then $S_{t-1} \setminus S_{t-2}$, ..., then $S_1 \setminus S_2$.
\item Assign per-group developer levels as their positions $1 \ldots n$. For document with set $S_s$, set required level to $n - |S_s| + 1$.
\end{algosteps}
\OPTIMALITY{By Dilworth's theorem, the matching reduction yields the minimum number of chains. The realization is valid since nested families are exactly suffixes under an appropriate order.}
\COMPLEXITY{Building edges $O(m^2 n)$ if done naively; with bit masks it is $O(m^2)$ for subset checks plus Hopcroft–Karp $O(E\sqrt{V}) = O(m^2 \sqrt{m})$. Level assignment is $O(nm)$. Overall feasible for $m \le 500$.}
\[
\begin{aligned}
T(n,m) &= O(m^2 \sqrt{m} + nm), \quad S(n,m)=O(m^2 + nm).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return None
    grid = []
    for _ in range(n):
        s = list(next(it).strip())
        assert len(s) == m
        grid.append(s)
    return n, m, grid

def build_masks(n, m, grid):
    masks = [0] * m
    for j in range(m):
        mask = 0
        for i in range(n):
            if grid[i][j] == '1':
                mask |= (1 << i)
        masks[j] = mask
    return masks

def hopcroft_karp(adj, n_left, n_right):
    INF = 10**18
    pairU = [-1] * n_left
    pairV = [-1] * n_right
    dist = [0] * n_left

    def bfs():
        dq = deque()
        for u in range(n_left):
            if pairU[u] == -1:
                dist[u] = 0
                dq.append(u)
            else:
                dist[u] = INF
        found_augmenting = False
        while dq:
            u = dq.popleft()
            for v in adj[u]:
                pu = pairV[v]
                if pu != -1 and dist[pu] == INF:
                    dist[pu] = dist[u] + 1
                    dq.append(pu)
                if pu == -1:
                    found_augmenting = True
        return found_augmenting

    def dfs(u):
        for v in adj[u]:
            pu = pairV[v]
            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):
                pairU[u] = v
                pairV[v] = u
                return True
        dist[u] = 10**18
        return False

    matching = 0
    while bfs():
        for u in range(n_left):
            if pairU[u] == -1:
                if dfs(u):
                    matching += 1
    return matching, pairU, pairV

def build_chain_cover(masks):
    m = len(masks)
    # Build bipartite graph edges j->k if masks[j] ⊆ masks[k] and (strict or j<k)
    adj = [[] for _ in range(m)]
    for j in range(m):
        Mj = masks[j]
        for k in range(m):
            if j == k:
                continue
            Mk = masks[k]
            if (Mj | Mk) == Mk:
                # j subseteq k
                if Mj != Mk or j < k:
                    adj[j].append(k)
    match_sz, matchL, matchR = hopcroft_karp(adj, m, m)
    k_chains = m - match_sz
    # Recover chains: next link = matchL[u], prev for right matched to u
    next_doc = [-1] * m
    prev_doc = [-1] * m
    for u in range(m):
        v = matchL[u]
        if v != -1:
            next_doc[u] = v
            prev_doc[v] = u
    chains = []
    used = [False] * m
    for u in range(m):
        if prev_doc[u] == -1:
            # start of a chain
            cur = u
            chain = []
            while cur != -1 and not used[cur]:
                chain.append(cur)
                used[cur] = True
                cur = next_doc[cur]
            chains.append(chain)
    # Any remaining nodes (due to isolated cycles avoided by tie rule) are already covered
    return k_chains, chains

def realize_chain_group(n, chain_docs, masks):
    # reverse to get decreasing inclusion M0 ⊇ M1 ⊇ ...
    chain_docs = list(reversed(chain_docs))
    t = len(chain_docs)
    Ms = [masks[j] for j in chain_docs]
    # Compute last index s where developer i is in Ms[s]
    Lidx = [-1] * n
    for s in range(t):
        mm = Ms[s]
        while mm:
            lb = mm & -mm
            i = (lb.bit_length() - 1)
            Lidx[i] = s
            mm ^= lb
    in_M0 = Ms[0]
    buckets = [[] for _ in range(t + 1)]
    for i in range(n):
        if ((in_M0 >> i) & 1) == 0:
            b = 0
        else:
            s_last = Lidx[i]
            b = t - s_last
        buckets[b].append(i)
    order = []
    for b in range(t + 1):
        order.extend(buckets[b])
    pos_in_order = [0] * n
    for idx, dev in enumerate(order):
        pos_in_order[dev] = idx + 1
    req_levels = {}
    for idx, j in enumerate(chain_docs):
        pop = Ms[idx].bit_count()
        req_levels[j] = n - pop + 1
    return pos_in_order, req_levels, chain_docs

def solve_case_optimal(n, m, grid):
    masks = build_masks(n, m, grid)
    k, chains = build_chain_cover(masks)
    # Assign per-document group
    doc_group = [0] * m
    for gid, chain in enumerate(chains, start=1):
        for j in chain:
            doc_group[j] = gid
    # Build per-group developer levels and doc required levels
    dev_levels = [[1] * k for _ in range(n)]
    doc_level = [1] * m
    for gid, chain in enumerate(chains, start=1):
        pos_in_order, req_levels, chain_dec = realize_chain_group(n, chain, masks)
        for i in range(n):
            dev_levels[i][gid - 1] = pos_in_order[i]
        for j, L in req_levels.items():
            doc_level[j] = L
    return k, doc_group, doc_level, dev_levels

def print_solution(n, m, k, doc_group, doc_level, dev_levels, out):
    print(k, file=out)
    print(" ".join(map(str, doc_group)), file=out)
    print(" ".join(map(str, doc_level)), file=out)
    for i in range(n):
        print(" ".join(map(str, dev_levels[i])), file=out)

def simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels):
    for j in range(m):
        g = doc_group[j] - 1
        req = doc_level[j]
        for i in range(n):
            have = 1 if dev_levels[i][g] >= req else 0
            want = 1 if grid[i][j] == '1' else 0
            if have != want:
                return False
    return True

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    n, m, grid = parsed
    k, doc_group, doc_level, dev_levels = solve_case_optimal(n, m, grid)
    print_solution(n, m, k, doc_group, doc_level, dev_levels, sys.stdout)

def _run_io(inp: str, func):
    from io import StringIO
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    sys.stdin, sys.stdout = StringIO(inp), StringIO()
    try:
        func()
        out = sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout
    return out

if __name__ == "__main__":
    # Exactly 3 asserts / I/O mini-tests
    # 1) All-equal columns => k=1
    n, m, grid = 3, 2, [list("11"), list("11"), list("11")]
    k, doc_group, doc_level, dev_levels = solve_case_optimal(n, m, grid)
    assert k == 1 and simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels)

    # 2) Incomparable columns => k=2
    n, m, grid = 3, 2, [list("10"), list("01"), list("10")]
    k, doc_group, doc_level, dev_levels = solve_case_optimal(n, m, grid)
    assert k == 2 and simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels)

    # 3) I/O smoke
    out = _run_io("3 3\n101\n010\n111\n", solve_all)
    assert out.strip().splitlines()[0].isdigit()
\end{minted}
\VALIDATION{Three asserts: all-one case gives $k=1$; an incomparable pair yields $k=2$; and an I/O smoke test.}
\RESULT{Print a minimal number of groups and a constructive assignment of group indices and levels realizing exactly the given access matrix.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify correctness by simulation: for each $(i,j)$, check that printed levels yield access iff $a_{i,j}=1$. Cover degenerate (all zeros, all ones), equal columns, incomparable pairs, and random small matrices.}
\LINE{CROSS-CHECKS}{Compare $k$ from Approach A (upper bound $m$), Approach B (greedy), and Approach C (optimal). On tiny cases, verify $k_{\text{C}} \le k_{\text{B}} \le k_{\text{A}} = m$.}
\LINE{EDGE-CASE GENERATOR}{Generate $n,m \in \{1,\ldots,6\}$ matrices including: identical columns, nested columns, alternating patterns, and random bits with fixed seed.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_all_zero(n, m):
    return [["0"] * m for _ in range(n)]

def gen_all_one(n, m):
    return [["1"] * m for _ in range(n)]

def gen_nested(n, m):
    # Columns are nested by inclusion
    cols = []
    for j in range(m):
        t = max(0, n - j - 1)
        col = ["0"] * n
        for i in range(t, n):
            col[i] = "1"
        cols.append(col)
    # Transpose to rows
    grid = [["0"] * m for _ in range(n)]
    for j in range(m):
        for i in range(n):
            grid[i][j] = cols[j][i]
    return grid

def gen_random(n, m, seed=7):
    rng = random.Random(seed)
    grid = [["0"] * m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = "1" if rng.random() < 0.5 else "0"
    return grid
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return None
    grid = []
    for _ in range(n):
        s = list(next(it).strip())
        assert len(s) == m
        grid.append(s)
    return n, m, grid

def build_masks(n, m, grid):
    masks = [0] * m
    for j in range(m):
        mask = 0
        for i in range(n):
            if grid[i][j] == '1':
                mask |= (1 << i)
        masks[j] = mask
    return masks

def hopcroft_karp(adj, n_left, n_right):
    INF = 10**18
    pairU = [-1] * n_left
    pairV = [-1] * n_right
    dist = [0] * n_left

    def bfs():
        dq = deque()
        for u in range(n_left):
            if pairU[u] == -1:
                dist[u] = 0
                dq.append(u)
            else:
                dist[u] = INF
        found_augmenting = False
        while dq:
            u = dq.popleft()
            for v in adj[u]:
                pu = pairV[v]
                if pu != -1 and dist[pu] == INF:
                    dist[pu] = dist[u] + 1
                    dq.append(pu)
                if pu == -1:
                    found_augmenting = True
        return found_augmenting

    def dfs(u):
        for v in adj[u]:
            pu = pairV[v]
            if pu == -1 or (dist[pu] == dist[u] + 1 and dfs(pu)):
                pairU[u] = v
                pairV[v] = u
                return True
        dist[u] = 10**18
        return False

    matching = 0
    while bfs():
        for u in range(n_left):
            if pairU[u] == -1:
                if dfs(u):
                    matching += 1
    return matching, pairU, pairV

def build_chain_cover(masks):
    m = len(masks)
    adj = [[] for _ in range(m)]
    for j in range(m):
        Mj = masks[j]
        for k in range(m):
            if j == k:
                continue
            Mk = masks[k]
            if (Mj | Mk) == Mk:
                if Mj != Mk or j < k:
                    adj[j].append(k)
    match_sz, matchL, matchR = hopcroft_karp(adj, m, m)
    next_doc = [-1] * m
    prev_doc = [-1] * m
    for u in range(m):
        v = matchL[u]
        if v != -1:
            next_doc[u] = v
            prev_doc[v] = u
    chains = []
    used = [False] * m
    for u in range(m):
        if prev_doc[u] == -1:
            cur = u
            chain = []
            while cur != -1 and not used[cur]:
                chain.append(cur)
                used[cur] = True
                cur = next_doc[cur]
            chains.append(chain)
    return m - match_sz, chains

def realize_chain_group(n, chain_docs, masks):
    chain_docs = list(reversed(chain_docs))
    t = len(chain_docs)
    Ms = [masks[j] for j in chain_docs]
    Lidx = [-1] * n
    for s in range(t):
        mm = Ms[s]
        while mm:
            lb = mm & -mm
            i = (lb.bit_length() - 1)
            Lidx[i] = s
            mm ^= lb
    in_M0 = Ms[0]
    buckets = [[] for _ in range(t + 1)]
    for i in range(n):
        if ((in_M0 >> i) & 1) == 0:
            b = 0
        else:
            s_last = Lidx[i]
            b = t - s_last
        buckets[b].append(i)
    order = []
    for b in range(t + 1):
        order.extend(buckets[b])
    pos_in_order = [0] * n
    for idx, dev in enumerate(order):
        pos_in_order[dev] = idx + 1
    req_levels = {}
    for idx, j in enumerate(chain_docs):
        pop = Ms[idx].bit_count()
        req_levels[j] = n - pop + 1
    return pos_in_order, req_levels

def solve_case(n, m, grid):
    masks = build_masks(n, m, grid)
    k, chains = build_chain_cover(masks)
    doc_group = [0] * m
    for gid, chain in enumerate(chains, start=1):
        for j in chain:
            doc_group[j] = gid
    dev_levels = [[1] * k for _ in range(n)]
    doc_level = [1] * m
    for gid, chain in enumerate(chains, start=1):
        pos_in_order, req_levels = realize_chain_group(n, chain, masks)
        for i in range(n):
            dev_levels[i][gid - 1] = pos_in_order[i]
        for j, L in req_levels.items():
            doc_level[j] = L
    return k, doc_group, doc_level, dev_levels

def print_solution(n, m, k, doc_group, doc_level, dev_levels, out):
    print(k, file=out)
    print(" ".join(map(str, doc_group)), file=out)
    print(" ".join(map(str, doc_level)), file=out)
    for i in range(n):
        print(" ".join(map(str, dev_levels[i])), file=out)

def simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels):
    for j in range(m):
        g = doc_group[j] - 1
        req = doc_level[j]
        for i in range(n):
            have = 1 if dev_levels[i][g] >= req else 0
            want = 1 if grid[i][j] == '1' else 0
            if have != want:
                return False
    return True

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    n, m, grid = parsed
    k, doc_group, doc_level, dev_levels = solve_case(n, m, grid)
    print_solution(n, m, k, doc_group, doc_level, dev_levels, sys.stdout)

def _run_io(inp: str, func):
    from io import StringIO
    backup_stdin, backup_stdout = sys.stdin, sys.stdout
    sys.stdin, sys.stdout = StringIO(inp), StringIO()
    try:
        func()
        out = sys.stdout.getvalue()
    finally:
        sys.stdin, sys.stdout = backup_stdin, backup_stdout
    return out

if __name__ == "__main__":
    # Unit asserts
    n, m, grid = 3, 2, [list("10"), list("01"), list("10")]
    k, doc_group, doc_level, dev_levels = solve_case(n, m, grid)
    assert k == 2 and simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels)

    n, m, grid = 3, 3, [list("111"), list("111"), list("111")]
    k, doc_group, doc_level, dev_levels = solve_case(n, m, grid)
    assert k == 1 and simulate_check(n, m, grid, k, doc_group, doc_level, dev_levels)

    # I/O smoke test
    out = _run_io("2 3\n101\n010\n", solve_all)
    assert out.strip().splitlines()[0].isdigit()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimum number of access groups equals the minimum number of inclusion-chains covering document columns, solved via maximum matching.}
\WHY{Chain decompositions and Dilworth's theorem are common in advanced CF problems; constructing the actual levels is an extra implementation step.}
\CHECKLIST{
\begin{bullets}
\item Build column masks correctly.
\item Edge construction: subset check with tie-breaking for equal sets.
\item Maximum matching via Hopcroft–Karp.
\item Recover chains from matching.
\item Reverse chains to get decreasing inclusion.
\item Construct developer order and thresholds per group.
\item Print in the exact required format.
\item Validate by simulation on tiny cases.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All-zero column(s) and all-one column(s).
\item Duplicate columns.
\item Single document ($m=1$).
\item Single developer ($n=1$).
\item Completely incomparable columns.
\item Columns nested strictly by one developer at a time.
\item Mixed equal and nested columns.
\item Multiple chains of length $1$.
\item Very unbalanced $n$ versus $m$.
\item Large $n,m$ near $500$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to orient equal-set edges by index causing cycles.
\item Using naive set operations instead of bit masks (performance).
\item Off-by-one in thresholds: it is $n - |S| + 1$, not $|S|$.
\item Mixing 0-based and 1-based group indices in output.
\item Not assigning developer levels for groups without any $1$s (still need values).
\item Overflow concerns are irrelevant in Python but keep levels within $[1,10^9]$.
\item Mismatched chain direction when realizing levels (must be decreasing by inclusion).
\item Not handling columns that are identical leading to broken matching recovery.
\end{bullets}}
\FAILMODES{Greedy chain packing may use more groups than necessary on adversarial inputs; the matching-based method remains optimal.}
\ELI{Think of each group as a single slider for all developers. Documents in the same group are placed along that slider by choosing threshold positions. You need as many sliders as the largest bunch of document-columns that cannot be nested inside one another.}

\NotePages{3}

\end{document}