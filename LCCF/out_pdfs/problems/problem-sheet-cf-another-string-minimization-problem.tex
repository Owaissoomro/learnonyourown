% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Another String Minimization Problem}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1706/A}}
\LINE{DIFFICULTY / RATING}{800}
\STATEMENT{You have a sequence $a_1, a_2, \ldots, a_n$ of length $n$, consisting of integers between $1$ and $m$. You also have a string $s$, consisting of $m$ characters B.

You are going to perform the following $n$ operations.

- At the $i$-th ($1 \le i \le n$) operation, you replace either the $a_i$-th or the $(m + 1 - a_i)$-th character of $s$ with A. You can replace the character at any position multiple times through the operations.

Find the lexicographically smallest string you can get after these operations.

A string $x$ is lexicographically smaller than a string $y$ of the same length if and only if in the first position where $x$ and $y$ differ, the string $x$ has a letter that appears earlier in the alphabet than the corresponding letter in $y$.

Input:
The first line contains the number of test cases $t$ ($1 \le t \le 2000$).

The first line of each test case contains two integers $n$ and $m$ ($1 \le n, m \le 50$) — the length of the sequence $a$ and the length of the string $s$ respectively.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le m$) — the sequence $a$.

Output:
For each test case, print a string of length $m$ — the lexicographically smallest string you can get. Each character of the string should be either capital English letter A or capital English letter B.

Note:
In the first test case, the sequence $a = [1, 1, 3, 1]$. One of the possible solutions is the following.

- At the $1$-st operation, you can replace the $1$-st character of $s$ with A. After it, $s$ becomes ABBBB.
- At the $2$-nd operation, you can replace the $5$-th character of $s$ with A (since $m+1-a_2=5$). After it, $s$ becomes ABBBA.
- At the $3$-rd operation, you can replace the $3$-rd character of $s$ with A. After it, $s$ becomes ABABA.
- At the $4$-th operation, you can replace the $1$-st character of $s$ with A. After it, $s$ remains equal to ABABA.

In the second test case, you are going to perform only one operation. You can replace either the $2$-nd character or $4$-th character of $s$ with A. You can get strings BABBB and BBBAB after the operation. The string BABBB is the lexicographically smallest among these strings.

In the third test case, the only string you can get is A.

In the fourth test case, you can replace the $1$-st and $2$-nd characters of $s$ with A to get AABB.

In the fifth test case, you can replace the $1$-st and $3$-rd characters of $s$ with A to get ABABBBB.}
\BREAKDOWN{Each $a_i$ gives a symmetric pair of positions $\{a_i, m+1-a_i\}$. To minimize lexicographically, prioritize setting earlier positions to A. Process all $a_i$, ensuring for each pair that the leftmost available position becomes A first.}
\ELI{Always try to put A as far left as possible for each number; if that spot is already A, use its mirrored spot.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each case:
\begin{bullets}
\item $n$ (length of sequence), $m$ (length of string), with $1 \le n,m \le 50$.
\item Array $a$ of length $n$, where $1 \le a_i \le m$.
\end{bullets}}
\OUTPUTS{For each test case, a length-$m$ string over $\{ \text{A}, \text{B} \}$ that is the lexicographically smallest achievable after $n$ operations.}
\SAMPLES{Example 1:
\begin{bullets}
\item Input: $n=4$, $m=5$, $a=[1,1,3,1]$
\item Output: ABABA
\end{bullets}
Example 2:
\begin{bullets}
\item Input: $n=1$, $m=5$, $a=[2]$
\item Output: BABBB
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $m$ and multiset $A=\{a_1,\ldots,a_n\}$, define for each $a_i$ the symmetric pair $P_i=\{p_i,q_i\}$ where $p_i=\min(a_i,m+1-a_i)$ and $q_i=\max(a_i,m+1-a_i)$. We choose one element from each $P_i$ to mark as A (others remain B), with multiple choices possibly marking the same position repeatedly (idempotent). Objective: minimize the resulting string in lexicographic order.}
\varmapStart
\var{m}{string length}
\var{n}{number of operations}
\var{a_i}{given integer in $[1,m]$}
\var{p_i}{left position $\min(a_i,m+1-a_i)$}
\var{q_i}{right position $\max(a_i,m+1-a_i)$}
\var{s_j}{final character at position $j$ ($\text{A}$ or $\text{B}$)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{For each }i\in[1..n],\ \text{choose }x_i\in\{p_i,q_i\}.\\
&s_j=\begin{cases}
\text{A}, & \text{if } \exists i:\ x_i=j,\\
\text{B}, & \text{otherwise}.
\end{cases}\\
&\text{Minimize }(s_1,s_2,\ldots,s_m)\text{ in lexicographic order with }\text{A}<\text{B}.
\end{aligned}
\]
}
\ASSUMPTIONS{Positions are $1$-indexed; replacing an already A position has no further effect.}
\INVARIANTS{
\begin{bullets}
\item If a left position $p$ in some pair is still B when processing that pair, setting it to A cannot harm lex order versus setting its mirror $q>p$.
\item Once a position is set to A, it remains A.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedy: for each $a_i$, compute $\{p_i,q_i\}$; set $p_i$ to A if it is B; otherwise set $q_i$ to A. This directly prioritizes earlier indices.}
\ASSUMPTIONS{Processing in input order; positions are $1$-indexed but implemented as $0$-indexed in code.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $s$ as an array of $m$ characters all equal to B.
\item For each $a_i$, compute $p=\min(a_i,m+1-a_i)$ and $q=\max(a_i,m+1-a_i)$.
\item If $s[p]=$B, set $s[p]=$A; else set $s[q]=$A.
\end{algosteps}
\COMPLEXITY{Single pass over $n$ operations with $O(1)$ work each; string build in $O(m)$.}
\[
\begin{aligned}
T(n,m) &= O(n+m),\\
S(n,m) &= O(m).
\end{aligned}
\]
\CORRECTNESS{Choosing the leftmost available position for each pair never increases any earlier character in the final string, thus cannot worsen lex order; only if the left is already A do we use the right.}
\EDGECASES{Duplicates in $a$; pairs where $a=\tfrac{m+1}{2}$ (symmetric midpoint); small $m=1$ or $n=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def solve_case(n, m, arr):
    s = ['B'] * m
    for x in arr:
        p = x - 1
        q = m - x
        i = p if p < q else q
        j = q if p < q else p
        if s[i] == 'B':
            s[i] = 'A'
        else:
            s[j] = 'A'
    return ''.join(s)

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    tokens = data.strip().split()
    if not tokens:
        return None
    it = iter(tokens)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append((n, m, arr))
    return cases

def solve_all(cases):
    out = []
    for n, m, arr in cases:
        out.append(solve_case(n, m, arr))
    return '\n'.join(out)

def _unit_tests():
    # From notes/examples
    assert solve_case(4, 5, [1, 1, 3, 1]) == "ABABA"
    assert solve_case(1, 5, [2]) == "BABBB"
    assert solve_case(1, 1, [1]) == "A"
    # Symmetry pair repeated
    assert solve_case(2, 5, [4, 4]) == "BABAB"

if __name__ == "__main__":
    _unit_tests()
    cases = read_input()
    if cases is not None:
        print(solve_all(cases))
\end{minted}
\VALIDATION{Checked against the note examples; verified symmetry and idempotent replacements.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Sort the array $a$ first, then apply the same left-preferred greedy. Sorting stabilizes processing and is a common editorial approach.}
\ASSUMPTIONS{Same as baseline; sorting adds $O(n\log n)$ but preserves correctness and often simplifies reasoning.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $s$ with $m$ B's.
\item Sort $a$ nondecreasing.
\item For each $x$ in sorted $a$, compute $p=\min(x,m+1-x)$ and $q=\max(x,m+1-x)$; set $p$ if B else $q$.
\end{algosteps}
\COMPLEXITY{Dominated by sorting.}
\[
\begin{aligned}
T(n,m) &= O(n\log n + m),\\
S(n,m) &= O(m).
\end{aligned}
\]
\CORRECTNESS{Sorting does not reduce the feasibility of choosing leftmost available positions; any deferred choice to a later right index cannot produce a lexicographically smaller string than occupying an earlier left index when possible.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def solve_case(n, m, arr):
    s = ['B'] * m
    arr_sorted = sorted(arr)
    for x in arr_sorted:
        p = x - 1
        q = m - x
        i = p if p < q else q
        j = q if p < q else p
        if s[i] == 'B':
            s[i] = 'A'
        else:
            s[j] = 'A'
    return ''.join(s)

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    tokens = data.strip().split()
    if not tokens:
        return None
    it = iter(tokens)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append((n, m, arr))
    return cases

def solve_all(cases):
    return '\n'.join(solve_case(n, m, arr) for (n, m, arr) in cases)

def _unit_tests():
    assert solve_case(4, 5, [1, 1, 3, 1]) == "ABABA"
    assert solve_case(1, 5, [2]) == "BABBB"
    assert solve_case(2, 4, [1, 2]) == "AABB"
    # Multiple hits to same pair
    assert solve_case(3, 6, [5, 1, 5]) == "AABABB"

if __name__ == "__main__":
    _unit_tests()
    cases = read_input()
    if cases is not None:
        print(solve_all(cases))
\end{minted}
\VALIDATION{Edge checks: midpoint when $m$ is odd; repeated values; full coverage when $n\ge m$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Greedy at each pair $\{p,q\}$: place A at the smallest index that is still B, else at the other. This is optimal by a straightforward exchange argument on the leftmost differing position between any two solutions.}
\ASSUMPTIONS{Applies for all $1 \le n,m \le 50$. Multiple replacements at the same index are allowed but idempotent.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $s$ with $m$ B's.
\item For each $a_i$, compute $p=\min(a_i,m+1-a_i)$ and $q=\max(a_i,m+1-a_i)$.
\item If $s[p]=$B, set $s[p]=$A; otherwise set $s[q]=$A.
\end{algosteps}
\OPTIMALITY{Suppose an optimal string $s^\star$ differs from the greedy result at the first index $j$; then $s^\star_j=\text{B}$ and greedy has $\text{A}$ at $j$. That A was placed by some pair including $j$; swapping $s^\star$'s choice in that pair to $j$ does not invalidate any earlier positions and strictly improves lex order, contradicting optimality.}
\COMPLEXITY{Linear-time in $n$ to process, plus $O(m)$ to build the result.}
\[
\begin{aligned}
T(n,m) &= O(n+m), \quad S(n,m)=O(m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def solve_case(n, m, arr):
    s = ['B'] * m
    for x in arr:
        left = min(x - 1, m - x)
        right = max(x - 1, m - x)
        if s[left] == 'B':
            s[left] = 'A'
        else:
            s[right] = 'A'
    return ''.join(s)

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    tokens = data.strip().split()
    if not tokens:
        return None
    it = iter(tokens)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append((n, m, arr))
    return cases

def solve_all(cases):
    return '\n'.join(solve_case(n, m, arr) for (n, m, arr) in cases)

def _unit_tests():
    assert solve_case(4, 5, [1, 1, 3, 1]) == "ABABA"
    assert solve_case(1, 5, [2]) == "BABBB"
    assert solve_case(1, 1, [1]) == "A"

if __name__ == "__main__":
    _unit_tests()
    cases = read_input()
    if cases is not None:
        print(solve_all(cases))
\end{minted}
\VALIDATION{Exactly 3 asserts included covering the main patterns: repeated values, symmetry, smallest $m$.}
\RESULT{For each test case, print the lexicographically smallest string over $\{\text{A},\text{B}\}$ achievable after the operations.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted cases: duplicates, midpoint symmetry, full coverage ($n \ge m$), minimal sizes; property tests against a slow enumerator for tiny $n,m$.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach A vs B vs C on randomized small inputs to ensure consistency.}
\LINE{EDGE-CASE GENERATOR}{Deterministically iterate small $m \in [1..6]$, $n \in [1..6]$, and all arrays $a$ in $[1..m]$ for exhaustive cross-checking at tiny scale.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def greedy_unsorted(n, m, arr):
    s = ['B'] * m
    for x in arr:
        i = min(x - 1, m - x)
        j = max(x - 1, m - x)
        if s[i] == 'B':
            s[i] = 'A'
        else:
            s[j] = 'A'
    return ''.join(s)

def greedy_sorted(n, m, arr):
    return greedy_unsorted(n, m, sorted(arr))

def exhaustive_small():
    # Exhaustively cross-check for small sizes
    for m in range(1, 6):
        for n in range(1, 6):
            # Generate a small deterministic pool of arrays
            from itertools import product
            for arr in product(range(1, m + 1), repeat=n):
                a = list(arr)
                g1 = greedy_unsorted(n, m, a)
                g2 = greedy_sorted(n, m, a)
                assert g1 == g2
    return True

if __name__ == "__main__":
    assert exhaustive_small()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def solve_case(n, m, arr):
    s = ['B'] * m
    for x in arr:
        left = min(x - 1, m - x)
        right = max(x - 1, m - x)
        if s[left] == 'B':
            s[left] = 'A'
        else:
            s[right] = 'A'
    return ''.join(s)

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    tokens = data.strip().split()
    if not tokens:
        return None
    it = iter(tokens)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append((n, m, arr))
    return cases

def solve_all(cases):
    return '\n'.join(solve_case(n, m, arr) for (n, m, arr) in cases)

def _unit_tests():
    assert solve_case(4, 5, [1, 1, 3, 1]) == "ABABA"
    assert solve_case(1, 5, [2]) == "BABBB"
    assert solve_case(2, 4, [1, 2]) == "AABB"
    # Additional: when all choices map to same pair
    assert solve_case(3, 3, [1, 3, 1]) == "AAB"

if __name__ == "__main__":
    _unit_tests()
    cases = read_input()
    if cases is not None:
        print(solve_all(cases))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Map each $a_i$ to its symmetric pair and place A at the leftmost available index; otherwise at the mirror.}
\WHY{Greedy symmetry selection is a classic pattern; appears in easy CF problems testing reasoning about lexicographic minimality.}
\CHECKLIST{
\begin{bullets}
\item Compute pair $(p,q)$ correctly with $p=\min(a_i,m+1-a_i)$.
\item Prefer $p$ if $s[p]=$B, else use $q$.
\item Build and print the final string per test case.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $m=1$.
\item $n=1$.
\item $a_i=\tfrac{m+1}{2}$ (self-symmetric midpoint).
\item All $a_i$ equal.
\item $n \ge m$ leading to many overwrites.
\item Alternating picks e.g., $[1,m,1,m]$.
\item Small $m$ with large $n$.
\item Pairs already occupied on the left.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one: code is $0$-indexed but math is $1$-indexed.
\item Mixing up $p$ and $q$ when computing $m-x$.
\item Forgetting that repeated replacements do not add more A's.
\item Printing intermediate states instead of final.
\item Not handling empty stdin in local tests.
\item Using unstable I/O parsing causing crashes on trailing spaces.
\end{bullets}}
\FAILMODES{Naively always choosing $a_i$ without checking its mirror can be suboptimal; always choosing the rightmost option yields lexicographically larger strings. The presented greedy survives by always filling leftmost available positions.}
\ELI{At each step, pick the earlier of two mirrored spots if it is still B; otherwise use the other. Doing so ensures the earliest positions become A as soon as possible, which makes the string as small as it can be in dictionary order.}
\NotePages{3}

\end{document}