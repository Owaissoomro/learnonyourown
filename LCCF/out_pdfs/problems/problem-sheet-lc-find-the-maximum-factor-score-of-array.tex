% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find the Maximum Factor Score of Array}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-the-maximum-factor-score-of-array/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given an integer array \texttt{nums}. The \textbf{factor score} of an array is defined as the \emph{product} of the LCM and GCD of all elements of that array. Return the \textbf{maximum factor score} of \texttt{nums} after removing \textbf{at most} one element from it. \textbf{Note} that \emph{both} the LCM and GCD of a single number are the number itself, and the \emph{factor score} of an \textbf{empty} array is 0.

\textbf{Example 1:}
\textbf{Input:} \texttt{nums = [2,4,8,16]}
\textbf{Output:} 64
\textbf{Explanation:}
On removing 2, the GCD of the rest of the elements is 4 while the LCM is 16, which gives a maximum factor score of \texttt{4 * 16 = 64}.

\textbf{Example 2:}
\textbf{Input:} \texttt{nums = [1,2,3,4,5]}
\textbf{Output:} 60
\textbf{Explanation:}
The maximum factor score of 60 can be obtained without removing any elements.

\textbf{Example 3:}
\textbf{Input:} \texttt{nums = [3]}
\textbf{Output:} 9

\textbf{Constraints:}
\begin{itemize}
\item \texttt{1 <= nums.length <= 100}
\item \texttt{1 <= nums[i] <= 30}
\end{itemize}}
\BREAKDOWN{Compute factor score $f(S)=\operatorname{lcm}(S)\cdot\gcd(S)$ for either the full array or any array formed by removing exactly one element. Use structure to avoid recomputing LCM and GCD from scratch for each removal.}
\ELI{Precompute GCDs and LCMs from left and right so you can get the GCD and LCM of the array without any one element in $O(1)$ per position, then take the best product.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list \texttt{nums} of integers with length $n$ where $1 \le n \le 100$ and $1 \le \texttt{nums}[i] \le 30$.}
\OUTPUTS{An integer equal to $\max\{\operatorname{lcm}(S)\cdot\gcd(S)\}$ over $S \in \{\texttt{nums}\}\cup\{\texttt{nums}\setminus\{\texttt{nums}[i]\}\mid 0\le i<n\}$. For an empty array $S$, the factor score is defined as 0.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{nums = [2,4,8,16]}; Output: \texttt{64}.
\item Input: \texttt{nums = [3]}; Output: \texttt{9}.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given multiset $A=\{a_1,\ldots,a_n\}$ of positive integers, define
\begin{BreakableEquation*}
f(S)=\operatorname{lcm}(S)\cdot \gcd(S),\quad S\subseteq A,\ |A\setminus S|\in\{0,1\}.
\end{BreakableEquation*}
Return $\max f(S)$ over all $S$ that equal $A$ or $A\setminus\{a_i\}$ for some $i$.}
\varmapStart
\var{n}{length of the array}
\var{a_i}{the $i$-th element of \texttt{nums}}
\var{G(S)}{$\gcd$ of elements of set/list $S$; $G(\varnothing)=0$ by convention}
\var{L(S)}{$\operatorname{lcm}$ of elements of $S$; $L(\varnothing)=1$ by convention}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\gcd(x,y) &= \max\{d: d\mid x,\ d\mid y\},\quad \gcd(0,x)=x,\\
\operatorname{lcm}(x,y) &= \frac{x}{\gcd(x,y)}\cdot y,\quad \operatorname{lcm}(1,x)=x,\\
G(a_1,\ldots,a_k) &= \gcd(\cdots\gcd(\gcd(a_1,a_2),a_3)\cdots,a_k),\\
L(a_1,\ldots,a_k) &= \operatorname{lcm}(\cdots\operatorname{lcm}(\operatorname{lcm}(a_1,a_2),a_3)\cdots,a_k).
\end{aligned}
\]
}
\ASSUMPTIONS{All $a_i\ge 1$. For algebraic convenience, use $G(\varnothing)=0$ and $L(\varnothing)=1$ so that $f(\varnothing)=0\cdot 1=0$, matching the problem definition.}
\INVARIANTS{
\begin{itemize}
\item $G$ is nonincreasing when adding elements; $L$ is nondecreasing when adding elements.
\item For any split at $i$, $G(A\setminus\{a_i\})=\gcd(G(A_{\text{left}}),G(A_{\text{right}}))$ and $L(A\setminus\{a_i\})=\operatorname{lcm}(L(A_{\text{left}}),L(A_{\text{right}}))$ when $A_{\text{left}}=\{a_1,\ldots,a_{i-1}\}$, $A_{\text{right}}=\{a_{i+1},\ldots,a_n\}$, given the identities above.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly evaluate $f(S)=L(S)\cdot G(S)$ for $S=A$ and each $S=A\setminus\{a_i\}$ by recomputing $G$ and $L$ from scratch.}
\ASSUMPTIONS{Use Euclid for $\gcd$ and $\operatorname{lcm}(x,y)=x/\gcd(x,y)\cdot y$. Python integers avoid overflow.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $G(A)$ and $L(A)$ in one pass; set answer to $G(A)\cdot L(A)$.
\item For each $i$ from $0$ to $n-1$, compute $G(A\setminus\{a_i\})$ and $L(A\setminus\{a_i\})$ by scanning all $j\ne i$; update the maximum.
\item Return the maximum.
\end{algosteps}
\COMPLEXITY{For each $i$ we scan $O(n)$ elements and do $O(1)$ $\gcd/\operatorname{lcm}$ updates, so $T(n)=O(n^2\log V)$ where $V\le 30$; space $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= \underbrace{O(n)}_{\text{all}} + \sum_{i=1}^{n} \underbrace{O(n)}_{\text{exclude }i} \\
     &= O(n^2).
\end{aligned}
\]
\CORRECTNESS{By definition, the algorithm evaluates $f(S)$ for all allowable $S$ and returns the max. The neutral-element conventions ensure the empty set case yields $0$.}
\EDGECASES{Single element; all equal; presence of $1$; mixture of coprime and multiple relations.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from math import gcd
from typing import List

def lcm(a: int, b: int) -> int:
    if a == 0 or b == 0:
        return 0
    return a // gcd(a, b) * b

class Solution:
    # Baseline O(n^2) method
    def maxFactorScore(self, nums: List[int]) -> int:
        n = len(nums)
        # all elements
        g = 0
        L = 1
        for x in nums:
            g = gcd(g, x)
            L = lcm(L, x if x > 0 else 1)
        ans = g * L
        # remove one element (or none)
        for i in range(n):
            g2 = 0
            L2 = 1
            for j, x in enumerate(nums):
                if j == i:
                    continue
                g2 = gcd(g2, x)
                L2 = lcm(L2, x if x > 0 else 1)
            ans = max(ans, g2 * L2)
        return ans

# Tiny tests for the baseline
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxFactorScore([2,4,8,16]) == 64
    assert sol.maxFactorScore([1,2,3,4,5]) == 60
    assert sol.maxFactorScore([3]) == 9
\end{minted}
\VALIDATION{Checked on the three provided examples. Also implicitly validates the empty array convention via removing the only element.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Prefix/Suffix Composition}
\WHICHFORMULA{Use prefix/suffix arrays of GCD and LCM to get, for each index $i$, $G(A\setminus\{a_i\})=\gcd(\text{prefG}[i],\text{sufG}[i+1])$ and $L(A\setminus\{a_i\})=\operatorname{lcm}(\text{prefL}[i],\text{sufL}[i+1])$ in $O(1)$.}
\ASSUMPTIONS{Neutral elements: $\gcd(0,x)=x$; $\operatorname{lcm}(1,x)=x$. Store prefix for $[0..i-1]$ and suffix for $[i..n-1]$ with sentinels.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build arrays \texttt{prefG}, \texttt{prefL} of size $n+1$ where index $i$ holds the aggregate over $[0..i-1]$; initialize \texttt{prefG[0]=0}, \texttt{prefL[0]=1}.
\item Build arrays \texttt{sufG}, \texttt{sufL} over $[i..n-1]$; initialize \texttt{sufG[n]=0}, \texttt{sufL[n]=1}.
\item The all-elements candidate is \texttt{prefG[n] * prefL[n]}. For each $i$, compute
$g_i=\gcd(\texttt{prefG[i]},\texttt{sufG[i+1]})$ and $L_i=\operatorname{lcm}(\texttt{prefL[i]},\texttt{sufL[i+1]})$; update the maximum with $g_i\cdot L_i$.
\end{algosteps}
\COMPLEXITY{Prefix and suffix builds are $O(n)$; each exclusion query is $O(1)$. Hence $T(n)=O(n)$ and $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n) \text{ build} + O(n) \text{ scan} = O(n).
\end{aligned}
\]
\CORRECTNESS{By associativity and the neutral elements, prefix/suffix composition equals the aggregate over the array with $a_i$ removed. Taking the max over all $i$ and the full array covers all allowed choices.}
\textbf{Code (Improved)}
\begin{minted}{python}
from math import gcd
from typing import List

def lcm(a: int, b: int) -> int:
    if a == 0 or b == 0:
        return 0
    return a // gcd(a, b) * b

class Solution:
    # Improved O(n) method using prefix/suffix gcd and lcm
    def maxFactorScore(self, nums: List[int]) -> int:
        n = len(nums)
        prefG = [0] * (n + 1)
        prefL = [1] * (n + 1)
        for i, x in enumerate(nums, start=1):
            prefG[i] = gcd(prefG[i - 1], x)
            prefL[i] = lcm(prefL[i - 1], x)
        sufG = [0] * (n + 1)
        sufL = [1] * (n + 1)
        for i in range(n - 1, -1, -1):
            x = nums[i]
            sufG[i] = gcd(sufG[i + 1], x)
            sufL[i] = lcm(sufL[i + 1], x)
        ans = prefG[n] * prefL[n]  # keep all
        for i in range(n):
            g2 = gcd(prefG[i], sufG[i + 1])
            L2 = lcm(prefL[i], sufL[i + 1])
            cand = g2 * L2
            if cand > ans:
                ans = cand
        return ans

# Checks on edge inputs
if __name__ == "__main__":
    sol = Solution()
    # Provided examples
    assert sol.maxFactorScore([2,4,8,16]) == 64
    assert sol.maxFactorScore([1,2,3,4,5]) == 60
    assert sol.maxFactorScore([3]) == 9
    # Additional edges
    assert sol.maxFactorScore([1,1,1]) == 1  # gcd=1, lcm=1
\end{minted}
\VALIDATION{Covers examples and constant arrays including many 1s, ensuring neutral elements behave properly.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Prefix/Suffix Aggregation with Minimal Passes}
\WHICHFORMULA{Same as Approach B; it is optimal up to constant factors because any solution must at least read the input.}
\ASSUMPTIONS{Integer domain small ($\le 30$), but solution does not rely on factorization; it only uses Euclid and the lcm-gcd identity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item One forward pass to fill prefix GCD/LCM; one backward pass for suffix GCD/LCM.
\item Evaluate the all-keep candidate and each single-removal candidate in a final pass.
\item Return the maximum.
\end{algosteps}
\OPTIMALITY{A lower bound of $\Omega(n)$ holds by input size. The algorithm achieves $O(n)$ time and is thus time-optimal in the RAM model.}
\COMPLEXITY{$T(n)=O(n)$, $S(n)=O(n)$; using only constant-time arithmetic per element.}
\[
\begin{aligned}
T(n) &= O(n) \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from math import gcd
from typing import List

def lcm(a: int, b: int) -> int:
    if a == 0 or b == 0:
        return 0
    return a // gcd(a, b) * b

class Solution:
    def maxFactorScore(self, nums: List[int]) -> int:
        n = len(nums)
        prefG = [0] * (n + 1)
        prefL = [1] * (n + 1)
        for i in range(1, n + 1):
            x = nums[i - 1]
            prefG[i] = gcd(prefG[i - 1], x)
            prefL[i] = lcm(prefL[i - 1], x)
        sufG = [0] * (n + 1)
        sufL = [1] * (n + 1)
        for i in range(n - 1, -1, -1):
            x = nums[i]
            sufG[i] = gcd(sufG[i + 1], x)
            sufL[i] = lcm(sufL[i + 1], x)
        best = prefG[n] * prefL[n]
        for i in range(n):
            g2 = gcd(prefG[i], sufG[i + 1])
            L2 = lcm(prefL[i], sufL[i + 1])
            val = g2 * L2
            if val > best:
                best = val
        return best

if __name__ == "__main__":
    sol = Solution()
    # Exactly 3 asserts
    assert sol.maxFactorScore([2,4,8,16]) == 64
    assert sol.maxFactorScore([1,2,3,4,5]) == 60
    assert sol.maxFactorScore([3]) == 9
\end{minted}
\VALIDATION{Ran against the three sample cases; matches expected outputs exactly.}
\RESULT{The function returns the maximum possible product of LCM and GCD after optionally removing exactly one element (or none). Ties are resolved by returning that common maximum value.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for representative patterns: all equal numbers, arrays containing 1, mixed coprime numbers, strictly increasing powers of 2, single-element arrays. Property check: removing an element cannot increase GCD above the GCD of the remaining elements and cannot decrease LCM below that of the remaining elements.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (quadratic) and Approach C (linear) on small random arrays to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of size 1, 2, and small $n$, with values drawn from $\{1,2,3,4,5,6,10,15,30\}$ to exercise various gcd/lcm interactions.}
\begin{minted}{python}
from math import gcd
from typing import List
import random

def lcm(a: int, b: int) -> int:
    if a == 0 or b == 0:
        return 0
    return a // gcd(a, b) * b

class Baseline:
    def maxFactorScore(self, nums: List[int]) -> int:
        n = len(nums)
        g = 0
        L = 1
        for x in nums:
            g = gcd(g, x)
            L = lcm(L, x)
        ans = g * L
        for i in range(n):
            g2 = 0
            L2 = 1
            for j, x in enumerate(nums):
                if j == i:
                    continue
                g2 = gcd(g2, x)
                L2 = lcm(L2, x)
            ans = max(ans, g2 * L2)
        return ans

class Reference:
    def maxFactorScore(self, nums: List[int]) -> int:
        n = len(nums)
        prefG = [0] * (n + 1)
        prefL = [1] * (n + 1)
        for i in range(1, n + 1):
            x = nums[i - 1]
            prefG[i] = gcd(prefG[i - 1], x)
            prefL[i] = lcm(prefL[i - 1], x)
        sufG = [0] * (n + 1)
        sufL = [1] * (n + 1)
        for i in range(n - 1, -1, -1):
            x = nums[i]
            sufG[i] = gcd(sufG[i + 1], x)
            sufL[i] = lcm(sufL[i + 1], x)
        best = prefG[n] * prefL[n]
        for i in range(n):
            g2 = gcd(prefG[i], sufG[i + 1])
            L2 = lcm(prefL[i], sufL[i + 1])
            best = max(best, g2 * L2)
        return best

def edge_cases():
    cases = [
        [3],
        [1,1],
        [2,2,2,2],
        [1,2],
        [2,3,5,7],
        [2,4,8,16],
        [1,2,3,4,5],
        [6,10,15,30],
    ]
    return cases

if __name__ == "__main__":
    base = Baseline()
    ref = Reference()
    for arr in edge_cases():
        assert base.maxFactorScore(arr) == ref.maxFactorScore(arr)
    random.seed(0)
    pool = [1,2,3,4,5,6,10,15,30]
    for _ in range(200):
        n = random.randint(1, 8)
        arr = [random.choice(pool) for _ in range(n)]
        assert base.maxFactorScore(arr) == ref.maxFactorScore(arr)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from math import gcd
from typing import List

def lcm(a: int, b: int) -> int:
    if a == 0 or b == 0:
        return 0
    return a // gcd(a, b) * b

class Solution:
    def maxFactorScore(self, nums: List[int]) -> int:
        n = len(nums)
        prefG = [0] * (n + 1)
        prefL = [1] * (n + 1)
        for i in range(1, n + 1):
            x = nums[i - 1]
            prefG[i] = gcd(prefG[i - 1], x)
            prefL[i] = lcm(prefL[i - 1], x)
        sufG = [0] * (n + 1)
        sufL = [1] * (n + 1)
        for i in range(n - 1, -1, -1):
            x = nums[i]
            sufG[i] = gcd(sufG[i + 1], x)
            sufL[i] = lcm(sufL[i + 1], x)
        best = prefG[n] * prefL[n]
        for i in range(n):
            g2 = gcd(prefG[i], sufG[i + 1])
            L2 = lcm(prefL[i], sufL[i + 1])
            if g2 * L2 > best:
                best = g2 * L2
        return best

if __name__ == "__main__":
    sol = Solution()
    assert sol.maxFactorScore([2,4,8,16]) == 64
    assert sol.maxFactorScore([1,2,3,4,5]) == 60
    assert sol.maxFactorScore([3]) == 9
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize $\operatorname{lcm}(\cdot)\cdot\gcd(\cdot)$ after removing at most one element using prefix/suffix aggregation.}
\WHY{Combines two classic array aggregates (GCD/LCM) and tests the ability to compose them efficiently with exclusion queries.}
\CHECKLIST{
\begin{itemize}
\item Build prefix GCD/LCM with neutral elements 0 and 1 respectively.
\item Build suffix GCD/LCM similarly.
\item Evaluate keep-all candidate.
\item For each index, compose exclude-one candidate via $\gcd$ and $\operatorname{lcm}$.
\item Take maximum.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item Single element array.
\item All ones.
\item All equal non-one numbers.
\item Presence of many coprimes.
\item Strict chains of powers of two.
\item Arrays where removing any element decreases the score.
\item Arrays where removing a particular element drastically increases LCM or GCD.
\item Mixed small values ensuring no overflow issues.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Using wrong neutral element for GCD (must be 0) or LCM (must be 1) in prefix/suffix.
\item Mishandling the empty array case when $n=1$ and one removal is considered.
\item Implementing $\operatorname{lcm}$ as $a\cdot b/\gcd$ without guarding multiplication order; use $a//\gcd(a,b)\cdot b$.
\item Integer overflow in languages without big integers; use 64-bit.
\item Off-by-one errors in prefix/suffix indexing.
\item Confusing bitwise OR with LCM or bitwise AND with GCD in other languages.
\end{itemize}}
\FAILMODES{Quadratic recomputation times out if constraints were larger; prefix/suffix avoids repeated scans. Incorrect neutral elements produce wrong results for single-element removal leading to incorrect zero or one factors.}
\ELI{Precompute what the GCD and LCM are to the left and to the right of each position. Then pretend you remove that position and combine the left and right results to get the new GCD and LCM. Pick the best product.}
\NotePages{3}

\end{document}