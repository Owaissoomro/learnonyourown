% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lattice Optimizing}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2002/G}}
\LINE{DIFFICULTY / RATING}{3400}
\STATEMENT{Consider a grid graph with $n$ rows and $n$ columns. Let the cell in row $x$ and column $y$ be $(x,y)$. There exists a directed edge from $(x,y)$ to $(x+1,y)$, with non-negative integer value $d_{x,y}$, for all $1\le x < n, 1\le y \le n$, and there also exists a directed edge from $(x,y)$ to $(x,y+1)$, with non-negative integer value $r_{x,y}$, for all $1\le x \le n, 1\le y < n$.

Initially, you are at $(1,1)$, with an empty set $S$. You need to walk along the edges and eventually reach $(n,n)$. Whenever you pass an edge, its value will be inserted into $S$. Please maximize the MEX$^{\ast}$ of $S$ when you reach $(n,n)$.

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1\le t\le 100$). The description of the test cases follows.

The first line of each test case contains a single integer $n$ ($2\le n\le 20$) — the number of rows and columns.

Each of the next $n-1$ lines contains $n$ integers separated by single spaces — the matrix $d$ ($0\le d_{x,y}\le 2n-2$).

Each of the next $n$ lines contains $n-1$ integers separated by single spaces — the matrix $r$ ($0\le r_{x,y}\le 2n-2$).

It is guaranteed that the sum of all $n^3$ does not exceed $8000$.

Output:
For each test case, print a single integer — the maximum MEX of $S$ when you reach $(n,n)$.

Note:
In the first test case, the grid graph and one of the optimal paths are as follows:

In the second test case, the grid graph and one of the optimal paths are as follows:}
\BREAKDOWN{You must choose a monotone path of exactly $2n-2$ moves (right/down) from $(1,1)$ to $(n,n)$ that maximizes the MEX of the set of labels collected along the traversed edges. The MEX equals the largest $k$ such that all labels in $\{0,1,\ldots,k-1\}$ appear at least once on the path.}
\ELI{Think of edge labels as colors; you want a path that touches every color from $0$ up to some $k-1$, making $k$ as large as possible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: an integer $n$; then a $(n-1)\times n$ matrix $d$ of non-negative integers; then an $n\times (n-1)$ matrix $r$ of non-negative integers. Values satisfy $0\le d_{x,y}, r_{x,y}\le 2n-2$.}
\OUTPUTS{For each test case, print a single integer: the maximum achievable MEX of the set of traversed edge labels along a path from $(1,1)$ to $(n,n)$.}
\SAMPLES{- Example 1: $n=2$, $d=\begin{bmatrix}0&1\end{bmatrix}$, $r=\begin{bmatrix}1\\0\end{bmatrix}$. Best is down then right $\Rightarrow S=\{0\}$, answer $1$.
- Example 2: $n=2$, $d=\begin{bmatrix}1&1\end{bmatrix}$, $r=\begin{bmatrix}0\\0\end{bmatrix}$. Any path collects $\{0,1\}$, answer $2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G$ be the $n\times n$ grid with directed edges right and down. A path $P$ from $(1,1)$ to $(n,n)$ is a sequence of $2n-2$ edges. Let $L(P)$ be the set of labels encountered along $P$. Define $\operatorname{mex}(P)=\min\{m\in\mathbb{Z}_{\ge 0}: m\notin L(P)\}$. We seek $\max_P \operatorname{mex}(P)$. Equivalently, for $k\in[0,2n-2]$, decide if there exists $P$ with $\{0,1,\ldots,k-1\}\subseteq L(P)$, and take the largest feasible $k$.}
\varmapStart
\var{n}{grid side length}
\var{d_{x,y}}{label on down edge $(x,y)\to(x+1,y)$}
\var{r_{x,y}}{label on right edge $(x,y)\to(x,y+1)$}
\var{P}{monotone path from $(1,1)$ to $(n,n)$}
\var{k}{candidate MEX; require covering labels $[0,k-1]$}
\var{S}{set $L(P)$ of labels present along $P$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Feasible}(k) \iff \exists P:\ \{0,1,\ldots,k-1\}\subseteq L(P).\\
&\text{Answer}=\max\{k\in\{0,1,\ldots,2n-2\}:\ \text{Feasible}(k)\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Paths are monotone (only right/down). Labels are integers in $[0,2n-2]$. MEX is taken over a set (duplicates do not matter).}
\INVARIANTS{- Every path has exactly $2n-2$ edges.
- For any $k$, if a path is feasible for $k$, then it is feasible for all $k'\le k$ (monotonicity, allowing binary search on $k$).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all paths and compute the MEX of each path's label set; return the maximum.}
\ASSUMPTIONS{Only viable for very small $n$ since the number of paths is $\binom{2n-2}{n-1}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Recursively enumerate all monotone paths by choosing right or down moves until reaching $(n,n)$.
\item For each path, collect labels along traversed edges in a set; compute its MEX.
\item Record and return the maximum MEX observed.
\end{algosteps}
\COMPLEXITY{Exponential in $n$. For $n\ge 10$ this is already infeasible.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(\binom{2n-2}{n-1}\right),\quad
S(n) = O(n).
\end{aligned}
\]
\CORRECTNESS{By exhaustive enumeration, the maximum over all paths is found.}
\EDGECASES{All labels equal; ties in label values; minimal grid $n=2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline brute force: enumerate all paths (only for very small n).
# Not used for final solve_all due to exponential complexity.

from typing import List, Tuple, Set

def mex_of_set(s: Set[int]) -> int:
    m = 0
    while m in s:
        m += 1
    return m

def brute_max_mex(n: int, d: List[List[int]], r: List[List[int]]) -> int:
    best = 0
    path = []

    def dfs(i: int, j: int, seen: Set[int]):
        nonlocal best
        if i == n - 1 and j == n - 1:
            best = max(best, mex_of_set(seen))
            return
        # move right
        if j + 1 < n:
            lab = r[i][j]
            added = lab not in seen
            if added:
                seen.add(lab)
            dfs(i, j + 1, seen)
            if added:
                seen.remove(lab)
        # move down
        if i + 1 < n:
            lab = d[i][j]
            added = lab not in seen
            if added:
                seen.add(lab)
            dfs(i + 1, j, seen)
            if added:
                seen.remove(lab)

    dfs(0, 0, set())
    return best

# Tiny sanity
assert brute_max_mex(2, [[0,1]], [[1],[0]]) == 1
assert brute_max_mex(2, [[1,1]], [[0],[0]]) == 2
\end{minted}
\VALIDATION{Checked on $n=2$ cases; suitable only for trivial sizes.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search on MEX + DP Without Meet-in-the-Middle}
\WHICHFORMULA{Use monotonicity of feasibility in $k$ to binary search, and for each $k$ run a dynamic programming over layers keeping, at each cell, the family of reachable subsets of required labels $\{0,\ldots,k-1\}$.}
\ASSUMPTIONS{We only need to track which of the first $k$ labels have been seen; labels $\ge k$ are irrelevant for feasibility($k$). Prune states by subset dominance: in each cell, keep only masks not contained in another mask.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Binary search $k\in[0,2n-2]$.
\item For fixed $k$, propagate layer-by-layer from $(1,1)$ to all cells, carrying bitmasks of seen labels $<k$.
\item Prune per-cell mask sets by removing any mask that is a subset of another.
\item If any mask equals all-ones $(1\ll k)-1$ at $(n,n)$, then feasible.
\end{algosteps}
\COMPLEXITY{This improves over brute force but can still be large since masks can proliferate. With pruning and $k\le 2n-2\le 38$, it is often workable for small $n$, yet worst-case remains exponential.}
\[
\begin{aligned}
T(n) &\approx O\Big(n^2 \cdot \text{layers} \cdot M\Big),\ \text{where $M$ is pruned masks per cell.}
\end{aligned}
\]
\CORRECTNESS{Mask DP correctly tracks which required labels have appeared; pruning by subset inclusion is safe since supersets dominate subsets.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved feasibility checker (without meet-in-the-middle).
# For pedagogy; final solution further accelerates by splitting at the middle diagonal.

from typing import List, Dict, Tuple

def _prune_maximal(masks):
    # Keep only masks not subset of another (maximal by inclusion).
    uniq = list(set(masks))
    uniq.sort(key=lambda x: x.bit_count(), reverse=True)
    kept = []
    for m in uniq:
        dominated = False
        for k in kept:
            if (m | k) == k:  # m is subset of k
                dominated = True
                break
        if not dominated:
            kept.append(m)
    return kept

def feasible_dp_no_mitm(n: int, d: List[List[int]], r: List[List[int]], K: int) -> bool:
    if K == 0:
        return True
    target = (1 << K) - 1

    def bit_for(val: int) -> int:
        return (1 << val) if 0 <= val < K else 0

    # Layered DP from (0,0) to (n-1,n-1)
    from collections import defaultdict
    cur: Dict[Tuple[int, int], List[int]] = {(0, 0): [0]}
    total_steps = 2 * n - 2
    for _ in range(total_steps):
        nxt: Dict[Tuple[int, int], List[int]] = defaultdict(list)
        for (i, j), masks in cur.items():
            for m in masks:
                # right
                if j + 1 < n:
                    nxt[(i, j + 1)].append(m | bit_for(r[i][j]))
                # down
                if i + 1 < n:
                    nxt[(i + 1, j)].append(m | bit_for(d[i][j]))
        # prune per cell
        cur = {pos: _prune_maximal(ms) for pos, ms in nxt.items()}
        if not cur:
            return False
    return any(m == target for m in cur.get((n - 1, n - 1), []))

# Tiny sanity (agree with brute on tiny)
assert feasible_dp_no_mitm(2, [[0,1]], [[1],[0]], 1) is True
assert feasible_dp_no_mitm(2, [[0,1]], [[1],[0]], 2) is False
assert feasible_dp_no_mitm(2, [[1,1]], [[0],[0]], 2) is True
\end{minted}
\VALIDATION{Verified on $n=2$ toy cases and agrees with brute force for those.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Binary Search + Meet-in-the-Middle on the Middle Diagonal}
\WHICHFORMULA{Feasibility($k$) is decided by splitting paths at anti-diagonal $x+y=n+1$ (exactly $n-1$ steps from both ends). Enumerate forward masks to the diagonal and backward masks from $(n,n)$ to the diagonal, prune by dominance, then check if any forward/backward mask pair covers all $k$ labels. Use binary search over $k$.}
\ASSUMPTIONS{Half-path length is $n-1\le 19$, strongly limiting per-half mask sizes, even when $k$ can be as large as $2n-2\le 38$. Subset-dominance pruning keeps only inclusion-maximal masks per cell.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Binary search $k\in[0,2n-2]$.
\item For fixed $k$, map each label $<k$ to a bit. Define target bitmask with $k$ ones.
\item Forward DP for exactly $n-1$ steps from $(1,1)$ to all cells on diagonal $x+y=n+1$, collecting reachable masks; prune per cell by inclusion-maximality.
\item Backward DP for exactly $n-1$ steps from $(n,n)$ to the same diagonal (moving up/left), collecting masks; prune similarly.
\item For each diagonal cell, check if there exists $f$ in forward-masks and $b$ in backward-masks such that $(f\ \texttt{|}\ b)$ equals the target mask (i.e., $b$ is a superset of missing bits of $f$). If any cell passes, feasible.
\end{algosteps}
\OPTIMALITY{Meet-in-the-middle cuts the path length from $2n-2$ to $n-1$ per direction, curbing the number of distinct masks per cell. Dominance pruning ensures no unnecessary masks are carried. This is a standard optimal approach for fixed-length monotone grid paths with small per-half length.}
\COMPLEXITY{Let $M$ be the pruned mask count per diagonal cell (empirically modest). Then feasibility($k$) runs in roughly $O(n\cdot M^2)$ for pairing, plus $O(n^2\cdot M)$ for propagation and pruning. Overall binary search multiplies by $O(\log n)$.}
\[
\begin{aligned}
T(n) &\approx O\!\big(\log n \cdot (n^2 M + n M^2)\big),\quad S(n)=O(n M).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts

from typing import List, Tuple, Dict
from collections import defaultdict
import sys

def _prune_maximal(masks):
    # Keep only masks not subset of another (maximal by inclusion).
    uniq = list(set(masks))
    uniq.sort(key=lambda x: x.bit_count(), reverse=True)
    kept = []
    for m in uniq:
        dominated = False
        for k in kept:
            if (m | k) == k:  # m is subset of k
                dominated = True
                break
        if not dominated:
            kept.append(m)
    return kept

def _forward_masks_to_diag(n: int, d: List[List[int]], r: List[List[int]], K: int) -> Dict[Tuple[int,int], List[int]]:
    def bit_for(v: int) -> int:
        return (1 << v) if 0 <= v < K else 0
    cur: Dict[Tuple[int,int], List[int]] = {(0, 0): [0]}
    steps = n - 1
    for _ in range(steps):
        nxt: Dict[Tuple[int,int], List[int]] = defaultdict(list)
        for (i, j), ms in cur.items():
            for m in ms:
                if j + 1 < n:
                    nxt[(i, j + 1)].append(m | bit_for(r[i][j]))
                if i + 1 < n:
                    nxt[(i + 1, j)].append(m | bit_for(d[i][j]))
        cur = {pos: _prune_maximal(ms) for pos, ms in nxt.items()}
    # cur now maps diagonal cells (i+j == n-1) to lists of masks
    return cur

def _backward_masks_to_diag(n: int, d: List[List[int]], r: List[List[int]], K: int) -> Dict[Tuple[int,int], List[int]]:
    def bit_for(v: int) -> int:
        return (1 << v) if 0 <= v < K else 0
    cur: Dict[Tuple[int,int], List[int]] = {(n - 1, n - 1): [0]}
    steps = n - 1
    for _ in range(steps):
        nxt: Dict[Tuple[int,int], List[int]] = defaultdict(list)
        for (i, j), ms in cur.items():
            for m in ms:
                # move left: uses r[i][j-1] edge
                if j - 1 >= 0:
                    nxt[(i, j - 1)].append(m | bit_for(r[i][j - 1]))
                # move up: uses d[i-1][j] edge
                if i - 1 >= 0:
                    nxt[(i - 1, j)].append(m | bit_for(d[i - 1][j]))
        cur = {pos: _prune_maximal(ms) for pos, ms in nxt.items()}
    return cur

def feasible_mitm(n: int, d: List[List[int]], r: List[List[int]], K: int) -> bool:
    if K == 0:
        return True
    target = (1 << K) - 1
    fwd = _forward_masks_to_diag(n, d, r, K)
    bwd = _backward_masks_to_diag(n, d, r, K)
    cells = set(fwd.keys()) & set(bwd.keys())
    for pos in cells:
        F = _prune_maximal(fwd[pos])
        B = _prune_maximal(bwd[pos])
        for f in F:
            need = target & (~f)
            for b in B:
                if (b & need) == need:
                    return True
    return False

def solve_case(n: int, d: List[List[int]], r: List[List[int]]) -> int:
    lo, hi = 0, 2 * n - 2
    while lo < hi:
        mid = (lo + hi + 1) // 2
        if feasible_mitm(n, d, r, mid):
            lo = mid
        else:
            hi = mid - 1
    return lo

def read_input() -> Tuple[int, List[Tuple[int, List[List[int]], List[List[int]]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(t):
        n = int(next(it))
        d = [[int(next(it)) for _ in range(n)] for __ in range(n - 1)]
        r = [[int(next(it)) for _ in range(n - 1)] for __ in range(n)]
        tests.append((n, d, r))
    return t, tests

def solve_all():
    t, tests = read_input()
    out_lines = []
    for n, d, r in tests:
        out_lines.append(str(solve_case(n, d, r)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Basic sanity asserts (do not print).
    assert solve_case(2, [[0,1]], [[1],[0]]) == 1
    assert solve_case(2, [[1,1]], [[0],[0]]) == 2
    # All zeros -> MEX is 1 regardless of n.
    assert solve_case(3, [[0,0,0],[0,0,0]], [[0,0],[0,0],[0,0]]) == 1
    # Now run solver on stdin.
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts included:
1) $n=2$, $d=\bigl[\,[0,1]\,\bigr]$, $r=\bigl[\,[1],[0]\,\bigr]$ gives $1$.
2) $n=2$, $d=\bigl[\,[1,1]\,\bigr]$, $r=\bigl[\,[0],[0]\,\bigr]$ gives $2$.
3) All-zero labels yield answer $1$ for $n=3$.}
\RESULT{Print, for each test, the maximum achievable MEX along a path from $(1,1)$ to $(n,n)$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted $n=2$ cases, random tiny grids to cross-check brute force vs. meet-in-the-middle, and degenerate all-zero labels.}
\LINE{CROSS-CHECKS}{For small $n$ (e.g., $n\le 4$), compare Approach~A and Approach~C outputs on random instances to ensure consistency.}
\LINE{EDGE-CASE GENERATOR}{Generate extreme label patterns: all equal, alternating $0/1$, increasing stripes, and labels concentrated on one half of the grid.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

def gen_all_zero(n: int):
    d = [[0] * n for _ in range(n - 1)]
    r = [[0] * (n - 1) for _ in range(n)]
    return d, r

def gen_stripes(n: int):
    # Horizontal stripes alternating labels 0 and 1; vertical all 0
    d = [[0] * n for _ in range(n - 1)]
    r = [[(i % 2) for _ in range(n - 1)] for i in range(n)]
    return d, r

def gen_diag_increasing(n: int):
    # Labels grow with Manhattan distance, clipped to 2n-2
    d = [[min(i + j + 1, 2 * n - 2) for j in range(n)] for i in range(n - 1)]
    r = [[min(i + j + 1, 2 * n - 2) for j in range(n - 1)] for i in range(n)]
    return d, r

# Cross-check tiny instances
if __name__ == "__main__":
    import random
    random.seed(0)
    for n in range(2, 5):
        for _ in range(20):
            d = [[random.randint(0, 2 * n - 2) for _ in range(n)] for __ in range(n - 1)]
            r = [[random.randint(0, 2 * n - 2) for _ in range(n - 1)] for __ in range(n)]
            # Compare brute (only tiny) and final
            from math import comb
            if comb(2 * n - 2, n - 1) <= 10000:
                assert brute_max_mex(n, d, r) == solve_case(n, d, r)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts

from typing import List, Tuple, Dict
from collections import defaultdict
import sys

def _prune_maximal(masks):
    uniq = list(set(masks))
    uniq.sort(key=lambda x: x.bit_count(), reverse=True)
    kept = []
    for m in uniq:
        dominated = False
        for k in kept:
            if (m | k) == k:
                dominated = True
                break
        if not dominated:
            kept.append(m)
    return kept

def _forward_masks_to_diag(n: int, d: List[List[int]], r: List[List[int]], K: int) -> Dict[Tuple[int,int], List[int]]:
    def bit_for(v: int) -> int:
        return (1 << v) if 0 <= v < K else 0
    cur: Dict[Tuple[int,int], List[int]] = {(0, 0): [0]}
    for _ in range(n - 1):
        nxt: Dict[Tuple[int,int], List[int]] = defaultdict(list)
        for (i, j), ms in cur.items():
            for m in ms:
                if j + 1 < n:
                    nxt[(i, j + 1)].append(m | bit_for(r[i][j]))
                if i + 1 < n:
                    nxt[(i + 1, j)].append(m | bit_for(d[i][j]))
        cur = {pos: _prune_maximal(ms) for pos, ms in nxt.items()}
    return cur

def _backward_masks_to_diag(n: int, d: List[List[int]], r: List[List[int]], K: int) -> Dict[Tuple[int,int], List[int]]:
    def bit_for(v: int) -> int:
        return (1 << v) if 0 <= v < K else 0
    cur: Dict[Tuple[int,int], List[int]] = {(n - 1, n - 1): [0]}
    for _ in range(n - 1):
        nxt: Dict[Tuple[int,int], List[int]] = defaultdict(list)
        for (i, j), ms in cur.items():
            for m in ms:
                if j - 1 >= 0:
                    nxt[(i, j - 1)].append(m | bit_for(r[i][j - 1]))
                if i - 1 >= 0:
                    nxt[(i - 1, j)].append(m | bit_for(d[i - 1][j]))
        cur = {pos: _prune_maximal(ms) for pos, ms in nxt.items()}
    return cur

def feasible_mitm(n: int, d: List[List[int]], r: List[List[int]], K: int) -> bool:
    if K == 0:
        return True
    target = (1 << K) - 1
    fwd = _forward_masks_to_diag(n, d, r, K)
    bwd = _backward_masks_to_diag(n, d, r, K)
    cells = set(fwd.keys()) & set(bwd.keys())
    for pos in cells:
        F = _prune_maximal(fwd[pos])
        B = _prune_maximal(bwd[pos])
        for f in F:
            need = target & (~f)
            for b in B:
                if (b & need) == need:
                    return True
    return False

def solve_case(n: int, d: List[List[int]], r: List[List[int]]) -> int:
    lo, hi = 0, 2 * n - 2
    while lo < hi:
        mid = (lo + hi + 1) // 2
        if feasible_mitm(n, d, r, mid):
            lo = mid
        else:
            hi = mid - 1
    return lo

def read_input() -> Tuple[int, List[Tuple[int, List[List[int]], List[List[int]]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(t):
        n = int(next(it))
        d = [[int(next(it)) for _ in range(n)] for __ in range(n - 1)]
        r = [[int(next(it)) for _ in range(n - 1)] for __ in range(n)]
        tests.append((n, d, r))
    return t, tests

def solve_all():
    t, tests = read_input()
    out_lines = []
    for n, d, r in tests:
        out_lines.append(str(solve_case(n, d, r)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Exactly 3 asserts as validation
    assert solve_case(2, [[0,1]], [[1],[0]]) == 1
    assert solve_case(2, [[1,1]], [[0],[0]]) == 2
    assert solve_case(3, [[0,0,0],[0,0,0]], [[0,0],[0,0],[0,0]]) == 1
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the MEX of labels along a monotone path by ensuring coverage of $\{0,\ldots,k-1\}$ for the largest feasible $k$.}
\WHY{Meet-in-the-middle with inclusion pruning is a powerful pattern for fixed-length grid paths and subset-coverage goals, common in high-difficulty interview/contest tasks.}
\CHECKLIST{- Binary search $k$ using monotonicity.
- Split at the middle diagonal ($n-1$ steps each side).
- Forward/backward DP collecting masks of labels $<k$.
- Prune masks by inclusion-maximality per cell.
- Combine per diagonal cell: check if any pair covers all $k$ labels.}
\EDGECASES{- $n=2$ smallest grid.
- All edge labels identical.
- Labels concentrated on either horizontal or vertical edges.
- $k=0$ trivially feasible.
- Large $k$ near $2n-2$.
- Paths that must zig-zag to collect rare labels.}
\PITFALLS{- Off-by-one in matrix shapes: $d$ is $(n-1)\times n$, $r$ is $n\times(n-1)$.
- Wrong edge mapping when moving left/up in backward DP.
- Forgetting to mask with $K$: labels $\ge K$ must not set bits.
- Skipping dominance pruning leads to state explosion.
- Using XOR instead of complement for missing bits; must use $need = target\ \&\ \sim f$.}
\FAILMODES{Pure brute force fails immediately for $n\ge 10$. DP without meet-in-the-middle can blow up on adversarial labels; splitting at the diagonal plus pruning avoids worst proliferation in practice.}
\ELI{We try to collect all small numbers along a path. Because every path has two halves, we separately track which small numbers we can gather in the first and in the second half, keep only the best variants, and see if some pair covers all required numbers. This is repeated for $k$ by binary search.}
\NotePages{3}

\end{document}