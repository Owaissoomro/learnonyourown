% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Flowers and Chocolate}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/865/G}}
\LINE{DIFFICULTY / RATING}{CF: 865/G \quad Rating: 3300}
\STATEMENT{It is Piegirl's birthday soon, and Pieguy has decided to buy her a bouquet of flowers and a basket of chocolates.

The flower shop has $F$ different types of flowers available. The $i$-th type of flower always has exactly $p_i$ petals. Pieguy has decided to buy a bouquet consisting of exactly $N$ flowers. He may buy the same type of flower multiple times. The $N$ flowers are then arranged into a bouquet. The position of the flowers within a bouquet matters. You can think of a bouquet as an ordered list of flower types.

The chocolate shop sells chocolates in boxes. There are $B$ different types of boxes available. The $i$-th type of box contains $c_i$ pieces of chocolate. Pieguy can buy any number of boxes, and can buy the same type of box multiple times. He will then place these boxes into a basket. The position of the boxes within the basket matters. You can think of the basket as an ordered list of box types.

Pieguy knows that Piegirl likes to pluck a petal from a flower before eating each piece of chocolate. He would like to ensure that she eats the last piece of chocolate from the last box just after plucking the last petal from the last flower. That is, the total number of petals on all the flowers in the bouquet should equal the total number of pieces of chocolate in all the boxes in the basket.

How many different bouquet+basket combinations can Pieguy buy? The answer may be very large, so compute it modulo $1{,}000{,}000{,}007 = 10^9 + 7$.

Input:
The first line of input will contain integers $F$, $B$, and $N$ ($1 \le F \le 10$, $1 \le B \le 100$, $1 \le N \le 10^{18}$), the number of types of flowers, the number of types of boxes, and the number of flowers that must go into the bouquet, respectively.

The second line of input will contain $F$ integers $p_1, p_2, \ldots, p_F$ ($1 \le p_i \le 10^9$), the numbers of petals on each of the flower types.

The third line of input will contain $B$ integers $c_1, c_2, \ldots, c_B$ ($1 \le c_i \le 250$), the number of pieces of chocolate in each of the box types.

Output:
Print the number of bouquet+basket combinations Pieguy can buy, modulo $1{,}000{,}000{,}007 = 10^9 + 7$.

Note:
In the first example, there is 1 way to make a bouquet with 9 petals ($3 + 3 + 3$), and 1 way to make a basket with 9 pieces of chocolate ($3 + 3 + 3$), for 1 possible combination. There are 3 ways to make a bouquet with 13 petals ($3 + 5 + 5$, $5 + 3 + 5$, $5 + 5 + 3$), and 5 ways to make a basket with 13 pieces of chocolate ($3 + 10$, $10 + 3$, $3 + 3 + 7$, $3 + 7 + 3$, $7 + 3 + 3$), for 15 more combinations. Finally there is 1 way to make a bouquet with 15 petals ($5 + 5 + 5$) and 1 way to make a basket with 15 pieces of chocolate ($3 + 3 + 3 + 3 + 3$), for 1 more combination.

Note that it is possible for multiple types of flowers to have the same number of petals. Such types are still considered different. Similarly different types of boxes may contain the same number of pieces of chocolate, but are still considered different.}
\BREAKDOWN{Count ordered length-$N$ flower sequences by total petals and ordered chocolate-box sequences by total pieces, match equal totals, and sum products. The chocolate sequences have a short linear recurrence in the total pieces. Transform the sum into algebra on polynomials/linear recurrences to handle huge $N$.}
\ELI{Make a matrix that advances the chocolate-count DP by one piece; sum its $p_i$-th powers to a polynomial in that matrix; raise it to $N$ and read off the answer via a short vector dot product.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case.
\begin{bullets}
\item Integers $F,B,N$ with $1 \le F \le 10$, $1 \le B \le 100$, $1 \le N \le 10^{18}$.
\item List $p_1,\ldots,p_F$ with $1 \le p_i \le 10^9$.
\item List $c_1,\ldots,c_B$ with $1 \le c_i \le 250$.
\end{bullets}}
\OUTPUTS{One integer: the number of ordered bouquet+basket pairs whose total petals equal total chocolates, modulo $1{,}000{,}000{,}007$.}
\SAMPLES{
Example 1:
\begin{bullets}
\item Input
\[
\begin{aligned}
F&B&N\\
2&3&3\\
3&5\\
3&7&10
\end{aligned}
\]
\item Output: 17
\end{bullets}
Example 2:
\begin{bullets}
\item Input
\[
\begin{aligned}
F&B&N\\
1&2&4\\
1\\
1&1
\end{aligned}
\]
\item Output: $2^4=16$
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $P(x)=\sum_{i=1}^{F} x^{p_i}$ and $R(x)=\sum_{i=1}^{B} x^{c_i}$. The number of flower sequences of length $N$ with total $s$ petals is $[x^s]P(x)^N$. The number of chocolate sequences totaling $s$ is $B_s = [x^s]\dfrac{1}{1-R(x)}$ with $B_0=1$ and $B_s=0$ for $s<0$. The answer is
\begin{BreakableEquation*}
\sum_{s\ge 0} \bigl([x^s]P(x)^N\bigr)\, B_s = [x^0]\; P(x)^N \cdot \frac{1}{1-R(1/x)}.
\end{BreakableEquation*}%
}
\varmapStart
\var{F}{number of flower types}
\var{B}{number of box types}
\var{N}{number of flowers in bouquet (ordered)}
\var{p_i}{petal count of flower type $i$}
\var{c_i}{chocolate pieces in box type $i$}
\var{D}{maximum $c_i$}
\var{d_j}{number of box types with $c_i=j$}
\var{M}{modulus $1{,}000{,}000{,}007$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
B_s &= \sum_{j=1}^{D} d_j\, B_{s-j}\quad(s\ge 1),\quad B_0=1,\ B_s=0\ (s<0),\\
C(x) &= x^D - \sum_{j=1}^{D} d_j\, x^{D-j},\\
\text{Answer} &= \sum_{k=0}^{D-1} r_k\, B_k,\quad\text{where } R(x)\equiv P(x)^N \pmod{C(x)},\ \deg R < D,\ R(x)=\sum_{k=0}^{D-1} r_k x^k.
\end{aligned}
\]
}
\ASSUMPTIONS{Types with the same $p_i$ or $c_i$ are distinct and contribute multiplicities in $P(x)$ and $R(x)$. Arithmetic is over $\mathbb{Z}_M$.}
\INVARIANTS{
\begin{bullets}
\item $C(M)=0$ for the companion matrix $M$ of the recurrence for $B_s$.
\item In the quotient ring $\mathbb{Z}_M[x]/(C)$, $x^t$ reduces to a degree $<D$ polynomial via $x^D \equiv \sum_{j=1}^{D} d_j x^{D-j}$.
\item $P(M)^N$ reduces to $R(M)$ with $\deg R<D$, hence $e_1^\top P(M)^N v_0 = \sum_{k} r_k B_k$ with $v_0=(B_0,\ldots,B_{D-1})^\top$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct enumeration: sum over all ordered $N$-tuples of flower types, compute their total petals $s$, and multiply by the number of chocolate sequences totaling $s$ computed by a simple unbounded knapsack DP where order matters.}
\ASSUMPTIONS{Only feasible for tiny inputs (e.g., $F\le 3$, $N\le 8$, small $c_i$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all $F^N$ ordered sequences of flowers; tally counts $A_s$ of totals $s$.
\item Compute $B_s$ up to $\max s$ by DP: $B_0=1$ and $B_t=\sum_i B_{t-c_i}$ for $t\ge 1$.
\item Return $\sum_s A_s\, B_s \bmod M$.
\end{algosteps}
\COMPLEXITY{Exponential in $N$; polynomial in the maximum sum $S_{\max}$.
\[
\begin{aligned}
T(N) &= \Theta(F^N) + \Theta(S_{\max}\cdot B),\\
S(N) &= O(S_{\max}).
\end{aligned}
\]
}
\CORRECTNESS{Counts all ordered flower sequences exactly; the chocolate DP counts all ordered box sequences of each total. Multiplying and summing over totals yields the desired number of pairs.}
\EDGECASES{When $N=1$, $A_s$ is simply the count of $p_i=s$. Chocolate DP must handle $B_0=1$ (empty basket) but it is irrelevant if bouquet sums are strictly positive.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from itertools import product
MOD = 10**9 + 7

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    F = int(next(it)); B = int(next(it)); N = int(next(it))
    ps = [int(next(it)) for _ in range(F)]
    cs = [int(next(it)) for _ in range(B)]
    return (F, B, N, ps, cs)

def brute_count(F, B, N, ps, cs):
    # Enumerate all flower sequences; small only!
    sums = {}
    for seq in product(range(F), repeat=N):
        s = 0
        for idx in seq:
            s += ps[idx]
        sums[s] = (sums.get(s, 0) + 1) % MOD
    Smax = max(sums.keys()) if sums else 0
    # Order-sensitive unbounded DP for chocolates
    ways = [0] * (Smax + 1)
    ways[0] = 1
    for t in range(1, Smax + 1):
        w = 0
        for c in cs:
            if t - c >= 0:
                w += ways[t - c]
        ways[t] = w % MOD
    ans = 0
    for s, cnt in sums.items():
        ans = (ans + cnt * ways[s]) % MOD
    return ans

def solve_case():
    F, B, N, ps, cs = read_input()
    # Baseline is not intended for large inputs; still compute for small cases.
    return brute_count(F, B, N, ps, cs)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-checks
        assert brute_count(2, 3, 3, [3,5], [3,7,10]) == 17
        assert brute_count(1, 1, 4, [1], [1]) == 1  # 1 bouquet, 1 basket
        assert brute_count(1, 2, 4, [1], [1,1]) == pow(2,4,MOD)
        print("OK")
        return
    # Re-run parsing since we consumed it
    sys.stdin = sys.__stdin__
    sys.stdin = sys.__class__(open(0, 'rb'))
    F, B, N, ps, cs = map(int, data.split()[:3]), None, None, None, None  # dummy to silence linters
    # Read again properly
    sys.stdin.seek(0)
    out = solve_case()
    print(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked three tiny asserts, including the 17-combination example described in the note.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use generating functions: compute $A_s$ as coefficients of $P(x)^N$ by repeated squaring with truncation up to a maximum sum of interest; compute $B_s$ by linear DP; then sum $\sum_s A_s B_s$.}
\ASSUMPTIONS{This beats brute force when $N$ is modest and $\max p_i$ is small, because polynomial convolution with truncation avoids enumerating $F^N$ sequences. Still not feasible for $N\approx 10^{18}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $P(x)=\sum_i x^{p_i}$.
\item Compute $P(x)^N$ via exponentiation by squaring, truncating degrees at $S_{\max}$.
\item Compute $B_s$ for $0\le s\le S_{\max}$ by the order-sensitive unbounded DP.
\item Return the dot product of coefficient arrays.
\end{algosteps}
\COMPLEXITY{Let $S_{\max}$ be the truncation limit.
\[
\begin{aligned}
T(n) &= O(\log N \cdot S_{\max}^2 + S_{\max}\cdot B),\\
S(n) &= O(S_{\max}).
\end{aligned}
\]
}
\CORRECTNESS{Exponentiation-by-squaring on polynomials preserves coefficients, and truncation is valid if all nonzero $B_s$ for contributing $A_s$ lie within the cutoff.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
MOD = 10**9 + 7

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    F = int(next(it)); B = int(next(it)); N = int(next(it))
    ps = [int(next(it)) for _ in range(F)]
    cs = [int(next(it)) for _ in range(B)]
    return (F, B, N, ps, cs)

def poly_trim(a, Smax):
    if len(a) > Smax + 1:
        return a[:Smax+1]
    return a

def poly_add(a, b, Smax):
    n = max(len(a), len(b), Smax+1)
    c = [0]*n
    for i in range(min(len(a), n)):
        c[i] = (c[i] + a[i]) % MOD
    for i in range(min(len(b), n)):
        c[i] = (c[i] + b[i]) % MOD
    return poly_trim(c, Smax)

def poly_mul(a, b, Smax):
    n = min(len(a)+len(b)-1, Smax+1)
    c = [0]*n
    for i in range(len(a)):
        ai = a[i]
        if ai == 0: continue
        jmax = min(len(b)-1, Smax - i)
        for j in range(jmax+1):
            c[i+j] = (c[i+j] + ai * b[j]) % MOD
    return c

def poly_pow_trunc(P, N, Smax):
    # P is list where P[t] is coeff of x^t
    res = [1]
    base = poly_trim(P[:], Smax)
    e = N
    while e > 0:
        if e & 1:
            res = poly_mul(res, base, Smax)
        e >>= 1
        if e:
            base = poly_mul(base, base, Smax)
    return poly_trim(res, Smax)

def improved(F, B, N, ps, cs, Smax):
    # Build P(x)
    P = [0]*(min(Smax, max(ps)*N if ps else 0)+1 if Smax>0 else 1)
    for p in ps:
        if p <= Smax:
            if len(P) <= p:
                P += [0]*(p - len(P) + 1)
            P[p] = (P[p] + 1) % MOD
    PA = poly_pow_trunc(P, N, Smax)
    # Chocolates ways up to Smax
    ways = [0]*(Smax+1)
    ways[0] = 1
    for s in range(1, Smax+1):
        total = 0
        for c in cs:
            if s - c >= 0:
                total += ways[s-c]
        ways[s] = total % MOD
    ans = 0
    for s in range(min(len(PA), Smax+1)):
        ans = (ans + PA[s] * ways[s]) % MOD
    return ans

def solve_case():
    F, B, N, ps, cs = read_input()
    # Heuristic Smax for small tests; for real usage, this approach is not for large inputs.
    Smax = min(200, N * (max(ps) if ps else 0))
    return improved(F, B, N, ps, cs, Smax)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Tiny validations
        assert improved(2, 3, 3, [3,5], [3,7,10], 20) == 17
        assert improved(1, 2, 4, [1], [1,1], 10) == pow(2,4,MOD)
        print("OK")
        return
    sys.stdin.seek(0)
    out = solve_case()
    print(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Two asserts on tiny inputs, including the 17-answer case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Let $D=\max c_i$ and $d_j=\#\{i: c_i=j\}$. The chocolate totals sequence $(B_s)$ satisfies $B_s=\sum_{j=1}^{D} d_j B_{s-j}$ with $B_0=1$, giving the companion polynomial $C(x)=x^D-\sum_{j=1}^{D} d_j x^{D-j}$. Let $P(x)=\sum_{i=1}^{F} x^{p_i}$. Then the answer equals
\begin{BreakableEquation*}
\sum_{k=0}^{D-1} r_k B_k \quad\text{where}\quad R(x)\equiv P(x)^N \pmod{C(x)},\ \deg R<D.
\end{BreakableEquation*}
Compute $R(x)$ by binary exponentiation with polynomial multiplication modulo $C(x)$ using the reduction $x^D \equiv \sum_{j=1}^{D} d_j x^{D-j}$.}
\ASSUMPTIONS{Works for all valid inputs since $D\le 250$ and $F\le 10$. Arithmetic mod $M=1{,}000{,}000{,}007$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build counts $d_j$ for $1\le j\le D$, and compute $B_k$ for $0\le k\le D-1$ from the recurrence.
\item For each flower type petal count $p$, compute $X^{p} \bmod C(x)$ via fast exponentiation; sum these to obtain $P(x) \bmod C(x)$.
\item Compute $R(x) \equiv P(x)^N \bmod C(x)$ by binary exponentiation with modular polynomial multiplication.
\item Answer $= \sum_{k=0}^{D-1} R_k \cdot B_k \bmod M$.
\end{algosteps}
\OPTIMALITY{Binary exponentiation uses $O(\log N)$ modular polynomial multiplications; each multiplication costs $O(D^2)$ via dense convolution and $O(D^2)$ reduction. Precomputation for $P(x)$ costs $O(F D^2 \log \max p)$. This is tight in this framework since any method must at least account for the $D$-degree recurrence.}
\COMPLEXITY{Let $D=\max c_i \le 250$.
\[
\begin{aligned}
T(n) &= O\bigl(F D^2 \log(\max p_i) + D^2 \log N\bigr),\\
S(n) &= O(D).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List

MOD = 10**9 + 7

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    F = int(next(it)); B = int(next(it)); N = int(next(it))
    ps = [int(next(it)) for _ in range(F)]
    cs = [int(next(it)) for _ in range(B)]
    return (F, B, N, ps, cs)

def build_counts(cs: List[int]):
    D = max(cs) if cs else 0
    d = [0] * (D + 1)  # d[j] for j=0..D
    for c in cs:
        d[c] += 1
    return D, d

def poly_reduce_inplace(coefs: List[int], D: int, d: List[int]):
    # Reduce polynomial (list of coefficients, possibly length > D) modulo C(x)=x^D - sum d_j x^{D-j}
    # Reduction: for t from deg down to D, fold coef[t] * x^t using x^D ≡ sum d_j x^{D-j}
    t = len(coefs) - 1
    while t >= D:
        ct = coefs[t] % MOD
        if ct:
            for j in range(1, D + 1):
                dj = d[j]
                if dj:
                    coefs[t - j] = (coefs[t - j] + ct * dj) % MOD
        t -= 1
    # Truncate to degree < D
    del coefs[D:]

def poly_add_mod(a: List[int], b: List[int], D: int) -> List[int]:
    n = max(len(a), len(b), D)
    c = [0] * n
    for i in range(min(len(a), n)):
        c[i] = (c[i] + a[i]) % MOD
    for i in range(min(len(b), n)):
        c[i] = (c[i] + b[i]) % MOD
    if len(c) > D:
        del c[D:]
    return c

def poly_mul_mod(a: List[int], b: List[int], D: int, d: List[int]) -> List[int]:
    # Multiply two polynomials (deg < D), then reduce modulo C
    res_len = min(len(a) + len(b) - 1, 2 * D - 1)
    c = [0] * res_len
    for i in range(len(a)):
        ai = a[i]
        if ai == 0:
            continue
        jmax = min(len(b) - 1, res_len - 1 - i)
        for j in range(jmax + 1):
            c[i + j] = (c[i + j] + ai * b[j]) % MOD
    if len(c) > D:
        poly_reduce_inplace(c, D, d)
    # Ensure length D
    if len(c) < D:
        c += [0] * (D - len(c))
    elif len(c) > D:
        del c[D:]
    return c

def poly_pow_mod(base: List[int], exp: int, D: int, d: List[int]) -> List[int]:
    # Exponentiate polynomial modulo C
    # Represent polynomials with length D (deg < D)
    res = [0] * D
    res[0] = 1  # 1
    b = base[:]
    e = exp
    while e > 0:
        if e & 1:
            res = poly_mul_mod(res, b, D, d)
        e >>= 1
        if e:
            b = poly_mul_mod(b, b, D, d)
    return res

def pow_x_mod(p: int, D: int, d: List[int]) -> List[int]:
    # Compute x^p mod C(x) as degree < D polynomial
    if D == 0:
        return []
    X = [0] * D
    if D >= 2:
        X[1] = 1  # x
    else:
        # D == 1, then C(x) = x - d1, so x ≡ d1 (constant)
        X[0] = d[1] % MOD
    return poly_pow_mod(X, p, D, d)

def compute_B_prefix(D: int, d: List[int]) -> List[int]:
    Bvals = [0] * max(1, D)
    if D == 0:
        return Bvals
    Bvals[0] = 1
    for s in range(1, D):
        total = 0
        for j in range(1, min(D, s) + 1):
            if d[j]:
                total += d[j] * Bvals[s - j]
        Bvals[s] = total % MOD
    return Bvals

def solve_all():
    inp = read_input()
    if inp is None:
        return
    F, B, N, ps, cs = inp
    D, d = build_counts(cs)
    # Edge: If no boxes (not possible by constraints) or D==0, but B>=1 so D>=1.
    # Build P(x) mod C
    P = [0] * D
    for p in ps:
        poly = pow_x_mod(p, D, d)
        # P += poly
        for i in range(D):
            P[i] = (P[i] + poly[i]) % MOD
    # R(x) = P(x)^N mod C
    R = poly_pow_mod(P, N, D, d)
    # Precompute B_0..B_{D-1}
    Bvals = compute_B_prefix(D, d)
    # Answer is sum R_k * B_k
    ans = 0
    for k in range(D):
        ans = (ans + R[k] * (Bvals[k] if k < len(Bvals) else 0)) % MOD
    print(ans)

def test_small():
    # Example from statement note
    F, B, N, ps, cs = 2, 3, 3, [3,5], [3,7,10]
    sys.setrecursionlimit(1 << 25)
    # Brute for cross-check
    def brute(F, B, N, ps, cs):
        from itertools import product
        sums = {}
        for seq in product(range(F), repeat=N):
            s = sum(ps[i] for i in seq)
            sums[s] = (sums.get(s, 0) + 1) % MOD
        Smax = max(sums) if sums else 0
        ways = [0] * (Smax + 1)
        ways[0] = 1
        for t in range(1, Smax + 1):
            ways[t] = sum(ways[t - c] for c in cs if t - c >= 0) % MOD
        return sum((sums[s] * ways[s]) % MOD for s in sums) % MOD
    # Run optimal and brute
    def run_opt(F, B, N, ps, cs):
        D, d = build_counts(cs)
        P = [0] * D
        for p in ps:
            poly = pow_x_mod(p, D, d)
            for i in range(D):
                P[i] = (P[i] + poly[i]) % MOD
        R = poly_pow_mod(P, N, D, d)
        Bvals = compute_B_prefix(D, d)
        ans = sum((R[i] * Bvals[i]) % MOD for i in range(D)) % MOD
        return ans
    assert run_opt(F, B, N, ps, cs) == 17
    assert run_opt(1, 1, 4, [1], [1]) == 1
    assert run_opt(1, 2, 4, [1], [1,1]) == pow(2,4,MOD)
    # Random tiny checks
    import random
    random.seed(0)
    for _ in range(30):
        F = random.randint(1, 3)
        B = random.randint(1, 4)
        N = random.randint(1, 5)
        ps = [random.randint(1, 5) for _ in range(F)]
        cs = [random.randint(1, 5) for _ in range(B)]
        assert run_opt(F, B, N, ps, cs) == brute(F, B, N, ps, cs)
    print("OK")

def main():
    data = sys.stdin.read()
    if not data.strip():
        test_small()
        return
    # Re-feed and solve
    sys.stdin = sys.__stdin__
    sys.stdin = sys.__class__(open(0, 'rb'))
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts: the 17-answer example, and two sanity cases; plus 30 randomized tiny cross-checks against a brute-force enumerator when no input is provided.}
\RESULT{The printed number is the count of ordered bouquet+basket pairs with equal total petals/pieces, modulo $1{,}000{,}000{,}007$. There is no tie-breaking.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on crafted small instances, randomized fuzzing with small bounds vs. brute force, and explicit cross-check of the illustrative 17-answer case.}
\LINE{CROSS-CHECKS}{Compare Approach C against Approach A on dozens of tiny random cases; ensure exact equality modulo $M$.}
\LINE{EDGE-CASE GENERATOR}{Generates tiny $F,B,N$ with repeated $p_i$ or $c_i$, and extreme $D=1$ or $D$ near 6 to stress recurrence and modulus reduction.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_cases(seed=123, trials=20):
    random.seed(seed)
    cases = []
    for _ in range(trials):
        F = random.randint(1, 3)
        B = random.randint(1, 4)
        N = random.randint(1, 5)
        ps = [random.randint(1, 6) for _ in range(F)]
        cs = [random.randint(1, 6) for _ in range(B)]
        cases.append((F, B, N, ps, cs))
    # Add edgey ones
    cases.append((1, 1, 5, [1], [1]))
    cases.append((2, 3, 3, [3,5], [3,7,10]))
    cases.append((3, 4, 4, [1,1,1], [1,1,1,1]))
    return cases
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List

MOD = 10**9 + 7

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    F = int(next(it)); B = int(next(it)); N = int(next(it))
    ps = [int(next(it)) for _ in range(F)]
    cs = [int(next(it)) for _ in range(B)]
    return (F, B, N, ps, cs)

def build_counts(cs: List[int]):
    D = max(cs) if cs else 0
    d = [0] * (D + 1)
    for c in cs:
        d[c] += 1
    return D, d

def poly_reduce_inplace(coefs: List[int], D: int, d: List[int]):
    t = len(coefs) - 1
    while t >= D:
        ct = coefs[t] % MOD
        if ct:
            for j in range(1, D + 1):
                dj = d[j]
                if dj:
                    coefs[t - j] = (coefs[t - j] + ct * dj) % MOD
        t -= 1
    del coefs[D:]

def poly_mul_mod(a: List[int], b: List[int], D: int, d: List[int]) -> List[int]:
    res_len = min(len(a) + len(b) - 1, 2 * D - 1)
    c = [0] * res_len
    for i in range(len(a)):
        ai = a[i]
        if ai == 0: continue
        jmax = min(len(b) - 1, res_len - 1 - i)
        for j in range(jmax + 1):
            c[i + j] = (c[i + j] + ai * b[j]) % MOD
    if len(c) > D:
        poly_reduce_inplace(c, D, d)
    if len(c) < D:
        c += [0] * (D - len(c))
    elif len(c) > D:
        del c[D:]
    return c

def poly_pow_mod(base: List[int], exp: int, D: int, d: List[int]) -> List[int]:
    res = [0] * D
    if D > 0:
        res[0] = 1
    b = base[:]
    e = exp
    while e > 0:
        if e & 1:
            res = poly_mul_mod(res, b, D, d)
        e >>= 1
        if e:
            b = poly_mul_mod(b, b, D, d)
    return res

def pow_x_mod(p: int, D: int, d: List[int]) -> List[int]:
    if D == 0:
        return []
    X = [0] * D
    if D >= 2:
        X[1] = 1
    else:
        X[0] = d[1] % MOD
    return poly_pow_mod(X, p, D, d)

def compute_B_prefix(D: int, d: List[int]) -> List[int]:
    Bvals = [0] * max(1, D)
    if D == 0:
        return Bvals
    Bvals[0] = 1
    for s in range(1, D):
        total = 0
        for j in range(1, min(D, s) + 1):
            dj = d[j]
            if dj:
                total += dj * Bvals[s - j]
        Bvals[s] = total % MOD
    return Bvals

def solve_case():
    F, B, N, ps, cs = read_input()
    D, d = build_counts(cs)
    P = [0] * D
    for p in ps:
        poly = pow_x_mod(p, D, d)
        for i in range(D):
            P[i] = (P[i] + poly[i]) % MOD
    R = poly_pow_mod(P, N, D, d)
    Bvals = compute_B_prefix(D, d)
    ans = 0
    for k in range(D):
        ans = (ans + R[k] * (Bvals[k] if k < len(Bvals) else 0)) % MOD
    return ans

def solve_all():
    ans = solve_case()
    print(ans)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Minimal sanity asserts
        def run(F,B,N,ps,cs):
            D, d = build_counts(cs)
            P = [0]*D
            for p in ps:
                poly = pow_x_mod(p, D, d)
                for i in range(D):
                    P[i] = (P[i] + poly[i]) % MOD
            R = poly_pow_mod(P, N, D, d)
            Bvals = compute_B_prefix(D, d)
            return sum((R[i] * Bvals[i]) % MOD for i in range(D)) % MOD
        assert run(2,3,3,[3,5],[3,7,10]) == 17
        assert run(1,1,4,[1],[1]) == 1
        assert run(1,2,4,[1],[1,1]) == pow(2,4,MOD)
        print("OK")
        return
    sys.stdin = sys.__stdin__
    sys.stdin = sys.__class__(open(0, 'rb'))
    print(solve_case())

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce the problem to polynomial algebra modulo the chocolate-recurrence characteristic polynomial, then compute $P(x)^N \bmod C(x)$ and dot with the prefix of $(B_s)$.}
\WHY{This pattern (sum over equal totals across two ordered combinatorial classes) appears in hard interviews: it rewards comfort with generating functions, recurrences, and matrix/polynomial exponentiation.}
\CHECKLIST{
\begin{bullets}
\item Build $d_j$ counts and $D=\max c_i$.
\item Precompute $B_0,\ldots,B_{D-1}$.
\item Compute each $x^{p_i} \bmod C(x)$; sum to $P(x)\bmod C$.
\item Exponentiate: $R(x) \equiv P(x)^N \bmod C(x)$.
\item Answer $=\sum_{k=0}^{D-1} R_k B_k \bmod M$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Repeated $p_i$ or $c_i$; treat types as distinct via multiplicities in $P(x)$ and in $d_j$.
\item $D=1$ (all $c_i=1$): then $C(x)=x- B$; ensure $x \equiv B$ in modulus reduction.
\item Large $p_i$ up to $10^9$: use fast exponentiation for $x^{p_i} \bmod C(x)$.
\item $N=1$: result is $\sum_i B_{p_i}$.
\item Extremely skewed $d_j$ (e.g., only large $j$ present).
\item Modulo arithmetic throughout to avoid overflow.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting $B_0=1$ (empty chocolate sequence) in the recurrence.
\item Mishandling reduction: use $x^D \equiv \sum_j d_j x^{D-j}$, not $x^D \equiv \sum_j d_j x^j$.
\item Off-by-one on indices when folding high-degree coefficients during reduction.
\item Not padding/truncating polynomials to length $D$ consistently.
\item Treating identical $c_i$ as one type; they are distinct and must be counted via $d_j$.
\item Constructing $P(x)$ with monomials beyond modulus without reducing $x^{p_i}$ first.
\end{bullets}
}
\FAILMODES{Baseline and truncated DP fail for large $N$ or large sums. The optimal method survives because degree is bounded by $D\le 250$ and exponentiation is logarithmic in $N$.}
\ELI{Think of a machine that advances chocolate totals one by one. Each flower tells you to push that machine forward by $p_i$ steps. Summing over choices and doing it $N$ times boils down to raising a short polynomial (built from the flowers) to the $N$-th power in the world where $x^D$ can be shortened using the chocolate recurrence. The final dot product reads off the exact count.}
\NotePages{3}

\end{document}