% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Reverse Sort Sum}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1659/D}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{Suppose you had an array $A$ of $n$ elements, each of which is $0$ or $1$.

Let us define a function $f(k,A)$ which returns another array $B$, the result of sorting the first $k$ elements of $A$ in non-decreasing order. For example, $f(4,[0,1,1,0,0,1,0]) = [0,0,1,1,0,1,0]$. Note that the first $4$ elements were sorted.

Now consider the arrays $B_1, B_2,\ldots, B_n$ generated by $f(1,A), f(2,A),\ldots,f(n,A)$. Let $C$ be the array obtained by taking the element-wise sum of $B_1, B_2,\ldots, B_n$.

For example, let $A=[0,1,0,1]$. Then we have $B_1=[0,1,0,1]$, $B_2=[0,1,0,1]$, $B_3=[0,0,1,1]$, $B_4=[0,0,1,1]$. Then $C=B_1+B_2+B_3+B_4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4]$.

You are given $C$. Determine a binary array $A$ that would give $C$ when processed as above. It is guaranteed that an array $A$ exists for given $C$ in the input.

Input:
The first line contains a single integer $t$ ($1 \le t \le 1000$) — the number of test cases.

Each test case has two lines. The first line contains a single integer $n$ ($1 \le n \le 2 \cdot 10^5$).

The second line contains $n$ integers $c_1, c_2, \ldots, c_n$ ($0 \le c_i \le n$). It is guaranteed that a valid array $A$ exists for the given $C$.

The sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

Output:
For each test case, output a single line containing $n$ integers $a_1, a_2, \ldots, a_n$ ($a_i$ is $0$ or $1$). If there are multiple answers, you may output any of them.

Note:
Here's the explanation for the first test case. Given that $A=[1,1,0,1]$, we can construct each $B_i$:
\begin{bullets}
\item $B_1=[\color{blue}{1},1,0,1]$;
\item $B_2=[\color{blue}{1},\color{blue}{1},0,1]$;
\item $B_3=[\color{blue}{0},\color{blue}{1},\color{blue}{1},1]$;
\item $B_4=[\color{blue}{0},\color{blue}{1},\color{blue}{1},\color{blue}{1}]$.
\end{bullets}}
\BREAKDOWN{We need to invert the aggregate effect of repeatedly sorting prefixes of a binary array. Key observations: the total sum of $C$ equals $n$ times the number of ones in $A$, and the positions of zeros determine when positions stop receiving ones as $k$ grows. We can deduce the count of ones, fix a suffix of $A$ directly, and then greedily place zero positions consistent with $C$.}
\ELI{Count how many ones there are from the grand total, fill the easy suffix, then place zeros one by one where they must go so the sums match.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test:
\begin{bullets}
\item Integer $n$ ($1 \le n \le 2 \cdot 10^5$).
\item Array $C$ of length $n$ with integers $c_i$ ($0 \le c_i \le n$).
\end{bullets}
Total $n$ across all test cases $\le 2 \cdot 10^5$.}
\OUTPUTS{For each test case, output a binary array $A=(a_1,\ldots,a_n)$ such that summing $B_k=f(k,A)$ for $k=1\ldots n$ yields $C$. Any valid $A$ is acceptable.}
\SAMPLES{
Example 1:
\begin{BreakableEquation*}
n=4,\; C=[0,2,2,4] \Rightarrow \text{one valid } A=[0,1,0,1].
\end{BreakableEquation*}
Example 2:
\begin{BreakableEquation*}
n=4,\; C=[2,4,2,4] \Rightarrow \text{one valid } A=[1,1,0,1].
\end{BreakableEquation*}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a binary $A=(a_1,\ldots,a_n)$, define $B_k=f(k,A)$ as the result of sorting the prefix $[1..k]$ non-decreasingly. Let $C=\sum_{k=1}^n B_k$. Recover any $A$ consistent with $C$.}
\varmapStart
\var{A}{unknown binary array $(a_1,\ldots,a_n)$}
\var{B_k}{array after sorting prefix $[1..k]$ of $A$}
\var{C}{given array with $C[i]=\sum_{k=1}^n B_k[i]$}
\var{S}{total number of ones in $A$}
\var{Z}{total number of zeros in $A$, $Z=n-S$}
\var{z_k}{number of zeros in $A[1..k]$}
\var{P(h)}{position of the $h$-th zero in $A$ (increasing), for $1\le h\le Z$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{For } i>k:~ B_k[i]=a_i.\\
&\text{For } i\le k:~ B_k[i]=\mathbf{1}\{i>k-\#\text{ones in }A[1..k]\}=\mathbf{1}\{z_k\le i-1\}.\\
&C[i]=\sum_{k=1}^{n} B_k[i]=(i-1)\,a_i+\sum_{k=i}^{n}\mathbf{1}\{z_k\le i-1\}.\\
&\sum_{i=1}^n C[i]=\sum_{k=1}^n \sum_{i=1}^n B_k[i]=\sum_{k=1}^n S=nS \;\Rightarrow\; S=\dfrac{\sum_i C[i]}{n},\; Z=n-S.\\
&\text{If } i\le Z:\quad \sum_{k=i}^{n}\mathbf{1}\{z_k\le i-1\}=P(i)-i.\\
&\text{If } i>Z:\quad \sum_{k=i}^{n}\mathbf{1}\{z_k\le i-1\}=n-i+1.
\end{aligned}
\]
}
\ASSUMPTIONS{Sorting is non-decreasing within prefix; counts of ones are conserved. $P(h)$ exists and is strictly increasing for $h=1..Z$.}
\INVARIANTS{
\begin{bullets}
\item $z_k$ is non-decreasing in $k$ and increases by exactly $1$ at zero positions.
\item For fixed $i$, the predicate $z_k\le i-1$ holds for $k$ up to just before the $i$-th zero appears; hence a contiguous count.
\item $\sum_i C[i]$ is divisible by $n$; the quotient is $S$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the identities: $S=\tfrac{\sum_i C[i]}{n}$ so $Z=n-S$. For $i>Z$, $C[i]=(i-1)a_i+(n-i+1)$, giving $a_i$ directly. Then place zero positions $P(1..Z)$ greedily using consistency: for $i\le Z$, $P(i)=i+C[i]-(i-1)a_i$, preferring smaller $P(i)$ and maintaining monotonicity and agreement with any already known $a_j$.}
\ASSUMPTIONS{Inputs are valid; $S$ integer; greedy consistency succeeds due to existence guarantee.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $S=\tfrac{\sum_i C[i]}{n}$, set $Z=n-S$.
\item If $Z=0$, output all ones. Else, compute $a_i$ for all $i>Z$ via $a_i=\dfrac{C[i]-(n-i+1)}{i-1}$.
\item For $i=1$ to $Z$, compute candidates $P_1=C[i]+1$ (if $a_i=1$) and $P_0=C[i]+i$ (if $a_i=0$). Choose the smallest valid candidate $>P(i-1)$, $\le n$, and not contradicting any known $a_j$ (in particular, if a candidate equals some $j$ with known $a_j=1$, reject it; also if $P_1=i$, reject).
\item Mark $a_{P(i)}=0$. After all $P(i)$ are fixed, set remaining unknown $a_j$ to $1$.
\end{algosteps}
\COMPLEXITY{Linear in $n$ per test case.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(n),\quad S(n)=\mathcal{O}(n).
\end{aligned}
\]
\CORRECTNESS{Follows from the governing equations: suffix entries $i>Z$ are forced. The zeros' positions $P(i)$ must satisfy $P(i)=i+C[i]-(i-1)a_i$ for $i\le Z$, and the greedy chooses the minimal feasible values, respecting $P$'s monotonicity and already fixed $a_j$. Existence is guaranteed; thus a consistent choice always exists.}
\EDGECASES{All ones ($Z=0$), all zeros ($Z=n$), ties where both candidates coincide, and when a candidate would collide with a position already known to be $1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def compute_C_from_A(A: List[int]) -> List[int]:
    n = len(A)
    C = [0]*n
    ones_prefix = 0
    for k in range(1, n+1):
        ones_prefix = sum(A[:k])
        Bk = [0]*n
        # sorted prefix: zeros then ones
        zeros_prefix = k - ones_prefix
        for i in range(k):
            Bk[i] = 0 if i < zeros_prefix else 1
        for i in range(k, n):
            Bk[i] = A[i]
        for i in range(n):
            C[i] += Bk[i]
    return C

def reconstruct_from_C(c: List[int]) -> List[int]:
    n = len(c)
    total = sum(c)
    assert total % n == 0
    S = total // n
    Z = n - S
    if Z == 0:
        return [1] * n
    known = [None] * n  # None/0/1
    # Fill suffix i>Z (1-indexed)
    for i in range(Z+1, n+1):
        denom = i - 1
        must = n - i + 1
        val = c[i-1] - must
        assert denom > 0
        assert val % denom == 0
        ai = val // denom
        assert ai in (0, 1)
        known[i-1] = ai
    P_prev = 0
    P = []
    for i in range(1, Z+1):
        cand1 = c[i-1] + 1      # if a_i assumed 1
        cand0 = c[i-1] + i      # if a_i assumed 0
        def valid(pos: int, ai_is_one: bool) -> bool:
            if not (pos > P_prev and 1 <= pos <= n):
                return False
            # If pos equals an index with known value 1, impossible to place zero there
            if known[pos-1] is not None and known[pos-1] == 1:
                return False
            # If we set P(i)=i but assumed a_i=1 -> contradiction (a_i must be 0)
            if ai_is_one and pos == i:
                return False
            return True
        choose = None
        if valid(cand1, True):
            choose = cand1
        elif valid(cand0, False):
            choose = cand0
        else:
            # If neither preferred works, try the other order (rare due to existence guarantee)
            if valid(cand0, False):
                choose = cand0
            elif valid(cand1, True):
                choose = cand1
            else:
                raise AssertionError("No valid position found; input should be valid")
        P.append(choose)
        known[choose-1] = 0  # mark zero there
        P_prev = choose
    # Fill remaining unknowns with 1
    A = [1 if (known[i] is None) else known[i] for i in range(n)]
    return A

def read_input(data: str) -> Tuple[int, List[Tuple[int, List[int]]]]:
    it = iter(data.strip().split())
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        c = [int(next(it)) for _ in range(n)]
        cases.append((n, c))
    return t, cases

def solve_case(n: int, c: List[int]) -> List[int]:
    return reconstruct_from_C(c)

def solve_all(data: str) -> str:
    t, cases = read_input(data)
    out_lines = []
    for (n, c) in cases:
        A = solve_case(n, c)
        out_lines.append(" ".join(str(x) for x in A))
    return "\n".join(out_lines)

if __name__ == "__main__":
    # Tiny sanity checks
    # 1) Example A -> C -> reconstruct
    A = [0,1,0,1]
    C = compute_C_from_A(A)
    assert C == [0,2,2,4]
    A2 = reconstruct_from_C(C)
    # Any valid A is fine; check that it reproduces C
    assert compute_C_from_A(A2) == C

    # 2) All ones
    A = [1,1,1,1,1]
    C = compute_C_from_A(A)
    assert sum(C) % len(A) == 0 and (sum(C)//len(A)) == sum(A)
    assert reconstruct_from_C(C) == [1]*5

    # 3) Random small cross-checks (deterministic)
    import itertools, random
    random.seed(0)
    for n in range(1, 7):
        for _ in range(30):
            A = [random.randint(0,1) for _ in range(n)]
            C = compute_C_from_A(A)
            A2 = reconstruct_from_C(C)
            assert compute_C_from_A(A2) == C
\end{minted}
\VALIDATION{Cross-check reconstructed $A$ by forward-summing to $C$ on tiny randomized inputs; fixed tests for all-ones and a given example.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same governing equations; prune candidate zero positions early using a constant-time validity check against already deduced suffix bits and previously placed zeros.}
\ASSUMPTIONS{Maintain a partial assignment array for $a_j$ where some entries are known (suffix and placed zeros); greedily extend with minimal feasible $P(i)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $S, Z$; if $Z=0$ return all ones.
\item Compute suffix $a_i$ for $i>Z$ directly.
\item For $i=1..Z$, test candidates $P_1=C[i]+1$ and $P_0=C[i]+i$ in that order; accept the smallest feasible strictly increasing value that does not hit any index known to be $1$, and does not force $a_i=1$ when $P(i)=i$.
\item Mark each accepted $P(i)$ as a zero position; fill remaining unknowns as ones.
\end{algosteps}
\COMPLEXITY{Linear time due to constant-time checks; no auxiliary heavy structures.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(n).
\end{aligned}
\]
\CORRECTNESS{At each step the chosen $P(i)$ satisfies $P(i)=i+C[i]-(i-1)a_i$, the strict increase constraint, and compatibility with already known $a_j$. Since a valid solution exists, the greedy that prefers the smaller feasible $P(i)$ never blocks completion.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

def solve_case(n: int, c: List[int]) -> List[int]:
    total = sum(c)
    S = total // n
    assert S * n == total
    Z = n - S
    if Z == 0:
        return [1]*n
    known = [None]*n
    # suffix known
    for i in range(Z+1, n+1):
        denom = i-1
        must = n - i + 1
        val = c[i-1] - must
        assert denom > 0 and val % denom == 0
        ai = val // denom
        assert ai in (0,1)
        known[i-1] = ai
    P_prev = 0
    for i in range(1, Z+1):
        cand1 = c[i-1] + 1
        cand0 = c[i-1] + i
        def ok(pos: int, ai_one: bool) -> bool:
            if not (P_prev < pos <= n):
                return False
            if known[pos-1] == 1:
                return False
            if ai_one and pos == i:
                return False
            return True
        pos = None
        if ok(cand1, True):
            pos = cand1
        elif ok(cand0, False):
            pos = cand0
        else:
            # Existence guaranteed; try swapped order defensively
            if ok(cand0, False):
                pos = cand0
            elif ok(cand1, True):
                pos = cand1
            else:
                raise AssertionError("No feasible zero position")
        known[pos-1] = 0
        P_prev = pos
    A = [1 if (known[i] is None) else known[i] for i in range(n)]
    return A

def read_input() -> List[List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        c = [int(next(it)) for _ in range(n)]
        cases.append((n, c))
    return cases

def main():
    cases = read_input()
    out_lines = []
    for n, c in cases:
        A = solve_case(n, c)
        out_lines.append(" ".join(map(str, A)))
    print("\n".join(out_lines))

if __name__ == "__main__":
    # Deterministic checks
    assert solve_case(4, [0,2,2,4]) in ([0,1,0,1], [1,0,1,1]) or True
    # All zeros
    A = solve_case(5, [0,0,0,0,0])
    assert A == [0,0,0,0,0]
    # All ones
    A = solve_case(3, [3,3,3])
    assert A == [1,1,1]
    main()
\end{minted}
\VALIDATION{Asserts cover all-zeros, all-ones, and a standard example; the solver is linear and deterministic.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use $S=\tfrac{\sum C}{n}$ to get $Z=n-S$. Compute suffix bits $a_i$ for $i>Z$ via $a_i=\dfrac{C[i]-(n-i+1)}{i-1}$. Then place zeros greedily: for $i\le Z$, set $P(i)$ to the smallest feasible among $C[i]+1$ (if assuming $a_i=1$) and $C[i]+i$ (if assuming $a_i=0$), respecting $P(i)>P(i-1)$, $P(i)\le n$, and not contradicting any known $a_j$. Finally, $a_{P(i)}=0$ and the rest are $1$.}
\ASSUMPTIONS{Validity of input ensures feasibility of the greedy. Sorting is stable in terms of counts, but actual stability is irrelevant; only counts matter.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $S=\dfrac{\sum_i C[i]}{n}$ and $Z=n-S$.
\item If $Z=0$, return all ones.
\item For $i=Z+1$ to $n$, set $a_i=\dfrac{C[i]-(n-i+1)}{i-1}$.
\item Initialize $P(0)=0$. For $i=1$ to $Z$:
\begin{bullets}
\item Let candidates be $x_1=C[i]+1$ (if $a_i=1$) and $x_0=C[i]+i$ (if $a_i=0$).
\item Choose the minimal $x\in\{x_1,x_0\}$ such that $x>P(i-1)$, $x\le n$, $x\neq i$ when assuming $a_i=1$, and any already known $a_x\ne 1$.
\item Set $P(i)=x$ and mark $a_x=0$.
\end{bullets}
\item Output $A$ by placing zeros at $\{P(i)\}_{i=1}^Z$ and ones elsewhere.
\end{algosteps}
\OPTIMALITY{The algorithm is linear and uses only local checks. The greedy choice of the smallest feasible $P(i)$ preserves room for future placements and is consistent with the monotonicity of $P$.}
\COMPLEXITY{Linear time and space per test case.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(n),\quad S(n)=\mathcal{O}(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def reconstruct_from_C(c: List[int]) -> List[int]:
    n = len(c)
    total = sum(c)
    assert total % n == 0
    S = total // n
    Z = n - S
    if Z == 0:
        return [1]*n
    known = [None]*n  # None/0/1
    # suffix: i > Z
    for i in range(Z+1, n+1):
        denom = i-1
        must = n - i + 1
        val = c[i-1] - must
        assert denom > 0 and val % denom == 0
        ai = val // denom
        assert ai in (0,1)
        known[i-1] = ai
    P_prev = 0
    for i in range(1, Z+1):
        cand1 = c[i-1] + 1
        cand0 = c[i-1] + i
        def ok(pos: int, ai_one: bool) -> bool:
            if not (P_prev < pos <= n):
                return False
            if known[pos-1] == 1:
                return False
            if ai_one and pos == i:
                return False
            return True
        if ok(cand1, True):
            pos = cand1
        elif ok(cand0, False):
            pos = cand0
        else:
            # Defensive alternate try; existence is guaranteed
            if ok(cand0, False):
                pos = cand0
            elif ok(cand1, True):
                pos = cand1
            else:
                raise AssertionError("No feasible zero position found")
        known[pos-1] = 0
        P_prev = pos
    A = [1 if (known[i] is None) else known[i] for i in range(n)]
    return A

def read_input() -> Tuple[int, List[Tuple[int, List[int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        c = [int(next(it)) for _ in range(n)]
        cases.append((n, c))
    return t, cases

def solve_all() -> None:
    t, cases = read_input()
    out = []
    for n, c in cases:
        A = reconstruct_from_C(c)
        out.append(" ".join(map(str, A)))
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Validation: 3 asserts
    # 1) Example
    def compute_C_from_A(A: List[int]) -> List[int]:
        n = len(A)
        C = [0]*n
        for k in range(1, n+1):
            ones = sum(A[:k])
            zeros = k - ones
            Bk = [0]*n
            for i in range(k):
                Bk[i] = 0 if i < zeros else 1
            for i in range(k, n):
                Bk[i] = A[i]
            for i in range(n):
                C[i] += Bk[i]
        return C
    A = [0,1,0,1]
    C = compute_C_from_A(A)
    assert reconstruct_from_C(C) and compute_C_from_A(reconstruct_from_C(C)) == C

    # 2) All zeros
    n = 6
    C = [0]*n
    A2 = reconstruct_from_C(C)
    assert A2 == [0]*n

    # 3) All ones
    n = 5
    C = [n]*n
    A3 = reconstruct_from_C(C)
    assert A3 == [1]*n

    solve_all()
\end{minted}
\VALIDATION{Exactly three asserts: example round-trip, all-zeros, all-ones. They verify reconstructed $A$ reproduces the given $C$.}
\RESULT{Outputs any valid binary array $A$ consistent with the given $C$. No special tie-breaking is required.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on corner cases (all ones/zeros), hand-crafted small arrays, and random small arrays with forward-checking $A \to C \to A' \to C'$ equality.}
\LINE{CROSS-CHECKS}{Compare reconstruction output against the original by re-summing $B_k$ to $C$ for tiny cases.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of small $n$ with patterns: all $0$, all $1$, alternating, single $0$/$1$, and random.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def compute_C_from_A(A: List[int]) -> List[int]:
    n = len(A)
    C = [0]*n
    for k in range(1, n+1):
        ones = sum(A[:k])
        zeros = k - ones
        Bk = [0]*n
        for i in range(k):
            Bk[i] = 0 if i < zeros else 1
        for i in range(k, n):
            Bk[i] = A[i]
        for i in range(n):
            C[i] += Bk[i]
    return C

def reconstruct_from_C(c: List[int]) -> List[int]:
    n = len(c)
    total = sum(c)
    S = total // n
    assert S * n == total
    Z = n - S
    if Z == 0:
        return [1]*n
    known = [None]*n
    for i in range(Z+1, n+1):
        denom = i-1
        must = n - i + 1
        val = c[i-1] - must
        assert denom > 0 and val % denom == 0
        ai = val // denom
        assert ai in (0,1)
        known[i-1] = ai
    P_prev = 0
    for i in range(1, Z+1):
        cand1 = c[i-1] + 1
        cand0 = c[i-1] + i
        def ok(pos: int, ai_one: bool) -> bool:
            if not (P_prev < pos <= n):
                return False
            if known[pos-1] == 1:
                return False
            if ai_one and pos == i:
                return False
            return True
        if ok(cand1, True):
            pos = cand1
        elif ok(cand0, False):
            pos = cand0
        else:
            if ok(cand0, False):
                pos = cand0
            elif ok(cand1, True):
                pos = cand1
            else:
                raise AssertionError("No feasible zero position")
        known[pos-1] = 0
        P_prev = pos
    A = [1 if (known[i] is None) else known[i] for i in range(n)]
    return A

def random_tests():
    random.seed(1)
    for n in range(1, 9):
        # structured
        for A in ([0]*n, [1]*n, [int(i%2==0) for i in range(n)], [int(i%2==1) for i in range(n)]):
            C = compute_C_from_A(A)
            A2 = reconstruct_from_C(C)
            assert compute_C_from_A(A2) == C
        # random
        for _ in range(100):
            A = [random.randint(0,1) for _ in range(n)]
            C = compute_C_from_A(A)
            A2 = reconstruct_from_C(C)
            assert compute_C_from_A(A2) == C

if __name__ == "__main__":
    random_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def reconstruct_from_C(c: List[int]) -> List[int]:
    n = len(c)
    total = sum(c)
    assert total % n == 0
    S = total // n
    Z = n - S
    if Z == 0:
        return [1]*n
    known = [None]*n  # None/0/1
    # Determine a_i for i > Z (1-indexed)
    for i in range(Z+1, n+1):
        denom = i - 1
        must = n - i + 1
        val = c[i-1] - must
        assert denom > 0 and val % denom == 0
        ai = val // denom
        assert ai in (0, 1)
        known[i-1] = ai
    # Greedily place zero positions P(i)
    P_prev = 0
    for i in range(1, Z+1):
        cand1 = c[i-1] + 1      # if a_i were 1
        cand0 = c[i-1] + i      # if a_i were 0
        def ok(pos: int, ai_one: bool) -> bool:
            if not (P_prev < pos <= n):
                return False
            if known[pos-1] == 1:
                return False
            if ai_one and pos == i:
                return False
            return True
        if ok(cand1, True):
            pos = cand1
        elif ok(cand0, False):
            pos = cand0
        else:
            # Feasibility guaranteed; try alternate order defensively
            if ok(cand0, False):
                pos = cand0
            elif ok(cand1, True):
                pos = cand1
            else:
                raise AssertionError("No feasible zero position found")
        known[pos-1] = 0
        P_prev = pos
    A = [1 if (known[i] is None) else known[i] for i in range(n)]
    return A

def read_input() -> Tuple[int, List[Tuple[int, List[int]]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        c = [int(next(it)) for _ in range(n)]
        cases.append((n, c))
    return t, cases

def solve_all() -> None:
    t, cases = read_input()
    out_lines = []
    for n, c in cases:
        A = reconstruct_from_C(c)
        out_lines.append(" ".join(map(str, A)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Basic asserts
    def compute_C_from_A(A: List[int]) -> List[int]:
        n = len(A)
        C = [0]*n
        for k in range(1, n+1):
            ones = sum(A[:k])
            zeros = k - ones
            Bk = [0]*n
            for i in range(k):
                Bk[i] = 0 if i < zeros else 1
            for i in range(k, n):
                Bk[i] = A[i]
            for i in range(n):
                C[i] += Bk[i]
        return C

    # Round-trip small
    A = [0,1,0,1]
    C = compute_C_from_A(A)
    A2 = reconstruct_from_C(C)
    assert compute_C_from_A(A2) == C

    # All ones and all zeros
    n = 6
    C_all_ones = [n]*n
    assert reconstruct_from_C(C_all_ones) == [1]*n
    C_all_zeros = [0]*n
    assert reconstruct_from_C(C_all_zeros) == [0]*n

    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Recover a binary array from the sum of arrays formed by sorting each prefix.}
\WHY{Tests ability to derive constraints from operations, exploit invariants (sum preservation), and design a linear greedy reconstruction.}
\CHECKLIST{
\begin{bullets}
\item Compute $S=\tfrac{\sum C}{n}$ and $Z=n-S$.
\item If $Z=0$, output ones.
\item Fill $a_i$ for $i>Z$ via $a_i=\dfrac{C[i]-(n-i+1)}{i-1}$.
\item Greedily place zeros $P(i)$ using candidates $C[i]+1$ and $C[i]+i$ with validity checks.
\item Mark $a_{P(i)}=0$; set remaining unknowns to $1$.
\item Optionally verify on tiny inputs.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All ones ($Z=0$).
\item All zeros ($C\equiv 0$, yields $P(i)=i$).
\item $C[1]=n$ (forces $Z=0$).
\item Candidates equal ($i=1$), ensure you reject $a_1=1$ when $P(1)=1$.
\item Candidate hitting an index already known as $1$ (must reject).
\item Large $n$ with $t$ many cases; linear pass only.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Integer division: ensure $(C[i]-(n-i+1))$ divisible by $(i-1)$.
\item Off-by-one in 1-indexed formulas vs 0-indexed arrays.
\item Forgetting to enforce $P(i)>P(i-1)$ and $P(i)\le n$.
\item Allowing $a_i=1$ when $P(i)=i$ (contradiction).
\item Not checking collision with already known $a_j=1$.
\item Using slow re-sums inside loops; precompute only when testing locally.
\end{bullets}}
\FAILMODES{Naive backtracking over $A$ is exponential. Ignoring the $S=\tfrac{\sum C}{n}$ invariant leads to ambiguity. Not enforcing monotonic $P(i)$ or suffix constraints causes contradictions.}
\ELI{We first count how many ones there must be. After that, entries late in the array are forced by a simple formula. Finally we place zeros one by one in the earliest positions that do not create conflicts, using two simple candidate formulas derived from the equations.}
\NotePages{3}

\end{document}