% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximize Subarray GCD Score}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximize-subarray-gcd-score/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an array of positive integers \texttt{nums} and an integer \texttt{k}. You may perform at most \texttt{k} operations. In each operation, you can choose one element in the array and \textbf{double} its value. Each element can be doubled \textbf{at most} once. The \textbf{score} of a contiguous \textbf{subarray} is defined as the \textbf{product} of its length and the \emph{greatest common divisor (GCD)} of all its elements. Your task is to return the \textbf{maximum} \textbf{score} that can be achieved by selecting a contiguous subarray from the modified array.

\textbf{Note:}
\begin{itemize}
\item The \textbf{greatest common divisor (GCD)} of an array is the largest integer that evenly divides all the array elements.
\end{itemize}

\textbf{Example 1:}
\textbf{Input:} nums = [2, 4], k = 1
\textbf{Output:} 8
\textbf{Explanation:}
\begin{itemize}
\item Double \texttt{nums[0]} to 4 using one operation. The modified array becomes [4, 4].
\item The GCD of the subarray [4, 4] is 4, and the length is 2.
\item Thus, the maximum possible score is $2 \times 4 = 8$.
\end{itemize}

\textbf{Example 2:}
\textbf{Input:} nums = [3, 5, 7], k = 2
\textbf{Output:} 14
\textbf{Explanation:}
\begin{itemize}
\item Double \texttt{nums[2]} to 14 using one operation. The modified array becomes [3, 5, 14].
\item The GCD of the subarray [14] is 14, and the length is 1.
\item Thus, the maximum possible score is $1 \times 14 = 14$.
\end{itemize}

\textbf{Example 3:}
\textbf{Input:} nums = [5, 5, 5], k = 1
\textbf{Output:} 15
\textbf{Explanation:}
\begin{itemize}
\item The subarray [5, 5, 5] has a GCD of 5, and its length is 3.
\item Since doubling any element does not improve the score, the maximum score is $3 \times 5 = 15$.
\end{itemize}

\textbf{Constraints:}
\begin{itemize}
\item $1 \le n = \lvert\texttt{nums}\rvert \le 1500$
\item $1 \le \texttt{nums}[i] \le 10^9$
\item $1 \le k \le n$
\end{itemize}}
\BREAKDOWN{We must choose a contiguous subarray and, within it, optionally double up to $k$ elements (globally each element at most once) to maximize length times GCD. Doubling only affects the power-of-two factor of numbers; odd parts of numbers are unchanged.}
\ELI{GCD only gains an extra factor of 2 if you double every element that currently has the fewest factors of 2 in the subarray; the odd part of the GCD never changes by doubling.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Array \texttt{nums} of $n$ positive integers ($1 \le n \le 1500$, $1 \le \texttt{nums}[i] \le 10^9$) and integer $k$ with $1 \le k \le n$.}
\OUTPUTS{An integer: the maximum possible score over all contiguous subarrays after applying at most $k$ doublings (each element at most once).}
\SAMPLES{Examples:
\begin{itemize}
\item \texttt{nums = [2, 4]}, \texttt{k = 1} $\to 8$.
\item \texttt{nums = [3, 5, 7]}, \texttt{k = 2} $\to 14$.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For a chosen subarray $A = (a_l,\ldots,a_r)$, write $a_i = 2^{e_i} \cdot o_i$ with $o_i$ odd, $e_i = v_2(a_i)$. Choose $b_i \in \{0,1\}$ with at most $k$ of them equal to $1$ (doublings) applied to elements of $A$. The resulting GCD is
\begin{BreakableEquation*}
\gcd\bigl(2^{b_l}a_l,\ldots,2^{b_r}a_r\bigr) = \Bigl(\gcd(o_l,\ldots,o_r)\Bigr)\cdot 2^{\min_{i\in[l,r]}(e_i+b_i)}.
\end{BreakableEquation*}
Let $g_o = \gcd(o_l,\ldots,o_r)$ and $m = \min e_i$, and let $c = \#\{i \in [l,r]: e_i = m\}$. Then the best choice is $b_i = 1$ for all $i$ with $e_i=m$ if $c \le k$, giving exponent $m+1$, otherwise exponent $m$.}
\varmapStart
\var{e_i}{two-adic valuation $v_2(a_i)$ (number of trailing zeros in binary)}
\var{o_i}{odd part of $a_i$}
\var{g_o}{GCD of odd parts over the subarray}
\var{m}{minimum of $e_i$ over the subarray}
\var{c}{count of indices attaining $m$ in the subarray}
\var{k}{max doublings allowed}
\var{L}{subarray length $L=r-l+1$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{score}(l,r) \;=\; L \cdot g_o \cdot 2^{\,m + \mathbf{1}[c \le k]}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Doubling an element at most once; only doublings within the chosen subarray can affect its GCD; $g_o$ is unaffected by doubling.}
\INVARIANTS{
\begin{itemize}
\item For fixed $(l,r)$, $g_o$ is nonincreasing when extending $r$ and can be maintained by $g_o \gets \gcd(g_o, o_r)$.
\item $m$ and $c$ update online: if $e_r<m$, then $(m,c)\gets(e_r,1)$; if $e_r=m$, then $c\gets c+1$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the governing formula with recomputation per subarray: compute $g_o$, $m$, and $c$ from scratch for each $(l,r)$.}
\ASSUMPTIONS{Direct triple-loop; leverage integer $\gcd$; trailing-zero count by dividing by $2$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute nothing; iterate all $0 \le l \le r < n$.
\item For each subarray, scan $i\in[l,r]$ to compute $e_i$, $o_i$, track $g_o=\gcd$ over odd parts, $m=\min e_i$, and $c=\#\{i:e_i=m\}$.
\item Compute score $= (r-l+1)\cdot g_o \cdot 2^{m+\mathbf{1}[c\le k]}$ and take the maximum.
\end{algosteps}
\COMPLEXITY{Brute force scanning costs $O(n^3 \log A)$ time and $O(1)$ space.}
\[
\begin{aligned}
T(n) &= \sum_{l=0}^{n-1}\sum_{r=l}^{n-1} O((r-l+1)\log A) \\
     &= O\!\left(\sum_{L=1}^{n} (n-L+1)\cdot L \cdot \log A\right) \\
     &= O(n^3 \log A),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Follows directly from the decomposition of GCD into odd part and two-adic exponent and the fact that the minimum two-adic exponent increases by exactly one iff every minimum-attaining element is doubled (and this requires at most $k$ doublings).}
\EDGECASES{All odd numbers; all powers of two; mixed; $k=1$; subarray of length $1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
from math import gcd

class SolutionBaseline:
    def maximizeSubarrayGCDScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        def v2(x: int) -> int:
            # count trailing zeros
            return (x & -x).bit_length() - 1
        ans = 0
        for l in range(n):
            for r in range(l, n):
                go = 0  # gcd of odd parts
                m = 1 << 30  # min v2
                cntm = 0
                for i in range(l, r + 1):
                    e = v2(nums[i])
                    o = nums[i] >> e
                    go = gcd(go, o)
                    if e < m:
                        m = e
                        cntm = 1
                    elif e == m:
                        cntm += 1
                inc = 1 if cntm <= k else 0
                g = go << (m + inc)
                L = r - l + 1
                score = L * g
                if score > ans:
                    ans = score
        return ans

# Tiny self-checks for the baseline
sb = SolutionBaseline()
assert sb.maximizeSubarrayGCDScore([2, 4], 1) == 8
assert sb.maximizeSubarrayGCDScore([3, 5, 7], 2) == 14
assert sb.maximizeSubarrayGCDScore([5, 5, 5], 1) == 15
\end{minted}
\VALIDATION{Validated on the three provided examples.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Maintain rolling $g_o$, $m$, and $c$ while extending $r$ for each fixed $l$. This reduces recomputation and achieves $O(n^2 \log A)$.}
\ASSUMPTIONS{Two nested loops; use online $\gcd$ and simple integer updates.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute nothing except a helper $v_2(x)$ and odd part extraction.
\item For each $l$ from $0$ to $n-1$, reset $g_o=0$, $m=+\infty$, $c=0$.
\item Extend $r$ from $l$ to $n-1$: update $g_o\gets\gcd(g_o,o_r)$, and $(m,c)$ as minima with counts; compute the score immediately.
\end{algosteps}
\COMPLEXITY{Each pair $(l,r)$ is processed once with $O(\log A)$ amortized for $\gcd$.}
\[
\begin{aligned}
T(n) &= O(n^2 \log A),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Same invariant reasoning as baseline; rolling updates are algebraically identical to recomputing from scratch.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from math import gcd

class SolutionImproved:
    def maximizeSubarrayGCDScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        def v2(x: int) -> int:
            return (x & -x).bit_length() - 1
        E = [v2(x) for x in nums]
        O = [nums[i] >> E[i] for i in range(n)]
        ans = 0
        for l in range(n):
            go = 0
            m = 1 << 30
            cntm = 0
            for r in range(l, n):
                e = E[r]
                o = O[r]
                go = gcd(go, o)
                if e < m:
                    m = e
                    cntm = 1
                elif e == m:
                    cntm += 1
                inc = 1 if cntm <= k else 0
                g = go << (m + inc)
                L = r - l + 1
                score = L * g
                if score > ans:
                    ans = score
        return ans

# Same API/signature as baseline; deterministic; with asserts
si = SolutionImproved()
assert si.maximizeSubarrayGCDScore([2, 4], 1) == 8
assert si.maximizeSubarrayGCDScore([3, 5, 7], 2) == 14
assert si.maximizeSubarrayGCDScore([5, 5, 5], 1) == 15
\end{minted}
\VALIDATION{Checked on provided examples; complexity suits $n \le 1500$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the two-adic decomposition: only the minimum two-adic exponent matters for the power-of-two factor. Doubling can increase the minimum by at most $1$ and only if all minimum-attaining elements (count $c$) are doubled, which is feasible iff $c \le k$.}
\ASSUMPTIONS{Each element can be doubled once; only subarray-internal doublings affect its GCD; odd parts are invariant under doubling.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute arrays $E[i]=v_2(\texttt{nums}[i])$ and $O[i]=\texttt{nums}[i]\!/2^{E[i]}$.
\item For each $l$, sweep $r\ge l$ maintaining $g_o=\gcd$ of $O[l..r]$, current minimum $m=\min E[l..r]$, and $c$ the count of indices attaining $m$.
\item For each $(l,r)$, set $\text{inc}=1$ if $c \le k$ else $0$; score $= (r-l+1) \cdot g_o \cdot 2^{m+\text{inc}}$. Track the maximum.
\end{algosteps}
\OPTIMALITY{No algorithm can beat $O(n^2)$ in the comparison model when evaluating a function over all $O(n^2)$ subarrays unless additional structure is exploited. This achieves $O(n^2 \log A)$ with constant space, and the formula for the optimal GCD after doublings follows from the lattice property of valuations: the two-adic valuation of the GCD is the minimum valuation, which increases by exactly one if all minima are incremented.}
\COMPLEXITY{$O(n^2 \log A)$ time, $O(1)$ extra space beyond the input and small arrays $E,O$.}
\[
\begin{aligned}
T(n) &= O(n^2 \log A), \quad S(n) = O(n) \text{ for } E,O \text{ or } O(1) \text{ if in-place}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from math import gcd

class Solution:
    def maximizeSubarrayGCDScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        def v2(x: int) -> int:
            # trailing-zero count via lowbit
            return (x & -x).bit_length() - 1
        E = [v2(x) for x in nums]
        O = [nums[i] >> E[i] for i in range(n)]
        ans = 0
        for l in range(n):
            go = 0
            m = 1 << 30
            cntm = 0
            for r in range(l, n):
                e = E[r]
                o = O[r]
                go = gcd(go, o)
                if e < m:
                    m = e
                    cntm = 1
                elif e == m:
                    cntm += 1
                inc = 1 if cntm <= k else 0
                g = go << (m + inc)
                L = r - l + 1
                score = L * g
                if score > ans:
                    ans = score
        return ans

# Validations (exactly 3 asserts)
sol = Solution()
assert sol.maximizeSubarrayGCDScore([2, 4], 1) == 8
assert sol.maximizeSubarrayGCDScore([3, 5, 7], 2) == 14
assert sol.maximizeSubarrayGCDScore([5, 5, 5], 1) == 15
\end{minted}
\VALIDATION{Three asserts for the given examples.}
\RESULT{The function returns the maximum score $L \cdot \gcd$ achievable, where $L$ is subarray length and the GCD accounts for at most one extra factor $2$ if the count of minimum two-adic elements in the subarray does not exceed $k$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test with arrays of small sizes; verify against a slow $O(n^3)$ checker; include edge patterns: all odd, all powers of two, mixed, random.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Final on random seeds with $n \le 25$ to ensure consistency.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of identical elements; alternating odd/even; strictly increasing powers of two; random values.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
from random import Random
from math import gcd

def v2(x: int) -> int:
    return (x & -x).bit_length() - 1

def brute(nums: List[int], k: int) -> int:
    n = len(nums)
    ans = 0
    for l in range(n):
        for r in range(l, n):
            go = 0
            m = 1 << 30
            cntm = 0
            for i in range(l, r + 1):
                e = v2(nums[i])
                o = nums[i] >> e
                go = gcd(go, o)
                if e < m:
                    m = e; cntm = 1
                elif e == m:
                    cntm += 1
            inc = 1 if cntm <= k else 0
            g = go << (m + inc)
            L = r - l + 1
            ans = max(ans, L * g)
    return ans

def gen_cases() -> List[tuple]:
    cases = []
    cases += [([1], 1), ([2], 1), ([1, 1, 1], 1)]
    cases += [([2, 4, 8, 16], 1), ([3, 5, 7, 9], 2)]
    cases += [([2, 3, 4, 6, 9], 2)]
    rnd = Random(123)
    for n in range(1, 10):
        for _ in range(5):
            nums = [rnd.randint(1, 50) for _ in range(n)]
            k = rnd.randint(1, n)
            cases.append((nums, k))
    return cases

# Cross-check baseline vs final solution on small randoms
from math import gcd

class SolutionRef:
    def maximizeSubarrayGCDScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        def v2(x: int) -> int:
            return (x & -x).bit_length() - 1
        E = [v2(x) for x in nums]
        O = [nums[i] >> E[i] for i in range(n)]
        ans = 0
        for l in range(n):
            go = 0
            m = 1 << 30
            cntm = 0
            for r in range(l, n):
                e = E[r]; o = O[r]
                go = gcd(go, o)
                if e < m:
                    m = e; cntm = 1
                elif e == m:
                    cntm += 1
                inc = 1 if cntm <= k else 0
                g = go << (m + inc)
                L = r - l + 1
                ans = max(ans, L * g)
        return ans

for nums, k in gen_cases():
    assert SolutionRef().maximizeSubarrayGCDScore(nums, k) == brute(nums, k)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from math import gcd

class Solution:
    def maximizeSubarrayGCDScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        def v2(x: int) -> int:
            return (x & -x).bit_length() - 1
        # Precompute two-adic valuations and odd parts
        E = [v2(x) for x in nums]
        O = [nums[i] >> E[i] for i in range(n)]
        ans = 0
        for l in range(n):
            go = 0           # gcd of odd parts in current window
            m = 1 << 30      # minimum v2 in window
            cntm = 0         # count of elements attaining m
            for r in range(l, n):
                e = E[r]
                o = O[r]
                go = gcd(go, o)
                if e < m:
                    m = e
                    cntm = 1
                elif e == m:
                    cntm += 1
                inc = 1 if cntm <= k else 0
                g = go << (m + inc)
                L = r - l + 1
                score = L * g
                if score > ans:
                    ans = score
        return ans

# Quick sanity asserts
if __name__ == "__main__":
    s = Solution()
    assert s.maximizeSubarrayGCDScore([2, 4], 1) == 8
    assert s.maximizeSubarrayGCDScore([3, 5, 7], 2) == 14
    assert s.maximizeSubarrayGCDScore([5, 5, 5], 1) == 15
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Decompose each number into odd part and power of two; only the minimum power of two in a subarray matters for the GCD's two-adic exponent, and it can increase by $1$ iff you can double all elements that attain this minimum within $k$ operations.}
\WHY{This appears in interviews testing valuation-based reasoning and windowed GCD maintenance.}
\CHECKLIST{
\begin{itemize}
\item Compute $E[i]=v_2(\texttt{nums}[i])$ and $O[i]=$ odd part.
\item Sweep all subarrays with rolling $\gcd$ of $O$.
\item Maintain subarray minimum $m$ and its count $c$.
\item Apply $\text{inc}=1$ iff $c \le k$.
\item Maximize $L \cdot (g_o \ll (m+\text{inc}))$.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item All numbers odd ($E[i]=0$ for all $i$).
\item All numbers equal.
\item All numbers powers of two.
\item $k=1$ vs $k$ small relative to $c$.
\item Subarray of length $1$ where doubling helps.
\item Large values near $10^9$; Python big integers handle products.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Trying to increase the two-adic exponent by more than $1$ with single doublings (impossible).
\item Wasting doublings on non-minimum elements (does not change GCD).
\item Forgetting that odd parts are invariant under doubling.
\item Miscounting $c$ when a new smaller $e$ appears (reset both $m$ and $c$).
\item Integer overflows in languages without big integers (use 64-bit or big-int).
\item Off-by-one in window length $L=r-l+1$.
\end{itemize}}
\FAILMODES{Approaches that attempt to raise the GCD via doubling non-minimal two-adic elements will not improve the GCD; ignoring the count of minimal elements $c$ leads to overestimating the achievable power of two.}
\ELI{Break every number into an odd part times a power of two. The odd parts decide the odd GCD; doubling can only add one more factor of two if you can double every currently most “odd” element. Sweep all subarrays maintaining these quantities to find the best score.}
\NotePages{3}

\end{document}