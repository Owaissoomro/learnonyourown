% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Number of Removals to Make Mountain Array}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You may recall that an array \texttt{arr} is a mountain array if and only if:
\begin{bullets}
\item \texttt{arr.length} $\ge 3$.
\item There exists some index $i$ (0-indexed) with $0 < i < \texttt{arr.length} - 1$ such that:
\begin{bullets}
\item \texttt{arr[0] < arr[1] < ... < arr[i - 1] < arr[i]}.
\item \texttt{arr[i] > arr[i + 1] > ... > arr[arr.length - 1]}.
\end{bullets}
\end{bullets}
Given an integer array \texttt{nums}, return the minimum number of elements to remove to make \texttt{nums} a mountain array.

Examples:
\begin{bullets}
\item Input: \texttt{nums = [1,3,1]}; Output: \texttt{0}. The array itself is a mountain array, so no removals are needed.
\item Input: \texttt{nums = [2,1,1,5,6,2,3,1]}; Output: \texttt{3}. One solution removes indices 0, 1, and 5, making \texttt{[1,5,6,3,1]}.
\end{bullets}
Constraints:
\begin{bullets}
\item $3 \le \texttt{nums.length} \le 1000$.
\item $1 \le \texttt{nums[i]} \le 10^{9}$.
\item It is guaranteed that you can make a mountain array out of \texttt{nums}.
\end{bullets}}
\BREAKDOWN{Compute, for every index, the length of the longest strictly increasing subsequence ending there and the longest strictly decreasing subsequence starting there. A valid peak must have both lengths at least 2 when counting the peak. The longest mountain length gives the minimum removals as $n$ minus that length.}
\ELI{Find the best mountain hidden inside the array and remove everything else.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode method \texttt{minimumMountainRemovals(self, nums: List[int]) -> int}, where \texttt{nums} is the input array. Valid ranges: $3 \le n \le 1000$, $1 \le \texttt{nums[i]} \le 10^{9}$.}
\OUTPUTS{A single integer: the minimum number of elements to remove so that the remaining sequence (preserving order) forms a mountain array.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{[1,3,1]} $\to$ Output: \texttt{0}.
\item Input: \texttt{[2,1,1,5,6,2,3,1]} $\to$ Output: \texttt{3}.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A = (a_0,\ldots,a_{n-1})$. For each $i$, define:
\begin{bullets}
\item $\text{LIS}_i$: length of the longest strictly increasing subsequence that ends at index $i$.
\item $\text{LDS}_i$: length of the longest strictly decreasing subsequence that starts at index $i$.
\end{bullets}
A valid mountain peak at $i$ must satisfy $\text{LIS}_i \ge 2$ and $\text{LDS}_i \ge 2$. The mountain length at $i$ is $M_i = \text{LIS}_i + \text{LDS}_i - 1$. The optimal mountain length is $M^\star = \max_{1 \le i \le n-2,~\text{LIS}_i,\text{LDS}_i \ge 2} M_i$. The answer is $n - M^\star$.}
\varmapStart
\var{n}{array length}
\var{a_i}{value at index $i$}
\var{\text{LIS}_i}{strictly increasing subsequence length ending at $i$}
\var{\text{LDS}_i}{strictly decreasing subsequence length starting at $i$}
\var{M_i}{mountain length using $i$ as peak}
\var{M^\star}{maximum feasible mountain length}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{LIS}_i &= 1 + \max\{ \text{LIS}_j : 0 \le j < i,\ a_j < a_i \} \ \ (\text{or }1\text{ if none}),\\
\text{LDS}_i &= 1 + \max\{ \text{LDS}_j : i < j \le n-1,\ a_j < a_i \} \ \ (\text{or }1\text{ if none}),\\
M^\star &= \max_{1 \le i \le n-2 \atop \text{LIS}_i \ge 2,\ \text{LDS}_i \ge 2} \big(\text{LIS}_i + \text{LDS}_i - 1\big),\\
\text{Answer} &= n - M^\star.
\end{aligned}
\]
}
\ASSUMPTIONS{Subsequences preserve relative order. Strict inequalities enforce strictly increasing/decreasing runs. Peak cannot be at endpoints.}
\INVARIANTS{
\begin{bullets}
\item For any valid mountain, both sides have length at least 1 excluding the peak, hence $\text{LIS}_i,\text{LDS}_i \ge 2$ for feasible peaks.
\item Removing elements cannot increase $M^\star$, so $n - M^\star$ is the minimum removals.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct dynamic programming for LIS and LDS in $O(n^2)$ time using the recurrences for $\text{LIS}_i$ and $\text{LDS}_i$.}
\ASSUMPTIONS{Strict comparisons; endpoints cannot be peaks; array length at least 3.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $\text{LIS}_i$ for all $i$ via a forward $O(n^2)$ DP with strict $<$.
\item Compute $\text{LDS}_i$ for all $i$ via a backward $O(n^2)$ DP with strict $<$ to model decreasing to the right.
\item Over all $i \in [1,n-2]$ with $\text{LIS}_i,\text{LDS}_i \ge 2$, maximize $M_i$ and return $n - \max M_i$.
\end{algosteps}
\COMPLEXITY{$T(n)=O(n^2)$ and $S(n)=O(n)$ for the two DP arrays.}
\[
\begin{aligned}
T(n) &= \Theta(n^2) + \Theta(n^2) + \Theta(n) \\
     &= \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{By definition of LIS/LDS with strict inequalities, any peak $i$ with both sides length $\ge 2$ forms a valid mountain. Maximizing $M_i$ yields the longest mountain subsequence; removing all other elements is optimal by complement.}
\EDGECASES{Duplicates cannot lie on the same strictly increasing/decreasing side. Peaks at ends are disallowed.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        # O(n^2) LIS ending at i
        lis = [1] * n
        for i in range(n):
            for j in range(i):
                if nums[j] < nums[i]:
                    if lis[j] + 1 > lis[i]:
                        lis[i] = lis[j] + 1
        # O(n^2) LDS starting at i (strictly decreasing to the right)
        lds = [1] * n
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                if nums[j] < nums[i]:
                    if lds[j] + 1 > lds[i]:
                        lds[i] = lds[j] + 1
        best = 0
        for i in range(1, n - 1):
            if lis[i] >= 2 and lds[i] >= 2:
                best = max(best, lis[i] + lds[i] - 1)
        return n - best

# Tiny self-checks for the baseline
def _baseline_tests():
    s = Solution()
    assert s.minimumMountainRemovals([1, 3, 1]) == 0
    assert s.minimumMountainRemovals([2, 1, 1, 5, 6, 2, 3, 1]) == 3
    # Already mountain with duplicates off-peak
    assert s.minimumMountainRemovals([1, 2, 3, 2, 1]) == 0
    # Needs removals due to plateau
    assert s.minimumMountainRemovals([1, 2, 2, 3, 2, 1]) == 1

if __name__ == "__main__":
    _baseline_tests()
\end{minted}
\VALIDATION{Covers the two examples, a clean mountain, and a plateau requiring one removal.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use patience sorting (tails) with binary search to compute per-index LIS lengths in $O(n \log n)$, and symmetrically compute per-index LDS by scanning from right on negated values.}
\ASSUMPTIONS{Strict LIS via \texttt{bisect\_left}. For LDS, process from right to left with negated values so decreasing becomes increasing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Forward pass: maintain \texttt{tails}; for each $a_i$, let $p=\text{lower\_bound}(\texttt{tails}, a_i)$, set \texttt{tails[p]=a\_i} and record $\text{LIS}_i=p+1$.
\item Backward pass: maintain \texttt{tails\_neg}; for each $i$ from $n-1$ to $0$, let $v=-a_i$, $p=\text{lower\_bound}(\texttt{tails\_neg}, v)$, set \texttt{tails\_neg[p]=v} and record $\text{LDS}_i=p+1$.
\item Aggregate as before with $\text{LIS}_i,\text{LDS}_i \ge 2$ and return $n - \max M_i$.
\end{algosteps}
\COMPLEXITY{$O(n \log n)$ time and $O(n)$ space, improving over $O(n^2)$.}
\[
\begin{aligned}
T(n) &= \Theta(n \log n)~(\text{forward}) + \Theta(n \log n)~(\text{backward}) + \Theta(n) \\
     &= \Theta(n \log n).
\end{aligned}
\]
\CORRECTNESS{The patience method yields correct per-index strict LIS lengths when using \texttt{bisect\_left}. Negating values and scanning from right computes strict LDS starting at each index by equivalence of decreasing to increasing under sign inversion and reversal.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from bisect import bisect_left

class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        # Forward strict LIS ending at i
        lis = [0] * n
        tails = []
        for i, x in enumerate(nums):
            p = bisect_left(tails, x)
            if p == len(tails):
                tails.append(x)
            else:
                tails[p] = x
            lis[i] = p + 1
        # Backward strict LDS starting at i via LIS on negatives
        lds = [0] * n
        tails_neg = []
        for i in range(n - 1, -1, -1):
            v = -nums[i]
            p = bisect_left(tails_neg, v)
            if p == len(tails_neg):
                tails_neg.append(v)
            else:
                tails_neg[p] = v
            lds[i] = p + 1
        best = 0
        for i in range(1, n - 1):
            if lis[i] >= 2 and lds[i] >= 2:
                best = max(best, lis[i] + lds[i] - 1)
        return n - best

# Tiny self-checks for the improved version
def _improved_tests():
    s = Solution()
    assert s.minimumMountainRemovals([1, 3, 1]) == 0
    assert s.minimumMountainRemovals([2, 1, 1, 5, 6, 2, 3, 1]) == 3
    assert s.minimumMountainRemovals([1, 2, 3, 4, 3, 2, 1]) == 0
    assert s.minimumMountainRemovals([4, 3, 2, 1, 2, 3]) == 2  # e.g., keep [3,4,3,2] -> need 2 removals

if __name__ == "__main__":
    _improved_tests()
\end{minted}
\VALIDATION{Checks both examples, a clear mountain, and an asymmetric case requiring removals.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Two-pass $O(n \log n)$ per-index strict LIS/LDS with feasibility filtering at aggregation time. This achieves optimal asymptotic complexity for comparison-based LIS-style solutions.}
\ASSUMPTIONS{Same as Approach B; strictly increasing left side and strictly decreasing right side; peaks not at endpoints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute per-index strict LIS ending lengths in $O(n \log n)$.
\item Compute per-index strict LDS starting lengths in $O(n \log n)$ by scanning from right with negated values.
\item For all $i \in [1,n-2]$ with both lengths at least 2, maximize $M_i$ and return $n - \max M_i$.
\end{algosteps}
\OPTIMALITY{Any algorithm must read all $n$ elements and, in general, cannot beat $O(n \log n)$ for per-index LIS lengths in the comparison model. This solution matches that lower bound up to constant factors.}
\COMPLEXITY{$T(n)=\Theta(n \log n)$, $S(n)=\Theta(n)$.}
\[
\begin{aligned}
T(n) &= \Theta(n \log n), \quad S(n) = \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from bisect import bisect_left

class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        # Per-index strict LIS ending at i
        lis = [0] * n
        tails = []
        for i, x in enumerate(nums):
            p = bisect_left(tails, x)
            if p == len(tails):
                tails.append(x)
            else:
                tails[p] = x
            lis[i] = p + 1
        # Per-index strict LDS starting at i via LIS on negatives, scanning from right
        lds = [0] * n
        tails_neg = []
        for i in range(n - 1, -1, -1):
            v = -nums[i]
            p = bisect_left(tails_neg, v)
            if p == len(tails_neg):
                tails_neg.append(v)
            else:
                tails_neg[p] = v
            lds[i] = p + 1
        best = 0
        for i in range(1, n - 1):
            if lis[i] >= 2 and lds[i] >= 2:
                cand = lis[i] + lds[i] - 1
                if cand > best:
                    best = cand
        return n - best

# Final mini-tests (exactly 3)
def _final_tests():
    s = Solution()
    assert s.minimumMountainRemovals([1, 3, 1]) == 0
    assert s.minimumMountainRemovals([2, 1, 1, 5, 6, 2, 3, 1]) == 3
    assert s.minimumMountainRemovals([1, 2, 3, 2, 1]) == 0

if __name__ == "__main__":
    _final_tests()
\end{minted}
\VALIDATION{Asserts cover both prompts and a canonical mountain.}
\RESULT{Returns the minimum number of removals; ties are irrelevant since the task asks only for the count, not a specific resulting mountain.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small arrays covering: already-mountain, all-increasing, all-decreasing, plateaus (equal neighbors), multiple candidate peaks, and random mixes. Verify that $\text{LIS}_i,\text{LDS}_i \ge 2$ condition is enforced.}
\LINE{CROSS-CHECKS}{Compare baseline $O(n^2)$ results with optimal $O(n \log n)$ on random seeds for $n \le 40$ to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with runs of equal values, strictly monotone arrays, and arrays with peak at various positions to stress feasibility filtering.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_strict_increasing(n: int) -> List[int]:
    return list(range(1, n + 1))

def gen_strict_decreasing(n: int) -> List[int]:
    return list(range(n, 0, -1))

def gen_plateau(n: int, val: int = 5) -> List[int]:
    return [val] * n

def gen_peak(n: int, peak_idx: int) -> List[int]:
    # Builds a clean mountain with peak at peak_idx
    left = list(range(1, peak_idx + 1))
    right = list(range(peak_idx, 0, -1))
    return left + right

def cross_check():
    from bisect import bisect_left

    class A:
        def minimumMountainRemovals(self, nums: List[int]) -> int:
            n = len(nums)
            lis = [1] * n
            for i in range(n):
                for j in range(i):
                    if nums[j] < nums[i]:
                        lis[i] = max(lis[i], lis[j] + 1)
            lds = [1] * n
            for i in range(n - 1, -1, -1):
                for j in range(i + 1, n):
                    if nums[j] < nums[i]:
                        lds[i] = max(lds[i], lds[j] + 1)
            best = 0
            for i in range(1, n - 1):
                if lis[i] >= 2 and lds[i] >= 2:
                    best = max(best, lis[i] + lds[i] - 1)
            return n - best

    class B:
        def minimumMountainRemovals(self, nums: List[int]) -> int:
            n = len(nums)
            lis = [0] * n
            tails = []
            for i, x in enumerate(nums):
                p = bisect_left(tails, x)
                if p == len(tails):
                    tails.append(x)
                else:
                    tails[p] = x
                lis[i] = p + 1
            lds = [0] * n
            tails_neg = []
            for i in range(n - 1, -1, -1):
                v = -nums[i]
                p = bisect_left(tails_neg, v)
                if p == len(tails_neg):
                    tails_neg.append(v)
                else:
                    tails_neg[p] = v
                lds[i] = p + 1
            best = 0
            for i in range(1, n - 1):
                if lis[i] >= 2 and lds[i] >= 2:
                    best = max(best, lis[i] + lds[i] - 1)
            return n - best

    a, b = A(), B()
    random.seed(0)
    for n in range(3, 41):
        for _ in range(200):
            arr = [random.randint(1, 20) for _ in range(n)]
            # Skip cases where no mountain is possible (rare), but the original CF/LC guarantees feasibility.
            assert a.minimumMountainRemovals(arr) == b.minimumMountainRemovals(arr)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from bisect import bisect_left

class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        # Strict LIS ending at each index in O(n log n)
        lis = [0] * n
        tails = []
        for i, x in enumerate(nums):
            p = bisect_left(tails, x)
            if p == len(tails):
                tails.append(x)
            else:
                tails[p] = x
            lis[i] = p + 1
        # Strict LDS starting at each index via LIS on negatives scanning from right
        lds = [0] * n
        tails_neg = []
        for i in range(n - 1, -1, -1):
            v = -nums[i]
            p = bisect_left(tails_neg, v)
            if p == len(tails_neg):
                tails_neg.append(v)
            else:
                tails_neg[p] = v
            lds[i] = p + 1
        # Aggregate feasible peaks
        best = 0
        for i in range(1, n - 1):
            if lis[i] >= 2 and lds[i] >= 2:
                val = lis[i] + lds[i] - 1
                if val > best:
                    best = val
        return n - best

# Deterministic asserts
def _ref_tests():
    s = Solution()
    assert s.minimumMountainRemovals([1, 3, 1]) == 0
    assert s.minimumMountainRemovals([2, 1, 1, 5, 6, 2, 3, 1]) == 3
    assert s.minimumMountainRemovals([1, 2, 3, 2, 1]) == 0
    assert s.minimumMountainRemovals([1, 2, 2, 3, 2, 1]) == 1

if __name__ == "__main__":
    _ref_tests()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute per-index strict LIS and LDS, combine only peaks with both sides length at least 2, and answer is $n$ minus the best mountain length.}
\WHY{This pattern (per-index LIS/LDS and combining) is common in sequence DP questions, especially those involving bitonic/mountain properties.}
\CHECKLIST{
\begin{bullets}
\item Strictness: use $<$ for LIS and LDS.
\item Compute LIS ending and LDS starting, not global lengths.
\item Exclude endpoints as peaks.
\item Require both sides length $\ge 2$.
\item Answer $= n - \max(\text{LIS} + \text{LDS} - 1)$.
\item Use \texttt{bisect\_left} for strict LIS in $O(n \log n)$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All increasing or all decreasing sequences.
\item Plateaus: equal adjacent values prevent strictness.
\item Smallest $n=3$ cases.
\item Multiple equal best peaks; choose any, count only.
\item Duplicates clustered near the peak.
\item Peak forced near boundaries ($i=1$ or $i=n-2$).
\item Large values up to $10^{9}$ (no overflow in Python).
\item Repeated local ups and downs.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using $\le$ instead of $<$ breaks strictness.
\item Allowing peaks at indices 0 or $n-1$.
\item Forgetting to subtract 1 when combining lengths.
\item Using global LIS/LDS rather than per-index.
\item Incorrect LDS computation direction or not negating.
\item Off-by-one in \texttt{bisect} index to length mapping.
\item Not filtering peaks with side lengths $<2$.
\item Mixing subsequences with subarrays (must be subsequences).
\end{bullets}
}
\FAILMODES{Baseline $O(n^2)$ passes within constraints here but would fail for larger $n$. Incorrect handling of duplicates or endpoints yields infeasible mountains or overcounts. The $O(n \log n)$ approach remains robust.}
\ELI{We measure how tall we can climb up to each spot and how far we can go down starting there. Any spot with enough up and down makes a mountain. Keep the biggest mountain and remove everything else.}
\NotePages{3}

\end{document}