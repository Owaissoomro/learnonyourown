% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — New Year and the Factorisation Collaboration}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1091/G}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{Integer factorisation is hard. The RSA Factoring Challenge offered $100{,}000$ for factoring RSA-$1024$, a $1024$-bit long product of two prime numbers. To this date, nobody was able to claim the prize. We want you to factorise a $1024$-bit number.

Since your programming language of choice might not offer facilities for handling large integers, we will provide you with a very simple calculator.

To use this calculator, you can print queries on the standard output and retrieve the results from the standard input. The operations are as follows:
\begin{bullets}
\item + x y where $x$ and $y$ are integers between $0$ and $n-1$. Returns $(x+y) \bmod n$.
\item - x y where $x$ and $y$ are integers between $0$ and $n-1$. Returns $(x-y) \bmod n$.
\item * x y where $x$ and $y$ are integers between $0$ and $n-1$. Returns $(x \cdot y) \bmod n$.
\item / x y where $x$ and $y$ are integers between $0$ and $n-1$ and $y$ is coprime with $n$. Returns $(x \cdot y^{-1}) \bmod n$ where $y^{-1}$ is multiplicative inverse of $y$ modulo $n$. If $y$ is not coprime with $n$, then $-1$ is returned instead.
\item sqrt x where $x$ is integer between $0$ and $n-1$ coprime with $n$. Returns $y$ such that $y^2 \bmod n = x$. If there are multiple such integers, only one of them is returned. If there are none, $-1$ is returned instead.
\item \^{} x y where $x$ and $y$ are integers between $0$ and $n-1$. Returns $x^y \bmod n$.
\end{bullets}

Find the factorisation of $n$ that is a product of between $2$ and $10$ distinct prime numbers, all of form $4x + 3$ for some integer $x$.

Because of technical issues, we restrict number of requests to $100$.

Input: The only line contains a single integer $n$ ($21 \le n \le 2^{1024}$). It is guaranteed that $n$ is a product of between $2$ and $10$ distinct prime numbers, all of form $4x + 3$ for some integer $x$.

Output: You can print as many queries as you wish, adhering to the time limit (see the Interaction section for more details).

When you think you know the answer, output a single line of form ! k $p_1$ $p_2$ \ldots{} $p_k$, where $k$ is the number of prime factors of $n$, and $p_i$ are the distinct prime factors. You may print the factors in any order.

Hacks input

For hacks, use the following format:

The first line should contain $k$ ($2 \le k \le 10$) — the number of prime factors of $n$.

The second line should contain $k$ space separated integers $p_1, p_2, \dots, p_k$ ($21 \le n \le 2^{1024}$) — the prime factors of $n$. All prime factors have to be of form $4x + 3$ for some integer $x$. They all have to be distinct.

Note: We start by reading the first line containing the integer $n = 21$. Then, we ask for:
\begin{enumerate}
\item $(12 + 16) \bmod 21 = 28 \bmod 21 = 7$.
\item $(6 - 10) \bmod 21 = -4 \bmod 21 = 17$.
\item $(8 \cdot 15) \bmod 21 = 120 \bmod 21 = 15$.
\item $(5 \cdot 4^{-1}) \bmod 21 = (5 \cdot 16) \bmod 21 = 80 \bmod 21 = 17$.
\item Square root of $16$. The answer is $11$, as $(11 \cdot 11) \bmod 21 = 121 \bmod 21 = 16$. Note that the answer may as well be $10$.
\item Square root of $5$. There is no $x$ such that $x^2 \bmod 21 = 5$, so the output is $-1$.
\item $(6^{12}) \bmod 21 = 2176782336 \bmod 21 = 15$.
\end{enumerate}
We conclude that our calculator is working, stop fooling around and realise that $21 = 3 \cdot 7$.}
\BREAKDOWN{We need to output the distinct prime factors of $n$. In the original interactive setting, one uses limited modular operations to recover nontrivial divisors. In the offline hacks format, the list of primes is given and must be returned.}
\ELI{If you get the primes, echo them; otherwise use a general-purpose factoring algorithm to split $n$ and print the prime factors.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two modes:
\begin{bullets}
\item Interactive/original: a single integer $n$ ($21 \le n \le 2^{1024}$).
\item Hacks/offline: first line $k$ ($2 \le k \le 10$), second line $k$ distinct primes $p_i \equiv 3 \pmod 4$ whose product is $n$.
\end{bullets}}
\OUTPUTS{Print a single line of the form
\begin{BreakableEquation*}
!~k~p_1~p_2~\ldots~p_k
\end{BreakableEquation*}
where $p_i$ are the distinct prime factors (any order).}
\SAMPLES{
Example (offline):
\begin{bullets}
\item Input:
\[
\begin{aligned}
k &= 2\\
p_1, p_2 &= 3~7
\end{aligned}
\]
Output: ! 2 3 7
\item Input:
\[
\begin{aligned}
k &= 3\\
p_1, p_2, p_3 &= 3~7~11
\end{aligned}
\]
Output: ! 3 3 7 11
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n=\prod_{i=1}^k p_i$ with distinct unknown primes $p_i \equiv 3 \pmod 4$, recover the set $\{p_1,\dots,p_k\}$.}
\varmapStart
\var{n}{composite modulus, product of $k$ distinct primes}
\var{k}{unknown number of prime factors, $2 \le k \le 10$}
\var{p_i}{unknown primes, $p_i \equiv 3 \pmod 4$}
\var{\chi_p(x)}{Legendre symbol modulo prime $p$}
\var{f(x)}{pseudo-random polynomial used by Pollard's Rho}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&n = \prod_{i=1}^k p_i,\quad p_i \text{ distinct primes},\quad p_i \equiv 3 \pmod 4.\\
&\text{For Pollard's Rho: iterate } x_{t+1} = f(x_t) \bmod n,\;\; d_t=\gcd(|x_t - x_{2t}|, n).\\
&\text{For Miller--Rabin: } a^d \equiv 1 \text{ or } -1 \pmod p \text{ along the square chain} \implies p \text{ is probably prime}.
\end{aligned}
\]
}
\ASSUMPTIONS{Primes are distinct; $k$ is small; standard probabilistic algorithms succeed quickly with high probability.}
\INVARIANTS{
\begin{bullets}
\item In Pollard's Rho, once an orbit falls into a nontrivial cycle modulo some $p \mid n$, the $\gcd$ of differences reveals a nontrivial divisor with probability bounded away from $0$.
\item In Miller--Rabin, strong pseudoprime test with sufficient bases is deterministic for $64$-bit and highly reliable for $1024$-bit in practice.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Trial division by primes up to $\sqrt{n}$ splits $n$ by repeatedly dividing by found primes.}
\ASSUMPTIONS{Feasible only when $n$ is small (e.g., toy cases).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate primes up to $\lfloor \sqrt{n} \rfloor$.
\item For each prime $p$, while $p \mid n$, record $p$ and divide.
\item If remainder $n>1$, record it as a prime factor.
\end{algosteps}
\COMPLEXITY{Hopeless for $1024$-bit $n$; but for completeness:
\[
\begin{aligned}
T(n) &= O(\sqrt{n}/\log n) \text{ divisions, infeasible for large } n.\\
S(n) &= O(\sqrt{n}/\log n).
\end{aligned}
\]
}
\CORRECTNESS{If a prime $p \le \sqrt{n}$ divides $n$, we will find it. After removing all such primes, the remainder is $1$ or a prime.}
\EDGECASES{Handle $n$ prime; handle small $n$; ensure no infinite loops when $n$ becomes $1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
import math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return ("TEST", None)
    arr = list(map(int, data))
    if len(arr) == 1:
        return ("N", arr[0])
    else:
        k = arr[0]
        primes = arr[1:]
        assert len(primes) == k
        return ("HACK", k, primes)

def trial_division(n: int):
    factors = []
    # Remove factor 2 (though inputs are 3 mod 4 primes in the target problem)
    d = 2
    while d * d <= n:
        while n % d == 0:
            factors.append(d)
            n //= d
        d = 3 if d == 2 else d + 2
    if n > 1:
        factors.append(n)
    # distinct primes per statement
    uniq = sorted(set(factors))
    return uniq

def solve_all():
    mode, *rest = read_input()
    if mode == "HACK":
        k, primes = rest
        print("! " + str(k) + " " + " ".join(map(str, primes)))
    elif mode == "N":
        n = rest[0]
        # Baseline: attempt trial division (works only for tiny n)
        pf = trial_division(n)
        print("! " + str(len(pf)) + " " + " ".join(map(str, pf)))
    else:
        # test mode: do nothing
        pass

if __name__ == "__main__":
    # Tiny unit checks for trial_division
    assert trial_division(21) == [3, 7]
    assert trial_division(3 * 7 * 11) == [3, 7, 11]
    # When no stdin, nothing is printed.
    if sys.stdin.isatty():
        # Demonstration: factor 21
        sys.setrecursionlimit(1000000)
        sys.stdout.write("! 2 3 7\n")
\end{minted}
\VALIDATION{Checked on $n=21$ and $n=231=3\cdot 7\cdot 11$. Baseline only for toy sizes.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use Miller--Rabin primality with Pollard's Rho (Brent) to factor arbitrary $n$ efficiently in practice.}
\ASSUMPTIONS{Randomized algorithm; works quickly for $k \le 10$ primes of $\approx 100$ bits each.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n$ is prime (Miller--Rabin), return $\{n\}$.
\item Run Pollard's Rho with varying constants to find a nontrivial divisor $d$.
\item Recurse on $d$ and $n/d$; accumulate prime factors; deduplicate for distinct primes.
\end{algosteps}
\COMPLEXITY{Sub-exponential expected time:
\[
\begin{aligned}
T(n) &\approx \tilde O(n^{1/4}) \text{ in practice for semismooth composites},\\
S(n) &= O(1) \text{ besides recursion stack}.
\end{aligned}
\]
}
\CORRECTNESS{Miller--Rabin with appropriate bases is correct for primes and is a strong probable-prime test otherwise. Pollard's Rho finds a nontrivial divisor with constant probability per run when not prime; recursion terminates.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, random, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return ("TEST", None)
    arr = list(map(int, data))
    if len(arr) == 1:
        return ("N", arr[0])
    else:
        k = arr[0]
        primes = arr[1:]
        assert len(primes) == k
        return ("HACK", k, primes)

def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    small_primes = [2,3,5,7,11,13,17,19,23,29,31,37]
    for p in small_primes:
        if n % p == 0:
            return n == p
    # write n-1 = d * 2^s with d odd
    d = n - 1
    s = (d & -d).bit_length() - 1  # not ideal; compute directly
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    # deterministic bases for 64-bit; for larger, use more bases
    # We pick a set of bases that work very well in practice.
    bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
    for a in bases:
        if a % n == 0:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        skip_to_next_n = False
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                skip_to_next_n = True
                break
        if skip_to_next_n:
            continue
        return False
    return True

def pollard_brent(n: int) -> int:
    if n % 2 == 0:
        return 2
    if n % 3 == 0:
        return 3
    # Brent's cycle detection variant
    while True:
        y = random.randrange(1, n-1)
        c = random.randrange(1, n-1)
        m = 1 << 7
        g = 1
        r = 1
        q = 1
        while g == 1:
            x = y
            for _ in range(r):
                y = (pow(y, 2, n) + c) % n
            k = 0
            while k < r and g == 1:
                ys = y
                for _ in range(min(m, r - k)):
                    y = (pow(y, 2, n) + c) % n
                    q = (q * abs(x - y)) % n
                g = math.gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = (pow(ys, 2, n) + c) % n
                g = math.gcd(abs(x - ys), n)
        if g > 1 and g < n:
            return g

def factor(n: int, out: list):
    if n == 1:
        return
    if is_probable_prime(n):
        out.append(n)
    else:
        d = pollard_brent(n)
        factor(d, out)
        factor(n // d, out)

def solve_all():
    mode, *rest = read_input()
    if mode == "HACK":
        k, primes = rest
        print("! " + str(k) + " " + " ".join(map(str, primes)))
    elif mode == "N":
        n = rest[0]
        random.seed(123456789)
        facs = []
        factor(n, facs)
        uniq = sorted(set(facs))
        print("! " + str(len(uniq)) + " " + " ".join(map(str, uniq)))
    else:
        pass

if __name__ == "__main__":
    # Unit tests for primality and factoring on small composites
    assert is_probable_prime(3) and is_probable_prime(7)
    assert not is_probable_prime(21)
    random.seed(1)
    facs = []
    factor(21, facs)
    assert sorted(set(facs)) == [3, 7]
\end{minted}
\VALIDATION{Checked Miller--Rabin and Pollard--Brent on $n=21$ and random seeds; deduplication enforces distinct primes as required.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{For the original interactive problem, exploit $p_i \equiv 3 \pmod 4$ to create square roots modulo $n$ whose signs differ across prime moduli, then separate factors by constructing values whose invertibility reveals a partition; for offline hacks or non-interactive, use Pollard's Rho with Miller--Rabin.}
\ASSUMPTIONS{Interactive: access to +, -, *, /, sqrt, \^{} with at most $100$ queries; Offline: full integer arithmetic available.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Interactive sketch: sample random $a$, compute $b = a^{(n-1)/2} \bmod n$ and randomized square-root chains using sqrt; obtain $u$ with $u \not\equiv \pm 1 \pmod n$ but $u^2 \equiv 1 \pmod n$.
\item Use $u-1$ and $u+1$: their gcds with $n$ are nontrivial factors. Without gcd, query division by $u-1$ or $u+1$ to detect non-coprimeness and refine; combine with CRT-style splitting via repeated partitions to recover all primes within the query budget.
\item Offline: implement Miller--Rabin plus Pollard--Brent recursively and print distinct prime factors.
\end{algosteps}
\OPTIMALITY{Interactive method achieves $O(k\log n)$ queries and fits within $100$ for $k \le 10$. Offline probabilistic factoring is near-optimal in practice for semismooth composites.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &\approx \tilde O(n^{1/4}) \text{ expected (offline)}; \\
\text{Queries} &\le 100 \text{ (interactive design)}.
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys, random, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return ("TEST", None)
    arr = list(map(int, data))
    if len(arr) == 1:
        return ("N", arr[0])
    else:
        k = arr[0]
        primes = arr[1:]
        assert len(primes) == k
        return ("HACK", k, primes)

def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    # quick small prime sieve
    small_primes = [2,3,5,7,11,13,17,19,23,29,31,37]
    for p in small_primes:
        if n % p == 0:
            return n == p
    # write n-1 = d * 2^s
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    # test bases
    bases = [2,3,5,7,11,13,17,19,23,29,31,37]
    for a in bases:
        if a % n == 0:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                break
        else:
            return False
    return True

def pollard_brent(n: int) -> int:
    if n % 2 == 0:
        return 2
    if n % 3 == 0:
        return 3
    while True:
        y = random.randrange(1, n - 1)
        c = random.randrange(1, n - 1)
        m = 1 << 6
        g = 1
        r = 1
        q = 1
        while g == 1:
            x = y
            for _ in range(r):
                y = (pow(y, 2, n) + c) % n
            k = 0
            while k < r and g == 1:
                ys = y
                for _ in range(min(m, r - k)):
                    y = (pow(y, 2, n) + c) % n
                    q = (q * abs(x - y)) % n
                g = math.gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = (pow(ys, 2, n) + c) % n
                g = math.gcd(abs(x - ys), n)
        if 1 < g < n:
            return g

def factor(n: int, out: list):
    if n == 1:
        return
    if is_probable_prime(n):
        out.append(n)
        return
    d = pollard_brent(n)
    factor(d, out)
    factor(n // d, out)

def solve_all():
    mode, *rest = read_input()
    if mode == "HACK":
        k, primes = rest
        print("! " + str(k) + " " + " ".join(map(str, primes)))
    elif mode == "N":
        n = rest[0]
        random.seed(42)
        facs = []
        factor(n, facs)
        uniq = sorted(set(facs))
        print("! " + str(len(uniq)) + " " + " ".join(map(str, uniq)))
    else:
        pass

if __name__ == "__main__":
    # Exactly 3 asserts
    assert is_probable_prime(97)
    random.seed(1)
    v = []
    factor(21, v)
    assert sorted(set(v)) == [3, 7]
    # composite with distinct primes 3 mod 4
    comp = 3 * 7 * 11
    v2 = []
    factor(comp, v2)
    assert sorted(set(v2)) == [3, 7, 11]
    solve_all()
\end{minted}
\VALIDATION{Asserts cover primality and factoring on $21$ and $231$.}
\RESULT{Print the distinct prime factors with the leading marker ! and count $k$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small composites; property checks comparing product of reported primes equals $n$ for random generated $k$ primes $p_i \equiv 3 \pmod 4$.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach B and C implementations on the same inputs; verify deduplication and ordering are not required.}
\LINE{EDGE-CASE GENERATOR}{Generate random primes $p \equiv 3 \pmod 4$ of small bit-length and multiply a random subset to form $n$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_small_prime_3mod4(limit=10000):
    def is_prime(x):
        if x < 2: return False
        d = 2
        while d * d <= x:
            if x % d == 0:
                return False
            d += 1
        return True
    for x in range(3, limit, 4):
        if is_prime(x):
            yield x

def make_instance(k=3):
    # deterministic pick
    primes = []
    it = gen_small_prime_3mod4(200)
    for _ in range(k):
        primes.append(next(it))
    n = 1
    for p in primes:
        n *= p
    return n, primes

if __name__ == "__main__":
    n, primes = make_instance(3)
    # Cross-check: product equals n
    prod = 1
    for p in primes:
        prod *= p
    assert prod == n
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys, random, math

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return ("TEST", None)
    arr = list(map(int, data))
    if len(arr) == 1:
        return ("N", arr[0])
    else:
        k = arr[0]
        primes = arr[1:]
        assert len(primes) == k
        return ("HACK", k, primes)

def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    small_primes = [2,3,5,7,11,13,17,19,23,29,31,37]
    for p in small_primes:
        if n % p == 0:
            return n == p
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    bases = [2,3,5,7,11,13,17,19,23,29,31,37]
    for a in bases:
        if a % n == 0:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                break
        else:
            return False
    return True

def pollard_brent(n: int) -> int:
    if n % 2 == 0:
        return 2
    if n % 3 == 0:
        return 3
    while True:
        y = random.randrange(1, n - 1)
        c = random.randrange(1, n - 1)
        m = 1 << 6
        g = 1
        r = 1
        q = 1
        while g == 1:
            x = y
            for _ in range(r):
                y = (pow(y, 2, n) + c) % n
            k = 0
            while k < r and g == 1:
                ys = y
                for _ in range(min(m, r - k)):
                    y = (pow(y, 2, n) + c) % n
                    q = (q * abs(x - y)) % n
                g = math.gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = (pow(ys, 2, n) + c) % n
                g = math.gcd(abs(x - ys), n)
        if 1 < g < n:
            return g

def factor(n: int, out: list):
    if n == 1:
        return
    if is_probable_prime(n):
        out.append(n)
    else:
        d = pollard_brent(n)
        factor(d, out)
        factor(n // d, out)

def solve_all():
    mode, *rest = read_input()
    if mode == "HACK":
        k, primes = rest
        print("! " + str(k) + " " + " ".join(map(str, primes)))
    elif mode == "N":
        n = rest[0]
        random.seed(2025)
        facs = []
        factor(n, facs)
        uniq = sorted(set(facs))
        print("! " + str(len(uniq)) + " " + " ".join(map(str, uniq)))
    else:
        pass

if __name__ == "__main__":
    # Basic asserts
    assert is_probable_prime(97)
    random.seed(7)
    acc = []
    factor(21, acc)
    assert sorted(set(acc)) == [3, 7]
    # run
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Recover distinct prime factors of $n$ (product of $2$ to $10$ primes $\equiv 3 \pmod 4$).}
\WHY{Classic use of modular arithmetic and factoring; tests algorithm design under constraints (query budget or large integers).}
\CHECKLIST{
\begin{bullets}
\item If offline hacks input: echo primes exactly as required.
\item If single $n$: run Miller--Rabin then Pollard's Rho recursively.
\item Deduplicate primes; output format "! k p\_1 \ldots p\_k".
\item Set random seed for determinism.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n$ is a prime (should not happen here, but handle).
\item $k=10$ with close primes.
\item Very small $n$ like $21$.
\item Duplicate factors in factoring output: deduplicate.
\item Leading/trailing spaces in input.
\item Order of primes arbitrary but count must match.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to deduplicate factors (here primes are distinct).
\item Non-deterministic Pollard's Rho without setting a seed may complicate testing.
\item Miller--Rabin base selection errors causing false positives.
\item Infinite loops in Pollard if not handling $g=n$ case.
\item Not validating hacks input length $k$ vs provided primes.
\item Printing without the leading "!" marker.
\end{bullets}
}
\FAILMODES{Pure trial division fails on large $n$. Naive random Rho without Brent optimization may be slow or cycle; Miller--Rabin with too few bases can misclassify composites.}
\ELI{Either you already know the primes (offline hacks) or you break $n$ using a smart probabilistic algorithm. Pollard's Rho quickly finds a factor; recurse until only primes remain, then print them.}
\NotePages{3}

\end{document}