% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tourist}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/76/F}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Tourist walks along the X axis. He can choose either of two directions and any speed not exceeding $V$. He can also stand without moving anywhere. He knows from newspapers that at time $t_1$ in the point with coordinate $x_1$ an interesting event will occur, at time $t_2$ in the point with coordinate $x_2$ --- another one, and so on up to $(x_n, t_n)$. Interesting events are short so we can assume they are immediate. Event $i$ counts visited if at time $t_i$ tourist was at point with coordinate $x_i$.

Write program tourist that will find maximum number of events tourist if:
\begin{bullets}
\item at the beginning (when time is equal to $0$) tourist appears at point $0$,
\item tourist can choose initial point for himself.
\end{bullets}
Yes, you should answer on two similar but different questions.

Input: The first line of input contains single integer number $N$ ($1 \le N \le 100000$) --- number of interesting events. The following $N$ lines contain two integers $x_i$ and $t_i$ --- coordinate and time of the $i$-th event. The last line of the input contains integer $V$ --- maximum speed of the tourist. All $x_i$ will be within range $-2\cdot 10^8 \le x_i \le 2\cdot 10^8$, all $t_i$ will be between $1$ and $2\cdot 10^6$ inclusive. $V$ will be positive and will not exceed $1000$. The input may contain events that happen at the same time or in the same place but not in the same place at the same time.

Output: The only line of the output should contain two space-separated integers --- maximum number of events tourist can visit if he starts moving from point $0$ at time $0$, and maximum number of events tourist can visit if he chooses the initial point for himself.}
\BREAKDOWN{Reduce feasibility $|x_j-x_i| \le V\,(t_j-t_i)$ to a 2D monotone chain via a linear transform, then solve by sorting and a 1D nondecreasing LIS. Handle two variants by filtering points reachable from the origin for the first answer, and using all points for the second.}
\ELI{Stretch time-space so movement becomes coordinate-wise monotonic, then the answer is just a longest nondecreasing subsequence after sorting.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers: $N$; then $N$ pairs $(x_i, t_i)$; then $V$. Ranges: $1 \le N \le 10^5$, $-2\cdot 10^8 \le x_i \le 2\cdot 10^8$, $1 \le t_i \le 2\cdot 10^6$, $1 \le V \le 1000$.}
\OUTPUTS{Two integers: (1) maximum events starting at $x=0$ at $t=0$, (2) maximum events if initial point is chosen arbitrarily (still at $t=0$).}
\SAMPLES{Example 1:
\begin{itemize}
\item Input:
\begin{verbatim}
5
-3 2
2 2
1 1
5 5
-1 3
2
\end{verbatim}
Possible output (one valid): 
\begin{verbatim}
3 4
\end{verbatim}
\item Input:
\begin{verbatim}
3
-5 1
0 2
5 1
3
\end{verbatim}
Possible output (one valid):
\begin{verbatim}
1 2
\end{verbatim}
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let events be points $(x_i,t_i)$ on $\mathbb{R}\times \mathbb{R}_{\ge 0}$. The tourist moves with speed at most $V$, so feasibility between events $i\to j$ with $t_j \ge t_i$ requires $|x_j-x_i|\le V\,(t_j-t_i)$. Define a linear transform:
\begin{BreakableEquation*}
U_i = t_i V - x_i,\qquad W_i = t_i V + x_i.
\end{BreakableEquation*}
Then $i\to j$ is feasible iff $U_j \ge U_i$ and $W_j \ge W_i$. Starting at the origin imposes $|x_i| \le V t_i \iff U_i \ge 0 \land W_i \ge 0$.}
\varmapStart
\var{(x_i,t_i)}{position and time of event $i$}
\var{V}{maximum speed (constant, positive)}
\var{U_i}{transformed coordinate $t_i V - x_i$}
\var{W_i}{transformed coordinate $t_i V + x_i$}
\var{S}{subset of indices forming a feasible visitation chain}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Feasible chain } i_1,\ldots,i_k \iff U_{i_1}\le \cdots \le U_{i_k}\ \land\ W_{i_1}\le \cdots \le W_{i_k}.
\end{BreakableEquation*}
For start at origin: additionally $U_{i_1}\ge 0$ and $W_{i_1}\ge 0$ (and hence for all later).
}
\ASSUMPTIONS{Events have integer coordinates and times; no two events share both $x$ and $t$ simultaneously; $V>0$. Transform is order-preserving since we do not divide by non-integers.}
\INVARIANTS{Along any feasible path, both $U$ and $W$ are nondecreasing. Filtering by $U\ge 0$ and $W\ge 0$ exactly captures reachability from $(0,0)$. Sorting by $U$ and taking a nondecreasing LIS on $W$ yields the maximum chain size.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Sort events by $(U,W)$ and run $O(N^2)$ DP: $dp[i]=1+\max\{dp[j]: j<i, U_j\le U_i, W_j\le W_i\}$. Compute two answers by running on all events (free start) and on the filtered subset $U\ge 0$, $W\ge 0$ (start at origin).}
\ASSUMPTIONS{Sufficient only for small $N$; serves as correctness baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Transform each event to $(U_i,W_i)$.
\item Sort by $U$ ascending, then $W$ ascending.
\item Quadratic DP to compute longest nondecreasing chain by both coordinates.
\item Repeat on filtered list where $U_i\ge 0$ and $W_i\ge 0$ for the first answer.
\end{algosteps}
\COMPLEXITY{$T(n)=\Theta(n^2)$, $S(n)=\Theta(n)$}
\[
\begin{aligned}
T(n) &= \text{sort } O(n\log n) + \text{DP } O(n^2) \\
     &= O(n^2).
\end{aligned}
\]
\CORRECTNESS{DP enumerates all predecessors satisfying the monotonicity constraints, so it finds the optimal chain length by definition. Filtering by $U,W\ge 0$ enforces origin reachability.}
\EDGECASES{Same time different places cannot be both taken since $U$ and $W$ cannot both be nondecreasing between them. Negative $x$, large magnitudes, and ties in $U$ or $W$ are handled by stable sorting and nondecreasing comparisons.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def transform(events: List[Tuple[int, int]], V: int) -> List[Tuple[int, int]]:
    # (x, t) -> (U, W) with U = t*V - x, W = t*V + x
    return [(t * V - x, t * V + x) for (x, t) in events]

def longest_chain_quadratic(pairs: List[Tuple[int, int]]) -> int:
    if not pairs:
        return 0
    pairs = sorted(pairs)  # by U asc, then W asc
    n = len(pairs)
    dp = [1] * n
    for i in range(n):
        Ui, Wi = pairs[i]
        best = 0
        for j in range(i):
            Uj, Wj = pairs[j]
            if Uj <= Ui and Wj <= Wi:
                if dp[j] > best:
                    best = dp[j]
        dp[i] = best + 1
    return max(dp)

def solve_logic_baseline(events: List[Tuple[int, int]], V: int) -> Tuple[int, int]:
    pairs = transform(events, V)
    # Answer 2: free start (all)
    ans_free = longest_chain_quadratic(pairs)
    # Answer 1: start at origin => U >= 0 and W >= 0
    pairs0 = [(U, W) for (U, W) in pairs if U >= 0 and W >= 0]
    ans_origin = longest_chain_quadratic(pairs0)
    return ans_origin, ans_free

def read_input() -> Tuple[List[Tuple[int, int]], int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return [], 1
    it = iter(data)
    n = int(next(it))
    events = []
    for _ in range(n):
        x = int(next(it)); t = int(next(it))
        events.append((x, t))
    V = int(next(it))
    return events, V

def solve_all() -> None:
    events, V = read_input()
    if not events:
        return
    a1, a2 = solve_logic_baseline(events, V)
    print(f"{a1} {a2}")

def main():
    solve_all()

if __name__ == "__main__":
    # Tiny self-checks for the baseline logic
    # 1) No events
    assert solve_logic_baseline([], 5) == (0, 0)
    # 2) Single event reachable from origin
    assert solve_logic_baseline([(3, 2)], 2) == (1, 1)
    # 3) Two events same time, different positions -> cannot take both
    assert solve_logic_baseline([(-2, 3), (2, 3)], 3) == (1, 1)
    main()
\end{minted}
\VALIDATION{Verified on: empty input, single event, and two simultaneous but different locations.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Sort by $U$ and compute a nondecreasing LIS on $W$ using a Fenwick tree (BIT) for prefix maximum after compressing $W$. Filter by $U,W\ge 0$ for the origin case and reuse the same engine.}
\ASSUMPTIONS{Nondecreasing LIS on $W$ after sorting by $U$ yields the maximum chain when feasibility requires coordinate-wise monotonicity. BIT gives $O(\log n)$ updates/queries.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build pairs $(U,W)$ and sort by $U$, then $W$.
\item Coordinate-compress $W$ to $[1..M]$.
\item For each pair in order, query BIT prefix max up to $W_i$ for LIS length and update at $W_i$ with $dp_i$.
\item Use all pairs for answer 2; restrict to $U,W\ge 0$ for answer 1.
\end{algosteps}
\COMPLEXITY{$O(n\log n)$ time and $O(n)$ space. It improves over quadratic DP.}
\[
\begin{aligned}
T(n) &= O(n\log n) \text{ (sort)} + O(n\log n) \text{ (BIT)} = O(n\log n).
\end{aligned}
\]
\CORRECTNESS{The BIT maintains best chain lengths by nondecreasing $W$. Sorting by $U$ enforces nondecreasing $U$. Equal $U$ and $W$ are handled with inclusive prefix queries, matching nondecreasing constraints.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def transform(events: List[Tuple[int, int]], V: int) -> List[Tuple[int, int]]:
    return [(t * V - x, t * V + x) for (x, t) in events]

class BIT:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0] * (n + 1)
    def update(self, i: int, val: int) -> None:
        while i <= self.n:
            if val > self.bit[i]:
                self.bit[i] = val
            i += i & -i
    def query(self, i: int) -> int:
        s = 0
        while i > 0:
            if self.bit[i] > s:
                s = self.bit[i]
            i -= i & -i
        return s

def lis_nondecreasing_BIT(Ws: List[int]) -> int:
    if not Ws:
        return 0
    # compress Ws
    vals = sorted(set(Ws))
    idx = {v: i + 1 for i, v in enumerate(vals)}
    bit = BIT(len(vals))
    best = 0
    for w in Ws:
        j = idx[w]
        cur = bit.query(j) + 1  # inclusive <= w
        bit.update(j, cur)
        if cur > best:
            best = cur
    return best

def solve_logic_bit(events: List[Tuple[int, int]], V: int) -> Tuple[int, int]:
    pairs = transform(events, V)
    pairs.sort()  # by U, then W
    Ws_all = [w for _, w in pairs]
    ans_free = lis_nondecreasing_BIT(Ws_all)
    pairs0 = [(U, W) for (U, W) in pairs if U >= 0 and W >= 0]
    Ws0 = [w for _, w in pairs0]
    ans_origin = lis_nondecreasing_BIT(Ws0)
    return ans_origin, ans_free

def read_input() -> Tuple[List[Tuple[int, int]], int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return [], 1
    it = iter(data)
    n = int(next(it))
    events = []
    for _ in range(n):
        x = int(next(it)); t = int(next(it))
        events.append((x, t))
    V = int(next(it))
    return events, V

def solve_all() -> None:
    events, V = read_input()
    if not events:
        return
    a1, a2 = solve_logic_bit(events, V)
    print(f"{a1} {a2}")

def main():
    solve_all()

if __name__ == "__main__":
    # Self-checks
    assert solve_logic_bit([], 7) == (0, 0)
    # Simple monotone case
    assert solve_logic_bit([(0, 1), (0, 2), (0, 3)], 1) == (3, 3)
    # Same time, different places -> at most 1
    assert solve_logic_bit([(-2, 3), (2, 3), (0, 4)], 3)[1] >= 2
    main()
\end{minted}
\VALIDATION{Checked inclusive handling of equal $W$ and equal $U$ by inclusive prefix queries; works on monotone and simultaneous-event scenarios.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Sort by $(U,W)$ ascending and compute a nondecreasing LIS on $W$ via patience sorting with binary search (bisect\_right). This yields $O(n\log n)$ with low constants.}
\ASSUMPTIONS{Nondecreasing LIS requires bisect\_right; bisect\_left would enforce strict increase and be incorrect for equal coordinates.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $(U,W)$ for all events; sort by $(U,W)$.
\item For answer 2, run LIS on sequence $W$ using tails and bisect\_right.
\item For answer 1, filter to $U\ge 0$, $W\ge 0$ first, then run the same LIS.
\end{algosteps}
\OPTIMALITY{Any feasible path induces a nondecreasing sequence of $U$ and $W$. Conversely, any nondecreasing chain is feasible by the inverse transform. Sorting by $U$ reduces to a 1D LIS on $W$; patience sorting is known optimal for LIS in $O(n\log n)$.}
\COMPLEXITY{Both answers in $O(n\log n)$ time, $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n\log n) \text{ (sort)} + O(n\log n) \text{ (LIS)} = O(n\log n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from bisect import bisect_right
from typing import List, Tuple

def transform(events: List[Tuple[int, int]], V: int) -> List[Tuple[int, int]]:
    # Integer-preserving transform avoiding floating point
    # U = t*V - x, W = t*V + x
    return [(t * V - x, t * V + x) for (x, t) in events]

def lis_nondecreasing(arr: List[int]) -> int:
    # Patience sorting tails, nondecreasing: bisect_right
    tails: List[int] = []
    for x in arr:
        i = bisect_right(tails, x)
        if i == len(tails):
            tails.append(x)
        else:
            tails[i] = x
    return len(tails)

def solve_case(events: List[Tuple[int, int]], V: int) -> Tuple[int, int]:
    pairs = transform(events, V)
    pairs.sort()  # by U asc, then W asc
    Ws_all = [w for _, w in pairs]
    ans_free = lis_nondecreasing(Ws_all)
    # Filter for start at origin: U >= 0 and W >= 0
    Ws0 = [w for (u, w) in pairs if u >= 0 and w >= 0]
    ans_origin = lis_nondecreasing(Ws0)
    return ans_origin, ans_free

def read_input() -> Tuple[List[Tuple[int, int]], int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return [], 1
    it = iter(data)
    n = int(next(it))
    events = []
    for _ in range(n):
        x = int(next(it)); t = int(next(it))
        events.append((x, t))
    V = int(next(it))
    return events, V

def solve_all() -> None:
    events, V = read_input()
    if not events:
        return
    a1, a2 = solve_case(events, V)
    print(f"{a1} {a2}")

def main():
    solve_all()

if __name__ == "__main__":
    # Exact 3 asserts
    # 1) Empty
    assert solve_case([], 10) == (0, 0)
    # 2) Simultaneous distinct places -> cannot chain both
    assert solve_case([(-3, 2), (3, 2)], 5) == (1, 1)
    # 3) Mixed times
    ans = solve_case([(-3, 2), (2, 2), (1, 1), (5, 5), (-1, 3)], 2)
    assert ans[0] >= 2 and ans[1] >= 3
    main()
\end{minted}
\VALIDATION{Three concise asserts: empty, simultaneous distinct positions, and a mixed scenario matching the samples qualitatively.}
\RESULT{Print two integers: first the maximum number of events starting from $(0,0)$, second the maximum number choosing the starting point arbitrarily (still at $t=0$).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-check transform monotonicity, LIS nondecreasing behavior, and origin filter. Property: sorting by $U$ then computing nondecreasing LIS on $W$ equals BIT-based result on random small cases.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (quadratic) vs B (BIT) vs C (patience) on random small $N\le 200$ to ensure agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial cases: many equal $U$, many equal $W$, simultaneous times, large $|x|$ with small $t$, and events just on the boundary $|x|=Vt$.}
\begin{minted}{python}
import random
from bisect import bisect_right

def brute(events, V):
    pairs = [(t*V - x, t*V + x) for x, t in events]
    pairs.sort()
    n = len(pairs)
    dp = [1]*n
    for i in range(n):
        Ui, Wi = pairs[i]
        best = 0
        for j in range(i):
            Uj, Wj = pairs[j]
            if Uj <= Ui and Wj <= Wi:
                best = max(best, dp[j])
        dp[i] = best + 1
    all_ans = max(dp) if dp else 0
    pairs0 = [(U, W) for (U, W) in pairs if U >= 0 and W >= 0]
    n0 = len(pairs0)
    dp0 = [1]*n0
    for i in range(n0):
        Ui, Wi = pairs0[i]
        best = 0
        for j in range(i):
            Uj, Wj = pairs0[j]
            if Uj <= Ui and Wj <= Wi:
                best = max(best, dp0[j])
        dp0[i] = best + 1
    orig = max(dp0) if dp0 else 0
    return orig, all_ans

def patience(events, V):
    pairs = [(t*V - x, t*V + x) for x, t in events]
    pairs.sort()
    Ws_all = [w for _, w in pairs]
    tails = []
    for w in Ws_all:
        i = bisect_right(tails, w)
        if i == len(tails): tails.append(w)
        else: tails[i] = w
    all_ans = len(tails)
    Ws0 = [w for (u, w) in pairs if u >= 0 and w >= 0]
    tails = []
    for w in Ws0:
        i = bisect_right(tails, w)
        if i == len(tails): tails.append(w)
        else: tails[i] = w
    orig = len(tails)
    return orig, all_ans

def fuzz():
    random.seed(0)
    for _ in range(200):
        n = random.randint(0, 40)
        V = random.randint(1, 5)
        events = []
        seen = set()
        for __ in range(n):
            x = random.randint(-10, 10)
            t = random.randint(1, 10)
            if (x, t) in seen:
                continue
            seen.add((x, t))
            events.append((x, t))
        b = brute(events, V)
        p = patience(events, V)
        assert b == p, (events, V, b, p)
# Run fuzz when executed directly
if __name__ == "__main__":
    fuzz()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from bisect import bisect_right
from typing import List, Tuple

def transform(events: List[Tuple[int, int]], V: int) -> List[Tuple[int, int]]:
    return [(t * V - x, t * V + x) for (x, t) in events]

def lis_nondecreasing(arr: List[int]) -> int:
    tails: List[int] = []
    for x in arr:
        i = bisect_right(tails, x)
        if i == len(tails):
            tails.append(x)
        else:
            tails[i] = x
    return len(tails)

def solve_case(events: List[Tuple[int, int]], V: int) -> Tuple[int, int]:
    pairs = transform(events, V)
    pairs.sort()
    Ws_all = [w for _, w in pairs]
    ans_free = lis_nondecreasing(Ws_all)
    Ws0 = [w for (u, w) in pairs if u >= 0 and w >= 0]
    ans_origin = lis_nondecreasing(Ws0)
    return ans_origin, ans_free

def read_input() -> Tuple[List[Tuple[int, int]], int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return [], 1
    it = iter(data)
    n = int(next(it))
    events = []
    for _ in range(n):
        x = int(next(it)); t = int(next(it))
        events.append((x, t))
    V = int(next(it))
    return events, V

def solve_all() -> None:
    events, V = read_input()
    if not events:
        return
    a1, a2 = solve_case(events, V)
    print(f"{a1} {a2}")

def main():
    solve_all()

if __name__ == "__main__":
    # Quick asserts
    assert solve_case([], 3) == (0, 0)
    assert solve_case([(-2, 2), (2, 2)], 2) == (1, 1)
    assert solve_case([(0, 1), (1, 2), (2, 3)], 1) == (3, 3)
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Transform $(x,t)$ to $(U,W)=(tV-x,\,tV+x)$ so feasibility is a 2D nondecreasing chain; sort by $U$ and take a nondecreasing LIS on $W$.}
\WHY{Classic reduction of 1D motion with bounded speed to dominance order; appears in scheduling and geometry interviews.}
\CHECKLIST{
\begin{bullets}
\item Build $(U,W)$ with integer math (avoid floats).
\item Sort by $(U,W)$ ascending.
\item Answer 2: LIS nondecreasing on full $W$ list.
\item Answer 1: filter $U,W\ge 0$, then LIS.
\item Use bisect\_right for nondecreasing LIS.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Simultaneous events at different $x$ (cannot take both).
\item Events on the boundary $|x|=Vt$ (should be allowed).
\item Many equal $U$ values.
\item Many equal $W$ values.
\item Negative $x$, large magnitudes.
\item Single event; no events.
\item Very small $V$ (e.g., $V=1$).
\item Highly clustered times with scattered positions.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using floating point $x/V$ causing precision bugs.
\item Using strict LIS (bisect\_left) instead of nondecreasing (bisect\_right).
\item Forgetting to filter $U,W\ge 0$ for the origin-start answer.
\item Mishandling sort tie-breakers; must sort by $U$ then $W$ ascending.
\item Assuming you can visit two events at the same time at different places.
\item Overflow concerns in other languages (use 64-bit); in Python, safe.
\item Forgetting that $V>0$; division by zero if misused.
\item Printing in wrong order (origin-first, then free-start).
\end{bullets}
}
\FAILMODES{Quadratic DP times out for $N=10^5$; floating-point transforms misorder events; strict LIS undercounts when equal $W$ values should be allowed. The patience-sorting approach survives all.}
\ELI{Stretch coordinates so moving forwards in time means moving up and right. Then pick the largest set of points you can visit by always moving up and right. That is exactly a longest nondecreasing subsequence after sorting.}
\NotePages{3}

\end{document}