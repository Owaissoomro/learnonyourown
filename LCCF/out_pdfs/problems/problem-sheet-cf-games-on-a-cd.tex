% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Games on a CD}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/727/E}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Several years ago Tolya had $n$ computer games and at some point of time he decided to burn them to CD. After that he wrote down the names of the games one after another in a circle on the CD in clockwise order. The names were distinct, the length of each name was equal to $k$. The names did not overlap.

Thus, there is a cyclic string of length $n \cdot k$ written on the CD.

Several years have passed and now Tolya cannot remember which games he burned to his CD. He knows that there were $g$ popular games that days. All of the games he burned were among these $g$ games, and no game was burned more than once.

You have to restore any valid list of games Tolya could burn to the CD several years ago.

Input: The first line of the input contains two positive integers $n$ and $k$ ($1 \le n \le 10^5$, $1 \le k \le 10^5$) — the amount of games Tolya burned to the CD, and the length of each of the names.

The second line of the input contains one string consisting of lowercase English letters — the string Tolya wrote on the CD, split in arbitrary place. The length of the string is $n \cdot k$. It is guaranteed that the length is not greater than $10^6$.

The third line of the input contains one positive integer $g$ ($n \le g \le 10^5$) — the amount of popular games that could be written on the CD. It is guaranteed that the total length of names of all popular games is not greater than $2 \cdot 10^6$.

Each of the next $g$ lines contains a single string — the name of some popular game. Each name consists of lowercase English letters and has length $k$. It is guaranteed that the names are distinct.

Output: If there is no answer, print ``NO'' (without quotes).

Otherwise, print two lines. In the first line print ``YES'' (without quotes). In the second line, print $n$ integers — the games which names were written on the CD. You should print games in the order they could have been written on the CD, it means, in clockwise order. You can print games starting from any position. Remember, that no game was burned to the CD more than once. If there are several possible answers, print any of them.}
\BREAKDOWN{We are given a cyclic string of length $n \cdot k$ that is a rotation of a concatenation of $n$ distinct length-$k$ names chosen from $g$ candidates. We must find an offset $r \in [0,k-1]$ so that reading $k$-length blocks starting at positions $r, r+k, \ldots, r+(n-1)k$ yields $n$ distinct names from the list. If possible, output their indices in that order.}
\ELI{Try each possible boundary offset modulo $k$, split the circle into consecutive $k$-chunks, check if all chunks are known and pairwise distinct.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integers $n, k$ with $1 \le n \le 10^5$, $1 \le k \le 10^5$, and $n \cdot k \le 10^6$.
- String $S$ of lowercase letters, $|S| = n \cdot k$, which is a rotation of the cyclic writing.
- Integer $g$ with $n \le g \le 10^5$; total length of all $g$ names $\le 2 \cdot 10^6$.
- Then $g$ distinct strings (lowercase), each of length exactly $k$.}
\OUTPUTS{If impossible, print NO. Otherwise print YES on the first line, and on the second line print $n$ space-separated integers in $[1,g]$ giving a valid clockwise order of distinct games, starting from any position on the circle.}
\SAMPLES{Example 1:
- Input
  n=3, k=2
  S=cdabef
  g=4
  names=[ab, cd, ef, gh]
- One valid output
  YES
  2 1 3

Example 2:
- Input
  n=2, k=3
  S=abcdef
  g=2
  names=[abc, abe]
- Output
  NO}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathcal{G}=\{w_1,\ldots,w_g\}$ be the candidate names, $|w_i|=k$. Let $C$ be the cyclic string of length $n \cdot k$ obtained by some ordering of $n$ distinct names from $\mathcal{G}$. The observed string $S$ is an arbitrary rotation of $C$. We seek indices $(i_0,\ldots,i_{n-1})$ with all $i_t$ distinct such that for some offset $r \in \{0,\ldots,k-1\}$ and all $t$,
the length-$k$ substring of $S$ starting at position $r+t\cdot k$ (with wrap-around) equals $w_{i_t}$.}
\varmapStart
\var{n}{number of names on CD}
\var{k}{length of each name}
\var{g}{number of candidate names}
\var{S}{observed string of length $n \cdot k$ (rotation of the cycle)}
\var{r}{boundary offset modulo $k$}
\var{i_t}{index in $[1,g]$ of the $t$-th chosen name}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\exists r \in \{0,\ldots,k-1\},\ \exists (i_0,\ldots,i_{n-1}) \text{ all distinct such that}\\
&\forall t\in\{0,\ldots,n-1\}:\ S[(r+t k)\,:\,(r+t k)+k] \equiv w_{i_t}\quad\text{(indices modulo }n k\text{)}.
\end{aligned}
\]
}
\ASSUMPTIONS{Alphabet is lowercase English; names are distinct; $S$ may begin at an arbitrary position on the cycle; comparisons are exact string equality.}
\INVARIANTS{For any fixed $r$, the $n$ starting positions $r, r+k, \ldots, r+(n-1)k$ cover exactly one representative per congruence class along the cycle; if any chunk is unknown or repeated, that $r$ is invalid.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all $k$ boundary offsets $r$. For each, read $n$ consecutive chunks of length $k$ stepping by $k$, and check membership in the candidate set and pairwise distinctness.}
\ASSUMPTIONS{Use direct substring slicing and a Python set of candidate names; correctness is immediate but may be slow if many large slices are created.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read input; store a map name $\to$ index $1..g$; extend $S$ to $S+S$ for wrap-around.
\item For each $r \in [0,k-1]$, collect chunks $S[r+i\cdot k : r+i\cdot k + k]$ for $i=0..n-1$.
\item If all chunks are in the map and are pairwise distinct, output their indices and stop.
\end{algosteps}
\COMPLEXITY{Creates $k \cdot n$ slices of length $k$; total characters processed can be $O(n \cdot k^2)$ in the worst case, which is too slow for tight limits, but fine as a pedagogical baseline.}
\[
\begin{aligned}
T(n,k) &= \underbrace{k \cdot n}_{\text{offsets}\times\text{chunks}} \cdot O(k) \\
       &= O(n \cdot k^2),\quad S(n,k)=O(g + n k).
\end{aligned}
\]
\CORRECTNESS{For the true boundary offset $r^\star$, the $n$ chunks coincide with the actual names in clockwise order; the membership and distinctness checks then succeed. For any other $r$, at least one chunk will mismatch or repeat.}
\EDGECASES{Handle $n=1$; handle $k=1$; ensure wrap-around by reading from $S+S$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 727E — Baseline brute-force slicing
# Includes: read_input(), solve_case(), main guard, and asserts

from typing import List, Tuple, Dict

def read_input() -> Tuple[int, int, str, int, List[str]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    S = next(it).strip()
    g = int(next(it))
    names = [next(it).strip() for _ in range(g)]
    return n, k, S, g, names

def solve_given_baseline(n: int, k: int, S: str, g: int, names: List[str]) -> Tuple[bool, List[int]]:
    # Map name -> index (1-based)
    name_to_idx: Dict[str, int] = {w: i + 1 for i, w in enumerate(names)}
    m = n * k
    S2 = S + S  # for wrap-around
    for r in range(k):
        used_idx = set()
        order: List[int] = []
        ok = True
        for i in range(n):
            start = r + i * k
            chunk = S2[start:start + k]
            idx = name_to_idx.get(chunk, -1)
            if idx == -1 or idx in used_idx:
                ok = False
                break
            used_idx.add(idx)
            order.append(idx)
        if ok:
            return True, order
    return False, []

def solve_case() -> None:
    n, k, S, g, names = read_input()
    ok, order = solve_given_baseline(n, k, S, g, names)
    if not ok:
        print("NO")
    else:
        print("YES")
        print(" ".join(map(str, order)))

if __name__ == "__main__":
    # Tiny self-checks for the baseline
    ok, order = solve_given_baseline(3, 2, "cdabef", 4, ["ab", "cd", "ef", "gh"])
    assert ok and set(order) == {1, 2, 3} and len(order) == 3
    ok2, order2 = solve_given_baseline(2, 3, "abcdef", 2, ["abc", "abe"])
    assert not ok2
    # A one-name case
    ok3, order3 = solve_given_baseline(1, 3, "abc", 2, ["abc", "def"])
    assert ok3 and order3 in ([1],)
    # Do not run solve_case() here to avoid interfering with asserts in this block
\end{minted}
\VALIDATION{Checks: a valid rotation with three names; an impossible case; a single-name case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Rolling Hash + Precomputed Chunk IDs}
\WHICHFORMULA{Avoid materializing $O(k)$-sized substrings. Precompute double rolling hashes of $S+S$ and map candidate names by hash to indices. Build an array $A[p]$ for all $p\in[0,nk-1]$ with the ID of chunk $S[p:p+k]$ (or $-1$). Then test each offset $r$ by reading $A[r+i k]$.}
\ASSUMPTIONS{Use double polynomial hash (mod $10^9+7$ and $10^9+9$) with a fixed base; collisions are negligible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute powers and prefix hashes for $S+S$ under two moduli.
\item Hash each candidate name under both moduli; store pair $\to$ index.
\item For all $p$ in $[0,nk-1]$, compute the pair-hash of $S[p:p+k]$ in $O(1)$; set $A[p]$ to mapped ID or $-1$.
\item For each $r\in[0,k-1]$, scan $A[r+i k]$ for $i=0..n-1$, ensuring all in-map and distinct; if so, output the order.
\end{algosteps}
\COMPLEXITY{All $A[p]$ computed in $O(nk)$ time; each offset scan is $O(n)$; across all $k$ offsets the total is $O(nk) \le 10^6$. Memory is linear in $nk$ and $g$.}
\[
\begin{aligned}
T(n,k) &= O(nk) \text{ hashing } + O(k \cdot n) \text{ scans }= O(nk),\\
S(n,k) &= O(nk + g).
\end{aligned}
\]
\CORRECTNESS{For the correct boundary offset, the $n$ positions form exactly the true names; membership and distinctness are necessary and sufficient. Hash equality with double mod ensures equality with overwhelming probability.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF 727E — Improved: double rolling hash, precompute IDs, scan offsets
# Includes: read_input(), solve_case(), main guard, and asserts

from typing import List, Tuple, Dict

MOD1 = 1_000_000_007
MOD2 = 1_000_000_009
BASE = 911382323  # < MOD1 and < MOD2

def read_input() -> Tuple[int, int, str, int, List[str]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    S = next(it).strip()
    g = int(next(it))
    names = [next(it).strip() for _ in range(g)]
    return n, k, S, g, names

def build_pow(L: int) -> Tuple[List[int], List[int]]:
    p1 = [1] * (L + 1)
    p2 = [1] * (L + 1)
    for i in range(L):
        p1[i+1] = (p1[i] * BASE) % MOD1
        p2[i+1] = (p2[i] * BASE) % MOD2
    return p1, p2

def build_pref(s: str) -> Tuple[List[int], List[int]]:
    n = len(s)
    h1 = [0] * (n + 1)
    h2 = [0] * (n + 1)
    for i, ch in enumerate(s, 1):
        v = ord(ch) - 96  # 'a'->1..'z'->26
        h1[i] = (h1[i-1] * BASE + v) % MOD1
        h2[i] = (h2[i-1] * BASE + v) % MOD2
    return h1, h2

def get_sub(h1: List[int], h2: List[int], p1: List[int], p2: List[int], l: int, r: int) -> Tuple[int, int]:
    x1 = (h1[r] - (h1[l] * p1[r - l]) % MOD1) % MOD1
    x2 = (h2[r] - (h2[l] * p2[r - l]) % MOD2) % MOD2
    return x1, x2

def hash_word(w: str, p1: List[int], p2: List[int]) -> Tuple[int, int]:
    h1 = 0
    h2 = 0
    for ch in w:
        v = ord(ch) - 96
        h1 = (h1 * BASE + v) % MOD1
        h2 = (h2 * BASE + v) % MOD2
    return h1, h2

def solve_given_hashed(n: int, k: int, S: str, g: int, names: List[str]) -> Tuple[bool, List[int]]:
    m = n * k
    S2 = S + S  # length 2m
    p1, p2 = build_pow(len(S2) + 5)
    H1, H2 = build_pref(S2)
    # Map name-hash -> index
    hmap: Dict[Tuple[int, int], int] = {}
    for idx, w in enumerate(names, 1):
        hmap[hash_word(w, p1, p2)] = idx
    # A[p] = id of chunk S[p:p+k] or -1
    A = [-1] * m
    for p in range(m):
        h = get_sub(H1, H2, p1, p2, p, p + k)
        A[p] = hmap.get(h, -1)
    seen = [0] * (g + 1)
    stamp = 0
    for r in range(k):
        stamp += 1
        order: List[int] = []
        ok = True
        for i in range(n):
            idx = A[r + i * k]
            if idx == -1 or seen[idx] == stamp:
                ok = False
                break
            seen[idx] = stamp
            order.append(idx)
        if ok:
            return True, order
    return False, []

def solve_case() -> None:
    n, k, S, g, names = read_input()
    ok, order = solve_given_hashed(n, k, S, g, names)
    if not ok:
        print("NO")
    else:
        print("YES")
        print(" ".join(map(str, order)))

if __name__ == "__main__":
    # Tiny asserts for the improved version
    ok, order = solve_given_hashed(3, 2, "cdabef", 4, ["ab", "cd", "ef", "gh"])
    assert ok and set(order) == {1, 2, 3} and len(order) == 3
    ok2, order2 = solve_given_hashed(2, 3, "abcdef", 2, ["abc", "abe"])
    assert not ok2
    ok3, order3 = solve_given_hashed(1, 1, "a", 3, ["b", "a", "c"])
    assert ok3 and order3 in ([2],)
\end{minted}
\VALIDATION{Valid case with rotation; impossible case; single-letter case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Same rolling-hash backbone as Approach B, but with a time-stamp array to check distinctness in $O(1)$ without clearing, achieving strict $O(nk)$ time and $O(nk+g)$ memory.}
\ASSUMPTIONS{The polynomial double-hash collision probability is negligible; constraints guarantee $n \cdot k \le 10^6$, so arrays over positions are feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute double hashes of $S+S$ and map candidate hashes to indices.
\item Build array $A[p]$ for $p \in [0, n k - 1]$ giving the candidate index or $-1$.
\item For each offset $r \in [0, k-1]$, scan $p=r+i k$; use a global seen-array with increasing stamp to detect duplicates in $O(1)$ per ID; stop at the first valid $r$.
\end{algosteps}
\OPTIMALITY{Every character of $S$ participates in $O(1)$ hash operations; each position $p$ is processed once to form $A[p]$, and each $A[p]$ is read in exactly one offset-scan. Lower than $O(nk)$ is impossible since the input has $\Theta(nk)$ characters.}
\COMPLEXITY{$T(n,k)=O(nk)$, $S(n,k)=O(nk+g)$.}
\[
\begin{aligned}
T(n,k) &= O(nk) \\
S(n,k) &= O(nk + g)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF 727E — Final reference solution (double rolling hash, O(nk))
# Includes: read_input(), solve_case(), main guard, and exactly 3 asserts

from typing import List, Tuple, Dict

MOD1 = 1_000_000_007
MOD2 = 1_000_000_009
BASE = 911382323

def read_input() -> Tuple[int, int, str, int, List[str]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    S = next(it).strip()
    g = int(next(it))
    names = [next(it).strip() for _ in range(g)]
    return n, k, S, g, names

def build_pow(L: int) -> Tuple[List[int], List[int]]:
    p1 = [1] * (L + 1)
    p2 = [1] * (L + 1)
    for i in range(L):
        p1[i+1] = (p1[i] * BASE) % MOD1
        p2[i+1] = (p2[i] * BASE) % MOD2
    return p1, p2

def build_pref(s: str) -> Tuple[List[int], List[int]]:
    n = len(s)
    h1 = [0] * (n + 1)
    h2 = [0] * (n + 1)
    for i, ch in enumerate(s, 1):
        v = ord(ch) - 96
        h1[i] = (h1[i-1] * BASE + v) % MOD1
        h2[i] = (h2[i-1] * BASE + v) % MOD2
    return h1, h2

def get_sub(h1: List[int], h2: List[int], p1: List[int], p2: List[int], l: int, r: int) -> Tuple[int, int]:
    x1 = (h1[r] - (h1[l] * p1[r - l]) % MOD1) % MOD1
    x2 = (h2[r] - (h2[l] * p2[r - l]) % MOD2) % MOD2
    return x1, x2

def hash_word(w: str) -> Tuple[int, int]:
    h1 = 0
    h2 = 0
    for ch in w:
        v = ord(ch) - 96
        h1 = (h1 * BASE + v) % MOD1
        h2 = (h2 * BASE + v) % MOD2
    return h1, h2

def solve_given(n: int, k: int, S: str, g: int, names: List[str]) -> Tuple[bool, List[int]]:
    m = n * k
    S2 = S + S
    p1, p2 = build_pow(len(S2) + 5)
    H1, H2 = build_pref(S2)
    # Map candidate hash -> index
    hmap: Dict[Tuple[int, int], int] = {}
    for idx, w in enumerate(names, 1):
        hmap[hash_word(w)] = idx
    # Build A[p] for p in [0, m-1]
    A = [-1] * m
    for p in range(m):
        A[p] = hmap.get(get_sub(H1, H2, p1, p2, p, p + k), -1)
    seen = [0] * (g + 1)
    stamp = 0
    for r in range(k):
        stamp += 1
        order: List[int] = []
        ok = True
        for i in range(n):
            idx = A[r + i * k]
            if idx == -1 or seen[idx] == stamp:
                ok = False
                break
            seen[idx] = stamp
            order.append(idx)
        if ok:
            return True, order
    return False, []

def solve_case() -> None:
    n, k, S, g, names = read_input()
    ok, order = solve_given(n, k, S, g, names)
    if not ok:
        print("NO")
    else:
        print("YES")
        print(" ".join(map(str, order)))

if __name__ == "__main__":
    # Exactly 3 asserts (mini-tests)
    ok, order = solve_given(3, 2, "cdabef", 4, ["ab", "cd", "ef", "gh"])
    assert ok and len(order) == 3 and len(set(order)) == 3
    ok2, order2 = solve_given(2, 3, "abcdef", 2, ["abc", "abe"])
    assert not ok2
    ok3, order3 = solve_given(1, 4, "game", 3, ["play", "code", "game"])
    assert ok3 and order3 in ([3],)
\end{minted}
\VALIDATION{Three asserts: a valid rotation, an impossible instance, and a single-name case.}
\RESULT{If solvable, outputs the $n$ indices in the clockwise order starting from a valid boundary; any rotation of the correct order is accepted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test correctness on small crafted cases: valid rotations with different $r$, impossible cases with unknown chunk, and degenerate $n=1$ and $k=1$. Property check: if we reconstruct the concatenation of reported names and rotate, it must match $S$.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline, Improved, and Final on the same tiny instances; they should either all say NO or produce valid YES sequences of distinct indices.}
\LINE{EDGE-CASE GENERATOR}{Generate random sets of $g$ names and random permutations of $n$ of them to build $C$, then cut at random offset; verify solver recovers a valid sequence.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

from typing import List, Tuple
import random

def make_instance(n: int, k: int, g: int, seed: int = 0) -> Tuple[int, int, str, int, List[str]]:
    random.seed(seed)
    alphabet = "abcd"  # keep tiny
    def rand_word():
        return "".join(random.choice(alphabet) for _ in range(k))
    pool = set()
    while len(pool) < g:
        pool.add(rand_word())
    names = list(pool)
    chosen = random.sample(names, n)
    C = "".join(chosen)
    # rotate by random shift in [0, n*k-1]
    shift = random.randrange(0, n * k)
    S = C[shift:] + C[:shift]
    return n, k, S, g, names

# Quick cross-check runner using the final solver
def quick_check():
    from collections import Counter
    for seed in range(20):
        n, k, S, g, names = make_instance(5, 3, 8, seed)
        ok, order = solve_given(n, k, S, g, names)
        assert ok
        # Verify distinctness and membership
        assert len(order) == n and len(set(order)) == n
        # Verify reconstruction matches S up to rotation
        recon = "".join(names[i-1] for i in order)
        doubled = recon + recon
        assert S in doubled

if __name__ == "__main__":
    quick_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution (same as Approach C), ready to submit on CF.

from typing import List, Tuple, Dict
import sys

MOD1 = 1_000_000_007
MOD2 = 1_000_000_009
BASE = 911382323

def read_input() -> Tuple[int, int, str, int, List[str]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    S = next(it).strip()
    g = int(next(it))
    names = [next(it).strip() for _ in range(g)]
    return n, k, S, g, names

def build_pow(L: int):
    p1 = [1] * (L + 1)
    p2 = [1] * (L + 1)
    for i in range(L):
        p1[i+1] = (p1[i] * BASE) % MOD1
        p2[i+1] = (p2[i] * BASE) % MOD2
    return p1, p2

def build_pref(s: str):
    n = len(s)
    h1 = [0] * (n + 1)
    h2 = [0] * (n + 1)
    for i, ch in enumerate(s, 1):
        v = ord(ch) - 96
        h1[i] = (h1[i-1] * BASE + v) % MOD1
        h2[i] = (h2[i-1] * BASE + v) % MOD2
    return h1, h2

def get_sub(h1, h2, p1, p2, l, r):
    x1 = (h1[r] - (h1[l] * p1[r - l]) % MOD1) % MOD1
    x2 = (h2[r] - (h2[l] * p2[r - l]) % MOD2) % MOD2
    return x1, x2

def hash_word(w: str):
    h1 = 0
    h2 = 0
    for ch in w:
        v = ord(ch) - 96
        h1 = (h1 * BASE + v) % MOD1
        h2 = (h2 * BASE + v) % MOD2
    return h1, h2

def solve_given(n: int, k: int, S: str, g: int, names: List[str]):
    m = n * k
    S2 = S + S
    p1, p2 = build_pow(len(S2) + 5)
    H1, H2 = build_pref(S2)
    hmap: Dict[Tuple[int, int], int] = {}
    for idx, w in enumerate(names, 1):
        hmap[hash_word(w)] = idx
    A = [-1] * m
    for p in range(m):
        A[p] = hmap.get(get_sub(H1, H2, p1, p2, p, p + k), -1)
    seen = [0] * (g + 1)
    stamp = 0
    for r in range(k):
        stamp += 1
        order = []
        ok = True
        for i in range(n):
            idx = A[r + i * k]
            if idx == -1 or seen[idx] == stamp:
                ok = False
                break
            seen[idx] = stamp
            order.append(idx)
        if ok:
            return True, order
    return False, []

def solve_case():
    n, k, S, g, names = read_input()
    ok, order = solve_given(n, k, S, g, names)
    if not ok:
        print("NO")
    else:
        print("YES")
        print(" ".join(map(str, order)))

if __name__ == "__main__":
    # Inline sanity asserts
    ok, order = solve_given(3, 2, "cdabef", 4, ["ab", "cd", "ef", "gh"])
    assert ok and len(order) == 3 and len(set(order)) == 3
    ok2, order2 = solve_given(2, 3, "abcdef", 2, ["abc", "abe"])
    assert not ok2
    ok3, order3 = solve_given(1, 1, "a", 2, ["a", "b"])
    assert ok3 and order3 in ([1],)
    # If reading from stdin is desired, uncomment:
    # solve_case()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find a boundary offset modulo $k$ such that $n$ consecutive $k$-chunks form $n$ distinct known names; output their indices in order.}
\WHY{String-cycle reconstruction and modular alignment appear in interviews and contests; hashing and residue-class reasoning are common techniques.}
\CHECKLIST{%
- Map each candidate name to an ID.
- Precompute double hashes for $S+S$.
- Build ID array $A[p]$ for all starting positions.
- For each $r \in [0,k-1]$, scan $A[r+i k]$; ensure all IDs are valid and unique.
- Print YES and the found order; otherwise NO.}
\EDGECASES{%
- $n=1$ (any rotation is the string itself).
- $k=1$ (chunks are characters; requires distinct letters).
- Unknown chunk (immediate NO).
- Duplicate chunk within an offset (invalid; must be distinct).
- All names present but $S$ is not aligned at a boundary ($r \ne 0$ is needed).
- Large $g$ with many unused names (must still ensure uniqueness).}
\PITFALLS{%
- Forgetting to wrap across the end of $S$ (use $S+S$).
- Building $O(k)$-sized substrings repeatedly (use rolling hash).
- Clearing a seen-set per offset with $O(g)$ cost (use time-stamps).
- Off-by-one in hash ranges $[l,r)$.
- Using a single-mod hash with higher collision risk.
- Printing indices not in clockwise order from the chosen boundary.}
\FAILMODES{Naive slicing may time out for large $k$; naive set-clearing per offset may also be slow. The optimal approach touches each position $O(1)$ times and avoids per-offset reinitialization.}
\ELI{Cut the circle at the right place so names line up into $k$-length blocks. Check if all these blocks are in the list and no name repeats. Use hashing to recognize blocks quickly without copying big substrings.}
\NotePages{3}

\end{document}