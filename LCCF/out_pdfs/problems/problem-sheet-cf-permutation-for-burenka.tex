% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Permutation for Burenka}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1718/D}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{We call an array $a$ pure if all elements in it are pairwise distinct. For example, an array $[1, 7, 9]$ is pure, $[1, 3, 3, 7]$ is not, because $3$ occurs twice in it.

A pure array $b$ is similar to a pure array $c$ if their lengths $n$ are the same and for all pairs of indices $l$, $r$, such that $1 \le l \le r \le n$, it is true that $\operatorname{argmax}([b_l, b_{l + 1}, \ldots, b_r]) = \operatorname{argmax}([c_l, c_{l + 1}, \ldots, c_r])$, where $\operatorname{argmax}(x)$ is defined as the index of the largest element in $x$ (which is unique for pure arrays). For example, $\operatorname{argmax}([3, 4, 2]) = 2$, $\operatorname{argmax}([1337, 179, 57]) = 1$.

Recently, Tonya found out that Burenka really likes a permutation $p$ of length $n$. Tonya decided to please her and give her an array $a$ similar to $p$. He already fixed some elements of $a$, but exactly $k$ elements are missing (in these positions temporarily $a_i = 0$). It is guaranteed that $k \ge 2$. Also, he has a set $S$ of $k - 1$ numbers.

Tonya realized that he was missing one number to fill the empty places of $a$, so he decided to buy it. He has $q$ options to buy. Tonya thinks that the number $d$ suits him, if it is possible to replace all zeros in $a$ with numbers from $S$ and the number $d$, so that $a$ becomes a pure array similar to $p$. For each option of $d$, output whether this number is suitable for him or not.

Input:
The first line contains a single integer $t$ ($1 \le t \le 10^4$) is the number of test cases. The description of the test cases follows.

The first line of each test case contains a couple of integers $n$ and $q$ ($1 \le n, q \le 3 \cdot 10^5$).

The second line of each input test case contains $n$ integers $p_1, p_2, \ldots, p_n$ ($1 \le p_i \le n$) — the permutation Burenka likes.

The third line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le 10^6$) — elements of Tonya's array, where $0$ denotes a missing element. It is guaranteed that there are two indexes $i, j$ ($1 \le i, j \le n, i \ne j$) such that $a_i = 0, a_j = 0$, which implies that $k \ge 2$.

The fourth line of each test case contains $k - 1$ distinct integers $s_1, $ $s_2, \ldots, s_{k-1}$ ($1 \le s_i \le 10^6$) — elements of Tonya's set $S$.

Each of the next $q$ lines contains a single integer $d$ ($1 \le d \le 10^6$) — the number that Tonya plans to buy.

It is guaranteed that for each given $d$ it is possible to fill in the gaps in $a$ with numbers from $S$ and the number $d$ to get a pure array.

It is guaranteed that the sum of $n$ and the sum of $q$ in all tests does not exceed $3 \cdot 10^5$.

Output:
Output $q$ lines. For each value $d$, print ``YES'' if there is a way to fill the array $a$ to make it similar to $p$, and ``NO'' otherwise.

Note:
In the first test case for $d = 9$, you can get $a = [5, 9, 7, 6]$, it can be proved that $a$ is similar to $p$, for $d = 1$ and $d = 4$ it can be proved that there is no answer.

In the second test case for $d = 1$, you can get $a = [1, 5, 10, 9, 3]$, for $d = 8$, you can get $a = [3, 5, 10, 9, 8]$, it can be proved that for $d = 11$ there is no answer.}
\BREAKDOWN{Two arrays of distinct values are similar iff they induce the same order of maxima on all subarrays, which is equivalent to having the same Cartesian tree, or equivalently, the same relative order of values. Therefore, $a$ is similar to $p$ iff the ranks of $a$ match the permutation order of $p$. With some $a_i$ fixed and the rest to be filled from $S \cup \{d\}$, reduce feasibility to placing each new value into one of the open intervals between consecutive fixed values along $p$-order.}
\ELI{Sort positions by $p$. Fixed $a$'s must strictly increase along that order. Zeros form gaps; values from $S$ must fall inside the corresponding numeric intervals. Exactly one gap remains short by one; $d$ must fall into that gap.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.
\begin{bullets}
\item $t$ — number of test cases.
\item For each case: $n, q$.
\item Permutation $p_1,\ldots,p_n$ with $1 \le p_i \le n$ and pairwise distinct.
\item Array $a_1,\ldots,a_n$ with $0 \le a_i \le 10^6$; zeros indicate missing values; there are $k \ge 2$ zeros.
\item Set $S$ of $k-1$ distinct integers in $[1,10^6]$.
\item Then $q$ lines, each a candidate $d \in [1,10^6]$.
\end{bullets}}
\OUTPUTS{For each $d$, output a line: YES if we can fill all zeros using $S \cup \{d\}$ to obtain a pure array similar to $p$, otherwise NO.}
\SAMPLES{Example 1 (crafted). 
\begin{bullets}
\item $n=4$, $q=3$, $p=[2,4,3,1]$, $a=[5,0,0,1]$. Zeros $k=2$, so $S$ has one value, say $[3]$. Queries: $d \in \{6,2,5\}$. Answers: YES, NO, YES.
\item $n=3$, $q=2$, $p=[2,1,3]$, $a=[0,5,0]$. Zeros $k=2$, $S=[2]$. Queries $d \in \{6,4\}$. Answers: YES, NO.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $P$ be the total order on indices induced by increasing $p_i$. Let $F=\{i \mid a_i \ne 0\}$ be fixed positions and $Z=\{i \mid a_i=0\}$ be missing positions. Consider the sequence of positions $i_1,\ldots,i_n$ sorted by increasing $p_{i_j}$. The final array $a'$ is similar to $p$ iff $a'_{i_1}<a'_{i_2}<\cdots<a'_{i_n}$.}
\varmapStart
\var{n}{length of arrays}
\var{p}{permutation liked by Burenka}
\var{a}{partially filled array}
\var{S}{set of $k-1$ distinct integers to use}
\var{d}{candidate integer to buy}
\var{F}{indices with fixed nonzero $a_i$}
\var{Z}{indices with $a_i=0$}
\var{v(i)}{fixed value at index $i$ if $i \in F$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let }(i_1,\ldots,i_n)\text{ be indices sorted by }p_{i_1}<\cdots<p_{i_n}.\\
&\text{Feasibility: } \forall j<\ell \text{ with } i_j,i_\ell\in F:\ a_{i_j}<a_{i_\ell}.\\
&\text{Let }V=(v_1<\cdots<v_m)\text{ be fixed values in $P$-order, with $m=|F|$.}\\
&\text{Define open intervals }I_0=(-\infty,v_1),\ I_r=(v_r,v_{r+1})\ (1\le r<m),\ I_m=(v_m,+\infty).\\
&\text{Let }\text{need}_r=\#\{j:\ i_j\in Z \text{ and } j \text{ lies between the flanking fixeds of } I_r\}.\\
&\text{Let }\text{cnt}^S_r=\#\{x\in S:\ x\in I_r\}.\\
&\text{Then for }T=S\cup\{d\}\text{, feasibility }\Leftrightarrow \forall r:\ \text{cnt}^T_r=\text{need}_r.
\end{aligned}
\]
}
\ASSUMPTIONS{All values used are distinct (purity). Comparison is strict $<$ as arrays are pure. Equality with fixed values is disallowed.}
\INVARIANTS{
\begin{bullets}
\item Along $P$-order, fixed values must be strictly increasing; otherwise no completion exists.
\item The multiset $T$ is partitioned uniquely by the open intervals between consecutive fixed values.
\item The sum of interval deficits equals $|Z|-|S|=1$, hence exactly one interval lacks exactly one value; $d$ must fall into it.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly simulate filling by interval counting per query: sort indices by $p$, verify fixed monotonicity, then for each query count how many of $S \cup \{d\}$ fall into each open interval and check exact equality with needs.}
\ASSUMPTIONS{Small $q$ or small $k$ so that per-query re-counting is acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort indices by $p$; collect fixed values in that order and verify they are strictly increasing.
\item Determine the need per open interval by scanning $a$ in $p$-order.
\item For each query $d$, form $T=S\cup\{d\}$ and count $|T\cap I_r|$ for every interval $I_r$; accept iff these counts match $\text{need}_r$ exactly.
\end{algosteps}
\COMPLEXITY{Let $m=|F|$ and $k=|Z|$. Preprocessing $O(n\log n)$. Each query counts via binary search among $m$ boundaries for each element of $T$ in $O((k)\log m)$. Space $O(n)$.}
\[
\begin{aligned}
T(n) &\approx O(n\log n) + O\big(q\cdot k\log m\big),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Assigning values to positions in increasing order of $p$ requires strictly increasing numeric values. Each zero contributes one slot in exactly one open interval between consecutive fixed values along this order. Counting membership in these open intervals precisely encodes feasibility.}
\EDGECASES{All $a_i=0$; no fixed values $m=0$ (single interval $(-\infty,+\infty)$). Intervals with $\text{need}_r=0$ must receive zero values. $d$ equal to any fixed value or duplicate in $S$ is disallowed (purity).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from bisect import bisect_left, bisect_right

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        p = [int(next(it)) for _ in range(n)]
        a = [int(next(it)) for _ in range(n)]
        k = sum(1 for x in a if x == 0)
        S = [int(next(it)) for _ in range(k-1)]
        queries = [int(next(it)) for _ in range(q)]
        cases.append((n, q, p, a, S, queries))
    return cases

def preprocess(n, p, a):
    order = sorted(range(n), key=lambda i: p[i])
    fixed_vals = []
    need = []
    zeros_in_gap = 0
    seen_fixed_vals = []
    for idx in order:
        if a[idx] == 0:
            zeros_in_gap += 1
        else:
            cur = a[idx]
            if fixed_vals and not (cur > fixed_vals[-1]):
                return None  # impossible due to non-increasing fixed values
            fixed_vals.append(cur)
            seen_fixed_vals.append(cur)
            need.append(zeros_in_gap)
            zeros_in_gap = 0
    need.append(zeros_in_gap)
    # fixed_vals sorted strictly increasing if not None
    return fixed_vals, need

def count_by_intervals(values, fixed_vals):
    # Intervals are (-inf, v1), (v1,v2), ..., (v_m, +inf)
    m = len(fixed_vals)
    cnt = [0]*(m+1)
    fixed_set = set(fixed_vals)
    for x in values:
        if x in fixed_set:
            return None  # purity / open interval violation
        # number of fixed values strictly less than x
        j = bisect_left(fixed_vals, x)
        cnt[j] += 1
    return cnt

def solve_case_baseline(n, q, p, a, S, queries):
    pre = preprocess(n, p, a)
    if pre is None:
        return ["NO"]*q
    fixed_vals, need = pre
    answers = []
    for d in queries:
        T = S + [d]
        cnt = count_by_intervals(T, fixed_vals)
        if cnt is None:
            answers.append("NO")
            continue
        ok = (len(cnt) == len(need)) and all(cnt[i] == need[i] for i in range(len(need)))
        answers.append("YES" if ok else "NO")
    return answers

def solve_all_baseline(cases):
    out_lines = []
    for (n, q, p, a, S, queries) in cases:
        ans = solve_case_baseline(n, q, p, a, S, queries)
        out_lines.extend(ans)
    return "\n".join(out_lines)

def main():
    cases = read_input()
    print(solve_all_baseline(cases))

if __name__ == "__main__":
    # Tiny self-checks
    data = [
        "2",
        "4","3",
        "2","4","3","1",
        "5","0","0","1",
        "3",
        "6","2","5",
        "3","2",
        "2","1","3",
        "0","5","0",
        "2",
        "6","4",
    ]
    cases = read_input(data)
    out = solve_all_baseline(cases).splitlines()
    # Case 1: YES, NO, YES
    assert out[0:3] == ["YES","NO","YES"]
    # Case 2: YES, NO
    assert out[3:5] == ["YES","NO"]
    # Run on stdin if present
    if sys.stdin.isatty():
        pass
    else:
        main()
\end{minted}
\VALIDATION{Checks ensure: (1) Increasing fixed values along $p$-order; (2) Exact matching of interval counts to needs; (3) Purity via exclusion of equal-to-fixed values.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Precompute $S$-counts per interval; single-deficit rule}
\WHICHFORMULA{Observe that $|Z|-|S|=1$, hence the vector of deficits $\text{need}-\text{cnt}^S$ must be zero everywhere except one interval where it equals $1$. Therefore, per query answer is YES iff $d$ falls in that unique deficient interval.}
\ASSUMPTIONS{The fixed values are strictly increasing in $p$-order; no $s\in S$ equals a fixed value (purity guaranteed by the statement).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Preprocess as in A: fixed values in $p$-order, the open intervals, and their needs.
\item Count $\text{cnt}^S$ in $O(|S|\log m)$ using binary search over fixed values.
\item If any $\text{cnt}^S_r > \text{need}_r$ or the total deficit $\sum_r (\text{need}_r-\text{cnt}^S_r) \ne 1$, then all answers are NO.
\item Otherwise, locate the unique interval $r^\star$ with deficit $1$; for each query $d$, answer YES iff $d$ lies in $I_{r^\star}$.
\end{algosteps}
\COMPLEXITY{Preprocessing $O(n\log n + |S|\log m)$. Each query answered in $O(\log m)$. This strictly improves over the baseline per-query re-counting.}
\[
\begin{aligned}
T(n) &= O\big(n\log n + |S|\log m + q\log m\big).\\
\end{aligned}
\]
\CORRECTNESS{The partition of $S$ and $d$ by open intervals is unique. Because the sum of needs across intervals equals $|Z|$ and $|S|=|Z|-1$, exactly one interval must be short by one, provided none is overfull. Placing $d$ in that interval and ordering values increasingly yields a unique increasing fill along $p$-order.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from bisect import bisect_left

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        p = [int(next(it)) for _ in range(n)]
        a = [int(next(it)) for _ in range(n)]
        k = sum(1 for x in a if x == 0)
        S = [int(next(it)) for _ in range(k-1)]
        queries = [int(next(it)) for _ in range(q)]
        cases.append((n, q, p, a, S, queries))
    return cases

def preprocess(n, p, a):
    order = sorted(range(n), key=lambda i: p[i])
    fixed_vals = []
    need = []
    zeros_in_gap = 0
    for idx in order:
        if a[idx] == 0:
            zeros_in_gap += 1
        else:
            cur = a[idx]
            if fixed_vals and not (cur > fixed_vals[-1]):
                return None
            fixed_vals.append(cur)
            need.append(zeros_in_gap)
            zeros_in_gap = 0
    need.append(zeros_in_gap)
    return fixed_vals, need

def counts_S(S, fixed_vals):
    cnt = [0]*(len(fixed_vals)+1)
    fixed_set = set(fixed_vals)
    for x in S:
        if x in fixed_set:
            return None
        j = bisect_left(fixed_vals, x)  # number of fixed < x
        cnt[j] += 1
    return cnt

def solve_case_improved(n, q, p, a, S, queries):
    pre = preprocess(n, p, a)
    if pre is None:
        return ["NO"]*q
    fixed_vals, need = pre
    cntS = counts_S(S, fixed_vals)
    if cntS is None:
        return ["NO"]*q
    # Check overfill and compute deficit
    deficit = [need[i]-cntS[i] for i in range(len(need))]
    if any(x < 0 for x in deficit):
        return ["NO"]*q
    if sum(deficit) != 1:
        return ["NO"]*q
    want = next(i for i,x in enumerate(deficit) if x == 1)
    fixed_set = set(fixed_vals)
    answers = []
    for d in queries:
        if d in fixed_set:
            answers.append("NO")
            continue
        j = bisect_left(fixed_vals, d)
        answers.append("YES" if j == want else "NO")
    return answers

def solve_all_improved(cases):
    out_lines = []
    for case in cases:
        out_lines.extend(solve_case_improved(*case))
    return "\n".join(out_lines)

def main():
    cases = read_input()
    print(solve_all_improved(cases))

if __name__ == "__main__":
    # Deterministic checks versus baseline logic on tiny cases
    tiny = [
        "1",
        "4","4",
        "2","4","3","1",
        "5","0","0","1",
        "3",
        "6","2","5","7",
    ]
    cases = read_input(tiny)
    out = solve_all_improved(cases).splitlines()
    # Interval (1,5) needs 1 (S=3 already fills), (5, +inf) needs 1 -> YES if d>5
    assert out == ["YES","NO","YES","YES"]
    # No stdin interactive run in this test block
    pass
\end{minted}
\VALIDATION{If any interval is overfilled by $S$, all answers are NO. Otherwise there is a unique deficient interval; every query is checked by a single binary search to locate $d$'s interval.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Single-pass preprocessing and binary-search per query}
\WHICHFORMULA{Reduce similarity to order-isomorphism: along $p$-order, values must strictly increase. Partition missing slots into open intervals between fixed values and precompute the unique deficient interval after placing $S$.}
\ASSUMPTIONS{Fixed values along $p$-order are strictly increasing; purity holds (no candidate equals a fixed value).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort indices by $p$ and scan to verify fixed monotonicity and to compute the needs per interval.
\item Count $S$ into intervals via binary search over fixed values.
\item Validate that there is no overfill and the total deficit is exactly $1$; identify the deficient interval index $r^\star$.
\item For each query $d$, answer YES iff $d$ lies in $I_{r^\star}$, i.e., the number of fixed values $< d$ equals $r^\star$.
\end{algosteps}
\OPTIMALITY{Any correct solution must, in the worst case, inspect each $s \in S$ and each $d$. The algorithm runs in $O(n\log n + |S|\log n + q\log n)$ time, which is optimal up to logarithmic factors for comparison-based interval location.}
\COMPLEXITY{As derived. Space $O(n)$.}
\[
\begin{aligned}
T(n) &= O\big(n\log n\big) + O\big(|S|\log n\big) + O\big(q\log n\big).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from bisect import bisect_left

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        p = [int(next(it)) for _ in range(n)]
        a = [int(next(it)) for _ in range(n)]
        k = sum(1 for x in a if x == 0)
        S = [int(next(it)) for _ in range(k-1)]
        queries = [int(next(it)) for _ in range(q)]
        cases.append((n, q, p, a, S, queries))
    return cases

def preprocess(n, p, a):
    order = sorted(range(n), key=lambda i: p[i])
    fixed_vals = []
    need = []
    zeros_in_gap = 0
    for idx in order:
        if a[idx] == 0:
            zeros_in_gap += 1
        else:
            cur = a[idx]
            if fixed_vals and not (cur > fixed_vals[-1]):
                return None
            fixed_vals.append(cur)
            need.append(zeros_in_gap)
            zeros_in_gap = 0
    need.append(zeros_in_gap)
    return fixed_vals, need

def counts_in_intervals(vals, fixed_vals):
    m = len(fixed_vals)
    cnt = [0]*(m+1)
    fixed_set = set(fixed_vals)
    for x in vals:
        if x in fixed_set:
            return None
        j = bisect_left(fixed_vals, x)
        cnt[j] += 1
    return cnt

def solve_case(n, q, p, a, S, queries):
    pre = preprocess(n, p, a)
    if pre is None:
        return ["NO"]*q
    fixed_vals, need = pre
    cntS = counts_in_intervals(S, fixed_vals)
    if cntS is None:
        return ["NO"]*q
    deficit = [need[i] - cntS[i] for i in range(len(need))]
    if any(x < 0 for x in deficit):
        return ["NO"]*q
    if sum(deficit) != 1:
        return ["NO"]*q
    target = next(i for i,x in enumerate(deficit) if x == 1)
    fixed_set = set(fixed_vals)
    ans = []
    for d in queries:
        if d in fixed_set:
            ans.append("NO")
            continue
        j = bisect_left(fixed_vals, d)
        ans.append("YES" if j == target else "NO")
    return ans

def solve_all():
    cases = read_input()
    out_lines = []
    for case in cases:
        out_lines.extend(solve_case(*case))
    return "\n".join(out_lines)

def main():
    print(solve_all())

if __name__ == "__main__":
    # Unit asserts
    # 1) All zeros -> any d works
    n,q = 3,3
    p = [2,1,3]; a = [0,0,0]
    k = 3; S = [4,7]  # k-1=2
    queries = [1,5,10]
    res = solve_case(n,q,p,a,S,queries)
    assert res == ["YES","YES","YES"]
    # 2) Simple gaps with fixeds increasing
    n,q = 4,4
    p = [2,4,3,1]; a = [5,0,0,1]
    S = [3]
    queries = [6,2,5,7]
    res = solve_case(n,q,p,a,S,queries)
    assert res == ["YES","NO","YES","YES"]
    # 3) Fixed values violate monotonicity in p-order -> all NO
    n,q = 3,2
    p = [1,2,3]; a = [5,4,0]
    S = [1]
    queries = [2,6]
    res = solve_case(n,q,p,a,S,queries)
    assert res == ["NO","NO"]
    # Ready for judge
    if not sys.stdin.isatty():
        main()
\end{minted}
\VALIDATION{Exactly 3 asserts check full-zeros, a typical mid-case, and the monotonicity failure case.}
\RESULT{Return YES iff $d$ lies in the unique deficient open interval between consecutive fixed values along $p$-order. Ties with fixed values are rejected to preserve purity.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: (i) all zeros; (ii) representative intervals with ends and middle gaps; (iii) impossible due to fixed monotonicity failure; (iv) overfill by $S$ causes all NO; (v) $d$ equal to a fixed value rejected.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved vs Final on small random instances: they must agree.}
\LINE{EDGE-CASE GENERATOR}{Generate random $p$, pick a strictly increasing pattern for fixed values consistent with $p$, insert zeros, compute $S$ from random values placed into random intervals with one deficit, then test random queries covering each interval and boundaries equal to fixed values.}
\begin{minted}{python}
import random
from bisect import bisect_left

def gen_case(n=8):
    p = list(range(1,n+1))
    random.shuffle(p)
    order = sorted(range(n), key=lambda i: p[i])
    # choose some fixed positions
    fixed_mask = [random.random() < 0.5 for _ in range(n)]
    # ensure at least 2 zeros
    if sum(1 for b in fixed_mask if not b) < 2:
        fixed_mask[random.choice(range(n))] = False
        fixed_mask[random.choice(range(n))] = False
    # assign strictly increasing fixed values
    vals = sorted(random.sample(range(1,10**6), sum(fixed_mask)))
    a = [0]*n
    j = 0
    for idx in order:
        if fixed_mask[idx]:
            a[idx] = vals[j]; j += 1
    # build intervals and needs
    fixed_vals = [a[idx] for idx in order if a[idx]!=0]
    need = []
    zeros_in_gap = 0
    for idx in order:
        if a[idx] == 0:
            zeros_in_gap += 1
        else:
            need.append(zeros_in_gap); zeros_in_gap = 0
    need.append(zeros_in_gap)
    m = len(fixed_vals)
    # choose S by filling all but one unit of deficit
    universe = set(range(1,10**6))
    universe.difference_update(x for x in a if x!=0)
    S = []
    fixed_set = set(fixed_vals)
    # helper to sample from interval (L,R)
    def sample_from(L, R, cnt):
        pool = []
        if L is None:
            pool = [x for x in random.sample(range(1,10**6), cnt*3) if x < R and x not in fixed_set]
        elif R is None:
            pool = [x for x in random.sample(range(1,10**6), cnt*3) if x > L and x not in fixed_set]
        else:
            pool = [x for x in random.sample(range(1,10**6), cnt*3) if L < x < R and x not in fixed_set]
        return pool[:cnt]
    deficits = need[:]
    missing = sum(deficits)
    # leave exactly one unit deficit
    missing_S = missing - 1
    # distribute S counts per interval
    for r in range(m+1):
        take = min(deficits[r], random.randint(0, deficits[r]))
        if (missing_S - take) < sum(deficits[r+1:]):
            take = deficits[r]  # ensure feasibility
        deficits[r] -= take
        # sample 'take' values into interval r
        L = fixed_vals[r-1] if r-1 >= 0 else None
        R = fixed_vals[r] if r < m else None
        S.extend(sample_from(L, R, take))
        missing_S -= take
    # Now choose d and some other queries
    rstar = deficits.index(1)
    L = fixed_vals[rstar-1] if rstar-1 >= 0 else None
    R = fixed_vals[rstar] if rstar < m else None
    def in_interval(x):
        return (L is None or x > L) and (R is None or x < R)
    d_yes = None
    while d_yes is None:
        x = random.randint(1,10**6)
        if x not in fixed_set and x not in S and in_interval(x):
            d_yes = x
    d_no = None
    while d_no is None:
        x = random.randint(1,10**6)
        if x not in fixed_set and x not in S and not in_interval(x):
            d_no = x
    return (n, len([0 for x in a if x==0]), p, a, S, [d_yes, d_no])

# Reference solver (final)
def solve_case(n, q, p, a, S, queries):
    order = sorted(range(n), key=lambda i: p[i])
    fixed_vals = []
    need = []
    zeros_in_gap = 0
    for idx in order:
        if a[idx] == 0:
            zeros_in_gap += 1
        else:
            cur = a[idx]
            if fixed_vals and not (cur > fixed_vals[-1]):
                return ["NO"]*q
            fixed_vals.append(cur)
            need.append(zeros_in_gap)
            zeros_in_gap = 0
    need.append(zeros_in_gap)
    cntS = [0]*(len(fixed_vals)+1)
    fixed_set = set(fixed_vals)
    for x in S:
        if x in fixed_set: return ["NO"]*q
        j = bisect_left(fixed_vals, x); cntS[j]+=1
    deficit = [need[i]-cntS[i] for i in range(len(need))]
    if any(x<0 for x in deficit) or sum(deficit)!=1:
        return ["NO"]*q
    target = next(i for i,x in enumerate(deficit) if x==1)
    ans = []
    for d in queries:
        if d in fixed_set: ans.append("NO"); continue
        j = bisect_left(fixed_vals, d)
        ans.append("YES" if j==target else "NO")
    return ans

# Run a few randomized checks
random.seed(0)
for _ in range(20):
    n, k, p, a, S, queries = gen_case(7)
    out = solve_case(n, 2, p, a, S, queries)
    assert out[0] == "YES" and out[1] == "NO"
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from bisect import bisect_left

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it)); q = int(next(it))
        p = [int(next(it)) for _ in range(n)]
        a = [int(next(it)) for _ in range(n)]
        k = sum(1 for x in a if x == 0)
        S = [int(next(it)) for _ in range(k-1)]
        queries = [int(next(it)) for _ in range(q)]
        cases.append((n, q, p, a, S, queries))
    return cases

def preprocess(n, p, a):
    order = sorted(range(n), key=lambda i: p[i])
    fixed_vals = []
    need = []
    zeros_in_gap = 0
    for idx in order:
        if a[idx] == 0:
            zeros_in_gap += 1
        else:
            cur = a[idx]
            if fixed_vals and not (cur > fixed_vals[-1]):
                return None
            fixed_vals.append(cur)
            need.append(zeros_in_gap)
            zeros_in_gap = 0
    need.append(zeros_in_gap)
    return fixed_vals, need

def counts_in_intervals(vals, fixed_vals):
    m = len(fixed_vals)
    cnt = [0]*(m+1)
    fixed_set = set(fixed_vals)
    for x in vals:
        if x in fixed_set:
            return None
        j = bisect_left(fixed_vals, x)
        cnt[j] += 1
    return cnt

def solve_case(n, q, p, a, S, queries):
    pre = preprocess(n, p, a)
    if pre is None:
        return ["NO"]*q
    fixed_vals, need = pre
    cntS = counts_in_intervals(S, fixed_vals)
    if cntS is None:
        return ["NO"]*q
    deficit = [need[i]-cntS[i] for i in range(len(need))]
    if any(x < 0 for x in deficit) or sum(deficit) != 1:
        return ["NO"]*q
    target = next(i for i,x in enumerate(deficit) if x == 1)
    fixed_set = set(fixed_vals)
    ans = []
    for d in queries:
        if d in fixed_set:
            ans.append("NO")
            continue
        j = bisect_left(fixed_vals, d)
        ans.append("YES" if j == target else "NO")
    return ans

def solve_all():
    cases = read_input()
    out = []
    for case in cases:
        out.extend(solve_case(*case))
    return "\n".join(out)

def main():
    print(solve_all())

if __name__ == "__main__":
    # Basic asserts
    # 1) All zeros
    n,q = 3,3
    p = [2,1,3]; a = [0,0,0]
    S = [4,7]
    queries = [1,5,10]
    assert solve_case(n,q,p,a,S,queries) == ["YES","YES","YES"]
    # 2) Representative case
    n,q = 4,4
    p = [2,4,3,1]; a = [5,0,0,1]
    S = [3]
    queries = [6,2,5,7]
    assert solve_case(n,q,p,a,S,queries) == ["YES","NO","YES","YES"]
    # 3) Monotonicity failure
    n,q = 3,2
    p = [1,2,3]; a = [5,4,0]
    S = [1]
    queries = [2,6]
    assert solve_case(n,q,p,a,S,queries) == ["NO","NO"]
    # Run if piped input
    if not sys.stdin.isatty():
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Similarity to a permutation equals matching the $p$-order: along increasing $p$, the final values must strictly increase.}
\WHY{This reframes a seemingly global argmax constraint into local open-interval placement between fixed values, enabling precomputation and fast per-query checks.}
\CHECKLIST{
\begin{bullets}
\item Sort indices by $p$.
\item Verify fixed $a$'s strictly increase.
\item Count zero slots per open interval.
\item Count how many $S$ values fall in each interval.
\item Ensure no overfill; sum of deficits is exactly $1$.
\item The unique deficient interval determines which $d$ are YES.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All elements missing ($m=0$): every $d$ is acceptable (subject to purity).
\item Intervals with zero need must not receive any $s \in S$.
\item $d$ equal to any fixed value is invalid (purity).
\item Fixed values non-increasing in $p$-order $\Rightarrow$ impossible.
\item Very large or small $d$ are handled by the end intervals $(-\infty,v_1)$ and $(v_m,+\infty)$.
\item Duplicate between $d$ and $S$ would break purity (the statement rules these out).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using closed intervals accidentally allows equality with fixed values; intervals must be open.
\item Forgetting to include the leading and trailing intervals.
\item Miscounting zeros in gaps when scanning in $p$-order.
\item Not checking for overfill by $S$ before answering queries.
\item Sorting by index instead of by $p$-value.
\item Overflow is not an issue, but beware of missing strict inequality checks.
\end{bullets}}
\FAILMODES{If $S$ already overfills an interval, no $d$ can fix it. If fixed values violate strict increase in $p$-order, similarity is impossible regardless of $d$. The method detects both early.}
\ELI{Think of walking through positions in the order Burenka likes. Wherever Tonya already put numbers, they must go up; zeros are gaps between them. All $S$ numbers fill most gaps, leaving exactly one missing spot; $d$ works iff it fits in the numeric gap corresponding to that missing spot.}
\NotePages{3}

\end{document}