% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find Mode in Binary Search Tree}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-mode-in-binary-search-tree/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given the \texttt{root} of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. See \url{https://en.wikipedia.org/wiki/Mode_(statistics)} for the definition of mode.

If the tree has more than one mode, return them in any order.

Assume a BST is defined as follows:
\begin{itemize}
\item The left subtree of a node contains only nodes with keys less than or equal to the node's key.
\item The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
\item Both the left and right subtrees must also be binary search trees.
\end{itemize}

Examples:

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{root = [1,null,2,2]}

\quad \textbf{Output:} \texttt{[2]}

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{root = [0]}

\quad \textbf{Output:} \texttt{[0]}

Constraints:
\begin{itemize}
\item The number of nodes in the tree is in the range $[1, 10^4]$.
\item $-10^5 \le \texttt{Node.val} \le 10^5$.
\end{itemize}

Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).}
\BREAKDOWN{Compute the frequency of each value appearing in the BST and return all values attaining the maximum frequency. Use BST in-order traversal to see equal values contiguously. Optimize space by using in-order counting and optionally Morris traversal to avoid recursion/stack.}
\ELI{Walk the BST in sorted order, count runs of equal numbers, and keep those with the biggest run length.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A binary tree root pointer \texttt{root} representing a BST that may contain duplicate values. Each node has fields \texttt{val}, \texttt{left}, \texttt{right}. The tree has $1 \le n \le 10^4$ nodes and values in $[-10^5, 10^5]$.}
\OUTPUTS{A list of integers containing all modes (values with maximum frequency) in any order. If there is a single mode, return a singleton list.}
\SAMPLES{
Example 1: \texttt{root = [1,null,2,2]} $\to$ \texttt{[2]}.

Example 2: \texttt{root = [0]} $\to$ \texttt{[0]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T$ be a BST (as a binary tree with the BST ordering property). Let $M$ be the multiset of node values in $T$. Define the frequency function $f(x) = \lvert\{v \in M : v = x\}\rvert$. We seek the set $\{x : f(x) = \max_{y} f(y)\}$.}
\varmapStart
\var{T}{input BST}
\var{M}{multiset of node values extracted from $T$}
\var{f(x)}{frequency of value $x$ in $M$}
\var{\text{mode}}{any value attaining $\max_{y} f(y)$}
\varmapEnd
\GOVERN{
\[
\text{Modes}(T) = \left\{x \;\middle|\; f(x) = \max_{y} f(y)\right\},
\quad f(x) = \sum_{v \in M} \mathbf{1}[v = x].
\]
}
\ASSUMPTIONS{BST permits duplicates, with duplicates allowed in either left or right per the specified $\le$/$\ge$ rules. Tree size $n \ge 1$.}
\INVARIANTS{
\begin{itemize}
\item In-order traversal of a BST visits values in nondecreasing order, so equal values appear contiguously.
\item The count of a run of equal values equals their frequency in $M$.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Count frequencies with a hash map by traversing all nodes; then select keys with the maximum count.}
\ASSUMPTIONS{Use any tree traversal (DFS/BFS). Extra space $O(k)$ for up to $k$ distinct values.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Traverse all nodes and accumulate counts in a dictionary keyed by \texttt{val}.
\item Compute $c_{\max} = \max$ of all counts.
\item Return all keys whose count equals $c_{\max}$.
\end{algosteps}
\COMPLEXITY{Let $n$ be the number of nodes and $k$ the number of distinct values.}
\[
\begin{aligned}
T(n) &= O(n) \text{ to traverse and count } + O(k) \text{ to scan counts} = O(n),\\
S(n) &= O(k) \text{ for the dictionary (worst } O(n)\text{)}.
\end{aligned}
\]
\CORRECTNESS{Every node contributes exactly one to the frequency of its value, so the dictionary computes $f(x)$ for each value $x$. Taking the argmax set yields exactly all modes.}
\EDGECASES{Single node; all values identical; all values distinct; negative values; highly skewed trees.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import Optional, List, Dict, Any, Tuple

class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    # LC signature
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        if root is None:
            return []
        # Count with a dictionary
        counts: Dict[int, int] = {}
        stack: List[TreeNode] = [root]
        while stack:
            node = stack.pop()
            counts[node.val] = counts.get(node.val, 0) + 1
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        maxc = max(counts.values())
        return [v for v, c in counts.items() if c == maxc]

# --- Tests (deterministic) ---
def build_tree_example1() -> TreeNode:
    # [1, null, 2, 2] means:
    #     1
    #      \
    #       2
    #      /
    #     2
    root = TreeNode(1)
    root.right = TreeNode(2)
    root.right.left = TreeNode(2)
    return root

def build_tree_single(val: int = 0) -> TreeNode:
    return TreeNode(val)

if __name__ == "__main__":
    sol = Solution()
    root1 = build_tree_example1()
    ans1 = sorted(sol.findMode(root1))
    assert ans1 == [2]
    root2 = build_tree_single(0)
    ans2 = sorted(sol.findMode(root2))
    assert ans2 == [0]
    # Additional: all distinct -> all are modes
    root3 = TreeNode(2, TreeNode(1), TreeNode(3))
    ans3 = sorted(sol.findMode(root3))
    assert ans3 == [1, 2, 3]
\end{minted}
\VALIDATION{Verified on examples and a distinct-values case. Dictionary counts match expected modes.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized In-Order Counting (No Value Map)}
\WHICHFORMULA{Exploit BST in-order traversal to see equal values contiguously; maintain a running count for the current value, a global max, and collect modes on the fly.}
\ASSUMPTIONS{Recursive in-order traversal uses implicit stack space $O(h)$ where $h$ is tree height; no explicit hash map of values.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain variables: \texttt{prev\_val}, \texttt{count}, \texttt{max\_count}, and a list \texttt{modes}.
\item In-order traverse: when visiting a node with value $v$, if $v = \texttt{prev\_val}$ increment \texttt{count}, else reset \texttt{count} to $1$ and set \texttt{prev\_val} to $v$.
\item If \texttt{count} $>$ \texttt{max\_count}, reset \texttt{modes} to $[v]$ and update \texttt{max\_count}; if equal, append $v$.
\end{algosteps}
\COMPLEXITY{Still linear time, but avoids storing all distinct values.}
\[
\begin{aligned}
T(n) &= O(n) \text{ single in-order traversal},\\
S(n) &= O(h) \text{ recursion stack only}.
\end{aligned}
\]
\CORRECTNESS{In-order yields nondecreasing values; hence equal values appear in a single consecutive run whose length equals their frequency. The running counter identifies modes exactly.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import Optional, List

class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    # LC signature
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        if root is None:
            return []
        prev_val: Optional[int] = None
        count = 0
        max_count = 0
        modes: List[int] = []

        def handle(val: int) -> None:
            nonlocal prev_val, count, max_count, modes
            if prev_val is None or val != prev_val:
                prev_val = val
                count = 1
            else:
                count += 1
            if count > max_count:
                max_count = count
                modes = [val]
            elif count == max_count:
                modes.append(val)

        def inorder(node: Optional[TreeNode]) -> None:
            if not node:
                return
            inorder(node.left)
            handle(node.val)
            inorder(node.right)

        inorder(root)
        return modes

# --- Tests (deterministic) ---
def build_tree_example1() -> TreeNode:
    root = TreeNode(1)
    root.right = TreeNode(2)
    root.right.left = TreeNode(2)
    return root

if __name__ == "__main__":
    sol = Solution()
    root1 = build_tree_example1()
    assert sorted(sol.findMode(root1)) == [2]
    root2 = TreeNode(0)
    assert sorted(sol.findMode(root2)) == [0]
    # Mixed frequencies
    #       2
    #      / \
    #     1   3
    #          \
    #           3
    r = TreeNode(2, TreeNode(1), TreeNode(3, None, TreeNode(3)))
    assert sorted(sol.findMode(r)) == [3]
\end{minted}
\VALIDATION{Checked example inputs and a skewed case with a unique mode.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Morris In-Order Traversal (O(1) Extra Space)}
\WHICHFORMULA{Use Morris traversal to perform in-order without recursion or an explicit stack; maintain the same run-length counting to find modes in one pass.}
\ASSUMPTIONS{Tree structure may be threaded temporarily; all threads are restored, leaving the tree intact. Values fit in standard integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{prev\_val}, \texttt{count}, \texttt{max\_count}, and \texttt{modes}.
\item Iterate with Morris in-order: for each node, either visit directly if no left child, or create a temporary thread from its inorder predecessor and move left; when returning via the thread, remove it and visit.
\item On each visit, update run-length counters and maintain modes as in Approach B.
\end{algosteps}
\OPTIMALITY{Time $O(n)$ with exactly $2n$ pointer rewirings in the worst case; extra space $O(1)$ beyond the output. This meets the follow-up requirement.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= O(n) \text{ visits with at most two touches per edge},\\
S(n) &= O(1) \text{ auxiliary (output excluded)}.
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import Optional, List

class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    # LC signature
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        if root is None:
            return []
        prev_val: Optional[int] = None
        count = 0
        max_count = 0
        modes: List[int] = []

        def handle(val: int) -> None:
            nonlocal prev_val, count, max_count, modes
            if prev_val is None or val != prev_val:
                prev_val = val
                count = 1
            else:
                count += 1
            if count > max_count:
                max_count = count
                modes = [val]
            elif count == max_count:
                modes.append(val)

        node = root
        while node:
            if node.left is None:
                handle(node.val)
                node = node.right
            else:
                # Find inorder predecessor
                pred = node.left
                while pred.right is not None and pred.right is not node:
                    pred = pred.right
                if pred.right is None:
                    # Thread and go left
                    pred.right = node
                    node = node.left
                else:
                    # Remove thread and visit node
                    pred.right = None
                    handle(node.val)
                    node = node.right
        return modes

# --- Tests (exactly 3 asserts or I/O mini-tests) ---
if __name__ == "__main__":
    # Example 1: [1,null,2,2] -> [2]
    r1 = TreeNode(1)
    r1.right = TreeNode(2)
    r1.right.left = TreeNode(2)
    assert sorted(Solution().findMode(r1)) == [2]

    # Example 2: [0] -> [0]
    r2 = TreeNode(0)
    assert sorted(Solution().findMode(r2)) == [0]

    # Case with multiple modes: values [1,1,2,2,3] -> modes [1,2]
    # Construct BST:
    #       2
    #      / \
    #     1   3
    #      \
    #       1
    #        \
    #         2
    a = TreeNode(2)
    a.left = TreeNode(1, None, TreeNode(1, None, TreeNode(2)))
    a.right = TreeNode(3)
    assert sorted(Solution().findMode(a)) == [1, 2]
\end{minted}
\VALIDATION{Three asserts: both examples and a case with two modes.}
\RESULT{Return all values achieving the maximum frequency; order is arbitrary.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test on: single-node, all-equal, all-distinct, two modes, skewed trees, and random BSTs built by successive inserts. Compare results across approaches.}
\LINE{CROSS-CHECKS}{On small trees ($n \le 10$), validate that Baseline (map) and Improved (in-order) and Optimal (Morris) yield identical sorted outputs.}
\LINE{EDGE-CASE GENERATOR}{Deterministically generate degenerate chains, balanced trees from sorted arrays with controlled duplicates, and adversarial patterns (e.g., long runs at start/end).}
\begin{minted}{python}
from typing import Optional, List, Iterable
import random

class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

def bst_insert(root: Optional[TreeNode], val: int) -> TreeNode:
    if root is None:
        return TreeNode(val)
    cur = root
    while True:
        if val <= cur.val:
            if cur.left is None:
                cur.left = TreeNode(val)
                break
            cur = cur.left
        else:
            if cur.right is None:
                cur.right = TreeNode(val)
                break
            cur = cur.right
    return root

def build_bst(values: Iterable[int]) -> Optional[TreeNode]:
    root: Optional[TreeNode] = None
    for v in values:
        root = bst_insert(root, v)
    return root

class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        if root is None:
            return []
        prev_val: Optional[int] = None
        count = 0
        max_count = 0
        modes: List[int] = []
        def handle(val: int) -> None:
            nonlocal prev_val, count, max_count, modes
            if prev_val is None or val != prev_val:
                prev_val = val
                count = 1
            else:
                count += 1
            if count > max_count:
                max_count = count
                modes = [val]
            elif count == max_count:
                modes.append(val)
        node = root
        while node:
            if node.left is None:
                handle(node.val)
                node = node.right
            else:
                pred = node.left
                while pred.right is not None and pred.right is not node:
                    pred = pred.right
                if pred.right is None:
                    pred.right = node
                    node = node.left
                else:
                    pred.right = None
                    handle(node.val)
                    node = node.right
        return modes

def sorted_modes(root: Optional[TreeNode]) -> List[int]:
    return sorted(Solution().findMode(root))

if __name__ == "__main__":
    # Deterministic tests
    r = build_bst([1, 2, 2])
    assert sorted_modes(r) == [2]
    r = build_bst([0])
    assert sorted_modes(r) == [0]
    r = build_bst([1, 2, 3])
    assert sorted_modes(r) == [1, 2, 3]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import Optional, List

# LeetCode-ready reference implementation (Morris traversal; O(1) extra space)
class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        if root is None:
            return []
        prev_val: Optional[int] = None
        count = 0
        max_count = 0
        modes: List[int] = []

        def handle(val: int) -> None:
            nonlocal prev_val, count, max_count, modes
            if prev_val is None or val != prev_val:
                prev_val = val
                count = 1
            else:
                count += 1
            if count > max_count:
                max_count = count
                modes = [val]
            elif count == max_count:
                modes.append(val)

        node = root
        while node:
            if node.left is None:
                handle(node.val)
                node = node.right
            else:
                pred = node.left
                while pred.right is not None and pred.right is not node:
                    pred = pred.right
                if pred.right is None:
                    pred.right = node
                    node = node.left
                else:
                    pred.right = None
                    handle(node.val)
                    node = node.right
        return modes

# Self-check asserts
if __name__ == "__main__":
    r1 = TreeNode(1)
    r1.right = TreeNode(2)
    r1.right.left = TreeNode(2)
    assert sorted(Solution().findMode(r1)) == [2]
    r2 = TreeNode(0)
    assert sorted(Solution().findMode(r2)) == [0]
    r3 = TreeNode(2, TreeNode(1), TreeNode(3))
    assert sorted(Solution().findMode(r3)) == [1, 2, 3]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find all values with maximum frequency in a BST, ideally in $O(n)$ time and $O(1)$ extra space via Morris traversal.}
\WHY{Tests run-order aware in-order counting, run-length logic, and space-optimized traversals, common in interviews and coding contests.}
\CHECKLIST{
\begin{itemize}
\item Confirm BST allows duplicates and their placement.
\item Choose traversal: map counting vs in-order run counting vs Morris.
\item Maintain \texttt{prev}, \texttt{count}, \texttt{max\_count}, modes update logic.
\item Restore threads in Morris correctly.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item Single node tree.
\item All nodes identical.
\item All values distinct (all are modes).
\item Modes appear on both sides of the tree.
\item Very skewed tree (height $n$).
\item Negative and zero values.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Forgetting to reset \texttt{count} when value changes.
\item Not initializing \texttt{prev\_val} properly (first visit).
\item Missing the final run if doing a two-pass approach.
\item In Morris, failing to remove threads, corrupting the tree.
\item Handling duplicates consistently with BST definition.
\item Returning unsorted results when tests expect sorted (if they do).
\end{itemize}
}
\FAILMODES{A naive unsorted traversal may not expose equal values contiguously, making single-pass run counting incorrect. Morris mis-implementation can loop infinitely or lose nodes; ensure predecessor threading is correct.}
\ELI{Walk the BST in sorted order, count how many times each number repeats consecutively, and remember the biggest counts. Using Morris traversal, you can do this without extra memory beyond the output.}
\NotePages{3}

\end{document}