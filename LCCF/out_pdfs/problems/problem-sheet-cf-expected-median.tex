% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Expected Median}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1999/F}}
\LINE{DIFFICULTY / RATING}{1500}
\STATEMENT{Arul has a binary array $a$ of length $n$. He will take all subsequences of length $k$ ($k$ is odd) of this array and find their median. What is the sum of all these values? As this sum can be very large, output it modulo $10^9 + 7$. In other words, print the remainder of this sum when divided by $10^9 + 7$.

Input: The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases. The first line of each test case contains two integers $n$ and $k$ ($1 \le k \le n \le 2 \cdot 10^5$, $k$ is odd) — the length of the array and the length of the subsequence, respectively. The second line of each test case contains $n$ integers $a_i$ ($0 \le a_i \le 1$) — the elements of the array. It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

Output: For each test case, print the sum modulo $10^9 + 7$.

Note: In the first test case, there are four subsequences of $[1,0,0,1]$ with length $k=3$: $[1,0,0]$ has median $0$; $[1,0,1]$ has median $1$; $[1,0,1]$ has median $1$; $[0,0,1]$ has median $0$. In the second test case, all subsequences of length $1$ have median $1$, so the answer is $5$.}
\BREAKDOWN{For a binary sequence of odd length, the median equals $1$ iff the number of ones is at least $\tfrac{k+1}{2}$. Therefore, the required sum equals the number of length-$k$ subsequences containing at least $\tfrac{k+1}{2}$ ones. Reduce the problem to a purely combinatorial count based only on the total counts of ones and zeros in $a$.}
\ELI{Count how many length-$k$ subsequences have a majority of ones; that count is the sum because the median is either $0$ or $1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: integers $n,k$ with $1 \le k \le n \le 2\cdot 10^5$, $k$ odd; then an array $a$ of $n$ integers with $a_i \in \{0,1\}$.}
\OUTPUTS{For each test case, output a single integer: the sum of medians over all length-$k$ subsequences of $a$, modulo $10^9 + 7$.}
\SAMPLES{Example 1: $n=4$, $k=3$, $a=[1,0,0,1]$; answer $=2$. Example 2: $n=5$, $k=1$, $a=[1,1,1,1,1]$; answer $=5$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $c_1$ be the number of ones and $c_0=n-c_1$ be the number of zeros in the array. For odd $k$, a length-$k$ subsequence has median $1$ iff it contains at least $r=\tfrac{k+1}{2}$ ones. The order of chosen indices is fixed by the original array, so each choice of indices uniquely defines a subsequence.}
\varmapStart
\var{n}{length of the array}
\var{k}{subsequence length (odd)}
\var{c_1}{count of ones in $a$}
\var{c_0}{count of zeros in $a$}
\var{r}{threshold of ones needed, $r=\tfrac{k+1}{2}$}
\varmapEnd
\GOVERN{
\[
\text{Answer} \equiv \sum_{t=L}^{U} \binom{c_1}{t}\binom{c_0}{k-t} \pmod{10^9+7},\quad
L=\max\!\bigl(r,\,k-c_0\bigr),\; U=\min\!\bigl(k,\,c_1\bigr).
\]
}
\ASSUMPTIONS{All combinations are taken modulo the prime $10^9+7$. Binomial coefficients with invalid arguments are $0$.}
\INVARIANTS{The count depends only on $(c_1,c_0)$, not on the positions of ones and zeros. Each selection of $t$ ones and $k-t$ zeros yields exactly one subsequence by preserving original order.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the direct binomial sum over $t$ from $r$ to $\min(k,c_1)$: add $\binom{c_1}{t}\binom{c_0}{k-t}$ modulo $10^9+7$. Precompute factorials and inverse factorials once.}
\ASSUMPTIONS{Modular arithmetic with modulus $10^9+7$; factorial tables up to $\max n$ over all tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read all tests and compute $c_1$ and $c_0$ for each.
\item Precompute factorials and inverse factorials up to $\max n$.
\item For each test, compute $r=\tfrac{k+1}{2}$ and sum $\binom{c_1}{t}\binom{c_0}{k-t}$ for $t=r,\ldots,\min(k,c_1)$ with the implicit constraint $k-t\le c_0$.
\end{algosteps}
\COMPLEXITY{For each test, iterating $t$ over at most $k+1$ values with $O(1)$ per term using precomputed binomials. Total across all tests is $O\!\left(\sum k\right)\le O\!\left(\sum n\right)$. Space $O(\max n)$.}
\[
\begin{aligned}
T(n) &\le O\!\left(\sum_{\text{tests}} k\right) \le O\!\left(\sum_{\text{tests}} n\right) \le O(2\cdot 10^5),\\
S(n) &= O(\max n).
\end{aligned}
\]
\CORRECTNESS{By definition, median$=1$ iff the subsequence has at least $r$ ones. The number of such subsequences with exactly $t$ ones is $\binom{c_1}{t}\binom{c_0}{k-t}$. Summing over valid $t$ yields the desired count.}
\EDGECASES{$c_1=0$ or $c_0=0$; $k=1$; $k=n$; small arrays; ensure lower bound $t\ge k-c_0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 1999F - Expected Median (Baseline)
# Count subsequences of length k with at least r=(k+1)//2 ones.
# Implements: read_input(), solve_all(), main()+guard, and test asserts.

from typing import List, Tuple

MOD = 10**9 + 7

# Dynamic factorials/inverses growth (no recomputation from scratch)
FAC = [1]
IFAC = [1]
INV = [0, 1]  # INV[i] = modular inverse of i for i>=1

def ensure_fact(n: int) -> None:
    """Ensure factorial tables are available up to n."""
    cur = len(FAC) - 1
    if n <= cur:
        return
    # Grow INV, FAC, IFAC incrementally
    global FAC, IFAC, INV
    for i in range(len(INV), n + 1):
        INV.append(MOD - (MOD // i) * INV[MOD % i] % MOD)
    for i in range(cur + 1, n + 1):
        FAC.append(FAC[-1] * i % MOD)
        IFAC.append(IFAC[-1] * INV[i] % MOD)

def nCr(n: int, r: int) -> int:
    if r < 0 or r > n:
        return 0
    ensure_fact(n)
    return FAC[n] * IFAC[r] % MOD * IFAC[n - r] % MOD

def solve_case(n: int, k: int, arr: List[int]) -> int:
    c1 = sum(arr)
    c0 = n - c1
    r = (k + 1) // 2
    L = max(r, k - c0)
    U = min(k, c1)
    if L > U:
        return 0
    ans = 0
    for t in range(L, U + 1):
        ans = (ans + nCr(c1, t) * nCr(c0, k - t)) % MOD
    return ans

def read_input(data: str = None) -> List[Tuple[int, int, List[int]]]:
    import sys
    it = iter(data.split()) if data is not None else iter(sys.stdin.read().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, k, a))
    return tests

def solve_all(tests: List[Tuple[int, int, List[int]]]) -> List[int]:
    # Precompute up to max n among tests (for safety; dynamic growth also works)
    max_n = 0
    for n, k, a in tests:
        if n > max_n:
            max_n = n
    ensure_fact(max_n)
    return [solve_case(n, k, a) for (n, k, a) in tests]

def main():
    tests = read_input()
    ans = solve_all(tests)
    import sys
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    # Basic sanity asserts (do not consume stdin)
    assert solve_case(4, 3, [1,0,0,1]) == 2
    assert solve_case(5, 1, [1,1,1,1,1]) == 5
    assert solve_case(5, 3, [0,0,0,0,0]) == 0
    main()
\end{minted}
\VALIDATION{Spot-check by comparing to combinatorics directly on small inputs; ensure $k=n$ matches $\sum_{t=\lceil k/2\rceil}^{c_1} \binom{c_1}{t}\binom{c_0}{k-t}$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same binomial sum but prune the loop bounds to $[L,U]$ where $L=\max(r,k-c_0)$ and $U=\min(k,c_1)$, avoiding iterating over impossible $t$. Maintain factorials incrementally to avoid recomputing inverse factorials from scratch.}
\ASSUMPTIONS{Incremental precomputation arrays for factorials, inverse factorials, and modular inverses.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $c_1,c_0,r$.
\item Set $L=\max(r,k-c_0)$ and $U=\min(k,c_1)$.
\item Sum $\binom{c_1}{t}\binom{c_0}{k-t}$ only for $t\in[L,U]$, using incrementally maintained factorial tables.
\end{algosteps}
\COMPLEXITY{Loop length is $U-L+1\le \min(c_1,k)-\max(r,k-c_0)+1\le k+1$. Growth of factorial tables is amortized $O(1)$ per increase, total $O(\max n)$.}
\[
\begin{aligned}
T(n) &= O\!\left((U-L+1) + 1\right) \le O(k),\\
S(n) &= O(\max n).
\end{aligned}
\]
\CORRECTNESS{Same rationale as baseline; the pruning only removes $t$ that violate either $t<r$ or $k-t>c_0$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF 1999F - Expected Median (Improved: pruned loop + incremental tables)

from typing import List, Tuple

MOD = 10**9 + 7
FAC = [1]
IFAC = [1]
INV = [0, 1]

def ensure_fact(n: int) -> None:
    cur = len(FAC) - 1
    if n <= cur:
        return
    global FAC, IFAC, INV
    for i in range(len(INV), n + 1):
        INV.append(MOD - (MOD // i) * INV[MOD % i] % MOD)
    for i in range(cur + 1, n + 1):
        FAC.append(FAC[-1] * i % MOD)
        IFAC.append(IFAC[-1] * INV[i] % MOD)

def nCr(n: int, r: int) -> int:
    if r < 0 or r > n:
        return 0
    ensure_fact(n)
    return FAC[n] * IFAC[r] % MOD * IFAC[n - r] % MOD

def solve_case(n: int, k: int, arr: List[int]) -> int:
    c1 = sum(arr)
    c0 = n - c1
    r = (k + 1) // 2
    L = max(r, k - c0)
    U = min(k, c1)
    if L > U:
        return 0
    acc = 0
    for t in range(L, U + 1):
        acc = (acc + nCr(c1, t) * nCr(c0, k - t)) % MOD
    return acc

def read_input(data: str = None) -> List[Tuple[int, int, List[int]]]:
    import sys
    it = iter(data.split()) if data is not None else iter(sys.stdin.read().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, k, a))
    return tests

def solve_all(tests: List[Tuple[int, int, List[int]]]) -> List[int]:
    max_n = 0
    for n, k, a in tests:
        if n > max_n:
            max_n = n
    ensure_fact(max_n)
    return [solve_case(n, k, a) for (n, k, a) in tests]

def main():
    tests = read_input()
    res = solve_all(tests)
    import sys
    sys.stdout.write("\n".join(map(str, res)))

if __name__ == "__main__":
    # Sanity checks
    assert solve_case(4, 3, [1,0,0,1]) == 2
    assert solve_case(5, 1, [1,0,1,1,1]) == 4
    assert solve_case(3, 3, [1,0,1]) == 1
    main()
\end{minted}
\VALIDATION{Check arrays with all zeros, all ones, and mixed small cases. Verify that bounds $L$ and $U$ produce empty sums exactly when impossible.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use complement when cheaper: the answer equals $\binom{n}{k} - \sum_{t} \binom{c_1}{t}\binom{c_0}{k-t}$ over $t \le r-1$ (with feasibility $k-t\le c_0$). Choose the shorter of the two sums to minimize iterations.}
\ASSUMPTIONS{Same modular binomial setup as before; decide between direct and complement sums by comparing their loop lengths.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $c_1,c_0,r$, and ensure factorials up to $n$.
\item Let direct bounds be $L=\max(r,k-c_0)$ to $U=\min(k,c_1)$.
\item Let complement bounds be $L'=\max(0,k-c_0)$ to $U'=\min(r-1,c_1)$.
\item If $(U-L)\le (U'-L')$, sum direct; else compute $\binom{n}{k}-\text{complement}$.
\end{algosteps}
\OPTIMALITY{Every term is $O(1)$; choosing the shorter of the two disjoint ranges minimizes the number of terms summed. This is tight for worst cases where $c_1$ is near $0$ or $n$.}
\COMPLEXITY{Per test $O\!\left(\min(\#\text{direct terms}, \#\text{complement terms})\right)\le O(k)$; total $O(\sum n)$. Space $O(\max n)$.}
\[
\begin{aligned}
T(n) &\le O\!\left(\min\bigl(U-L+1,\,U'-L'+1\bigr)\right),\\
\text{with } U&=\min(k,c_1),\ L=\max(r,k-c_0),\ U'=\min(r-1,c_1),\ L'=\max(0,k-c_0).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF 1999F - Expected Median (Optimal: choose direct vs complement)
# Complete, ready-to-submit reference with asserts.

from typing import List, Tuple

MOD = 10**9 + 7

FAC = [1]
IFAC = [1]
INV = [0, 1]

def ensure_fact(n: int) -> None:
    cur = len(FAC) - 1
    if n <= cur:
        return
    global FAC, IFAC, INV
    for i in range(len(INV), n + 1):
        INV.append(MOD - (MOD // i) * INV[MOD % i] % MOD)
    for i in range(cur + 1, n + 1):
        FAC.append(FAC[-1] * i % MOD)
        IFAC.append(IFAC[-1] * INV[i] % MOD)

def nCr(n: int, r: int) -> int:
    if r < 0 or r > n:
        return 0
    ensure_fact(n)
    return FAC[n] * IFAC[r] % MOD * IFAC[n - r] % MOD

def count_sum(c1: int, c0: int, k: int, L: int, U: int) -> int:
    if L > U:
        return 0
    acc = 0
    for t in range(L, U + 1):
        acc = (acc + nCr(c1, t) * nCr(c0, k - t)) % MOD
    return acc

def solve_case(n: int, k: int, arr: List[int]) -> int:
    c1 = sum(arr)
    c0 = n - c1
    r = (k + 1) // 2
    Ld = max(r, k - c0)
    Ud = min(k, c1)
    Lc = max(0, k - c0)
    Uc = min(r - 1, c1)
    if Ld > Ud and (Lc > Uc):
        return 0
    # Choose shorter range
    len_d = max(0, Ud - Ld + 1)
    len_c = max(0, Uc - Lc + 1)
    if len_d <= len_c:
        return count_sum(c1, c0, k, Ld, Ud)
    total = nCr(n, k)
    bad = count_sum(c1, c0, k, Lc, Uc)
    return (total - bad) % MOD

def read_input(data: str = None) -> List[Tuple[int, int, List[int]]]:
    import sys
    it = iter(data.split()) if data is not None else iter(sys.stdin.read().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, k, a))
    return tests

def solve_all(tests: List[Tuple[int, int, List[int]]]) -> List[int]:
    max_n = 0
    for n, k, a in tests:
        if n > max_n:
            max_n = n
    ensure_fact(max_n)
    return [solve_case(n, k, a) for (n, k, a) in tests]

def main():
    tests = read_input()
    out = solve_all(tests)
    import sys
    sys.stdout.write("\n".join(map(str, out)))

if __name__ == "__main__":
    # Exactly 3 validation asserts
    assert solve_case(4, 3, [1,0,0,1]) == 2  # sample reasoning
    assert solve_case(5, 1, [1,1,1,1,1]) == 5  # all ones, k=1
    assert solve_case(6, 5, [0,0,0,1,1,1]) == 3  # choose all 5, need >=3 ones
    main()
\end{minted}
\VALIDATION{Three asserts included in the code: a mixed sample, trivial $k=1$, and a constructed case with $n=6,k=5$.}
\RESULT{For each test, prints the count of length-$k$ subsequences with at least $\tfrac{k+1}{2}$ ones, i.e., the sum of medians over all such subsequences, modulo $10^9+7$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test helper combinatorics, compare direct vs complement branches on random small arrays by brute force, and ensure consistency when $k=n$ and when $k=1$.}
\LINE{CROSS-CHECKS}{On tiny $n\le 8$, enumerate all $\binom{n}{k}$ index sets, compute medians directly, and compare with the formula-based answer. Cross-check Approach A vs C outputs on random seeds.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with $(c_1,c_0)\in\{(0,n),(n,0)\}$, alternating bits, and extremes $k=1$, $k=n$, and $k=\tfrac{n+1}{2}$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

from typing import List, Tuple
import random

def brute_force_sum(arr: List[int], k: int) -> int:
    # For small n only
    n = len(arr)
    from itertools import combinations
    r = (k + 1) // 2
    ans = 0
    for idxs in combinations(range(n), k):
        ones = sum(arr[i] for i in idxs)
        ans += 1 if ones >= r else 0
    return ans

def gen_cases() -> List[Tuple[int,int,List[int]]]:
    cases = []
    # Boundaries
    cases.append((1, 1, [0]))
    cases.append((1, 1, [1]))
    cases.append((5, 1, [1,1,1,1,1]))
    cases.append((5, 5, [1,0,1,0,1]))
    # Degenerate all zeros/ones
    cases.append((6, 3, [0]*6))
    cases.append((6, 3, [1]*6))
    # Alternating
    cases.append((6, 5, [0,1,0,1,0,1]))
    # Random small with odd k
    random.seed(0)
    for n in range(2, 8):
        for k in range(1, n+1, 2):
            arr = [random.randrange(2) for _ in range(n)]
            cases.append((n, k, arr))
    return cases
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference implementation (same as Approach C)

from typing import List, Tuple

MOD = 10**9 + 7
FAC = [1]
IFAC = [1]
INV = [0, 1]

def ensure_fact(n: int) -> None:
    cur = len(FAC) - 1
    if n <= cur:
        return
    global FAC, IFAC, INV
    for i in range(len(INV), n + 1):
        INV.append(MOD - (MOD // i) * INV[MOD % i] % MOD)
    for i in range(cur + 1, n + 1):
        FAC.append(FAC[-1] * i % MOD)
        IFAC.append(IFAC[-1] * INV[i] % MOD)

def nCr(n: int, r: int) -> int:
    if r < 0 or r > n:
        return 0
    ensure_fact(n)
    return FAC[n] * IFAC[r] % MOD * IFAC[n - r] % MOD

def count_sum(c1: int, c0: int, k: int, L: int, U: int) -> int:
    if L > U:
        return 0
    acc = 0
    for t in range(L, U + 1):
        acc = (acc + nCr(c1, t) * nCr(c0, k - t)) % MOD
    return acc

def solve_case(n: int, k: int, arr: List[int]) -> int:
    c1 = sum(arr)
    c0 = n - c1
    r = (k + 1) // 2
    Ld = max(r, k - c0)
    Ud = min(k, c1)
    Lc = max(0, k - c0)
    Uc = min(r - 1, c1)
    if Ld > Ud and (Lc > Uc):
        return 0
    len_d = max(0, Ud - Ld + 1)
    len_c = max(0, Uc - Lc + 1)
    if len_d <= len_c:
        return count_sum(c1, c0, k, Ld, Ud)
    total = nCr(n, k)
    bad = count_sum(c1, c0, k, Lc, Uc)
    return (total - bad) % MOD

def read_input(data: str = None) -> List[Tuple[int, int, List[int]]]:
    import sys
    it = iter(data.split()) if data is not None else iter(sys.stdin.read().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, k, a))
    return tests

def solve_all(tests: List[Tuple[int, int, List[int]]]) -> List[int]:
    max_n = 0
    for n, k, a in tests:
        if n > max_n:
            max_n = n
    ensure_fact(max_n)
    return [solve_case(n, k, a) for (n, k, a) in tests]

def main():
    tests = read_input()
    out = solve_all(tests)
    import sys
    sys.stdout.write("\n".join(map(str, out)))

if __name__ == "__main__":
    # A few asserts
    assert solve_case(4, 3, [1,0,0,1]) == 2
    assert solve_case(5, 1, [1,1,1,1,1]) == 5
    assert solve_case(6, 5, [0,0,0,1,1,1]) == 3
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count length-$k$ subsequences with at least $\tfrac{k+1}{2}$ ones; that count is the sum of medians (since medians are $0/1$).}
\WHY{Frequently tests the skill to transform an order-sensitive task on subsequences into an order-agnostic combinatorial count, exploiting that picking indices determines a unique subsequence.}
\CHECKLIST{%
\begin{bullets}
\item Compute $c_1$ and $c_0$.
\item Set $r=\tfrac{k+1}{2}$.
\item Bound $t$ by feasibility: $k-t\le c_0$, $0\le t\le c_1$.
\item Sum $\binom{c_1}{t}\binom{c_0}{k-t}$ over the chosen range.
\item Use modulus $10^9+7$; precompute factorials/inverses.
\end{bullets}}
\EDGECASES{%
\begin{bullets}
\item All zeros: answer $0$ unless $k=0$ (not allowed here).
\item All ones: answer $=\binom{n}{k}$.
\item $k=1$: answer $=c_1$.
\item $k=n$: answer $=1$ iff $c_1\ge\tfrac{n+1}{2}$ else $0$.
\item Small $n$ where $k-c_0>c_1$ making the sum empty.
\item Very unbalanced $c_1$ or $c_0$ driving the complement branch.
\end{bullets}}
\PITFALLS{%
\begin{bullets}
\item Forgetting feasibility $k-t\le c_0$ when $t$ is near $r$.
\item Recomputing factorials or inverse factorials per test (TLE risk).
\item Using slow modular inverse per binomial call rather than precomputation.
\item Off-by-one in $r=(k+1)//2$.
\item Integer overflow without modulo (in other languages).
\item Negative modulo when subtracting complement; add MOD before modulo.
\end{bullets}}
\FAILMODES{%
\begin{bullets}
\item Brute-force enumeration of $\binom{n}{k}$ subsequences is infeasible.
\item DP over positions and counts is overkill; counting by $(c_1,c_0)$ is exact and faster.
\end{bullets}}
\ELI{Since medians are either $0$ or $1$, the sum is just how many subsequences have a majority of ones. That only depends on how many ones and zeros the array has, not where they are, so a clean combinatorial formula solves it.}
\NotePages{3}

\end{document}