% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Sort the Matrix Diagonally}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/sort-the-matrix-diagonally/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{A \textbf{matrix diagonal} is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. For example, the \textbf{matrix diagonal} starting from \texttt{mat[2][0]}, where \texttt{mat} is a \texttt{6 x 3} matrix, includes cells \texttt{mat[2][0]}, \texttt{mat[3][1]}, and \texttt{mat[4][2]}. Given an \texttt{m x n} matrix \texttt{mat} of integers, sort each \textbf{matrix diagonal} in ascending order and return the resulting matrix.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]}

\quad \textbf{Output:} \texttt{[[1,1,1,1],[1,2,2,2],[1,2,3,3]]}

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]}

\quad \textbf{Output:} \texttt{[[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]}

\textbf{Constraints:}
\begin{bullets}
\item $m = \texttt{len(mat)}$, $n = \texttt{len(mat[i])}$.
\item $1 \le m, n \le 100$.
\item $1 \le \texttt{mat[i][j]} \le 100$.
\end{bullets}}
\BREAKDOWN{Group cells by their diagonal key $d=i-j$, sort values within each group, and write them back from top-left to bottom-right along each diagonal. Ensure all diagonals starting at the top row or left column are processed.}
\ELI{Treat each diagonal like an independent list: collect it, sort it, and put the numbers back along the same diagonal.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of lists \texttt{mat} of size $m \times n$ with integers. Valid ranges: $1 \le m,n \le 100$ and $1 \le \texttt{mat[i][j]} \le 100$.}
\OUTPUTS{A new matrix (or in-place modified \texttt{mat}) where for every diagonal with constant $d=i-j$, the sequence along that diagonal is nondecreasing from top-left to bottom-right.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{[[3,3,1,1],[2,2,1,2],[1,1,1,2]]} $\to$ Output: \texttt{[[1,1,1,1],[1,2,2,2],[1,2,3,3]]}.
\item Input: \texttt{[[1]]} $\to$ Output: \texttt{[[1]]}.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\Model{Let indices be zero-based. For each cell $(i,j)$ with $0 \le i < m$, $0 \le j < n$, define its diagonal key $d=i-j$. Each diagonal is the ordered set $D_d=\{(i,j): i-j=d\}$ sorted by $i$ (equivalently by $j$). The task is to permute entries within each $D_d$ so that the resulting values are nondecreasing along increasing $i$.}
\varmapStart
\var{m,n}{matrix dimensions}
\var{\texttt{mat}}{input integer matrix of size $m \times n$}
\var{d}{diagonal key $i-j$}
\var{D_d}{set of coordinates on diagonal $d$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall d,\ \text{if } D_d = \bigl((i_1,j_1),\ldots,(i_k,j_k)\bigr)\ \text{with } i_1<\cdots<i_k,\ \text{then } \texttt{mat}[i_1][j_1] \le \cdots \le \texttt{mat}[i_k][j_k].
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are valid and zero-based; diagonals are maximal in bottom-right direction; values are integers within $[1,100]$.}
\INVARIANTS{
\begin{bullets}
\item Diagonal membership is invariant: coordinates do not move across diagonals (key $d=i-j$ is preserved).
\item Multiset per diagonal is preserved: only the order within each $D_d$ changes.
\item After processing, each $D_d$ is nondecreasing in $i$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate each diagonal starting point, extract its values, sort with a comparison sort, and write them back. Uses the key $d=i-j$ implicitly by following bottom-right steps $(+1,+1)$.}
\ASSUMPTIONS{Matrix fits in memory; in-place overwrite allowed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each starting cell in the top row $(0,c)$ for $c=0,\ldots,n-1$ and in the left column $(r,0)$ for $r=1,\ldots,m-1$, traverse along $(+1,+1)$ to collect values of that diagonal into a list.
\item Sort the collected list ascending.
\item Traverse the same diagonal again and overwrite cells with the sorted values.
\end{algosteps}
\COMPLEXITY{Let $L_d$ be diagonal lengths. Extract+sort+write for diagonal $d$ costs $O(L_d\log L_d)$. Summed over all diagonals, time $T=\sum_d O(L_d\log L_d) \le O(mn\log(\min(m,n)))$, space $S=O(\min(m,n))$ for the buffer.}
\[
\begin{aligned}
T(m,n) &= \sum_{d} \bigl(\Theta(L_d) + \Theta(L_d\log L_d) + \Theta(L_d)\bigr) \\
       &= \Theta\!\left(\sum_d L_d \log L_d\right) \le \Theta(mn\log(\min(m,n))).
\end{aligned}
\]
\CORRECTNESS{Each diagonal is independently sorted and written back to the same coordinates, preserving diagonal membership and producing nondecreasing sequences.}
\EDGECASES{Single row or column; all equal elements; already sorted diagonals; strictly decreasing diagonals.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0

        # Process all diagonals starting from first row
        for c0 in range(n):
            r, c = 0, c0
            buf = []
            while r < m and c < n:
                buf.append(mat[r][c])
                r += 1
                c += 1
            buf.sort()
            r, c = 0, c0
            i = 0
            while r < m and c < n:
                mat[r][c] = buf[i]
                i += 1
                r += 1
                c += 1

        # Process all diagonals starting from first column (excluding (0,0) to avoid duplicate)
        for r0 in range(1, m):
            r, c = r0, 0
            buf = []
            while r < m and c < n:
                buf.append(mat[r][c])
                r += 1
                c += 1
            buf.sort()
            r, c = r0, 0
            i = 0
            while r < m and c < n:
                mat[r][c] = buf[i]
                i += 1
                r += 1
                c += 1

        return mat

# Basic asserts (from the prompt)
sol = Solution()
assert sol.diagonalSort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]) == [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
assert sol.diagonalSort([[1]]) == [[1]]
mat2 = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
exp2 = [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]
assert sol.diagonalSort([row[:] for row in mat2]) == exp2
\end{minted}
\VALIDATION{Checked example cases and single-element matrix. Verified no duplication of starting points.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Min-Heap per Diagonal}
\WHICHFORMULA{Group by diagonal key $d=i-j$ into min-heaps, then fill the matrix row-major by popping from the heap of each cell's diagonal. This avoids two traversals per diagonal.}
\ASSUMPTIONS{Python \texttt{heapq} available; values arbitrary integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a dictionary \texttt{heaps} mapping key $d=i-j$ to a min-heap of values observed on that diagonal.
\item Iterate cells in row-major order; for each $(i,j)$, replace \texttt{mat[i][j]} by \texttt{heappop(heaps[d])}.
\item Return the modified matrix.
\end{algosteps}
\COMPLEXITY{Heap construction pushes each element once and pops once: $O(mn\log L)$ where $L \le \min(m,n)$ bounds heap sizes; space $O(mn)$ for the dictionary of heaps. This reduces passes and constant factors compared to repeated per-diagonal traversals.}
\[
\begin{aligned}
T(m,n) &= O(mn\log(\min(m,n))), \quad S(m,n)=O(mn).
\end{aligned}
\]
\CORRECTNESS{Row-major fill order visits each diagonal in increasing $(i,j)$; popping from its min-heap yields nondecreasing placement along that diagonal. Multisets per diagonal are preserved by construction.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        heaps = {}
        for i in range(m):
            for j in range(n):
                d = i - j
                if d not in heaps:
                    heaps[d] = []
                heapq.heappush(heaps[d], mat[i][j])
        for i in range(m):
            for j in range(n):
                d = i - j
                mat[i][j] = heapq.heappop(heaps[d])
        return mat

# Asserts
sol = Solution()
assert sol.diagonalSort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]) == [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
assert sol.diagonalSort([[1,2],[3,4]]) == [[1,2],[3,4]]
mat2 = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
exp2 = [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]
assert sol.diagonalSort([row[:] for row in mat2]) == exp2
\end{minted}
\VALIDATION{Validated on given examples and a small already-sorted matrix to ensure stability is not required.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Per-Diagonal Counting Sort (Values in [1,100])}
\WHICHFORMULA{Use counting sort per diagonal leveraging the constraint $1 \le \texttt{mat[i][j]} \le 100$. This achieves linear time in the number of elements.}
\ASSUMPTIONS{Value range bounded by a small constant ($100$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each diagonal starting point in top row and left column, traverse and tally counts in an array \texttt{cnt[101]}.
\item Traverse the diagonal again, writing back values by scanning \texttt{cnt} from $1$ to $100$.
\item Repeat for all diagonals, return \texttt{mat}.
\end{algosteps}
\OPTIMALITY{Each element is read and written once; counts are scanned over a fixed-size alphabet, so time is $\Theta(mn + 100\cdot D)$ where $D$ is the number of diagonals ($D \le m+n-1$). As 100 is constant, $T=\Theta(mn)$, which is information-theoretically optimal up to constants under the given alphabet bound.}
\COMPLEXITY{Time $T=\Theta(mn)$, space $S=O(1)$ extra per diagonal (array of size $101$).}
\[
\begin{aligned}
T(m,n) &= \Theta\bigl(mn + 100(m+n)\bigr) = \Theta(mn), \quad S(m,n)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0

        def sort_from(start_r: int, start_c: int) -> None:
            # Count values on this diagonal
            cnt = [0] * 101  # values in [1,100]
            r, c = start_r, start_c
            while r < m and c < n:
                cnt[mat[r][c]] += 1
                r += 1
                c += 1
            # Write back in ascending order
            r, c = start_r, start_c
            v = 1
            while r < m and c < n:
                while v <= 100 and cnt[v] == 0:
                    v += 1
                mat[r][c] = v
                cnt[v] -= 1
                r += 1
                c += 1

        # Top row
        for c0 in range(n):
            sort_from(0, c0)
        # Left column (skip (0,0))
        for r0 in range(1, m):
            sort_from(r0, 0)
        return mat

# Exactly 3 asserts
sol = Solution()
assert sol.diagonalSort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]) == [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
assert sol.diagonalSort([[1]]) == [[1]]
mat2 = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
exp2 = [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]
assert sol.diagonalSort([row[:] for row in mat2]) == exp2
\end{minted}
\VALIDATION{Three asserts match examples and a trivial case.}
\RESULT{Returns the matrix with each $d=i-j$ diagonal sorted ascending; ties arbitrary but preserved as multiplicities.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on examples; edge cases (single row/column, all equal, strictly decreasing diagonals); randomized matrices verifying per-diagonal multiset preservation and sortedness.}
\LINE{CROSS-CHECKS}{Compare outputs from Approaches A, B, and C on small random matrices to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate $m,n \in \{1,2,3,5,10\}$ and values in $[1,5]$ to cover duplicates and small alphabets.}
\begin{minted}{python}
from typing import List, Tuple
import random
import collections

def ref_diagonal_sort_counting(mat: List[List[int]]) -> List[List[int]]:
    m = len(mat)
    n = len(mat[0]) if m > 0 else 0

    def sort_from(start_r: int, start_c: int) -> None:
        cnt = [0] * 101
        r, c = start_r, start_c
        while r < m and c < n:
            cnt[mat[r][c]] += 1
            r += 1
            c += 1
        r, c = start_r, start_c
        v = 1
        while r < m and c < n:
            while v <= 100 and cnt[v] == 0:
                v += 1
            mat[r][c] = v
            cnt[v] -= 1
            r += 1
            c += 1

    for c0 in range(n):
        sort_from(0, c0)
    for r0 in range(1, m):
        sort_from(r0, 0)
    return mat

def ref_diagonal_sort_heap(mat: List[List[int]]) -> List[List[int]]:
    import heapq
    m = len(mat)
    n = len(mat[0]) if m > 0 else 0
    heaps = {}
    for i in range(m):
        for j in range(n):
            d = i - j
            if d not in heaps:
                heaps[d] = []
            heapq.heappush(heaps[d], mat[i][j])
    for i in range(m):
        for j in range(n):
            d = i - j
            mat[i][j] = heapq.heappop(heaps[d])
    return mat

def is_diagonally_sorted(mat: List[List[int]]) -> bool:
    m = len(mat)
    n = len(mat[0]) if m > 0 else 0
    for i in range(m - 1):
        for j in range(n - 1):
            if i - j == (i+1) - (j+1):
                if mat[i][j] > mat[i+1][j+1]:
                    return False
    return True

def diagonals_multiset(mat: List[List[int]]) -> dict:
    m = len(mat)
    n = len(mat[0]) if m > 0 else 0
    dmap = collections.defaultdict(list)
    for i in range(m):
        for j in range(n):
            dmap[i-j].append(mat[i][j])
    for k in dmap:
        dmap[k].sort()
    return dmap

def gen_matrix(m: int, n: int, lo: int = 1, hi: int = 7, rng: random.Random = random) -> List[List[int]]:
    return [[rng.randint(lo, hi) for _ in range(n)] for _ in range(m)]

# Cross-check small random cases deterministically
rng = random.Random(12345)
for m in [1, 2, 3, 5]:
    for n in [1, 2, 4, 6]:
        for _ in range(10):
            A = gen_matrix(m, n, 1, 7, rng)
            B = [row[:] for row in A]
            C = [row[:] for row in A]
            out1 = ref_diagonal_sort_counting([row[:] for row in B])
            out2 = ref_diagonal_sort_heap([row[:] for row in C])
            assert out1 == out2, (A, out1, out2)
            assert is_diagonally_sorted(out1)
            # Check multiset per diagonal preserved
            assert diagonals_multiset(A) == diagonals_multiset(out1)

# Reference Solution (ready to submit)
from typing import List

class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0

        def sort_from(start_r: int, start_c: int) -> None:
            cnt = [0] * 101
            r, c = start_r, start_c
            while r < m and c < n:
                cnt[mat[r][c]] += 1
                r += 1
                c += 1
            r, c = start_r, start_c
            v = 1
            while r < m and c < n:
                while v <= 100 and cnt[v] == 0:
                    v += 1
                mat[r][c] = v
                cnt[v] -= 1
                r += 1
                c += 1

        for c0 in range(n):
            sort_from(0, c0)
        for r0 in range(1, m):
            sort_from(r0, 0)
        return mat

# Final quick checks
sol = Solution()
assert sol.diagonalSort([[1]]) == [[1]]
assert sol.diagonalSort([[2,1],[3,2]]) == [[2,1],[3,2]]
assert sol.diagonalSort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]) == [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort each diagonal (constant $i-j$) in ascending order independently.}
\WHY{Common LC pattern: grouping by invariant key (here $i-j$) and local reordering; tests understanding of matrix traversal and data-structure choice.}
\CHECKLIST{
\begin{bullets}
\item Identify diagonal key $d=i-j$.
\item Enumerate starting points: top row and left column.
\item Extract values correctly along $(+1,+1)$.
\item Sort (comparison or counting given bounds).
\item Write back in the same order of coordinates.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $m=1$ or $n=1$.
\item All equal elements.
\item Already sorted diagonals.
\item Strictly decreasing diagonals.
\item Rectangular matrices with $m \ne n$.
\item Max sizes ($100 \times 100$).
\item Values at bounds $1$ and $100$ only.
\item Repeated values causing many ties.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Double-processing the $(0,0)$ diagonal start.
\item Traversal bounds off-by-one when writing back.
\item Forgetting to reset write index or counter pointer.
\item Using global counting array without clearing per diagonal.
\item Misusing heap fill order (not row-major) causing wrong placement.
\item Building diagonal starts from every cell (quadratic overhead).
\item Mutating input while still collecting unsorted values from it (mixing phases).
\item Allocating large temporary arrays unnecessarily.
\end{bullets}
}
\FAILMODES{Approaches that naively search neighbors for each cell without grouping by $i-j$ can lead to $O(mn\min(m,n))$ time. The provided solutions avoid this by per-diagonal extraction or pre-grouping.}
\ELI{Think of diagonals as separate shelves. Take items from a shelf, sort them, and put them back on the same shelf from left to right and top to bottom.}
\NotePages{3}

\end{document}