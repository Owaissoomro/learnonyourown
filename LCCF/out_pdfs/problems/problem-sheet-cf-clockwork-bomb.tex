% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Clockwork Bomb}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/650/E}}
\LINE{DIFFICULTY / RATING}{CF: 650/E \quad Rating: 3200}
\STATEMENT{My name is James diGriz, I am the most clever robber and treasure hunter in the whole galaxy. There are books written about my adventures and songs about my operations, though you were able to catch me up in a pretty awkward moment.

I was able to hide from cameras, outsmart all the guards and pass numerous traps, but when I finally reached the treasure box and opened it, I have accidentally started the clockwork bomb! Luckily, I have met such kind of bombs before and I know that the clockwork mechanism can be stopped by connecting contacts with wires on the control panel of the bomb in a certain manner.

I see $n$ contacts connected by $n-1$ wires. Contacts are numbered with integers from $1$ to $n$. The bomb has a security mechanism that ensures the following condition: if there exist $k \ge 2$ contacts $c_1,c_2,\ldots,c_k$ forming a circuit, i.e., there exist $k$ distinct wires between contacts $c_1$ and $c_2$, $c_2$ and $c_3$, $\ldots$, $c_k$ and $c_1$, then the bomb immediately explodes and my story ends here. In particular, if two contacts are connected by more than one wire they form a circuit of length $2$. It is also prohibited to connect a contact with itself.

On the other hand, if I disconnect more than one wire (i.e., at some moment there will be no more than $n-2$ wires in the scheme) then the other security check fails and the bomb also explodes. So, the only thing I can do is to unplug some wire and plug it into a new place ensuring the fact that no circuits appear.

I know how I should put the wires in order to stop the clockwork. But my time is running out! Help me get out of this alive: find the sequence of operations each of which consists of unplugging some wire and putting it into another place so that the bomb is defused.

Input:

The first line of the input contains $n$ ($2 \le n \le 500{,}000$), the number of contacts.

Each of the following $n-1$ lines contains two integers $x_i$ and $y_i$ ($1 \le x_i,y_i \le n$, $x_i \ne y_i$) denoting the contacts currently connected by the $i$-th wire.

The remaining $n-1$ lines contain the description of the sought scheme in the same format.

It is guaranteed that the starting and the ending schemes are correct (i.e., do not contain circuits nor wires connecting a contact with itself).

Output:

The first line should contain $k$ ($k \ge 0$) — the minimum number of moves of unplugging and plugging back some wire required to defuse the bomb.

In each of the following $k$ lines output four integers $a_i,b_i,c_i,d_i$ meaning that on the $i$-th step it is necessary to unplug the wire connecting the contacts $a_i$ and $b_i$ and plug it to the contacts $c_i$ and $d_i$. Of course the wire connecting contacts $a_i$ and $b_i$ should be present in the scheme.

If there is no correct sequence transforming the existing scheme into the sought one, output $-1$.

Note: Picture with the clarification for the sample tests:}
\BREAKDOWN{We are given two trees on the same $n$ labeled vertices. In one move, replace exactly one current edge by another non-present edge, while maintaining that the graph remains a tree at every step. Find a sequence of minimum length to transform the initial tree into the target tree.}
\ELI{Each move swaps one current edge for a missing target edge along a cycle; the fewest moves equals the number of edges that differ between the two trees.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single test:
- Integer $n$ with $2 \le n \le 500{,}000$.
- $n-1$ lines: edges of the initial tree.
- $n-1$ lines: edges of the target tree.
Edges are given as unordered pairs $(x,y)$ with $1 \le x,y \le n$ and $x \ne y$. No self-loops or multiple edges.}
\OUTPUTS{Print $k$ — the minimum number of operations. Then print $k$ lines, each with $a~b~c~d$: unplug edge $(a,b)$ currently present, and plug it as $(c,d)$. The sequence must be valid and maintain a tree after each move. If impossible (which does not occur for two trees), print $-1$.}
\SAMPLES{Example (tiny):
- Input:
3
1 2
2 3
1 2
1 3
Output:
1
2 3 1 3

Another:
4
1 2
2 3
3 4
1 3
2 4
3 4
1 2
Output:
2
2 3 1 3
3 4 2 4}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T_1=(V,E_1)$ be the initial tree and $T_2=(V,E_2)$ the target tree on the same vertex set $V=\{1,\ldots,n\}$. One operation replaces an edge $e\in E$ with $f\notin E$, provided the result remains a tree. The goal is to transform $E_1$ into $E_2$ in the minimum number of operations while always staying in the space of trees.}
\varmapStart
\var{E_1}{initial edge set}
\var{E_2}{target edge set}
\var{B}{``bad'' edge set $E_1 \setminus E_2$}
\var{A}{``add'' edge set $E_2 \setminus E_1$}
\var{P_{u,v}}{unique path in the current tree between $u$ and $v$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&|E_1|=|E_2|=n-1,\quad (V,E_1)\ \text{and}\ (V,E_2)\ \text{are trees}.\\
&k_\star = |E_2\setminus E_1| = |E_1\setminus E_2|.\\
&\text{For } (u,v)\in A:\ \text{adding } (u,v) \text{ to the current tree creates a unique cycle } C.\\
&\exists\ e\in C\cap B \quad \text{(else } E_2 \text{ would contain a cycle).}
\end{aligned}
\]
}
\ASSUMPTIONS{Edges are unordered pairs; both input graphs are trees. At each step, removing an edge on the created cycle and adding the desired edge keeps the graph a tree.}
\INVARIANTS{
- The current graph is always a tree on $V$.
- The number of ``bad'' edges decreases by exactly $1$ per operation.
- The process terminates in exactly $|A|$ steps.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Replace each missing target edge $(u,v)\in A$ by locating the unique path between $u$ and $v$ in the current tree and removing any edge on that path not belonging to $E_2$.}
\ASSUMPTIONS{We can traverse the current tree in $O(n)$ time to find the $u\to v$ path.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build sets $E_1$, $E_2$ and current adjacency of $E_1$.
\item Let $A := E_2\setminus E_1$. For each $(u,v)\in A$:
\begin{bullets}
\item Run DFS/BFS to find the path $u\to v$ in the current tree.
\item On that path, pick an edge $(a,b)$ not in $E_2$; remove it and add $(u,v)$.
\item Record operation $(a,b)\to(u,v)$ and update adjacency and $E_1$.
\end{bullets}
\item Output all recorded operations.
\end{algosteps}
\COMPLEXITY{For $m=|A|$, each step costs $O(n)$ in the worst case, so $T(n)=O(mn)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= \sum_{(u,v)\in A} O(n) \\
     &= O(|A|\,n) \le O(n^2).
\end{aligned}
\]
\CORRECTNESS{Adding $(u,v)$ creates a unique cycle; at least one edge on that cycle is not in $E_2$, otherwise $E_2$ would have a cycle including $(u,v)$. Removing such an edge keeps the graph a tree. The number of edges differing from $E_2$ decreases by one per step, so the process ends in $|A|$ steps, which is optimal.}
\EDGECASES{No operations if $E_1=E_2$. Works for $n=2$. Path discovery is unique in a tree.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], []
    e1 = []
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        e1.append((min(a, b), max(a, b)))
    e2 = []
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        e2.append((min(a, b), max(a, b)))
    return n, e1, e2

def solve_case(n: int, e1: list, e2: list):
    if n == 0:
        return "0\n"
    E1 = set(e1)
    E2 = set(e2)
    # Current adjacency
    adj = [[] for _ in range(n + 1)]
    for (u, v) in E1:
        adj[u].append(v)
        adj[v].append(u)
    add_edges = [e for e in E2 if e not in E1]
    ops = []
    # Helper: find path nodes from u to v
    def find_path(u, v):
        parent = [-1] * (n + 1)
        dq = deque([u])
        parent[u] = 0
        while dq and parent[v] == -1:
            x = dq.popleft()
            for y in adj[x]:
                if parent[y] == -1:
                    parent[y] = x
                    dq.append(y)
                    if y == v:
                        break
        if parent[v] == -1:
            return []  # should not happen in a tree
        path_nodes = [v]
        cur = v
        while cur != u:
            cur = parent[cur]
            path_nodes.append(cur)
        path_nodes.reverse()
        return path_nodes

    for (u, v) in add_edges:
        # path as edges
        nodes = find_path(u, v)
        # Find a removable edge on path not in E2
        rem = None
        for i in range(len(nodes) - 1):
            a, b = nodes[i], nodes[i + 1]
            e = (min(a, b), max(a, b))
            if e not in E2:
                rem = e
                break
        if rem is None:
            # No valid operation sequence (should not happen for two trees)
            return "-1\n"
        a, b = rem
        # Remove rem
        adj[a].remove(b)
        adj[b].remove(a)
        E1.remove(rem)
        # Add (u,v)
        adj[u].append(v)
        adj[v].append(u)
        E1.add((min(u, v), max(u, v)))
        ops.append((a, b, u, v))
    out = [str(len(ops))]
    out += ["{} {} {} {}".format(a, b, c, d) for (a, b, c, d) in ops]
    return "\n".join(out) + "\n"

def solve_all():
    data = sys.stdin.read()
    n, e1, e2 = read_input(data)
    sys.stdout.write(solve_case(n, e1, e2))

if __name__ == "__main__":
    # Tiny tests
    t1 = """3
1 2
2 3
1 2
1 3
"""
    n, e1, e2 = read_input(t1)
    out = solve_case(n, e1, e2).strip().splitlines()
    assert out[0] == "1"
    # After operation, E1 should equal E2
    # Another test
    t2 = """4
1 2
2 3
3 4
1 3
2 4
3 4
1 2
"""
    n, e1, e2 = read_input(t2)
    out = solve_case(n, e1, e2).strip().splitlines()
    assert int(out[0]) == 2
    # Run solver if stdin is non-empty
    # (Already handled by solve_all)
    pass
\end{minted}
\VALIDATION{Checks include:
- Simple chain of 3 nodes.
- A 4-node example requiring two moves.
Both ensure $k=|E_2\setminus E_1|$ and a valid transformation.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Dynamic Trees via Link-Cut Trees (Edge-as-Node)}
\WHICHFORMULA{Maintain the current tree as a dynamic forest with a Link-Cut Tree (LCT). Mark ``bad'' edges (present in current but not in target). For each $(u,v)\in A$, query along the path $u\to v$ for any marked edge, cut it, and link $(u,v)$ using the same edge node (now unmarked).}
\ASSUMPTIONS{LCT supports makeroot, access, splay, link, cut, and path aggregate to detect a marked edge on a path in $O(\log n)$ amortized time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build sets $E_1,E_2$ and initialize an LCT with $n$ vertex nodes and $n-1$ edge nodes.
\item For each initial edge $(x,y)\in E_1$, create an edge-node $e$, set its value to $1$ if $(x,y)\notin E_2$, else $0$, and link $e$ to $x$ and $y$.
\item For each $(u,v)\in E_2\setminus E_1$:
\begin{bullets}
\item Query the LCT on path $u\to v$ to find some edge-node $e$ with value $1$.
\item Let $e$ connect $(a,b)$ currently. Perform cut$(e,a)$ and cut$(e,b)$.
\item Set $e$'s value to $0$, update endpoints to $(u,v)$, and link $e$ to $u$ and $v$.
\item Record operation $(a,b)\to(u,v)$.
\end{bullets}
\item Output all operations; their count is $|E_2\setminus E_1|$.
\end{algosteps}
\COMPLEXITY{Each operation is $O(\log n)$ amortized in the LCT, so total $T(n)=O(n\log n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O\big((n-1)\log n\big) \quad \text{build} \;+\; O\big(|A|\log n\big) \quad \text{ops}.
\end{aligned}
\]
\CORRECTNESS{Adding $(u,v)$ forms a unique cycle in the current tree; at least one edge on this cycle is not in $E_2$. The LCT path-aggregate guarantees one such edge is found. Replacing it with $(u,v)$ preserves the tree invariant and reduces the number of bad edges by one.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], []
    e1 = []
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        if a > b: a, b = b, a
        e1.append((a, b))
    e2 = []
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        if a > b: a, b = b, a
        e2.append((a, b))
    return n, e1, e2

class LCT:
    __slots__ = ("n", "l", "r", "p", "rev", "val", "best")
    def __init__(self, size):
        self.n = size
        self.l = [0] * (size + 1)
        self.r = [0] * (size + 1)
        self.p = [0] * (size + 1)
        self.rev = [0] * (size + 1)
        self.val = [0] * (size + 1)   # 1 for bad edge-node, 0 otherwise
        self.best = [0] * (size + 1)  # 1 if any node in splay-subtree has val==1, else 0

    def _is_root(self, x):
        px = self.p[x]
        return px == 0 or (self.l[px] != x and self.r[px] != x)

    def _push(self, x):
        if self.rev[x]:
            self.l[x], self.r[x] = self.r[x], self.l[x]
            if self.l[x]: self.rev[self.l[x]] ^= 1
            if self.r[x]: self.rev[self.r[x]] ^= 1
            self.rev[x] = 0

    def _pull(self, x):
        b = self.val[x]
        if self.l[x] and self.best[self.l[x]]: b = 1
        if self.r[x] and self.best[self.r[x]]: b = 1
        self.best[x] = b

    def _rotate(self, x):
        y = self.p[x]
        z = self.p[y]
        self._push(y); self._push(x)
        if self.l[y] == x:
            self.l[y] = self.r[x]
            if self.r[x]: self.p[self.r[x]] = y
            self.r[x] = y
        else:
            self.r[y] = self.l[x]
            if self.l[x]: self.p[self.l[x]] = y
            self.l[x] = y
        self.p[y] = x
        self.p[x] = z
        if z:
            if self.l[z] == y: self.l[z] = x
            elif self.r[z] == y: self.r[z] = x
        self._pull(y); self._pull(x)

    def _splay(self, x):
        st = []
        y = x
        st.append(y)
        while not self._is_root(y):
            y = self.p[y]
            st.append(y)
        while st:
            self._push(st.pop())
        while not self._is_root(x):
            y = self.p[x]
            z = self.p[y]
            if not self._is_root(y):
                if (self.l[z] == y) == (self.l[y] == x):
                    self._rotate(y)
                else:
                    self._rotate(x)
            self._rotate(x)

    def access(self, x):
        last = 0
        y = x
        while y:
            self._splay(y)
            self.r[y] = last
            self._pull(y)
            last = y
            y = self.p[y]
        self._splay(x)

    def makeroot(self, x):
        self.access(x)
        self.rev[x] ^= 1
        self._push(x)

    def findroot(self, x):
        self.access(x)
        while self.l[x]:
            self._push(x)
            x = self.l[x]
        self._splay(x)
        return x

    def link(self, x, y):
        self.makeroot(x)
        if self.findroot(y) != x:
            self.p[x] = y

    def cut(self, x, y):
        self.makeroot(x)
        self.access(y)
        # Now x is in the leftmost of y's splay-subtree if directly connected
        if self.l[y] == x and self.p[x] == y and self.r[x] == 0:
            self.l[y] = 0
            self.p[x] = 0
            self._pull(y)

    def path_has_bad(self, u, v):
        self.makeroot(u)
        self.access(v)
        return self.best[v] == 1

    def pick_bad_on_path(self, u, v):
        # Returns index of a node with val==1 on path u..v, or 0 if none
        self.makeroot(u)
        self.access(v)
        if self.best[v] == 0:
            return 0
        x = v
        # descend to find any val==1
        while True:
            self._push(x)
            if self.l[x] and self.best[self.l[x]] == 1:
                x = self.l[x]
                continue
            if self.val[x] == 1:
                break
            x = self.r[x]
        self._splay(x)
        return x

def solve_case(n: int, e1: list, e2: list):
    if n == 0:
        return "0\n"
    E1 = set(e1)
    E2 = set(e2)
    add_edges = [e for e in e2 if e not in E1]
    # Build LCT with vertices [1..n] and edge-nodes [n+1..n+(n-1)]
    total = n + (n - 1)
    lct = LCT(total)
    # map each initial edge to an edge-node id
    edge_u = [0] * (total + 1)
    edge_v = [0] * (total + 1)
    edge_ids = {}
    next_id = n + 1
    for (a, b) in e1:
        eid = next_id
        next_id += 1
        edge_ids[(a, b)] = eid
        edge_u[eid] = a
        edge_v[eid] = b
        # mark bad if not in E2
        lct.val[eid] = 0 if (a, b) in E2 else 1
        lct._pull(eid)
        # link
        lct.link(eid, a)
        lct.link(eid, b)
    ops = []
    for (u, v) in add_edges:
        e_bad = lct.pick_bad_on_path(u, v)
        if e_bad == 0:
            # Should not happen for two trees
            return "-1\n"
        a = edge_u[e_bad]; b = edge_v[e_bad]
        # Cut the bad edge-node from its endpoints
        lct.cut(e_bad, a)
        lct.cut(e_bad, b)
        # Reuse this edge-node to link (u,v) and mark as good
        edge_u[e_bad] = u
        edge_v[e_bad] = v
        lct.val[e_bad] = 0
        lct._pull(e_bad)
        lct.link(e_bad, u)
        lct.link(e_bad, v)
        ops.append((a, b, u, v))
    out = [str(len(ops))]
    out += ["{} {} {} {}".format(a, b, c, d) for (a, b, c, d) in ops]
    return "\n".join(out) + "\n"

def solve_all():
    data = sys.stdin.read()
    n, e1, e2 = read_input(data)
    sys.stdout.write(solve_case(n, e1, e2))

if __name__ == "__main__":
    # Tiny deterministic checks
    t1 = """3
1 2
2 3
1 2
1 3
"""
    n, e1, e2 = read_input(t1)
    out = solve_case(n, e1, e2).strip().splitlines()
    assert out[0] == "1"
    t2 = """4
1 2
2 3
3 4
1 3
2 4
3 4
1 2
"""
    n, e1, e2 = read_input(t2)
    out = solve_case(n, e1, e2).strip().splitlines()
    assert int(out[0]) == 2
\end{minted}
\VALIDATION{Edge cases:
- Already equal trees produce $k=0$.
- Small chains and stars verify correctness.
- Path queries always find a bad edge until none remain.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Matroid Basis Exchange + Link-Cut Implementation}
\WHICHFORMULA{Tree edge sets form bases of the graphic matroid. For any $f\in E_2\setminus E$, adding $f$ to the current tree $E$ creates a unique cycle with at least one $e\in E\setminus E_2$. Exchange $E \leftarrow E \cup \{f\}\setminus\{e\}$. Implement exchanges with an LCT in $O(\log n)$ time each.}
\ASSUMPTIONS{Both $E_1$ and $E_2$ are trees; exchange property holds; LCT supports path aggregate to find a removable edge.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Preprocess sets $E_1,E_2$; initialize LCT with edge-nodes marked bad iff not in $E_2$.
\item For each $(u,v)\in E_2\setminus E_1$, find any bad edge-node on the path $u\to v$ via LCT aggregate and replace it by $(u,v)$.
\item Output the sequence. The count equals $|E_2\setminus E_1|$ and is minimum.
\end{algosteps}
\OPTIMALITY{Lower bound: at least one operation per edge in $E_2\setminus E_1$. Achievability: the exchange step reduces $|E\triangle E_2|$ by $2$; after $|E_2\setminus E_1|$ steps we reach $E_2$. Hence the bound is tight.}
\COMPLEXITY{Building links: $O(n\log n)$; each of $|E_2\setminus E_1|$ operations: $O(\log n)$. Overall $O(n\log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], []
    e1 = []
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        if a > b: a, b = b, a
        e1.append((a, b))
    e2 = []
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        if a > b: a, b = b, a
        e2.append((a, b))
    return n, e1, e2

class LCT:
    __slots__ = ("n", "l", "r", "p", "rev", "val", "best")
    def __init__(self, size):
        self.n = size
        self.l = [0] * (size + 1)
        self.r = [0] * (size + 1)
        self.p = [0] * (size + 1)
        self.rev = [0] * (size + 1)
        self.val = [0] * (size + 1)   # 1 for bad edge-node, 0 otherwise
        self.best = [0] * (size + 1)  # 1 if any node in splay-subtree has val==1, else 0

    def _is_root(self, x):
        px = self.p[x]
        return px == 0 or (self.l[px] != x and self.r[px] != x)

    def _push(self, x):
        if self.rev[x]:
            self.l[x], self.r[x] = self.r[x], self.l[x]
            if self.l[x]: self.rev[self.l[x]] ^= 1
            if self.r[x]: self.rev[self.r[x]] ^= 1
            self.rev[x] = 0

    def _pull(self, x):
        b = self.val[x]
        if self.l[x] and self.best[self.l[x]]: b = 1
        if self.r[x] and self.best[self.r[x]]: b = 1
        self.best[x] = b

    def _rotate(self, x):
        y = self.p[x]
        z = self.p[y]
        self._push(y); self._push(x)
        if self.l[y] == x:
            self.l[y] = self.r[x]
            if self.r[x]: self.p[self.r[x]] = y
            self.r[x] = y
        else:
            self.r[y] = self.l[x]
            if self.l[x]: self.p[self.l[x]] = y
            self.l[x] = y
        self.p[y] = x
        self.p[x] = z
        if z:
            if self.l[z] == y: self.l[z] = x
            elif self.r[z] == y: self.r[z] = x
        self._pull(y); self._pull(x)

    def _splay(self, x):
        st = []
        y = x
        st.append(y)
        while not self._is_root(y):
            y = self.p[y]
            st.append(y)
        while st:
            self._push(st.pop())
        while not self._is_root(x):
            y = self.p[x]
            z = self.p[y]
            if not self._is_root(y):
                if (self.l[z] == y) == (self.l[y] == x):
                    self._rotate(y)
                else:
                    self._rotate(x)
            self._rotate(x)

    def access(self, x):
        last = 0
        y = x
        while y:
            self._splay(y)
            self.r[y] = last
            self._pull(y)
            last = y
            y = self.p[y]
        self._splay(x)

    def makeroot(self, x):
        self.access(x)
        self.rev[x] ^= 1
        self._push(x)

    def findroot(self, x):
        self.access(x)
        while self.l[x]:
            self._push(x)
            x = self.l[x]
        self._splay(x)
        return x

    def link(self, x, y):
        self.makeroot(x)
        if self.findroot(y) != x:
            self.p[x] = y

    def cut(self, x, y):
        self.makeroot(x)
        self.access(y)
        if self.l[y] == x and self.p[x] == y and self.r[x] == 0:
            self.l[y] = 0
            self.p[x] = 0
            self._pull(y)

    def pick_bad_on_path(self, u, v):
        self.makeroot(u)
        self.access(v)
        if self.best[v] == 0:
            return 0
        x = v
        while True:
            self._push(x)
            if self.l[x] and self.best[self.l[x]] == 1:
                x = self.l[x]
                continue
            if self.val[x] == 1:
                break
            x = self.r[x]
        self._splay(x)
        return x

def solve_case(n: int, e1: list, e2: list):
    if n == 0:
        return "0\n"
    E1 = set(e1)
    E2 = set(e2)
    add_edges = [e for e in e2 if e not in E1]
    total = n + (n - 1)
    lct = LCT(total)
    edge_u = [0] * (total + 1)
    edge_v = [0] * (total + 1)
    next_id = n + 1
    for (a, b) in e1:
        eid = next_id
        next_id += 1
        edge_u[eid] = a
        edge_v[eid] = b
        lct.val[eid] = 0 if (a, b) in E2 else 1
        lct._pull(eid)
        lct.link(eid, a)
        lct.link(eid, b)
    ops = []
    for (u, v) in add_edges:
        e_bad = lct.pick_bad_on_path(u, v)
        if e_bad == 0:
            return "-1\n"
        a = edge_u[e_bad]; b = edge_v[e_bad]
        lct.cut(e_bad, a)
        lct.cut(e_bad, b)
        edge_u[e_bad] = u
        edge_v[e_bad] = v
        lct.val[e_bad] = 0
        lct._pull(e_bad)
        lct.link(e_bad, u)
        lct.link(e_bad, v)
        ops.append((a, b, u, v))
    out = [str(len(ops))]
    out += ["{} {} {} {}".format(a, b, c, d) for (a, b, c, d) in ops]
    return "\n".join(out) + "\n"

def solve_all():
    data = sys.stdin.read()
    n, e1, e2 = read_input(data)
    sys.stdout.write(solve_case(n, e1, e2))

if __name__ == "__main__":
    # Exactly 3 asserts
    t1 = """2
1 2
1 2
"""
    n, e1, e2 = read_input(t1)
    assert solve_case(n, e1, e2).strip().splitlines()[0] == "0"
    t2 = """3
1 2
2 3
1 2
1 3
"""
    n, e1, e2 = read_input(t2)
    assert solve_case(n, e1, e2).strip().splitlines()[0] == "1"
    t3 = """4
1 2
2 3
3 4
1 3
2 4
3 4
1 2
"""
    n, e1, e2 = read_input(t3)
    assert solve_case(n, e1, e2).strip().splitlines()[0] == "2"
\end{minted}
\VALIDATION{Three asserts exercise $k=0$, $k=1$, and $k=2$ cases.}
\RESULT{We output the minimum number of operations $k=|E_2\setminus E_1|$ and one valid sequence of edge replacements that maintains a tree throughout.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Compare baseline and LCT outputs on randomly generated small trees; verify $k=|E_2\setminus E_1|$ and that simulating operations transforms $E_1$ into $E_2$.}
\LINE{CROSS-CHECKS}{For small $n$, both approaches must yield the same $k$; simulate the moves to confirm final edge set equals $E_2$.}
\LINE{EDGE-CASE GENERATOR}{Generate stars, paths, and random trees with small $n$; swap a few edges to create the target.}
\begin{minted}{python}
import sys, random
from collections import defaultdict, deque

def gen_tree(n, rng):
    parent = list(range(n+1))
    edges = []
    for v in range(2, n+1):
        u = rng.randrange(1, v)
        a, b = (u, v) if u < v else (v, u)
        edges.append((a, b))
    return edges

def simulate_ops(n, e1, ops):
    adj = [[] for _ in range(n+1)]
    S = set(e1)
    for (a, b) in S:
        adj[a].append(b); adj[b].append(a)
    for (a, b, c, d) in ops:
        x, y = (a, b) if a < b else (b, a)
        if (x, y) not in S: return False
        # remove x-y
        S.remove((x, y))
        adj[a].remove(b); adj[b].remove(a)
        # add c-d
        u, v = (c, d) if c < d else (d, c)
        if u == v or (u, v) in S: return False
        S.add((u, v))
        adj[u].append(v); adj[v].append(u)
        # ensure still connected and acyclic: simple DFS count edges
        seen = [False]*(n+1)
        st = [1]; seen[1]=True; cnt=0
        while st:
            x = st.pop()
            for y in adj[x]:
                cnt += 1
                if not seen[y]:
                    seen[y]=True; st.append(y)
        if not all(seen[1:]): return False
        if cnt//2 != n-1: return False
    return True

# Reference solution (LCT) glued for testing
def solve_ref(data: str):
    # import solver from Approach C above by simple in-place copy (omitted in generator)
    from sys import stdin
    return

def run_random_tests():
    rng = random.Random(12345)
    for n in range(2, 9):
        for _ in range(30):
            e1 = gen_tree(n, rng)
            e2 = gen_tree(n, rng)
            # Baseline solver reused from Approach A
            from collections import deque
            def baseline(n, e1, e2):
                E1 = set(e1); E2 = set(e2)
                adj = [[] for _ in range(n+1)]
                for (u, v) in E1:
                    adj[u].append(v); adj[v].append(u)
                add_edges = [e for e in E2 if e not in E1]
                ops = []
                def find_path(u, v):
                    parent = [-1]*(n+1)
                    dq = deque([u]); parent[u]=0
                    while dq and parent[v]==-1:
                        x = dq.popleft()
                        for y in adj[x]:
                            if parent[y]==-1:
                                parent[y]=x; dq.append(y)
                                if y==v: break
                    cur=v; nodes=[v]
                    while cur!=u:
                        cur=parent[cur]; nodes.append(cur)
                    nodes.reverse()
                    return nodes
                for (u, v) in add_edges:
                    nodes = find_path(u, v)
                    rem = None
                    for i in range(len(nodes)-1):
                        a, b = nodes[i], nodes[i+1]
                        e = (a, b) if a < b else (b, a)
                        if e not in E2:
                            rem = e; break
                    a, b = rem
                    # perform swap
                    adj[a].remove(b); adj[b].remove(a); E1.remove(rem)
                    adj[u].append(v); adj[v].append(u); E1.add((u, v) if u < v else (v, u))
                    ops.append((a, b, u, v))
                return ops
            ops = baseline(n, e1, e2)
            assert len(ops) == len([e for e in e2 if e not in set(e1)])
            assert simulate_ops(n, e1, ops)
    print("Random tests passed.")

if __name__ == "__main__":
    if sys.stdin.isatty():
        run_random_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution (Approach C)
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return 0, [], []
    e1 = []
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        if a > b: a, b = b, a
        e1.append((a, b))
    e2 = []
    for _ in range(n - 1):
        a = int(next(it)); b = int(next(it))
        if a > b: a, b = b, a
        e2.append((a, b))
    return n, e1, e2

class LCT:
    __slots__ = ("n", "l", "r", "p", "rev", "val", "best")
    def __init__(self, size):
        self.n = size
        self.l = [0] * (size + 1)
        self.r = [0] * (size + 1)
        self.p = [0] * (size + 1)
        self.rev = [0] * (size + 1)
        self.val = [0] * (size + 1)   # 1 for bad edge-node, 0 otherwise
        self.best = [0] * (size + 1)  # 1 if any node in splay-subtree has val==1, else 0

    def _is_root(self, x):
        px = self.p[x]
        return px == 0 or (self.l[px] != x and self.r[px] != x)

    def _push(self, x):
        if self.rev[x]:
            self.l[x], self.r[x] = self.r[x], self.l[x]
            if self.l[x]: self.rev[self.l[x]] ^= 1
            if self.r[x]: self.rev[self.r[x]] ^= 1
            self.rev[x] = 0

    def _pull(self, x):
        b = self.val[x]
        if self.l[x] and self.best[self.l[x]]: b = 1
        if self.r[x] and self.best[self.r[x]]: b = 1
        self.best[x] = b

    def _rotate(self, x):
        y = self.p[x]
        z = self.p[y]
        self._push(y); self._push(x)
        if self.l[y] == x:
            self.l[y] = self.r[x]
            if self.r[x]: self.p[self.r[x]] = y
            self.r[x] = y
        else:
            self.r[y] = self.l[x]
            if self.l[x]: self.p[self.l[x]] = y
            self.l[x] = y
        self.p[y] = x
        self.p[x] = z
        if z:
            if self.l[z] == y: self.l[z] = x
            elif self.r[z] == y: self.r[z] = x
        self._pull(y); self._pull(x)

    def _splay(self, x):
        st = []
        y = x
        st.append(y)
        while not self._is_root(y):
            y = self.p[y]
            st.append(y)
        while st:
            self._push(st.pop())
        while not self._is_root(x):
            y = self.p[x]
            z = self.p[y]
            if not self._is_root(y):
                if (self.l[z] == y) == (self.l[y] == x):
                    self._rotate(y)
                else:
                    self._rotate(x)
            self._rotate(x)

    def access(self, x):
        last = 0
        y = x
        while y:
            self._splay(y)
            self.r[y] = last
            self._pull(y)
            last = y
            y = self.p[y]
        self._splay(x)

    def makeroot(self, x):
        self.access(x)
        self.rev[x] ^= 1
        self._push(x)

    def findroot(self, x):
        self.access(x)
        while self.l[x]:
            self._push(x)
            x = self.l[x]
        self._splay(x)
        return x

    def link(self, x, y):
        self.makeroot(x)
        if self.findroot(y) != x:
            self.p[x] = y

    def cut(self, x, y):
        self.makeroot(x)
        self.access(y)
        if self.l[y] == x and self.p[x] == y and self.r[x] == 0:
            self.l[y] = 0
            self.p[x] = 0
            self._pull(y)

    def pick_bad_on_path(self, u, v):
        self.makeroot(u)
        self.access(v)
        if self.best[v] == 0:
            return 0
        x = v
        while True:
            self._push(x)
            if self.l[x] and self.best[self.l[x]] == 1:
                x = self.l[x]
                continue
            if self.val[x] == 1:
                break
            x = self.r[x]
        self._splay(x)
        return x

def solve_case(n: int, e1: list, e2: list):
    if n == 0:
        return "0\n"
    E1 = set(e1)
    E2 = set(e2)
    add_edges = [e for e in e2 if e not in E1]
    total = n + (n - 1)
    lct = LCT(total)
    edge_u = [0] * (total + 1)
    edge_v = [0] * (total + 1)
    next_id = n + 1
    for (a, b) in e1:
        eid = next_id
        next_id += 1
        edge_u[eid] = a
        edge_v[eid] = b
        lct.val[eid] = 0 if (a, b) in E2 else 1
        lct._pull(eid)
        lct.link(eid, a)
        lct.link(eid, b)
    ops = []
    for (u, v) in add_edges:
        e_bad = lct.pick_bad_on_path(u, v)
        if e_bad == 0:
            return "-1\n"
        a = edge_u[e_bad]; b = edge_v[e_bad]
        lct.cut(e_bad, a)
        lct.cut(e_bad, b)
        edge_u[e_bad] = u
        edge_v[e_bad] = v
        lct.val[e_bad] = 0
        lct._pull(e_bad)
        lct.link(e_bad, u)
        lct.link(e_bad, v)
        ops.append((a, b, u, v))
    out = [str(len(ops))]
    out += ["{} {} {} {}".format(a, b, c, d) for (a, b, c, d) in ops]
    return "\n".join(out) + "\n"

def main():
    data = sys.stdin.read()
    n, e1, e2 = read_input(data)
    sys.stdout.write(solve_case(n, e1, e2))

if __name__ == "__main__":
    # Final quick asserts
    t1 = """2
1 2
1 2
"""
    n, e1, e2 = read_input(t1)
    assert solve_case(n, e1, e2).strip().splitlines()[0] == "0"
    t2 = """3
1 2
2 3
1 2
1 3
"""
    n, e1, e2 = read_input(t2)
    assert solve_case(n, e1, e2).strip().splitlines()[0] == "1"
    t3 = """4
1 2
2 3
3 4
1 3
2 4
3 4
1 2
"""
    n, e1, e2 = read_input(t3)
    assert solve_case(n, e1, e2).strip().splitlines()[0] == "2"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Transform one tree into another by exchanging edges along cycles; minimum moves equal the number of differing edges.}
\WHY{A classic dynamic trees problem testing matroid thinking and data structures like Link-Cut Trees; common at difficult CF levels.}
\CHECKLIST{
- Compute $E_1$, $E_2$, identify adds/removes.
- Maintain current tree; for each add $(u,v)$, find a removable edge on $u\to v$.
- Replace and record; ensure tree invariant after each step.
}
\EDGECASES{
- $n=2$.
- Identical trees ($k=0$).
- Star to path transformations.
- Long chains where path length equals $O(n)$ (baseline stress).
- Multiple valid removable edges on a cycle.
- Input ordering of edges arbitrary.}
\PITFALLS{
- Forgetting to normalize unordered edge pairs.
- Breaking connectivity by removing a wrong edge not on the created cycle.
- Mishandling dynamic structure updates (link/cut ordering).
- Off-by-one in IDs when mixing vertex and edge nodes.
- Not propagating lazy reversals in LCT before decisions.
- Assuming impossibility where it never happens for two trees.}
\FAILMODES{Baseline $O(n^2)$ time may TLE on large $n$; LCT survives by guaranteeing $O(\log n)$ per operation.}
\ELI{Two trees differ in some edges. Add each missing target edge; it forms a cycle. Remove any edge on that cycle that does not belong to the target. Repeat until both trees match. A Link-Cut Tree finds such an edge efficiently.}
\NotePages{3}

\end{document}