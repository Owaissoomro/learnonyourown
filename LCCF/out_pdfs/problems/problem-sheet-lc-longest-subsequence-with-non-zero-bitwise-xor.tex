% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Longest Subsequence With Non-Zero Bitwise XOR}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/longest-subsequence-with-non-zero-bitwise-xor/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given an integer array \texttt{nums}. Return the length of the longest subsequence in \texttt{nums} whose bitwise XOR is non-zero. If no such subsequence exists, return 0.

Example 1: Input: \texttt{nums = [1, 2, 3]}. Output: 2. Explanation: One longest subsequence is \texttt{[2, 3]}. The bitwise XOR is computed as \texttt{2 XOR 3 = 1}, which is non-zero.

Example 2: Input: \texttt{nums = [2, 3, 4]}. Output: 3. Explanation: The longest subsequence is \texttt{[2, 3, 4]}. The bitwise XOR is computed as \texttt{2 XOR 3 XOR 4 = 5}, which is non-zero.

Constraints:
\begin{bullets}
\item $1 \le \texttt{nums.length} \le 10^5$
\item $0 \le \texttt{nums[i]} \le 10^9$
\end{bullets}}
\BREAKDOWN{Compute the XOR of all elements. If it is non-zero, the entire array works. If it is zero, then either all numbers are zero (no valid subsequence) or there exists a non-zero element, in which case remove one such element to make the XOR non-zero, maximizing length.}
\ELI{Either take all elements if their XOR is non-zero, otherwise drop exactly one non-zero element if it exists; if all are zero, it is impossible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Array \texttt{nums} of integers with length $n$ where $1 \le n \le 10^5$ and $0 \le \texttt{nums[i]} \le 10^9$.}
\OUTPUTS{An integer: the maximum length of a subsequence of \texttt{nums} whose XOR is non-zero. If no such subsequence exists, output $0$.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{[1, 2, 3]} $\to$ Output: $2$.
\item Input: \texttt{[0, 0, 0]} $\to$ Output: $0$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n \in \mathbb{N}$ and sequence $(a_1,\ldots,a_n)$ with $a_i \in \mathbb{Z}_{\ge 0}$, find
\begin{BreakableEquation*}
\max\bigl\{|S|: S \subseteq \{1,\ldots,n\}\ \text{and}\ \bigoplus_{i \in S} a_i \ne 0\bigr\}.
\end{BreakableEquation*}
Here $\oplus$ denotes bitwise XOR, and the subsequence is represented by an index set $S$ preserving order (length depends only on $|S|$).}
\varmapStart
\var{n}{array length}
\var{a_i}{the $i$-th integer in the array}
\var{X}{total XOR $X \coloneqq \bigoplus_{i=1}^{n} a_i$}
\var{Z}{indicator that all $a_i=0$}
\varmapEnd
\GOVERN{
\[
\text{Ans} =
\begin{cases}
n, & \text{if } X \ne 0,\\[4pt]
0, & \text{if } X = 0 \ \text{and}\ \forall i:\ a_i=0,\\[4pt]
n-1, & \text{if } X = 0 \ \text{and}\ \exists i:\ a_i \ne 0.
\end{cases}
\]
}
\ASSUMPTIONS{XOR is associative and commutative; subsequences can drop any indices. The empty subsequence has XOR $0$.}
\INVARIANTS{
\begin{bullets}
\item If $X=0$ and some $a_j \ne 0$, then $\bigoplus_{i \ne j} a_i = a_j \ne 0$.
\item If all $a_i=0$, any subsequence XOR is $0$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all subsequences by bitmask, compute XOR per mask, and keep the maximum length with non-zero XOR.}
\ASSUMPTIONS{Only feasible for very small $n$ due to $2^n$ growth; useful as a verifier.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each mask from $1$ to $2^n-1$, compute XOR of chosen elements.
\item If XOR is non-zero, update the best length with the popcount of the mask.
\item Return the best length found.
\end{algosteps}
\COMPLEXITY{Exponential time and linear work per subset; memory is constant.}
\[
\begin{aligned}
T(n) &= \Theta(2^n \cdot n),\quad S(n)=\Theta(1).
\end{aligned}
\]
\CORRECTNESS{Exhaustively checks all subsequences; picks the maximum length among those with XOR $\ne 0$.}
\EDGECASES{All zeros $\to 0$; single element non-zero $\to 1$; total XOR non-zero $\to n$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestSubsequenceXorNonZero(self, nums: List[int]) -> int:
        n = len(nums)
        best = 0
        # Enumerate all non-empty subsequences
        for mask in range(1, 1 << n):
            x = 0
            cnt = 0
            m = mask
            i = 0
            while m:
                if m & 1:
                    x ^= nums[i]
                    cnt += 1
                i += 1
                m >>= 1
            if x != 0 and cnt > best:
                best = cnt
        return best

# Tiny sanity tests (exponential baseline; keep inputs small)
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestSubsequenceXorNonZero([1, 2, 3]) == 2  # [2,3]
    assert sol.longestSubsequenceXorNonZero([2, 3, 4]) == 3  # all
    assert sol.longestSubsequenceXorNonZero([0, 0, 0]) == 0
    assert sol.longestSubsequenceXorNonZero([5]) == 1
    assert sol.longestSubsequenceXorNonZero([0]) == 0
\end{minted}
\VALIDATION{Matches examples; handles all-zero case and singletons.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Algebraic Insight}
\WHICHFORMULA{Use the total XOR $X$. If $X \ne 0$, take all $n$. If $X=0$, answer is $0$ when all elements are zero, else $n-1$ by removing one non-zero element.}
\ASSUMPTIONS{XOR properties: associativity, commutativity, self-inverse ($a \oplus a = 0$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $X = \bigoplus_i a_i$ and a flag \texttt{anyNonZero}.
\item If $X \ne 0$, return $n$.
\item Else if \texttt{anyNonZero} is false, return $0$ (all zeros).
\item Else return $n-1$.
\end{algosteps}
\COMPLEXITY{Single pass over the array.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1).
\end{aligned}
\]
\CORRECTNESS{If $X \ne 0$, the full array works. If $X=0$ and some $a_j \ne 0$, then removing $a_j$ yields XOR $a_j \ne 0$ and length $n-1$, which is optimal (cannot reach $n$ since $X=0$). If all zeros, no subsequence yields non-zero XOR.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestSubsequenceXorNonZero(self, nums: List[int]) -> int:
        x = 0
        any_nonzero = False
        for v in nums:
            x ^= v
            if v != 0:
                any_nonzero = True
        n = len(nums)
        if x != 0:
            return n
        # x == 0
        if not any_nonzero:
            return 0
        return n - 1

# Tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestSubsequenceXorNonZero([1, 2, 3]) == 2
    assert sol.longestSubsequenceXorNonZero([2, 3, 4]) == 3
    assert sol.longestSubsequenceXorNonZero([0, 0, 0]) == 0
    assert sol.longestSubsequenceXorNonZero([0, 0, 5, 0]) == 3  # drop the 5 or keep others
\end{minted}
\VALIDATION{Covers $X\ne 0$, all-zeros, and mixed arrays with $X=0$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-Pass XOR Check}
\WHICHFORMULA{Final method is the constant-space, linear-time pass computing total XOR and whether any element is non-zero.}
\ASSUMPTIONS{General arrays with values in $[0,10^9]$; no additional structure needed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Accumulate $X = \bigoplus_i a_i$ and track \texttt{anyNonZero}.
\item If $X \ne 0$, return $n$.
\item If $X=0$ and \texttt{anyNonZero} is false, return $0$; else return $n-1$.
\end{algosteps}
\OPTIMALITY{A single pass is information-theoretically optimal: any algorithm must inspect all elements to decide whether $X=0$ and whether all elements are zero.}
\COMPLEXITY{Linear time and constant extra space.}
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestSubsequenceXorNonZero(self, nums: List[int]) -> int:
        x = 0
        any_nonzero = False
        for v in nums:
            x ^= v
            if v != 0:
                any_nonzero = True
        n = len(nums)
        if x != 0:
            return n
        return 0 if not any_nonzero else n - 1

# Exactly 3 asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestSubsequenceXorNonZero([1, 2, 3]) == 2
    assert sol.longestSubsequenceXorNonZero([0, 0, 0]) == 0
    assert sol.longestSubsequenceXorNonZero([5, 5, 5, 5]) == 3  # total XOR=0 but not all zero
\end{minted}
\VALIDATION{Three asserts exercising $X\ne 0$, all zeros, and $X=0$ with a non-zero present.}
\RESULT{Return $n$ if total XOR is non-zero; else return $0$ iff all elements are zero, otherwise $n-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for representative categories: $X \ne 0$ (full length), all zeros (0), $X=0$ with at least one non-zero ($n-1$), singletons, mixed arrays.}
\LINE{CROSS-CHECKS}{Compare brute-force (Approach A) vs optimal (Approach C) on small random arrays to ensure agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of sizes $1$ to $8$ with small value range to compare exact results against brute force.}
\begin{minted}{python}
from typing import List
import random

def brute(nums: List[int]) -> int:
    n = len(nums)
    best = 0
    for mask in range(1, 1 << n):
        x = 0
        cnt = 0
        for i in range(n):
            if mask >> i & 1:
                x ^= nums[i]
                cnt += 1
        if x != 0:
            best = max(best, cnt)
    return best

class Solution:
    def longestSubsequenceXorNonZero(self, nums: List[int]) -> int:
        x = 0
        any_nonzero = False
        for v in nums:
            x ^= v
            if v != 0:
                any_nonzero = True
        n = len(nums)
        if x != 0:
            return n
        return 0 if not any_nonzero else n - 1

if __name__ == "__main__":
    # Deterministic seeds and samples
    random.seed(0)
    for n in range(1, 9):
        for _ in range(200):
            arr = [random.randrange(0, 4) for __ in range(n)]
            assert Solution().longestSubsequenceXorNonZero(arr) == brute(arr)
    # Spot checks
    assert Solution().longestSubsequenceXorNonZero([2, 3, 4]) == 3
    assert Solution().longestSubsequenceXorNonZero([0, 0, 5, 0]) == 3
    assert Solution().longestSubsequenceXorNonZero([0, 0, 0]) == 0
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def longestSubsequenceXorNonZero(self, nums: List[int]) -> int:
        x = 0
        any_nonzero = False
        for v in nums:
            x ^= v
            if v != 0:
                any_nonzero = True
        n = len(nums)
        if x != 0:
            return n
        return 0 if not any_nonzero else n - 1

if __name__ == "__main__":
    sol = Solution()
    # Core examples and edges
    assert sol.longestSubsequenceXorNonZero([1, 2, 3]) == 2
    assert sol.longestSubsequenceXorNonZero([2, 3, 4]) == 3
    assert sol.longestSubsequenceXorNonZero([0, 0, 0]) == 0
    assert sol.longestSubsequenceXorNonZero([5]) == 1
    assert sol.longestSubsequenceXorNonZero([0]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute total XOR; if non-zero take all $n$, else answer is $0$ if all zeros, otherwise $n-1$.}
\WHY{This appears in interviews to test XOR properties, subsequence flexibility, and edge-case reasoning with constant-space solutions.}
\CHECKLIST{
\begin{bullets}
\item Compute total XOR $X$.
\item Check if any element is non-zero.
\item If $X \ne 0$: return $n$.
\item Else if none non-zero: return $0$.
\item Else: return $n-1$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All zeros: output $0$.
\item Single non-zero: output $1$.
\item $X \ne 0$: output $n$.
\item $X=0$ with at least one non-zero: output $n-1$.
\item Large $n$ with mixed values.
\item Repeated identical numbers with even/odd counts.
\item Presence of many zeros among non-zeros.
\item Minimal $n=1$ cases.
\item Values at bounds $0$ and $10^9$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Confusing subsequence with subarray (contiguity is irrelevant here).
\item Forgetting that removing one non-zero from total XOR $0$ yields non-zero XOR.
\item Mishandling the all-zero case (answer must be $0$, not $n-1$).
\item Using $O(2^n)$ brute force on large inputs.
\item Integer overflows are not a concern for XOR but avoid sum-based reasoning.
\item Off-by-one when returning $n-1$.
\item Assuming at least one non-zero element without checking.
\end{bullets}
}
\FAILMODES{Brute force times out. Greedy heuristics without XOR reasoning may fail on arrays where $X=0$. The presented method is robust and linear.}
\ELI{If everything XORs to something non-zero, take all. If everything cancels to zero, then either everything was zero (no hope) or drop any one non-zero to break the canceling.}
\NotePages{3}

\end{document}