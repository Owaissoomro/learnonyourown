% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Prime Divisors Selection}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1468/L}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{Suppose you have a sequence of $k$ integers $A = [a_1, a_2, \dots, a_k]$ where each $a_i \ge 2$. A sequence of prime integers $P = [p_1, p_2, \dots, p_k]$ is called suitable for the sequence $A$ if $a_1$ is divisible by $p_1$, $a_2$ is divisible by $p_2$ and so on.

A sequence of prime integers $P$ is called friendly if there are no unique integers in this sequence.

A sequence $A$ is called ideal, if each sequence $P$ that is suitable for $A$ is friendly as well (i.\,e. there is no sequence $P$ that is suitable for $A$, but not friendly). For example, the sequence $[2, 4, 16]$ is ideal, while the sequence $[2, 4, 6]$ is not ideal (there exists a sequence $P = [2, 2, 3]$ which is suitable for $A$, but not friendly).

You are given $n$ different integers $x_1$, $x_2$, \dots, $x_n$. You have to choose exactly $k$ of them in such a way that they form an ideal sequence, or report that it is impossible. Note that no integer can be chosen more than once.

Input:
The first line contains two integers $n$ and $k$ ($1 \le k \le n \le 1000$).

The second line contains $n$ pairwise distinct integers $x_1$, $x_2$, \dots, $x_n$ ($2 \le x_i \le 10^{18}$).

Output:
If it is impossible to choose exactly $k$ integers from $x_1$, $x_2$, \dots, $x_n$ in such a way that the chosen integers form an ideal sequence, print $0$.

Otherwise, print $k$ pairwise distinct integers — the elements of the chosen ideal sequence. If there are multiple answers, print any of them.}
\BREAKDOWN{Find a subset of size $k$ such that for every prime $p$ that divides at least one chosen number, in every suitable assignment of primes to positions no prime appears exactly once. Characterize such subsets and give a constructive selection algorithm, or conclude impossibility.}
\ELI{We must pick $k$ numbers so that every prime used among them is ``backed'' by at least two pure powers of that prime, making it impossible to make any prime appear exactly once no matter how you pick divisors.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n,k$ with $1 \le k \le n \le 1000$. Then $n$ distinct integers $x_i$ with $2 \le x_i \le 10^{18}$.}
\OUTPUTS{Either a single $0$ if impossible; otherwise any $k$ distinct chosen integers that form an ideal sequence, printed in one line separated by spaces.}
\SAMPLES{Example 1: $n=3,k=3$, numbers $2,4,16$. One valid output is $2~4~16$.

Example 2: $n=3,k=3$, numbers $2,4,6$. Output $0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given a multiset $S \subset \{x_1,\dots,x_n\}$ of size $k$, define $\mathcal{P}(S)$ as all sequences $(p_i)_{i=1}^k$ with $p_i$ prime and $p_i \mid a_i$ where $a_i$ is the $i$-th element of $S$. $S$ is ideal iff for every $(p_i)\in\mathcal{P}(S)$, every prime $p$ appearing among the $p_i$ has frequency $\ne 1$.}
\varmapStart
\var{n}{number of candidates}
\var{k}{required selection size}
\var{x_i}{candidate values}
\var{p}{prime}
\var{S}{selected $k$ numbers}
\var{G}{set of primes with at least two prime powers present in $S$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
S \text{ ideal} \iff &~\forall p \text{ prime}: \left(\exists i: p \mid a_i \right) \Rightarrow \#\{i: p_i = p\} \not= 1 ~\text{for all suitable } (p_i) \\
\iff &~\forall p \text{ dividing some } a\in S,\; \#\{a\in S: a=p^e,~e\ge 1\} \ge 2.
\end{aligned}
\]
}
\ASSUMPTIONS{All $x_i$ are distinct; integers fit in signed 64-bit. Primes mean standard primes.}
\INVARIANTS{If a prime $p$ divides any chosen number and fewer than two pure powers $p^e$ are chosen, then there exists a suitable assignment making $p$ unique; hence the condition is necessary and sufficient. Composites whose prime divisors all lie in $G$ do not violate ideality once $G$ is backed by at least two pure powers per prime.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Characterize ideal sets by the ``two prime powers per prime'' rule. A naive brute force would try all $\binom{n}{k}$ subsets and test the condition, but infeasible.}
\ASSUMPTIONS{We can test whether a set is ideal by factoring its elements.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all subsets $S$ of size $k$.
\item For each $S$, factor each $a\in S$ and count, for each prime $p$, how many pure powers $p^e$ are in $S$.
\item Accept $S$ iff every prime dividing any $a\in S$ has at least two pure powers in $S$.
\end{algosteps}
\COMPLEXITY{Exponential; infeasible for $n \le 1000$.}
\[
\begin{aligned}
T(n) &= \Theta\!\left(\binom{n}{k}\cdot k \cdot \text{factor}(10^{18})\right) \\
     &= \text{intractable}.
\end{aligned}
\]
\CORRECTNESS{Follows from the necessary and sufficient condition that every appearing prime must be supported by at least two pure powers within the chosen set.}
\EDGECASES{No prime has two prime powers; $k$ odd with only disjoint pairs available; composites including primes outside the supported set.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math, random
from typing import List, Tuple

def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    # small primes
    small_primes = [2,3,5,7,11,13,17,19,23,29,31,37]
    for p in small_primes:
        if n % p == 0:
            return n == p
    # write n-1 = d*2^s
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    # Deterministic MR bases for 64-bit
    for a in [2,3,5,7,11,13,17]:
        if a % n == 0:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        skip = False
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                skip = True
                break
        if not skip:
            return False
    return True

def kth_root_floor(n: int, k: int) -> int:
    if k == 1:
        return n
    lo, hi = 1, int(n ** (1.0 / k)) + 3
    while lo < hi:
        mid = (lo + hi + 1) // 2
        val = 1
        overflow = False
        for _ in range(k):
            val *= mid
            if val > n:
                overflow = True
                break
        if overflow or val > n:
            hi = mid - 1
        else:
            lo = mid
    return lo

def prime_power_base(x: int) -> int:
    # Return prime base p if x = p^e, e>=1, else 0
    # Try e from 60 down to 2
    for e in range(60, 1, -1):
        r = kth_root_floor(x, e)
        if r >= 2:
            # check exact power
            v = 1
            for _ in range(e):
                v *= r
                if v > x:
                    break
            if v == x and is_probable_prime(r):
                return r
    # check if x itself is prime (p^1)
    if is_probable_prime(x):
        return x
    return 0

def read_input() -> Tuple[int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    arr = [int(next(it)) for _ in range(n)]
    return n, k, arr

def choose_ideal(n: int, k: int, arr: List[int]) -> List[int]:
    # Group numbers that are prime powers by their prime base
    groups = {}  # p -> list of numbers equal to p^e
    base_index = {}  # number -> its prime base (for quick membership)
    for x in arr:
        p = prime_power_base(x)
        if p:
            groups.setdefault(p, []).append(x)
            base_index[x] = p
    good_primes = [p for p, lst in groups.items() if len(lst) >= 2]
    if not good_primes:
        return []  # impossible unless k == 0 (which never happens here)
    # Prepare lists
    # First two per good prime, and extras in the same prime
    first_two_per_prime = []
    extras = []
    for p in good_primes:
        lst = groups[p]
        lst.sort()
        first_two_per_prime.extend(lst[:2])
        if len(lst) > 2:
            extras.extend(lst[2:])
    # Find composites that are composed only of good primes
    good_set = set(good_primes)
    comps = []  # (value, set_of_distinct_primes_used)
    for x in arr:
        if x in base_index:
            continue  # skip prime powers; already accounted
        y = x
        used = set()
        for p in good_primes:
            if y % p == 0:
                used.add(p)
                while y % p == 0:
                    y //= p
            if y == 1:
                break
        if y == 1:
            comps.append((x, used))
    # Case analysis
    ans = []
    total_pairs_numbers = 2 * len(good_primes)
    if total_pairs_numbers > k:
        # We must choose subset of primes
        # Sort primes by group size descending to have more flexibility
        good_primes.sort(key=lambda p: len(groups[p]), reverse=True)
        if k % 2 == 0:
            need_pairs = k // 2
            for p in good_primes[:need_pairs]:
                ans.extend(groups[p][:2])
            return ans
        else:
            # Try to find a prime with at least 3 prime powers
            p3 = None
            for p in good_primes:
                if len(groups[p]) >= 3:
                    p3 = p
                    break
            if p3 is not None and k >= 3:
                ans.extend(groups[p3][:3])
                need_pairs = (k - 3) // 2
                taken = 0
                for p in good_primes:
                    if p == p3:
                        continue
                    if taken < need_pairs:
                        ans.extend(groups[p][:2])
                        taken += 1
                    else:
                        break
                if len(ans) == k:
                    return ans
                else:
                    return []
            # Else, try to use a composite that uses exactly two good primes
            pair_comp = None
            for x, used in comps:
                if 2 <= len(used) <= 2:
                    pair_comp = (x, used)
                    break
            if pair_comp is None or k < 5:
                return []
            x, used = pair_comp
            used = list(used)
            ans.append(x)
            # ensure we include both pairs for the two primes used
            for p in used:
                ans.extend(groups[p][:2])
            # fill the rest with other pairs
            need_pairs = (k - len(ans)) // 2
            taken = 0
            for p in good_primes:
                if p in used:
                    continue
                if taken < need_pairs:
                    ans.extend(groups[p][:2])
                    taken += 1
                else:
                    break
            if len(ans) == k:
                return ans
            else:
                return []
    else:
        # We can include all pairs, then fill from extras and composites
        ans = list(first_two_per_prime)
        need = k - len(ans)
        pool = []
        pool.extend(extras)
        pool.extend(x for (x, _) in comps)
        if len(pool) < need:
            return []
        ans.extend(pool[:need])
        return ans

def solve_all():
    n, k, arr = read_input()
    if n == 0:
        return
    ans = choose_ideal(n, k, arr)
    if not ans or len(ans) != k or len(set(ans)) != k:
        print(0)
    else:
        print(" ".join(str(v) for v in ans))

def main():
    solve_all()

if __name__ == "__main__":
    # Basic internal tests
    def run_io(inp: str) -> str:
        import sys, io
        backup_stdin, backup_stdout = sys.stdin, sys.stdout
        sys.stdin = io.StringIO(inp)
        sys.stdout = io.StringIO()
        try:
            solve_all()
            return sys.stdout.getvalue()
        finally:
            sys.stdin, sys.stdout = backup_stdin, backup_stdout

    # Test 1: Ideal all powers of 2
    out = run_io("3 3\n2 4 16\n")
    toks = out.strip().split()
    assert len(toks) == 3

    # Test 2: Impossible case [2,4,6]
    out = run_io("3 3\n2 4 6\n")
    assert out.strip() == "0"

    # Test 3: Larger pool of 2-powers
    out = run_io("5 5\n4 8 16 32 64\n")
    toks = out.strip().split()
    assert len(toks) == 5

    main()
\end{minted}
\VALIDATION{Sanity tests cover possible, impossible, and filling from extras. Additional thorough validation is in the final section.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prime-Power Grouping and Safe Completion}
\WHICHFORMULA{Use the characterization: any prime appearing among selected numbers must have at least two pure powers included. Construct the answer from prime-power groups and then append only numbers composed of these primes.}
\ASSUMPTIONS{We can detect prime powers up to $10^{18}$ via Miller–Rabin primality and integer $k$-th roots; $n \le 1000$ allows $O(n \cdot 60 \cdot \log n)$ operations.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $x_i$, detect if $x_i = p^e$ for some prime $p$ and $e \ge 1$. Group numbers by their base prime $p$.
\item Let $G$ be primes whose groups have size at least $2$. For each $p \in G$, take two numbers to secure $p$.
\item Build a pool of extras: remaining prime powers from these groups, and composites that reduce to $1$ after dividing out primes in $G$.
\item If $2|G| \le k$, output all pairs then fill with extras. Else, if $k$ is even output $k/2$ pairs; if $k$ is odd, use either a group with size $\ge 3$ (take $3$) plus pairs, or one composite using exactly two primes plus pairs; otherwise impossible.
\end{algosteps}
\COMPLEXITY{Dominated by prime-power detection; $O(n \cdot 60 \cdot \log x)$ for roots and modular exponentiation; space $O(n)$.}
\[
\begin{aligned}
T(n) &= O\!\big(n \cdot 60 \cdot \log 10^{18}\big) + O(n^2) \text{ (light divides)} \\
     &\approx O(10^6\text{--}10^7) \text{ ops in Python}.
\end{aligned}
\]
\CORRECTNESS{By construction, every prime that appears in the selection has at least two pure powers in the selection, so any suitable assignment cannot make it unique. Extras are restricted to numbers composed solely of already-secured primes, preserving the invariant.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    small_primes = [2,3,5,7,11,13,17,19,23,29,31,37]
    for p in small_primes:
        if n % p == 0:
            return n == p
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    for a in [2,3,5,7,11,13,17]:
        if a % n == 0:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        comp = True
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                comp = False
                break
        if comp:
            return False
    return True

def kth_root_floor(n: int, k: int) -> int:
    if k == 1:
        return n
    lo, hi = 1, int(n ** (1.0 / k)) + 3
    while lo < hi:
        mid = (lo + hi + 1) // 2
        val = 1
        overflow = False
        for _ in range(k):
            val *= mid
            if val > n:
                overflow = True
                break
        if overflow or val > n:
            hi = mid - 1
        else:
            lo = mid
    return lo

def prime_power_base(x: int) -> int:
    for e in range(60, 1, -1):
        r = kth_root_floor(x, e)
        if r >= 2:
            v = 1
            for _ in range(e):
                v *= r
                if v > x:
                    break
            if v == x and is_probable_prime(r):
                return r
    if is_probable_prime(x):
        return x
    return 0

def read_input() -> Tuple[int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    arr = [int(next(it)) for _ in range(n)]
    return n, k, arr

def solve_case(n: int, k: int, arr: List[int]) -> List[int]:
    groups = {}
    base_of = {}
    for x in arr:
        p = prime_power_base(x)
        if p:
            groups.setdefault(p, []).append(x)
            base_of[x] = p
    good = [p for p, lst in groups.items() if len(lst) >= 2]
    if not good:
        return []
    first_two = []
    extras = []
    for p in good:
        lst = sorted(groups[p])
        first_two.extend(lst[:2])
        extras.extend(lst[2:])
    good_set = set(good)
    comps = []
    for x in arr:
        if x in base_of:
            continue
        y = x
        used = set()
        for p in good:
            if y % p == 0:
                used.add(p)
                while y % p == 0:
                    y //= p
            if y == 1:
                break
        if y == 1:
            comps.append((x, used))
    total_pairs = 2 * len(good)
    if total_pairs > k:
        good.sort(key=lambda p: len(groups[p]), reverse=True)
        if k % 2 == 0:
            ans = []
            need = k // 2
            for p in good[:need]:
                ans.extend(sorted(groups[p])[:2])
            return ans
        else:
            p3 = None
            for p in good:
                if len(groups[p]) >= 3:
                    p3 = p
                    break
            if p3 is not None and k >= 3:
                ans = sorted(groups[p3])[:3]
                need_pairs = (k - 3) // 2
                taken = 0
                for p in good:
                    if p == p3:
                        continue
                    if taken < need_pairs:
                        ans.extend(sorted(groups[p])[:2])
                        taken += 1
                if len(ans) == k:
                    return ans
                return []
            pair_comp = None
            for x, used in comps:
                if len(used) == 2:
                    pair_comp = (x, used)
                    break
            if pair_comp is None or k < 5:
                return []
            x, used = pair_comp
            used = list(used)
            ans = [x]
            for p in used:
                ans.extend(sorted(groups[p])[:2])
            need_pairs = (k - len(ans)) // 2
            taken = 0
            for p in good:
                if p in used:
                    continue
                if taken < need_pairs:
                    ans.extend(sorted(groups[p])[:2])
                    taken += 1
            if len(ans) == k:
                return ans
            return []
    else:
        ans = list(first_two)
        need = k - len(ans)
        pool = list(extras) + [x for (x, _) in comps]
        if len(pool) < need:
            return []
        ans.extend(pool[:need])
        return ans

def solve_all():
    n, k, arr = read_input()
    ans = solve_case(n, k, arr)
    if not ans or len(ans) != k or len(set(ans)) != k:
        print(0)
    else:
        print(" ".join(str(v) for v in ans))

def main():
    solve_all()

if __name__ == "__main__":
    # Quick asserts
    import io
    def run_io(inp: str) -> str:
        import sys
        bk_in, bk_out = sys.stdin, sys.stdout
        sys.stdin = io.StringIO(inp)
        sys.stdout = io.StringIO()
        try:
            solve_all()
            return sys.stdout.getvalue()
        finally:
            sys.stdin, sys.stdout = bk_in, bk_out

    # Ideal all powers of 2
    out = run_io("3 3\n2 4 16\n")
    assert len(out.strip().split()) == 3

    # Impossible
    out = run_io("3 3\n2 4 6\n")
    assert out.strip() == "0"

    # Even k with many good primes
    out = run_io("6 4\n2 4 3 9 5 25\n")
    assert len(out.strip().split()) == 4

    main()
\end{minted}
\VALIDATION{Covers even/odd $k$, presence/absence of composites, and cases where only pairs exist.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Deterministic Miller–Rabin + $k$-th Roots + Pairwise Activation}
\WHICHFORMULA{Detect prime powers exactly; select two per ``good'' prime; if needed, add extras and composites composed only of these primes. Handle tight cases when $k$ is odd by either a triple from a group or a composite of exactly two good primes.}
\ASSUMPTIONS{Deterministic Miller–Rabin with bases $\{2,3,5,7,11,13,17\}$ suffices for $x \le 10^{18}$. Integer $k$-th roots computed by binary search are exact for power checks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Preprocess each $x_i$ to find prime-power base $p$ (or $0$). Build groups per base.
\item Let $G=\{p: |group[p]|\ge 2\}$. If $G=\varnothing$, print $0$.
\item If $2|G|\le k$: include two from each $p\in G$, then fill remaining slots by (i) more prime powers from the same groups, and (ii) any number divisible only by primes in $G$.
\item Else if $k$ even: take pairs for any $k/2$ primes in $G$.
\item Else $k$ odd: if some group has size $\ge 3$, take three from it and then pairs to fill; else use a composite consisting of exactly two primes from $G$, then include both pairs for those two primes and pairs for other primes as needed; if none exists, print $0$.
\end{algosteps}
\OPTIMALITY{This is optimal for the characterization: any ideal set must satisfy the two-prime-power backing for every appearing prime. The construction chooses a maximal safe set and prunes to exactly $k$ while preserving the invariant; impossibility conditions are tight.}
\COMPLEXITY{$O(n \cdot 60 \cdot \log x)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O\!\big(n \cdot 60 \cdot \log 10^{18}\big) \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    small_primes = [2,3,5,7,11,13,17,19,23,29,31,37]
    for p in small_primes:
        if n % p == 0:
            return n == p
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    for a in [2,3,5,7,11,13,17]:
        if a % n == 0:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        composite = True
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                composite = False
                break
        if composite:
            return False
    return True

def kth_root_floor(n: int, k: int) -> int:
    if k == 1:
        return n
    lo, hi = 1, int(n ** (1.0 / k)) + 3
    while lo < hi:
        mid = (lo + hi + 1) // 2
        val = 1
        overflow = False
        for _ in range(k):
            val *= mid
            if val > n:
                overflow = True
                break
        if overflow or val > n:
            hi = mid - 1
        else:
            lo = mid
    return lo

def prime_power_base(x: int) -> int:
    for e in range(60, 1, -1):
        r = kth_root_floor(x, e)
        if r >= 2:
            v = 1
            for _ in range(e):
                v *= r
                if v > x:
                    break
            if v == x and is_probable_prime(r):
                return r
    if is_probable_prime(x):
        return x
    return 0

def read_input() -> Tuple[int, int, List[int]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    arr = [int(next(it)) for _ in range(n)]
    return n, k, arr

def solve_case(n: int, k: int, arr: List[int]) -> List[int]:
    groups = {}
    base_of = {}
    for x in arr:
        p = prime_power_base(x)
        if p:
            groups.setdefault(p, []).append(x)
            base_of[x] = p
    good = [p for p, lst in groups.items() if len(lst) >= 2]
    if not good:
        return []
    first_two = []
    extras = []
    for p in good:
        lst = sorted(groups[p])
        first_two.extend(lst[:2])
        extras.extend(lst[2:])
    good_set = set(good)
    comps = []
    for x in arr:
        if x in base_of:
            continue
        y = x
        used = set()
        for p in good:
            if y % p == 0:
                used.add(p)
                while y % p == 0:
                    y //= p
            if y == 1:
                break
        if y == 1:
            comps.append((x, used))
    total_pairs = 2 * len(good)
    if total_pairs > k:
        good.sort(key=lambda p: len(groups[p]), reverse=True)
        if k % 2 == 0:
            ans = []
            need = k // 2
            for p in good[:need]:
                ans.extend(sorted(groups[p])[:2])
            return ans
        else:
            p3 = None
            for p in good:
                if len(groups[p]) >= 3:
                    p3 = p
                    break
            if p3 is not None and k >= 3:
                ans = sorted(groups[p3])[:3]
                need_pairs = (k - 3) // 2
                taken = 0
                for p in good:
                    if p == p3:
                        continue
                    if taken < need_pairs:
                        ans.extend(sorted(groups[p])[:2])
                        taken += 1
                if len(ans) == k:
                    return ans
                return []
            pair_comp = None
            for x, used in comps:
                if len(used) == 2:
                    pair_comp = (x, used)
                    break
            if pair_comp is None or k < 5:
                return []
            x, used = pair_comp
            used = list(used)
            ans = [x]
            for p in used:
                ans.extend(sorted(groups[p])[:2])
            need_pairs = (k - len(ans)) // 2
            taken = 0
            for p in good:
                if p in used:
                    continue
                if taken < need_pairs:
                    ans.extend(sorted(groups[p])[:2])
                    taken += 1
            if len(ans) == k:
                return ans
            return []
    else:
        ans = list(first_two)
        need = k - len(ans)
        pool = list(extras) + [x for (x, _) in comps]
        if len(pool) < need:
            return []
        ans.extend(pool[:need])
        return ans

def solve_all():
    n, k, arr = read_input()
    ans = solve_case(n, k, arr)
    if not ans or len(ans) != k or len(set(ans)) != k:
        print(0)
    else:
        print(" ".join(str(v) for v in ans))

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts / I/O mini-tests
    import io
    def run_io(inp: str) -> str:
        import sys
        bk_in, bk_out = sys.stdin, sys.stdout
        sys.stdin = io.StringIO(inp)
        sys.stdout = io.StringIO()
        try:
            solve_all()
            return sys.stdout.getvalue()
        finally:
            sys.stdin, sys.stdout = bk_in, bk_out

    # 1) All powers of a single prime
    out = run_io("3 3\n2 4 16\n")
    assert len(out.strip().split()) == 3

    # 2) Not enough support primes -> impossible
    out = run_io("3 3\n2 4 6\n")
    assert out.strip() == "0"

    # 3) Mixed with composites, fill from extras
    out = run_io("7 5\n2 4 8 3 9 6 18\n")
    toks = out.strip().split()
    assert len(toks) == 5

    main()
\end{minted}
\VALIDATION{Three asserts cover canonical positive, negative, and mixed scenarios.}
\RESULT{Outputs any $k$ distinct integers forming an ideal sequence or $0$ if impossible. If multiple answers exist, any is acceptable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests verify feasibility detection and selection size; adversarial cases include odd $k$ under tight pairs, and composites requiring only secured primes.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach B and C on small crafted cases; both share the same core routine, so agreement is expected.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of prime powers for several primes, optionally insert composites made from them, and random numbers containing other primes to ensure they are excluded unless fully supported.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_case(num_primes=3, per_prime=3, extras=3, noise=2, k=5):
    primes = [2,3,5,7,11,13,17,19]
    bases = primes[:num_primes]
    arr = set()
    for p in bases:
        v = p
        for _ in range(per_prime):
            arr.add(v)
            v *= p
            if v > 10**12:  # keep numbers modest
                v = p
    # add composites from bases only
    for _ in range(extras):
        x = 1
        for p in random.sample(bases, k=min(2, len(bases))):
            x *= p ** random.randint(1, 3)
        arr.add(x)
    # add noise containing primes outside bases
    other_primes = [23,29,31,37,41]
    for _ in range(noise):
        x = random.choice(other_primes) ** random.randint(1, 3)
        arr.add(x)
    arr = list(arr)
    random.shuffle(arr)
    n = len(arr)
    return n, k, arr

# Reference solution callable
def solve_reference(n, k, arr):
    import sys
    data = [str(n), str(k)] + [str(x) for x in arr]
    inp = " ".join(data) + "\n"
    import io
    from sys import stdin, stdout
    backup_in, backup_out = stdin, stdout
    try:
        stdin = io.StringIO(inp)
        stdout = io.StringIO()
        # Inline the final solver
        def is_probable_prime(n: int) -> bool:
            if n < 2:
                return False
            small_primes = [2,3,5,7,11,13,17,19,23,29,31,37]
            for p in small_primes:
                if n % p == 0:
                    return n == p
            d = n - 1
            s = 0
            while d % 2 == 0:
                d //= 2
                s += 1
            for a in [2,3,5,7,11,13,17]:
                if a % n == 0:
                    continue
                x = pow(a, d, n)
                if x == 1 or x == n - 1:
                    continue
                composite = True
                for _ in range(s - 1):
                    x = (x * x) % n
                    if x == n - 1:
                        composite = False
                        break
                if composite:
                    return False
            return True
        def kth_root_floor(n: int, k: int) -> int:
            if k == 1:
                return n
            lo, hi = 1, int(n ** (1.0 / k)) + 3
            while lo < hi:
                mid = (lo + hi + 1) // 2
                val = 1
                overflow = False
                for _ in range(k):
                    val *= mid
                    if val > n:
                        overflow = True
                        break
                if overflow or val > n:
                    hi = mid - 1
                else:
                    lo = mid
            return lo
        def prime_power_base(x: int) -> int:
            for e in range(60, 1, -1):
                r = kth_root_floor(x, e)
                if r >= 2:
                    v = 1
                    for _ in range(e):
                        v *= r
                        if v > x:
                            break
                    if v == x and is_probable_prime(r):
                        return r
            if is_probable_prime(x):
                return x
            return 0
        def solve_case(n: int, k: int, arr: list) -> list:
            groups = {}
            base_of = {}
            for x in arr:
                p = prime_power_base(x)
                if p:
                    groups.setdefault(p, []).append(x)
                    base_of[x] = p
            good = [p for p, lst in groups.items() if len(lst) >= 2]
            if not good:
                return []
            first_two = []
            extras = []
            for p in good:
                lst = sorted(groups[p])
                first_two.extend(lst[:2])
                extras.extend(lst[2:])
            comps = []
            for x in arr:
                if x in base_of:
                    continue
                y = x
                used = set()
                for p in good:
                    if y % p == 0:
                        used.add(p)
                        while y % p == 0:
                            y //= p
                    if y == 1:
                        break
                if y == 1:
                    comps.append((x, used))
            total_pairs = 2 * len(good)
            if total_pairs > k:
                good.sort(key=lambda p: len(groups[p]), reverse=True)
                if k % 2 == 0:
                    ans = []
                    need = k // 2
                    for p in good[:need]:
                        ans.extend(sorted(groups[p])[:2])
                    return ans
                else:
                    p3 = None
                    for p in good:
                        if len(groups[p]) >= 3:
                            p3 = p
                            break
                    if p3 is not None and k >= 3:
                        ans = sorted(groups[p3])[:3]
                        need_pairs = (k - 3) // 2
                        taken = 0
                        for p in good:
                            if p == p3:
                                continue
                            if taken < need_pairs:
                                ans.extend(sorted(groups[p])[:2])
                                taken += 1
                        if len(ans) == k:
                            return ans
                        return []
                    pair_comp = None
                    for x, used in comps:
                        if len(used) == 2:
                            pair_comp = (x, used)
                            break
                    if pair_comp is None or k < 5:
                        return []
                    x, used = pair_comp
                    used = list(used)
                    ans = [x]
                    for p in used:
                        ans.extend(sorted(groups[p])[:2])
                    need_pairs = (k - len(ans)) // 2
                    taken = 0
                    for p in good:
                        if p in used:
                            continue
                        if taken < need_pairs:
                            ans.extend(sorted(groups[p])[:2])
                            taken += 1
                    if len(ans) == k:
                        return ans
                    return []
            else:
                ans = list(first_two)
                need = k - len(ans)
                pool = list(extras) + [x for (x, _) in comps]
                if len(pool) < need:
                    return []
                ans.extend(pool[:need])
                return ans
        ans = solve_case(n, k, arr)
        if not ans or len(ans) != k or len(set(ans)) != k:
            print(0)
        else:
            print(" ".join(map(str, ans)))
        return stdout.getvalue()
    finally:
        stdin, stdout = backup_in, backup_out

# Smoke run
if __name__ == "__main__":
    n, k, arr = gen_case()
    out = solve_reference(n, k, arr)
    # Output is either 0 or k integers; we do not assert here to keep it general.
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Pick $k$ numbers so that every prime occurring among them is backed by at least two prime powers of that prime, then append only numbers made from those primes.}
\WHY{This tests your ability to characterize a global property (no unique primes in any suitable assignment) and reduce it to a structural selection constraint, with careful edge handling and 64-bit arithmetic.}
\CHECKLIST{
\begin{bullets}
\item Detect prime powers $p^e$ reliably for $x \le 10^{18}$.
\item Group by base prime; identify primes with at least two numbers.
\item Secure two numbers per chosen prime.
\item Append only extras and composites divisible solely by secured primes.
\item Handle odd $k$: prefer a triple or a composite with exactly two secured primes.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item No prime has two prime powers $\Rightarrow$ impossible.
\item $k$ odd and every group size equals $2$, no suitable composite $\Rightarrow$ impossible.
\item Numbers that are perfect powers of non-primes (e.g., $8^2=64$) must still be detected via the prime base $2^6$.
\item Very large $x$ near $10^{18}$: avoid overflow in power/root checks.
\item Composites using any prime outside secured set must be rejected.
\item Duplicate avoidance: input numbers are distinct; do not output repeats.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using floating roots can misclassify due to precision; use integer binary search.
\item Incomplete Miller–Rabin bases can produce false primes; use a safe base set for 64-bit.
\item Forgetting that $p^1$ is also a prime power; include primes themselves.
\item Mishandling odd $k$ when only pairs exist; need triple or a 2-prime composite.
\item Accidentally including a composite that uses an unsecured prime.
\item Time blowups from full factorization; only divide by known secured primes.
\end{bullets}
}
\FAILMODES{Brute force fails on $n=1000$. Greedy that appends arbitrary composites breaks the invariant if it introduces a new prime without two backing prime powers. Our method safeguards against this by filtering composites.}
\ELI{We back every prime in our selection with at least two pure powers of that prime so that any choice of divisors across positions cannot isolate a prime. With the backing in place, we can safely add more numbers built only from those backed primes.}
\NotePages{3}

\end{document}