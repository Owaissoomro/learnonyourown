% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Levko and Sets}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/360/D}}
\LINE{DIFFICULTY / RATING}{2600}
\STATEMENT{Levko loves all sorts of sets very much.

Levko has two arrays of integers $a_1,a_2,\ldots,a_n$ and $b_1,b_2,\ldots,b_m$ and a prime number $p$. Today he generates $n$ sets. The generation process for the $i$-th set is as follows:
\begin{enumerate}
\item Initially, the set contains the single number $1$.
\item Take any element $c$ from this set. For all $j$ ($1 \le j \le m$), if the number $\bigl(c \cdot a_i^{\,b_j}\bigr) \bmod p$ does not occur in the set, add it to the set.
\item Repeat step 2 as long as at least one new element can be added.
\end{enumerate}
Levko wonders how many numbers belong to at least one set. That is, he wants the size of the union of the $n$ generated sets.

Input: The first line contains three integers $n$, $m$ and $p$ ($1 \le n \le 10^4$, $1 \le m \le 10^5$, $2 \le p \le 10^9$), $p$ is prime.

The second line contains space-separated integers $a_1,a_2,\ldots,a_n$ ($1 \le a_i < p$). The third line contains space-separated integers $b_1,b_2,\ldots,b_m$ ($1 \le b_i \le 10^9$).

Output: Print a single integer — the size of the union of the sets.}
\BREAKDOWN{Interpret each generated set as the subgroup of $\mathbb{Z}_p^\times$ generated by $\{a_i^{b_j}\}_j$. The union size equals the number of residues in the union of these subgroups. Reduce the problem to arithmetic on divisors of $p-1$ and Euler's totient counts.}
\ELI{Each set is the closure under multiplying by some fixed list of numbers modulo $p$; in a cyclic group this closure is a subgroup, and the union size can be counted over the divisor lattice of $p-1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case:
\begin{bullets}
\item Integers $n,m,p$ with $1 \le n \le 10^4$, $1 \le m \le 10^5$, prime $p$, $2 \le p \le 10^9$.
\item Array $a$ of length $n$, with $1 \le a_i < p$.
\item Array $b$ of length $m$, with $1 \le b_j \le 10^9$.
\end{bullets}}
\OUTPUTS{One integer: the size of the union of the $n$ generated sets.}
\SAMPLES{
Example 1:
\[
\begin{aligned}
n&=1,~m=1,~p=7\\
a&=[3],~b=[1]\\
\text{Answer }&=6
\end{aligned}
\]
Example 2:
\[
\begin{aligned}
n&=2,~m=2,~p=7\\
a&=[6,5],~b=[1,2]\\
\text{Answer }&=6
\end{aligned}
\]
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=\mathbb{Z}_p^\times$ be the multiplicative group modulo $p$, which is cyclic of order $M=p-1$. For each $i$, let $S_i=\{a_i^{b_j}\bmod p: 1\le j\le m\} \subseteq G$ and $H_i=\langle S_i\rangle$ be the subgroup generated by $S_i$. We seek $\left|\bigcup_{i=1}^n H_i\right|$.}
\varmapStart
\var{p}{prime modulus}
\var{M}{group order $M=p-1$}
\var{G}{greatest common divisor $G=\gcd(b_1,\ldots,b_m)$}
\var{\operatorname{ord}(x)}{multiplicative order of $x$ in $\mathbb{Z}_p^\times$}
\var{H_i}{subgroup generated by $\{a_i^{b_j}\}_j$}
\var{D}{set of divisors $d_i$ of $M$ corresponding to subgroups $H_i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{For each } i:\quad \operatorname{ord}(a_i)\mid M,\quad
h_i \coloneqq \gcd\bigl(\operatorname{ord}(a_i),~G\bigr),\\
&\text{then } \langle a_i^{b_1},\ldots,a_i^{b_m}\rangle = \langle a_i^{h_i}\rangle \text{ has size } \frac{\operatorname{ord}(a_i)}{\gcd(\operatorname{ord}(a_i),h_i)}.\\
&\text{In the global cyclic group of size }M,\text{ this subgroup equals } \{g^{t d_i}:0\le t< M/d_i\} \\
&\text{for some primitive root } g,\text{ with } d_i = \frac{M}{\operatorname{ord}(a_i)/\gcd(\operatorname{ord}(a_i),h_i)}.\\
&\text{Let } \mathcal{D}=\{d_i\}\subseteq \operatorname{Div}(M). \\
&\left|\bigcup_{i=1}^n H_i\right|= \sum_{\substack{t\mid M\\ \exists~d\in\mathcal{D}:~d\mid t}} \varphi\!\left(\frac{M}{t}\right),
\end{aligned}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item $p$ is prime $\Rightarrow$ $G=\mathbb{Z}_p^\times$ is cyclic of order $M=p-1$.
\item Each $H_i$ is a subgroup of $G$ determined uniquely by a divisor of $M$.
\item Counting over the divisor lattice uses that numbers $k\in[0,M-1]$ with $\gcd(k,M)=t$ are exactly $\varphi(M/t)$ many.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item Subgroup generated by $\{a_i^{b_j}\}_j$ depends only on $\gcd(b_1,\ldots,b_m)$ and $\operatorname{ord}(a_i)$.
\item Inclusion of subgroups corresponds to divisibility among their associated $d$-parameters: $S(d')\subseteq S(d)$ iff $d\mid d'$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the closure for each $i$ by BFS from $1$ under multipliers $\{a_i^{b_j}\bmod p\}_j$ and count the union.}
\ASSUMPTIONS{Feasible only for tiny $p$ due to $O(p\cdot m)$ per set and $n$ sets.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $i$, compute multipliers $M_i=\{a_i^{b_j}\bmod p\}_j$.
\item BFS/DFS: start from $1$, repeatedly insert $c\cdot x\bmod p$ for $x\in M_i$.
\item Union all visited residues across $i$ and output its size.
\end{algosteps}
\COMPLEXITY{Let $U$ be the union size. Worst case explores $p-1$ states per $i$ with $m$ edges per state: prohibitive.
\[
\begin{aligned}
T(n) &\approx \sum_{i=1}^n O\bigl((p-1)\cdot m\bigr) = O\bigl(n m p\bigr),\\
S(n) &= O(p).
\end{aligned}
\]
}
\CORRECTNESS{Closure under all multipliers exactly matches the subgroup generated by $\{a_i^{b_j}\}_j$. The union of visited nodes across $i$ equals the desired union.}
\EDGECASES{Duplicate multipliers; $a_i\equiv 1$; repeated $b_j$; ensure no inclusion of $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    return data

def brute_union_size(n, m, p, A, B):
    # Only for tiny p (used in tests).
    union = set()
    for ai in A:
        mults = set(pow(ai, bj, p) for bj in B)
        # Remove 0 if ever appears (it should not since 1 <= ai < p and p is prime).
        mults.discard(0)
        seen = set([1])
        dq = deque([1])
        while dq:
            c = dq.popleft()
            for x in mults:
                y = (c * x) % p
                if y not in seen:
                    seen.add(y)
                    dq.append(y)
        union |= seen
    # 0 is never generated (starts at 1, multiply in Z_p^*).
    return len(union)

def solve_case(data):
    it = iter(map(int, data))
    n = next(it); m = next(it); p = next(it)
    A = [next(it) for _ in range(n)]
    B = [next(it) for _ in range(m)]
    # Baseline is too slow in general; only run for tiny p in tests.
    return str(brute_union_size(n, m, p, A, B))

def main():
    data = read_input()
    if not data:
        # Self-checks on tiny primes.
        assert brute_union_size(1, 1, 7, [3], [1]) == 6  # generator
        assert brute_union_size(1, 1, 7, [6], [1]) == 2  # order 2 subgroup {1,6}
        assert brute_union_size(2, 2, 7, [6, 5], [1, 2]) == 6
        print("OK")
    else:
        print(solve_case(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The asserts in main use $p=7$ to confirm subgroup sizes and unions.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Orders + Divisor-Lattice Counting}
\WHICHFORMULA{Avoid discrete logs: in any cyclic group, $\langle a^{b_1},\ldots,a^{b_m}\rangle=\langle a^{\gcd(b_1,\ldots,b_m,\operatorname{ord}(a))}\rangle$. Compute $\operatorname{ord}(a_i)$ by factoring $p-1$ once and testing divisibility via fast exponentiation.}
\ASSUMPTIONS{We can factor $M=p-1$ in $O(\sqrt{M})$, feasible for $p\le 10^9$. The number of divisors of $M$ is modest.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Factor $M=p-1$ and enumerate its divisors $t\mid M$; precompute $\varphi(M/t)$ for all $t$.
\item Let $G=\gcd(b_1,\ldots,b_m)$.
\item For each $a_i$, compute $\operatorname{ord}(a_i)$ by successive division of $M$ by its prime factors while testing $a_i^{\text{ord}/q}\equiv 1\bmod p$.
\item Let $h_i=\gcd(\operatorname{ord}(a_i),G)$, subgroup size is $s_i=\operatorname{ord}(a_i)/h_i$; map it to divisor $d_i=M/s_i$ and collect $\mathcal{D}=\{d_i\}$.
\item Mark all $t\mid M$ that are multiples of some $d\in\mathcal{D}$; sum $\varphi(M/t)$ over marked $t$.
\end{algosteps}
\COMPLEXITY{Factoring $M$ costs $O(\sqrt{M})$. Each $\operatorname{ord}(a_i)$ costs $O(r\log p)$ pow-mods for $r=$ number of distinct prime factors of $M$ (including multiplicities for exponent stripping). Counting over divisors costs $O(\tau(M)\cdot |\mathcal{D}|)$.
\[
\begin{aligned}
T(n) &\approx O\bigl(\sqrt{M} + n\cdot r\cdot \log M + \tau(M)\cdot |\mathcal{D}|\bigr),\\
S(n) &= O(\tau(M)).
\end{aligned}
\]
}
\CORRECTNESS{By group theory in cyclic groups, each generated set is a subgroup determined solely by $\operatorname{ord}(a_i)$ and $G$. Every subgroup of $\mathbb{Z}_p^\times$ corresponds to a unique divisor of $M$, and counting via $\sum_{t:~\exists d\mid t}\varphi(M/t)$ matches the union of multiples on the exponent side.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
import math

def read_input():
    return sys.stdin.read().strip().split()

def factorize(n):
    fac = []
    d = 2
    while d * d <= n:
        if n % d == 0:
            e = 0
            while n % d == 0:
                n //= d
                e += 1
            fac.append((d, e))
        d += 1 if d == 2 else 2  # small skip optimization
    if n > 1:
        fac.append((n, 1))
    return fac

def all_divisors_from_factorization(fac):
    divs = [1]
    for p, e in fac:
        cur = []
        pe = 1
        for _ in range(e + 1):
            for v in divs:
                cur.append(v * pe)
            pe *= p
        divs = cur
    divs.sort()
    return divs

def phi_of_x_from_fac_of_M(x, facM):
    # Compute phi(x) using prime factors present in facM.
    res = x
    for p, _ in facM:
        if x % p == 0:
            res = res // p * (p - 1)
            while x % p == 0:
                x //= p
    # x could be 1 here; if >1 it is a prime factor not in facM (shouldn't happen since x | M).
    if x > 1:
        res = res // x * (x - 1)
    return res

def multiplicative_order(a, p, M, facM):
    # Compute ord of a modulo p, given M = p-1 and factorization of M.
    if a % p == 0:
        return 1  # not expected since 1 <= a < p
    ord_val = M
    for q, e in facM:
        for _ in range(e):
            if ord_val % q == 0:
                cand = ord_val // q
                if pow(a, cand, p) == 1:
                    ord_val = cand
                else:
                    break
    return ord_val

def union_size(n, m, p, A, B):
    M = p - 1
    facM = factorize(M)
    divs = all_divisors_from_factorization(facM)
    # Precompute phi(M/t) for all t | M
    phi_M_over_t = {}
    for t in divs:
        x = M // t
        phi_M_over_t[t] = phi_of_x_from_fac_of_M(x, facM)

    G = 0
    for bj in B:
        G = math.gcd(G, bj)

    D = set()
    for ai in A:
        ord_ai = multiplicative_order(ai % p, p, M, facM)
        hi = math.gcd(ord_ai, G)
        s_i = ord_ai // hi
        d_i = M // s_i
        D.add(d_i)

    # Mark t that have some d in D dividing t
    covered = set()
    for t in divs:
        for d in D:
            if t % d == 0:
                covered.add(t)
                break

    ans = sum(phi_M_over_t[t] for t in covered)
    return ans

def solve_case(data):
    it = iter(map(int, data))
    n = next(it); m = next(it); p = next(it)
    A = [next(it) for _ in range(n)]
    B = [next(it) for _ in range(m)]
    return str(union_size(n, m, p, A, B))

def main():
    data = read_input()
    if not data:
        # Deterministic tests on tiny primes against brute force
        assert union_size(1, 1, 7, [3], [1]) == 6
        assert union_size(1, 1, 7, [6], [1]) == 2
        assert union_size(2, 2, 7, [6, 5], [1, 2]) == 6
        # Extra: change gcd of B shrinks subgroup
        assert union_size(1, 2, 7, [3], [2, 4]) == 3
        print("OK")
    else:
        print(solve_case(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Self-checks verify known subgroup sizes and that increasing $\gcd(b_j)$ shrinks generated subgroups accordingly.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Order-Stripping + Totient Summation (Provably Optimal Here)}
\WHICHFORMULA{Use prime factorization of $M=p-1$ to strip orders $\operatorname{ord}(a_i)$ by trial division and fast power, map to divisor parameters $d_i$, then count with $\sum_{t:\exists d\mid t}\varphi(M/t)$.}
\ASSUMPTIONS{Cyclic group $\mathbb{Z}_p^\times$ and unique subgroups per divisor of $M$. Factorization and divisor enumeration are tractable for $p\le 10^9$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Factor $M=p-1$; list all divisors $t\mid M$. Precompute $\varphi(M/t)$.
\item Compute $G=\gcd(b_1,\ldots,b_m)$.
\item For each $a_i$, compute $\operatorname{ord}(a_i)$ by repeatedly dividing $M$ by its prime factors when $a_i^{\text{ord}/q}\equiv 1$.
\item Build $d_i=M/(\operatorname{ord}(a_i)/\gcd(\operatorname{ord}(a_i),G))$ and deduplicate.
\item Mark all $t$ divisible by some $d_i$ and sum $\varphi(M/t)$.
\end{algosteps}
\OPTIMALITY{We avoid discrete logs entirely; counting over divisors uses only $\tau(M)$ states. Any algorithm must at least read all $a_i$ and $b_j$, and factorizing $p-1$ is necessary to distinguish subgroups.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= O\bigl(\sqrt{p} + n\cdot r\cdot \log p + \tau(p-1)\cdot |\mathcal{D}|\bigr),\quad r\le \log_2(p-1),\\
S(n) &= O(\tau(p-1)).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
import math

def read_input():
    return sys.stdin.read().strip().split()

def factorize(n):
    fac = []
    d = 2
    while d * d <= n:
        if n % d == 0:
            e = 0
            while n % d == 0:
                n //= d
                e += 1
            fac.append((d, e))
        d += 1 if d == 2 else 2
    if n > 1:
        fac.append((n, 1))
    return fac

def all_divisors_from_factorization(fac):
    divs = [1]
    for p, e in fac:
        cur = []
        pe = 1
        for _ in range(e + 1):
            for v in divs:
                cur.append(v * pe)
            pe *= p
        divs = cur
    divs.sort()
    return divs

def phi_of_x_from_fac_of_M(x, facM):
    res = x
    for p, _ in facM:
        if x % p == 0:
            res = res // p * (p - 1)
            while x % p == 0:
                x //= p
    if x > 1:
        res = res // x * (x - 1)
    return res

def multiplicative_order(a, p, M, facM):
    if a % p == 0:
        return 1
    ord_val = M
    for q, e in facM:
        for _ in range(e):
            if ord_val % q == 0:
                cand = ord_val // q
                if pow(a, cand, p) == 1:
                    ord_val = cand
                else:
                    break
    return ord_val

def solve_all(data):
    it = iter(map(int, data))
    n = next(it); m = next(it); p = next(it)
    A = [next(it) for _ in range(n)]
    B = [next(it) for _ in range(m)]

    M = p - 1
    facM = factorize(M)
    divs = all_divisors_from_factorization(facM)

    phi_M_over_t = {}
    for t in divs:
        x = M // t
        phi_M_over_t[t] = phi_of_x_from_fac_of_M(x, facM)

    G = 0
    for bj in B:
        G = math.gcd(G, bj)

    D = set()
    for ai in A:
        ord_ai = multiplicative_order(ai % p, p, M, facM)
        hi = math.gcd(ord_ai, G)
        s_i = ord_ai // hi
        d_i = M // s_i
        D.add(d_i)

    covered = set()
    for t in divs:
        for d in D:
            if t % d == 0:
                covered.add(t)
                break

    ans = sum(phi_M_over_t[t] for t in covered)
    return str(ans)

def main():
    data = read_input()
    if not data:
        # Exactly 3 deterministic mini-tests
        assert solve_all(list(map(str, [1,1,7, 3, 1]))) == "6"
        assert solve_all(list(map(str, [1,1,7, 6, 1]))) == "2"
        assert solve_all(list(map(str, [2,2,7, 6,5, 1,2]))) == "6"
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts cover: generator case; small subgroup; and union covering the full group.}
\RESULT{Outputs the size of $\bigcup_{i=1}^n H_i \subseteq \mathbb{Z}_p^\times$. There are no tie-breakers.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-check the optimal method against the brute-force BFS for small primes. Test variations in $\gcd(b_j)$ and in $a_i$ orders.}
\LINE{CROSS-CHECKS}{On tiny primes ($p\le 29$), randomly craft $a$ and $b$, compare brute force union with optimal counting.}
\LINE{EDGE-CASE GENERATOR}{Generate cases where $a_i$ has order $1,2,$ or maximal $p-1$; vary $G=\gcd(b)$ to be $1$ and greater divisors of $p-1$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import sys, math
from collections import deque

def brute(n, m, p, A, B):
    U = set()
    for ai in A:
        mults = set(pow(ai, bj, p) for bj in B)
        mults.discard(0)
        seen = set([1])
        dq = deque([1])
        while dq:
            c = dq.popleft()
            for x in mults:
                y = (c * x) % p
                if y not in seen:
                    seen.add(y); dq.append(y)
        U |= seen
    return len(U)

def run_cross_checks():
    # Fixed crafted cases (no randomness)
    cases = []
    cases.append((1,1,7,[3],[1]))
    cases.append((1,1,7,[6],[1]))
    cases.append((2,2,7,[6,5],[1,2]))
    cases.append((1,2,13,[2],[2,4]))  # G=2, order of 2 is 12; subgroup size 6
    for (n,m,p,A,B) in cases:
        from math import gcd
        ans_brute = brute(n,m,p,A,B)
        # Use final solver
        data = list(map(str, [n,m,p] + A + B))
        from sys import setrecursionlimit
        setrecursionlimit(1<<20)
        # inline solve_all from above (duplicated minimal parts)
        def factorize(n):
            fac=[]; d=2
            while d*d<=n:
                if n%d==0:
                    e=0
                    while n%d==0: n//=d; e+=1
                    fac.append((d,e))
                d += 1 if d==2 else 2
            if n>1: fac.append((n,1))
            return fac
        def all_divs(fac):
            divs=[1]
            for p,e in fac:
                cur=[]; pe=1
                for _ in range(e+1):
                    for v in divs: cur.append(v*pe)
                    pe*=p
                divs=cur
            divs.sort()
            return divs
        def phi_from_M(x, facM):
            res=x
            for p,_ in facM:
                if x%p==0:
                    res = res//p*(p-1)
                    while x%p==0: x//=p
            if x>1: res = res//x*(x-1)
            return res
        def ord_ai(a,p,M,facM):
            ordv=M
            for q,e in facM:
                for _ in range(e):
                    if ordv%q==0 and pow(a, ordv//q, p)==1:
                        ordv//=q
                    else:
                        break
            return ordv
        M=p-1; facM=factorize(M); divs=all_divs(facM)
        phi={t:phi_from_M(M//t, facM) for t in divs}
        G=0
        for bj in B: G=math.gcd(G,bj)
        D=set()
        for ai in A:
            o=ord_ai(ai%p,p,M,facM)
            hi=math.gcd(o,G); s=o//hi; d=M//s
            D.add(d)
        covered=set()
        for t in divs:
            for d in D:
                if t%d==0: covered.add(t); break
        ans_fast = sum(phi[t] for t in covered)
        assert ans_brute == ans_fast, (n,m,p,A,B,ans_brute,ans_fast)
    print("Cross-checks passed.")

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
import math

def read_input():
    return sys.stdin.read().strip().split()

def factorize(n):
    fac = []
    d = 2
    while d * d <= n:
        if n % d == 0:
            e = 0
            while n % d == 0:
                n //= d
                e += 1
            fac.append((d, e))
        d += 1 if d == 2 else 2
    if n > 1:
        fac.append((n, 1))
    return fac

def all_divisors_from_factorization(fac):
    divs = [1]
    for p, e in fac:
        cur = []
        pe = 1
        for _ in range(e + 1):
            for v in divs:
                cur.append(v * pe)
            pe *= p
        divs = cur
    divs.sort()
    return divs

def phi_of_x_from_fac_of_M(x, facM):
    res = x
    for p, _ in facM:
        if x % p == 0:
            res = res // p * (p - 1)
            while x % p == 0:
                x //= p
    if x > 1:
        res = res // x * (x - 1)
    return res

def multiplicative_order(a, p, M, facM):
    if a % p == 0:
        return 1
    ord_val = M
    for q, e in facM:
        for _ in range(e):
            if ord_val % q == 0:
                cand = ord_val // q
                if pow(a, cand, p) == 1:
                    ord_val = cand
                else:
                    break
    return ord_val

def solve_all(data):
    it = iter(map(int, data))
    n = next(it); m = next(it); p = next(it)
    A = [next(it) for _ in range(n)]
    B = [next(it) for _ in range(m)]

    M = p - 1
    facM = factorize(M)
    divs = all_divisors_from_factorization(facM)

    phi_M_over_t = {}
    for t in divs:
        x = M // t
        phi_M_over_t[t] = phi_of_x_from_fac_of_M(x, facM)

    G = 0
    for bj in B:
        G = math.gcd(G, bj)

    D = set()
    for ai in A:
        ord_ai = multiplicative_order(ai % p, p, M, facM)
        hi = math.gcd(ord_ai, G)
        s_i = ord_ai // hi
        d_i = M // s_i
        D.add(d_i)

    covered = set()
    for t in divs:
        for d in D:
            if t % d == 0:
                covered.add(t)
                break

    ans = sum(phi_M_over_t[t] for t in covered)
    return str(ans)

def main():
    data = read_input()
    if not data:
        # Minimal asserts
        assert solve_all(list(map(str, [1,1,7, 3, 1]))) == "6"
        assert solve_all(list(map(str, [1,1,7, 6, 1]))) == "2"
        assert solve_all(list(map(str, [2,2,7, 6,5, 1,2]))) == "6"
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce each generated set to a subgroup of $\mathbb{Z}_p^\times$ determined by $\operatorname{ord}(a_i)$ and $G=\gcd(b)$, then count the union via the divisor lattice of $p-1$.}
\WHY{Appears in interviews where algebraic structure helps collapse a huge search to number-theoretic counting.}
\CHECKLIST{
\begin{bullets}
\item Factor $M=p-1$.
\item Compute $G=\gcd(b_1,\ldots,b_m)$.
\item For each $a_i$, strip $\operatorname{ord}(a_i)$ using $M$'s prime factors.
\item Map to $d_i=M/(\operatorname{ord}(a_i)/\gcd(\operatorname{ord}(a_i),G))$.
\item Enumerate $t\mid M$, mark those with some $d_i\mid t$, sum $\varphi(M/t)$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $a_i=1$ $\Rightarrow$ $\operatorname{ord}(a_i)=1$, contributes $d_i=M$ (only $\{1\}$).
\item All $b_j$ equal $\Rightarrow$ $G=b_1$.
\item Large repeated $a_i$ values; deduplicate $d_i$.
\item Prime $p=2$ gives $M=1$; answer is $1$.
\item When some $b_j=0$ (not allowed here), would need careful handling; here $1\le b_j$.
\item Ensure no inclusion of residue $0$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to divide $\operatorname{ord}(a_i)$ repeatedly by the same prime factor.
\item Mixing up $s_i$ (subgroup size) and $d_i$ (divisor parameter in exponent space).
\item Double-counting when summing without restricting $t\mid M$.
\item Using discrete logs unnecessarily (too slow for many $a_i$).
\item Overflow in languages without big-int; use 64-bit safely in Python.
\item Missing that $\varphi(M/t)$ counts numbers with $\gcd(\cdot,M)=t$.
\end{bullets}}
\FAILMODES{Naive BFS is exponential in practice for large $p$. Discrete-log approaches per $a_i$ are too slow; avoid BSGS per query. The order-stripping approach survives due to $O(\sqrt{p})$ factorization and $O(\tau(M))$ divisor work.}
\ELI{The multiplicative group modulo a prime is a cycle. Each $i$-th set is some regularly spaced subset of that cycle. The union is just all cycle positions divisible by certain step sizes, and counting them uses Euler's totient on the divisor lattice.}
\NotePages{3}

\end{document}