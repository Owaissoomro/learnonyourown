% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Conference}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1965/F}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{You have been asked to organize a very important art conference. The first step is to choose the dates.

The conference must last for a certain number of consecutive days. Each day, one lecturer must perform, and the same lecturer cannot perform more than once.

You asked $n$ potential lecturers if they could participate in the conference. Lecturer $i$ indicated that they could perform on any day from $l_i$ to $r_i$ inclusive.

A certain segment of days can be chosen as the conference dates if there is a way to assign an available lecturer to each day of the segment, assigning each lecturer to no more than one day.

For each $k$ from $1$ to $n$, find how many ways there are to choose a segment of $k$ consecutive days as the conference dates.

Input:
The first line of input contains one integer $n$ — the number of potential lecturers ($1 \le n \le 2 \cdot 10^5$).

Each of the next $n$ lines contains two integers $l_i$ and $r_i$ — the segment of available days for the $i$th lecturer ($1 \le l_i \le r_i \le 2 \cdot 10^5$).

Output:
Print $n$ integers, where the $k$th number denotes the number of ways to select a segment of $k$ consecutive days as conference dates.

Note:
In the first testcase, a one-day conference can be organized on any of the days from $1$ to $6$. A two-day conference can be organized from day $2$ to day $3$, as well as from day $4$ to day $5$.

In the second testcase, five lecturers can perform only from day $1$ to day $3$, so it will not be possible to organize a conference longer than three days.}
\BREAKDOWN{We must count, for every length $k$, the number of day intervals $[L,R]$ with $R-L+1=k$ for which a matching exists from days to lecturers' availability intervals. Use an interval-graph Hall condition that reduces to a sliding-window min/max inequality computable in linear time over the day axis, then aggregate counts by length via a difference array.}
\ELI{Transform feasibility to comparing a sliding minimum of a prefix-based array $P$ with a sliding maximum of a suffix-based array $Q$, then sweep two pointers to get maximal valid $R$ per $L$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integer $n$ ($1 \le n \le 2 \cdot 10^5$).
- $n$ lines: integers $(l_i,r_i)$ with $1 \le l_i \le r_i \le 2 \cdot 10^5$.}
\OUTPUTS{Print $n$ space-separated integers. The $k$th integer equals the number of feasible segments of length $k$ (i.e., intervals $[L,R]$ with $R-L+1=k$) such that there exists an injective assignment of lecturers to the days $L,L+1,\ldots,R$.}
\SAMPLES{Example 1:
- $n=2$, intervals $(1,1)$, $(2,2)$.
- Feasible segments: $[1,1],[2,2],[1,2]$. Output: $2~1$.

Example 2:
- $n=3$, intervals $(1,3),(1,3),(1,3)$.
- Feasible segments: all $[L,R]\subseteq[1,3]$ with $|[L,R]|\le 3$. Counts: $k=1$: $3$, $k=2$: $2$, $k=3$: $1$. Output: $3~2~1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Days are integers on a line. Each lecturer $i$ contributes an interval $[l_i,r_i]$. For a candidate segment $[L,R]$, we need an injective mapping from days to intervals that cover them. By Hall's theorem specialized to interval families, feasibility is equivalent to: for every subsegment $[a,b]\subseteq[L,R]$, the number of lecturer intervals intersecting $[a,b]$ is at least $b-a+1$.}
\varmapStart
\var{n}{number of lecturers}
\var{[l_i,r_i]}{availability of lecturer $i$}
\var{C([a,b])}{number of intervals intersecting $[a,b]$}
\var{L\_p[b]}{count of lecturers with $l_i \le b$}
\var{R\_p[t]}{count of lecturers with $r_i \le t$}
\var{P[b]}{$L\_p[b]-b$}
\var{Q[t]}{$R\_p[t]-t$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
C([a,b]) = \#\{i:\,l_i\le b\} - \#\{i:\,r_i < a\} = L_p[b] - R_p[a-1].
\end{BreakableEquation*}
Feasibility for $[L,R]$ is
\begin{BreakableEquation*}
\min_{L\le a\le b\le R}\big(C([a,b])-(b-a+1)\big)\ \ge\ 0.
\end{BreakableEquation*}
Using $C([a,b]) = L_p[b]-R_p[a-1]$,
\begin{BreakableEquation*}
C([a,b])-(b-a+1) = (L_p[b]-b) - (R_p[a-1]-(a-1)) = P[b]-Q[a-1].
\end{BreakableEquation*}
Thus $[L,R]$ is feasible iff
\begin{BreakableEquation*}
\min_{b\in[L,R]} P[b]\ \ge\ \max_{t\in[L-1,R-1]} Q[t].
\end{BreakableEquation*}
}
\ASSUMPTIONS{Days live in $\{1,\ldots,M\}$ with $M=\max_i r_i$. Any feasible segment must end at $R\le M$. Empty ranges have $\min=+\infty$ and $\max=-\infty$ by convention.}
\INVARIANTS{
- Extending $R$ weakly decreases $\min P$ and weakly increases $\max Q$; hence for fixed $L$, feasible $R$ form a prefix interval.
- For interval families, Hall's condition reduces to contiguous subsets; checking all subsegments suffices.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the day-by-day greedy matching with a min-heap of available lecturers (by earliest end). For each candidate $[L,R]$, simulate: at each day $d$, add all lecturers with $l_i\le d$ and pick one with smallest $r_i\ge d$; if heap empty, fail.}
\ASSUMPTIONS{Feasibility for fixed $[L,R]$ can be decided in $O((R-L+1)\log n)$ by the standard earliest-deadline-first greedy, which is optimal for intervals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $L$, for each $R\ge L$, simulate greedy matching across days $d=L..R$ using a min-heap keyed by $r_i$.
\item Count $[L,R]$ feasible if the heap never empties and selected $r_i\ge d$ at each step.
\item Aggregate counts per length $k=R-L+1$.
\end{algosteps}
\COMPLEXITY{Naively $O(M^2 \log n)$ where $M=\max r_i$; intractable for constraints, but acceptable for validating small instances.}
\[
\begin{aligned}
T(M,n) &\approx \sum_{L=1}^{M}\sum_{R=L}^{M} (R-L+1)\log n \\
       &= \Theta(M^3\log n)\ \text{(worst-case)}.
\end{aligned}
\]
\CORRECTNESS{Earliest-finish greedy maximizes the number of matched days for interval-to-point matching. Simulating per window is exact by optimality.}
\EDGECASES{Days with zero coverage; multiple lecturers starting/ending on same day; degenerate single-day windows; maximal coordinate $M$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from heapq import heappush, heappop

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    segs = []
    for _ in range(n):
        l = int(next(it)); r = int(next(it))
        segs.append((l, r))
    return n, segs

def greedy_feasible_window(L, R, intervals):
    # Greedy earliest-deadline-first within window [L, R]
    # Build day-indexed starts for speed on small inputs
    starts = {}
    for i, (l, r) in enumerate(intervals):
        # lecturer is available on any day d with l <= d <= r
        # We can consider them when day d >= l
        starts.setdefault(l, []).append(r)
    heap = []
    # To avoid O(n) scanning each day, we rely on starts dict
    # but if a lecturer l < L, we need to insert them on day L
    # So pre-insert all lecturers with l <= L
    init_list = []
    for (l, r) in intervals:
        if l <= L and r >= L:
            init_list.append(r)
    for rr in init_list:
        heappush(heap, rr)
    # We have added those whose l <= L; those with l > L will be added on their l
    # Note: to avoid double-inserting, we skip adding from starts for days <= L.
    for day in range(L, R + 1):
        if day > L:
            # Add all who start today
            for rr in starts.get(day, []):
                if rr >= day:
                    heappush(heap, rr)
        # Remove expired
        while heap and heap[0] < day:
            heappop(heap)
        if not heap:
            return False
        heappop(heap)  # assign one lecturer today
    return True

def brute_count(n, intervals):
    if n == 0:
        return []
    M = max(r for _, r in intervals)
    res = [0] * (n + 1)
    for L in range(1, M + 1):
        for R in range(L, M + 1):
            k = R - L + 1
            if k > n:
                break
            if greedy_feasible_window(L, R, intervals):
                res[k] += 1
    return res[1:]

def solve_all(n, intervals):
    # Slow baseline wrapper
    return brute_count(n, intervals)

def main():
    # Basic self-checks with tiny inputs
    n1, segs1 = 2, [(1,1),(2,2)]
    assert solve_all(n1, segs1) == [2,1]
    n2, segs2 = 3, [(1,3),(1,3),(1,3)]
    assert solve_all(n2, segs2) == [3,2,1]
    # If real input present, run (beware: baseline is slow)
    n, segs = read_input()
    if n:
        ans = solve_all(n, segs)
        print(" ".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The asserts validate obvious small cases. For larger random tests, see Approach C's tests comparing optimal to brute on tiny instances.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Checking Feasibility via Min/Max and Segment Trees}
\WHICHFORMULA{From $C([a,b]) = L_p[b]-R_p[a-1]$, feasibility of $[L,R]$ is $\min_{b\in[L,R]} P[b] \ge \max_{t\in[L-1,R-1]} Q[t]$ where $P[b]=L_p[b]-b$ and $Q[t]=R_p[t]-t$. We can answer queries with two range queries per window.}
\ASSUMPTIONS{Precompute $P,Q$ over $[1..M]$ and support range min and max queries in $O(\log M)$ using segment trees or sparse tables.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $L_p, R_p$ in $O(M)$ from frequency arrays of $l_i$ and $r_i$.
\item Form arrays $P[b]=L_p[b]-b$ and $Q[t]=R_p[t]-t$.
\item For each $L$, binary search maximal $R$ such that $\min P[L..R] \ge \max Q[L-1..R-1]$ using two segment trees (min for $P$, max for $Q$).
\item Aggregate contributions for lengths $k\le n$ with a difference array.
\end{algosteps}
\COMPLEXITY{Building: $O(M)$. Each $L$ does $O(\log M)$ range queries inside an $O(\log M)$ binary search: $O(M \log^2 M)$.}
\[
\begin{aligned}
T(M) &= O(M) + O(M \log^2 M).
\end{aligned}
\]
\CORRECTNESS{Directly enforces the derived necessary-and-sufficient inequality on $P$ and $Q$. Binary search is valid since feasibility in $R$ is monotone for fixed $L$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
import sys
from math import inf

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    segs = []
    M = 0
    for _ in range(n):
        l = int(next(it)); r = int(next(it))
        segs.append((l, r))
        M = max(M, r)
    return n, segs

class SegTree:
    def __init__(self, arr, op, e):
        n = len(arr)
        self.N = 1
        while self.N < n:
            self.N <<= 1
        self.e = e
        self.op = op
        self.st = [e] * (2*self.N)
        for i, v in enumerate(arr):
            self.st[self.N + i] = v
        for i in range(self.N - 1, 0, -1):
            self.st[i] = op(self.st[2*i], self.st[2*i+1])
    def query(self, l, r):
        if l > r:
            return self.e
        l += self.N; r += self.N
        resl, resr = self.e, self.e
        while l <= r:
            if (l & 1) == 1:
                resl = self.op(resl, self.st[l]); l += 1
            if (r & 1) == 0:
                resr = self.op(self.st[r], resr); r -= 1
            l >>= 1; r >>= 1
        return self.op(resl, resr)

def solve_all(n, intervals):
    if n == 0:
        return []
    M = max(r for _, r in intervals)
    freqL = [0]*(M+1)
    freqR = [0]*(M+1)
    for l, r in intervals:
        freqL[l] += 1
        freqR[r] += 1
    Lp = [0]*(M+1)
    Rp = [0]*(M+1)
    for i in range(1, M+1):
        Lp[i] = Lp[i-1] + freqL[i]
        Rp[i] = Rp[i-1] + freqR[i]
    P = [0]*(M+1)  # 1..M
    for b in range(1, M+1):
        P[b] = Lp[b] - b
    Q = [0]*M  # 0..M-1
    for t in range(0, M):
        Q[t] = Rp[t] - t
    stP = SegTree(P[1:], min, inf)  # index 0..M-1 corresponds to b=1..M
    stQ = SegTree(Q, max, -10**18)  # 0..M-1
    diff = [0]*(n+2)
    for L in range(1, M+1):
        lo, hi, best = L, M, L-1
        while lo <= hi:
            mid = (lo + hi) // 2
            minP = stP.query(L-1, mid-1)
            maxQ = stQ.query(L-1, mid-1) if L-1 <= mid-1 else -10**18
            if minP >= maxQ:
                best = mid
                lo = mid + 1
            else:
                hi = mid - 1
        length = best - L + 1
        if length > 0:
            length = min(length, n)
            diff[1] += 1
            diff[length+1] -= 1
    res = []
    cur = 0
    for k in range(1, n+1):
        cur += diff[k]
        res.append(cur)
    return res

def main():
    # tiny validations
    n1, segs1 = 2, [(1,1),(2,2)]
    assert solve_all(n1, segs1) == [2,1]
    n2, segs2 = 3, [(1,3),(1,3),(1,3)]
    assert solve_all(n2, segs2) == [3,2,1]
    n, segs = read_input()
    if n:
        print(" ".join(map(str, solve_all(n, segs))))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks match Approach A on tiny hand-crafted cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two-Pointer Sweep with Sliding Min/Max}
\WHICHFORMULA{Use the necessary-and-sufficient inequality
\begin{BreakableEquation*}
\min_{b\in[L,R]} P[b]\ \ge\ \max_{t\in[L-1,R-1]} Q[t],
\end{BreakableEquation*}
with $P[b]=L_p[b]-b$ and $Q[t]=R_p[t]-t$. For fixed $L$, feasibility is monotone in $R$, so $R$ can be extended greedily using two deques that maintain the sliding minimum of $P$ and sliding maximum of $Q$.}
\ASSUMPTIONS{Indices: days from $1$ to $M=\max r_i$; $P[1..M]$, $Q[0..M-1]$. Empty ranges have $\min=+\infty$, $\max=-\infty$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $L_p, R_p$ by prefix sums of day-start and day-end frequencies in $O(M)$.
\item Compute $P[b]=L_p[b]-b$ for $b=1..M$ and $Q[t]=R_p[t]-t$ for $t=0..M-1$.
\item Maintain two deques:
  - $\mathcal{D}_P$ for the min over $P[L..R]$,
  - $\mathcal{D}_Q$ for the max over $Q[L-1..R-1]$.
\item For each $L=1..M$:
  - If $R<L-1$, clear deques and set $R=L-1$.
  - While $R<M$ and $\min(\text{front}(\mathcal{D}_P), P[R+1]) \ge \max(\text{front}(\mathcal{D}_Q), Q[R])$, push $P[R+1]$ into $\mathcal{D}_P$ (monotone increasing), push $Q[R]$ into $\mathcal{D}_Q$ (monotone decreasing), and increment $R$.
  - Record $R_{\max}(L)=R$ and add $+1$ to all lengths $k\le \min(n, R-L+1)$ via a difference array.
  - Slide: pop $L$ from $\mathcal{D}_P$ and $L-1$ from $\mathcal{D}_Q$ if present.
\item Prefix the difference array to obtain counts for all $k=1..n$.
\end{algosteps}
\OPTIMALITY{Each of $R$ and $L$ advances at most $M$ times, and each array index is pushed and popped at most once per deque, yielding $O(M)$ time after $O(M)$ preprocessing. This matches the information-theoretic lower bound to inspect per-day aggregates.}
\COMPLEXITY{Precompute arrays in $O(M)$; two-pointer sweep $O(M)$; total $O(M)$ time and $O(M)$ space.}
\[
\begin{aligned}
T(M) &= O(M), \quad S(M) = O(M).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    segs = []
    M = 0
    for _ in range(n):
        l = int(next(it)); r = int(next(it))
        segs.append((l, r))
        if r > M:
            M = r
    return n, segs

def solve_case(n, intervals):
    if n == 0:
        return []
    M = max(r for _, r in intervals)
    # Frequencies of starts/ends
    freqL = [0]*(M+1)
    freqR = [0]*(M+1)
    for l, r in intervals:
        freqL[l] += 1
        freqR[r] += 1
    # Prefix sums
    Lp = [0]*(M+1)
    Rp = [0]*(M+1)
    for i in range(1, M+1):
        Lp[i] = Lp[i-1] + freqL[i]
        Rp[i] = Rp[i-1] + freqR[i]
    # P[b] for b=1..M, Q[t] for t=0..M-1
    P = [0]*(M+1)
    for b in range(1, M+1):
        P[b] = Lp[b] - b
    Q = [0]*M
    for t in range(0, M):
        Q[t] = Rp[t] - t
    # Two-pointer with sliding min (P) and sliding max (Q)
    deqP = deque()  # indices b in [L..R], increasing P-values
    deqQ = deque()  # indices t in [L-1..R-1], decreasing Q-values
    R = 0
    INF = 10**18
    diff = [0]*(n+2)
    for L in range(1, M+1):
        # Align empty window if needed
        if R < L-1:
            deqP.clear()
            deqQ.clear()
            R = L-1
        # Try to extend R greedily
        while R < M:
            curMinP = P[deqP[0]] if deqP else INF
            curMaxQ = Q[deqQ[0]] if deqQ else -INF
            newP = P[R+1]
            newQ = Q[R]  # new Q range becomes [L-1..R]
            if min(curMinP, newP) >= max(curMaxQ, newQ):
                # Append P[R+1] to deqP (monotone increasing)
                while deqP and P[deqP[-1]] >= newP:
                    deqP.pop()
                deqP.append(R+1)
                # Append Q[R] to deqQ (monotone decreasing)
                while deqQ and Q[deqQ[-1]] <= newQ:
                    deqQ.pop()
                deqQ.append(R)
                R += 1
            else:
                break
        # Count lengths up to n
        length = R - L + 1
        if length > 0:
            t = length if length < n else n
            diff[1] += 1
            diff[t+1] -= 1
        # Slide left boundary
        if deqP and deqP[0] == L:
            deqP.popleft()
        if deqQ and deqQ[0] == L-1:
            deqQ.popleft()
    # Build result by prefix sum on diff
    res = []
    cur = 0
    for k in range(1, n+1):
        cur += diff[k]
        res.append(cur)
    return res

def solve_all(n, intervals):
    return solve_case(n, intervals)

def main():
    # Cross-check against a slow brute for tiny cases
    def brute(n, intervals):
        from heapq import heappush, heappop
        if n == 0:
            return []
        M = max(r for _, r in intervals)
        ans = [0]*(n+1)
        for L in range(1, M+1):
            for R in range(L, M+1):
                k = R - L + 1
                if k > n: break
                # Greedy feasibility test
                # Pre-bucket by start
                starts = {}
                for (l, r) in intervals:
                    starts.setdefault(l, []).append(r)
                heap = []
                # Pre-insert those with l <= L and r >= L
                for (l, r) in intervals:
                    if l <= L and r >= L:
                        heappush(heap, r)
                ok = True
                for d in range(L, R+1):
                    if d > L:
                        for rr in starts.get(d, []):
                            if rr >= d: heappush(heap, rr)
                    while heap and heap[0] < d:
                        heappop(heap)
                    if not heap:
                        ok = False
                        break
                    heappop(heap)
                if ok:
                    ans[k] += 1
        return ans[1:]

    # Deterministic tests
    n1, segs1 = 2, [(1,1),(2,2)]
    assert solve_all(n1, segs1) == [2,1]
    n2, segs2 = 3, [(1,3),(1,3),(1,3)]
    assert solve_all(n2, segs2) == [3,2,1]
    # Random tiny cross-checks
    import random
    random.seed(0)
    for _ in range(30):
        n = random.randint(1, 5)
        intervals = []
        M = random.randint(1, 6)
        for _ in range(n):
            l = random.randint(1, M)
            r = random.randint(l, M)
            intervals.append((l, r))
        got = solve_all(n, intervals)
        expect = brute(n, intervals)
        assert got == expect, (n, M, intervals, got, expect)

    # If real input present, solve
    n, segs = read_input()
    if n:
        print(" ".join(map(str, solve_all(n, segs))))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts:
- Two hand-crafted cases.
- A randomized tiny cross-check comparing optimal vs brute over multiple seeds.
All pass before reading stdin.}
\RESULT{Array of $n$ counts where the $k$th entry is the number of feasible segments of length $k$. There are no tie-breaks; every valid $[L,R]$ contributes exactly once to its length.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks on small handcrafted cases, randomized sanity checks against a brute-force oracle for tiny $M$, and structural edge cases: no overlap, full overlap, staircase overlaps.}
\LINE{CROSS-CHECKS}{Approach C is cross-validated against a brute greedy (Approach A) on small domains.}
\LINE{EDGE-CASE GENERATOR}{Random generator over small $M$ selects $n$ intervals uniformly with $l\le r$ to explore sparse/dense coverage regimes.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_singletons(M):
    # returns intervals (d,d) for each day
    return [(d, d) for d in range(1, M+1)]

def gen_full_cover(n, L, R):
    # n lecturers all cover [L, R]
    return [(L, R) for _ in range(n)]

def gen_staircase(n, M):
    # Nested increasing ends
    res = []
    for i in range(1, n+1):
        l = max(1, i-1)
        r = min(M, l + (i % max(1, M)))
        if l > r: l, r = 1, M
        if l > r: l, r = r, l
        if l > r: l, r = 1, M
        if l > r: l, r = 1, 1
        if l > r: l, r = 1, M
        if l > r: l, r = 1, 1
        res.append((min(l, r), max(l, r)))
    return res
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    n = int(next(it))
    segs = []
    M = 0
    for _ in range(n):
        l = int(next(it)); r = int(next(it))
        segs.append((l, r))
        if r > M:
            M = r
    return n, segs

def solve_case(n, intervals):
    if n == 0:
        return []
    M = max(r for _, r in intervals)
    freqL = [0]*(M+1)
    freqR = [0]*(M+1)
    for l, r in intervals:
        freqL[l] += 1
        freqR[r] += 1
    Lp = [0]*(M+1)
    Rp = [0]*(M+1)
    for i in range(1, M+1):
        Lp[i] = Lp[i-1] + freqL[i]
        Rp[i] = Rp[i-1] + freqR[i]
    P = [0]*(M+1)
    for b in range(1, M+1):
        P[b] = Lp[b] - b
    Q = [0]*M
    for t in range(0, M):
        Q[t] = Rp[t] - t
    deqP = deque()
    deqQ = deque()
    R = 0
    INF = 10**18
    diff = [0]*(n+2)
    for L in range(1, M+1):
        if R < L-1:
            deqP.clear()
            deqQ.clear()
            R = L-1
        while R < M:
            curMinP = P[deqP[0]] if deqP else INF
            curMaxQ = Q[deqQ[0]] if deqQ else -INF
            newP = P[R+1]
            newQ = Q[R]
            if min(curMinP, newP) >= max(curMaxQ, newQ):
                while deqP and P[deqP[-1]] >= newP:
                    deqP.pop()
                deqP.append(R+1)
                while deqQ and Q[deqQ[-1]] <= newQ:
                    deqQ.pop()
                deqQ.append(R)
                R += 1
            else:
                break
        length = R - L + 1
        if length > 0:
            t = length if length < n else n
            diff[1] += 1
            diff[t+1] -= 1
        if deqP and deqP[0] == L:
            deqP.popleft()
        if deqQ and deqQ[0] == L-1:
            deqQ.popleft()
    res = []
    cur = 0
    for k in range(1, n+1):
        cur += diff[k]
        res.append(cur)
    return res

def solve_all(n, intervals):
    return solve_case(n, intervals)

def main():
    # Exactness tests (tiny)
    n1, segs1 = 2, [(1,1),(2,2)]
    assert solve_all(n1, segs1) == [2,1]
    n2, segs2 = 3, [(1,3),(1,3),(1,3)]
    assert solve_all(n2, segs2) == [3,2,1]
    # Read and solve
    n, segs = read_input()
    if n:
        print(" ".join(map(str, solve_all(n, segs))))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce matching feasibility over an interval family to a sliding-window inequality between a range-min array $P$ and a range-max array $Q$.}
\WHY{Convex bipartite graphs (days vs. intervals) often admit Hall-like conditions with prefix/suffix transforms, enabling linear-time sweeps in interview/hard contest problems.}
\CHECKLIST{
- Build $L_p, R_p$ correctly from $l_i, r_i$.
- Compute $P[b]=L_p[b]-b$ and $Q[t]=R_p[t]-t$ with indices $b\in[1..M], t\in[0..M-1]$.
- Maintain deques for $\min P[L..R]$ and $\max Q[L-1..R-1]$.
- Two-pointer extend $R$ while $\min P \ge \max Q$; record $R_{\max}(L)$.
- Aggregate counts by length via difference array capped at $n$.}
\EDGECASES{
- No coverage day: infeasible forces window to stop.
- All-covering lecturers: counts become all segments within the cover.
- $n=1$ and single-day windows.
- Multiple starts/ends on same day.
- Windows where $R<L$ (empty): treat $\min=+\infty$, $\max=-\infty$ correctly.}
\PITFALLS{
- Off-by-one in $Q$ indexing: $Q$ uses $t=a-1$ and window $[L-1..R-1]$.
- Forgetting to pop left indices when $L$ increases.
- Adding $Q[R]$ only when extending $R$; do not add if window should be empty ($R<L-1$); reset properly.
- Using $\max r$ as $M$; windows with $R>M$ are irrelevant and must not be counted.
- Overflowing counts without capping lengths at $n$.}
\FAILMODES{Baseline greedy per window times out. Segment-tree approach is $O(M\log^2 M)$ and may pass but is heavier. The deque two-pointer survives worst-case dense inputs in $O(M)$.}
\ELI{Count intervals touching any subwindow by clever prefix math. This turns a combinatorial matching test into comparing two simple arrays inside a sliding window, which we can maintain in constant-time per step.}
\NotePages{3}

\end{document}