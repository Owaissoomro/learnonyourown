% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — 1-bit and 2-bit Characters}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/1-bit-and-2-bit-characters/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{
We have two special characters:
\begin{itemize}
\item The first character can be represented by one bit \texttt{0}.
\item The second character can be represented by two bits (\texttt{10} or \texttt{11}).
\end{itemize}

Given a binary array \texttt{bits} that ends with \texttt{0}, return \texttt{true} if the last character must be a one-bit character.

\textbf{Example 1:}

\textbf{Input:} \texttt{bits = [1,0,0]}\\
\textbf{Output:} \texttt{true}\\
\textbf{Explanation:} The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.

\textbf{Example 2:}

\textbf{Input:} \texttt{bits = [1,1,1,0]}\\
\textbf{Output:} \texttt{false}\\
\textbf{Explanation:} The only way to decode it is two-bit character and two-bit character. So the last character is not one-bit character.

\textbf{Constraints:}
\begin{itemize}
\item $1 \le \lvert \texttt{bits} \rvert \le 1000$
\item $\texttt{bits}[i] \in \{0,1\}$
\end{itemize}
}
\BREAKDOWN{Model the encoding as tokens of length 1 (\texttt{0}) or length 2 (\texttt{10}, \texttt{11}). Traverse the array according to token lengths and check whether the last index is consumed by a single-bit token. Alternatively, use the parity of consecutive ones before the last zero.}
\ELI{Walk through the bits: jump by 2 when you see a leading 1, otherwise jump by 1; the last character is one-bit iff you land exactly on the last index.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list \texttt{bits} of integers 0/1 with length $n$ where $1 \le n \le 1000$ and the last element is $0$.}
\OUTPUTS{A boolean: \texttt{true} if the last character must be a one-bit character under the encoding, else \texttt{false}.}
\SAMPLES{
\begin{itemize}
\item \texttt{bits = [0]} $\to$ \texttt{true}
\item \texttt{bits = [1,0,0]} $\to$ \texttt{true}; \texttt{bits = [1,1,1,0]} $\to$ \texttt{false}
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $b_0,b_1,\ldots,b_{n-1}\in\{0,1\}$ with $b_{n-1}=0$. A valid parse partitions the index set into tokens of length 1 if the leading bit is 0, or length 2 if the leading bit is 1. The predicate asks whether in every valid parse the last token is the one-bit token at position $n-1$. Equivalently (and in fact), due to determinism of greedy parsing, whether the greedy walk lands on index $n-1$.}
\varmapStart
\var{i}{current index while scanning}
\var{n}{length of \texttt{bits}}
\var{b_i}{the $i$-th bit of the input}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
i_0 &= 0,\\
i_{t+1} &=
\begin{cases}
i_t + 1, & \text{if } b_{i_t} = 0,\\
i_t + 2, & \text{if } b_{i_t} = 1,
\end{cases}\\
\text{Stop at } t^\star &: \text{ the smallest $t$ with } i_t \ge n-1.\\
\text{Answer} &:~ (i_{t^\star} = n-1).
\end{aligned}
\]
}
\ASSUMPTIONS{Input ends with 0. Tokens do not overlap and cover a prefix; the greedy advance is safe because a leading 1 forces a two-bit token.}
\INVARIANTS{
\begin{itemize}
\item Monotonic advance: $i$ increases by 1 or 2 each step.
\item Safety: If $b_i=1$, then $i+1<n$ because $b_{n-1}=0$, so two-bit token is available.
\item Termination: Since $i$ increases and $i<n$, the loop terminates in $O(n)$ steps.
\end{itemize}
}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedy scan from left to right: if the current bit is 0, consume one bit; if it is 1, consume two bits. This directly mirrors the encoding rules.}
\ASSUMPTIONS{The last bit is 0, ensuring no out-of-bounds when a 1 appears near the end.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $i \leftarrow 0$, $n \leftarrow \lvert \texttt{bits} \rvert$.
\item While $i < n-1$: if $\texttt{bits}[i]=0$ then $i \leftarrow i+1$ else $i \leftarrow i+2$.
\item Return $i = n-1$.
\end{algosteps}
\COMPLEXITY{Linear scan with constant work per step: $T(n)=O(n)$, $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &\le \sum_{k=0}^{\lfloor n/1 \rfloor} O(1) = O(n).
\end{aligned}
\]
\CORRECTNESS{A leading 1 deterministically forms a two-bit token; a leading 0 forms a one-bit token. Hence the greedy walk matches any valid parsing. The last character is one-bit iff the walk lands on the final index.}
\EDGECASES{Single element $[0]$; alternating patterns like $[1,0,1,0,\ldots,0]$; runs of ones ending at the last zero, e.g., $[1,1,1,0]$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        i, n = 0, len(bits)
        # Walk until we reach or pass the penultimate index
        while i < n - 1:
            if bits[i] == 0:
                i += 1
            else:
                i += 2
        return i == n - 1

# Basic validation
s = Solution()
assert s.isOneBitCharacter([1,0,0]) is True
assert s.isOneBitCharacter([1,1,1,0]) is False
assert s.isOneBitCharacter([0]) is True
\end{minted}
\VALIDATION{Covers minimal input, examples, and a simple alternating pattern.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Parity of trailing ones before the last zero}
\WHICHFORMULA{Count consecutive ones immediately before the last bit (which is 0). If the count is even, the last zero stands alone (one-bit); if odd, it is paired with the preceding 1 as a two-bit token.}
\ASSUMPTIONS{The string ends with 0, so counting ones leftward is well-defined.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $i \leftarrow n-2$ and $c \leftarrow 0$.
\item While $i \ge 0$ and $\texttt{bits}[i]=1$: increment $c$ and decrement $i$.
\item Return $(c \bmod 2 = 0)$.
\end{algosteps}
\COMPLEXITY{Single backward pass over a suffix: $T(n)=O(n)$, $S(n)=O(1)$. It can be faster in practice by exiting early once a 0 is found.}
\[
\begin{aligned}
T(n) &\le n-1 = O(n).
\end{aligned}
\]
\CORRECTNESS{Consecutive ones before the final zero form pairs of two-bit tokens. An even count pairs up completely, leaving the last zero unpaired (one-bit). An odd count leaves one leading 1 to pair with the final zero as a two-bit token.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        # Count consecutive ones before the last zero
        i = len(bits) - 2
        cnt = 0
        while i >= 0 and bits[i] == 1:
            cnt += 1
            i -= 1
        return (cnt % 2) == 0

# Edge-focused checks
s = Solution()
assert s.isOneBitCharacter([0]) is True
assert s.isOneBitCharacter([1,0]) is False  # odd run of ones before last zero
\end{minted}
\VALIDATION{Checks minimal case and a length-2 adversarial case where the last zero is paired.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Backward Parity Test (Succinct)}
\WHICHFORMULA{Use the parity of the run of ones immediately preceding the final zero. This is both simplest and optimal in time and space.}
\ASSUMPTIONS{The input ends with 0.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $c\leftarrow 0$ and scan left from $n-2$ while the bit is 1, incrementing $c$.
\item If $c$ is even, return \texttt{true}; else return \texttt{false}.
\item This uses $O(1)$ space and a single pass over a suffix.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must inspect at least the trailing run to distinguish cases like $[1,0]$ vs. $[0,0]$. This method does so with $O(1)$ space and $O(k)$ time where $k$ is the length of that run, which is asymptotically optimal in the worst case $k=O(n)$.}
\COMPLEXITY{$T(n)=O(n)$ in worst case, $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &\le n-1, \quad S(n)=1.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        i = len(bits) - 2
        cnt = 0
        while i >= 0 and bits[i] == 1:
            cnt += 1
            i -= 1
        return (cnt % 2) == 0

# Exactly 3 asserts
s = Solution()
assert s.isOneBitCharacter([1,0,0]) is True
assert s.isOneBitCharacter([1,1,1,0]) is False
assert s.isOneBitCharacter([0]) is True
\end{minted}
\VALIDATION{Three asserts cover both examples and the minimal case.}
\RESULT{Return \texttt{true} iff the run of ones before the last zero has even length; equivalently, iff a greedy left-to-right walk lands on index $n-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on provided examples; edge cases like \texttt{[0]}, \texttt{[1,0]}, \texttt{[1,1,0]}, alternating patterns; randomized small cases with a cross-check between the forward-greedy and backward-parity methods.}
\LINE{CROSS-CHECKS}{Compare the outputs of Approach A (forward walk) and Approach B/C (backward parity) on many random inputs that end with 0.}
\LINE{EDGE-CASE GENERATOR}{Generate short arrays of length up to 8 with last bit fixed to 0, covering all combinations to expose corner behaviors.}
\begin{minted}{python}
import random
from typing import List

def forward(bits: List[int]) -> bool:
    i, n = 0, len(bits)
    while i < n - 1:
        i += 1 if bits[i] == 0 else 2
    return i == n - 1

def backward(bits: List[int]) -> bool:
    i = len(bits) - 2
    cnt = 0
    while i >= 0 and bits[i] == 1:
        cnt += 1
        i -= 1
    return (cnt % 2) == 0

def generate_cases(maxn: int = 8):
    cases = []
    for n in range(1, maxn + 1):
        for mask in range(1 << (n - 1)):
            arr = [(mask >> k) & 1 for k in range(n - 1)]
            arr.reverse()
            arr.append(0)  # force last bit to 0
            cases.append(arr)
    return cases

# Deterministic randomized sampling (subset of all)
random.seed(0)
sampled = []
for _ in range(200):
    n = random.randint(1, 12)
    arr = [random.randint(0, 1) for _ in range(max(0, n - 1))] + [0]
    sampled.append(arr)

# Cross-check exhaustive for small n and sampled larger cases
for arr in generate_cases(7) + sampled:
    assert forward(arr) == backward(arr)

print("Cross-checks passed on", len(generate_cases(7)) + len(sampled), "cases.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        # Count consecutive ones before the final zero; even => last is one-bit.
        i = len(bits) - 2
        cnt = 0
        while i >= 0 and bits[i] == 1:
            cnt += 1
            i -= 1
        return (cnt % 2) == 0

# Self-checks against a forward-walk helper
def _forward(bits: List[int]) -> bool:
    i, n = 0, len(bits)
    while i < n - 1:
        i += 1 if bits[i] == 0 else 2
    return i == n - 1

s = Solution()
# Examples and edges
assert s.isOneBitCharacter([1,0,0]) is True
assert s.isOneBitCharacter([1,1,1,0]) is False
assert s.isOneBitCharacter([0]) is True
assert s.isOneBitCharacter([1,0]) is False
assert s.isOneBitCharacter([1,1,0]) is True
# Cross-check on a few random cases
import random
random.seed(1)
for _ in range(50):
    n = random.randint(1, 12)
    arr = [random.randint(0, 1) for _ in range(max(0, n - 1))] + [0]
    assert s.isOneBitCharacter(arr) == _forward(arr)
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Determine if the final character in a bitstring ending with 0 is a one-bit character under a 1/2-bit encoding.}
\WHY{Tests greedy parsing, pattern parity reasoning, and proof of correctness under simple encoding rules—common in screening rounds.}
\CHECKLIST{
\begin{bullets}
\item Confirm the last bit is 0 (as per constraints).
\item Choose method: forward walk or backward parity.
\item Implement in $O(n)$ time and $O(1)$ space.
\item Test minimal and adversarial cases: \texttt{[0]}, \texttt{[1,0]}, runs of ones before the last zero.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Single element \texttt{[0]}.
\item Two elements \texttt{[1,0]} (must be two-bit at end).
\item All zeros: \texttt{[0,0,0,0]}.
\item Long run of ones before last zero: \texttt{[1,1,1,1,0]}.
\item Alternating starting with 1: \texttt{[1,0,1,0,\ldots,0]}.
\item Near-end 1s: \texttt{[0,0,1,0]}.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one in the forward loop condition ($i<n-1$ is required).
\item Forgetting that a leading 1 forces consuming two bits.
\item Backward method: starting from the correct index $n-2$.
\item Not handling $n=1$ properly.
\item Misinterpreting ``must be'' as existence rather than determinism.
\item Returning the wrong parity in the backward count.
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item Naive DP over all parses is overkill and slower.
\item Incorrect forward stop condition may wrongly classify \texttt{[1,0]}.
\item Not enforcing last bit 0 could cause index-out-of-range for forward method.
\end{bullets}
}
\ELI{Scan from left taking steps of 1 on 0 and 2 on 1; if you land exactly on the last index, it is a one-bit character. Or just count how many 1s are right before the last 0: even means the last 0 stands alone, odd means it pairs with a 1.}
\NotePages{3}

\end{document}