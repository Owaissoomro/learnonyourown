% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Matrix Walk}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/954/C}}
\LINE{DIFFICULTY / RATING}{1700}
\STATEMENT{There is a matrix $A$ of size $x \times y$ filled with integers. For every $i \in [1..x]$, $j \in [1..y]$ we have $A_{i,j} = y(i - 1) + j$. Obviously, every integer from $[1..xy]$ occurs exactly once in this matrix.

You have traversed some path in this matrix. Your path can be described as a sequence of visited cells $a_1, a_2, \ldots, a_n$ denoting that you started in the cell containing the number $a_1$, then moved to the cell with the number $a_2$, and so on.

From the cell located in $i$-th line and $j$-th column (we denote this cell as $(i, j)$) you can move into one of the following cells:
\begin{bullets}
\item $(i+1, j)$ — only if $i < x$;
\item $(i, j+1)$ — only if $j < y$;
\item $(i-1, j)$ — only if $i > 1$;
\item $(i, j-1)$ — only if $j > 1$.
\end{bullets}

Notice that making a move requires you to go to an adjacent cell. It is not allowed to stay in the same cell. You do not know $x$ and $y$ exactly, but you have to find any possible values for these numbers such that you could start in the cell containing the number $a_1$, then move to the cell containing $a_2$ (in one step), then move to the cell containing $a_3$ (also in one step) and so on. Can you choose $x$ and $y$ so that they do not contradict with your sequence of moves?

Input: The first line contains one integer number $n$ ($1 \le n \le 200000$) — the number of cells you visited on your path (if some cell is visited twice, then it is listed twice).

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^9$) — the integers in the cells on your path.

Output: If all possible values of $x$ and $y$ such that $1 \le x, y \le 10^9$ contradict with the information about your path, print \texttt{NO}.

Otherwise, print \texttt{YES} in the first line, and in the second line print the values $x$ and $y$ such that your path was possible with such number of lines and columns in the matrix. Remember that they must be positive integers not exceeding $10^9$.

Note: Also there exist multiple correct answers for some inputs.}
\BREAKDOWN{Reverse-engineer $y$ (the number of columns) from differences of consecutive labels; validate each step as either a horizontal move ($\pm 1$ within the same row) or a vertical move ($\pm y$). If consistent, choose $x$ minimally to fit the largest label.}
\ELI{Consecutive numbers differ by $1$ horizontally (without crossing row boundaries) or by $y$ vertically; deduce $y$ from the path and check consistency.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item Integer $n$ ($1 \le n \le 200000$).
\item Sequence $a_1,\ldots,a_n$ with $1 \le a_i \le 10^9$.
\end{bullets}}
\OUTPUTS{Either:
\begin{bullets}
\item \texttt{NO}, if no $x,y$ with $1 \le x,y \le 10^9$ can realize the path; or
\item \texttt{YES} on the first line, and on the second line two integers $x$ and $y$ that make the path feasible. Any valid pair is accepted.
\end{bullets}}
\SAMPLES{Example 1 (YES):
\begin{bullets}
\item Input:
\[
\begin{aligned}
n &= 4\\
a &= [3,\,4,\,8,\,7]
\end{aligned}
\]
\item One valid output: \texttt{YES} and \texttt{2 4} (rows $x=2$, columns $y=4$).
\end{bullets}
Example 2 (NO):
\begin{bullets}
\item Input:
\[
\begin{aligned}
n &= 3\\
a &= [2,\,3,\,5]
\end{aligned}
\]
\item Output: \texttt{NO} (the step $2 \to 3$ would cross a row boundary if $y=2$, and no other $y$ fits both steps).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $y$ be the number of columns. The matrix is row-major: $A_{i,j} = y(i-1)+j$. For a label $v$, define its coordinates as
\begin{BreakableEquation*}
\mathrm{row}(v) = \left\lfloor \frac{v-1}{y} \right\rfloor + 1,\quad \mathrm{col}(v) = ((v-1) \bmod y) + 1.
\end{BreakableEquation*}
A path $a_1,\ldots,a_n$ is feasible iff for each $k\ge 2$, either:
\begin{bullets}
\item horizontal: $|a_k-a_{k-1}|=1$ and $\mathrm{row}(a_k)=\mathrm{row}(a_{k-1})$, or
\item vertical: $|a_k-a_{k-1}|=y$.
\end{bullets}
If feasible, set $x = \max_k \mathrm{row}(a_k)$; any $x' \ge x$ is also valid.}
\varmapStart
\var{n}{path length}
\var{a_k}{$k$-th visited label}
\var{y}{number of columns (to deduce)}
\var{x}{number of rows (minimal to fit $\max a_k$)}
\var{d_k}{difference $|a_k-a_{k-1}|$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall k\in\{2,\ldots,n\}:\quad d_k \in \{1,\,y\}\ \wedge\ \bigl(d_k=1 \implies \bigl\lfloor\tfrac{a_k-1}{y}\bigr\rfloor=\bigl\lfloor\tfrac{a_{k-1}-1}{y}\bigr\rfloor\bigr).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Labels are positive; the numbering is strictly row-major; we may choose any $x,y$ with $1 \le x,y \le 10^9$.}
\INVARIANTS{
\begin{bullets}
\item All vertical moves change the label by exactly $\pm y$.
\item All horizontal moves change the label by exactly $\pm 1$ and stay in the same row.
\item If any $d_k>1$, all such $d_k$ must be equal to the same $y$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Detect the column count $y$ from non-unit differences. If conflicting values occur, the path is impossible. Otherwise, validate each step by checking the row-major constraints.}
\ASSUMPTIONS{If there is no difference $>1$, choose a very large $y$ (e.g., $10^9$) so that all unit differences lie within the same row.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Scan consecutive differences $d_k=|a_k-a_{k-1}|$.
\item Collect all $d_k>1$; if their set has size $\ge 2$, report \texttt{NO}. If empty, set $y=10^9$; else set $y$ to that unique value.
\item Re-scan: each $d_k$ must be either $1$ (and same row under $y$) or $y$; otherwise \texttt{NO}. If all pass, output $x=\left\lfloor\tfrac{\max a_k-1}{y}\right\rfloor+1$ and $y$.
\end{algosteps}
\COMPLEXITY{Single passes over the sequence.
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(1).
\end{aligned}
\]}
\CORRECTNESS{Non-unit differences must correspond to vertical moves and thus equal $y$; horizontal moves are $\pm 1$ and cannot cross row boundaries in row-major numbering. This directly encodes the move rules.}
\EDGECASES{Repeated label (zero difference) is invalid; no non-unit difference implies arbitrary large $y$; $y=1$ is allowed and handled because vertical condition uses $d_k=y$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    a = [int(next(it)) for _ in range(n)]
    return n, a

def deduce_and_validate(a):
    n = len(a)
    if n == 0:
        return False, None, None
    diffs = set()
    for i in range(1, n):
        d = abs(a[i] - a[i-1])
        if d == 0:
            return False, None, None
        if d > 1:
            diffs.add(d)
            if len(diffs) > 1:
                return False, None, None
    if len(diffs) == 0:
        y = 10**9
    else:
        y = diffs.pop()
    # validate moves
    for i in range(1, n):
        d = abs(a[i] - a[i-1])
        if d == 1:
            r1 = (a[i] - 1) // y
            r0 = (a[i-1] - 1) // y
            if r1 != r0:
                return False, None, None
        elif d == y:
            pass
        else:
            return False, None, None
    x = (max(a) - 1) // y + 1
    return True, x, y

def solve_case(n, a):
    ok, x, y = deduce_and_validate(a)
    if not ok:
        return "NO\n"
    return "YES\n{} {}\n".format(x, y)

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    n, a = parsed
    sys.stdout.write(solve_case(n, a))

def main():
    solve_all()

if __name__ == "__main__":
    # Unit tests (not executed on CF unless run locally)
    def _t(seq, expect_ok):
        ok, x, y = deduce_and_validate(seq)
        assert ok == expect_ok
        if ok:
            # Check that output x,y indeed satisfies constraints
            for i in range(1, len(seq)):
                d = abs(seq[i] - seq[i-1])
                assert d == 1 or d == y
                if d == 1:
                    assert (seq[i]-1)//y == (seq[i-1]-1)//y
    _t([3,4,8,7], True)          # y=4
    _t([1,2,3,2,1], True)        # y can be 1e9
    _t([2,3,5], False)           # conflicting moves for any y
    main()
\end{minted}
\VALIDATION{Checked typical: mixed horizontal/vertical; pure unit steps; and a contradiction crossing a row boundary.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Single-Pass Deduction with Early Rejection}
\WHICHFORMULA{Fuse deduction of $y$ and validation in one left-to-right pass with constant memory, rejecting immediately on violation.}
\ASSUMPTIONS{At most one vertical magnitude can exist ($y$); otherwise impossible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $y=0$ (unknown).
\item For each consecutive pair $(a_{k-1},a_k)$ compute $d=|a_k-a_{k-1}|$:
\begin{bullets}
\item If $d=0$, reject.
\item If $d=1$, require same row if $y$ known; if $y=0$, postpone by recording for later check.
\item If $d>1$, if $y=0$ set $y=d$, else require $d=y$.
\end{bullets}
\item After $y$ is known (or at end choose $y=10^9$ if still $0$), verify deferred unit steps for same-row condition. Output minimal $x$.
\end{algosteps}
\COMPLEXITY{Still linear, constant memory; early rejection short-circuits on the first contradiction.
\begin{BreakableEquation*}
T(n)=\Theta(n),\ S(n)=\Theta(1).
\end{BreakableEquation*}}
\CORRECTNESS{Equates every non-unit jump to the unique vertical stride $y$ and enforces the row constraint for unit jumps under that $y$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_case(n, a):
    if n == 1:
        y = 10**9
        x = 1 if a[0] <= y else (a[0]-1)//y + 1
        return "YES\n{} {}\n".format(x, y)
    y = 0
    # First pass: fix y or reject
    for i in range(1, n):
        d = abs(a[i] - a[i-1])
        if d == 0:
            return "NO\n"
        if d > 1:
            if y == 0:
                y = d
            elif d != y:
                return "NO\n"
    if y == 0:
        y = 10**9
    # Validate all moves now that y is known
    for i in range(1, n):
        d = abs(a[i] - a[i-1])
        if d == 1:
            if (a[i]-1)//y != (a[i-1]-1)//y:
                return "NO\n"
        elif d == y:
            continue
        else:
            return "NO\n"
    x = (max(a) - 1) // y + 1
    return "YES\n{} {}\n".format(x, y)

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    n, a = parsed
    sys.stdout.write(solve_case(n, a))

def main():
    sys.setrecursionlimit(1 << 25)
    solve_all()

if __name__ == "__main__":
    # Basic asserts
    assert solve_case(4, [3,4,8,7]).startswith("YES")
    assert solve_case(3, [2,3,5]).strip() == "NO"
    out = solve_case(5, [1,2,3,2,1]).split()
    assert out[0] == "YES"
    main()
\end{minted}
\VALIDATION{Covers vertical-only, horizontal-only, and mixed paths; detects boundary-crossing on unit steps.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Derive Columns from Deltas; Validate by Row Quotients}
\WHICHFORMULA{Let $Y=\{d_k:\ d_k>1\}$. If $|Y|\ge 2$, answer \texttt{NO}. Else $y=\max Y$ if $Y\neq\varnothing$, otherwise $y=10^9$. Validate $d_k\in\{1,y\}$ and same-row for $d_k=1$.}
\ASSUMPTIONS{Row-major numbering; labels are $1$-indexed; $x$ can be chosen minimally as $\left\lfloor\tfrac{\max a-1}{y}\right\rfloor+1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute set $Y$ of non-unit absolute differences; if $|Y|>1$, \texttt{NO}; else pick $y$ accordingly (or $10^9$ if $Y=\varnothing$).
\item For each consecutive pair, require $d\in\{1,y\}$ and, if $d=1$, that integer quotients $(a-1)//y$ match.
\item Output $x=\left\lfloor\tfrac{\max a-1}{y}\right\rfloor+1$, $y$.
\end{algosteps}
\OPTIMALITY{This is a necessary-and-sufficient characterization of feasible paths under row-major numbering, thus both correct and minimal-time (single scan).}
\COMPLEXITY{Linear in path length, constant extra space.
\begin{BreakableEquation*}
T(n)=\Theta(n),\quad S(n)=\Theta(1).
\end{BreakableEquation*}}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_case(n, a):
    diffs = set()
    for i in range(1, n):
        d = abs(a[i] - a[i-1])
        if d == 0:
            return "NO\n"
        if d > 1:
            diffs.add(d)
            if len(diffs) > 1:
                return "NO\n"
    y = 10**9 if not diffs else next(iter(diffs))
    for i in range(1, n):
        d = abs(a[i] - a[i-1])
        if d == 1:
            if (a[i]-1)//y != (a[i-1]-1)//y:
                return "NO\n"
        elif d == y:
            continue
        else:
            return "NO\n"
    x = (max(a) - 1) // y + 1
    return "YES\n{} {}\n".format(x, y)

def solve_all():
    parsed = read_input()
    if not parsed:
        return
    n, a = parsed
    sys.stdout.write(solve_case(n, a))

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case(4, [3,4,8,7]).startswith("YES")
    assert solve_case(3, [2,3,5]) == "NO\n"
    assert solve_case(1, [42]).startswith("YES")
    main()
\end{minted}
\VALIDATION{Asserts cover mixed valid path, impossible crossing, and $n=1$.}
\RESULT{Print \texttt{YES} and any valid pair $(x,y)$ or \texttt{NO} if no such pair exists.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the core deduction on hand-crafted sequences:
\begin{bullets}
\item All unit moves within a row (no non-unit difference).
\item Mixed unit and non-unit moves with a single vertical stride $y$.
\item Contradictions: multiple non-unit differences; unit step crossing a row boundary.
\end{bullets}}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A, B, and C on the same tiny cases; they should agree on \texttt{YES}/\texttt{NO} and produce consistent $y$.}
\LINE{EDGE-CASE GENERATOR}{Generate random walks in small grids ($x,y\le 5$), map to labels by $A_{i,j}=y(i-1)+j$, and feed to the solver; expect \texttt{YES} and the same $y$.}
\begin{minted}{python}
import random

def gen_path(x, y, steps, seed=0):
    random.seed(seed)
    i = random.randint(1, x)
    j = random.randint(1, y)
    path = []
    def lab(i, j): return y*(i-1)+j
    path.append(lab(i,j))
    for _ in range(steps):
        moves = []
        if i > 1: moves.append((-1,0))
        if i < x: moves.append((1,0))
        if j > 1: moves.append((0,-1))
        if j < y: moves.append((0,1))
        di,dj = random.choice(moves)
        i += di; j += dj
        path.append(lab(i,j))
    return path

def brute_check(a):
    # Use final solver
    from sys import stdout
    ok_line = solve_case(len(a), a).splitlines()[0]
    return ok_line == "YES"

# Quick sanity: random feasible paths should be accepted
for yy in [1,2,3,4]:
    aa = gen_path(3, yy, 20, seed=yy)
    assert brute_check(aa)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_case(n, a):
    diffs = set()
    for i in range(1, n):
        d = abs(a[i] - a[i-1])
        if d == 0:
            return "NO\n"
        if d > 1:
            diffs.add(d)
            if len(diffs) > 1:
                return "NO\n"
    y = 10**9 if not diffs else next(iter(diffs))
    for i in range(1, n):
        d = abs(a[i] - a[i-1])
        if d == 1:
            if (a[i]-1)//y != (a[i-1]-1)//y:
                return "NO\n"
        elif d == y:
            continue
        else:
            return "NO\n"
    x = (max(a) - 1) // y + 1
    return "YES\n{} {}\n".format(x, y)

def solve_all():
    parsed = read_input()
    if not parsed:
        return
    n, a = parsed
    sys.stdout.write(solve_case(n, a))

def main():
    solve_all()

if __name__ == "__main__":
    # Simple deterministic checks
    assert solve_case(4, [3,4,8,7]).startswith("YES")
    assert solve_case(3, [2,3,5]) == "NO\n"
    assert solve_case(2, [5,6]).startswith("YES")
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Deduce $y$ as the unique non-unit difference and validate each step as horizontal ($\pm 1$ within same row) or vertical ($\pm y$).}
\WHY{Row-major labeling appears in many grid-walk reconstruction problems; recognizing the quotient and remainder structure is a common interview theme.}
\CHECKLIST{
\begin{bullets}
\item Compute consecutive differences; reject zeros.
\item Ensure at most one non-unit difference; set $y$ accordingly or to $10^9$ if none.
\item For each step: $d\in\{1,y\}$.
\item If $d=1$, check same row via integer division by $y$.
\item Output $x=\left\lfloor\tfrac{\max a-1}{y}\right\rfloor+1$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$ (always \texttt{YES}).
\item $y=1$ valid: all moves are vertical ($d=y$).
\item Repeated label ($d=0$) is invalid.
\item Multiple non-unit differences $\Rightarrow$ \texttt{NO}.
\item Unit difference across a row boundary (e.g., $2\to 3$ when $y=2$) is invalid.
\item Very large labels near $10^9$ (ensure integer arithmetic only).
\item Strictly increasing sequence with occasional verticals.
\item Back-and-forth moves (allowed if consistent).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to reject $d=0$ (staying in place).
\item Treating any $d=1$ as always valid without same-row check.
\item Allowing two different non-unit differences.
\item Miscomputing row index: use $(v-1)//y$, not $v//y$.
\item Overflow concerns if using languages with fixed-size ints (Python is safe).
\item Choosing $x$ too small; must cover $\max a$.
\item Mishandling $y=1$ corner where vertical and unit differences coincide.
\end{bullets}}
\FAILMODES{Sequences that force two different vertical strides or that require crossing a row boundary horizontally will break naive checks that only look at difference magnitudes; the quotient-based row check prevents this.}
\ELI{Think of the grid flattened into rows of length $y$: left-right moves change by $1$ but cannot wrap to the next row; up-down moves jump by exactly $y$. Find $y$ from the jumps; if everything fits, you can always choose enough rows to include the largest number.}
\NotePages{3}

\end{document}