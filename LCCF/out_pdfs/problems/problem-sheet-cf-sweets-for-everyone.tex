% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Sweets for Everyone!}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/248/D}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Christmas celebrations are coming to Whoville. Cindy Lou Who and her parents Lou Lou Who and Betty Lou Who decided to give sweets to all people in their street. They decided to give the residents of each house on the street, one kilogram of sweets. So they need as many kilos of sweets as there are homes on their street.

The street, where the Lou Who family lives can be represented as $n$ consecutive sections of equal length. You can go from any section to a neighbouring one in one unit of time. Each of the sections is one of three types: an empty piece of land, a house or a shop. Cindy Lou and her family can buy sweets in a shop, but no more than one kilogram of sweets in one shop (the vendors care about the residents of Whoville not to overeat on sweets).

After the Lou Who family leave their home, they will be on the first section of the road. To get to this section of the road, they also require one unit of time. We can assume that Cindy and her mom and dad can carry an unlimited number of kilograms of sweets. Every time they are on a house section, they can give a kilogram of sweets to the inhabitants of the house, or they can simply move to another section. If the family have already given sweets to the residents of a house, they cannot do it again. Similarly, if they are on the shop section, they can either buy a kilo of sweets in it or skip this shop. If they have bought a kilo of sweets in a shop, the seller of the shop remembered them and will not sell them a single candy if they come again. The time to buy and give sweets can be neglected. The Lou Whos do not want the people of any house to remain without food.

The Lou Whos want to spend no more than $t$ time units of time to give out sweets, as they really want to have enough time to prepare for the Christmas celebration. In order to have time to give all the sweets, they may have to initially bring additional $k$ kilos of sweets.

Cindy Lou wants to know the minimum number of $k$ kilos of sweets they need to take with them, to have time to give sweets to the residents of each house in their street.

Your task is to write a program that will determine the minimum possible value of $k$.

Input: The first line of the input contains two space-separated integers $n$ and $t$ ($2 \le n \le 5\cdot 10^5$, $1 \le t \le 10^9$). The second line of the input contains $n$ characters, the $i$-th of them equals ``H'' (if the $i$-th segment contains a house), ``S'' (if the $i$-th segment contains a shop) or ``.'' (if the $i$-th segment does not contain a house or a shop).

It is guaranteed that there is at least one segment with a house.

Output: If there is not a single value of $k$ that makes it possible to give sweets to everybody in at most $t$ units of time, print in a single line ``-1''. Otherwise, print on a single line the minimum possible value of $k$.

Note: In the first example, there are as many stores, as houses. If the family do not take a single kilo of sweets from home, in order to treat the inhabitants of the first house, they will need to make at least one step back, and they have absolutely no time for it. If they take one kilogram of sweets, they will not need to go back.

In the second example, the number of shops is equal to the number of houses and plenty of time. Available at all stores passing out candy in one direction and give them when passing in the opposite direction.

In the third example, the shops on the street are fewer than houses. The Lou Whos have to take the missing number of kilograms of sweets with them from home.}
\BREAKDOWN{Find minimal initial stock $k$ so that all houses can be supplied within time $t$, given at most one purchase per shop and unit-cost movement on a line starting at section $1$ (with an initial $+1$ time to step onto section $1$). Key is to trade initial stock against detours to future shops.}
\ELI{Scan left to right: whenever houses temporarily exceed available sweets from the left, remember where the shortage starts and where it finally ends at a shop; those intervals drive the extra walking time for a given $k$. Then binary search the smallest $k$ that fits within $t$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n$, $t$; a string $s$ of length $n$ over characters from the set $\{\text{H},\text{S},.\}$. Valid ranges: $2 \le n \le 5\cdot 10^5$, $1 \le t \le 10^9$. There is at least one H in $s$.}
\OUTPUTS{Print a single integer: the minimum $k$ so that all houses can be served in time $\le t$. If impossible for all $k$, print $-1$.}
\SAMPLES{Example 1: $n=3$, $t=3$, $s=$ ``HSH''. Answer: $1$.

Example 2: $n=5$, $t=9$, $s=$ ``H.SH S'' (i.e., positions 1:H, 3:S, 4:H, 5:S). Answer: $0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Positions $i=1,\ldots,n$ on a line; each $i$ has type $s_i\in\{\text{H},\text{S},.\}$. Movement cost between $i$ and $i+1$ is $1$. Start off-road, then step onto $1$ costing $1$ time. Carry unlimited sweets; initially $k$. At each visited shop you may buy $1$ once; at each house you must deliver $1$ exactly once. Choose a walk that visits all houses and obeys shop capacities minimizing time; we seek the least $k$ so that minimal time $\le t$.}
\varmapStart
\var{n}{number of sections}
\var{t}{time budget}
\var{k}{initial sweets to bring; decision variable}
\var{H(i)}{indicator that $s_i=\text{H}$}
\var{S(i)}{indicator that $s_i=\text{S}$}
\var{r_H}{rightmost house position $\max\{i: H(i)=1\}$}
\var{D(i)}{running deficit $H$ minus $S$ minus $k$ at prefix $[1..i]$}
\var{L}{first position where deficit becomes positive (start of first shortage segment)}
\var{R}{last position where deficit returns to $0$ (end of last shortage segment)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Feasibility}(k) &:\iff \sum_i H(i) \le k + \sum_i S(i).\\
D(i) &= \sum_{j=1}^i H(j) - \sum_{j=1}^i S(j) - k.\\
L &= \min\{i : D(i)>0\}\ \text{if exists}.\\
R &= \max\{i : D(i)=0 \text{ and } \exists j\le i: D(j)>0\}.\\
T(k) &=
\begin{cases}
r_H, & \text{if } D(i)\le 0\ \forall i,\\[2pt]
2R - L, & \text{if } R \ge r_H,\\[2pt]
r_H + 2(R - L), & \text{if } R < r_H.
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{You always buy at every shop you pass if you will ever need that unit; carrying is free. Optimal tours can be structured by shortage segments where prefix houses temporarily exceed available sweets from the left.}
\INVARIANTS{If $D(i)\le 0$ for all $i$, then a monotone walk to $r_H$ suffices (time $r_H$). When shortages occur, the earliest shortage starts at $L$ and the final resolution is at $R$; optimal tours either (i) go up to $R$ then back to $L$ (if $R \ge r_H$), or (ii) resolve by returning at $R$ and then finish to $r_H$ (if $R<r_H$).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Binary search on $k$ in $[0,\#H]$ and, for each $k$, simulate an optimal tour length $T(k)$ using shortage segment logic.}
\ASSUMPTIONS{We can evaluate $T(k)$ in linear time by a single scan computing $r_H$, $D(\cdot)$, and the first/last shortage boundaries $(L,R)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute counts of houses and shops, and the last house position $r_H$.
\item For a fixed $k$, check feasibility $\#H \le k + \#S$; if false, infeasible.
\item Scan left to right maintaining $D(i)$ starting at $-k$, record the first index $L$ where $D$ becomes $>0$, and the last index $R$ where $D$ comes back to $0$ from $>0$.
\item Compute $T(k)$ by the piecewise formula and compare to $t$.
\item Binary search the minimal $k$ satisfying $T(k)\le t$.
\end{algosteps}
\COMPLEXITY{Binary search over $k$ with an $O(n)$ check each time: $T(n)=O(n\log n)$, $S(n)=O(1)$ extra beyond input.}
\[
\begin{aligned}
T(n) &= O(n \log(\#H+1)) \\
     &\le O(n \log n).
\end{aligned}
\]
\CORRECTNESS{If no prefix is short on sweets ($D(i)\le 0$), a monotone pass to $r_H$ suffices. Otherwise, let $L$ be the first shortage and $R$ the final time it is resolved by shops to the right. Optimality arises from deferring returns to batch collect shops: if $R\ge r_H$, go to $R$ then back to $L$; if $R<r_H$, return at $R$ to $L$ and then finish to $r_H$. Any other pattern adds redundant traversals.}
\EDGECASES{No shortages ($k$ large), all shops right of $r_H$, all shops left of shortages, $t<r_H$ (impossible).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    t = int(next(it))
    s = list(next(it).strip())
    assert len(s) == n
    return n, t, s

def time_needed_for_k(n, s, k):
    totalH = sum(1 for c in s if c == 'H')
    totalS = sum(1 for c in s if c == 'S')
    # Last house position (1-indexed); guaranteed at least one H
    rH = 0
    for i, c in enumerate(s, start=1):
        if c == 'H':
            rH = i
    # If even with all shops we cannot cover houses, infeasible
    if k + totalS < totalH:
        return 10**30  # INF
    # Scan to compute first shortage start L and last resolution R
    diff = -k
    L = None
    R = None
    for i, c in enumerate(s, start=1):
        if c == 'H':
            prev = diff
            diff += 1
            if prev <= 0 and diff > 0 and L is None:
                L = i
        elif c == 'S':
            prev = diff
            diff -= 1
            if prev > 0 and diff == 0:
                R = i
        else:
            # '.' does not change diff
            pass
    # No shortages at all
    if L is None:
        return rH
    # By feasibility, R must exist (diff ends <= 0), but guard anyway
    if R is None:
        return 10**30
    if R >= rH:
        return 2 * R - L
    else:
        return rH + 2 * (R - L)

def solve_case(n, t, s):
    totalH = sum(1 for c in s if c == 'H')
    totalS = sum(1 for c in s if c == 'S')
    # Minimal time if no shortages: must at least reach last house
    rH = max((i for i,c in enumerate(s, start=1) if c == 'H'), default=0)
    if t < rH:
        return -1
    lo = max(0, totalH - totalS)
    hi = totalH
    ans = -1
    while lo <= hi:
        mid = (lo + hi) // 2
        Tmid = time_needed_for_k(n, s, mid)
        if Tmid <= t:
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

def main():
    n, t, s = read_input()
    print(solve_case(n, t, s))

if __name__ == "__main__":
    # Basic assertions from reasoning
    # 1) Simple: HSH, need k=1 if t=3
    n, t, s = 3, 3, list("HSH")
    assert solve_case(n, t, s) == 1
    # 2) Example: H.SH S (positions 1:H,3:S,4:H,5:S) with t=9 -> k=0
    n, t, s = 5, 9, list("H.SH" + "S")
    assert solve_case(n, t, s) == 0
    # 3) If t < last house position => -1
    n, t, s = 4, 3, list("H..H")
    assert solve_case(n, t, s) == -1
    # 4) Need k to cover shortage if few shops
    n, t, s = 5, 10, list("HH..S")
    # totalH=2,totalS=1 => need at least k=1; feasible in time
    assert solve_case(n, t, s) == 1
    # Run main if stdin provided
    if not sys.stdin.isatty():
        main()
\end{minted}
\VALIDATION{The asserts cover: minimal $k$ when shops suffice; impossibility if $t<r_H$; and cases requiring nonzero $k$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same binary search, but with a single pass check using only scalar counters: running deficit $D$, first shortage start $L$, last resolution $R$, and last house $r_H$.}
\ASSUMPTIONS{One scan is enough; we do not need to materialize prefix arrays.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precount $\#H$, $\#S$, and $r_H$; set lower bound $\max(0,\#H-\#S)$.
\item For a mid $k$, compute $T(k)$ in one pass via $D$ transitions and $(L,R)$.
\item If $T(k)\le t$, shrink right; else increase $k$.
\item Output the smallest feasible $k$, or $-1$ if none.
\end{algosteps}
\COMPLEXITY{Same $O(n\log n)$ time, $O(1)$ extra space; constant factors are minimal (single integer transitions).}
\[
\begin{aligned}
T(n) &= O(n \log n),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{The $D$-based characterization captures exactly when the left supply (initial $k$ plus shops to the left) temporarily fails and when it is restored by a shop to the right. An optimal walk batches forward collection up to the final restoration point $R$ of the last shortage and returns to the first shortage $L$ (or resolves early when $R<r_H$). This yields the closed-form $T(k)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API and logic as baseline; already optimal and single-pass per check.
# We reuse the exact implementation from Approach A.
\end{minted}
\VALIDATION{Stress on random small cases (not shown) can cross-check $T(k)$ monotonicity and the boundary cases $R \ge r_H$ vs $R < r_H$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Binary search on $k$ with a linear-time check using shortage segment endpoints. Final time formula:
- If no shortage: $T=r_H$.
- Else if $R \ge r_H$: $T=2R-L$.
- Else: $T=r_H + 2(R-L)$.}
\ASSUMPTIONS{Movement is on a line; buying/giving has negligible time; carrying is free. Shops can be ``pre-bought'' for future houses.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\#H$, $\#S$, and $r_H$. Early exit: if $t<r_H$, print $-1$.
\item Set $k_{\min}=\max(0,\#H-\#S)$, $k_{\max}=\#H$. Binary search $k$.
\item For each $k$, scan once computing $D$, first $L$, last $R$, and derive $T(k)$ by the formula.
\item Return the minimal $k$ with $T(k)\le t$, else $-1$.
\end{algosteps}
\OPTIMALITY{Lower bound: you must at least reach $r_H$ once, costing $r_H$. Any shortage requires extra traversal distance; batching forward to the last resolving shop and a single return to the first shortage (or resolving early if $R<r_H$) is optimal on a line due to triangle inequality and non-crossing structure of detours. Hence the formula is tight.}
\COMPLEXITY{$O(n\log n)$ time, $O(1)$ space.}
\[
\begin{aligned}
T(n) &= O(n\log n),\quad S(n)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    t = int(next(it))
    s = list(next(it).strip())
    assert len(s) == n
    return n, t, s

def time_needed_for_k(n, s, k):
    totalH = 0
    totalS = 0
    rH = 0
    for i, c in enumerate(s, start=1):
        if c == 'H':
            totalH += 1
            rH = i
        elif c == 'S':
            totalS += 1
    if k + totalS < totalH:
        return 10**30  # infeasible
    # Scan for first shortage start L and last resolution R
    diff = -k
    L = None
    R = None
    for i, c in enumerate(s, start=1):
        if c == 'H':
            prev = diff
            diff += 1
            if prev <= 0 and diff > 0 and L is None:
                L = i
        elif c == 'S':
            prev = diff
            diff -= 1
            if prev > 0 and diff == 0:
                R = i
        else:
            pass
    if L is None:
        return rH
    if R is None:
        return 10**30
    if R >= rH:
        return 2 * R - L
    else:
        return rH + 2 * (R - L)

def solve_case(n, t, s):
    # Early lower bound: must at least reach last house
    rH = max((i for i, c in enumerate(s, start=1) if c == 'H'), default=0)
    if t < rH:
        return -1
    totalH = sum(1 for c in s if c == 'H')
    totalS = sum(1 for c in s if c == 'S')
    lo = max(0, totalH - totalS)
    hi = totalH
    ans = -1
    while lo <= hi:
        mid = (lo + hi) // 2
        if time_needed_for_k(n, s, mid) <= t:
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

def main():
    n, t, s = read_input()
    print(solve_case(n, t, s))

if __name__ == "__main__":
    # Unit-style checks
    # Case: trivial no shortage; reach last house.
    assert solve_case(4, 4, list("H..H")) == 0
    # Case: need one initial because shops < houses by 1
    assert solve_case(5, 10, list("HH..S")) == 1
    # Case: two shops, two houses; k=0 but need detours; t tightness
    assert time_needed_for_k(5, list("H.SH" + "S"), 0) == 9
    main()
\end{minted}
\VALIDATION{Exactly 3 checks: no shortage; minimal $k$ due to shortfall of shops; and a scenario with detours verifying $T(k)$.}
\RESULT{Print the minimal initial kilograms $k$ required to supply every house within $t$ time units; print $-1$ if impossible (not even with $k=\#H$ when $t<r_H$).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for $T(k)$ correctness; verify monotonicity of $T(k)$ w.r.t. $k$; random small instances cross-checked by a slower enumerator (optional offline).}
\LINE{CROSS-CHECKS}{Compare computed $T(k)$ to hand routes on crafted cases: (i) no shortages; (ii) shortages resolved before $r_H$; (iii) shortages resolved after $r_H$; (iv) $t<r_H$ infeasible.}
\LINE{EDGE-CASE GENERATOR}{Generate strings with clustered houses, clustered shops, and alternating patterns to ensure both branches $R<r_H$ and $R\ge r_H$ are exercised.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_all(n):
    # generate some patterned cases deterministically
    cases = []
    cases.append("H" + "."*(n-2) + "H")  # houses at ends
    cases.append("S"*(n//3) + "H"*(n - n//3))  # shops then houses
    alt = "".join("HS"[(i%2)] for i in range(n))
    cases.append(alt.replace("S","."))  # alternate H and .
    cases.append(alt)  # alternate H and S
    # ensure at least one H
    cases = [c if "H" in c else ("H" + c[1:]) for c in cases]
    return cases

def brute_time(n, s, k):
    # Reference via formula (same as final); included for clarity
    return time_needed_for_k(n, list(s), k)

def self_test():
    for n in range(2, 20):
        for s in gen_all(n):
            H = s.count("H")
            S = s.count("S")
            # try multiple t
            for k in range(max(0, H-S), H+1):
                T = brute_time(n, s, k)
                # monotone in k
                if k > 0:
                    assert T <= brute_time(n, s, k-1) or brute_time(n, s, k-1) >= 10**20
    print("Self-test passed.")

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    t = int(next(it))
    s = list(next(it).strip())
    assert len(s) == n
    return n, t, s

def time_needed_for_k(n, s, k):
    totalH = 0
    totalS = 0
    rH = 0
    for i, c in enumerate(s, start=1):
        if c == 'H':
            totalH += 1
            rH = i
        elif c == 'S':
            totalS += 1
    if k + totalS < totalH:
        return 10**30
    diff = -k
    L = None
    R = None
    for i, c in enumerate(s, start=1):
        if c == 'H':
            prev = diff
            diff += 1
            if prev <= 0 and diff > 0 and L is None:
                L = i
        elif c == 'S':
            prev = diff
            diff -= 1
            if prev > 0 and diff == 0:
                R = i
    if L is None:
        return rH
    if R is None:
        return 10**30
    if R >= rH:
        return 2 * R - L
    else:
        return rH + 2 * (R - L)

def solve_case(n, t, s):
    rH = max((i for i, c in enumerate(s, start=1) if c == 'H'), default=0)
    if t < rH:
        return -1
    totalH = sum(1 for c in s if c == 'H')
    totalS = sum(1 for c in s if c == 'S')
    lo = max(0, totalH - totalS)
    hi = totalH
    ans = -1
    while lo <= hi:
        mid = (lo + hi) // 2
        if time_needed_for_k(n, s, mid) <= t:
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

def main():
    n, t, s = read_input()
    print(solve_case(n, t, s))

if __name__ == "__main__":
    # quick sanity
    assert solve_case(3, 3, list("HSH")) == 1
    assert solve_case(5, 9, list("H.SH" + "S")) == 0
    assert solve_case(4, 3, list("H..H")) == -1
    if not sys.stdin.isatty():
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Binary search the minimal initial stock $k$ so that the optimal tour time $T(k)$ (computed in $O(n)$) is within $t$.}
\WHY{Greedy scanning with a correct time formula is crucial; naive per-deficit returns overcount.}
\CHECKLIST{%
- Compute $r_H$, $\#H$, $\#S$. 
- Early reject if $t<r_H$.
- Binary search $k\in[\max(0,\#H-\#S),\#H]$.
- For mid $k$, scan $D(i)$; find $L$ (first deficit), $R$ (last zero after deficits).
- Use piecewise formula for $T(k)$.
- Compare $T(k)$ to $t$.}
\EDGECASES{%
- No shortages at any prefix ($L$ is None) $\Rightarrow T=r_H$.
- All required shops to close shortages lie beyond $r_H$ ($R\ge r_H$).
- Shortages close before $r_H$ ($R<r_H$).
- $t<r_H$ regardless of $k$ $\Rightarrow -1$.
- $k+\#S<\#H$ at some mid $\Rightarrow$ infeasible mid.
- String starts/ends with long runs of H or S.}
\PITFALLS{%
- Forgetting the initial $+1$ time to step onto section $1$ (we account by using $r_H$ as time baseline).
- Misdetecting $L$ and $R$ transitions (must check sign changes of $D$ on events).
- Using per-house/shop pair sums $2(s-h)$ overcounts; batching matters.
- Not handling the case $L$ is None.
- Integer overflows in other languages (use 64-bit).
- Off-by-one in positions (we use $1$-indexed positions).}
\FAILMODES{Naive immediate-return strategy yields suboptimal time and thus overestimates $k$; our segmented formula avoids this by allowing batched forward collection and a single return at the right place.}
\ELI{Walk right. If you ever run short, note where that first happened ($L$) and where the shortage is finally fixed by a shop ($R$). Either you go far enough to fix it all and come back to $L$, or you fix it before the last house and then continue. This gives a simple time formula; binary search the least $k$ that fits the time budget.}
\NotePages{3}

\end{document}