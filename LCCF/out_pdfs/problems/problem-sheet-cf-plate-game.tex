% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Plate Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/197/A}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{You have a rectangular table with length $a$ and width $b$ and an infinite number of plates of radius $r$. Two players play the following game: they take turns to put the plates on the table so that the plates do not lie on each other (but they can touch each other), and so that any point on any plate is located within the table's border. During the game one cannot move the plates that already lie on the table. The player who cannot make another move loses. Determine which player wins, the one who moves first or the one who moves second, provided that both players play optimally well.

Input: A single line contains three space-separated integers $a$, $b$, $r$ ($1 \le a, b, r \le 100$) — the table sides and the plates' radius, correspondingly.

Output: If the player who moves first wins, print ``First''. Otherwise print ``Second''.

Note: In the first sample the table has place for only one plate. The first player puts a plate on the table, the second player cannot do that and loses.

In the second sample the table is so small that it does not have enough place even for one plate. So the first player loses without making a single move.}
\BREAKDOWN{Model legal placements of a circle of radius $r$ inside the $a \times b$ rectangle. Use symmetry or parity reasoning to determine which player makes the last move under optimal play.}
\ELI{If a plate of diameter $2r$ fits along both sides, the first player wins by a symmetry-pairing strategy; otherwise no one can move and the second wins.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Three integers $a$, $b$, $r$ with $1 \le a,b,r \le 100$.}
\OUTPUTS{Print exactly one word: \texttt{First} if the first player wins under optimal play, otherwise \texttt{Second}.}
\SAMPLES{Example 1: Input: \texttt{3 3 1} \quad Output: \texttt{First}

Example 2: Input: \texttt{4 4 3} \quad Output: \texttt{Second}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the table be the rectangle $[0,a] \times [0,b]$. Legal centers of plates are points in $[r,a-r] \times [r,b-r]$. Two plates of radius $r$ with centers $x,y$ are non-overlapping iff $\|x-y\| \ge 2r$. Players alternately pick legal centers respecting these constraints. The player with no legal move loses.}
\varmapStart
\var{a}{table length}
\var{b}{table width}
\var{r}{plate radius}
\var{S}{set of legal centers $[r,a-r] \times [r,b-r]$}
\var{d}{minimum allowed center distance $2r$}
\varmapEnd
\GOVERN{
\[
  \text{Win} =
  \begin{cases}
    \text{First}, & \text{if } 2r \le \min(a,b),\\
    \text{Second}, & \text{otherwise.}
  \end{cases}
\]
}
\ASSUMPTIONS{Plates may touch borders and each other; no plate can cross the boundary; the rectangle has central symmetry.}
\INVARIANTS{
\begin{bullets}
\item Central symmetry: reflecting any legal center across the rectangle center keeps it legal.
\item Distance preservation under central symmetry ensures non-overlap is preserved.
\item If the center is available, placing a plate at the exact rectangle center is legal iff $2r \le \min(a,b)$.
\end{bullets}
}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============
% (If you add any Formula pages above, no extra notes are required unless desired.)

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Approximate the maximum number of plates by a coarse grid packing: count how many diameters fit along each side, $g_a=\left\lfloor \tfrac{a}{2r} \right\rfloor$, $g_b=\left\lfloor \tfrac{b}{2r} \right\rfloor$, and use the parity of $g_a g_b$.}
\ASSUMPTIONS{Assumes optimal packing aligns to a rectangular lattice, which can underestimate the true maximum but is simple to compute.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $a,b,r$.
\item Compute $g_a=\left\lfloor \tfrac{a}{2r} \right\rfloor$ and $g_b=\left\lfloor \tfrac{b}{2r} \right\rfloor$.
\item If $g_a \cdot g_b$ is odd, print \texttt{First}, else print \texttt{Second}.
\end{algosteps}
\COMPLEXITY{Time and space are both $O(1)$; only constant-time arithmetic is used.}
\[
\begin{aligned}
T(n) &= O(1), \\
S(n) &= O(1). \\
\end{aligned}
\]
\CORRECTNESS{This method gives a lower bound on the number of plates via grid packing; the parity conclusion may be wrong because optimal packings need not be axis-aligned grids.}
\EDGECASES{If $g_a=0$ or $g_b=0$, the method correctly outputs \texttt{Second} since no plate fits at all.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (Approach A - Grid parity heuristic)
from typing import Tuple
import sys, io

def read_input(data: str = None) -> Tuple[int, int, int]:
    if data is None:
        data = sys.stdin.read()
    parts = data.strip().split()
    if len(parts) != 3:
        raise ValueError("Expected exactly three integers a b r.")
    a, b, r = map(int, parts)
    return a, b, r

def solve_case(a: int, b: int, r: int) -> str:
    # Grid-based lower-bound packing; parity heuristic (not always optimal).
    if r <= 0:
        return "Second"
    ga = a // (2 * r)
    gb = b // (2 * r)
    return "First" if (ga * gb) % 2 == 1 else "Second"

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Run self-tests
        assert solve_case(3, 3, 1) == "First"
        assert solve_case(4, 4, 3) == "Second"
        assert solve_case(1, 1, 1) == "Second"
        print("OK")
        return
    a, b, r = read_input(data)
    print(solve_case(a, b, r))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Tiny checks: \texttt{3 3 1} $\to$ \texttt{First}; \texttt{4 4 3} $\to$ \texttt{Second}; \texttt{1 1 1} $\to$ \texttt{Second}.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Symmetry Pairing Insight}
\WHICHFORMULA{Use the central-symmetry pairing strategy. If a center plate fits at the rectangle center, the first player mirrors every move of the second, guaranteeing the last move. Thus, the decision reduces to $2r \le \min(a,b)$.}
\ASSUMPTIONS{Rectangle is centrally symmetric; plates are congruent; touching is allowed; mirror images of legal moves remain legal and non-overlapping.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $a,b,r$.
\item If $2r \le \min(a,b)$, print \texttt{First}; else print \texttt{Second}.
\item Justification: when $2r \le \min(a,b)$, the first places at the rectangle center and mirrors every opponent move across the center.
\end{algosteps}
\COMPLEXITY{Constant time and space.}
\[
\begin{aligned}
T(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Central reflection preserves feasibility and distances. After the first move at the center, all remaining legal positions can be partitioned into mirrored pairs. The second player always takes one of a pair; the first responds with its mate, ensuring the last move.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF TEMPLATE (Approach B - Direct condition via symmetry)
from typing import Tuple
import sys, io

def read_input(data: str = None) -> Tuple[int, int, int]:
    if data is None:
        data = sys.stdin.read()
    parts = data.strip().split()
    if len(parts) != 3:
        raise ValueError("Expected exactly three integers a b r.")
    a, b, r = map(int, parts)
    return a, b, r

def solve_case(a: int, b: int, r: int) -> str:
    return "First" if 2 * r <= min(a, b) else "Second"

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests
        assert solve_case(3, 3, 1) == "First"
        assert solve_case(4, 4, 3) == "Second"
        assert solve_case(2, 2, 1) == "First"
        print("OK")
        return
    a, b, r = read_input(data)
    print(solve_case(a, b, r))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Edge checks: smallest fit \texttt{2 2 1} $\to$ \texttt{First}; just-too-large \texttt{3 3 2} $\to$ \texttt{Second}; long-thin fail \texttt{100 1 1} $\to$ \texttt{Second}.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Strategy-Stealing With Center Placement}
\WHICHFORMULA{Exact decision: output \texttt{First} iff $2r \le \min(a,b)$, else \texttt{Second}.}
\ASSUMPTIONS{Same as Approach B; this is the standard Codeforces solution.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read integers $a,b,r$.
\item If $2r \le \min(a,b)$, output \texttt{First}.
\item Otherwise, output \texttt{Second}.
\end{algosteps}
\OPTIMALITY{No algorithm can do better than $O(1)$ time on this input size. The decision criterion is both necessary and sufficient by the pairing argument.}
\COMPLEXITY{Constant time and space with trivial arithmetic.}
\[
\begin{aligned}
T(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import Tuple
import sys, io

def read_input(data: str = None) -> Tuple[int, int, int]:
    if data is None:
        data = sys.stdin.read()
    parts = data.strip().split()
    if len(parts) != 3:
        raise ValueError("Expected exactly three integers a b r.")
    a, b, r = map(int, parts)
    return a, b, r

def solve_case(a: int, b: int, r: int) -> str:
    return "First" if 2 * r <= min(a, b) else "Second"

def solve_all() -> None:
    a, b, r = read_input()
    print(solve_case(a, b, r))

def _run_tests():
    def run_io(s: str) -> str:
        a, b, r = read_input(s)
        from io import StringIO
        buf = io.StringIO()
        # direct call to solution
        out = solve_case(a, b, r)
        return out.strip()
    assert run_io("3 3 1\n") == "First"
    assert run_io("4 5 3\n") == "Second"
    assert run_io("2 2 1\n") == "First"

def main():
    data = sys.stdin.read()
    if not data.strip():
        _run_tests()
        print("OK")
        return
    a, b, r = read_input(data)
    print(solve_case(a, b, r))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts: \texttt{3 3 1} $\to$ \texttt{First}; \texttt{4 5 3} $\to$ \texttt{Second}; \texttt{2 2 1} $\to$ \texttt{First}.}
\RESULT{Print \texttt{First} iff a plate of diameter $2r$ fits in both dimensions, otherwise \texttt{Second}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify boundary thresholds around $2r = \min(a,b)$; symmetric cases with $a=b$; degenerate thin rectangles where one side $<2r$; random small integers.}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C over small ranges. Approach B and C must always agree; discrepancies with A highlight why grid-parity can be wrong.}
\LINE{EDGE-CASE GENERATOR}{Enumerate all triples with $1 \le a,b,r \le 6$ to exercise threshold behavior exhaustively.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def brute_decision(a: int, b: int, r: int) -> str:
    # Proven optimal rule
    return "First" if 2 * r <= min(a, b) else "Second"

def grid_parity(a: int, b: int, r: int) -> str:
    if r <= 0:
        return "Second"
    ga = a // (2 * r)
    gb = b // (2 * r)
    return "First" if (ga * gb) % 2 == 1 else "Second"

def cross_check_small():
    bad = []
    for a in range(1, 7):
        for b in range(1, 7):
            for r in range(1, 7):
                opt = brute_decision(a, b, r)
                approx = grid_parity(a, b, r)
                if opt != approx:
                    bad.append((a, b, r, opt, approx))
    return bad

assert brute_decision(3, 3, 1) == "First"
assert brute_decision(4, 4, 3) == "Second"
assert brute_decision(2, 2, 1) == "First"
# Run cross-check, just collect; do not print to keep deterministic output expectations
_ = cross_check_small()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
from typing import Tuple
import sys, io

def read_input(data: str = None) -> Tuple[int, int, int]:
    if data is None:
        data = sys.stdin.read()
    parts = data.strip().split()
    if len(parts) != 3:
        raise ValueError("Expected exactly three integers a b r.")
    a, b, r = map(int, parts)
    return a, b, r

def solve_case(a: int, b: int, r: int) -> str:
    return "First" if 2 * r <= min(a, b) else "Second"

def main():
    data = sys.stdin.read()
    if not data.strip():
        # sanity asserts
        assert solve_case(3, 3, 1) == "First"
        assert solve_case(4, 5, 3) == "Second"
        assert solve_case(2, 2, 1) == "First"
        print("OK")
        return
    a, b, r = read_input(data)
    print(solve_case(a, b, r))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Decide winner by the single condition $2r \le \min(a,b)$.}
\WHY{Classic symmetry-pairing tactic; appears in geometry-tiling impartial games and is a common trick in interviews and contests.}
\CHECKLIST{
\begin{bullets}
\item Compute $2r$ and compare to both $a$ and $b$.
\item If both sides fit, answer \texttt{First}; else \texttt{Second}.
\item Remember plates may touch each other and borders.
\item Use integers throughout; no floating-point needed.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $a=2r$, $b \ge 2r$ exactly fits: \texttt{First}.
\item $b=2r$, $a \ge 2r$ exactly fits: \texttt{First}.
\item $\min(a,b)=2r-1$: just too small, \texttt{Second}.
\item Very thin rectangle, e.g., $a \gg b$ but $b<2r$: \texttt{Second}.
\item Smallest valid inputs: $a=b=r=1$: \texttt{Second}.
\item Large side symmetry: $a=b$ does not change rule.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting that touching is allowed; use $\le$ not $<$.
\item Overcomplicating by attempting to count packings or simulate.
\item Floating-point comparisons introducing off-by-one errors.
\item Misreading the condition as $2r \le a+b$ or similar.
\item Mishandling input parsing when extra whitespace is present.
\item Printing quotes around words; output must be plain \texttt{First} or \texttt{Second}.
\end{bullets}
}
\FAILMODES{Any approach that tries to compute the exact number of plates or relies on grid packing can fail; the symmetry-stealing proof bypasses packing complexity entirely.}
\ELI{If a plate of diameter $2r$ fits both ways, the first player plays in the middle and then always mirrors the second player's moves. That guarantees the first player gets the last move. If even one plate does not fit, the second wins immediately.}
\NotePages{3}

\end{document}