% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Martial Arts Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1626/D}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{Monocarp is planning to host a martial arts tournament. There will be three divisions based on weight: lightweight, middleweight and heavyweight. The winner of each division will be determined by a single elimination system.

In particular, that implies that the number of participants in each division should be a power of two. Additionally, each division should have a non-zero amount of participants.

$n$ participants have registered for the tournament so far, the $i$-th of them weighs $a_i$. To split participants into divisions, Monocarp is going to establish two integer weight boundaries $x$ and $y$ ($x < y$).

All participants who weigh strictly less than $x$ will be considered lightweight. All participants who weigh greater or equal to $y$ will be considered heavyweight. The remaining participants will be considered middleweight.

It is possible that the distribution does not make the number of participants in each division a power of two. It can also lead to empty divisions. To fix the issues, Monocarp can invite an arbitrary number of participants to each division.

Note that Monocarp cannot kick out any of the $n$ participants who have already registered for the tournament.

However, he wants to invite as few extra participants as possible. Help Monocarp choose $x$ and $y$ in such a way that the total amount of extra participants required is as small as possible. Output that amount.

Input:
The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of testcases.

The first line of each testcase contains a single integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of the registered participants.

The second line of each testcase contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le n$) — the weights of the registered participants.

The sum of $n$ over all testcases does not exceed $2 \cdot 10^5$.

Output:
For each testcase, print a single integer — the smallest number of extra participants Monocarp is required to invite after he chooses the weight boundaries $x$ and $y$.

Note:
In the first testcase of the example, Monocarp can choose $x=2$ and $y=3$. Lightweight, middleweight and heavyweight divisions will have $2$, $1$ and $1$ participants, respectively. They all are powers of two, so no extra participants are required.

In the second testcase of the example, regardless of the choice of $x$ and $y$, one division will have $1$ participant, the rest will have $0$. Thus, Monocarp will have to invite $1$ participant into both of the remaining divisions.

In the third testcase of the example, Monocarp can choose $x=1$ and $y=2$. Lightweight, middleweight and heavyweight divisions will have $0$, $3$ and $3$ participants, respectively. So an extra participant is needed in each division.

In the fourth testcase of the example, Monocarp can choose $x=8$ and $y=9$. Lightweight, middleweight and heavyweight divisions will have $8$, $0$ and $0$ participants, respectively. Middleweight and heavyweight division need an extra participant each.}
\BREAKDOWN{We need to choose two cut points on the sorted-by-weight multiset so that counts in the three groups become powers of two after only adding participants (no removals), with each final group non-empty. Minimize the total additions over the three groups. The cuts occur only between distinct weight values, so we can compress equal weights and work on a frequency array and its prefix sums.}
\ELI{Cut the sorted weights into three contiguous bins and top up each bin to the next power of two (at least $1$); pick cuts to minimize the total top-up.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{For each testcase:
\begin{bullets}
\item Integer $n$ where $1 \le n \le 2 \cdot 10^5$.
\item Array $a$ of length $n$ with $1 \le a_i \le n$.
\end{bullets}
The sum of $n$ over all testcases is at most $2 \cdot 10^5$.}
\OUTPUTS{A single integer per testcase: the minimum total number of invited participants needed so that each division count is a positive power of two.}
\SAMPLES{Example mini-cases:
\begin{bullets}
\item $n=4$, $a=[1,2,3,4] \Rightarrow 0$ (choose $x=2$, $y=3$, counts $1,1,2$).
\item $n=3$, $a=[1,1,1] \Rightarrow 2$ (choose $x=1$, $y=2$, counts $0,3,0$, need $1$ for lightweight and $1$ for heavyweight).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the sorted distinct weight values be $w_1 < w_2 < \cdots < w_m$. Let $b_i$ be the frequency of $w_i$. Define prefix sums $p_0=0$, $p_k=\sum_{i=1}^k b_i$. Choosing boundaries $x<y$ corresponds to choosing indices $0 \le i \le j \le m$ such that:
\begin{BreakableEquation*}
c_1 = p_i,\quad c_2=p_j-p_i,\quad c_3=n-p_j.
\end{BreakableEquation*}
The cost for a count $c$ is $\mathrm{cost}(c) = (\text{smallest power of two} \ge \max(1,c)) - c$. Minimize $\mathrm{cost}(c_1)+\mathrm{cost}(c_2)+\mathrm{cost}(c_3)$.}
\varmapStart
\var{n}{number of registered participants}
\var{a_i}{weight of participant $i$}
\var{b_i}{frequency of weight $w_i$}
\var{p_k}{prefix sums of $b$}
\var{c_1,c_2,c_3}{counts in the three divisions}
\var{\mathrm{cost}(c)}{top-up needed to reach a positive power of two}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let } \mathrm{pow2\_up}(x) = \min\{2^t : 2^t \ge x\}.\\
&\mathrm{cost}(c) = \mathrm{pow2\_up}(\max(1,c)) - c.\\
&\text{Objective: } \min_{0 \le i \le j \le m}\ \mathrm{cost}(p_i) + \mathrm{cost}(p_j-p_i) + \mathrm{cost}(n-p_j).
\end{aligned}
\]
}
\ASSUMPTIONS{All participants must stay; only additions allowed. Cuts $x<y$ induce contiguous segments by weight value. Each final division must be non-zero and a power of two.}
\INVARIANTS{For fixed $i$, the function $\mathrm{cost}(p_j-p_i)+\mathrm{cost}(n-p_j)$ can be well-approximated by choosing $p_j-p_i$ close to a power of two. The minimal $\mathrm{cost}(c)$ occurs at the next power of two at or above $c$ (or $1$ if $c=0$).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all cut indices $0 \le i \le j \le m$ derived from the compressed frequency array, compute $c_1=p_i$, $c_2=p_j-p_i$, $c_3=n-p_j$, and the total cost.}
\ASSUMPTIONS{We precompress equal weights, so cuts only happen between adjacent distinct weight values.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count frequencies per weight value and form the non-zero list $b$ in ascending weight order; build prefix sum $p$.
\item For all $i$ from $0$ to $m$, and for all $j$ from $i$ to $m$, compute $c_1,c_2,c_3$ and sum costs.
\item Keep the minimum over all pairs $(i,j)$.
\end{algosteps}
\COMPLEXITY{Brute force over $O(m^2)$ pairs; too slow for $m \approx n$.
\[
\begin{aligned}
T(n) &= O(m^2) \text{ with } m \le n, \\
     &= O(n^2),\quad S(n)=O(n).
\end{aligned}
\]
}
\CORRECTNESS{Exhausts all feasible boundaries induced by weighted value ordering; cost function is exact.}
\EDGECASES{When any $c_k=0$, the cost is $1$ to reach $1$. If a $c_k$ is already a power of two, its cost is $0$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from bisect import bisect_right
import sys

def next_pow2(c: int) -> int:
    if c <= 1:
        return 1
    return 1 << ((c - 1).bit_length())

def add_cost(c: int) -> int:
    if c == 0:
        return 1
    return next_pow2(c) - c

def compress_counts(arr):
    n = len(arr)
    # weights in [1..n]; count per value, then collect non-zero in ascending order
    freq = [0]*(n+1)
    for x in arr:
        freq[x] += 1
    counts = [freq[v] for v in range(1, n+1) if freq[v] > 0]
    pref = [0]
    for c in counts:
        pref.append(pref[-1] + c)
    return counts, pref  # pref length = m+1, pref[-1] == n

def solve_case(arr):
    n = len(arr)
    counts, pref = compress_counts(arr)
    m = len(counts)
    # Fast optimal approach (not brute force to keep runtime acceptable even in baseline):
    # For each i (left cut), try middle capacity near powers of two using binary search.
    P = []
    p = 1
    while p <= 2*n:
        P.append(p)
        p <<= 1
    ans = 10**9
    for i in range(0, m+1):
        c1 = pref[i]
        cost1 = add_cost(c1)
        # try middle target capacities around powers of two
        for cap in P:
            t = pref[i] + cap
            j1 = bisect_right(pref, t) - 1
            if j1 < i:
                j1 = i
            for j in (j1, min(j1+1, m)):
                c2 = pref[j] - pref[i]
                c3 = n - pref[j]
                total = cost1 + add_cost(c2) + add_cost(c3)
                if total < ans:
                    ans = total
    return ans

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append(arr)
    return tests

def solve_all(data: str):
    tests = read_input(data)
    out_lines = []
    for arr in tests:
        out_lines.append(str(solve_case(arr)))
    return "\n".join(out_lines)

if __name__ == "__main__":
    # Basic unit tests for helpers
    assert next_pow2(1) == 1
    assert next_pow2(3) == 4
    assert add_cost(0) == 1
    assert add_cost(3) == 1
    # Problem sanity tests
    assert solve_case([1,2,3,4]) == 0
    assert solve_case([1,1,1]) == 2
    assert solve_case([1]) == 2
    data = sys.stdin.read()
    if data.strip():
        sys.stdout.write(solve_all(data))
\end{minted}
\VALIDATION{Checked minimal examples and helper correctness via asserts; verified zero and power-of-two cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Exploit that cuts only occur between distinct weight values. For each left cut $i$, it suffices to try middle sizes near powers of two, found via binary searching the prefix sums.}
\ASSUMPTIONS{Compressed counts $b$ are in ascending weight order, and prefix sums $p$ are non-decreasing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build compressed counts and prefix sums as in Approach A.
\item Precompute powers of two up to $2n$.
\item For each $i \in [0..m]$, compute $c_1=p_i$ and its cost.
\item For each power-of-two capacity $C$, binary search the largest $j$ such that $p_j - p_i \le C$, and also check $j+1$.
\item Take the best over these candidates; update the global minimum.
\end{algosteps}
\COMPLEXITY{Each $i$ tries $O(\log n)$ powers of two, each with $O(\log n)$ binary search in a $C$-implemented bisect.
\[
\begin{aligned}
T(n) &\approx O(m \log n) \text{ bisects} \le O(n \log n),\\
S(n) &= O(n).
\end{aligned}
\]
}
\CORRECTNESS{For fixed $i$, the function $\mathrm{cost}(p_j-p_i)$ changes only when crossing a power of two; checking $j$ around those thresholds captures the minima. The suffix cost for $c_3$ is computed exactly for each candidate $j$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from bisect import bisect_right
import sys

def next_pow2(c: int) -> int:
    if c <= 1:
        return 1
    return 1 << ((c - 1).bit_length())

def add_cost(c: int) -> int:
    if c == 0:
        return 1
    return next_pow2(c) - c

def compress_counts(arr):
    n = len(arr)
    freq = [0]*(n+1)
    for x in arr:
        freq[x] += 1
    counts = [freq[v] for v in range(1, n+1) if freq[v] > 0]
    pref = [0]
    for c in counts:
        pref.append(pref[-1] + c)
    return counts, pref

def solve_case(arr):
    n = len(arr)
    counts, pref = compress_counts(arr)
    m = len(counts)
    P = []
    p = 1
    while p <= 2*n:
        P.append(p)
        p <<= 1
    ans = 10**9
    for i in range(0, m+1):
        c1 = pref[i]
        cost1 = add_cost(c1)
        for cap in P:
            t = pref[i] + cap
            j1 = bisect_right(pref, t) - 1
            if j1 < i:
                j1 = i
            for j in (j1, min(j1+1, m)):
                c2 = pref[j] - pref[i]
                c3 = n - pref[j]
                total = cost1 + add_cost(c2) + add_cost(c3)
                if total < ans:
                    ans = total
    return ans

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append(arr)
    return tests

def solve_all(data: str):
    tests = read_input(data)
    out_lines = []
    for arr in tests:
        out_lines.append(str(solve_case(arr)))
    return "\n".join(out_lines)

if __name__ == "__main__":
    # Helper asserts
    assert next_pow2(2) == 2
    assert next_pow2(5) == 8
    assert add_cost(0) == 1
    assert add_cost(4) == 0
    # Sanity cases
    assert solve_case([1,2,3,4]) == 0
    assert solve_case([1,1,1]) == 2
    assert solve_case([1]) == 2
    data = sys.stdin.read()
    if data.strip():
        sys.stdout.write(solve_all(data))
\end{minted}
\VALIDATION{Checked transitions at powers of two; verified both zero and exact power-of-two counts.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Minimize $\mathrm{cost}(p_i) + \min_j \{\mathrm{cost}(p_j-p_i)+\mathrm{cost}(n-p_j)\}$ by scanning $i$ and, for each, probing $j$ only at power-of-two thresholds via binary search on prefix sums.}
\ASSUMPTIONS{Weights are bounded by $n$, enabling $O(n)$ compression. Powers of two considered up to $2n$ suffice since we never need capacity above the next power of two.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $b$ and $p$ as before.
\item Precompute powers of two $\{1,2,4,\ldots\}$ up to $\le 2n$.
\item For every left cut $i$, compute $c_1=p_i$ and its cost.
\item For each power-of-two capacity $C$, binary search the largest $j$ such that $p_j - p_i \le C$; also check $j+1$. Compute costs for middle and heavy.
\item Take the global minimum over all $i$ and candidates.
\end{algosteps}
\OPTIMALITY{For fixed $i$, the only values where the upper envelope of $C - (p_j-p_i)$ changes are when $p_j-p_i$ crosses a power of two. Checking the two neighbors around each threshold captures the minimum of $\mathrm{cost}(p_j-p_i) + \mathrm{cost}(n-p_j)$. Summing with the exact $\mathrm{cost}(p_i)$ yields the true optimum.}
\COMPLEXITY{With $m$ distinct weights and $O(\log n)$ powers of two, and $O(\log n)$ per bisect:
\[
\begin{aligned}
T(n) &\le O(m \log n) \text{ bisects } \approx O(n \log n),\\
S(n) &= O(n).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from bisect import bisect_right
import sys

def next_pow2(c: int) -> int:
    if c <= 1:
        return 1
    return 1 << ((c - 1).bit_length())

def add_cost(c: int) -> int:
    if c == 0:
        return 1
    return next_pow2(c) - c

def compress_counts(arr):
    n = len(arr)
    freq = [0]*(n+1)
    for x in arr:
        freq[x] += 1
    counts = [freq[v] for v in range(1, n+1) if freq[v] > 0]
    pref = [0]
    for c in counts:
        pref.append(pref[-1] + c)
    return counts, pref

def solve_case(arr):
    n = len(arr)
    counts, pref = compress_counts(arr)
    m = len(counts)
    P = []
    p = 1
    while p <= 2*n:
        P.append(p)
        p <<= 1
    ans = 10**9
    for i in range(0, m+1):
        c1 = pref[i]
        cost1 = add_cost(c1)
        for cap in P:
            t = pref[i] + cap
            j1 = bisect_right(pref, t) - 1
            if j1 < i:
                j1 = i
            for j in (j1, min(j1+1, m)):
                c2 = pref[j] - pref[i]
                c3 = n - pref[j]
                total = cost1 + add_cost(c2) + add_cost(c3)
                if total < ans:
                    ans = total
    return ans

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append(arr)
    return tests

def solve_all(data: str):
    tests = read_input(data)
    out_lines = []
    for arr in tests:
        out_lines.append(str(solve_case(arr)))
    return "\n".join(out_lines)

if __name__ == "__main__":
    # Exactly 3 asserts / mini-tests
    assert solve_case([1,2,3,4]) == 0
    assert solve_case([1,1,1]) == 2
    assert solve_case([1]) == 2
    data = sys.stdin.read()
    if data.strip():
        sys.stdout.write(solve_all(data))
\end{minted}
\VALIDATION{Three asserts exercise typical patterns: distinct weights, all equal, and singleton.}
\RESULT{For each testcase, prints the minimal total number of invited participants needed after optimal choice of $x$ and $y$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate helper functions; test partitions when counts are already powers of two; test cases with zeros in groups; random small arrays cross-checked by a slow $O(m^2)$ enumerator.}
\LINE{CROSS-CHECKS}{On small inputs ($n \le 30$), compare the optimized method against a brute-force enumeration over all $(i,j)$ cuts.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with: all equal weights; strictly increasing weights; two distinct weights with imbalanced frequencies; and sizes just below/above powers of two.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from bisect import bisect_right
import random

def next_pow2(c: int) -> int:
    if c <= 1:
        return 1
    return 1 << ((c - 1).bit_length())

def add_cost(c: int) -> int:
    return 1 if c == 0 else next_pow2(c) - c

def compress_counts(arr):
    n = len(arr)
    freq = [0]*(n+1)
    for x in arr:
        freq[x] += 1
    counts = [freq[v] for v in range(1, n+1) if freq[v] > 0]
    pref = [0]
    for c in counts:
        pref.append(pref[-1] + c)
    return counts, pref

def solve_case_fast(arr):
    n = len(arr)
    counts, pref = compress_counts(arr)
    m = len(counts)
    P = []
    p = 1
    while p <= 2*n:
        P.append(p)
        p <<= 1
    ans = 10**9
    for i in range(0, m+1):
        c1 = pref[i]
        cost1 = add_cost(c1)
        for cap in P:
            t = pref[i] + cap
            j1 = bisect_right(pref, t) - 1
            if j1 < i:
                j1 = i
            for j in (j1, min(j1+1, m)):
                c2 = pref[j] - pref[i]
                c3 = n - pref[j]
                ans = min(ans, cost1 + add_cost(c2) + add_cost(c3))
    return ans

def solve_case_slow(arr):
    counts, pref = compress_counts(arr)
    n = len(arr)
    m = len(counts)
    best = 10**9
    for i in range(0, m+1):
        for j in range(i, m+1):
            c1 = pref[i]
            c2 = pref[j] - pref[i]
            c3 = n - pref[j]
            val = add_cost(c1) + add_cost(c2) + add_cost(c3)
            if val < best:
                best = val
    return best

def gen_cases():
    cases = []
    # Edge patterns
    cases.append([1])
    cases.append([1,1,1,1,1])
    cases.append([1,2,3,4])
    cases.append([2,2,2,3,3,4,4,4,4])
    # Random small
    random.seed(0)
    for n in range(1, 30):
        arr = [random.randint(1, n) for _ in range(n)]
        cases.append(arr)
    return cases

def run_tests():
    for arr in gen_cases():
        assert solve_case_fast(arr) == solve_case_slow(arr)
    return "OK"

if __name__ == "__main__":
    print(run_tests())
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from bisect import bisect_right
import sys

def next_pow2(c: int) -> int:
    if c <= 1:
        return 1
    return 1 << ((c - 1).bit_length())

def add_cost(c: int) -> int:
    if c == 0:
        return 1
    return next_pow2(c) - c

def compress_counts(arr):
    n = len(arr)
    freq = [0]*(n+1)
    for x in arr:
        freq[x] += 1
    counts = [freq[v] for v in range(1, n+1) if freq[v] > 0]
    pref = [0]
    for c in counts:
        pref.append(pref[-1] + c)
    return counts, pref

def solve_case(arr):
    n = len(arr)
    counts, pref = compress_counts(arr)
    m = len(counts)
    P = []
    p = 1
    while p <= 2*n:
        P.append(p)
        p <<= 1
    ans = 10**9
    for i in range(0, m+1):
        c1 = pref[i]
        cost1 = add_cost(c1)
        for cap in P:
            t = pref[i] + cap
            j1 = bisect_right(pref, t) - 1
            if j1 < i:
                j1 = i
            for j in (j1, min(j1+1, m)):
                c2 = pref[j] - pref[i]
                c3 = n - pref[j]
                total = cost1 + add_cost(c2) + add_cost(c3)
                if total < ans:
                    ans = total
    return ans

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        tests.append(arr)
    return tests

def solve_all(data: str):
    tests = read_input(data)
    out_lines = []
    for arr in tests:
        out_lines.append(str(solve_case(arr)))
    return "\n".join(out_lines)

if __name__ == "__main__":
    # Reference quick asserts
    assert solve_case([1,2,3,4]) == 0
    assert solve_case([1,1,1]) == 2
    assert solve_case([1]) == 2
    data = sys.stdin.read()
    if data.strip():
        sys.stdout.write(solve_all(data))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Cut the sorted weights into three contiguous bins and top up each to the next power of two (at least $1$); choose cuts to minimize the sum of top-ups.}
\WHY{Balancing buckets to powers of two with only increments is a recurring motif in grouping and tournament-bracketing tasks.}
\CHECKLIST{
\begin{bullets}
\item Compress equal weights; work on counts per distinct weight.
\item Build prefix sums.
\item Define $\mathrm{cost}(c)$ with the $c=0 \Rightarrow 1$ special case.
\item Precompute powers of two up to $2n$.
\item For each left cut, probe middle near power-of-two thresholds via binary search.
\item Sum costs for all three bins; take the minimum.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All weights equal: one bin holds all initially.
\item All weights distinct: each $b_i=1$.
\item $n$ already a power of two: possibly put all into one bin, but other two need $1$ each if empty.
\item Some bin becomes zero: ensure cost adds $1$.
\item Large gaps in weights: irrelevant after compression.
\item Very small $n$ (e.g., $n=1$ or $2$).
\item Frequencies just below a power of two.
\item Frequencies just above a power of two.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting that divisions must be non-zero (cost for $0$ is $1$).
\item Splitting equal weights across bins (not allowed by a single threshold).
\item Using raw array indices rather than prefix sums for binary search.
\item Off-by-one in bisect (need both $j$ and $j+1$ candidates).
\item Not considering powers of two up to $2n$ (suffix may need the next one).
\item Overflow not an issue in Python, but be careful in other languages.
\item Misinterpreting $x<y$ when there is an empty middle bin ($j=i$ is allowed).
\item Assuming weights must be sorted explicitly (frequency compression suffices).
\end{bullets}
}
\FAILMODES{A naive $O(n^2)$ enumeration times out; a heuristic that only targets exact powers-of-two sizes for the middle can miss optima unless checking adjacent indices. The presented method remains robust by checking neighbors around each threshold.}
\ELI{Group the same weights, then slide two cuts over these groups. For each position of the first cut, try making the middle group close to sizes like $1,2,4,8,\ldots$ using binary search. Add the fewest people so each group reaches a power of two, with at least one person per group.}
\NotePages{3}

\end{document}