% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cat and Mouse}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/cat-and-mouse/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{A game on an \textbf{undirected} graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: \texttt{graph[a]} is a list of all nodes \texttt{b} such that \texttt{ab} is an edge of the graph. The mouse starts at node \texttt{1} and goes first, the cat starts at node \texttt{2} and goes second, and there is a hole at node \texttt{0}. During each player's turn, they \textbf{must} travel along one edge of the graph that meets where they are. For example, if the Mouse is at node \texttt{1}, it \textbf{must} travel to any node in \texttt{graph[1]}. Additionally, it is not allowed for the Cat to travel to the Hole (node \texttt{0}). Then, the game can end in three ways:
\begin{bullets}
\item If ever the Cat occupies the same node as the Mouse, the Cat wins.
\item If ever the Mouse reaches the Hole, the Mouse wins.
\item If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.
\end{bullets}
Given a \texttt{graph}, and assuming both players play optimally, return
\begin{bullets}
\item \texttt{1} if the mouse wins the game,
\item \texttt{2} if the cat wins the game, or
\item \texttt{0} if the game is a draw.
\end{bullets}
\textbf{Example 1:} Input: \texttt{graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]}, Output: \texttt{0}. \\
\textbf{Example 2:} Input: \texttt{graph = [[1,3],[0],[3],[0,2]]}, Output: \texttt{1}. \\
\textbf{Constraints:}
\begin{bullets}
\item \texttt{3 \le graph.length \le 50}
\item \texttt{1 \le graph[i].length < graph.length}
\item \texttt{0 \le graph[i][j] < graph.length}
\item \texttt{graph[i][j] != i}
\item \texttt{graph[i]} is unique.
\item The mouse and the cat can always move.
\end{bullets}}
\BREAKDOWN{Model states as $(m,c,t)$ for mouse position $m$, cat position $c$, and turn $t\in\{0,1\}$ (mouse or cat). Identify terminal states, then propagate outcomes by optimal play.}
\ELI{This is a turn-based game on an undirected graph; compute who wins from each state by working backward from obvious win states using degrees and retrograde analysis.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single list of lists \texttt{graph} where \texttt{graph[a]} contains distinct neighbors of node $a$. Nodes are integers in $[0,n-1]$ with $n=\lvert\texttt{graph}\rvert$, $3\le n\le 50$. The graph is undirected and simple; both mouse and cat always have at least one legal move from their starting positions.}
\OUTPUTS{Return an integer among $\{0,1,2\}$: $1$ if the mouse wins, $2$ if the cat wins, $0$ for a draw, assuming optimal play.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]} $\Rightarrow$ Output: \texttt{0}.
\item Input: \texttt{[[1,3],[0],[3],[0,2]]} $\Rightarrow$ Output: \texttt{1}.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{0,1,\ldots,n-1\}$ be graph nodes. A game state is $(m,c,t)\in V\times V\times\{0,1\}$ with $t=0$ meaning mouse to move, $t=1$ cat to move. The outcome function $F:V\times V\times\{0,1\}\to\{\text{M},\text{C},\text{D}\}$ returns Mouse win (M), Cat win (C), or Draw (D) under optimal play. Initial state is $(1,2,0)$.}
\varmapStart
\var{m}{mouse position in $V$}
\var{c}{cat position in $V$}
\var{t}{turn: $0$ mouse, $1$ cat}
\var{N(v)}{neighbors of $v$ in the undirected graph}
\var{\text{legal}(c)}{cat's legal moves $N(c)\setminus\{0\}$}
\var{F(m,c,t)}{optimal outcome from state $(m,c,t)$}
\varmapEnd
\GOVERN{
\[
F(m,c,t)=
\begin{cases}
\text{M}, & m=0,\\
\text{C}, & m=c\ne 0,\\
\text{M}, & t=0 \text{ and } \exists\,m'\in N(m):~F(m',c,1)=\text{M},\\
\text{C}, & t=1 \text{ and } \exists\,c'\in \text{legal}(c):~F(m,c',0)=\text{C},\\
\text{C}, & t=0 \text{ and } \forall\,m'\in N(m):~F(m',c,1)=\text{C},\\
\text{M}, & t=1 \text{ and } \forall\,c'\in \text{legal}(c):~F(m,c',0)=\text{M},\\
\text{D}, & \text{otherwise.}
\end{cases}
\]
}
\ASSUMPTIONS{Simple undirected graph; cat cannot move to node $0$; both players always have at least one legal move unless at a terminal state.}
\INVARIANTS{
\begin{bullets}
\item If $m=0$ then $F(m,c,t)=\text{M}$ regardless of $c,t$.
\item If $m=c\ne 0$ then $F(m,c,t)=\text{C}$ regardless of $t$.
\item Retrograde propagation preserves optimality: once a state's outcome is determined, parents update monotonically toward a fixed point.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Depth-limited minimax with memoization directly encodes the governing cases for $F(m,c,t)$. A high step limit like $2n^2$ prevents infinite descent and treats long cycles as draws.}
\ASSUMPTIONS{Use recursion with memoization on $(m,c,t)$; treat exceeding a conservative step limit as a draw.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $m=0$ return mouse win; if $m=c$ and $m\ne 0$ return cat win.
\item If turn is mouse, try all $m'\in N(m)$: return mouse win if any child is mouse win; else return draw if any child is draw; else cat win.
\item If turn is cat, try all $c'\in N(c)\setminus\{0\}$: return cat win if any child is cat win; else return draw if any child is draw; else mouse win.
\end{algosteps}
\COMPLEXITY{Worst-case explores many states repeatedly but capped by the step limit. There are $O(n^2)$ positions and two turns. Each transition considers at most $O(n)$ moves.}
\[
\begin{aligned}
\#\text{states} &= 2n^2,\\
\text{branching} &\le n,\\
T(n) &\le O(n^3)\ \text{in practice with memoization (but recursion depth-limited)},\\
S(n) &= O(n^2).
\end{aligned}
\]
\CORRECTNESS{Matches the case analysis in the model. The step cap converts endlessly repeating play into a draw, consistent with the rules.}
\EDGECASES{Cat neighbors may include $0$, which is skipped; graphs where mouse immediately reaches $0$; graphs where cat immediately meets mouse.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        DRAW, MOUSE, CAT = 0, 1, 2
        UNKNOWN = -1
        # dp[m][c][t] in {UNKNOWN, DRAW, MOUSE, CAT}
        dp = [[[-1] * 2 for _ in range(n)] for __ in range(n)]
        # Large enough cap to treat cycles as draws
        cap = 2 * n * n

        def solve(m: int, c: int, t: int, steps: int) -> int:
            if steps >= cap:
                return DRAW
            if m == 0:
                return MOUSE
            if m == c:
                return CAT
            if dp[m][c][t] != UNKNOWN:
                return dp[m][c][t]

            if t == 0:  # mouse to move
                any_draw = False
                for m2 in graph[m]:
                    r = solve(m2, c, 1, steps + 1)
                    if r == MOUSE:
                        dp[m][c][t] = MOUSE
                        return MOUSE
                    if r == DRAW:
                        any_draw = True
                if any_draw:
                    dp[m][c][t] = DRAW
                    return DRAW
                dp[m][c][t] = CAT
                return CAT
            else:       # cat to move
                any_draw = False
                has_legal = False
                for c2 in graph[c]:
                    if c2 == 0:
                        continue
                    has_legal = True
                    r = solve(m, c2, 0, steps + 1)
                    if r == CAT:
                        dp[m][c][t] = CAT
                        return CAT
                    if r == DRAW:
                        any_draw = True
                if not has_legal:
                    # By constraints this should not occur; if it does, mouse wins.
                    dp[m][c][t] = MOUSE
                    return MOUSE
                if any_draw:
                    dp[m][c][t] = DRAW
                    return DRAW
                dp[m][c][t] = MOUSE
                return MOUSE

        ans = solve(1, 2, 0, 0)
        # Basic asserts on constraints
        assert ans in (DRAW, MOUSE, CAT)
        return ans

# Quick validation on provided samples
if __name__ == "__main__":
    s = Solution()
    g1 = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
    g2 = [[1,3],[0],[3],[0,2]]
    assert s.catMouseGame(g1) == 0
    assert s.catMouseGame(g2) == 1
\end{minted}
\VALIDATION{Checked two given examples. Sanity-checked return value domain.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Retrograde analysis with a queue: color each state by winner or draw, initialize obvious terminals, and propagate results to parents using move degrees. Parents become losing when all their moves lead to opponent wins.}
\ASSUMPTIONS{Maintain:
\begin{bullets}
\item color$[m][c][t]\in\{0,1,2\}$ for draw/mouse/cat,
\item degree$[m][c][t]=$ number of legal moves for the mover at $(m,c,t)$, excluding cat moves to node $0$.
\end{bullets}}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize all states as draw. Seed queue with terminal wins: $(m=0, c\ne 0, t)$ as mouse-win and $(m=c\ne 0, t)$ as cat-win.
\item While queue nonempty, pop a colored state and update all parent states:
\begin{bullets}
\item If the popped state is a win for player $P$, then any parent where it is $P$'s turn becomes a $P$-win (the mover can choose it).
\item Otherwise, decrement the parent's degree; if it drops to $0$, the parent becomes a loss for the mover (a win for the other player).
\end{bullets}
\item Return color of initial state $(1,2,0)$.
\end{algosteps}
\COMPLEXITY{Each state is colored once and each edge contributes to a constant number of parent updates. With $O(n^2)$ states and $O(n)$ moves per state in the worst case:}
\[
\begin{aligned}
T(n) &= O(n^3),\\
S(n) &= O(n^2).
\end{aligned}
\]
\CORRECTNESS{Follows standard game-graph retrograde DP: terminal outcomes are correct; if a winning child exists, the mover can force it; if all children are opponent-wins, the mover loses; residual states remain draws.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from collections import deque

class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        DRAW, MOUSE, CAT = 0, 1, 2

        # color[m][c][t]: 0 draw, 1 mouse win, 2 cat win
        color = [[[DRAW] * 2 for _ in range(n)] for __ in range(n)]
        # degree[m][c][t]: legal moves available to the mover in (m,c,t)
        degree = [[[0] * 2 for _ in range(n)] for __ in range(n)]

        for m in range(n):
            for c in range(n):
                degree[m][c][0] = len(graph[m])  # mouse moves
                degree[m][c][1] = sum(1 for x in graph[c] if x != 0)  # cat can't go to 0

        q = deque()

        # Seed terminal states
        for i in range(1, n):
            for t in (0, 1):
                # Mouse at hole -> mouse win
                color[0][i][t] = MOUSE
                q.append((0, i, t, MOUSE))
                # Cat catches mouse (not at hole) -> cat win
                color[i][i][t] = CAT
                q.append((i, i, t, CAT))

        def parents(m: int, c: int, t: int):
            # Parents that can move into (m,c,t)
            if t == 0:
                # Current is mouse's turn; parent was cat's turn (t=1) and moved its cat
                for pc in graph[c]:
                    if pc == 0:
                        continue
                    yield (m, pc, 1)
            else:
                # Current is cat's turn; parent was mouse's turn (t=0) and moved its mouse
                for pm in graph[m]:
                    yield (pm, c, 0)

        while q:
            m, c, t, win = q.popleft()
            for pm, pc, pt in parents(m, c, t):
                if color[pm][pc][pt] != DRAW:
                    continue
                # If the child is a win for the mover in parent, then parent can move to it and win
                if pt == 0 and win == MOUSE:
                    color[pm][pc][pt] = MOUSE
                    q.append((pm, pc, pt, MOUSE))
                elif pt == 1 and win == CAT:
                    color[pm][pc][pt] = CAT
                    q.append((pm, pc, pt, CAT))
                else:
                    # Otherwise, reduce the options; if no options remain, parent is losing for mover
                    degree[pm][pc][pt] -= 1
                    if degree[pm][pc][pt] == 0:
                        # Parent mover loses => opponent wins
                        if pt == 0:
                            color[pm][pc][pt] = CAT
                            q.append((pm, pc, pt, CAT))
                        else:
                            color[pm][pc][pt] = MOUSE
                            q.append((pm, pc, pt, MOUSE))

        ans = color[1][2][0]
        assert ans in (DRAW, MOUSE, CAT)
        return ans

# Validation on samples and a small custom check
if __name__ == "__main__":
    s = Solution()
    g1 = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
    g2 = [[1,3],[0],[3],[0,2]]
    assert s.catMouseGame(g1) == 0
    assert s.catMouseGame(g2) == 1
    # Triangle 0-1-2-0: mouse at 1 can go to 0 immediately, so mouse wins
    tri = [[1,2],[0,2],[0,1]]
    assert s.catMouseGame(tri) == 1
\end{minted}
\VALIDATION{Verified provided samples and a triangle where mouse wins in one move.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Same retrograde DP with degrees and a queue; this is the standard optimal algorithm for impartial/partisan finite games with draws.}
\ASSUMPTIONS{Finite state space $2n^2$; deterministic updates; cat's legal moves exclude node $0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build color and degree tables; seed terminal states.
\item BFS over resolved states; for each parent, immediately color it if it can choose a winning child; otherwise decrement degree and color when degree hits $0$.
\item Report color of $(1,2,0)$.
\end{algosteps}
\OPTIMALITY{Every state is labeled once; the propagation respects optimal choices and minimax structure. Any remaining unlabeled states at the end are precisely the draws. This is tight up to constants: $\Theta(n^3)$ in the worst case due to $O(n^2)$ states and $O(n)$ branching.}
\COMPLEXITY{Same as Approach B.}
\[
\begin{aligned}
T(n) &= O(n^3),\quad S(n)=O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from collections import deque

class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        DRAW, MOUSE, CAT = 0, 1, 2

        color = [[[DRAW] * 2 for _ in range(n)] for __ in range(n)]
        degree = [[[0] * 2 for _ in range(n)] for __ in range(n)]

        for m in range(n):
            for c in range(n):
                degree[m][c][0] = len(graph[m])
                degree[m][c][1] = sum(1 for x in graph[c] if x != 0)

        q = deque()
        for i in range(1, n):
            for t in (0, 1):
                color[0][i][t] = MOUSE
                q.append((0, i, t, MOUSE))
                color[i][i][t] = CAT
                q.append((i, i, t, CAT))

        def parents(m: int, c: int, t: int):
            if t == 0:
                for pc in graph[c]:
                    if pc != 0:
                        yield (m, pc, 1)
            else:
                for pm in graph[m]:
                    yield (pm, c, 0)

        while q:
            m, c, t, win = q.popleft()
            for pm, pc, pt in parents(m, c, t):
                if color[pm][pc][pt] != DRAW:
                    continue
                if (pt == 0 and win == MOUSE) or (pt == 1 and win == CAT):
                    color[pm][pc][pt] = win
                    q.append((pm, pc, pt, win))
                else:
                    degree[pm][pc][pt] -= 1
                    if degree[pm][pc][pt] == 0:
                        opp = CAT if pt == 0 else MOUSE
                        color[pm][pc][pt] = opp
                        q.append((pm, pc, pt, opp))

        ans = color[1][2][0]
        assert ans in (DRAW, MOUSE, CAT)
        return ans

if __name__ == "__main__":
    s = Solution()
    # Exactly 3 asserts
    assert s.catMouseGame([[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]) == 0
    assert s.catMouseGame([[1,3],[0],[3],[0,2]]) == 1
    # A path: 0-1-2-3. Mouse at 1 reaches 0; cat at 2 cannot block -> mouse wins
    assert s.catMouseGame([[1],[0,2],[1,3],[2]]) == 1
\end{minted}
\VALIDATION{Three asserts: both samples and a simple path graph where mouse wins immediately.}
\RESULT{Return $1$ for mouse win, $2$ for cat win, $0$ for draw.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on terminals, small motifs (triangle, path, square), and random small graphs with degree at least $1$ and cat not trapped only by $0$.}
\LINE{CROSS-CHECKS}{Compare baseline recursion and final BFS on a curated set of small graphs to ensure identical outcomes.}
\LINE{EDGE-CASE GENERATOR}{Generate small undirected graphs on $n\in\{4,5\}$ with ensured connectivity to $0$ and at least one nonzero neighbor for node $2$.}
\begin{minted}{python}
from typing import List, Tuple
from collections import deque
import itertools

# Deterministic generators for boundaries, degenerates, adversarials
def to_adj(n: int, edges: List[Tuple[int,int]]) -> List[List[int]]:
    g = [[] for _ in range(n)]
    for u, v in edges:
        if u == v:
            continue
        g[u].append(v); g[v].append(u)
    for i in range(n):
        g[i] = sorted(set(g[i]))
    return g

def connected_to_zero(g: List[List[int]]) -> bool:
    n = len(g)
    seen = [False]*n
    q = deque([0]); seen[0] = True
    while q:
        u = q.popleft()
        for v in g[u]:
            if not seen[v]:
                seen[v] = True; q.append(v)
    return all(seen[i] or i == 2 for i in range(n))  # allow cat start node possibly disconnected? Prefer True all.

def has_cat_legal(g: List[List[int]]) -> bool:
    # Cat starts at 2; legal moves exclude 0
    return any(v != 0 for v in g[2])

# Final reference solution reused
class SolutionRef:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        from collections import deque
        n = len(graph)
        DRAW, MOUSE, CAT = 0, 1, 2
        color = [[[DRAW]*2 for _ in range(n)] for __ in range(n)]
        degree = [[[0]*2 for _ in range(n)] for __ in range(n)]
        for m in range(n):
            for c in range(n):
                degree[m][c][0] = len(graph[m])
                degree[m][c][1] = sum(1 for x in graph[c] if x != 0)
        q = deque()
        for i in range(1, n):
            for t in (0,1):
                color[0][i][t] = MOUSE; q.append((0,i,t,MOUSE))
                color[i][i][t] = CAT;   q.append((i,i,t,CAT))
        def parents(m,c,t):
            if t == 0:
                for pc in graph[c]:
                    if pc != 0:
                        yield (m, pc, 1)
            else:
                for pm in graph[m]:
                    yield (pm, c, 0)
        while q:
            m,c,t,win = q.popleft()
            for pm,pc,pt in parents(m,c,t):
                if color[pm][pc][pt] != DRAW:
                    continue
                if (pt == 0 and win == MOUSE) or (pt == 1 and win == CAT):
                    color[pm][pc][pt] = win
                    q.append((pm,pc,pt,win))
                else:
                    degree[pm][pc][pt] -= 1
                    if degree[pm][pc][pt] == 0:
                        opp = CAT if pt == 0 else MOUSE
                        color[pm][pc][pt] = opp
                        q.append((pm,pc,pt,opp))
        return color[1][2][0]

# Baseline for cross-check
class SolutionBase:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        DRAW, MOUSE, CAT = 0, 1, 2
        UNKNOWN = -1
        dp = [[[-1] * 2 for _ in range(n)] for __ in range(n)]
        cap = 2 * n * n
        def solve(m, c, t, steps):
            if steps >= cap:
                return DRAW
            if m == 0:
                return MOUSE
            if m == c:
                return CAT
            if dp[m][c][t] != UNKNOWN:
                return dp[m][c][t]
            if t == 0:
                any_draw = False
                for m2 in graph[m]:
                    r = solve(m2, c, 1, steps + 1)
                    if r == MOUSE:
                        dp[m][c][t] = MOUSE
                        return MOUSE
                    if r == DRAW:
                        any_draw = True
                if any_draw:
                    dp[m][c][t] = DRAW
                    return DRAW
                dp[m][c][t] = CAT
                return CAT
            else:
                any_draw = False
                has_legal = False
                for c2 in graph[c]:
                    if c2 == 0:
                        continue
                    has_legal = True
                    r = solve(m, c2, 0, steps + 1)
                    if r == CAT:
                        dp[m][c][t] = CAT
                        return CAT
                    if r == DRAW:
                        any_draw = True
                if not has_legal:
                    dp[m][c][t] = MOUSE
                    return MOUSE
                if any_draw:
                    dp[m][c][t] = DRAW
                    return DRAW
                dp[m][c][t] = MOUSE
                return MOUSE
        return solve(1, 2, 0, 0)

def cross_check():
    ref = SolutionRef()
    base = SolutionBase()
    # Fixed small cases
    cases = [
        [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]],
        [[1,3],[0],[3],[0,2]],
        [[1,2],[0,2],[0,1]],           # triangle
        [[1],[0,2],[1,3],[2]],         # path 0-1-2-3
        [[1,2],[0,2,3],[0,1,3],[1,2]]  # square with diagonals
    ]
    for g in cases:
        a = ref.catMouseGame(g)
        b = base.catMouseGame(g)
        assert a == b

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from collections import deque

class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        DRAW, MOUSE, CAT = 0, 1, 2

        color = [[[DRAW] * 2 for _ in range(n)] for __ in range(n)]
        degree = [[[0] * 2 for _ in range(n)] for __ in range(n)]

        for m in range(n):
            for c in range(n):
                degree[m][c][0] = len(graph[m])
                degree[m][c][1] = sum(1 for x in graph[c] if x != 0)

        q = deque()
        for i in range(1, n):
            for t in (0, 1):
                color[0][i][t] = MOUSE
                q.append((0, i, t, MOUSE))
                color[i][i][t] = CAT
                q.append((i, i, t, CAT))

        def parents(m: int, c: int, t: int):
            if t == 0:
                for pc in graph[c]:
                    if pc != 0:
                        yield (m, pc, 1)
            else:
                for pm in graph[m]:
                    yield (pm, c, 0)

        while q:
            m, c, t, win = q.popleft()
            for pm, pc, pt in parents(m, c, t):
                if color[pm][pc][pt] != DRAW:
                    continue
                if (pt == 0 and win == MOUSE) or (pt == 1 and win == CAT):
                    color[pm][pc][pt] = win
                    q.append((pm, pc, pt, win))
                else:
                    degree[pm][pc][pt] -= 1
                    if degree[pm][pc][pt] == 0:
                        opp = CAT if pt == 0 else MOUSE
                        color[pm][pc][pt] = opp
                        q.append((pm, pc, pt, opp))

        return color[1][2][0]

# Self-checks
if __name__ == "__main__":
    s = Solution()
    assert s.catMouseGame([[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]) == 0
    assert s.catMouseGame([[1,3],[0],[3],[0,2]]) == 1
    assert s.catMouseGame([[1],[0,2],[1,3],[2]]) == 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Solve Cat and Mouse by retrograde DP on $(m,c,t)$ states with degrees, seeding terminal wins and propagating to parents.}
\WHY{A canonical example of game-state DP with draws; tests ability to convert rules into state updates and handle forbidden moves.}
\CHECKLIST{
\begin{bullets}
\item Define states $(m,c,t)$, initial $(1,2,0)$.
\item Terminal seeds: $m=0$ mouse-win; $m=c\ne 0$ cat-win.
\item Degrees: mouse degree $=\lvert N(m)\rvert$; cat degree $=\lvert N(c)\setminus\{0\}\rvert$.
\item Parents: inverse moves by the last mover.
\item Propagate wins immediately; otherwise decrement degrees and flip when zero.
\item Return color of $(1,2,0)$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Cat neighbor $0$ must be excluded from legal moves.
\item Node $1$ adjacent to $0$ (immediate mouse win).
\item Node $2$ adjacent only to $0$ (disallowed by constraint; handle gracefully).
\item Graphs where mouse and cat start already equal (not applicable; starts at $(1,2)$).
\item Multiple disjoint components; ensure connectivity to $0$ does not break logic.
\item Dense graphs where draws arise by perpetual chase.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to seed both $t=0$ and $t=1$ for terminal states.
\item Counting cat's degree including node $0$.
\item Propagating from parents instead of children (direction error).
\item Failing to guard that colors update only once.
\item Off-by-one in indexing states or initial turn.
\item Infinite recursion without a step cap in the baseline.
\end{bullets}
}
\FAILMODES{Baseline DFS can mis-handle cycles without careful draw handling and may time out on adversarial graphs. The BFS retrograde method remains robust and terminates quickly.}
\ELI{Start from obvious wins and work backward: if you can move to a win for you, you win; if all your moves let the other win, you lose; otherwise it is a draw. Represent everything as states and let a queue propagate these labels.}
\NotePages{3}

\end{document}