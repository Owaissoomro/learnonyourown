% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Min Cost to Connect All Points}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/min-cost-to-connect-all-points/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given an array \texttt{points} representing integer coordinates of some points on a 2D-plane, where \(\texttt{points}[i] = [x_i, y_i]\). The cost of connecting two points \([x_i, y_i]\) and \([x_j, y_j]\) is the Manhattan distance between them: \(|x_i - x_j| + |y_i - y_j|\), where \(|\text{val}|\) denotes the absolute value of \(\text{val}\). Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.

\textbf{Example 1:}

Input: \(\texttt{points} = [[0,0],[2,2],[3,10],[5,2],[7,0]]\)

Output: \(20\)

Explanation: We can connect the points as shown to get the minimum cost of \(20\). Notice that there is a unique path between every pair of points.

\textbf{Example 2:}

Input: \(\texttt{points} = [[3,12],[-2,5],[-4,1]]\)

Output: \(18\)

\textbf{Constraints:}
\begin{bullets}
\item \(1 \le \texttt{points.length} \le 1000\).
\item \(-10^{6} \le x_i, y_i \le 10^{6}\).
\item All pairs \((x_i, y_i)\) are distinct.
\end{bullets}}
\BREAKDOWN{Model the points as vertices of a complete graph with edge weights equal to Manhattan distances. The task asks for the weight of a minimum spanning tree (MST). Compute MST cost efficiently without explicitly materializing all \(O(n^2)\) edges when possible.}
\ELI{Make the cheapest network of roads so every city is reachable with no cycles, using road cost equal to Manhattan distance.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list \(\texttt{points}\) of length \(n\) with \(1 \le n \le 1000\); each element is a 2-list \([x, y]\) with integers satisfying \(-10^{6} \le x, y \le 10^{6}\); all points are distinct.}
\OUTPUTS{A single integer: the minimal total cost to connect all points so that there is exactly one simple path between any two points (i.e., the MST total weight under Manhattan metric).}
\SAMPLES{Example 1: \(\texttt{points}=[[0,0],[2,2],[3,10],[5,2],[7,0]] \to 20\). Example 2: \(\texttt{points}=[[3,12],[-2,5],[-4,1]] \to 18\).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let \(V=\{1,\ldots,n\}\) index the points \((x_i,y_i)\). Define a complete weighted graph on \(V\) with edge weight \(w_{ij}=\lvert x_i-x_j\rvert+\lvert y_i-y_j\rvert\) for \(i\ne j\). Find a spanning tree \(T\subseteq \{\{i,j\}: i\ne j\}\) minimizing \(\sum_{\{i,j\}\in T} w_{ij}\).}
\varmapStart
\var{n}{number of points}
\var{(x_i,y_i)}{coordinates of point \(i\)}
\var{w_{ij}}{Manhattan distance between points \(i\) and \(j\)}
\var{T}{edge set of a spanning tree on \(V\)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\min_{T} \quad & \sum_{\{i,j\}\in T} w_{ij} \\
\text{s.t.}\quad & |T|=n-1, \\
& (V,T)\ \text{is connected and acyclic.}
\end{aligned}
\]
}
\ASSUMPTIONS{All coordinates are integers; the graph is complete; all edge weights are nonnegative; at least one spanning tree exists for \(n\ge 1\).}
\INVARIANTS{
\begin{bullets}
\item Cut property: For any nonempty proper subset \(S\subset V\), the minimum-weight edge crossing \((S, V\setminus S)\) is in some MST.
\item Cycle property: For any cycle, the maximum-weight edge is not in any MST.
\item During Prim's algorithm, the current chosen edges always connect the visited set to the rest with minimal possible frontier edge.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Construct all \(O(n^2)\) edges with Manhattan weights and apply Kruskal's algorithm with a disjoint-set union (DSU).}
\ASSUMPTIONS{We can afford generating and sorting all edges for \(n\le 1000\) since \(n(n-1)/2 \le 499{,}500\) edges is feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the complete edge list \((w_{ij}, i, j)\) for all \(i<j\).
\item Sort edges by weight nondecreasing.
\item Scan edges; use DSU to add an edge if it connects two different components; stop after \(n-1\) edges and return the accumulated weight.
\end{algosteps}
\COMPLEXITY{Sorting dominates: \(T(n)=\Theta(n^2\log n)\) time, \(S(n)=\Theta(n^2)\) space for edges plus near-linear DSU overhead.}
\[
\begin{aligned}
\#\text{edges} &= \binom{n}{2} = \Theta(n^2),\\
T(n) &= \Theta(n^2\log n) \text{ (sort)} + \Theta(n^2\ \alpha(n)) \text{ (DSU)}.
\end{aligned}
\]
\CORRECTNESS{Kruskal with DSU is correct by the cut and cycle properties: always choosing the smallest available edge that does not create a cycle yields an MST.}
\EDGECASES{\(n=1\) returns \(0\); duplicate coordinates are disallowed by constraints; ties in edge weights are handled by deterministic sorting but do not affect optimality.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class DSU:
    def __init__(self, n: int):
        self.p = list(range(n))
        self.r = [0] * n
        self.cnt = n

    def find(self, x: int) -> int:
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x

    def union(self, a: int, b: int) -> bool:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return False
        if self.r[ra] < self.r[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]:
            self.r[ra] += 1
        self.cnt -= 1
        return True

class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 1:
            return 0
        edges: List[Tuple[int, int, int]] = []
        for i in range(n):
            x1, y1 = points[i]
            for j in range(i + 1, n):
                x2, y2 = points[j]
                w = abs(x1 - x2) + abs(y1 - y2)
                edges.append((w, i, j))
        edges.sort()
        dsu = DSU(n)
        ans = 0
        taken = 0
        for w, i, j in edges:
            if dsu.union(i, j):
                ans += w
                taken += 1
                if taken == n - 1:
                    break
        return ans

if __name__ == "__main__":
    sol = Solution()
    assert sol.minCostConnectPoints([[0,0],[2,2],[3,10],[5,2],[7,0]]) == 20
    assert sol.minCostConnectPoints([[3,12],[-2,5],[-4,1]]) == 18
    assert sol.minCostConnectPoints([[1,1]]) == 0
\end{minted}
\VALIDATION{Checked samples and the trivial single-point case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use Prim's algorithm with a binary heap; avoid materializing all edges by generating distances to unvisited vertices on the fly.}
\ASSUMPTIONS{Heap operations reduce sorting overhead; distances are computed only when needed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize min-heap with \((0, 0)\): cost to add vertex \(0\) is \(0\).
\item While fewer than \(n\) vertices are in the tree: pop the smallest \((w, u)\) not yet visited; add \(w\) to answer.
\item For every unvisited vertex \(v\), compute \(d(u,v)\) and push \((d(u,v), v)\) to the heap. Repeat until all vertices are taken.
\end{algosteps}
\COMPLEXITY{Each extraction costs \(O(\log n)\) and we may push \(O(n)\) entries per step, leading to \(T(n)=O(n^2\log n)\), with \(S(n)=O(n^2)\) in the worst case due to heap entries (though still avoiding explicit edge storage).}
\[
\begin{aligned}
T(n) &= O\big(\sum_{k=1}^{n} (n-k)\log n\big) = O(n^2\log n).
\end{aligned}
\]
\CORRECTNESS{Prim's algorithm is correct by the cut property: at each step it picks the cheapest edge leaving the current connected set.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 1:
            return 0
        seen = [False] * n
        heap: List[Tuple[int, int]] = [(0, 0)]  # (cost to add, node)
        ans = 0
        added = 0
        while added < n:
            w, u = heapq.heappop(heap)
            if seen[u]:
                continue
            seen[u] = True
            ans += w
            added += 1
            x1, y1 = points[u]
            for v in range(n):
                if not seen[v]:
                    x2, y2 = points[v]
                    d = abs(x1 - x2) + abs(y1 - y2)
                    heapq.heappush(heap, (d, v))
        return ans

if __name__ == "__main__":
    sol = Solution()
    assert sol.minCostConnectPoints([[0,0],[2,2],[3,10],[5,2],[7,0]]) == 20
    assert sol.minCostConnectPoints([[3,12],[-2,5],[-4,1]]) == 18
    assert sol.minCostConnectPoints([[1,1]]) == 0
\end{minted}
\VALIDATION{Validated against the same samples; also resilient to \(n=1\).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Prim's algorithm in \(O(n^2)\) time using an array of best-known connection costs rather than a heap. For dense graphs like the complete graph here, this is optimal for \(n\le 1000\) in practice and avoids extra log factors.}
\ASSUMPTIONS{The graph is complete and weights are nonnegative; scanning all vertices per iteration is feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain arrays: \(\text{inTree}[i]\) and \(\text{best}[i]\) initialized to \(\infty\), with \(\text{best}[0]=0\).
\item Repeat \(n\) times: pick \(u\) not in tree with minimal \(\text{best}[u]\); add \(\text{best}[u]\) to answer and mark \(u\) in tree.
\item For every vertex \(v\) not in tree, set \(\text{best}[v] \leftarrow \min(\text{best}[v], d(u,v))\).
\end{algosteps}
\OPTIMALITY{Prim's choice is optimal by the cut property at each step. Among comparison-based implementations, this achieves the standard dense-graph bound \(O(n^2)\).}
\COMPLEXITY{\(T(n)=\Theta(n^2)\) time from repeated \(O(n)\) scans and updates; \(S(n)=\Theta(n)\).}
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n} O(n) = O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 1:
            return 0
        INF = 10**18
        in_tree = [False] * n
        best = [INF] * n
        best[0] = 0
        ans = 0
        for _ in range(n):
            u = -1
            u_cost = INF
            for i in range(n):
                if not in_tree[i] and best[i] < u_cost:
                    u_cost = best[i]
                    u = i
            in_tree[u] = True
            ans += u_cost
            x1, y1 = points[u]
            for v in range(n):
                if not in_tree[v]:
                    x2, y2 = points[v]
                    d = abs(x1 - x2) + abs(y1 - y2)
                    if d < best[v]:
                        best[v] = d
        return ans

if __name__ == "__main__":
    sol = Solution()
    assert sol.minCostConnectPoints([[0,0],[2,2],[3,10],[5,2],[7,0]]) == 20
    assert sol.minCostConnectPoints([[3,12],[-2,5],[-4,1]]) == 18
    assert sol.minCostConnectPoints([[1,1]]) == 0
\end{minted}
\VALIDATION{Exactly 3 asserts: two samples and the base case.}
\RESULT{Returns the MST total weight under Manhattan metric; when multiple MSTs exist, any is acceptable since only the total weight is required.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify against samples; property-check small random instances by comparing Kruskal vs. Prim; test degenerate cases such as \(n=1\), collinear points, identical x or y coordinates.}
\LINE{CROSS-CHECKS}{On small \(n\) (e.g., \(n\le 9\)), compare the Baseline Kruskal result with the Optimal \(O(n^2)\) Prim to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate clustered points and lattice-aligned points to stress Manhattan structure and tie-heavy situations.}
\begin{minted}{python}
from typing import List, Tuple
import random

def kruskal(points: List[List[int]]) -> int:
    n = len(points)
    if n <= 1:
        return 0
    edges: List[Tuple[int, int, int]] = []
    for i in range(n):
        x1, y1 = points[i]
        for j in range(i + 1, n):
            x2, y2 = points[j]
            edges.append((abs(x1 - x2) + abs(y1 - y2), i, j))
    edges.sort()
    parent = list(range(n))
    rank = [0] * n
    def find(x: int) -> int:
        while parent[x] != x:
            parent[x] = parent[parent[x]]
            x = parent[x]
        return x
    def union(a: int, b: int) -> bool:
        ra, rb = find(a), find(b)
        if ra == rb:
            return False
        if rank[ra] < rank[rb]:
            ra, rb = rb, ra
        parent[rb] = ra
        if rank[ra] == rank[rb]:
            rank[ra] += 1
        return True
    ans = 0
    taken = 0
    for w, i, j in edges:
        if union(i, j):
            ans += w
            taken += 1
            if taken == n - 1:
                break
    return ans

def prim_o2(points: List[List[int]]) -> int:
    n = len(points)
    if n <= 1:
        return 0
    INF = 10**18
    in_tree = [False] * n
    best = [INF] * n
    best[0] = 0
    ans = 0
    for _ in range(n):
        u = -1
        u_cost = INF
        for i in range(n):
            if not in_tree[i] and best[i] < u_cost:
                u_cost = best[i]
                u = i
        in_tree[u] = True
        ans += u_cost
        x1, y1 = points[u]
        for v in range(n):
            if not in_tree[v]:
                x2, y2 = points[v]
                d = abs(x1 - x2) + abs(y1 - y2)
                if d < best[v]:
                    best[v] = d
    return ans

def gen_points(n: int, seed: int = 0) -> List[List[int]]:
    random.seed(seed)
    pts = []
    for _ in range(n):
        x = random.randint(-10, 10)
        y = random.randint(-10, 10)
        pts.append([x, y])
    # Deduplicate if collisions happen
    uniq = []
    seen = set()
    for x, y in pts:
        if (x, y) in seen:
            x += random.randint(1, 3)
        seen.add((x, y))
        uniq.append([x, y])
    return uniq

if __name__ == "__main__":
    # Cross-check small sizes
    for n in range(1, 9):
        for seed in range(7):
            pts = gen_points(n, seed)
            a = kruskal(pts)
            b = prim_o2(pts)
            assert a == b, (n, seed, pts, a, b)
    # Quick sanity on given samples
    assert prim_o2([[0,0],[2,2],[3,10],[5,2],[7,0]]) == 20
    assert kruskal([[3,12],[-2,5],[-4,1]]) == 18
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 1:
            return 0
        INF = 10**18
        in_tree = [False] * n
        best = [INF] * n
        best[0] = 0
        ans = 0
        for _ in range(n):
            u = -1
            u_cost = INF
            for i in range(n):
                if not in_tree[i] and best[i] < u_cost:
                    u_cost = best[i]
                    u = i
            in_tree[u] = True
            ans += u_cost
            x1, y1 = points[u]
            for v in range(n):
                if not in_tree[v]:
                    x2, y2 = points[v]
                    d = abs(x1 - x2) + abs(y1 - y2)
                    if d < best[v]:
                        best[v] = d
        return ans

if __name__ == "__main__":
    sol = Solution()
    assert sol.minCostConnectPoints([[0,0],[2,2],[3,10],[5,2],[7,0]]) == 20
    assert sol.minCostConnectPoints([[3,12],[-2,5],[-4,1]]) == 18
    assert sol.minCostConnectPoints([[1,1]]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute the MST cost over a complete graph under Manhattan distance; Prim's \(O(n^2)\) is clean and optimal for this input size.}
\WHY{This tests MST fundamentals, choosing between Kruskal and Prim, and writing cache-friendly \(O(n^2)\) Prim without a heap.}
\CHECKLIST{
\begin{bullets}
\item Recognize MST formulation under Manhattan metric.
\item Choose Prim (dense) vs. Kruskal (sparser or small \(n\)).
\item Implement and maintain best connection costs correctly.
\item Handle \(n=1\) returning \(0\).
\item Ensure no off-by-one in loop over \(n\) selections.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Single point: answer \(0\).
\item Two points: answer is their Manhattan distance.
\item Collinear points with equal spacing.
\item Many ties in distances.
\item Points sharing same \(x\) or same \(y\).
\item Large coordinates near \(\pm 10^{6}\) but still safe in Python.
\item Clustered vs. widely separated groups.
\item Duplicate coordinates are disallowed but be mindful in custom tests.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to mark vertex as visited before relaxing neighbors.
\item Using a heap without discarding stale entries.
\item Integer overflow in languages with fixed-width ints (not an issue in Python).
\item Early-terminating Kruskal before collecting \(n-1\) edges incorrectly.
\item Mixing up indices vs. coordinates in distance computation.
\item Not reinitializing arrays between runs in reusable environments.
\end{bullets}
}
\FAILMODES{Building and sorting all edges may be slower or memory-heavy if naively implemented, but still fine for \(n\le 1000\). Heap-based Prim may degrade if stale entries accumulate without checks. The \(O(n^2)\) Prim avoids both issues.}
\ELI{Treat each point as a city and repeatedly connect the nearest new city to the growing network. Keep track of the cheapest way to attach every unconnected city and always pick the cheapest next attachment.}
\NotePages{3}

\end{document}