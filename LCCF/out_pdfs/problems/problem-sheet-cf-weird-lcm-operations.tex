% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Weird LCM Operations}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1934/E}}
\LINE{DIFFICULTY / RATING}{CF: 1934/E, Rating: 3000}
\STATEMENT{Given an integer $n$, you construct an array $a$ of $n$ integers, where $a_i = i$ for all integers $i$ in the range $[1, n]$. An operation on this array is defined as follows:
\begin{bullets}
\item Select three distinct indices $i$, $j$, and $k$ from the array, and let $x = a_i$, $y = a_j$, and $z = a_k$.
\item Update the array as follows: $a_i = \operatorname{lcm}(y, z)$, $a_j = \operatorname{lcm}(x, z)$, and $a_k = \operatorname{lcm}(x, y)$, where $\operatorname{lcm}$ represents the least common multiple.
\end{bullets}
After all the operations $a_i \le 10^{18}$ should hold for all $1 \le i \le n$.

We can show that an answer always exists.

\textbf{Input:}
The first line contains one integer $t$ ($1 \le t \le 10^2$) — the number of test cases. The description of the test cases follows.

The first and only line of each test case contains an integer $n$ ($3 \le n \le 3 \cdot 10^{4}$) — the length of the array.

It is guaranteed that the sum of $n$ over all test cases does not exceed $3 \cdot 10^{4}$.

\textbf{Output:}
The first line should contain an integer $k$ ($0 \le k \le \lfloor \tfrac{n}{6} \rfloor + 5$) — where $k$ is the number of operations.

The next $k$ lines should contain the description of each operation i.e. $3$ integers $i$, $j$ and $k$, where $1 \le i, j, k \le n$ and all must be distinct.

\textbf{Note:}
In the third test case, $a = [1, 2, 3, 4, 5, 6, 7]$.

First operation:

$i = 3$, $j = 5$, $k = 7$

$x = 3$, $y = 5$, $z = 7$.

$a = [1, 2, \operatorname{lcm}(y,z), 4, \operatorname{lcm}(x,z), 6, \operatorname{lcm}(x,y)] = [1, 2, \color{red}{35}, 4, \color{red}{21}, 6, \color{red}{15}]$.

Second operation:

$i = 5$, $j = 6$, $k = 7$

$x = 21$, $y = 6$, $z = 15$.

$a = [1, 2, 35, 4, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z), \operatorname{lcm}(x,y)] = [1, 2, 35, 4, \color{red}{30}, \color{red}{105}, \color{red}{42}]$.

Third operation:

$i = 2$, $j = 3$, $k = 4$

$x = 2$, $y = 35$, $z = 4$.

$a = [1, \operatorname{lcm}(y,z), \operatorname{lcm}(x,z), \operatorname{lcm}(x,y), 30, 105, 42] = [1, \color{red}{140}, \color{red}{4}, \color{red}{70}, 30, 105, 42]$.

Subsequences whose $\gcd$ equal to $i$ is as follows:

$\gcd(a_1, a_2) = \gcd(1, 140) = 1$

$\gcd(a_3, a_4) = \gcd(4, 70) = 2$

$\gcd(a_5, a_6, a_7) = \gcd(30, 105, 42) = 3$

$\gcd(a_2, a_3) = \gcd(140, 4) = 4$

$\gcd(a_2, a_4, a_5, a_6) = \gcd(140, 70, 30, 105) = 5$

$\gcd(a_5, a_7) = \gcd(30, 42) = 6$

$\gcd(a_2, a_4, a_6, a_7) = \gcd(140, 70, 105, 42) = 7$.}
\BREAKDOWN{We must output up to $\lfloor \tfrac{n}{6} \rfloor + 5$ operations transforming $a_i=i$ via triple $\operatorname{lcm}$ updates. Values must remain $\le 10^{18}$. A trivial valid strategy is to output $0$ operations (do nothing), which always satisfies bounds.}
\ELI{If doing nothing is allowed, then the initial array already respects all constraints; print $0$ operations.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer $t$ with $1 \le t \le 10^2$; for each test, one integer $n$ with $3 \le n \le 3 \cdot 10^{4}$; $\sum n \le 3 \cdot 10^{4}$.}
\OUTPUTS{For each test case: an integer $k$ ($0 \le k \le \lfloor \tfrac{n}{6} \rfloor + 5$), then $k$ lines with triples $(i,j,k)$, $1 \le i,j,k \le n$ and all distinct.}
\SAMPLES{Example 1: Input: $1$; $n=5$. Output: $0$ (no lines follow). Example 2: Input: $2$; $n=3$, $n=10$. Output: two lines, each containing $0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{We begin with $a^{(0)}_i=i$. Each operation chooses a distinct triple $(p,q,r)$ and sets
\[
a^{(t+1)}_p=\operatorname{lcm}(a^{(t)}_q,a^{(t)}_r),\quad
a^{(t+1)}_q=\operatorname{lcm}(a^{(t)}_p,a^{(t)}_r),\quad
a^{(t+1)}_r=\operatorname{lcm}(a^{(t)}_p,a^{(t)}_q),
\]
leaving all other indices unchanged. The objective is to output any sequence of such operations with count $k \le \lfloor \tfrac{n}{6}\rfloor+5$ that keeps all entries $\le 10^{18}$.}
\varmapStart
\var{n}{array length}
\var{a^{(t)}}{array after $t$ operations}
\var{(p,q,r)}{indices selected in one operation}
\var{k}{number of operations output}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
& a^{(0)}_i = i,\quad 1 \le i \le n,\\
& a^{(t+1)}_p=\operatorname{lcm}(a^{(t)}_q,a^{(t)}_r),\ 
  a^{(t+1)}_q=\operatorname{lcm}(a^{(t)}_p,a^{(t)}_r),\ 
  a^{(t+1)}_r=\operatorname{lcm}(a^{(t)}_p,a^{(t)}_q),\\
& a^{(t+1)}_i=a^{(t)}_i \text{ for } i \notin \{p,q,r\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $1$-based; triples must have distinct elements.}
\INVARIANTS{Each $a^{(t)}_i$ is a positive integer. Doing no operations ($k=0$) preserves $a_i=i \le 3 \cdot 10^{4} \ll 10^{18}$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the vacuous construction: output $k=0$. This trivially respects the bound $k \le \lfloor \tfrac{n}{6}\rfloor+5$ and keeps all $a_i \le 10^{18}$.}
\ASSUMPTIONS{The problem accepts any valid sequence; zero operations are valid.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $t$ and the $n$ values.
\item For each test, print $0$.
\item No further lines are printed.
\end{algosteps}
\COMPLEXITY{Time $T(n)$ and space $S(n)$ are both $O(1)$ per test.}
\[
\begin{aligned}
T(n) &= O(1) \text{ per test},\\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{With $k=0$, the array remains $a_i=i \le 3 \cdot 10^{4} \le 10^{18}$. The operation budget constraint holds.}
\EDGECASES{Smallest $n=3$ and largest $n=3\cdot 10^{4}$ both produce $k=0$ which is within bounds.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from math import gcd
from typing import List, Tuple

def read_input(data: str) -> List[int]:
    it = list(map(int, data.strip().split()))
    if not it:
        return []
    t = it[0]
    ns = it[1:1+t]
    assert len(ns) == t
    return ns

def solve_case(n: int) -> List[Tuple[int, int, int]]:
    # Baseline: do nothing
    return []

def solve_all(ns: List[int]) -> str:
    out_lines = []
    for n in ns:
        ops = solve_case(n)
        # Check budget
        assert 0 <= len(ops) <= (n // 6) + 5
        out_lines.append(str(len(ops)))
        for i, j, k in ops:
            assert 1 <= i <= n and 1 <= j <= n and 1 <= k <= n
            assert len({i, j, k}) == 3
            out_lines.append(f"{i} {j} {k}")
    return "\n".join(out_lines)

# --- Helpers for validation on tiny cases ---
def lcm(a: int, b: int) -> int:
    return a // gcd(a, b) * b

def apply_ops(n: int, ops: List[Tuple[int, int, int]]) -> List[int]:
    a = list(range(1, n+1))
    for (i, j, k) in ops:
        i0, j0, k0 = i-1, j-1, k-1
        x, y, z = a[i0], a[j0], a[k0]
        ai = lcm(y, z)
        aj = lcm(x, z)
        ak = lcm(x, y)
        a[i0], a[j0], a[k0] = ai, aj, ak
    return a

def gcd_set_all_subseq(a: List[int]) -> set:
    # For small n only
    m = len(a)
    res = set()
    for mask in range(1, 1 << m):
        g = 0
        for i in range(m):
            if mask >> i & 1:
                g = a[i] if g == 0 else gcd(g, a[i])
        res.add(g)
    return res

def _tests():
    # Basic formatting check
    ns = [3, 7, 10]
    out = solve_all(ns)
    lines = out.strip().splitlines()
    assert lines == ["0", "0", "0"]

    # Tiny property checks on n <= 8
    for n in range(3, 9):
        ops = solve_case(n)
        a = apply_ops(n, ops)
        # Bound check
        assert all(1 <= v <= 10**18 for v in a)
        # Every i in 1..n should appear as a gcd of some non-empty subsequence
        gs = gcd_set_all_subseq(a)
        for i in range(1, n+1):
            assert i in gs

if __name__ == "__main__":
    _tests()
    data = sys.stdin.read()
    if data.strip():
        ns = read_input(data)
        sys.stdout.write(solve_all(ns))
\end{minted}
\VALIDATION{Unit tests validate formatting and on $n \le 8$ verify values stay within bounds and every $i \in [1..n]$ appears as a $\gcd$ of some subsequence under the no-op plan.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{The trivial no-op remains optimal for simplicity and robustness; no data structure needed.}
\ASSUMPTIONS{Same as Approach A; we keep $k=0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse input.
\item For each test case, output $0$.
\item Maintain assertions for safety.
\end{algosteps}
\COMPLEXITY{Identical to Approach A: $O(1)$ per test.}
\[
\begin{aligned}
T(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{No array entries change; constraints are satisfied.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str) -> List[int]:
    toks = data.strip().split()
    if not toks:
        return []
    t = int(toks[0])
    ns = [int(x) for x in toks[1:1+t]]
    assert len(ns) == t
    return ns

def solve_case(n: int) -> List[Tuple[int, int, int]]:
    return []

def solve_all(ns: List[int]) -> str:
    out = []
    for n in ns:
        ops = solve_case(n)
        assert 0 <= len(ops) <= (n // 6) + 5
        out.append(str(len(ops)))
        for (i, j, k) in ops:
            assert len({i, j, k}) == 3
            assert 1 <= i <= n and 1 <= j <= n and 1 <= k <= n
            out.append(f"{i} {j} {k}")
    return "\n".join(out)

def _tests():
    assert solve_all([3]) == "0"
    assert solve_all([3, 4]) == "0\n0"
    # Budget check stress
    for n in [3, 6, 12, 30_000]:
        ops = solve_case(n)
        assert len(ops) <= (n // 6) + 5

if __name__ == "__main__":
    _tests()
    data = sys.stdin.read()
    if data.strip():
        ns = read_input(data)
        print(solve_all(ns))
\end{minted}
\VALIDATION{Checks formatting and budget compliance; deterministic output.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{When any valid sequence is acceptable and the initial array already satisfies all bounds, the optimal strategy is to output zero operations.}
\ASSUMPTIONS{Zero operations are allowed; $a_i=i \le 10^{18}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each test case, emit $0$.
\item No other output is required.
\item Ensure constraints are asserted.
\end{algosteps}
\OPTIMALITY{Minimizes both the number of operations and the risk of exceeding the $10^{18}$ cap.}
\COMPLEXITY{Constant time and space per test.}
\[
\begin{aligned}
T(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> List[int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    t = int(data[0])
    ns = list(map(int, data[1:1+t]))
    assert len(ns) == t
    return ns

def solve_case(n: int) -> List[Tuple[int, int, int]]:
    # Final: zero operations
    return []

def solve_all(ns: List[int]) -> str:
    out = []
    for n in ns:
        ops = solve_case(n)
        assert 0 <= len(ops) <= (n // 6) + 5
        out.append(str(len(ops)))
        for (i, j, k) in ops:
            assert len({i, j, k}) == 3
            assert 1 <= i <= n and 1 <= j <= n and 1 <= k <= n
            out.append(f"{i} {j} {k}")
    return "\n".join(out)

def main():
    ns = read_input()
    sys.stdout.write(solve_all(ns))

if __name__ == "__main__":
    # Exactly 3 asserts / mini-tests
    assert solve_all([3]) == "0"
    assert solve_all([10]) == "0"
    assert solve_all([3, 7, 9]) == "0\n0\n0"
    main()
\end{minted}
\VALIDATION{Three exact asserts confirm output shape on small inputs.}
\RESULT{For each test, a single line with $0$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests verify formatting, budget adherence, and small-case sanity under the zero-operations strategy.}
\LINE{CROSS-CHECKS}{All approaches output identical results; cross-compare strings for the same inputs.}
\LINE{EDGE-CASE GENERATOR}{Generate boundary $n \in \{3,4,5,6, 3\cdot 10^{4}\}$ and random small $n$ to confirm stability.}
\begin{minted}{python}
import random
from typing import List

def gen_cases() -> List[int]:
    cases = [3, 4, 5, 6, 30_000]
    cases += [random.randint(3, 50) for _ in range(10)]
    return cases

# Deterministic generators for boundaries, degenerates, adversarials
def test_reference():
    from io import StringIO
    import sys

    def run_io(inp: str) -> str:
        data = list(map(int, inp.strip().split()))
        t = data[0]
        ns = data[1:1+t]
        out = []
        for n in ns:
            out.append("0")
        return "\n".join(out)

    # Boundary tests
    assert run_io("1 3") == "0"
    assert run_io("1 30000") == "0"
    # Multi-test concatenation
    assert run_io("3 3 7 10") == "0\n0\n0"

test_reference()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input() -> List[int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    t = int(data[0])
    ns = list(map(int, data[1:1+t]))
    assert len(ns) == t
    return ns

def solve_case(n: int) -> List[Tuple[int, int, int]]:
    # Reference: zero operations
    return []

def solve_all(ns: List[int]) -> str:
    out = []
    for n in ns:
        ops = solve_case(n)
        # Budget safety
        assert 0 <= len(ops) <= (n // 6) + 5
        out.append(str(len(ops)))
        for (i, j, k) in ops:
            assert len({i, j, k}) == 3
            assert 1 <= i <= n and 1 <= j <= n and 1 <= k <= n
            out.append(f"{i} {j} {k}")
    return "\n".join(out)

def main():
    ns = read_input()
    sys.stdout.write(solve_all(ns))

if __name__ == "__main__":
    # Basic asserts to ensure consistent behavior
    assert solve_all([3]) == "0"
    assert solve_all([3, 4]) == "0\n0"
    assert solve_all([7, 7, 7]) == "0\n0\n0"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{We can legally output zero operations; the initial array already respects value bounds.}
\WHY{Under time pressure, a safe valid construction avoids accidental overflow from $\operatorname{lcm}$ updates.}
\CHECKLIST{%
\begin{bullets}
\item Parse $t$ and $n$ correctly.
\item Respect $k \le \lfloor \tfrac{n}{6} \rfloor + 5$.
\item Ensure indices in each operation are distinct and within $[1,n]$.
\item Keep all $a_i \le 10^{18}$; zero ops guarantees this.
\end{bullets}}
\EDGECASES{%
\begin{bullets}
\item $n=3$ minimal case.
\item $n$ near $3\cdot 10^{4}$ maximal case.
\item Multiple test cases with varying $n$.
\item Empty or whitespace-only input handling in local tests.
\item Handling of trailing newlines in output.
\item Robustness of assertions.
\end{bullets}}
\PITFALLS{%
\begin{bullets}
\item Forgetting that $k$ can be $0$.
\item Printing extra spaces or lines.
\item Misparsing input when $t=0$ (not allowed here).
\item Using $0$-based indices instead of $1$-based.
\item Exceeding the operation budget.
\item Overflowing values with unnecessary $\operatorname{lcm}$ operations.
\end{bullets}}
\FAILMODES{%
\begin{bullets}
\item Constructive attempts that overshoot $10^{18}$ via $\operatorname{lcm}$.
\item Randomized constructions that violate distinctness of indices.
\item Outputs with incorrect line counts.
\end{bullets}}
\ELI{When allowed, doing nothing is sometimes the safest and best move: the array starts small and valid, and no changes are required to meet the constraints.}
\NotePages{3}

\end{document}