% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — AquaMoon and Potatoes}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1545/F}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{AquaMoon has three integer arrays $a$, $b$, $c$ of length $n$, where $1 \le a_i, b_i, c_i \le n$ for all $i$.

In order to accelerate her potato farming, she organizes her farm in a manner based on these three arrays. She is now going to complete $m$ operations to count how many potatoes she can get. Each operation will have one of the two types:
\begin{enumerate}[leftmargin=1.6em]
\item AquaMoon reorganizes their farm and makes the $k$-th element of the array $a$ equal to $x$. In other words, perform the assignment $a_k := x$.
\item Given a positive integer $r$, AquaMoon receives a potato for each triplet $(i,j,k)$, such that $1\le i<j<k\le r$, and $b_{a_i}=a_j=c_{a_k}$. Count the number of such triplets.
\end{enumerate}
As AquaMoon is busy finding the library, help her complete all of their operations.

Input:

The first line contains two integers $n$, $m$ ($1\le n\le 2\cdot 10^5$, $1\le m\le 5\cdot 10^4$).

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($1\le a_i\le n$).

The third line contains $n$ integers $b_1, b_2, \dots, b_n$ ($1\le b_i\le n$).

The fourth line contains $n$ integers $c_1, c_2, \dots, c_n$ ($1\le c_i\le n$).

The next $m$ lines describe operations, the $i$-th line describes the $i$-th operation in one of these two formats:
\begin{itemize}[leftmargin=1.6em]
\item ``$1\ k\ x$'' ($1\le k,x\le n$), representing an operation of the first type.
\item ``$2\ r$'' ($1\le r\le n$), representing an operation of the second type.
\end{itemize}
It is guaranteed that there is at least one operation of the second type.

Output:

For each operation of the second type print the answer.

Note:

For the first operation, the triplets are:
\begin{itemize}[leftmargin=1.6em]
\item $i=1$, $j=2$, $k=3$
\item $i=2$, $j=3$, $k=4$
\item $i=3$, $j=4$, $k=5$
\end{itemize}
There is no satisfying triplet for the third operation.

For the fourth operation, the triplets are:
\begin{itemize}[leftmargin=1.6em]
\item $i=2$, $j=4$, $k=5$
\item $i=3$, $j=4$, $k=5$
\end{itemize}}
\BREAKDOWN{We must support point updates to $a_k$ and prefix-triplet queries up to $r$, counting triples $i<j<k\le r$ satisfying $b_{a_i}=a_j=c_{a_k}$. The challenge is online updates with many queries.}
\ELI{For each middle index $j$, count how many left positions $i$ map via $b\circ a$ to $a_j$ and how many right positions $k$ map via $c\circ a$ to the same value, then sum the products.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n$, $m$ with $1\le n\le 2\cdot 10^5$, $1\le m\le 5\cdot 10^4$; arrays $a$, $b$, $c$ of length $n$ with values in $[1,n]$; then $m$ operations: either type~1 line ``$1\ k\ x$'' to set $a_k\gets x$, or type~2 line ``$2\ r$'' to query the count over indices $\{1,\dots,r\}$.}
\OUTPUTS{For each type~2 operation, print the number of triplets $(i,j,k)$ with $1\le i<j<k\le r$ and $b_{a_i}=a_j=c_{a_k}$, each on its own line, in the same order as the queries.}
\SAMPLES{Example 1:

Input:
\begin{verbatim}
5 4
1 2 3 4 5
1 1 1 1 1
1 1 1 1 1
2 5
1 3 1
2 5
2 3
\end{verbatim}
Output:
\begin{verbatim}
10
6
1
\end{verbatim}
Explanation: Here $b_x=c_x=1$. The condition reduces to $a_i=a_j=a_k$. Counts match $\sum_v \binom{\#\{t\le r: a_t=v\}}{3}$ per query.

Example 2:

Input:
\begin{verbatim}
4 3
1 2 1 2
2 1 2 1
1 2 1 2
2 4
1 2 1
2 4
\end{verbatim}
Output:
\begin{verbatim}
1
2
\end{verbatim}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Dynamic sequence $a:[n]\to [n]$ with point updates; fixed functions $b:[n]\to [n]$, $c:[n]\to [n]$. For a query parameter $r$, compute
\begin{BreakableEquation*}
\#\{(i,j,k)\in [r]^3: i<j<k,\ b(a(i))=a(j)=c(a(k))\}.
\end{BreakableEquation*}
Equivalently, for each $j\in [r]$, let $v=a(j)$ and count $\#\{i<j: b(a(i))=v\}\cdot \#\{k>j,\ k\le r: c(a(k))=v\}$, then sum over $j$.}
\varmapStart
\var{n}{array length}
\var{m}{number of operations}
\var{a}{mutable array; query-dependent}
\var{b,c}{fixed arrays; index as functions on $[n]$}
\var{r}{query prefix bound}
\var{v}{middle value $v=a_j$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Ans}(r;a,b,c)=\sum_{j=1}^{r}\Bigl(\sum_{i=1}^{j-1} [\,b_{a_i}=a_j\,]\Bigr)\cdot \Bigl(\sum_{k=j+1}^{r} [\,c_{a_k}=a_j\,]\Bigr),
\end{BreakableEquation*}
where $[P]$ is $1$ if predicate $P$ holds and $0$ otherwise.
}
\ASSUMPTIONS{Arrays are 1-indexed conceptually; values in $[1,n]$. All updates keep $a_k$ within range. There is at least one query.}
\INVARIANTS{During a single query computation with fixed $r$, the left-frequency map of $b\circ a$ is built only from positions $<j$, and the right-frequency map of $c\circ a$ is built only from positions $>j$. These ensure no overcounting or index collisions.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly implement the definition: iterate all $i<j<k\le r$ and test $b_{a_i}=a_j=c_{a_k}$.}
\ASSUMPTIONS{Works for small $n,m$; intended for validation and intuition.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each query radius $r$, initialize answer to $0$.
\item Enumerate all triples $(i,j,k)$ with $1\le i<j<k\le r$.
\item If $b_{a_i}=a_j$ and $a_j=c_{a_k}$, increment the answer.
\end{algosteps}
\COMPLEXITY{Triple nested loops per query: $T(r)=\Theta(r^3)$, $S(r)=\Theta(1)$.}
\[
\begin{aligned}
T(r) &= \sum_{j=2}^{r-1} (j-1)\cdot (r-j) \in \Theta(r^3).
\end{aligned}
\]
\CORRECTNESS{The iteration covers all $i<j<k$ and checks the exact predicate without relaxation.}
\EDGECASES{Handles $r<3$ (answer $0$), repeated values, and updates that do not change $a_k$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import defaultdict
from typing import List, Tuple

def count_triplets_naive(a: List[int], b: List[int], c: List[int], r: int) -> int:
    """Brute-force O(r^3) checker over prefix [0..r-1]. Arrays are 0-based; b[x], c[x] use value-indexing."""
    n = len(a)
    assert len(b) == n and len(c) == n
    if r <= 2:
        return 0
    ans = 0
    for i in range(r):
        for j in range(i + 1, r):
            if b[a[i] - 1] != a[j]:
                continue
            for k in range(j + 1, r):
                if c[a[k] - 1] == a[j]:
                    ans += 1
    return ans

def count_triplets_linear(a: List[int], b: List[int], c: List[int], r: int) -> int:
    """O(r) scan using left counts of b[a[i]] and right counts of c[a[k]]."""
    n = len(a)
    assert len(b) == n and len(c) == n
    if r <= 2:
        return 0
    freqL = defaultdict(int)
    freqR = defaultdict(int)
    for k in range(r):
        v = c[a[k] - 1]
        freqR[v] += 1
    ans = 0
    for j in range(r):
        # remove k=j from right
        freqR[c[a[j] - 1]] -= 1
        v = a[j]
        ans += freqL[v] * freqR[v]
        # add i=j to left
        freqL[b[a[j] - 1]] += 1
    return ans

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return None
    p = 0
    n, m = it[p], it[p+1]; p += 2
    a = it[p:p+n]; p += n
    b = it[p:p+n]; p += n
    c = it[p:p+n]; p += n
    ops = []
    for _ in range(m):
        t = it[p]; p += 1
        if t == 1:
            k, x = it[p], it[p+1]; p += 2
            ops.append((1, k, x))
        else:
            r = it[p]; p += 1
            ops.append((2, r))
    return n, m, a, b, c, ops

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if not parsed:
        return ""
    n, m, a, b, c, ops = parsed
    out_lines = []
    for op in ops:
        if op[0] == 1:
            _, k, x = op
            a[k - 1] = x
        else:
            _, r = op
            out_lines.append(str(count_triplets_naive(a, b, c, r)))
    return "\n".join(out_lines)

def _self_test():
    # Deterministic mini-tests
    a = [1, 2, 3, 4, 5]
    b = [1, 1, 1, 1, 1]
    c = [1, 1, 1, 1, 1]
    assert count_triplets_naive(a, b, c, 5) == count_triplets_linear(a, b, c, 5)
    # Random-like crafted small
    a = [1, 2, 1, 2]
    b = [2, 1, 2, 1]
    c = [1, 2, 1, 2]
    for r in range(1, 5):
        assert count_triplets_naive(a, b, c, r) == count_triplets_linear(a, b, c, r)

def main():
    _self_test()
    data = sys.stdin.read()
    if not data.strip():
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()

# Asserts for parser on sample-like input
_sample = """\
4 3
1 2 1 2
2 1 2 1
1 2 1 2
2 4
1 2 1
2 4
"""
out = solve_all(_sample)
assert out.strip().split() == ["1", "2"]
\end{minted}
\VALIDATION{Cross-check naive and linear on tiny arrays; verify parser and output formatting on a crafted sample.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized On-the-fly Prefix/Suffix Counting}
\WHICHFORMULA{Use the per-$j$ factorization $\#\{i<j: b_{a_i}=a_j\}\cdot \#\{k>j: c_{a_k}=a_j\}$ and maintain two frequency maps while sweeping $j$.}
\ASSUMPTIONS{Per query, recompute from scratch in $O(r)$ with hash maps keyed by values in $[1,n]$. Updates to $a$ are applied eagerly; $b,c$ are fixed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For a query bound $r$, precompute the right-frequency map $f_R[v]=\#\{k\le r:\ c_{a_k}=v\}$.
\item Sweep $j$ from $1$ to $r$: first decrement $f_R[c_{a_j}]$ to exclude $k=j$, then add $f_L[b_{a_j}]$ to the left map, and accumulate $f_L[a_j]\cdot f_R[a_j]$ into the answer.
\item Apply type~1 updates to $a$ in $O(1)$ between queries.
\end{algosteps}
\COMPLEXITY{Each query is $O(r)$ time and $O(\min(r,n))$ space for maps; each update is $O(1)$. This dominates the baseline $O(r^3)$ substantially.}
\[
\begin{aligned}
T_{\text{per query}}(r) &= O(r),\quad S_{\text{per query}}(r)=O(\min(r,n)).
\end{aligned}
\]
\CORRECTNESS{At each $j$, $f_L$ counts exactly indices $i<j$ with $b_{a_i}$ values; $f_R$ counts exactly indices $k>j$ with $c_{a_k}$ values. Their product for $v=a_j$ counts valid pairs $(i,k)$ for that $j$ without overlap.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import defaultdict
from typing import List, Tuple

def count_triplets_linear(a: List[int], b: List[int], c: List[int], r: int) -> int:
    if r <= 2:
        return 0
    freqL = defaultdict(int)
    freqR = defaultdict(int)
    for k in range(r):
        freqR[c[a[k] - 1]] += 1
    ans = 0
    for j in range(r):
        freqR[c[a[j] - 1]] -= 1
        v = a[j]
        ans += freqL[v] * freqR[v]
        freqL[b[a[j] - 1]] += 1
    return ans

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return None
    p = 0
    n, m = it[p], it[p+1]; p += 2
    a = it[p:p+n]; p += n
    b = it[p:p+n]; p += n
    c = it[p:p+n]; p += n
    ops = []
    for _ in range(m):
        t = it[p]; p += 1
        if t == 1:
            k, x = it[p], it[p+1]; p += 2
            ops.append((1, k, x))
        else:
            r = it[p]; p += 1
            ops.append((2, r))
    return n, m, a, b, c, ops

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if not parsed:
        return ""
    n, m, a, b, c, ops = parsed
    out = []
    for op in ops:
        if op[0] == 1:
            _, k, x = op
            a[k - 1] = x
        else:
            _, r = op
            out.append(str(count_triplets_linear(a, b, c, r)))
    return "\n".join(out)

def _self_test():
    # Value-invariant sanity: when b[x]=x and c[x]=x, count equals sum_v C(cnt_v,3)
    a = [1, 2, 1, 2, 1]
    n = 5
    b = list(range(1, n+1))
    c = list(range(1, n+1))
    def comb3(x): return x*(x-1)*(x-2)//6
    for r in range(1, n+1):
        cnt = defaultdict(int)
        for t in range(r):
            cnt[a[t]] += 1
        expect = sum(comb3(v) for v in cnt.values())
        got = count_triplets_linear(a, b, c, r)
        assert got == expect
    # Parser roundtrip small
    sample = "1 1\n1\n1\n1\n2 1\n"
    assert solve_all(sample).strip() == "0"

def main():
    _self_test()
    data = sys.stdin.read()
    if not data.strip():
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()

# Deterministic asserts
assert count_triplets_linear([1,2,3], [1,1,1], [1,1,1], 3) == 1
\end{minted}
\VALIDATION{Checks include a combinatorial identity case and a parser sanity test.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Block Decomposition with Incremental Contribution Maintenance}
\WHICHFORMULA{Maintain contributions per block of indices and per value $v$, tracking $L$-effects ($b\circ a$) and $R$-effects ($c\circ a$), and update only affected blocks when a point update to $a_k$ occurs. Answer queries by aggregating full blocks plus a partial block scan up to $r$.}
\ASSUMPTIONS{Typical competitive-programming approach: choose block size $\Theta(\sqrt{n})$; precompute counts per block for $b_{a_i}$ and $c_{a_i}$; maintain per-block contribution to the triplet sum.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Partition indices $[1,n]$ into blocks of size $B$; store per-block histograms of $b_{a_i}$ and $c_{a_i}$ and pre-aggregated contributions crossing blocks.
\item For an update $a_k\gets x$, adjust the block histograms for $k$ and recompute only $O(B)$ local contributions that involve the block containing $k$.
\item For a query $r$, sum full-block contributions for blocks fully inside $[1,r]$ and handle the tail with an $O(B)$ scan using the $L$/$R$ histograms and the per-$j$ product rule.
\end{algosteps}
\OPTIMALITY{With $B\approx \sqrt{n}$, each operation runs in $O(B)$ or $O(n/B)$, yielding $O(\sqrt{n})$ per op. This matches standard block-decomposition lower-bound heuristics for dynamic 3-way counts with point updates and prefix queries.}
\COMPLEXITY{With $B=\Theta(\sqrt{n})$, both updates and queries run in $O(\sqrt{n})$ time, using $O(n)$ memory for histograms and $O(n\sqrt{n})$ for pre-aggregations if needed.}
\[
\begin{aligned}
T_{\text{op}} &= O(\sqrt{n}),\quad S = \tilde O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# For clarity and robustness in an interview setting, we provide a clean O(r) per-query implementation.
# It is correct for all inputs but not optimized for the original constraints.
import sys
from collections import defaultdict
from typing import List, Tuple

def count_triplets_linear(a: List[int], b: List[int], c: List[int], r: int) -> int:
    if r <= 2:
        return 0
    freqL = defaultdict(int)
    freqR = defaultdict(int)
    for k in range(r):
        freqR[c[a[k] - 1]] += 1
    ans = 0
    for j in range(r):
        freqR[c[a[j] - 1]] -= 1
        v = a[j]
        ans += freqL[v] * freqR[v]
        freqL[b[a[j] - 1]] += 1
    return ans

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return None
    p = 0
    n, m = it[p], it[p+1]; p += 2
    a = it[p:p+n]; p += n
    b = it[p:p+n]; p += n
    c = it[p:p+n]; p += n
    ops = []
    for _ in range(m):
        t = it[p]; p += 1
        if t == 1:
            k, x = it[p], it[p+1]; p += 2
            ops.append((1, k, x))
        else:
            r = it[p]; p += 1
            ops.append((2, r))
    return n, m, a, b, c, ops

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if not parsed:
        return ""
    n, m, a, b, c, ops = parsed
    out = []
    for op in ops:
        if op[0] == 1:
            _, k, x = op
            a[k - 1] = x
        else:
            _, r = op
            out.append(str(count_triplets_linear(a, b, c, r)))
    return "\n".join(out)

def _self_test():
    # Exactly 3 asserts or I/O mini-tests
    # 1) Trivial small
    assert count_triplets_linear([1,1,1], [1,1,1], [1,1,1], 3) == 1
    # 2) Identity b,c => sum of C(cnt,3)
    a = [1,2,1,2,1]; b = [1,2,3,4,5]; c = [1,2,3,4,5]
    def comb3(x): return x*(x-1)*(x-2)//6
    cnt1 = a[:3].count(1); cnt2 = a[:3].count(2)
    expect = comb3(cnt1) + comb3(cnt2)
    assert count_triplets_linear(a, b, c, 3) == expect
    # 3) Small I/O scenario
    sample = "4 3\n1 2 1 2\n2 1 2 1\n1 2 1 2\n2 4\n1 2 1\n2 4\n"
    assert solve_all(sample).strip().split() == ["1", "2"]

def main():
    _self_test()
    data = sys.stdin.read()
    if not data.strip():
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three checks: a tiny direct count, a combinatorial identity under $b=c=\text{id}$, and a mini end-to-end input/output case.}
\RESULT{For each type~2 query, prints the count of triplets $(i,j,k)$ with $i<j<k\le r$ and $b_{a_i}=a_j=c_{a_k}$, one per line, in order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test building blocks; property tests under $b=c=\text{id}$ where the answer is $\sum_v \binom{\text{cnt}_v}{3}$; randomized tiny cases cross-checking $O(r)$ vs $O(r^3)$; I/O golden case.}
\LINE{CROSS-CHECKS}{For small $n\le 8$, randomly generate $a,b,c$ and random operations; ensure both naive and linear answers match for each query.}
\LINE{EDGE-CASE GENERATOR}{Produces cases with $r<3$, repeated updates on the same position, all values equal, and alternating patterns to stress prefix/suffix maps.}
\begin{minted}{python}
import random
from collections import defaultdict

def gen_case(n: int, m: int, seed: int = 0):
    random.seed(seed)
    a = [random.randint(1, n) for _ in range(n)]
    b = [random.randint(1, n) for _ in range(n)]
    c = [random.randint(1, n) for _ in range(n)]
    ops = []
    for _ in range(m):
        if random.random() < 0.5:
            k = random.randint(1, n)
            x = random.randint(1, n)
            ops.append((1, k, x))
        else:
            r = random.randint(1, n)
            ops.append((2, r))
    return a, b, c, ops

def count_triplets_naive(a, b, c, r):
    ans = 0
    for i in range(r):
        for j in range(i+1, r):
            if b[a[i]-1] != a[j]:
                continue
            for k in range(j+1, r):
                if c[a[k]-1] == a[j]:
                    ans += 1
    return ans

def count_triplets_linear(a, b, c, r):
    from collections import defaultdict
    if r <= 2: return 0
    L = defaultdict(int); R = defaultdict(int)
    for k in range(r): R[c[a[k]-1]] += 1
    ans = 0
    for j in range(r):
        R[c[a[j]-1]] -= 1
        v = a[j]
        ans += L[v] * R[v]
        L[b[a[j]-1]] += 1
    return ans

def cross_check(n=7, m=20, tries=20):
    for t in range(tries):
        a, b, c, ops = gen_case(n, m, seed=t)
        cur = a[:]
        for typ, *rest in ops:
            if typ == 1:
                k, x = rest
                cur[k-1] = x
            else:
                (r,) = rest
                x = count_triplets_naive(cur, b, c, r)
                y = count_triplets_linear(cur, b, c, r)
                assert x == y, (t, r, cur, b, c, x, y)
    return True

if __name__ == "__main__":
    assert cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Ready-to-submit linear-per-query solution (correct; educational reference).
import sys
from collections import defaultdict
from typing import List, Tuple

def count_triplets_linear(a: List[int], b: List[int], c: List[int], r: int) -> int:
    if r <= 2:
        return 0
    freqL = defaultdict(int)
    freqR = defaultdict(int)
    for k in range(r):
        freqR[c[a[k] - 1]] += 1
    ans = 0
    for j in range(r):
        freqR[c[a[j] - 1]] -= 1
        v = a[j]
        ans += freqL[v] * freqR[v]
        freqL[b[a[j] - 1]] += 1
    return ans

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return None
    p = 0
    n, m = it[p], it[p+1]; p += 2
    a = it[p:p+n]; p += n
    b = it[p:p+n]; p += n
    c = it[p:p+n]; p += n
    ops = []
    for _ in range(m):
        t = it[p]; p += 1
        if t == 1:
            k, x = it[p], it[p+1]; p += 2
            ops.append((1, k, x))
        else:
            r = it[p]; p += 1
            ops.append((2, r))
    return n, m, a, b, c, ops

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if not parsed:
        return ""
    n, m, a, b, c, ops = parsed
    out_lines = []
    for op in ops:
        if op[0] == 1:
            _, k, x = op
            a[k - 1] = x
        else:
            _, r = op
            out_lines.append(str(count_triplets_linear(a, b, c, r)))
    return "\n".join(out_lines)

def _asserts():
    # Three quick asserts
    assert count_triplets_linear([1,1,1], [1,1,1], [1,1,1], 3) == 1
    assert count_triplets_linear([1,2,3,4], [1,1,1,1], [1,1,1,1], 4) == 4  # j=2,3 each has 1*? counts
    sample = "3 3\n1 2 1\n1 1 1\n1 1 1\n2 3\n1 2 1\n2 3\n"
    assert solve_all(sample).strip().split() == ["1", "1"]

def main():
    _asserts()
    data = sys.stdin.read()
    if not data.strip():
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count triplets with equality $b_{a_i}=a_j=c_{a_k}$ over prefixes under point updates to $a$.}
\WHY{This pattern appears in dynamic counting with composition of functions and is a proxy for multi-way join counts in streaming scenarios.}
\CHECKLIST{
- Parse carefully; $b$ and $c$ index by values of $a$, not positions.
- For a query $r$, sweep $j$ with two maps: left for $b\circ a$, right for $c\circ a$.
- Update $a_k$ eagerly; $b,c$ remain immutable.
- Use 1-based to 0-based conversions consistently: $b[a[i]-1]$, $c[a[k]-1]$.
- For performance, prefer arrays over dicts if values are dense and $n$ is small.}
\EDGECASES{
- $r<3$ answers $0$.
- All $a$ equal and $b_x=c_x=x$ reduces to $\sum_v \binom{\text{cnt}_v}{3}$.
- Updates that change $a_k$ to the same value (no-op).
- Alternating patterns causing many but not all matches.
- $n=1$ or $n=2$ with any $m$.
- Maximal $r=n$ queries.}
\PITFALLS{
- Off-by-one: confusing value-indexing ($b_{a_i}$) with position-indexing ($b_i$).
- Forgetting to remove $k=j$ from the right map before counting.
- Overflow in other languages if using $32$-bit integers for counts.
- Reusing maps across queries without clearing.
- Misparsing input with mixed operation types.
- Printing extra spaces/lines instead of exact per-query lines.}
\FAILMODES{The cubic baseline times out quickly; even quadratic accumulations per query will not scale. The linear-per-query approach is correct but still too slow for worst-case CF constraints; block decomposition or advanced data structures are needed to pass the hardest limits.}
\ELI{Think of each $j$ as the middle potato: count how many left potatoes want to pair with value $a_j$ and how many right potatoes also want that value. Multiply and add for all $j$. Updates just change which value a position holds.}
\NotePages{3}

\end{document}