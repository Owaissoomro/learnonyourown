% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cheap Dinner}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1487/E}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{Ivan wants to have a good dinner. A good dinner should consist of a first course, a second course, a drink, and a dessert.

There are $n_1$ different types of first courses Ivan can buy (the $i$-th of them costs $a_i$ coins), $n_2$ different types of second courses (the $i$-th of them costs $b_i$ coins), $n_3$ different types of drinks (the $i$-th of them costs $c_i$ coins) and $n_4$ different types of desserts (the $i$-th of them costs $d_i$ coins).

Some dishes do not go well with each other. There are $m_1$ pairs of first courses and second courses that do not go well with each other, $m_2$ pairs of second courses and drinks, and $m_3$ pairs of drinks and desserts that do not go well with each other.

Ivan wants to buy exactly one first course, one second course, one drink, and one dessert so that they go well with each other, and the total cost of the dinner is the minimum possible. Help him to find the cheapest dinner option!

Input:
The first line contains four integers $n_1$, $n_2$, $n_3$ and $n_4$ ($1 \le n_i \le 150000$) — the number of types of first courses, second courses, drinks and desserts, respectively.

Then four lines follow. The first line contains $n_1$ integers $a_1, a_2, \ldots, a_{n_1}$ ($1 \le a_i \le 10^8$), where $a_i$ is the cost of the $i$-th type of first course. Three next lines denote the costs of second courses, drinks, and desserts in the same way ($1 \le b_i, c_i, d_i \le 10^8$).

The next line contains one integer $m_1$ ($0 \le m_1 \le 200000$) — the number of pairs of first and second courses that do not go well with each other. Each of the next $m_1$ lines contains two integers $x_i$ and $y_i$ ($1 \le x_i \le n_1$; $1 \le y_i \le n_2$) denoting that the first course number $x_i$ does not go well with the second course number $y_i$. All these pairs are different.

The block of pairs of second dishes and drinks that do not go well with each other is given in the same format. The same for pairs of drinks and desserts that do not go well with each other ($0 \le m_2, m_3 \le 200000$).

Output:
If it is impossible to choose a first course, a second course, a drink, and a dessert so that they go well with each other, print $-1$. Otherwise, print one integer — the minimum total cost of the dinner.

Note:
The best option in the first example is to take the first course $2$, the second course $1$, the drink $2$ and the dessert $1$.

In the second example, the only pair of the first course and the second course is bad, so it is impossible to have dinner.}
\BREAKDOWN{We must select one item from each of four layers with incompatibilities only between adjacent layers (first–second, second–drink, drink–dessert). Compute the minimum total cost or determine impossibility. A dynamic programming over layers with efficient exclusion of banned neighbors yields the answer.}
\ELI{Propagate cheapest costs from desserts backward, each time picking the cheapest compatible option with a data structure that can temporarily exclude banned indices.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Four integers $n_1,n_2,n_3,n_4$. Then arrays $a$ of length $n_1$, $b$ of length $n_2$, $c$ of length $n_3$, $d$ of length $n_4$. Then $m_1$ pairs $(x,y)$ with $1 \le x \le n_1$, $1 \le y \le n_2$ for first–second bans. Then $m_2$ pairs for second–drink bans with $1 \le x \le n_2$, $1 \le y \le n_3$. Then $m_3$ pairs for drink–dessert bans with $1 \le x \le n_3$, $1 \le y \le n_4$.}
\OUTPUTS{Single integer: minimal total cost if possible; otherwise $-1$.}
\SAMPLES{Example A:
1) Input
$n_1=1, n_2=1, n_3=1, n_4=1$; $a=[5]$; $b=[3]$; $c=[2]$; $d=[7]$; $m_1=m_2=m_3=0$.
Output: $17$.

Example B:
1) Input
$n_1=n_2=n_3=n_4=1$; $a=[1]$; $b=[2]$; $c=[3]$; $d=[4]$; $m_1=1$ with pair $(1,1)$; $m_2=m_3=0$.
Output: $-1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let four layers be $A$ (first), $B$ (second), $C$ (drinks), $D$ (desserts). Costs $a_i, b_j, c_k, d_\ell$. For each adjacent pair of layers, a set of forbidden edges: $F_{A,B} \subseteq A \times B$, $F_{B,C} \subseteq B \times C$, $F_{C,D} \subseteq C \times D$. We need
\begin{BreakableEquation*}
\min_{i \in A,\, j \in B,\, k \in C,\, \ell \in D} a_i+b_j+c_k+d_\ell
\end{BreakableEquation*}
subject to $(i,j) \notin F_{A,B}$, $(j,k) \notin F_{B,C}$, $(k,\ell) \notin F_{C,D}$.}
\varmapStart
\var{A,B,C,D}{index sets of sizes $n_1,n_2,n_3,n_4$}
\var{F_{A,B}}{forbidden pairs between layers $A$ and $B$}
\var{p^{(4)}_\ell}{effective cost on desserts: $d_\ell$}
\var{p^{(3)}_k}{best cost for drink $k$: $c_k + \min_{\ell \notin F_{C,D}(k)} p^{(4)}_\ell$}
\var{p^{(2)}_j}{best cost for second course $j$: $b_j + \min_{k \notin F_{B,C}(j)} p^{(3)}_k$}
\var{p^{(1)}_i}{best cost for first course $i$: $a_i + \min_{j \notin F_{A,B}(i)} p^{(2)}_j$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
p^{(4)}_\ell &= d_\ell,\\
p^{(3)}_k &= c_k + \min_{\ell:\,(k,\ell)\notin F_{C,D}} p^{(4)}_\ell,\\
p^{(2)}_j &= b_j + \min_{k:\,(j,k)\notin F_{B,C}} p^{(3)}_k,\\
p^{(1)}_i &= a_i + \min_{j:\,(i,j)\notin F_{A,B}} p^{(2)}_j,\\
\text{Answer} &= \min_i p^{(1)}_i.
\end{aligned}
\]
}
\ASSUMPTIONS{All costs are integers in $[1,10^8]$. Forbidden sets may be empty. If for some layer all outgoing edges of a node are forbidden to already-impossible next states (infinite cost), its effective cost is $+\infty$.}
\INVARIANTS{Backward DP monotonicity: if a next-layer node has $+\infty$ cost, it never contributes to minima. Compatibility only across adjacent layers; non-adjacent layers are independent given the immediate next-layer effective costs.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the backward DP recurrences, but compute each minimum by scanning all next-layer items and skipping forbidden ones.}
\ASSUMPTIONS{Suitable only for small inputs; uses sets for $O(1)$ compatibility checks but $O(n_L \cdot n_R)$ scans per transition.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $p^{(4)} = d$.
\item For drinks $k$, compute $p^{(3)}_k = c_k + \min_{\ell \notin F_{C,D}(k)} p^{(4)}_\ell$ by scanning all desserts.
\item For seconds $j$, compute $p^{(2)}_j = b_j + \min_{k \notin F_{B,C}(j)} p^{(3)}_k$ by scanning all drinks.
\item For firsts $i$, compute $p^{(1)}_i = a_i + \min_{j \notin F_{A,B}(i)} p^{(2)}_j$ by scanning all seconds. Answer is $\min_i p^{(1)}_i$ if finite, else $-1$.
\end{algosteps}
\COMPLEXITY{For sizes $n_1,\ldots,n_4$,
\[
\begin{aligned}
T(n) &= O(n_3 n_4 + n_2 n_3 + n_1 n_2),\\
S(n) &= O(n_1+n_2+n_3+n_4 + m_1+m_2+m_3).
\end{aligned}
\]
}
\CORRECTNESS{Implements the exact DP recurrences; scanning all next-layer nodes ensures the minimum among allowed neighbors is found.}
\EDGECASES{No compatible neighbor yields $+\infty$ effective cost; if all $p^{(1)}_i$ are infinite, print $-1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

INF = 10**19

def read_input(tokens: List[int]) -> Tuple[int,int,int,int,List[int],List[int],List[int],List[int],List[List[int]],List[List[int]],List[List[int]]]:
    it = iter(tokens)
    n1 = int(next(it)); n2 = int(next(it)); n3 = int(next(it)); n4 = int(next(it))
    a = [int(next(it)) for _ in range(n1)]
    b = [int(next(it)) for _ in range(n2)]
    c = [int(next(it)) for _ in range(n3)]
    d = [int(next(it)) for _ in range(n4)]
    m1 = int(next(it))
    ban_ab = [set() for _ in range(n1)]
    for _ in range(m1):
        x = int(next(it)) - 1
        y = int(next(it)) - 1
        ban_ab[x].add(y)
    m2 = int(next(it))
    ban_bc = [set() for _ in range(n2)]
    for _ in range(m2):
        x = int(next(it)) - 1
        y = int(next(it)) - 1
        ban_bc[x].add(y)
    m3 = int(next(it))
    ban_cd = [set() for _ in range(n3)]
    for _ in range(m3):
        x = int(next(it)) - 1
        y = int(next(it)) - 1
        ban_cd[x].add(y)
    # Convert to list-of-sets for baseline; later approaches may convert forms as needed.
    return n1, n2, n3, n4, a, b, c, d, ban_ab, ban_bc, ban_cd

def compute_prev_naive(cost_left: List[int], banned_sets: List[set], dp_right: List[int]) -> List[int]:
    nL = len(cost_left)
    nR = len(dp_right)
    res = [INF] * nL
    for i in range(nL):
        mn = INF
        bans = banned_sets[i]
        # scan all right nodes
        for j in range(nR):
            if j in bans:
                continue
            if dp_right[j] < mn:
                mn = dp_right[j]
        if mn >= INF // 2:
            res[i] = INF
        else:
            res[i] = cost_left[i] + mn
    return res

def solve_all(tokens: List[int]) -> str:
    n1, n2, n3, n4, a, b, c, d, ban_ab, ban_bc, ban_cd = read_input(tokens)
    dp4 = d[:]  # desserts
    dp3 = compute_prev_naive(c, ban_cd, dp4)
    dp2 = compute_prev_naive(b, ban_bc, dp3)
    dp1 = compute_prev_naive(a, ban_ab, dp2)
    ans = min(dp1) if dp1 else INF
    return str(-1 if ans >= INF // 2 else ans)

def main() -> None:
    data = sys.stdin.read().strip().split()
    if not data:
        # Self-tests
        # Test 1: simple no bans
        tokens = """2 2 2 2
        1 5
        2 3
        4 1
        2 7
        0
        0
        0
        """.split()
        out = solve_all(tokens)
        assert out == "6", out  # 1+2+1+2
        # Test 2: impossible due to first-second ban
        tokens = """1 1 1 1
        1
        2
        3
        4
        1
        1 1
        0
        0
        """.split()
        out = solve_all(tokens)
        assert out == "-1", out
        # Test 3: some bans but possible
        tokens = """1 2 2 2
        10
        5 100
        3 4
        1 2
        0
        1
        1 1
        1
        1 2
        """.split()
        out = solve_all(tokens)
        # Manually: dp4=[1,2]; dp3=[3+1=4, 4+1(ban 2? no)->5]; dp2=[5+4=9,100+4=104]; dp1=10+9=19
        assert out == "19", out
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Covers no-bans, hard-ban impossibility, and mixed bans with explicit manual calculation.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Segment Tree With Temporary Exclusions}
\WHICHFORMULA{Maintain a min-segment tree over next-layer effective costs. For each current node, temporarily set all banned next-indices to $+\infty$, query the global minimum in $O(1)$ (tree root), then restore those points.}
\ASSUMPTIONS{Point updates and global minimum queries suffice; duplicates are handled naturally; total time $O((n + m)\log n)$ per transition.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $p^{(4)}=d$ and a segment tree $T_4$ with leaves $d_\ell$.
\item For each drink $k$, temporarily set $T_4[\ell]\gets+\infty$ for all forbidden $(k,\ell)$, read $m=\min T_4$, set $p^{(3)}_k=c_k+m$ (or $+\infty$ if $m=+\infty$), then restore the modified leaves.
\item Repeat similarly to compute $p^{(2)}$ from $p^{(3)}$, and $p^{(1)}$ from $p^{(2)}$.
\item Answer is $\min_i p^{(1)}_i$ or $-1$ if $+\infty$.
\end{algosteps}
\COMPLEXITY{For each transition with left size $n_L$, right size $n_R$, and $q$ forbidden pairs, we perform $2q$ point updates and $n_L$ root queries:
\begin{BreakableEquation*}
T(n)=O\big((n_R + q)\log n_R + n_L\big)=O\big((n_L+n_R+q)\log n_R\big).
\end{BreakableEquation*}
Total over three transitions is $O\big((n_1+n_2+n_3+n_4+m_1+m_2+m_3)\log N\big)$.}
\CORRECTNESS{Temporarily excluding exactly the forbidden neighbors turns the global minimum into the correct minimum over allowed next-layer nodes. Restoring preserves correctness for subsequent nodes.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple

INF = 10**19

class SegMin:
    __slots__ = ("n", "size", "seg")
    def __init__(self, arr: List[int]) -> None:
        self.n = len(arr)
        size = 1
        while size < self.n:
            size <<= 1
        self.size = size
        self.seg = [INF] * (2 * size)
        base = size
        for i, v in enumerate(arr):
            self.seg[base + i] = v
        for i in range(base - 1, 0, -1):
            self.seg[i] = self.seg[i << 1] if self.seg[i << 1] < self.seg[i << 1 | 1] else self.seg[i << 1 | 1]

    def set(self, idx: int, val: int) -> None:
        p = self.size + idx
        self.seg[p] = val
        p >>= 1
        while p:
            left = self.seg[p << 1]
            right = self.seg[p << 1 | 1]
            self.seg[p] = left if left < right else right
            p >>= 1

    def all_min(self) -> int:
        return self.seg[1] if self.size > 0 else INF

def read_input(tokens: List[int]):
    it = iter(tokens)
    n1 = int(next(it)); n2 = int(next(it)); n3 = int(next(it)); n4 = int(next(it))
    a = [int(next(it)) for _ in range(n1)]
    b = [int(next(it)) for _ in range(n2)]
    c = [int(next(it)) for _ in range(n3)]
    d = [int(next(it)) for _ in range(n4)]
    m1 = int(next(it))
    ban_ab = [[] for _ in range(n1)]
    for _ in range(m1):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_ab[x].append(y)
    m2 = int(next(it))
    ban_bc = [[] for _ in range(n2)]
    for _ in range(m2):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_bc[x].append(y)
    m3 = int(next(it))
    ban_cd = [[] for _ in range(n3)]
    for _ in range(m3):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_cd[x].append(y)
    return n1, n2, n3, n4, a, b, c, d, ban_ab, ban_bc, ban_cd

def compute_prev_seg(cost_left: List[int], banned: List[List[int]], dp_right: List[int]) -> List[int]:
    seg = SegMin(dp_right)
    res = [INF] * len(cost_left)
    for i in range(len(cost_left)):
        for j in banned[i]:
            if 0 <= j < len(dp_right):
                seg.set(j, INF)
        mn = seg.all_min()
        res[i] = INF if mn >= INF // 2 else cost_left[i] + mn
        for j in banned[i]:
            if 0 <= j < len(dp_right):
                seg.set(j, dp_right[j])
    return res

def solve_all(tokens: List[int]) -> str:
    n1, n2, n3, n4, a, b, c, d, ban_ab, ban_bc, ban_cd = read_input(tokens)
    dp4 = d[:]
    dp3 = compute_prev_seg(c, ban_cd, dp4)
    dp2 = compute_prev_seg(b, ban_bc, dp3)
    dp1 = compute_prev_seg(a, ban_ab, dp2)
    ans = min(dp1) if dp1 else INF
    return str(-1 if ans >= INF // 2 else ans)

def main() -> None:
    data = sys.stdin.read().strip().split()
    if not data:
        # Self-tests
        # No bans
        tokens = """2 2 2 2
        1 5
        2 3
        4 1
        2 7
        0
        0
        0
        """.split()
        assert solve_all(tokens) == "6"
        # Impossible due to A-B ban
        tokens = """1 1 1 1
        1
        2
        3
        4
        1
        1 1
        0
        0
        """.split()
        assert solve_all(tokens) == "-1"
        # Mixed bans
        tokens = """3 3 3 3
        3 2 10
        5 6 1
        7 4 8
        9 2 3
        2
        1 2
        2 3
        1
        2 2
        1
        3 1
        """.split()
        out = solve_all(tokens)
        # Just ensure it's a number and not -1 spuriously
        assert out.isdigit()
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Runs on three small scenarios, including impossible and mixed bans; uses assertions for sanity.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Min-Segment Tree per Transition (Final)}
\WHICHFORMULA{Exactly the segment-tree exclusion method, implemented with careful zero-based indices, $+\infty$ handling, and iterative tree for speed.}
\ASSUMPTIONS{All arrays fit in memory; total operations $(\sum n_i + \sum m_i)\log N$ are fine in Python when implemented iteratively.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set $dp^{(4)} \leftarrow d$.
\item For $C \to D$: build tree on $dp^{(4)}$, compute $dp^{(3)}$ by temporary exclusions of banned desserts for each drink.
\item For $B \to C$: build tree on $dp^{(3)}$, compute $dp^{(2)}$ similarly.
\item For $A \to B$: build tree on $dp^{(2)}$, compute $dp^{(1)}$ similarly; answer is $\min dp^{(1)}$ or $-1$ if infinite.
\end{algosteps}
\OPTIMALITY{The recurrences are tight; adjacency constraints only require excluding banned next-layer indices. Each transition is optimal given the next-layer $dp$, so the full solution is optimal.}
\COMPLEXITY{Let $N=\max(n_1,n_2,n_3,n_4)$. Each transition costs $O((n_L+n_R+m)\log n_R)$; sum over three transitions is $O((\sum n_i + \sum m_i)\log N)$ time and $O(\sum n_i + \sum m_i)$ space.}
\[
\begin{aligned}
T &= O\big((n_3+n_4+m_3)\log n_4 + (n_2+n_3+m_2)\log n_3 + (n_1+n_2+m_1)\log n_2\big).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

INF = 10**19

class SegMin:
    __slots__ = ("n", "size", "seg")
    def __init__(self, arr: List[int]) -> None:
        self.n = len(arr)
        size = 1
        while size < self.n:
            size <<= 1
        self.size = size
        self.seg = [INF] * (2 * size)
        base = size
        # initialize leaves
        for i, v in enumerate(arr):
            self.seg[base + i] = v
        # build
        for i in range(base - 1, 0, -1):
            l = self.seg[i << 1]
            r = self.seg[i << 1 | 1]
            self.seg[i] = l if l < r else r

    def set(self, idx: int, val: int) -> None:
        p = self.size + idx
        self.seg[p] = val
        p >>= 1
        while p:
            l = self.seg[p << 1]
            r = self.seg[p << 1 | 1]
            self.seg[p] = l if l < r else r
            p >>= 1

    def all_min(self) -> int:
        return self.seg[1] if self.size > 0 else INF

def read_input(tokens: List[str]):
    it = iter(tokens)
    n1 = int(next(it)); n2 = int(next(it)); n3 = int(next(it)); n4 = int(next(it))
    a = [int(next(it)) for _ in range(n1)]
    b = [int(next(it)) for _ in range(n2)]
    c = [int(next(it)) for _ in range(n3)]
    d = [int(next(it)) for _ in range(n4)]
    m1 = int(next(it))
    ban_ab = [[] for _ in range(n1)]
    for _ in range(m1):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        if 0 <= x < n1 and 0 <= y < n2:
            ban_ab[x].append(y)
    m2 = int(next(it))
    ban_bc = [[] for _ in range(n2)]
    for _ in range(m2):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        if 0 <= x < n2 and 0 <= y < n3:
            ban_bc[x].append(y)
    m3 = int(next(it))
    ban_cd = [[] for _ in range(n3)]
    for _ in range(m3):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        if 0 <= x < n3 and 0 <= y < n4:
            ban_cd[x].append(y)
    return n1, n2, n3, n4, a, b, c, d, ban_ab, ban_bc, ban_cd

def compute_prev(cost_left: List[int], banned: List[List[int]], dp_right: List[int]) -> List[int]:
    seg = SegMin(dp_right)
    res = [INF] * len(cost_left)
    for i, base in enumerate(cost_left):
        for j in banned[i]:
            # set to INF temporarily
            seg.set(j, INF)
        mn = seg.all_min()
        res[i] = INF if mn >= INF // 2 else base + mn
        # restore
        for j in banned[i]:
            seg.set(j, dp_right[j])
    return res

def solve_all(tokens: List[str]) -> str:
    n1, n2, n3, n4, a, b, c, d, ban_ab, ban_bc, ban_cd = read_input(tokens)
    dp4 = d[:]
    dp3 = compute_prev(c, ban_cd, dp4)
    dp2 = compute_prev(b, ban_bc, dp3)
    dp1 = compute_prev(a, ban_ab, dp2)
    ans = min(dp1) if dp1 else INF
    return str(-1 if ans >= INF // 2 else ans)

def main() -> None:
    data = sys.stdin.read().strip().split()
    if not data:
        # Exactly 3 asserts
        # 1) No bans: sum of minima
        tokens = """2 2 2 2
        7 5
        4 3
        6 1
        2 9
        0
        0
        0
        """.split()
        assert solve_all(tokens) == "11"  # 5+3+1+2
        # 2) All A-B pairs banned for unique nodes: impossible
        tokens = """1 1 1 1
        10
        20
        30
        40
        1
        1 1
        0
        0
        """.split()
        assert solve_all(tokens) == "-1"
        # 3) B-C bans force second-best drink
        tokens = """2 2 2 2
        1 100
        1 100
        1 100
        1 100
        0
        1
        1 1
        0
        """.split()
        # Best path uses B=2 -> C=1 not allowed, so B=2->C=2 or B=1->C=1 allowed
        out = solve_all(tokens)
        assert out == "3", out  # pick a1(1)+b1(1)+c1(1)+d1(1)
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts: minimal sum without bans; impossible case; a case where bans force a specific adjacency choice.}
\RESULT{Print the minimal total cost if feasible; otherwise $-1$. Ties do not matter since only the cost is required.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for parsing, basic no-ban cases, all-ban impossibility, and targeted bans across each boundary. Property check: removing bans never increases the minimal cost.}
\LINE{CROSS-CHECKS}{For tiny instances, compare Baseline (naive scans) vs. Optimal (segment tree) outputs on random seeds.}
\LINE{EDGE-CASE GENERATOR}{Create small $n_i \in \{1,2,3\}$ with random costs and random forbidden edges; ensure coverage of zero and full bans, and cases where some $dp$ layer becomes entirely $+\infty$.}
\begin{minted}{python}
import sys
import random
from typing import List

INF = 10**19

class SegMin:
    __slots__ = ("n","size","seg")
    def __init__(self, arr: List[int]) -> None:
        self.n = len(arr)
        size = 1
        while size < self.n:
            size <<= 1
        self.size = size
        self.seg = [INF] * (2 * size)
        for i, v in enumerate(arr):
            self.seg[size + i] = v
        for i in range(size - 1, 0, -1):
            l = self.seg[i << 1]; r = self.seg[i << 1 | 1]
            self.seg[i] = l if l < r else r
    def set(self, idx: int, val: int) -> None:
        p = self.size + idx
        self.seg[p] = val
        p >>= 1
        while p:
            l = self.seg[p << 1]; r = self.seg[p << 1 | 1]
            self.seg[p] = l if l < r else r
            p >>= 1
    def all_min(self) -> int:
        return self.seg[1] if self.size > 0 else INF

def compute_prev(cost_left: List[int], banned: List[List[int]], dp_right: List[int]) -> List[int]:
    seg = SegMin(dp_right)
    res = [INF] * len(cost_left)
    for i, base in enumerate(cost_left):
        for j in banned[i]:
            seg.set(j, INF)
        mn = seg.all_min()
        res[i] = INF if mn >= INF // 2 else base + mn
        for j in banned[i]:
            seg.set(j, dp_right[j])
    return res

def solve_tokens(tokens: List[str]) -> str:
    it = iter(tokens)
    n1 = int(next(it)); n2 = int(next(it)); n3 = int(next(it)); n4 = int(next(it))
    a = [int(next(it)) for _ in range(n1)]
    b = [int(next(it)) for _ in range(n2)]
    c = [int(next(it)) for _ in range(n3)]
    d = [int(next(it)) for _ in range(n4)]
    m1 = int(next(it))
    ban_ab = [[] for _ in range(n1)]
    for _ in range(m1):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_ab[x].append(y)
    m2 = int(next(it))
    ban_bc = [[] for _ in range(n2)]
    for _ in range(m2):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_bc[x].append(y)
    m3 = int(next(it))
    ban_cd = [[] for _ in range(n3)]
    for _ in range(m3):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_cd[x].append(y)
    dp4 = d[:]
    dp3 = compute_prev(c, ban_cd, dp4)
    dp2 = compute_prev(b, ban_bc, dp3)
    dp1 = compute_prev(a, ban_ab, dp2)
    ans = min(dp1) if dp1 else INF
    return str(-1 if ans >= INF // 2 else ans)

def gen_case(n1, n2, n3, n4, p=0.3) -> List[str]:
    a = [random.randint(1, 20) for _ in range(n1)]
    b = [random.randint(1, 20) for _ in range(n2)]
    c = [random.randint(1, 20) for _ in range(n3)]
    d = [random.randint(1, 20) for _ in range(n4)]
    ab = []
    for i in range(n1):
        for j in range(n2):
            if random.random() < p:
                ab.append((i+1, j+1))
    bc = []
    for i in range(n2):
        for j in range(n3):
            if random.random() < p:
                bc.append((i+1, j+1))
    cd = []
    for i in range(n3):
        for j in range(n4):
            if random.random() < p:
                cd.append((i+1, j+1))
    parts = []
    parts += [str(n1), str(n2), str(n3), str(n4)]
    parts += list(map(str, a))
    parts += list(map(str, b))
    parts += list(map(str, c))
    parts += list(map(str, d))
    parts.append(str(len(ab)))
    for x,y in ab: parts += [str(x), str(y)]
    parts.append(str(len(bc)))
    for x,y in bc: parts += [str(x), str(y)]
    parts.append(str(len(cd)))
    for x,y in cd: parts += [str(x), str(y)]
    return parts

# Cross-check tiny randoms against a naive O(n^2) per transition implementation
def solve_tokens_naive(tokens: List[str]) -> str:
    it = iter(tokens)
    n1 = int(next(it)); n2 = int(next(it)); n3 = int(next(it)); n4 = int(next(it))
    a = [int(next(it)) for _ in range(n1)]
    b = [int(next(it)) for _ in range(n2)]
    c = [int(next(it)) for _ in range(n3)]
    d = [int(next(it)) for _ in range(n4)]
    m1 = int(next(it))
    ban_ab = [set() for _ in range(n1)]
    for _ in range(m1):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_ab[x].add(y)
    m2 = int(next(it))
    ban_bc = [set() for _ in range(n2)]
    for _ in range(m2):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_bc[x].add(y)
    m3 = int(next(it))
    ban_cd = [set() for _ in range(n3)]
    for _ in range(m3):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_cd[x].add(y)
    dp4 = d[:]
    # C->D
    dp3 = [INF]*n3
    for k in range(n3):
        mn = INF
        for l in range(n4):
            if l not in ban_cd[k] and dp4[l] < mn:
                mn = dp4[l]
        dp3[k] = INF if mn >= INF//2 else c[k] + mn
    # B->C
    dp2 = [INF]*n2
    for j in range(n2):
        mn = INF
        for k in range(n3):
            if k not in ban_bc[j] and dp3[k] < mn:
                mn = dp3[k]
        dp2[j] = INF if mn >= INF//2 else b[j] + mn
    # A->B
    dp1 = [INF]*n1
    for i in range(n1):
        mn = INF
        for j in range(n2):
            if j not in ban_ab[i] and dp2[j] < mn:
                mn = dp2[j]
        dp1[i] = INF if mn >= INF//2 else a[i] + mn
    ans = min(dp1) if dp1 else INF
    return str(-1 if ans >= INF // 2 else ans)

def main():
    # Deterministic seeds for reproducibility
    random.seed(0)
    # Boundary tests
    t = """1 1 1 1
    5
    6
    7
    8
    0
    0
    0
    """.split()
    assert solve_tokens(t) == "26"
    # Random cross-checks
    for _ in range(50):
        n1 = random.randint(1, 3)
        n2 = random.randint(1, 3)
        n3 = random.randint(1, 3)
        n4 = random.randint(1, 3)
        tokens = gen_case(n1,n2,n3,n4,p=0.4)
        fast = solve_tokens(tokens)
        slow = solve_tokens_naive(tokens)
        assert fast == slow, (fast, slow, tokens)
    print("Reference OK")

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution (same API as CF expects) with asserts gated by empty stdin.
import sys
from typing import List

INF = 10**19

class SegMin:
    __slots__ = ("n","size","seg")
    def __init__(self, arr: List[int]) -> None:
        self.n = len(arr)
        size = 1
        while size < self.n:
            size <<= 1
        self.size = size
        self.seg = [INF] * (2 * size)
        for i, v in enumerate(arr):
            self.seg[size + i] = v
        for i in range(size - 1, 0, -1):
            l = self.seg[i << 1]; r = self.seg[i << 1 | 1]
            self.seg[i] = l if l < r else r
    def set(self, idx: int, val: int) -> None:
        p = self.size + idx
        self.seg[p] = val
        p >>= 1
        while p:
            l = self.seg[p << 1]; r = self.seg[p << 1 | 1]
            self.seg[p] = l if l < r else r
            p >>= 1
    def all_min(self) -> int:
        return self.seg[1] if self.size > 0 else INF

def read_input(tokens: List[str]):
    it = iter(tokens)
    n1 = int(next(it)); n2 = int(next(it)); n3 = int(next(it)); n4 = int(next(it))
    a = [int(next(it)) for _ in range(n1)]
    b = [int(next(it)) for _ in range(n2)]
    c = [int(next(it)) for _ in range(n3)]
    d = [int(next(it)) for _ in range(n4)]
    m1 = int(next(it))
    ban_ab = [[] for _ in range(n1)]
    for _ in range(m1):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_ab[x].append(y)
    m2 = int(next(it))
    ban_bc = [[] for _ in range(n2)]
    for _ in range(m2):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_bc[x].append(y)
    m3 = int(next(it))
    ban_cd = [[] for _ in range(n3)]
    for _ in range(m3):
        x = int(next(it)) - 1; y = int(next(it)) - 1
        ban_cd[x].append(y)
    return n1, n2, n3, n4, a, b, c, d, ban_ab, ban_bc, ban_cd

def compute_prev(cost_left: List[int], banned: List[List[int]], dp_right: List[int]) -> List[int]:
    seg = SegMin(dp_right)
    res = [INF] * len(cost_left)
    for i, base in enumerate(cost_left):
        for j in banned[i]:
            seg.set(j, INF)
        mn = seg.all_min()
        res[i] = INF if mn >= INF // 2 else base + mn
        for j in banned[i]:
            seg.set(j, dp_right[j])
    return res

def solve_all(tokens: List[str]) -> str:
    n1, n2, n3, n4, a, b, c, d, ban_ab, ban_bc, ban_cd = read_input(tokens)
    dp4 = d[:]
    dp3 = compute_prev(c, ban_cd, dp4)
    dp2 = compute_prev(b, ban_bc, dp3)
    dp1 = compute_prev(a, ban_ab, dp2)
    ans = min(dp1) if dp1 else INF
    return str(-1 if ans >= INF // 2 else ans)

def main():
    data = sys.stdin.read().strip().split()
    if not data:
        # Minimal tests
        t = """1 1 1 1
        5
        6
        7
        8
        0
        0
        0
        """.split()
        assert solve_all(t) == "26"
        t = """1 1 1 1
        1
        2
        3
        4
        1
        1 1
        0
        0
        """.split()
        assert solve_all(t) == "-1"
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Backward DP over layers with temporary exclusion via a min-segment tree.}
\WHY{Common pattern in interviews/contests: find min over allowed set with per-query forbidden indices.}
\CHECKLIST{%
\begin{bullets}
\item Read arrays and banned pairs; convert to zero-based indices.
\item Initialize $dp$ on desserts.
\item For each transition, build segment tree on next-layer $dp$.
\item For each current node, set banned leaves to $+\infty$, query root, restore leaves.
\item If final minimum is $+\infty$, output $-1$; else output the minimum.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item A layer item has all neighbors forbidden or $+\infty$ next-layer costs.
\item $m_i=0$ for some or all layers.
\item Multiple bans to the same neighbor (duplicates) — do not double-exclude.
\item Large costs: avoid overflow; use 64-bit integers ($\le 4\cdot 10^8$ fits easily).
\item Single-element layers ($n_i=1$).
\item Entire layer becomes impossible ($dp$ all $+\infty$).
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to restore segment tree leaves after a node — corrupts later queries.
\item Mixing 1-based input indices with 0-based arrays.
\item Using a heap with temporary deletions without proper lazy-restore — leads to incorrect pops.
\item Using $+\infty$ that can overflow when added; pick a safe sentinel like $10^{19}$.
\item Building one tree and mutating it across transitions instead of rebuilding per layer.
\item Time blow-up from naive per-node full scans on large inputs.
\end{bullets}
}
\FAILMODES{Naive scanning across all right-layer nodes per left node ($O(n_L n_R)$) times three transitions will time out at $1.5\cdot 10^5$ scale. Heap-with-deletions approaches that pop temporarily-removed items produce wrong answers; segment tree avoids this by reversible point updates.}
\ELI{Start from desserts and add one course at a time, always picking the cheapest next item that is not forbidden. A segment tree lets us temporarily hide forbidden choices and read the best allowed price instantly.}
\NotePages{3}

\end{document}