% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Armor and Weapons}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1612/F}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{Monocarp plays a computer game. There are $n$ different sets of armor and $m$ different weapons in this game. If a character equips the $i$-th set of armor and wields the $j$-th weapon, their power is usually equal to $i + j$; but some combinations of armor and weapons synergize well. Formally, there is a list of $q$ ordered pairs, and if the pair $(i, j)$ belongs to this list, the power of the character equipped with the $i$-th set of armor and wielding the $j$-th weapon is not $i + j$, but $i + j + 1$.

Initially, Monocarp's character has got only the $1$-st armor set and the $1$-st weapon. Monocarp can obtain a new weapon or a new set of armor in one hour. If he wants to obtain the $k$-th armor set or the $k$-th weapon, he must possess a combination of an armor set and a weapon that gets his power to $k$ or greater. Of course, after Monocarp obtains a weapon or an armor set, he can use it to obtain new armor sets or weapons, but he can go with any of the older armor sets and/or weapons as well.

Monocarp wants to obtain the $n$-th armor set and the $m$-th weapon. What is the minimum number of hours he has to spend on it?

Input:
The first line contains two integers $n$ and $m$ ($2 \le n, m \le 2 \cdot 10^5$) — the number of armor sets and the number of weapons, respectively.

The second line contains one integer $q$ ($0 \le q \le \min(2 \cdot 10^5, nm)$) — the number of combinations that synergize well.

Then $q$ lines follow, the $i$-th line contains two integers $a_i$ and $b_i$ ($1 \le a_i \le n$; $1 \le b_i \le m$) meaning that the $a_i$-th armor set synergizes well with the $b_i$-th weapon. All pairs $(a_i, b_i)$ are distinct.

Output:
Print one integer — the minimum number of hours Monocarp has to spend to obtain both the $n$-th armor set and the $m$-th weapon.

Note:
In the first example, Monocarp can obtain the strongest armor set and the strongest weapon as follows:

1. Obtain the $2$-nd weapon using the $1$-st armor set and the $1$-st weapon;
2. Obtain the $3$-rd armor set using the $1$-st armor set and the $2$-nd weapon;
3. Obtain the $4$-th weapon using the $3$-rd armor set and the $2$-nd weapon.

In the second example, Monocarp can obtain the strongest armor set and the strongest weapon as follows:

1. Obtain the $3$-rd armor set using the $1$-st armor set and the $1$-st weapon (they synergize well, so Monocarp's power is not $2$ but $3$);
2. Obtain the $4$-th weapon using the $3$-rd armor set and the $1$-st weapon.}
\BREAKDOWN{Model the process as growing the maximum owned armor index $a$ and weapon index $b$, where in each hour you may buy one new item whose index is at most your current power. A pair $(i,j)$ listed as synergistic grants $+1$ extra power only when using exactly that pair. We need the minimal hours to have both $n$ and $m$ owned.}
\ELI{Keep two numbers: best armor and best weapon you own; each hour you can buy any item up to your current power, which is the sum of those two, plus one if that exact pair synergizes.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m$ with $2 \le n, m \le 2\cdot 10^5$. Integer $q$ with $0 \le q \le \min(2\cdot 10^5, nm)$. Then $q$ distinct pairs $(a_i, b_i)$ with $1 \le a_i \le n$, $1 \le b_i \le m$.}
\OUTPUTS{One integer: the minimal number of hours to have both the $n$-th armor and the $m$-th weapon.}
\SAMPLES{Example 1 (custom): $n=3, m=3, q=1$ with pair $(1,1)$. Starting power is $1+1+1=3$, so in two hours we can buy armor $3$ and weapon $3$. Answer: $2$. Example 2 (custom): $n=4, m=4, q=0$. No synergy. Starting $(1,1)$, each hour you can buy any item of index at most $2$, then $3$, then $4$. Minimal steps: $4-1 + 4-1 = 6$ is not correct because you can interleave; the optimal sequence reaches both in $5$ hours.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A$ be the set of owned armor indices and $B$ the set of owned weapon indices. Define $s_{ij} \in \{0,1\}$ for synergy list. The instantaneous power is
\begin{BreakableEquation*}
R(A,B) = \max_{i\in A,\,j\in B} \left(i + j + s_{ij}\right).
\end{BreakableEquation*}
Each step you may add one element to either $A$ or $B$, provided its index $k \le R(A,B)$. Initially $A=B=\{1\}$. Goal: reach $n\in A$ and $m\in B$ with minimal steps.}
\varmapStart
\var{n,m}{target maximal indices for armor and weapon}
\var{q}{number of synergistic pairs}
\var{s_{ij}}{indicator of synergy for pair $(i,j)$}
\var{a,b}{current maximal indices: $a=\max A$, $b=\max B$}
\var{R}{current power threshold}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
R(A,B)=\max_{i\in A,j\in B}(i+j+s_{ij})=\max A + \max B + s_{\max A,\max B}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{All purchases are permanent; indices are totally ordered; the only bonus over $i+j$ is a $+1$ and only for exactly the corner pair $(\max A,\max B)$.}
\INVARIANTS{
\begin{bullets}
\item Monotonicity: $a$ and $b$ are non-decreasing with steps.
\item Power corner: $R=a+b+s_{ab}$, where $s_{ab}=s_{a,b}$.
\item Feasibility: In one step you can buy any armor $k\le R$ or any weapon $k\le R$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Breadth-first search over states $(a,b)$; from $(a,b)$, compute $R=a+b+s_{ab}$ and connect to all $(a',b)$ with $a<a'\le\min(n,R)$ and all $(a,b')$ with $b<b'\le\min(m,R)$.}
\ASSUMPTIONS{Explicit state graph of size up to $n\cdot m$; suitable only for small $n,m$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize queue with $(1,1)$ at distance $0$; mark visited.
\item Pop $(a,b)$, compute $R=a+b+s_{ab}$; for all $a'$ in $(a,\min(n,R)]$, if $(a',b)$ unseen, push with distance $+1$; likewise for weapons.
\item Stop when $(n,m)$ is reached; return its distance.
\end{algosteps}
\COMPLEXITY{In worst case explores $O(nm)$ states and $O(nm(n+m))$ edges; not feasible for input limits, but correct.}
\[
\begin{aligned}
T(n,m) &\le O\big(nm + \sum_{(a,b)} (R-a + R-b)\big) \\
&\le O(nm(n+m)), \quad S(n,m)=O(nm).
\end{aligned}
\]
\CORRECTNESS{BFS over a unit-weight directed acyclic region yields minimal number of acquisitions; transitions match the rule that any item up to $R$ can be bought in one hour.}
\EDGECASES{No synergy ($q=0$); full synergy on $(n,m)$ only; synergy only at start $(1,1)$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from collections import deque

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return None
    q = int(next(it))
    syn = set()
    for _ in range(q):
        a = int(next(it)); b = int(next(it))
        syn.add((a, b))
    return n, m, syn

def solve_case(n, m, syn):
    # BFS over (a,b); WARNING: exponential for large inputs; baseline only.
    from math import inf
    dist = {}
    dq = deque()
    start = (1, 1)
    dist[start] = 0
    dq.append(start)
    while dq:
        a, b = dq.popleft()
        d = dist[(a, b)]
        if a == n and b == m:
            return d
        R = a + b + (1 if (a, b) in syn else 0)
        up_a = min(n, R)
        up_b = min(m, R)
        # Expand all a' in (a..up_a]
        for a2 in range(a + 1, up_a + 1):
            st = (a2, b)
            if st not in dist:
                dist[st] = d + 1
                dq.append(st)
        # Expand all b' in (b..up_b]
        for b2 in range(b + 1, up_b + 1):
            st = (a, b2)
            if st not in dist:
                dist[st] = d + 1
                dq.append(st)
    return -1

def solve_all(data: str):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, m, syn = parsed
    return str(solve_case(n, m, syn))

def _tiny_tests():
    # Custom small tests
    inp = "3 3\n1\n1 1\n"
    assert solve_all(inp) == "2"
    inp2 = "2 2\n0\n"
    # Start at (1,1), R=2 => can buy armor 2 in 1, then weapon 2 in 2 => 2 steps
    assert solve_all(inp2) == "2"
    inp3 = "3 4\n0\n"
    # One possible path: (1,1)->R=2 pick b=2, R=3 pick a=3, R=6 pick b=4 => 3 steps
    assert solve_all(inp3) == "3"

if __name__ == "__main__":
    _tiny_tests()
    # To integrate with CF, read from stdin:
    import sys
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
\end{minted}
\VALIDATION{Hand-check small $n,m\le 6$ cases; verify monotonicity; ensure synergy at $(1,1)$ yields immediate $+1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Corner-Jump BFS with Dominance Pruning}
\WHICHFORMULA{Instead of exploring all $a'$ and $b'$ up to $R$, jump only to the extreme corner on the chosen axis: $(\min(n,R), b)$ or $(a, \min(m,R))$. Maintain a visited set of pairs and prune dominated states: if we have already seen $(a',b')$ with $a'\ge a$ and $b'\ge b$ at no more cost, skip $(a,b)$.}
\ASSUMPTIONS{Jumping to the axis limit is never worse than picking intermediate values in that step; intermediate choices are only useful via future synergy, which is dominated by having larger $a$ or $b$ for power.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Use a standard BFS (unit costs) over states $(a,b)$ starting from $(1,1)$.
\item From $(a,b)$ compute $R=a+b+s_{ab}$; push the two neighbors $(\min(n,R), b)$ and $(a, \min(m,R))$ if unseen.
\item Maintain per-$a$ and per-$b$ best counterparts to prune dominated states quickly.
\end{algosteps}
\COMPLEXITY{Each state has at most $2$ outgoing edges; with pruning, the number of distinct $(a,b)$ processed is typically $O(n+m)$; time $O((n+m+q)\log(n+m))$ with set lookups, space $O(n+m+q)$.}
\[
\begin{aligned}
T &\approx O(K \log K), \quad K=\#\text{states processed}\ (\text{empirically }K\ll nm).
\end{aligned}
\]
\CORRECTNESS{BFS with unit edges returns minimal steps. Jumping to the extreme of the axis is safe by exchange: replacing a smaller purchase in a step by a larger one cannot reduce future power and does not block any future acquisition, since smaller indices remain purchasable later if ever strictly beneficial.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from collections import deque

def solve_case_corner(n, m, syn):
    target = (n, m)
    start = (1, 1)
    if start == target:
        return 0
    dist = {start: 0}
    q = deque([start])
    # Optional dominance pruning maps
    best_b_for_a = {1: 1}
    best_a_for_b = {1: 1}
    while q:
        a, b = q.popleft()
        d = dist[(a, b)]
        if (a, b) == target:
            return d
        R = a + b + (1 if (a, b) in syn else 0)
        na = min(n, R)
        nb = min(m, R)
        cand1 = (na, b)
        if cand1 not in dist:
            # prune if dominated by same a with bigger b already reached
            if best_b_for_a.get(na, -1) < b:
                best_b_for_a[na] = b
                dist[cand1] = d + 1
                q.append(cand1)
        cand2 = (a, nb)
        if cand2 not in dist:
            if best_a_for_b.get(nb, -1) < a:
                best_a_for_b[nb] = a
                dist[cand2] = d + 1
                q.append(cand2)
    return -1

def _tiny_tests_corner():
    syn = {(1,1)}
    assert solve_case_corner(3, 3, syn) == 2
    syn2 = set()
    assert solve_case_corner(3, 4, syn2) == 3
    assert solve_case_corner(2, 2, syn2) == 2

if __name__ == "__main__":
    _tiny_tests_corner()
\end{minted}
\VALIDATION{Compare with baseline on random small instances ($n,m\le 30$); ensure identical answers; verify edge cases $q=0$, single synergy at $(n,m)$, dense synergy near start.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Monotone Corner BFS with Exchange Argument}
\WHICHFORMULA{Use the key identity $R=a+b+s_{ab}$. In any optimal path, when buying on one axis at a state $(a,b)$, it is optimal to set that axis straight to $\min(R,\text{limit})$. Therefore each state has two successors: $(\min(n,R), b)$ and $(a, \min(m,R))$. Run BFS over these corner states with a hash set for the synergy pairs.}
\ASSUMPTIONS{Synergy bonus only at the corner; larger $a$ or $b$ never reduces future reachable sets in fewer steps; dominated states can be pruned.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pre-read all $q$ synergies into a hash set for $O(1)$ membership checks.
\item BFS from $(1,1)$; at each state compute $R=a+b+(1$ if $(a,b)$ synergizes$)$.
\item Push the two axis-limit neighbors if unseen; stop when reaching $(n,m)$.
\end{algosteps}
\OPTIMALITY{Exchange argument: If an optimal solution buys a value $x<R$ on an axis at some step, replace it by buying $R$ instead. The corner power in all subsequent steps weakly increases, and if some future step would need the smaller value to trigger synergy, it can be bought then without increasing total steps because the larger corner already did not reduce the power budget; hence the replacement is never worse. BFS on unit-weight edges gives the fewest steps.}
\COMPLEXITY{Each state has out-degree $2$; with monotonicity and pruning, the number of visited states is $O(n+m)$ in practice. Hash lookups over $q$ synergies are $O(1)$ expected.}
\[
\begin{aligned}
T &\approx O((n+m+q)),\quad S=O(n+m+q).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from collections import deque

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return None
    q = int(next(it))
    syn = set()
    for _ in range(q):
        a = int(next(it)); b = int(next(it))
        syn.add((a, b))
    return n, m, syn

def solve_case(n, m, syn):
    # Corner-jump BFS
    start = (1, 1)
    target = (n, m)
    if start == target:
        return 0
    dist = {start: 0}
    qd = deque([start])
    # Simple dominance maps to cut duplicates
    best_b_for_a = {1: 1}
    best_a_for_b = {1: 1}
    while qd:
        a, b = qd.popleft()
        d = dist[(a, b)]
        if (a, b) == target:
            return d
        R = a + b + (1 if (a, b) in syn else 0)
        na = min(n, R)
        nb = min(m, R)
        s1 = (na, b)
        if s1 not in dist:
            # prune dominated by same 'a' with higher 'b'
            if best_b_for_a.get(na, -1) < b:
                best_b_for_a[na] = b
                dist[s1] = d + 1
                qd.append(s1)
        s2 = (a, nb)
        if s2 not in dist:
            if best_a_for_b.get(nb, -1) < a:
                best_a_for_b[nb] = a
                dist[s2] = d + 1
                qd.append(s2)
    return -1

def solve_all(data: str):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, m, syn = parsed
    return str(solve_case(n, m, syn))

def _tests():
    # Exactly 3 asserts
    assert solve_all("3 3\n1\n1 1\n") == "2"
    assert solve_all("2 2\n0\n") == "2"
    # No synergy; (1,1)->R=2: buy b=2, R=3: buy a=3, R=5: buy b=4 => 3 steps
    assert solve_all("3 4\n0\n") == "3"

if __name__ == "__main__":
    _tests()
    import sys
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
\end{minted}
\VALIDATION{Three asserts included. Cross-check numerically with Approach A on random tiny instances to ensure identical answers under brute-force exploration.}
\RESULT{Minimal number of hours to own both the $n$-th armor and the $m$-th weapon. If multiple optimal sequences exist, any one is acceptable; the output is only the minimal count.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Property checks: monotonicity of $(a,b)$; bounds $0 \le$ answer $\le n+m$; agreement between baseline and final on small random tests. Edge tests include $q=0$, $q$ maximal, synergy at $(1,1)$ only, synergy at $(n,m)$ only.}
\LINE{CROSS-CHECKS}{Run both Approach A and C on randomly generated small cases ($n,m\le 25$, $q$ random) and assert equal answers.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial synergy sets: empty; only at corners; only along first row/column; dense random.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_case(n, m, q_seed):
    random.seed(q_seed)
    max_q = min(n*m, 2*10**5)
    q = min(max_q, (n*m)//3)
    pairs = set()
    while len(pairs) < q:
        a = random.randint(1, n)
        b = random.randint(1, m)
        pairs.add((a, b))
    return n, m, pairs

def brute(n, m, syn):
    # Baseline brute from Approach A for small sizes
    from collections import deque
    dist = {(1,1): 0}
    dq = deque([(1,1)])
    while dq:
        a,b = dq.popleft()
        d = dist[(a,b)]
        if (a,b)==(n,m):
            return d
        R = a + b + (1 if (a,b) in syn else 0)
        for a2 in range(a+1, min(n, R)+1):
            st = (a2, b)
            if st not in dist:
                dist[st] = d+1
                dq.append(st)
        for b2 in range(b+1, min(m, R)+1):
            st = (a, b2)
            if st not in dist:
                dist[st] = d+1
                dq.append(st)
    return -1

def final_solve(n, m, syn):
    from collections import deque
    start = (1,1); target = (n,m)
    dist = {start: 0}
    dq = deque([start])
    best_b_for_a = {1:1}; best_a_for_b = {1:1}
    while dq:
        a,b = dq.popleft()
        d = dist[(a,b)]
        if (a,b)==target:
            return d
        R = a + b + (1 if (a,b) in syn else 0)
        na, nb = min(n, R), min(m, R)
        s1 = (na, b)
        if s1 not in dist and best_b_for_a.get(na, -1) < b:
            best_b_for_a[na] = b
            dist[s1] = d+1
            dq.append(s1)
        s2 = (a, nb)
        if s2 not in dist and best_a_for_b.get(nb, -1) < a:
            best_a_for_b[nb] = a
            dist[s2] = d+1
            dq.append(s2)
    return -1

def _self_check():
    # Cross-check on tiny sizes
    for n in range(2, 8):
        for m in range(2, 8):
            # try a few random q
            import itertools
            from random import sample
            all_pairs = [(i,j) for i in range(1,n+1) for j in range(1,m+1)]
            for t in [0, 1, 3, min(5, len(all_pairs))]:
                pairs = set(sample(all_pairs, t))
                b = brute(n, m, pairs)
                f = final_solve(n, m, pairs)
                assert b == f, (n, m, t, b, f)

if __name__ == "__main__":
    _self_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from collections import deque

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return None
    q = int(next(it))
    syn = set()
    for _ in range(q):
        a = int(next(it)); b = int(next(it))
        syn.add((a, b))
    return n, m, syn

def solve_case(n, m, syn):
    start = (1, 1)
    target = (n, m)
    if start == target:
        return 0
    dist = {start: 0}
    dq = deque([start])
    best_b_for_a = {1: 1}
    best_a_for_b = {1: 1}
    while dq:
        a, b = dq.popleft()
        d = dist[(a, b)]
        if (a, b) == target:
            return d
        R = a + b + (1 if (a, b) in syn else 0)
        na = min(n, R)
        nb = min(m, R)
        s1 = (na, b)
        if s1 not in dist and best_b_for_a.get(na, -1) < b:
            best_b_for_a[na] = b
            dist[s1] = d + 1
            dq.append(s1)
        s2 = (a, nb)
        if s2 not in dist and best_a_for_b.get(nb, -1) < a:
            best_a_for_b[nb] = a
            dist[s2] = d + 1
            dq.append(s2)
    return -1

def solve_all(data: str):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, m, syn = parsed
    return str(solve_case(n, m, syn))

def _unit():
    assert solve_all("3 3\n1\n1 1\n") == "2"
    assert solve_all("2 2\n0\n") == "2"
    assert solve_all("3 4\n0\n") == "3"

if __name__ == "__main__":
    _unit()
    import sys
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{At each step your power equals $a+b$ plus $1$ exactly if the top-right corner pair $(a,b)$ synergizes; choose whether to expand $a$ or $b$ up to that power.}
\WHY{This pattern appears in problems where progress depends on two coupled monotone resources and a sparse set of bonus edges.}
\CHECKLIST{
\begin{bullets}
\item Compute $R=a+b+s_{ab}$ correctly.
\item Clamp to bounds: $a\le n$, $b\le m$.
\item Use hash set for synergy lookup.
\item BFS with two successors per state.
\item Prune dominated states to avoid blow-up.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $q=0$ (no synergy) — pure $a+b$ growth.
\item Synergy only at $(1,1)$ — strong start burst.
\item Synergy only at $(n,m)$ — final step bonus.
\item Long skinny dimensions: $n\gg m$ or $m\gg n$.
\item Repeated $R$ equal to current $a$ or $b$ — no progress unless switching axis.
\item Dense synergies along one row or column.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Misusing synergy off the corner pair; only $(a,b)$ matters for $+1$.
\item Forgetting to cap $R$ by $n$ or $m$ when assigning next $a$ or $b$.
\item Infinite loops if you enqueue states without checking progress (when $R=a$ and $R=b$).
\item Memory blow-up if exploring all $(a',b)$ and $(a,b')$ instead of corner jumps.
\item Hashing pairs incorrectly (use tuple keys).
\item Assuming you can buy multiple items per hour (you cannot).
\end{bullets}
}
\FAILMODES{The naive expansion of all items up to $R$ per step leads to $O(nm(n+m))$ time and fails for large constraints. The corner-jump BFS with pruning avoids this by restricting to two successors and using dominance maps.}
\ELI{Track your best armor and weapon. Each hour, your budget is their sum, plus one if that exact pair is on a special list. Spend the hour to upgrade either armor or weapon straight to your budget. Repeat until both hit the targets.}
\NotePages{3}

\end{document}