% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Strongly Connected Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/913/F}}
\LINE{DIFFICULTY / RATING}{2800}
\STATEMENT{There is a chess tournament in All-Right-City. $n$ players were invited to take part in the competition. The tournament is held by the following rules:

1. Initially, each player plays one game with every other player. There are no ties;
2. After that, the organizers build a complete directed graph with players as vertices. For every pair of players there is exactly one directed edge between them: the winner of their game is the startpoint of this edge and the loser is the endpoint;
3. After that, the organizers build a condensation of this graph. The condensation of this graph is an acyclic complete graph, therefore it has the only Hamiltonian path which consists of strongly connected components of initial graph $A_{1}\to A_{2}\to \ldots \to A_{k}$.
4. The players from the first component $A_{1}$ are placed on the first $|A_{1}|$ places, the players from the component $A_{2}$ are placed on the next $|A_{2}|$ places, and so on.
5. To determine exact place of each player in a strongly connected component, all the procedures from 1 to 5 are repeated recursively inside each component, i.e. for every $i=1,2,\ldots,k$ players from the component $A_{i}$ play games with each other again, and so on;
6. If a component consists of a single player, then he has no more rivals, his place is already determined and the process stops.

The players are enumerated with integers from $1$ to $n$. The enumeration was made using results of a previous tournament. It is known that player $i$ wins player $j$ ($i<j$) with probability $p$.

You need to help to organize the tournament. Find the expected value of total number of games played by all the players.

It can be shown that the answer can be represented as $\tfrac{P}{Q}$, where $P$ and $Q$ are coprime integers and $Q \not\equiv 0 \pmod{998244353}$. Print the value of $P\cdot Q^{-1}$ modulo $998{,}244{,}353$.

If you are not familiar with any of the terms above, you can read about them here.

Input:
The first line of input contains a single integer $n$ ($2 \le n \le 2000$) — the number of players.

The second line contains two integers $a$ and $b$ ($1 \le a < b \le 100$) — the numerator and the denominator of fraction $\tfrac{a}{b} = p$.

Output:
In the only line print the expected value of total number of games played by all the players. Print the answer using the format above.

Note:
In the first example the expected value is $4$.

In the second example the expected value is $\tfrac{27}{7}$.

In the third example the expected value is $\tfrac{56}{5}$.}
\BREAKDOWN{Compute the expected total number of games over a recursive process on random tournaments with bias $p$ for edges from lower to higher index. Reduce to summing, over unordered pairs, their expected number of replays, which forms a geometric series once the probability of staying in the same strongly connected component is known as a function of the distance. Precompute these probabilities via a recurrence over sizes.}
\ELI{Each pair keeps replaying while they stay in the same strongly connected component; the chance they stick together depends only on how many players lie between them and can be computed by dynamic programming.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integer $n$ with $2\le n\le 2000$.
- Integers $a,b$ with $1\le a<b\le 100$, representing $p=\tfrac{a}{b}$.}
\OUTPUTS{One integer: the expected total number of games as a rational modulo $998{,}244{,}353$, i.e., $P\cdot Q^{-1}\bmod 998{,}244{,}353$.}
\SAMPLES{Examples (illustrative):
- Input: $n=2$, $p=\tfrac{1}{2}$ $\to$ Output: $1$.
- Input: $n=3$, $p=\tfrac{1}{1}$ $\to$ Output: $3$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let vertices be $1,2,\ldots,n$. For each ordered pair $(i,j)$ with $i<j$, orient the edge $i\to j$ with probability $p$ and $j\to i$ with probability $1-p$, independently across pairs. Process recursively: on a set $S$ of size $m$, play all $\binom{m}{2}$ games (orient edges), compute strongly connected components (SCCs), then recurse on each SCC independently with fresh randomness. The objective is $\mathbb{E}[\text{total games}]$.}
\varmapStart
\var{n}{number of players}
\var{p}{win probability for $i<j$}
\var{s_m}{probability that a $p$-biased tournament on $m$ vertices is strongly connected}
\var{E(n)}{expected total number of games for $n$ players}
\var{d}{distance $j-i$ between two indices}
\var{\bar p}{shorthand for $1-p$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{For }m\ge 2:\quad s_m \;=\; 1 - \sum_{k=1}^{m-1} s_k \binom{m-2}{k-1}\,\Big(p^{k(m-k)} + \bar p^{\,k(m-k)}\Big),\qquad s_1=1.\\[4pt]
&\text{Expected replays for a pair at distance }d=m-1:\quad \frac{1}{1-s_m}.\\[4pt]
&E(n)\;=\;\sum_{m=2}^{n} (n-m+1)\cdot \frac{1}{1-s_m}.
\end{aligned}
\]
}
\ASSUMPTIONS{Edges across different pairs are independent. The SCCs of the biased tournament decompose the vertex set along index cuts where all cross edges align in one direction; thus, for endpoints at distance $d$, the event of sticking together at a level depends only on $m=d+1$.}
\INVARIANTS{At each recursion level, every component contributes exactly $\binom{|C|}{2}$ games. The process terminates almost surely as components shrink to singletons.}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct simulation or enumeration of all tournaments to average total games.}
\ASSUMPTIONS{Feasible only for very small $n$ (e.g., $n\le 7$) due to $2^{\Theta(n^2)}$ orientation space.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate all edge orientations (or many Monte Carlo samples).
\item For each orientation, compute SCC condensation and recursively count games.
\item Average the totals; convert to modular rational.
\end{algosteps}
\COMPLEXITY{Exponential in $n$; even Monte Carlo is too slow and produces non-deterministic results.}
\[
\begin{aligned}
T(n) &= \Theta\!\big(2^{\binom{n}{2}}\cdot n^2\big)\ \text{(enumeration)} \\
     &\text{or large for Monte Carlo with accuracy guarantees.}
\end{aligned}
\]
\CORRECTNESS{By definition, averaging over all orientations yields the expected value.}
\EDGECASES{Trivial extremes $p=0$ or $p=1$ collapse to a DAG with singleton SCCs.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline illustrative code: tiny-n exhaustive simulation to estimate E(n).
# Not for production; deterministic and with asserts for n<=5 only.

from itertools import combinations
from collections import defaultdict, deque

MOD = 998244353

def inv_mod(x): return pow(x, MOD-2, MOD)

def enumerate_orientations(n):
    # Orient edges in lex order between pairs (i<j); represent orientation bitmask.
    pairs = [(i, j) for i in range(n) for j in range(i+1, n)]
    m = len(pairs)
    for mask in range(1 << m):
        # Build adjacency list: edge i->j if bit is 1 else j->i
        g = [[] for _ in range(n)]
        for b, (i, j) in enumerate(pairs):
            if (mask >> b) & 1:
                g[i].append(j)
            else:
                g[j].append(i)
        yield g

def scc_kosaraju(g):
    n = len(g)
    rg = [[] for _ in range(n)]
    for u in range(n):
        for v in g[u]:
            rg[v].append(u)
    vis = [False]*n
    order = []
    def dfs(u):
        vis[u] = True
        for v in g[u]:
            if not vis[v]:
                dfs(v)
        order.append(u)
    for u in range(n):
        if not vis[u]:
            dfs(u)
    comp = [-1]*n
    def rdfs(u, cid):
        comp[u] = cid
        for v in rg[u]:
            if comp[v] == -1:
                rdfs(v, cid)
    cid = 0
    for u in reversed(order):
        if comp[u] == -1:
            rdfs(u, cid)
            cid += 1
    comps = [[] for _ in range(cid)]
    for u, c in enumerate(comp):
        comps[c].append(u)
    return comps

def total_games_recursive(players):
    # players: list of vertex ids; play all-vs-all once, then recurse per SCC
    m = len(players)
    if m <= 1: return 0
    # enumerate_orientations constructs graphs on 0..m-1; we need a separate sampler per call,
    # but for exhaustive tiny baseline we just return the direct combinatorial count for a fixed g.
    # This routine is not used in exhaustive enumeration; we inline counting there.
    return 0

def expected_games_exhaustive(n, p_num, p_den):
    # Exact expectation by enumerating all orientations with unbiased weights (for tiny n).
    # Here we treat p=1/2 only to keep deterministic rational averaging for asserts.
    assert p_num*2 == p_den, "baseline only supports p=1/2 in asserts"
    total = 0
    W = 0
    for g in enumerate_orientations(n):
        # total games = sum over recursion: at each node, C(m,2)
        # Simulate recursion deterministically for this orientation, then repeat inside SCCs with SAME orientation?
        # For baseline, we only count top-level C(n,2) because recursing needs fresh randomness;
        # this code is illustrative and not used for final answer.
        total += n*(n-1)//2
        W += 1
    # Expected equals top-level games when p in {0,1}; for p=1/2 it's >= C(n,2); return baseline part only.
    return total // W

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data: return None
    it = iter(data)
    n = int(next(it))
    a = int(next(it)); b = int(next(it))
    return n, a, b

def main():
    # Demonstration with tiny assert
    assert expected_games_exhaustive(2, 1, 2) == 1
    # No I/O in baseline main
    pass

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Tiny checks: for $n=2$, expectation is exactly $1$ for any $p$. For $p\in\{0,1\}$, the process has no recursion and returns $\binom{n}{2}$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Distance-Only Reduction}
\WHICHFORMULA{Pairs replay geometrically while they remain in the same SCC; for a fixed distance $d$, this occurs with a probability depending only on $m=d+1$. Thus, expected replays per pair at distance $d$ equals $\tfrac{1}{1-s_m}$.}
\ASSUMPTIONS{SCC boundaries align with index cuts that have unidirectional cross edges; hence, for endpoints at distance $d$, the stick-together probability is a function of $m=d+1$ only.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $s_m$ for all $2\le m\le n$ via a recurrence.
\item For each $m$, add $(n-m+1)\cdot (1-s_m)^{-1}$ to the answer.
\item All arithmetic is done modulo $998{,}244{,}353$ by mapping $p=\tfrac{a}{b}$ into the field.
\end{algosteps}
\COMPLEXITY{The DP over $m$ and $k$ runs in $O(n^2)$ field operations. Precomputations of powers and binomials are $O(n^2)$ and $O(n)$ respectively.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\quad S(n)=\Theta(n^2) \text{ for power tables.}
\end{aligned}
\]
\CORRECTNESS{Linearity of expectation lets us sum over distances. The geometric series holds by independence across levels and the stick probability depending only on $m$. The recurrence for $s_m$ counts complements where a first component of size $k$ appears on either end, with cross edges uniformly oriented, times $s_k$ for internal strong connectivity.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Distance-only DP; same API as final; includes sanity asserts.

MOD = 998244353

def inv_mod(x): return pow(x, MOD-2, MOD)

def precompute_fact(n):
    fact = [1]*(n+1)
    invfact = [1]*(n+1)
    for i in range(1, n+1): fact[i] = fact[i-1]*i % MOD
    invfact[n] = inv_mod(fact[n])
    for i in range(n, 0, -1): invfact[i-1] = invfact[i]*i % MOD
    return fact, invfact

def nCk(n, k, fact, invfact):
    if k < 0 or k > n: return 0
    return fact[n]*invfact[k]%MOD*invfact[n-k]%MOD

def solve_one(n, a, b):
    p = a * inv_mod(b) % MOD
    q = (1 - p) % MOD
    maxE = (n*n)//4 + 5
    p_pow = [1]*(maxE+1)
    q_pow = [1]*(maxE+1)
    for i in range(1, maxE+1):
        p_pow[i] = p_pow[i-1]*p % MOD
        q_pow[i] = q_pow[i-1]*q % MOD
    fact, invfact = precompute_fact(n)
    s = [0]*(n+1)
    s[1] = 1
    for m in range(2, n+1):
        acc = 0
        for k in range(1, m):
            e = k*(m-k)
            comb = nCk(m-2, k-1, fact, invfact)
            acc = (acc + s[k]*comb % MOD * ((p_pow[e] + q_pow[e]) % MOD)) % MOD
        s[m] = (1 - acc) % MOD
    ans = 0
    for m in range(2, n+1):
        denom = (1 - s[m]) % MOD
        ans = (ans + (n - m + 1) * inv_mod(denom)) % MOD
    return ans

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data: return None
    it = iter(data)
    n = int(next(it)); a = int(next(it)); b = int(next(it))
    return n, a, b

def main():
    # basic sanity asserts
    for n in range(2, 6):
        # p=1 => only top-level games
        got = solve_one(n, 1, 1)
        want = n*(n-1)//2 % MOD
        assert got == want, (n, got, want)
        # p=0 => only top-level games
        got = solve_one(n, 0, 1)
        want = n*(n-1)//2 % MOD
        assert got == want, (n, got, want)
    # n=2, any p => 1 game
    assert solve_one(2, 1, 2) == 1

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks extremes $p\in\{0,1\}$ give exactly $\binom{n}{2}$, and $n=2$ yields $1$ for any $p$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{DP for $s_m$ and Geometric Summation}
\WHICHFORMULA{Compute $s_m$ via the recurrence
\begin{BreakableEquation*}
s_m \;=\; 1 - \sum_{k=1}^{m-1} s_k \binom{m-2}{k-1}\,\Big(p^{k(m-k)} + (1-p)^{k(m-k)}\Big),
\end{BreakableEquation*}
then sum expected replays per distance: $\sum_{m=2}^{n} (n-m+1)\cdot (1-s_m)^{-1}$.}
\ASSUMPTIONS{Edges are independent; SCC boundaries occur at index cuts with uniform cross-edge orientation; recursive levels are i.i.d., so the number of replays for a pair is geometric with parameter $1-s_m$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Map $p=\tfrac{a}{b}$ to the field $\mathbb{F}_{998244353}$ via modular inverse.
\item Precompute factorials/inverses up to $n$ for binomials, and arrays of $p^e$ and $(1-p)^e$ for all exponents $e\le \lfloor n^2/4\rfloor$.
\item Fill $s[1..n]$ using the DP; each state uses $O(m)$ work, total $O(n^2)$.
\item Accumulate $\sum_{m=2}^{n} (n-m+1)\cdot (1-s_m)^{-1}$ and print it.
\end{algosteps}
\OPTIMALITY{$O(n^2)$ arithmetic is near-optimal for computing all $s_m$ up to $n$. Memory $O(n^2)$ (for power tables) is acceptable at $n\le 2000$.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= \Theta(n^2) \text{ modular ops},\\
S(n) &= \Theta(n^2) \text{ for power tables } + \Theta(n) \text{ for factorials}.
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

MOD = 998244353

def inv_mod(x): return pow(x, MOD-2, MOD)

def precompute_fact(n):
    fact = [1]*(n+1)
    invfact = [1]*(n+1)
    for i in range(1, n+1):
        fact[i] = fact[i-1]*i % MOD
    invfact[n] = inv_mod(fact[n])
    for i in range(n, 0, -1):
        invfact[i-1] = invfact[i]*i % MOD
    return fact, invfact

def nCk(n, k, fact, invfact):
    if k < 0 or k > n: return 0
    return fact[n]*invfact[k]%MOD*invfact[n-k]%MOD

def solve_all(n, a, b):
    p = a * inv_mod(b) % MOD
    q = (1 - p) % MOD
    # Max cross-edge exponent across all m and k
    maxE = (n*n)//4 + 5
    p_pow = [1]*(maxE+1)
    q_pow = [1]*(maxE+1)
    for i in range(1, maxE+1):
        p_pow[i] = p_pow[i-1]*p % MOD
        q_pow[i] = q_pow[i-1]*q % MOD
    fact, invfact = precompute_fact(n)
    s = [0]*(n+1)
    s[1] = 1
    for m in range(2, n+1):
        acc = 0
        for k in range(1, m):
            e = k*(m-k)
            comb = nCk(m-2, k-1, fact, invfact)
            acc = (acc + s[k]*comb % MOD * ((p_pow[e] + q_pow[e]) % MOD)) % MOD
        s[m] = (1 - acc) % MOD
    ans = 0
    for m in range(2, n+1):
        denom = (1 - s[m]) % MOD
        ans = (ans + (n - m + 1) * inv_mod(denom)) % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data: return None
    it = iter(data)
    n = int(next(it)); a = int(next(it)); b = int(next(it))
    return n, a, b

def main():
    # Self-checks
    for n in range(2, 8):
        # p=1 => only top-level games
        got = solve_all(n, 1, 1)
        want = n*(n-1)//2 % MOD
        assert got == want, ("p=1", n, got, want)
        # p=0 => only top-level games
        got = solve_all(n, 0, 1)
        want = n*(n-1)//2 % MOD
        assert got == want, ("p=0", n, got, want)
    assert solve_all(2, 1, 2) == 1
    # I/O
    args = read_input()
    if args is not None:
        n, a, b = args
        print(solve_all(n, a, b))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts:
- For all $2\le n\le 7$, $p=1$ gives $\binom{n}{2}$.
- For all $2\le n\le 7$, $p=0$ gives $\binom{n}{2}$.
- For $n=2$, $p=\tfrac12$ gives $1$.}
\RESULT{Print $E(n)$ modulo $998{,}244{,}353$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify extremes $p\in\{0,1\}$ and tiny $n$; random spot-checks ensure finiteness and stability.}
\LINE{CROSS-CHECKS}{Compare Approach B and C outputs on identical inputs (same DP). For $n=2$, compare against the trivial $1$.}
\LINE{EDGE-CASE GENERATOR}{Generate $(n,p)$ with $n\in\{2,3,4,5\}$ and $p\in\{\tfrac{0}{1},\tfrac{1}{2},\tfrac{1}{1}\}$, covering minimal sizes and extreme biases.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    cases = []
    for n in range(2, 8):
        for a, b in [(0,1),(1,2),(1,1)]:
            cases.append((n,a,b))
    return cases

def run_reference():
    for (n,a,b) in gen_cases():
        print(n, a, b)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final single-solve reference matching the CF-style input/output.
import sys

MOD = 998244353
def inv_mod(x): return pow(x, MOD-2, MOD)

def precompute_fact(n):
    fact = [1]*(n+1)
    invfact = [1]*(n+1)
    for i in range(1, n+1):
        fact[i] = fact[i-1]*i % MOD
    invfact[n] = inv_mod(fact[n])
    for i in range(n, 0, -1):
        invfact[i-1] = invfact[i]*i % MOD
    return fact, invfact

def nCk(n, k, fact, invfact):
    if k < 0 or k > n: return 0
    return fact[n]*invfact[k]%MOD*invfact[n-k]%MOD

def solve_all(n, a, b):
    p = a * inv_mod(b) % MOD
    q = (1 - p) % MOD
    maxE = (n*n)//4 + 5
    p_pow = [1]*(maxE+1)
    q_pow = [1]*(maxE+1)
    for i in range(1, maxE+1):
        p_pow[i] = p_pow[i-1]*p % MOD
        q_pow[i] = q_pow[i-1]*q % MOD
    fact, invfact = precompute_fact(n)
    s = [0]*(n+1)
    s[1] = 1
    for m in range(2, n+1):
        acc = 0
        for k in range(1, m):
            e = k*(m-k)
            comb = nCk(m-2, k-1, fact, invfact)
            acc = (acc + s[k]*comb % MOD * ((p_pow[e] + q_pow[e]) % MOD)) % MOD
        s[m] = (1 - acc) % MOD
    ans = 0
    for m in range(2, n+1):
        denom = (1 - s[m]) % MOD
        ans = (ans + (n - m + 1) * inv_mod(denom)) % MOD
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data: return None
    it = iter(data)
    n = int(next(it)); a = int(next(it)); b = int(next(it))
    return n, a, b

def main():
    # Asserts
    for n in range(2, 8):
        assert solve_all(n, 1, 1) == n*(n-1)//2 % MOD
        assert solve_all(n, 0, 1) == n*(n-1)//2 % MOD
    assert solve_all(2, 1, 2) == 1
    # I/O
    args = read_input()
    if args is not None:
        n, a, b = args
        print(solve_all(n, a, b))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute $s_m$ for all $m$ and sum $(n-m+1)\cdot(1-s_m)^{-1}$.}
\WHY{Tests the ability to model expected values via DP on random combinatorial structures and to handle modular probability arithmetic.}
\CHECKLIST{
- Map $p=\tfrac{a}{b}$ into the field via modular inverse.
- Precompute factorials and inverse factorials.
- Precompute $p^e$ and $(1-p)^e$ up to $\lfloor n^2/4\rfloor$.
- Fill $s_m$ bottom-up using the recurrence.
- Accumulate the geometric-sum contributions per distance.}
\EDGECASES{
- $p=0$ or $p=1$: answer is $\binom{n}{2}$.
- $n=2$: always $1$.
- Large $n$ near $2000$: ensure power tables sized to $\lfloor n^2/4\rfloor$.
- Modular negatives: normalize with $\bmod 998{,}244{,}353$.}
\PITFALLS{
- Using Python pow for every exponent repeatedly (too slow); instead precompute linear power tables.
- Forgetting $(m-2 \choose k-1)$ combinatorial factor.
- Off-by-one in distance: distance $d=m-1$ corresponds to $s_m$.
- Inverting zero: ensure denominator $(1-s_m)$ is nonzero in the field.
- Overflow if implemented in non-modular integers.}
\FAILMODES{A naive simulation cannot finish for $n\sim 2000$. A DP that recomputes pow per inner loop is too slow; precompute.}
\ELI{Pairs of players keep replaying as long as they stay in the same strongly connected group. The chance they stick together only depends on how many people sit between them, which we precompute, then add up over all possible distances.}
\NotePages{3}

\end{document}