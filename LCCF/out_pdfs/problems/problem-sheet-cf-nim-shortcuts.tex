% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Nim Shortcuts}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1458/E}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{After your debut mobile game ``Nim'' blew up, you decided to make a sequel called ``Nim 2''. This game will expand on the trusted Nim game formula, adding the much awaited second heap!

In the game, there are two heaps, each containing a non-negative number of stones. Two players make moves in turn. On their turn, a player can take any positive number of stones from either one of the heaps. A player who is unable to move loses the game.

To make the game easier to playtest, you've introduced developer shortcuts. There are $n$ shortcut positions $(x_1, y_1), \ldots, (x_n, y_n)$. These change the game as follows: suppose that before a player's turn the first and second heap contain $x$ and $y$ stones respectively. If the pair $(x, y)$ is equal to one of the pairs $(x_i, y_i)$, then the player about to move loses instantly, otherwise they are able to make moves as normal. Note that in the above explanation the two heaps and all pairs are ordered, that is, $x$ must refer to the size of the first heap, and $y$ must refer to the size of the second heap.

The game release was followed by too much celebration, and next thing you know is developer shortcuts made their way to the next official update of the game! Players now complain that the AI opponent has become unbeatable at certain stages of the game. You now have to write a program to figure out which of the given initial positions can be won by the starting player, assuming both players act optimally.

Input:
The first line contains two integers $n$ and $m$ ($1 \le n, m \le 10^5$) — the number of shortcut positions, and the number of initial positions that need to be evaluated.

The following $n$ lines describe shortcut positions. The $i$-th of these lines contains two integers $x_i, y_i$ ($0 \le x_i, y_i \le 10^9$). It is guaranteed that all shortcut positions are distinct.

The following $m$ lines describe initial positions. The $i$-th of these lines contains two integers $a_i, b_i$ ($0 \le a_i, b_i \le 10^9$) — the number of stones in the first and second heap respectively. It is guaranteed that all initial positions are distinct. However, initial positions are not necessarily distinct from shortcut positions.

Output:
For each initial position, on a separate line print ``WIN'' if the starting player is able to win from this position, and ``LOSE'' otherwise.}
\BREAKDOWN{We are on a DAG where a move decreases exactly one coordinate. In addition to the usual terminal $(0,0)$, there is a set of forbidden states where the player to move loses instantly. Compute the set of losing positions and classify given queries.}
\ELI{A position is losing iff there is no losing point to its left in the same row and none below in the same column; we can build all such points greedily via two synchronized minimal-excluded counters that skip forbidden columns/rows seen so far.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n,m$; then $n$ distinct forbidden pairs $(x_i,y_i)$ with $0 \le x_i,y_i \le 10^9$; then $m$ distinct queries $(a_i,b_i)$ with $0 \le a_i,b_i \le 10^9$.}
\OUTPUTS{For each query $(a,b)$ print LOSE iff $(a,b)$ is either a forbidden shortcut or a constructed losing position; otherwise print WIN. One answer per line.}
\SAMPLES{Example 1: $n=0,m=3$; queries $(0,0),(1,0),(1,1)$ outputs: LOSE, WIN, LOSE. Example 2: $n=2$ forbidden $(1,0),(0,1)$; queries $(1,1),(2,2),(2,1)$ outputs: WIN, LOSE, WIN.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $S\subseteq \mathbb{Z}_{\ge 0}^2$ be forbidden states. Legal moves from $(x,y)$ (if not forbidden) go to $(x',y)$ with $0\le x'<x$ or $(x,y')$ with $0\le y'<y$. Define losing set $\mathcal{L}$ by normal-play induction with base $(0,0)\in\mathcal{L}$ and $S\subseteq\mathcal{L}$ (instant loss states).}
\varmapStart
\var{S}{input set of forbidden pairs}
\var{\mathcal{L}}{set of losing positions}
\var{X_\mathrm{used}(t)}{columns that already contain a losing point with $y\le t$}
\var{Y_\mathrm{used}(t)}{rows that already contain a losing point with $x\le t$}
\var{f_X(t)}{mex $\ge t$ avoiding $X_\mathrm{used}$}
\var{f_Y(t)}{mex $\ge t$ avoiding $Y_\mathrm{used}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&(x,y)\in\mathcal{L}\iff (x,y)\in S\ \text{ or }\ \Big((x,y)\notin S\ \wedge\ \big[\forall x'<x,\ (x',y)\notin\mathcal{L}\big]\ \wedge\ \big[\forall y'<y,\ (x,y')\notin\mathcal{L}\big]\Big).\\
&\text{Greedy construction: starting at }(0,0),\ \text{repeatedly take }(x^\ast,y^\ast)=\big(f_X(y),\,f_Y(x)\big),\ \text{advance to it; }\\
&\text{if }(x^\ast,y^\ast)\in S\text{, record nothing (it's already losing); else add it to }\mathcal{L}.
\end{aligned}
\]
}
\ASSUMPTIONS{Coordinates are non-negative; $S$ is finite and distinct. The constructed sequence of non-forbidden losing points is strictly increasing in both coordinates.}
\INVARIANTS{(i) No two constructed losing points share the same $x$ or the same $y$. (ii) When at $(x,y)$, all forbidden with $y'\le y$ have their $x'$ blocked for future $f_X$, and all forbidden with $x'\le x$ have their $y'$ blocked for future $f_Y$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Dynamic programming on the finite rectangle $[0..X_{\max}]\times[0..Y_{\max}]$ where $X_{\max},Y_{\max}$ are maxima over inputs.}
\ASSUMPTIONS{Use only for tiny instances (e.g., maxima $\le 400$) to validate logic.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Mark $(0,0)$ and all $(x_i,y_i)\in S$ as losing.
\item For $x$ from $0$ to $X_{\max}$ and $y$ from $0$ to $Y_{\max}$ in increasing order of $x+y$, set $(x,y)$ losing iff it is not forbidden and there is no losing point left on row $y$ nor below on column $x$.
\item Answer queries by table lookup.
\end{algosteps}
\COMPLEXITY{Quadratic in the grid size.}
\[
\begin{aligned}
T &= \Theta\big((X_{\max}+1)(Y_{\max}+1)\big),\quad
S = \Theta\big((X_{\max}+1)(Y_{\max}+1)\big).
\end{aligned}
\]
\CORRECTNESS{Matches the inductive definition: options from $(x,y)$ are exactly its row-left and column-below cells.}
\EDGECASES{Includes $(0,0)$, queries that coincide with forbiddens, and empty $S$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Dict, Set

def brute_classify(Xmax: int, Ymax: int, forbidden: Set[Tuple[int,int]]) -> Set[Tuple[int,int]]:
    L = set()
    L.add((0,0))
    L |= (forbidden & {(x, y) for x in range(Xmax+1) for y in range(Ymax+1)})
    # Precompute for fast row/col checks
    row_has_L: List[Set[int]] = [set() for _ in range(Ymax+1)]
    col_has_L: List[Set[int]] = [set() for _ in range(Xmax+1)]
    row_has_L[0].add(0)
    col_has_L[0].add(0)
    for x in range(Xmax+1):
        for y in range(Ymax+1):
            if (x, y) in forbidden or (x, y) == (0,0):
                # ensure structures reflect losing
                row_has_L[y].add(x)
                col_has_L[x].add(y)
                continue
            # losing if no losing to the left in row y and no losing below in col x
            has_left_L = any(xp < x for xp in row_has_L[y])
            has_below_L = any(yp < y for yp in col_has_L[x])
            if (not has_left_L) and (not has_below_L):
                L.add((x, y))
                row_has_L[y].add(x)
                col_has_L[x].add(y)
    return L

# tiny self-checks for the brute method
def _test_brute():
    # No forbiddens: losing are exactly (k,k)
    L = brute_classify(5, 5, set())
    for k in range(6):
        assert (k, k) in L
    assert (1, 0) not in L and (0, 1) not in L
    # One forbidden
    F = {(1, 0)}
    L = brute_classify(5, 5, F)
    expect = {(0,0), (1,0), (2,1), (3,2), (4,3), (5,4)}
    for p in expect:
        assert p in L
    # Two symmetric forbiddens
    F = {(1,0), (0,1)}
    L = brute_classify(5, 5, F)
    expect = {(0,0), (1,0), (0,1), (2,2), (3,3), (4,4), (5,5)}
    for p in expect:
        assert p in L
_test_brute()
\end{minted}
\VALIDATION{The asserts check canonical diagonals without forbiddens and with simple forbiddens.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy Staircase via Two Coupled mex Counters}
\WHICHFORMULA{Track which columns (by $x$) already contain a losing point up to the current $y$, and which rows (by $y$) already contain a losing point up to the current $x$. The next non-forbidden losing point is the pair of minimal free $x$ and minimal free $y$.}
\ASSUMPTIONS{Maintain two dynamic ``taken'' sets with fast ``next free $\ge$ t'' (mex) using a disjoint-set successor map; sweep forbiddens by $x$ and $y$ to activate newly blocked rows/columns.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Store $S$ for membership; sort forbiddens by $y$ and by $x$.
\item Initialize current $(x,y)=(0,0)$; mark $x=0$ and $y=0$ as taken (because $(0,0)$ is losing).
\item Maintain indices that add to taken-$x$ all forbidden $x$ with $y'\le y$, and to taken-$y$ all forbidden $y$ with $x'\le x$.
\item Let $x^\ast$ be the mex $\ge x$ not in taken-$x$; let $y^\ast$ be the mex $\ge y$ not in taken-$y$.
\item If $(x^\ast,y^\ast)\in S$, advance to it (it is already losing); else record it as a constructed losing point and advance. Upon recording, also mark $x^\ast$ and $y^\ast$ as taken (they now host losing points).
\item Repeat until both coordinates exceed all query maxima.
\end{algosteps}
\COMPLEXITY{Let $Q$ be the number of constructed losing points generated up to query maxima. Each step does near-constant amortized work via successor-DSU.}
\[
\begin{aligned}
T &= \mathcal{O}\big((n+Q)\,\alpha(n+Q)\big),\quad S=\mathcal{O}(n+Q).
\end{aligned}
\]
\CORRECTNESS{By construction, a constructed losing point has no losing to its left in its row and none below in its column; conversely, any position satisfying that must coincide with the current pair of row/column mexes and is therefore generated unless forbidden (in which case it is already losing).}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Dict, Set

class MexSet:
    def __init__(self):
        # map v -> next candidate (successor), presence means "taken"
        self.nxt: Dict[int, int] = {}
    def take(self, v: int) -> None:
        if v not in self.nxt:
            self.nxt[v] = v + 1
    def mex_ge(self, v: int) -> int:
        # find smallest u >= v not taken; path-compress along the way
        path = []
        u = v
        while u in self.nxt:
            path.append(u)
            u = self.nxt[u]
        for t in path:
            self.nxt[t] = u
        return u

def generate_constructed_losing(S: Set[Tuple[int,int]], Xmax: int, Ymax: int) -> List[Tuple[int,int]]:
    # Sort forbiddens by y and by x
    by_y = sorted(S, key=lambda p: (p[1], p[0]))
    by_x = sorted(S, key=lambda p: (p[0], p[1]))
    iy = 0
    ix = 0
    takeX = MexSet()
    takeY = MexSet()
    # base (0,0) is losing
    takeX.take(0)
    takeY.take(0)
    cx, cy = 0, 0
    constructed: List[Tuple[int,int]] = []
    # Helper to activate forbiddens up to current sweep lines
    def activate():
        nonlocal iy, ix
        while iy < len(by_y) and by_y[iy][1] <= cy:
            takeX.take(by_y[iy][0])
            iy += 1
        while ix < len(by_x) and by_x[ix][0] <= cx:
            takeY.take(by_x[ix][1])
            ix += 1
    activate()
    # Generate until past query bounds
    while cx <= Xmax or cy <= Ymax:
        nx = takeX.mex_ge(cx)
        ny = takeY.mex_ge(cy)
        cx, cy = nx, ny
        if (cx, cy) in S:
            # forbidden losing; just advance sweep and activate; do not record
            activate()
            continue
        # constructed losing point
        constructed.append((cx, cy))
        takeX.take(cx)
        takeY.take(cy)
        activate()
    return constructed

def classify_positions(n: int, m: int, forb: List[Tuple[int,int]], queries: List[Tuple[int,int]]) -> List[str]:
    S = set(forb)
    Xmax = max([0] + [a for a, _ in queries])
    Ymax = max([0] + [b for _, b in queries])
    constructed = generate_constructed_losing(S, Xmax, Ymax)
    Lset = set(constructed)
    Lset.add((0, 0))
    # forbidden are losing as well
    Sset = S
    ans = []
    for a, b in queries:
        if (a, b) in Sset or (a, b) in Lset:
            ans.append("LOSE")
        else:
            ans.append("WIN")
    return ans

# Consistency checks vs brute on random tiny instances
def _check_against_brute():
    import random
    random.seed(0)
    for _ in range(50):
        Xmax = random.randint(2, 6)
        Ymax = random.randint(2, 6)
        k = random.randint(0, 4)
        Fs = set()
        while len(Fs) < k:
            Fs.add((random.randint(0, Xmax), random.randint(0, Ymax)))
        # queries: all points in box
        queries = [(x, y) for x in range(Xmax+1) for y in range(Ymax+1)]
        bruteL = brute_classify(Xmax, Ymax, Fs)
        got = classify_positions(len(Fs), len(queries), list(Fs), queries)
        for (x, y), lab in zip(queries, got):
            expect = "LOSE" if (x, y) in bruteL else "WIN"
            assert lab == expect, (Fs, (x, y), lab, expect)
_check_against_brute()
\end{minted}
\VALIDATION{Randomized tiny-grid comparison against the brute DP ensures the staircase generator matches the inductive definition on many small cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sweep + Successor-DSU Staircase}
\WHICHFORMULA{Maintain two dynamic sets with successor links to realize $f_X$ and $f_Y$ in near-constant amortized time, sweeping forbiddens once by $x$ and once by $y$.}
\ASSUMPTIONS{Queries bounded by maxima $X_{\max},Y_{\max}$; losing sequence is strictly increasing; membership of forbiddens via a hash set.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read inputs; store forbiddens in a hash set and two sorted arrays (by $x$ and by $y$).
\item Initialize two MexSet structures, taking $0$ in both to account for $(0,0)$.
\item Repeatedly compute the next pair $(x^\ast,y^\ast) = (\mathrm{mex\_X}(\ge x), \mathrm{mex\_Y}(\ge y))$; if forbidden, skip recording; if not, record as a losing point and take both coordinates.
\item After each advance, activate forbiddens whose $y$ is now $\le y$ to take their $x$ in the X-structure, and forbiddens whose $x$ is now $\le x$ to take their $y$ in the Y-structure.
\item Stop when both $x$ and $y$ exceed query maxima; answer queries by membership in the union of forbiddens, $(0,0)$, and constructed points.
\end{algosteps}
\OPTIMALITY{Each forbidden is activated once, and each constructed losing point is generated once. Successor-DSU yields inverse-Ackermann amortized time per take/mex.}
\COMPLEXITY{Let $Q$ be the number of constructed points up to bounds.}
\[
\begin{aligned}
T(n,m) &= \mathcal{O}\big((n+Q)\alpha(n+Q) + m\big),\quad S = \mathcal{O}(n+Q).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple, Dict, Set

class MexSet:
    def __init__(self):
        self.nxt: Dict[int, int] = {}
    def take(self, v: int) -> None:
        if v not in self.nxt:
            self.nxt[v] = v + 1
    def mex_ge(self, v: int) -> int:
        path = []
        u = v
        while u in self.nxt:
            path.append(u)
            u = self.nxt[u]
        for t in path:
            self.nxt[t] = u
        return u

def brute_classify(Xmax: int, Ymax: int, forbidden: Set[Tuple[int,int]]) -> Set[Tuple[int,int]]:
    L = set()
    L.add((0,0))
    within = {(x, y) for x in range(Xmax+1) for y in range(Ymax+1)}
    L |= (forbidden & within)
    row_has_L = [set() for _ in range(Ymax+1)]
    col_has_L = [set() for _ in range(Xmax+1)]
    row_has_L[0].add(0)
    col_has_L[0].add(0)
    for x in range(Xmax+1):
        for y in range(Ymax+1):
            if (x, y) in within and ((x, y) in forbidden or (x, y) == (0,0)):
                row_has_L[y].add(x)
                col_has_L[x].add(y)
                continue
            if x <= Xmax and y <= Ymax and (x, y) not in forbidden and (x, y) != (0,0):
                has_left_L = any(xp < x for xp in row_has_L[y])
                has_below_L = any(yp < y for yp in col_has_L[x])
                if (not has_left_L) and (not has_below_L):
                    L.add((x, y))
                    row_has_L[y].add(x)
                    col_has_L[x].add(y)
    return L

def generate_constructed_losing(S: Set[Tuple[int,int]], Xmax: int, Ymax: int) -> List[Tuple[int,int]]:
    by_y = sorted(S, key=lambda p: (p[1], p[0]))
    by_x = sorted(S, key=lambda p: (p[0], p[1]))
    iy = 0
    ix = 0
    takeX = MexSet()
    takeY = MexSet()
    takeX.take(0)
    takeY.take(0)
    cx, cy = 0, 0
    constructed: List[Tuple[int,int]] = []
    def activate():
        nonlocal iy, ix
        while iy < len(by_y) and by_y[iy][1] <= cy:
            takeX.take(by_y[iy][0])
            iy += 1
        while ix < len(by_x) and by_x[ix][0] <= cx:
            takeY.take(by_x[ix][1])
            ix += 1
    activate()
    while cx <= Xmax or cy <= Ymax:
        nx = takeX.mex_ge(cx)
        ny = takeY.mex_ge(cy)
        cx, cy = nx, ny
        if (cx, cy) in S:
            activate()
            continue
        constructed.append((cx, cy))
        takeX.take(cx)
        takeY.take(cy)
        activate()
    return constructed

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    m = int(next(it))
    forb = []
    for _ in range(n):
        x = int(next(it)); y = int(next(it))
        forb.append((x, y))
    queries = []
    for _ in range(m):
        a = int(next(it)); b = int(next(it))
        queries.append((a, b))
    return n, m, forb, queries

def solve_all(n: int, m: int, forb: List[Tuple[int,int]], queries: List[Tuple[int,int]]) -> List[str]:
    S = set(forb)
    Xmax = max([0] + [a for a, _ in queries])
    Ymax = max([0] + [b for _, b in queries])
    constructed = generate_constructed_losing(S, Xmax, Ymax)
    losing = set(constructed)
    losing.add((0, 0))
    ans = []
    for a, b in queries:
        if (a, b) in S or (a, b) in losing:
            ans.append("LOSE")
        else:
            ans.append("WIN")
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests
        # 1) No forbiddens
        n, m, forb, queries = 0, 6, [], [(0,0),(1,0),(0,1),(1,1),(2,2),(3,2)]
        out = solve_all(n, m, forb, queries)
        expect = ["LOSE","WIN","WIN","LOSE","LOSE","WIN"]
        assert out == expect
        # 2) Simple forbiddens
        n, m, forb, queries = 2, 3, [(1,0),(0,1)], [(1,1),(2,2),(2,1)]
        out = solve_all(n, m, forb, queries)
        expect = ["WIN","LOSE","WIN"]
        assert out == expect
        # 3) Random tiny cross-check
        import random
        random.seed(1)
        for _ in range(20):
            Xmax = random.randint(2, 5)
            Ymax = random.randint(2, 5)
            k = random.randint(0, 4)
            Fs = set()
            while len(Fs) < k:
                Fs.add((random.randint(0, Xmax), random.randint(0, Ymax)))
            queries = [(x, y) for x in range(Xmax+1) for y in range(Ymax+1)]
            bruteL = brute_classify(Xmax, Ymax, Fs)
            out = solve_all(len(Fs), len(queries), list(Fs), queries)
            for (x, y), lab in zip(queries, out):
                expect = "LOSE" if (x, y) in bruteL else "WIN"
                assert lab == expect
        print("OK")
    else:
        n, m, forb, queries = read_input(data)
        out = solve_all(n, m, forb, queries)
        sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 inline asserts at the top of main plus a randomized tiny cross-check ensure determinism and logic soundness.}
\RESULT{Print LOSE iff the position equals a forbidden shortcut (instant-loss) or equals a constructed losing pair $(x^\ast,y^\ast)$ from the greedy staircase; otherwise WIN.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on canonical cases, edge coordinates, and randomized cross-checks against the brute DP on small grids.}
\LINE{CROSS-CHECKS}{Compare the greedy generator vs brute for many small forbidden sets; ensure agreement on every grid cell.}
\LINE{EDGE-CASE GENERATOR}{Generate random forbidden sets within small boxes, include degenerate cases like empty $S$, many forbiddens on same row/column, and inclusion of $(0,0)$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    cases = []
    # Empty S
    cases.append((0, 3, [], [(0,0),(1,1),(2,1)]))
    # Only (0,0) forbidden (redundant with base)
    cases.append((1, 2, [(0,0)], [(0,0),(1,0)]))
    # Row/column clutter
    forb = [(k, 0) for k in range(1, 4)] + [(0, k) for k in range(1, 4)]
    cases.append((len(forb), 5, forb, [(0,0),(1,0),(0,1),(2,2),(3,3)]))
    return cases

def run_cases():
    for n, m, forb, queries in gen_cases():
        out = solve_all(n, m, forb, queries)
        print("\n".join(out))

if __name__ == "__main__":
    run_cases()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# The final solution is exactly the "Code (Final Submission)" in Approach C.
# It reads input, computes the greedy staircase of losing points using successor-DSU,
# and prints WIN/LOSE per query deterministically.
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute losing positions in a 2-heap Nim variant with instant-loss shortcuts by building a monotone staircase of pairs via two coupled mex counters.}
\WHY{Greedy mex coupling over rows and columns is a common trick in impartial games on grids with axis-aligned moves.}
\CHECKLIST{%
- Add $(0,0)$ as losing.%
- Store forbiddens; membership O(1).%
- Maintain two successor-DSUs for taken $x$'s and $y$'s.%
- Sweep forbiddens by $y$ into taken-$x$ and by $x$ into taken-$y$.%
- Generate pairs $(\mathrm{mex\_X},\mathrm{mex\_Y})$; skip if forbidden; otherwise record and take both coordinates.%
- Stop when both coordinates exceed query maxima; answer membership.}
\EDGECASES{%
- Empty $S$.%
- $(0,0)\in S$ (redundant but harmless).%
- Multiple forbiddens on same row/column.%
- Queries that equal forbiddens.%
- Very large coordinates but few forbiddens.%
- All queries below the first generated constructed pair.}
\PITFALLS{%
- Forgetting that $(0,0)$ is a losing base state.%
- Not taking constructed coordinates into the mex sets, causing repetition.%
- Not activating forbiddens as the sweep advances.%
- Off-by-one in successor-DSU path compression.%
- Stopping generation too early (must exceed both maxima).%
- Using recursion for mex with possible deep chains without compression.}
\FAILMODES{Brute DP over large coordinates is infeasible; naive scanning for each query misses interactions between rows and columns. The staircase method handles arbitrary large coordinates with work proportional to $n$ plus the number of constructed points needed for queries.}
\ELI{We draw a frontier that marks which $x$-columns and $y$-rows already have a losing point. The next losing point is simply the next free column and the next free row together—unless it is a shortcut, in which case it is already losing and we just step over it.}
\NotePages{3}

\end{document}