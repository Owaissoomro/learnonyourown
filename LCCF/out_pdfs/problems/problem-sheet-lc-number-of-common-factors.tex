% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Number of Common Factors}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/number-of-common-factors/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given two positive integers $a$ and $b$, return the number of common factors of $a$ and $b$. An integer $x$ is a common factor of $a$ and $b$ if $x$ divides both $a$ and $b$.\\
Examples:\\
Input: $a=12$, $b=6$; Output: $4$. The common factors are $1,2,3,6$.\\
Input: $a=25$, $b=30$; Output: $2$. The common factors are $1,5$.\\
Constraints: $1 \le a,b \le 1000$.}
\BREAKDOWN{Reduce the problem to counting the positive divisors common to both inputs. Observe that the set of common divisors of $a$ and $b$ equals the set of divisors of $\gcd(a,b)$. Thus, count divisors of $g=\gcd(a,b)$.}
\ELI{Count how many numbers evenly divide both inputs; that is the same as counting the divisors of their greatest common divisor.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $a,b$ with $1 \le a,b \le 1000$.}
\OUTPUTS{A single integer: the number of positive common factors of $a$ and $b$.}
\SAMPLES{Example 1: input $a=12$, $b=6$ $\to$ output $4$. Example 2: input $a=25$, $b=30$ $\to$ output $2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $a,b \in \mathbb{Z}_{>0}$. Let $g=\gcd(a,b)$. The answer is the number of positive divisors of $g$, commonly denoted $\tau(g)$.}
\varmapStart
\var{a,b}{given positive integers}
\var{g}{greatest common divisor $\gcd(a,b)$}
\var{\tau(n)}{number of positive divisors of $n$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Ans}=\left|\{d\in\mathbb{Z}_{>0}: d\mid a \text{ and } d\mid b\}\right|=\left|\{d\in\mathbb{Z}_{>0}: d\mid g\}\right|=\tau(g).
\end{BreakableEquation*}
}
\ASSUMPTIONS{All variables are integers. Only positive divisors are counted. Inputs are within the given constraints.}
\INVARIANTS{The set of common divisors of $a$ and $b$ is exactly the set of divisors of $g=\gcd(a,b)$. The divisor-counting loop up to $\lfloor\sqrt{g}\rfloor$ visits each divisor pair exactly once.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly test each $d$ from $1$ to $\min(a,b)$ and count those dividing both numbers.}
\ASSUMPTIONS{Constraints are small enough that $O(\min(a,b))$ iterations are acceptable as a baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $m=\min(a,b)$ and set $\text{cnt}=0$.
\item For each $d$ in $1,2,\ldots,m$, if $a\bmod d=0$ and $b\bmod d=0$, increment $\text{cnt}$.
\item Return $\text{cnt}$.
\end{algosteps}
\COMPLEXITY{Time $T(n)=O(\min(a,b))$, space $S(n)=O(1)$.}
\[
\begin{aligned}
T(a,b) &= \sum_{d=1}^{\min(a,b)} 1 \\
       &= O(\min(a,b)).
\end{aligned}
\]
\CORRECTNESS{Every common divisor is in $[1,\min(a,b)]$ and will be counted exactly once. No non-divisor is counted.}
\EDGECASES{$a=1$ or $b=1$; $a=b$; one divides the other; both primes.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        m = a if a < b else b
        cnt = 0
        for d in range(1, m + 1):
            if a % d == 0 and b % d == 0:
                cnt += 1
        return cnt

# Basic validation
s = Solution()
assert s.commonFactors(12, 6) == 4
assert s.commonFactors(25, 30) == 2
assert s.commonFactors(1, 1) == 1
\end{minted}
\VALIDATION{Checked sample cases and a boundary case $(1,1)$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{GCD + Prime Factorization}
\WHICHFORMULA{Use $g=\gcd(a,b)$. If $g=\prod p_i^{e_i}$, then the number of divisors is $\tau(g)=\prod (e_i+1)$.}
\ASSUMPTIONS{Trial division up to $\sqrt{g}$ suffices within constraints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $g=\gcd(a,b)$ using Euclid's algorithm.
\item Factor $g$ by trial division up to $\lfloor\sqrt{g}\rfloor$, collecting exponents $e_i$.
\item Return $\prod_i (e_i+1)$, doubling once more if a prime factor $>1$ remains.
\end{algosteps}
\COMPLEXITY{Factoring by trial division costs $O(\sqrt{g})$ time and $O(1)$ space, which improves on $O(\min(a,b))$ in general.}
\[
\begin{aligned}
T(a,b) &\approx O(\log \min(a,b)) + O(\sqrt{g}) = O(\sqrt{g}). \\
\end{aligned}
\]
\CORRECTNESS{The divisor-count formula $\tau(\cdot)$ for prime powers is standard; multiplying over independent prime powers yields the count of all divisors.}
\textbf{Code (Improved)}
\begin{minted}{python}
import math

class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        g = math.gcd(a, b)
        if g == 1:
            return 1  # only divisor is 1
        ans = 1
        p = 2
        # Count factor 2 separately (optional but fine)
        cnt = 0
        while g % p == 0:
            g //= p
            cnt += 1
        if cnt:
            ans *= (cnt + 1)
        p = 3
        while p * p <= g:
            cnt = 0
            while g % p == 0:
                g //= p
                cnt += 1
            if cnt:
                ans *= (cnt + 1)
            p += 2
        if g > 1:
            ans *= 2
        return ans

# Validation
s = Solution()
assert s.commonFactors(12, 6) == 4
assert s.commonFactors(25, 30) == 2
assert s.commonFactors(2, 4) == 2
\end{minted}
\VALIDATION{Compared on samples and a case where one divides the other.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{GCD + Divisor Pair Sweep}
\WHICHFORMULA{Compute $g=\gcd(a,b)$ and count divisors by iterating $i=1$ to $\lfloor\sqrt{g}\rfloor$, adding $2$ for each divisor pair $(i,g/i)$, or $1$ if $i^2=g$.}
\ASSUMPTIONS{Standard integer arithmetic; $g \ge 1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $g=\gcd(a,b)$.
\item Initialize $\text{ans}=0$. For $i=1$ to $\lfloor\sqrt{g}\rfloor$: if $g\bmod i=0$, then add $2$ to ans unless $i^2=g$, in which case add $1$.
\item Return ans.
\end{algosteps}
\OPTIMALITY{This achieves optimal $O(\sqrt{g})$ time and $O(1)$ space for counting divisors via trial division, with minimal constant factors. A lower bound of $\Omega(\sqrt{g})$ holds for comparison-based trial division in the worst case without preprocessing.}
\COMPLEXITY{Time $O(\sqrt{g})$ after an $O(\log \min(a,b))$ gcd; space $O(1)$.}
\[
\begin{aligned}
T(a,b) &= O(\log \min(a,b)) + O(\sqrt{g}), \quad S(a,b)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import math

class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        g = math.gcd(a, b)
        ans = 0
        i = 1
        while i * i <= g:
            if g % i == 0:
                ans += 1 if i * i == g else 2
            i += 1
        return ans

# Exactly 3 asserts
s = Solution()
assert s.commonFactors(12, 6) == 4
assert s.commonFactors(25, 30) == 2
assert s.commonFactors(1, 1000) == 1
\end{minted}
\VALIDATION{Three asserts: both samples and an extreme boundary $(1,1000)$.}
\RESULT{Returns the count of positive common factors of $a$ and $b$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test typical cases, boundaries, equal numbers, co-prime inputs, and cases where one divides the other. Cross-check the optimal method against the baseline for small ranges.}
\LINE{CROSS-CHECKS}{For $a,b \in [1,60]$, compare Approach A (brute force) with Approach C (gcd + pair sweep) on all pairs.}
\LINE{EDGE-CASE GENERATOR}{Deterministically iterate structured families: $(1,b)$, $(p,p)$ for primes, $(k,2k)$, and co-primes.}
\begin{minted}{python}
import math

def brute_common_factors(a: int, b: int) -> int:
    m = a if a < b else b
    cnt = 0
    for d in range(1, m + 1):
        if a % d == 0 and b % d == 0:
            cnt += 1
    return cnt

def optimal_common_factors(a: int, b: int) -> int:
    g = math.gcd(a, b)
    ans = 0
    i = 1
    while i * i <= g:
        if g % i == 0:
            ans += 1 if i * i == g else 2
        i += 1
    return ans

def cross_check_small(limit: int = 60) -> None:
    for a in range(1, limit + 1):
        for b in range(1, limit + 1):
            x = brute_common_factors(a, b)
            y = optimal_common_factors(a, b)
            assert x == y, (a, b, x, y)

def edge_families() -> None:
    # (1, b)
    for b in range(1, 101):
        assert optimal_common_factors(1, b) == 1
    # (k, 2k)
    for k in range(1, 101):
        assert optimal_common_factors(k, 2 * k) >= 2  # at least 1 and k
    # primes p != q are co-prime => only 1 common factor
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    for i, p in enumerate(primes):
        for q in primes[i + 1:]:
            assert optimal_common_factors(p, q) == 1

if __name__ == "__main__":
    cross_check_small()
    edge_families()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import math

class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        g = math.gcd(a, b)
        ans = 0
        i = 1
        while i * i <= g:
            if g % i == 0:
                ans += 1 if i * i == g else 2
            i += 1
        return ans

# Reference asserts
s = Solution()
assert s.commonFactors(12, 6) == 4
assert s.commonFactors(25, 30) == 2
assert s.commonFactors(2, 4) == 2
assert s.commonFactors(1, 1) == 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count positive common divisors of $a$ and $b$; equivalently, count divisors of $g=\gcd(a,b)$.}
\WHY{GCD and divisor-counting are frequent subroutines in interviews and contests; recognizing reductions to gcd is a common optimization step.}
\CHECKLIST{
\begin{bullets}
\item Compute $g=\gcd(a,b)$.
\item Count divisors via sweep up to $\lfloor\sqrt{g}\rfloor$.
\item Handle perfect squares correctly (do not double-count).
\item Return the accumulator.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $a=1$ or $b=1$.
\item $a=b$ (especially perfect squares).
\item Co-prime inputs (answer is $1$).
\item One input divides the other.
\item Prime inputs.
\item Maximum values near $1000$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Double-counting the square root divisor when $g$ is a perfect square.
\item Forgetting that only positive divisors are requested.
\item Off-by-one when looping to $\lfloor\sqrt{g}\rfloor$.
\item Not using gcd, resulting in unnecessary work or TLE at larger bounds.
\item Mishandling $g=1$.
\item Integer overflow is not an issue in Python, but beware in other languages.
\end{bullets}
}
\FAILMODES{Brute force over $[1,\min(a,b)]$ is acceptable here but scales worse than the gcd-based methods. Methods that attempt to list all divisors of $a$ and $b$ separately may waste work; reducing to $g$ avoids this.}
\ELI{Find the biggest number that divides both inputs, then count how many ways it can be divided evenly. Walking up to the square root lets you count divisor pairs efficiently without missing or double-counting any.}
\NotePages{3}

\end{document}