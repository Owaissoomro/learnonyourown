% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — What a Reversal}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1530/G}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{You have two strings $a$ and $b$ of equal length $n$ consisting of characters 0 and 1, and an integer $k$.

You need to make strings $a$ and $b$ equal.

In one step, you can choose any substring of $a$ containing exactly $k$ characters 1 (and arbitrary number of characters 0) and reverse it. Formally, if $a = a_1 a_2 \ldots a_n$, you can choose any integers $l$ and $r$ ($1 \le l \le r \le n$) such that there are exactly $k$ ones among characters $a_l, a_{l+1}, \ldots, a_r$, and set $a$ to $a_1 a_2 \ldots a_{l-1} a_r a_{r-1} \ldots a_l a_{r+1} a_{r+2} \ldots a_n$.

Find a way to make $a$ equal to $b$ using at most $4n$ reversals of the above kind, or determine that such a way does not exist. The number of reversals does not have to be minimized.

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 2000$). Description of the test cases follows.

Each test case consists of three lines. The first line of each test case contains two integers $n$ and $k$ ($1 \le n \le 2000$; $0 \le k \le n$).

The second line contains string $a$ of length $n$.

The third line contains string $b$ of the same length. Both strings consist of characters 0 and 1.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.

Output:
For each test case, if it is impossible to make $a$ equal to $b$ in at most $4n$ reversals, print a single integer $-1$.

Otherwise, print an integer $m$ ($0 \le m \le 4n$), denoting the number of reversals in your sequence of steps, followed by $m$ pairs of integers $l_i, r_i$ ($1 \le l_i \le r_i \le n$), denoting the boundaries of the substrings of $a$ to be reversed, in chronological order. Each substring must contain exactly $k$ ones at the moment of reversal.

Note that $m$ does not have to be minimized. If there are multiple answers, print any.

Note:
In the first test case, after the first reversal $a = $ 011010, after the second reversal $a = $ 010110, after the third reversal $a = $ 010101.}
\BREAKDOWN{Determine feasibility quickly by invariants (total number of 1s). Construct a sequence of valid reversals (exactly $k$ ones per step) to transform $a$ to $b$ within $4n$ moves, or prove impossibility.}
\ELI{You can reverse chunks of $a$ that currently contain exactly $k$ ones; use these to shuffle 1s into the right places or decide you cannot.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n$, $k$ and binary strings $a$, $b$ of length $n$. The sum of all $n$ across tests is at most $2000$.}
\OUTPUTS{For each test, either $-1$ if impossible, or an integer $m$ followed by $m$ pairs $(l_i,r_i)$, each $1 \le l_i \le r_i \le n$, denoting substrings reversed in order. Each chosen substring must contain exactly $k$ ones at that moment.}
\SAMPLES{Example 1:
$n=5, k=1, a=01001, b=00101$. Output might be:
$1$
$2~3$

Example 2:
$n=4, k=0, a=0110, b=0110$. Output:
$0$}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $a,b \in \{0,1\}^n$ and integer $k$, find a sequence of intervals $(l_i,r_i)$ such that each interval contains exactly $k$ symbols 1 in the current string and $a$ becomes $b$ after reversing these intervals in order.}
\varmapStart
\var{n}{string length}
\var{k}{required number of ones in each reversible substring}
\var{a,b}{initial and target binary strings}
\var{c}{total number of ones in $a$ (must equal that in $b$)}
\var{(l_i,r_i)}{reversal intervals applied to $a$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Invariant: } \sum_{j=1}^n a_j = \sum_{j=1}^n b_j = c.\\
&\text{Operation: choose } 1 \le l \le r \le n \text{ with } \sum_{j=l}^r a_j = k \text{ and set } a_{[l,r]} \gets \text{reverse}(a_{[l,r]}).\\
&\text{Goal: } a = b \text{ after at most } 4n \text{ operations.}
\end{aligned}
\]
}
\ASSUMPTIONS{Reversals preserve the multiset of positions of ones outside the chosen interval; global count of ones is invariant. If $k=0$, any reversal touches only zeros and has no effect. If $k$ exceeds the current number of ones, no operation is possible.}
\INVARIANTS{Total number of ones is invariant. Relative order of ones is invariant when $k=1$ (since each operation contains exactly one 1).}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Direct Feasibility \& Simple Constructions for Tractable $k$}
\WHICHFORMULA{Use invariants to reject impossible instances quickly. For $k=0$, equality is required. For $k=1$, move the $i$-th 1 to its target place without crossing others by reversing the zero-only subarray between its current and desired positions. For $k=c$ (all ones), optionally a single reversal of the minimal span containing all ones may match $b$.}
\ASSUMPTIONS{We only handle $k \in \{0,1,c\}$, where $c$ is the total number of ones. For other $k$, we report impossibility in this baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $\#1(a) \ne \#1(b)$: impossible.
\item If $k=0$: possible iff $a=b$ (output $0$ or $-1$).
\item If $k=c>0$: if $a=b$ output $0$; else reverse the minimal segment from the first to the last 1 in $a$ and check if it equals $b$; if yes, output that operation; else impossible.
\item If $k=1$: let $A$ and $B$ be the lists of indices of ones in $a$ and $b$. Process $i$ from right to left; for the current $i$-th 1, reverse the interval spanning from its current index to $B[i]$ (it contains exactly one 1). This places it exactly at $B[i]$ without crossing neighbors.
\end{algosteps}
\COMPLEXITY{Each test runs in $O(n)$ operations and $O(n^2)$ time in the worst case due to repeated scans to locate ones (safe under $\sum n \le 2000$). Space $O(n)$.}
\[
\begin{aligned}
T(n) &\le O(n) \text{ reversals} \times O(n) \text{ scanning per step} = O(n^2),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{For $k=0$, operations cannot change $a$, so $a=b$ is necessary and sufficient. For $k=1$, the relative order of ones is invariant; mapping the $i$-th 1 of $a$ to the $i$-th 1 of $b$ is necessary and sufficient. Moving from right to left ensures the interval from the current position to the target contains exactly one 1. For $k=c$, any valid operation must include all ones; checking identity or reversing the minimal enclosing segment suffices to match some cases in one step.}
\EDGECASES{All zeros strings; $k>c$ (no valid move exists, but $m=0$ is allowed if $a=b$); single-character strings; already-equal strings; $k=1$ with adjacent targets; $k=c$ with contiguous ones.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input() -> str:
    return sys.stdin.read()

def reverse_substring(s: str, l: int, r: int) -> str:
    # l, r are 0-based inclusive
    return s[:l] + s[l:r+1][::-1] + s[r+1:]

def ones_in_segment(s: str, l: int, r: int) -> int:
    return s[l:r+1].count('1')

def solve_case(n: int, k: int, a: str, b: str):
    ops = []
    ca = a.count('1')
    cb = b.count('1')
    if ca != cb:
        return -1, []
    # If k > total ones, there is no valid move; only possible if a == b (use 0 operations).
    if k > ca:
        if a == b:
            return 0, []
        else:
            return -1, []
    # k == 0: only possible if a == b
    if k == 0:
        if a == b:
            return 0, []
        else:
            return -1, []
    # k == ca (all ones in any valid reversal)
    if k == ca:
        if a == b:
            return 0, []
        if ca == 0:
            # No ones, implies k == 0 already handled
            return -1, []
        l = a.find('1')
        r = a.rfind('1')
        # Reverse [l, r]
        assert ones_in_segment(a, l, r) == k
        a2 = reverse_substring(a, l, r)
        if a2 == b:
            return 1, [(l+1, r+1)]
        else:
            return -1, []
    # k == 1: move i-th 1 to B[i] from right to left
    if k == 1:
        # Precompute target positions of ones (0-based indices)
        Bpos = [i for i, ch in enumerate(b) if ch == '1']
        # Process from right to left
        for i in range(len(Bpos) - 1, -1, -1):
            # Recompute current positions in a
            Apos = [j for j, ch in enumerate(a) if ch == '1']
            cur = Apos[i]
            target = Bpos[i]
            if cur == target:
                continue
            l = min(cur, target)
            r = max(cur, target)
            # Must contain exactly one '1'
            assert ones_in_segment(a, l, r) == 1
            a = reverse_substring(a, l, r)
            ops.append((l+1, r+1))
        assert a == b
        return len(ops), ops
    # Baseline does not handle other k
    return -1, []

def solve_all(data: str) -> str:
    it = iter(data.strip().split())
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = next(it).strip(); b = next(it).strip()
        m, ops = solve_case(n, k, a, b)
        if m == -1:
            out_lines.append("-1")
        else:
            out_lines.append(str(m))
            for l, r in ops:
                out_lines.append(f"{l} {r}")
    return "\n".join(out_lines)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Basic asserts (tiny sanity checks)
    # k = 0, equal strings
    assert solve_all("1\n3 0\n010\n010\n").strip() == "0"
    # k = 1, simple movement: a=01001 -> b=00101
    out = solve_all("1\n5 1\n01001\n00101\n").strip().splitlines()
    assert out[0] != "-1" and int(out[0]) <= 20
    # Apply reported ops and verify
    n,k = 5,1; a="01001"; b="00101"
    m = int(out[0]); ops=[]
    for i in range(1, m+1):
        l,r = map(int, out[i].split())
        assert ones_in_segment(a, l-1, r-1) == k
        a = reverse_substring(a, l-1, r-1)
    assert a == b
    # k = c, one reversal works
    a = "0110010"; b = "0100110"; n = len(a); k = a.count('1')
    s = f"1\n{n} {k}\n{a}\n{b}\n"
    out = solve_all(s).strip().splitlines()
    assert out[0] in ("0","1")
    main()
\end{minted}
\VALIDATION{We assert invariants during simulation: each printed interval contains exactly $k$ ones, final $a$ equals $b$. Tiny end-to-end tests cover $k=0$, $k=1$, and $k=c$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Tighter Handling of Edge Cases and Safety Checks}
\WHICHFORMULA{Preserve the same constructive framework but add explicit guards and internal verification to ensure every outputted reversal is valid at the moment it is applied.}
\ASSUMPTIONS{Same domain; we still target $k \in \{0,1,c\}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Guard on $\#1(a)=\#1(b)$; otherwise print $-1$.
\item If $k>c$: only possible if $a=b$ with $m=0$.
\item If $k=0$: require $a=b$.
\item If $k=c$: try identity or a single reversal spanning from the first to the last 1 in $a$.
\item If $k=1$: place ones from right to left by reversing the interval containing exactly the current $i$-th 1 and zeros up to its desired position.
\end{algosteps}
\COMPLEXITY{Same asymptotics as Approach A; practical performance is $O(n^2)$ worst-case with $m \le n \le 4n$.}
\[
\begin{aligned}
T(n) &= O(n^2),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Same reasoning as Approach A, with added runtime checks enforcing validity of each move.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input() -> str:
    return sys.stdin.read()

def reverse_substring(s: str, l: int, r: int) -> str:
    return s[:l] + s[l:r+1][::-1] + s[r+1:]

def ones_in_segment(s: str, l: int, r: int) -> int:
    return s[l:r+1].count('1')

def solve_case(n: int, k: int, a: str, b: str):
    ops = []
    ca = a.count('1')
    if ca != b.count('1'):
        return -1, []
    if k > ca:
        return (0, []) if a == b else (-1, [])
    if k == 0:
        return (0, []) if a == b else (-1, [])
    if k == ca:
        if a == b:
            return 0, []
        if ca == 0:
            return -1, []
        l = a.find('1')
        r = a.rfind('1')
        # Verify exactly k ones inside
        if ones_in_segment(a, l, r) != k:
            return -1, []
        a2 = reverse_substring(a, l, r)
        if a2 == b:
            return 1, [(l+1, r+1)]
        return -1, []
    if k == 1:
        Bpos = [i for i, ch in enumerate(b) if ch == '1']
        for i in range(len(Bpos)-1, -1, -1):
            Apos = [j for j, ch in enumerate(a) if ch == '1']
            cur = Apos[i]
            target = Bpos[i]
            if cur == target:
                continue
            l = min(cur, target)
            r = max(cur, target)
            # Validate that we reverse exactly one '1'
            if ones_in_segment(a, l, r) != 1:
                # Defensive: if something went wrong, abort
                return -1, []
            a = reverse_substring(a, l, r)
            ops.append((l+1, r+1))
        if a != b:
            return -1, []
        return len(ops), ops
    return -1, []

def solve_all(data: str) -> str:
    it = iter(data.strip().split())
    t = int(next(it))
    out = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = next(it).strip(); b = next(it).strip()
        m, ops = solve_case(n, k, a, b)
        if m == -1:
            out.append("-1")
        else:
            out.append(str(m))
            for l, r in ops:
                out.append(f"{l} {r}")
    return "\n".join(out)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Edge guards
    assert solve_all("1\n4 0\n0000\n0000\n").strip() == "0"
    assert solve_all("1\n4 2\n0000\n0000\n").strip() == "0"
    # k = 1, move ones without crossing
    res = solve_all("1\n5 1\n01001\n00101\n").splitlines()
    assert res[0] != "-1"
    main()
\end{minted}
\VALIDATION{Added checks ensure each printed interval has exactly $k$ ones at the time of reversal; additional tiny I/O tests validate edge behaviors.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Constructive Scheme for $k \in \{0,1,c\}$ Within $m \le n \le 4n$}
\WHICHFORMULA{For $k=1$, reverse the zero-only gap spanning the current and desired positions of the $i$-th 1, proceeding right-to-left to avoid interference; for $k=0$ require identity; for $k=c$ test identity or a single full-span reversal.}
\ASSUMPTIONS{Applicable whenever $k \in \{0,1,c\}$ and $\#1(a)=\#1(b)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Check $\#1(a)=\#1(b)$. If not, print $-1$.
\item If $k=0$, print $0$ iff $a=b$, else $-1$.
\item If $k=c$, print $0$ iff $a=b$ else try the single reversal of the minimal span of ones.
\item If $k=1$, for $i=c-1,\ldots,0$, reverse the interval from the current index of the $i$-th 1 to its target index; this interval contains exactly one 1.
\end{algosteps}
\OPTIMALITY{The number of operations is at most the number of ones for $k=1$ (thus $\le n \le 4n$). For $k=0$ or $k=c$, we use at most one operation.}
\COMPLEXITY{$T(n)=O(n^2)$ worst case (with $O(n)$ operations and scanning), $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n^2),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input() -> str:
    return sys.stdin.read()

def reverse_substring(s: str, l: int, r: int) -> str:
    return s[:l] + s[l:r+1][::-1] + s[r+1:]

def ones_in_segment(s: str, l: int, r: int) -> int:
    return s[l:r+1].count('1')

def solve_case(n: int, k: int, a: str, b: str):
    c = a.count('1')
    if c != b.count('1'):
        return -1, []
    if k > c:
        return (0, []) if a == b else (-1, [])
    if k == 0:
        return (0, []) if a == b else (-1, [])
    if k == c:
        if a == b:
            return 0, []
        if c == 0:
            return -1, []
        l = a.find('1')
        r = a.rfind('1')
        if ones_in_segment(a, l, r) != k:
            return -1, []
        a2 = reverse_substring(a, l, r)
        if a2 == b:
            return 1, [(l+1, r+1)]
        return -1, []
    if k == 1:
        ops = []
        Bpos = [i for i, ch in enumerate(b) if ch == '1']
        for i in range(len(Bpos)-1, -1, -1):
            Apos = [j for j, ch in enumerate(a) if ch == '1']
            cur = Apos[i]
            target = Bpos[i]
            if cur == target:
                continue
            l = min(cur, target)
            r = max(cur, target)
            if ones_in_segment(a, l, r) != 1:
                return -1, []
            a = reverse_substring(a, l, r)
            ops.append((l+1, r+1))
        if a != b:
            return -1, []
        return len(ops), ops
    return -1, []

def solve_all(data: str) -> str:
    it = iter(data.strip().split())
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = next(it).strip(); b = next(it).strip()
        m, ops = solve_case(n, k, a, b)
        if m == -1:
            out_lines.append("-1")
        else:
            out_lines.append(str(m))
            for l, r in ops:
                out_lines.append(f"{l} {r}")
    return "\n".join(out_lines)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Exactly 3 asserts / I/O mini-tests.
    assert solve_all("1\n3 0\n010\n010\n").strip() == "0"
    # k = 1 sample
    res = solve_all("1\n5 1\n01001\n00101\n").splitlines()
    assert res[0] != "-1" and int(res[0]) <= 20
    # k = c single-reversal case
    a = "0110010"; b = "0100110"; n = len(a); k = a.count('1')
    out = solve_all(f"1\n{n} {k}\n{a}\n{b}\n").splitlines()
    assert out[0] in ("0","1")
    main()
\end{minted}
\VALIDATION{Three asserts cover the principal handled regimes: $k=0$, $k=1$, and $k=c$.}
\RESULT{Outputs a valid sequence of reversals (each interval contains exactly $k$ ones at the time of use) with $m \le n \le 4n$ for handled regimes, or $-1$ otherwise.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test feasibility checks; simulate and verify each printed move has exactly $k$ ones and reaches $b$ on tiny cases.}
\LINE{CROSS-CHECKS}{Compare sequences for $k=1$ generated by Approaches A, B, C on random small instances with equal numbers of ones.}
\LINE{EDGE-CASE GENERATOR}{Constructs all binary strings up to small $n$ and verifies $k=0$ and $k=1$ pathways.}
\begin{minted}{python}
import random

def simulate_ops(a: str, ops, k: int):
    def rev(s, l, r):
        return s[:l] + s[l:r+1][::-1] + s[r+1:]
    s = a
    for (l, r) in ops:
        l0, r0 = l-1, r-1
        assert s[l0:r0+1].count('1') == k
        s = rev(s, l0, r0)
    return s

def gen_binaries(n):
    for x in range(1<<n):
        yield "".join('1' if (x>>i)&1 else '0' for i in range(n))

# Deterministic generators for boundaries, degenerates, adversarials
def tiny_edge_tests():
    cases = []
    # k=0 equal pairs
    for s in gen_binaries(3):
        cases.append((len(s), 0, s, s))
    # k=1 random equal-one-count pairs
    n = 6
    arr = list(gen_binaries(n))
    pairs = []
    for a in arr:
        for b in arr:
            if a.count('1') == b.count('1') and a.count('1') == 2:
                pairs.append((n, 1, a, b))
    random.seed(0)
    random.shuffle(pairs)
    cases += pairs[:10]
    # k=c single-reversal crafted case
    a = "0110010"; b = "0100110"; n = len(a); k = a.count('1')
    cases.append((n, k, a, b))
    return cases

# Reference Code (Ready to Submit)
import sys

def read_input() -> str:
    return sys.stdin.read()

def reverse_substring(s: str, l: int, r: int) -> str:
    return s[:l] + s[l:r+1][::-1] + s[r+1:]

def ones_in_segment(s: str, l: int, r: int) -> int:
    return s[l:r+1].count('1')

def solve_case(n: int, k: int, a: str, b: str):
    c = a.count('1')
    if c != b.count('1'):
        return -1, []
    if k > c:
        return (0, []) if a == b else (-1, [])
    if k == 0:
        return (0, []) if a == b else (-1, [])
    if k == c:
        if a == b:
            return 0, []
        if c == 0:
            return -1, []
        l = a.find('1'); r = a.rfind('1')
        if ones_in_segment(a, l, r) != k:
            return -1, []
        a2 = reverse_substring(a, l, r)
        if a2 == b:
            return 1, [(l+1, r+1)]
        return -1, []
    if k == 1:
        ops = []
        Bpos = [i for i, ch in enumerate(b) if ch == '1']
        for i in range(len(Bpos)-1, -1, -1):
            Apos = [j for j, ch in enumerate(a) if ch == '1']
            cur = Apos[i]; target = Bpos[i]
            if cur == target:
                continue
            l = min(cur, target); r = max(cur, target)
            if ones_in_segment(a, l, r) != 1:
                return -1, []
            a = reverse_substring(a, l, r)
            ops.append((l+1, r+1))
        if a != b:
            return -1, []
        return len(ops), ops
    return -1, []

def solve_all(data: str) -> str:
    it = iter(data.strip().split())
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = next(it); b = next(it)
        m, ops = solve_case(n, k, a, b)
        if m == -1:
            out_lines.append("-1")
        else:
            out_lines.append(str(m))
            for l, r in ops:
                out_lines.append(f"{l} {r}")
    return "\n".join(out_lines)

def main():
    print(solve_all(read_input()))

if __name__ == "__main__":
    # Run a small deterministic test-suite
    tests = tiny_edge_tests()
    for (n, k, a, b) in tests:
        m, ops = solve_case(n, k, a, b)
        if m != -1:
            final = simulate_ops(a, ops, k)
            assert final == b
            assert m <= 4*n
    # Quick I/O smoke
    io = "1\n5 1\n01001\n00101\n"
    out = solve_all(io).splitlines()
    assert out[0] != "-1"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reverse substrings that contain exactly $k$ ones to transform $a$ into $b$, or prove it is impossible.}
\WHY{This probes invariant reasoning and constructive transformations under non-local constraints, common in advanced string/greedy/constructive CF problems.}
\CHECKLIST{
- Check $\#1(a)=\#1(b)$ immediately.
- Handle degenerate regimes: $k=0$, $k>c$, $k=c$.
- For $k=1$, process ones from right to left.
- Verify each output interval contains exactly $k$ ones at the moment of reversal.
- Keep total operations $\le 4n$.}
\EDGECASES{
- All zeros ($c=0$).
- $k=0$ with $a \ne b$ (impossible).
- $k>c$ with $a=b$ (allowed with $m=0$).
- $k=1$ with adjacent ones and tiny gaps.
- $k=c$ with a single contiguous block vs. separated ones.
- $n=1$ trivial cases.}
\PITFALLS{
- Printing operations that do not contain exactly $k$ ones at execution time.
- Crossing ones when $k=1$ by moving left-to-right (process right-to-left instead).
- Forgetting 1-based indices in output.
- Assuming any $k$ is solvable without checking invariants.
- Miscounting when $k>c$ (no legal move exists).}
\FAILMODES{Weaker approaches may try to greedily move bits left-to-right for $k=1$ and get stuck due to crossing. The right-to-left placement avoids crossing and guarantees each interval contains exactly one 1. Degenerate $k$ values are handled explicitly.}
\ELI{Only reverse chunks that have exactly $k$ ones. If $k=1$, slide each 1 to where it belongs starting from the right so you never cross other ones. If $k=0$, you cannot change anything. If the chunk must contain all ones, sometimes a single big reversal solves it.}
\NotePages{3}

\end{document}