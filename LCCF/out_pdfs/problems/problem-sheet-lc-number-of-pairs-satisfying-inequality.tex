% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Number of Pairs Satisfying Inequality}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/number-of-pairs-satisfying-inequality/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given two \textbf{0-indexed} integer arrays \texttt{nums1} and \texttt{nums2}, each of size $n$, and an integer \texttt{diff}. Find the number of \textbf{pairs} $(i, j)$ such that:
\begin{bullets}
\item $0 \le i < j \le n - 1$ \textbf{and}
\item $\texttt{nums1}[i] - \texttt{nums1}[j] \le \texttt{nums2}[i] - \texttt{nums2}[j] + \texttt{diff}$.
\end{bullets}
Return the \textit{number of pairs} that satisfy the conditions.

\textbf{Example 1:}

\textbf{Input:} \texttt{nums1 = [3, 2, 5]}, \texttt{nums2 = [2, 2, 1]}, \texttt{diff = 1}

\textbf{Output:} \texttt{3}

\textbf{Explanation:}
There are $3$ pairs that satisfy the conditions:
\begin{enumerate}
\item $i = 0, j = 1$: $3 - 2 \le 2 - 2 + 1$. Since $i < j$ and $1 \le 1$, this pair satisfies the conditions.
\item $i = 0, j = 2$: $3 - 5 \le 2 - 1 + 1$. Since $i < j$ and $-2 \le 2$, this pair satisfies the conditions.
\item $i = 1, j = 2$: $2 - 5 \le 2 - 1 + 1$. Since $i < j$ and $-3 \le 2$, this pair satisfies the conditions.
\end{enumerate}
Therefore, we return $3$.

\textbf{Example 2:}

\textbf{Input:} \texttt{nums1 = [3, -1]}, \texttt{nums2 = [-2, 2]}, \texttt{diff = -1}

\textbf{Output:} \texttt{0}

\textbf{Explanation:}
Since there does not exist any pair that satisfies the conditions, we return $0$.

\textbf{Constraints:}
\begin{bullets}
\item $n == \texttt{nums1.length} == \texttt{nums2.length}$.
\item $2 \le n \le 10^5$.
\item $-10^4 \le \texttt{nums1}[i], \texttt{nums2}[i] \le 10^4$.
\item $-10^4 \le \texttt{diff} \le 10^4$.
\end{bullets}}
\BREAKDOWN{Define $a_i = \texttt{nums1}[i] - \texttt{nums2}[i]$. The inequality becomes $a_i \le a_j + \texttt{diff}$ for $i < j$. Count such ordered pairs efficiently by scanning and maintaining a data structure of prior $a_i$ values.}
\ELI{Transform both arrays into a single difference array, then count how many earlier values are not bigger than the current value plus a fixed slack.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function \texttt{numberOfPairs(nums1: List[int], nums2: List[int], diff: int) -\textgreater{} int}.
\begin{bullets}
\item \texttt{nums1}: list of $n$ integers, $2 \le n \le 10^5$, each in $[-10^4, 10^4]$.
\item \texttt{nums2}: list of $n$ integers, same $n$ and range as \texttt{nums1}.
\item \texttt{diff}: integer in $[-10^4, 10^4]$.
\end{bullets}}
\OUTPUTS{An integer equal to the number of pairs $(i, j)$ with $0 \le i < j \le n - 1$ and $a_i \le a_j + \texttt{diff}$ where $a_k = \texttt{nums1}[k] - \texttt{nums2}[k]$.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{nums1 = [3, 2, 5]}, \texttt{nums2 = [2, 2, 1]}, \texttt{diff = 1} \quad Output: \texttt{3}.
\item Input: \texttt{nums1 = [3, -1]}, \texttt{nums2 = [-2, 2]}, \texttt{diff = -1} \quad Output: \texttt{0}.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $a_i = \texttt{nums1}[i] - \texttt{nums2}[i]$ for $i \in \{0,\ldots,n-1\}$. We need to count
\begin{BreakableEquation*}
\#\{(i, j) \mid 0 \le i < j \le n-1,\ a_i \le a_j + d\},
\end{BreakableEquation*}
where $d = \texttt{diff}$.}
\varmapStart
\var{n}{array length}
\var{a_i}{difference $\texttt{nums1}[i] - \texttt{nums2}[i]$}
\var{d}{given integer slack \texttt{diff}}
\var{i,j}{pair indices with $i<j$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Answer} \;=\; \sum_{j=0}^{n-1}\ \sum_{i=0}^{j-1} \mathbf{1}\big(a_i \le a_j + d\big).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Zero-based indexing; $n \ge 2$; values fit in standard 64-bit sums though Python integers are unbounded.}
\INVARIANTS{
\begin{bullets}
\item While scanning by increasing $j$, all counted $i$ satisfy $i<j$.
\item In merge-based counting, subarrays remain sorted after each merge step.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly evaluate the definition $\sum_{j}\sum_{i<j}\mathbf{1}(a_i \le a_j + d)$ by two nested loops.}
\ASSUMPTIONS{No additional structure used; computes exact count for any valid input.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $a[i] \leftarrow \texttt{nums1}[i] - \texttt{nums2}[i]$ for all $i$.
\item For each $j$ from $0$ to $n-1$, for each $i$ from $0$ to $j-1$, if $a[i] \le a[j] + d$, increment the answer.
\item Return the final answer.
\end{algosteps}
\COMPLEXITY{Two nested loops dominate.}
\[
\begin{aligned}
T(n) &= \sum_{j=0}^{n-1} j \;=\; \tfrac{n(n-1)}{2} \;=\; \Theta(n^2), \\
S(n) &= \Theta(n) \text{ to store } a.
\end{aligned}
\]
\CORRECTNESS{By construction, we check exactly the predicate for every eligible ordered pair $(i,j)$ with $i<j$.}
\EDGECASES{All equal elements; strictly increasing or decreasing $a$; extreme $d$ such as very negative or very positive values.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        a = [x - y for x, y in zip(nums1, nums2)]
        n = len(a)
        ans = 0
        for j in range(n):
            aj = a[j]
            for i in range(j):
                if a[i] <= aj + diff:
                    ans += 1
        return ans

# Asserts (baseline)
s = Solution()
assert s.numberOfPairs([3, 2, 5], [2, 2, 1], 1) == 3
assert s.numberOfPairs([3, -1], [-2, 2], -1) == 0
assert s.numberOfPairs([0, 0, 0], [0, 0, 0], 0) == 3  # all pairs valid
\end{minted}
\VALIDATION{Checked the two samples and a uniform-zero case where all $\tfrac{n(n-1)}{2}$ pairs are valid.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Divide-and-Conquer (Merge-Count)}
\WHICHFORMULA{Count during merge: for each $x$ in left half and sorted right half $R$, the number of $y \in R$ with $x \le y + d$ equals $|R| - \text{first index of } y \ge x - d$. Two pointers amortize to linear per merge.}
\ASSUMPTIONS{Standard merge sort invariant: halves are sorted before merging; two-pointer scan maintains monotonicity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute array $a$.
\item Recursively sort-count on left and right halves, summing their answers.
\item During merge, for each $x$ in the sorted left, advance a pointer $j$ in the sorted right while $R[j] + d < x$, then add $|R| - j$ to the answer. Merge the halves.
\end{algosteps}
\COMPLEXITY{Same as merge sort; counting is linear per level.}
\[
\begin{aligned}
T(n) &= 2T(n/2) + O(n) \;=\; O(n\log n), \\
S(n) &= O(n) \text{ auxiliary merge buffers } + O(\log n) \text{ recursion}.
\end{aligned}
\]
\CORRECTNESS{Any cross pair $(i,j)$ with $i$ left, $j$ right is counted exactly once when merging their segments; within-side pairs are counted recursively. Sorting preserves order for subsequent merges.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        a = [x - y for x, y in zip(nums1, nums2)]

        def sort_count(arr: List[int]) -> (List[int], int):
            n = len(arr)
            if n <= 1:
                return arr[:], 0
            mid = n // 2
            left, cntL = sort_count(arr[:mid])
            right, cntR = sort_count(arr[mid:])
            # Count cross pairs (i in left, j in right) with left[i] <= right[j] + diff
            cnt = cntL + cntR
            j = 0
            m = len(right)
            for x in left:
                while j < m and right[j] + diff < x:
                    j += 1
                cnt += m - j
            # Merge
            i = 0
            j = 0
            merged: List[int] = []
            while i < len(left) and j < len(right):
                if left[i] <= right[j]:
                    merged.append(left[i]); i += 1
                else:
                    merged.append(right[j]); j += 1
            if i < len(left):
                merged.extend(left[i:])
            if j < len(right):
                merged.extend(right[j:])
            return merged, cnt

        _, ans = sort_count(a)
        return ans

# Asserts (improved)
s = Solution()
assert s.numberOfPairs([3, 2, 5], [2, 2, 1], 1) == 3
assert s.numberOfPairs([3, -1], [-2, 2], -1) == 0
assert s.numberOfPairs([1, 2, 3], [0, 0, 0], 0) == 3  # a = [1,2,3], need a[i] <= a[j], i<j
\end{minted}
\VALIDATION{Samples pass; monotone example $a=[1,2,3], d=0$ yields $\binom{3}{2}=3$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Fenwick Tree (BIT) with Coordinate Compression}
\WHICHFORMULA{Let $a_i = \texttt{nums1}[i] - \texttt{nums2}[i]$. Scan $j=0\ldots n-1$, maintaining a Fenwick tree over compressed $a$-values of prior indices $i<j$. For each $j$, query the prefix sum up to $a_j + d$ to get $\#\{i<j \mid a_i \le a_j + d\}$, then insert $a_j$.}
\ASSUMPTIONS{Coordinate compression over distinct $a$ values; Fenwick supports prefix sums and point updates in $O(\log n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $a[i] = \texttt{nums1}[i] - \texttt{nums2}[i]$ and the sorted unique values \texttt{vals}.
\item Initialize Fenwick tree over indices $1\ldots |\texttt{vals}|$.
\item For $j=0$ to $n-1$: add to answer the Fenwick prefix sum at index $\texttt{upper\_bound}(\texttt{vals}, a[j]+d)$, then update the tree at index of $a[j]$ by $+1$.
\end{algosteps}
\OPTIMALITY{Any solution must examine all $n$ elements; with comparison-based structures the $O(\log n)$ factor per step is tight for dynamic order statistics. Merge-count also achieves $O(n\log n)$.}
\COMPLEXITY{$O(n\log n)$ time, $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n) \text{ to build } a \;+\; O(n\log n) \text{ queries/updates}, \\
S(n) &= O(n) \text{ for compression and BIT}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import bisect

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0] * (n + 1)

    def add(self, i: int, delta: int) -> None:
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i

    def sum(self, i: int) -> int:
        s = 0
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        a = [x - y for x, y in zip(nums1, nums2)]
        vals = sorted(set(a))
        m = len(vals)
        bit = Fenwick(m)
        ans = 0
        for x in a:
            # count prior a[i] <= x + diff
            idx_q = bisect.bisect_right(vals, x + diff)
            ans += bit.sum(idx_q)
            # insert current value
            idx_u = bisect.bisect_left(vals, x) + 1
            bit.add(idx_u, 1)
        return ans

# Exactly 3 asserts (final)
s = Solution()
assert s.numberOfPairs([3, 2, 5], [2, 2, 1], 1) == 3
assert s.numberOfPairs([3, -1], [-2, 2], -1) == 0
assert s.numberOfPairs([0, 0, 0, 0], [0, 0, 0, 0], 0) == 6
\end{minted}
\VALIDATION{Validated on both samples and the all-zeros case where the answer is $\binom{4}{2}=6$.}
\RESULT{Returns the total number of valid index pairs; no tie-breaking needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Use samples, monotone sequences, and adversarial mixes of negative/positive values. Cross-check optimal solution against a deterministic brute force on small $n$.}
\LINE{CROSS-CHECKS}{For small arrays ($n \le 8$), compare the BIT result with a nested-loop brute force; for increasing and decreasing $a$, compare with closed forms where applicable.}
\LINE{EDGE-CASE GENERATOR}{Deterministically iterate through boundary values: $d \in \{-10^4, 0, 10^4\}$, tiny arrays $n \in \{2,3,4\}$, and patterns (all equal, strictly increasing, strictly decreasing, alternating).}
\begin{minted}{python}
from typing import List
import bisect

def brute_pairs(nums1: List[int], nums2: List[int], diff: int) -> int:
    a = [x - y for x, y in zip(nums1, nums2)]
    n = len(a)
    ans = 0
    for j in range(n):
        for i in range(j):
            if a[i] <= a[j] + diff:
                ans += 1
    return ans

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0] * (n + 1)
    def add(self, i: int, delta: int) -> None:
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i: int) -> int:
        s = 0
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        a = [x - y for x, y in zip(nums1, nums2)]
        vals = sorted(set(a))
        bit = Fenwick(len(vals))
        ans = 0
        for x in a:
            idx_q = bisect.bisect_right(vals, x + diff)
            ans += bit.sum(idx_q)
            idx_u = bisect.bisect_left(vals, x) + 1
            bit.add(idx_u, 1)
        return ans

def deterministic_cases():
    cases = []
    # Samples
    cases.append(([3,2,5], [2,2,1], 1))
    cases.append(([3,-1], [-2,2], -1))
    # All equal zeros
    cases.append(([0,0,0], [0,0,0], 0))
    # Strictly increasing a
    cases.append(([1,2,3], [0,0,0], 0))
    # Strictly decreasing a
    cases.append(([0,0,0], [1,2,3], 0))  # a = [-1,-2,-3]
    # Alternating signs
    cases.append(([5,-5,5,-5], [0,0,0,0], 1))
    # Extreme diff negative and positive
    cases.append(([1,2], [3,4], -10000))
    cases.append(([1,2], [3,4], 10000))
    return cases

# Cross-checks
sol = Solution()
for nums1, nums2, d in deterministic_cases():
    assert sol.numberOfPairs(nums1, nums2, d) == brute_pairs(nums1, nums2, d)

print("All deterministic tests passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import bisect

class Fenwick:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0] * (n + 1)

    def add(self, i: int, delta: int) -> None:
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i

    def sum(self, i: int) -> int:
        s = 0
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        # Transform into a single sequence a[i] = nums1[i] - nums2[i]
        a = [x - y for x, y in zip(nums1, nums2)]
        # Coordinate compression over values of a
        vals = sorted(set(a))
        bit = Fenwick(len(vals))
        ans = 0
        for x in a:
            # Count prior a[i] <= x + diff
            idx_q = bisect.bisect_right(vals, x + diff)
            ans += bit.sum(idx_q)
            # Insert current a[j]
            idx_u = bisect.bisect_left(vals, x) + 1
            bit.add(idx_u, 1)
        return ans

# Basic asserts
s = Solution()
assert s.numberOfPairs([3, 2, 5], [2, 2, 1], 1) == 3
assert s.numberOfPairs([3, -1], [-2, 2], -1) == 0
assert s.numberOfPairs([0, 0, 0, 0], [0, 0, 0, 0], 0) == 6
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count pairs $(i,j)$ with $i<j$ where $a_i \le a_j + d$, using either merge-count or BIT in $O(n\log n)$.}
\WHY{This is a classic transform-and-count pattern that appears in range counting, inversion variants, and interview problems emphasizing offline counting and order statistics.}
\CHECKLIST{
\begin{bullets}
\item Transform to $a[i] = \texttt{nums1}[i] - \texttt{nums2}[i]$.
\item Choose method: merge-count or BIT with compression.
\item Ensure $i<j$ direction is respected (order of processing).
\item For BIT: use bisect\_right on $x + d$ for inclusive bound.
\item For merge: careful two-pointer inequality direction.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All elements equal; answer is $\binom{n}{2}$ if $d \ge 0$.
\item Very negative $d$; possibly zero pairs.
\item Very positive $d$; possibly all pairs.
\item Mixed signs in $a$ due to negative inputs.
\item Small $n=2$ boundary.
\item Large $n$ performance stress.
\item Duplicate values in $a$ ensuring stability.
\item Non-present query key $x+d$ in compression domain.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using bisect\_left instead of bisect\_right for the inclusive $\le$ bound.
\item Updating the BIT before querying at index $j$ (would count $i=j$).
\item Off-by-one in Fenwick indices (1-based).
\item Forgetting to include duplicates during merges; breaking sort invariant.
\item Integer overflow in languages without big ints; use 64-bit.
\item Using $O(n^2)$ in production; will time out for $n=10^5$.
\item Mishandling negative values during compression or bisect.
\end{bullets}}
\FAILMODES{Pure sorting without counting cross pairs misses valid pairs. Hash-only approaches cannot answer ordered inequalities. Our methods explicitly handle order and inequality with provable $O(n\log n)$ time.}
\ELI{Subtract the arrays to get one list. Walk through it; at each step, ask how many earlier numbers are at most the current number plus a cushion $d$. A Fenwick tree or a merge trick answers this quickly.}
\NotePages{3}

\end{document}