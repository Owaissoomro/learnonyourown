% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Time to Kill All Monsters}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-time-to-kill-all-monsters/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an integer array $\texttt{health}$ of length $n \ge 1$ and an integer $\texttt{initialDamage} \ge 1$. You control a hero who can attack exactly one monster at a time.

Combat model:
\begin{bullets}
\item The hero starts with damage per second $D = \texttt{initialDamage}$.
\item When focusing a monster with remaining health $h$, it takes $\left\lceil \tfrac{h}{D} \right\rceil$ whole seconds to defeat it (time is discretized in whole seconds).
\item Immediately after a monster is defeated, your damage doubles: $D \leftarrow 2D$.
\item You may choose the order in which to fight the monsters; you may only work on one monster at a time.
\end{bullets}
Return the minimum total number of whole seconds needed to defeat all monsters.}
\BREAKDOWN{We must choose an order of killing to minimize $\sum \left\lceil \tfrac{h_{\pi(k)}}{D\cdot 2^{k-1}} \right\rceil$. The doubling after each kill suggests a greedy order by increasing health via an exchange argument.}
\ELI{Kill weaker monsters first so your damage doubles sooner; this makes later tough monsters much quicker, minimizing total time.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Python LC-style function signature we will use: \texttt{def minimumTime(self, health: List[int], initialDamage: int) -\textgreater{} int}. Constraints (typical and sufficient for algorithms presented):
\begin{bullets}
\item $1 \le n \le 2 \times 10^5$.
\item $1 \le \texttt{health}[i] \le 10^{18}$.
\item $1 \le \texttt{initialDamage} \le 10^{18}$.
\end{bullets}}
\OUTPUTS{A single integer: the minimal whole seconds to defeat all monsters under the model described.}
\SAMPLES{
\textbf{Example 1:}
\begin{bullets}
\item Input: $\texttt{health} = [3, 7],~\texttt{initialDamage} = 2$.
\item Optimal order: kill $3$ first: time $=\lceil 3/2 \rceil = 2$, damage doubles to $4$; then kill $7$: time $=\lceil 7/4 \rceil = 2$. Total $=4$.
\item Output: $4$.
\end{bullets}
\textbf{Example 2:}
\begin{bullets}
\item Input: $\texttt{health} = [10, 1, 1],~\texttt{initialDamage} = 1$.
\item Kill $1$ then $1$: $1+1=2$ seconds, damage doubles twice to $4$. Kill $10$ with $D=4$: $\lceil 10/4 \rceil=3$. Total $=5$.
\item Output: $5$.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $h_1,\ldots,h_n$ be monster healths. Choose a permutation $\pi$ of $\{1,\ldots,n\}$. Let $D_0=\texttt{initialDamage}$ and $D_k = 2^k D_0$ be the damage during the $k{+}1$-th kill. The total time for order $\pi$ is
\begin{BreakableEquation*}
T(\pi) = \sum_{k=0}^{n-1} \left\lceil \frac{h_{\pi(k+1)}}{D_k} \right\rceil.
\end{BreakableEquation*}
We want $\min_{\pi} T(\pi)$.}
\varmapStart
\var{n}{number of monsters}
\var{h_i}{health of monster $i$}
\var{D_0}{initial damage per second}
\var{D_k}{damage during the $(k{+}1)$-th kill, $D_k = 2^k D_0$}
\var{\pi}{permutation/order of kills}
\var{T(\pi)}{total time in whole seconds for order $\pi$}
\varmapEnd
\GOVERN{
\[
  \text{Minimize } T(\pi) = \sum_{k=0}^{n-1} \left\lceil \frac{h_{\pi(k+1)}}{2^k D_0} \right\rceil
  \quad\text{over permutations }\pi.
\]
}
\ASSUMPTIONS{Time is discretized to whole seconds; damage doubling is instantaneous upon each kill; one active target at a time; healths and damage are positive integers.}
\INVARIANTS{
\begin{bullets}
\item After $k$ kills, damage is exactly $2^k D_0$.
\item The sum of per-monster times equals the total time since no overlap is allowed.
\item For any two adjacent monsters in an order, swapping a larger-health earlier with smaller-health later never improves the sum if ceilings are ignored; with ceilings, the same order remains optimal in aggregate due to monotonicity.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all $n!$ permutations $\pi$ and compute $T(\pi)$ exactly by simulation; return the minimum.}
\ASSUMPTIONS{Feasible only for very small $n$ (e.g., $n \le 10$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate all permutations of indices $[0..n{-}1]$.
\item For each order, simulate: start with $D \leftarrow \texttt{initialDamage}$ and $\texttt{time} \leftarrow 0$.
\item For each index in the order, add $\left\lceil \tfrac{h}{D} \right\rceil$ to time and set $D \leftarrow 2D$.
\item Track the minimum total time across all permutations.
\end{algosteps}
\COMPLEXITY{Brute force over $n!$ orders; each simulation is $O(n)$.
\[
\begin{aligned}
T(n) &= n! \cdot O(n), \\
S(n) &= O(n) \text{ for current order and counters.}
\end{aligned}
\]
}
\CORRECTNESS{Exhaustive enumeration checks every possible order, so the minimum found is optimal by definition.}
\EDGECASES{Single monster; very large \texttt{initialDamage} relative to health; identical health values; large healths with small damage (to test ceiling behavior).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import itertools
import math

class Solution:
    def minimumTime(self, health: List[int], initialDamage: int) -> int:
        # Brute force: try all permutations (intended for small n)
        n = len(health)
        best = math.inf
        for order in itertools.permutations(range(n)):
            d = initialDamage
            t = 0
            for idx in order:
                h = health[idx]
                t += (h + d - 1) // d  # ceil(h / d)
                d <<= 1  # double damage
            if t < best:
                best = t
        return int(best)

# Tiny sanity checks (n small for brute force)
assert Solution().minimumTime([3], 5) == 1  # ceil(3/5)=1
assert Solution().minimumTime([3, 7], 2) == 4  # order (3,7): 2 + 2 = 4
# Compare two orders explicitly when n=2
brute_ans = Solution().minimumTime([10, 1], 1)
# Orders: (10,1): ceil(10/1)+ceil(1/2)=10+1=11 ; (1,10): 1+ceil(10/2)=1+5=6
assert brute_ans == 6
\end{minted}
\VALIDATION{Verified against hand computations for 1–2 monsters; the asserts cover ordering effect and ceiling arithmetic.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy by Increasing Health}
\WHICHFORMULA{Ignoring ceilings, the objective is proportional to $\sum h_{\pi(k)} / 2^{k-1}$; to minimize this, assign smaller $h$ to earlier, larger weights (by Rearrangement), i.e., sort $h$ ascending. Ceilings preserve the optimal order.}
\ASSUMPTIONS{Damage doubles deterministically; one target at a time; the ceiling function is monotone and does not invert the exchange argument.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $\texttt{health}$ in nondecreasing order.
\item Initialize $D \leftarrow \texttt{initialDamage}$ and $\texttt{ans} \leftarrow 0$.
\item For each $h$ in sorted order: add $\left\lceil \tfrac{h}{D} \right\rceil$ to $\texttt{ans}$; then set $D \leftarrow 2D$.
\end{algosteps}
\COMPLEXITY{Sorting dominates: $O(n \log n)$ time; $O(1)$ extra beyond input sort cost.}
\[
\begin{aligned}
T(n) &= O(n \log n) + O(n), \\
S(n) &= O(1) \text{ additional (in-place or linear buffer).}
\end{aligned}
\]
\CORRECTNESS{By an exchange argument: if two adjacent monsters $a \le b$ are scheduled as $(b,a)$ at damage $(D,2D)$, the contribution is $\lceil b/D\rceil + \lceil a/(2D)\rceil \ge \lceil a/D\rceil + \lceil b/(2D)\rceil$, so swapping to $(a,b)$ does not increase cost. Repeatedly applying this yields sorted order as optimal.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import random

class Solution:
    def minimumTime(self, health: List[int], initialDamage: int) -> int:
        h = sorted(health)
        d = initialDamage
        ans = 0
        for x in h:
            ans += (x + d - 1) // d
            d <<= 1
        return ans

# Checks on edge inputs
assert Solution().minimumTime([1], 1) == 1
assert Solution().minimumTime([1, 1, 1], 1) == 1 + 1 + 1  # 1 each, damage grows but ceiling keeps 1
assert Solution().minimumTime([3, 7], 2) == 4
# Random small cross-check against brute force for n<=6
def brute(health, initialDamage):
    import itertools, math
    best = 10**18
    for order in itertools.permutations(range(len(health))):
        d = initialDamage
        t = 0
        for i in order:
            t += (health[i] + d - 1) // d
            d <<= 1
        best = min(best, t)
    return best

for _ in range(50):
    n = random.randint(1, 6)
    arr = [random.randint(1, 15) for __ in range(n)]
    D0 = random.randint(1, 6)
    assert Solution().minimumTime(arr, D0) == brute(arr, D0)
\end{minted}
\VALIDATION{Compared against brute force for many random small cases; deterministic examples match hand calculations.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Greedy Sorted Order with Exchange Argument}
\WHICHFORMULA{Sort $\texttt{health}$ ascending and simulate doubling damage. This realizes the minimizer of
\begin{BreakableEquation*}
\sum_{k=0}^{n-1} \left\lceil \frac{h_{\pi(k)}}{2^k D_0} \right\rceil.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Ceiling is monotone; doubling is exact and instantaneous; no concurrency; all inputs are positive integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $h$ ascending.
\item Initialize $D \leftarrow D_0$ and $T \leftarrow 0$.
\item For each $h$ in sorted order: $T \mathrel{+}= \left\lceil \tfrac{h}{D} \right\rceil$; set $D \leftarrow 2D$.
\end{algosteps}
\OPTIMALITY{Consider two adjacent jobs with healths $a \le b$ at damages $(D,2D)$. Compare $(a,b)$ vs. $(b,a)$:
\[
\left\lceil \frac{a}{D} \right\rceil + \left\lceil \frac{b}{2D} \right\rceil
\le
\left\lceil \frac{b}{D} \right\rceil + \left\lceil \frac{a}{2D} \right\rceil,
\]
which holds because moving the larger job earlier increases its term by at least as much as the decrease from moving the smaller job later; this is tight when both are multiples of $D$. Repeatedly swapping adjacent inversions gives a nondecreasing sequence, which is optimal.}
\COMPLEXITY{$O(n \log n)$ time, $O(1)$ extra space beyond sorting.}
\[
\begin{aligned}
T(n) &= O(n \log n), \\
S(n) &= O(1) \text{ auxiliary.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumTime(self, health: List[int], initialDamage: int) -> int:
        health.sort()
        d = initialDamage
        res = 0
        for h in health:
            res += (h + d - 1) // d
            d <<= 1
        return res

# Exactly 3 asserts (mini-tests)
assert Solution().minimumTime([3, 7], 2) == 4
assert Solution().minimumTime([10, 1, 1], 1) == 5
assert Solution().minimumTime([5, 5, 5, 5], 3) == ((5+3-1)//3) + ((5+6-1)//6) + ((5+12-1)//12) + ((5+24-1)//24)
\end{minted}
\VALIDATION{Matches brute reasoning on small crafted cases; includes direct arithmetic comparison for a repeated-health case.}
\RESULT{Return the minimal total whole seconds to defeat all monsters under the doubling-damage model, achieved by killing in nondecreasing health order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover single-element edge cases, sorted vs. unsorted orders, identical healths, and random small instances cross-checked against brute force. Property: sorting by health never worse than any other order.}
\LINE{CROSS-CHECKS}{For $n \le 7$, compare greedy vs. brute force on random inputs; for larger $n$, spot-check arithmetic and growth behavior as $D$ doubles.}
\LINE{EDGE-CASE GENERATOR}{Generates extremes such as very large \texttt{initialDamage}, very large healths, many ones, and strictly increasing healths to stress ceiling transitions.}
\begin{minted}{python}
from typing import List
import random
import itertools

def greedy_min_time(health: List[int], initialDamage: int) -> int:
    h = sorted(health)
    d = initialDamage
    t = 0
    for x in h:
        t += (x + d - 1) // d
        d <<= 1
    return t

def brute_min_time(health: List[int], initialDamage: int) -> int:
    best = 10**30
    for order in itertools.permutations(range(len(health))):
        d = initialDamage
        t = 0
        for i in order:
            t += (health[i] + d - 1) // d
            d <<= 1
        best = min(best, t)
    return best

def run_tests():
    # Deterministic basic tests
    assert greedy_min_time([3], 5) == 1
    assert greedy_min_time([3, 7], 2) == 4
    assert greedy_min_time([10, 1, 1], 1) == 5
    # Cross-checks for small n
    for _ in range(100):
        n = random.randint(1, 7)
        arr = [random.randint(1, 30) for __ in range(n)]
        D0 = random.randint(1, 10)
        assert greedy_min_time(arr, D0) == brute_min_time(arr, D0)
    # Scale tests (no brute)
    assert greedy_min_time([10**18] * 5, 1) >= 5  # sanity lower bound
    assert greedy_min_time([1] * 1000, 1) == 1000

run_tests()

# Reference Code (Ready to Submit in LC-style)
class Solution:
    def minimumTime(self, health: List[int], initialDamage: int) -> int:
        health.sort()
        d = initialDamage
        res = 0
        for h in health:
            res += (h + d - 1) // d
            d <<= 1
        return res

# Sanity asserts using the final class
assert Solution().minimumTime([3, 7], 2) == 4
assert Solution().minimumTime([10, 1, 1], 1) == 5
assert Solution().minimumTime([1, 2, 4, 8], 1) == 1 + 1 + 1 + 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort by health ascending and simulate doubling damage; sum ceilings $\lceil h/D \rceil$.}
\WHY{Greedy order arises from an exchange argument akin to Rearrangement: accelerate the power growth early by dispatching small jobs first.}
\CHECKLIST{
\begin{bullets}
\item Sort $\texttt{health}$ ascending.
\item Initialize $D \leftarrow \texttt{initialDamage}$ and $\texttt{ans} \leftarrow 0$.
\item For each $h$: add $(h{+}D{-}1)//D$; then $D \leftarrow 2D$.
\item Watch for integer overflows in languages with fixed-width integers.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item Very large $\texttt{initialDamage}$ so that many terms equal $1$.
\item Very large healths (ensure ceiling arithmetic correctness).
\item All healths identical.
\item Healths already sorted vs. reverse sorted.
\item Mixed tiny and huge values to stress the order choice.
\item $\texttt{initialDamage}=1$.
\item Maximum $n$ to test performance.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using floor instead of ceiling: must compute $(h{+}D{-}1)//D$.
\item Doubling damage before adding the time for the current monster (wrong order).
\item Sorting in descending order by mistake.
\item Overflow in languages like C++/Java when doing $D \leftarrow 2D$; use wider types.
\item Mutating the input list inadvertently if it must be preserved; consider sorting a copy.
\item Assuming continuous time and using $\tfrac{h}{D}$ instead of ceiling in integer seconds.
\end{bullets}}
\FAILMODES{
\begin{bullets}
\item Non-greedy orders lead to larger totals, especially when a huge health is placed first.
\item Random or stable-order processing fails on adversarial inputs with one massive and many tiny healths.
\end{bullets}}
\ELI{Do the easy ones first to get stronger quickly; your power doubles after each win, so finishing small fights earlier pays off more later. Sorting by health is the simple and effective strategy.}
\NotePages{3}

\end{document}