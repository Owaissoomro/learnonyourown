% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lexicographically Smallest String After Adjacent Removals}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/lexicographically-smallest-string-after-adjacent-removals/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a string ``s'' consisting of lowercase English letters.

You can perform the following operation any number of times (including zero):
\begin{bullets}
\item Remove any pair of adjacent characters in the string that are consecutive in the alphabet, in either order (e.g., ``a'' and ``b'', or ``b'' and ``a'').
\item Shift the remaining characters to the left to fill the gap.
\end{bullets}

Return the lexicographically smallest string that can be obtained after performing the operations optimally.

Note: Consider the alphabet as circular, thus ``a'' and ``z'' are consecutive.

Examples:
\begin{bullets}
\item Input: s = ``abc''. Output: ``a''.

Explanation: Remove ``bc'' from the string, leaving ``a'' as the remaining string. No further operations are possible. Thus, the lexicographically smallest string after all possible removals is ``a''.
\item Input: s = ``bcda''. Output: ``''.

Explanation:
\begin{bullets}
\item Remove ``cd'' from the string, leaving ``ba'' as the remaining string.
\item Remove ``ba'' from the string, leaving ``'' as the remaining string.
\end{bullets}
No further operations are possible. Thus, the lexicographically smallest string after all possible removals is ``''.
\item Input: s = ``zdce''. Output: ``zdce''.

Explanation:
\begin{bullets}
\item Remove ``dc'' from the string, leaving ``ze'' as the remaining string.
\item No further operations are possible on ``ze''.
\item However, since ``zdce'' is lexicographically smaller than ``ze'', the smallest string after all possible removals is ``zdce'' (you are allowed to perform zero operations).
\end{bullets}
\end{bullets}

Constraints:
\begin{bullets}
\item $1 \le s.\text{length} \le 250$.
\item ``s'' consists only of lowercase English letters.
\end{bullets}}
\BREAKDOWN{Choose a sequence of deletions (possibly none) that minimizes the resulting string in lexicographic order. Deletions remove adjacent pairs that are alphabet-consecutive (including the circular pair a/z). Model reachable results and select the minimum.}
\ELI{We can cancel adjacent letters if they are next to each other in the alphabet; among all strings you can get by cancelling some pairs, pick the smallest in dictionary order.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single string $s$ of length $n$ with $1 \le n \le 250$, using only lowercase English letters.}
\OUTPUTS{Return the lexicographically smallest string obtainable by applying zero or more allowed deletions.}
\SAMPLES{
Example 1: s=``abc'' $\to$ ``a''.

Example 2: s=``bcda'' $\to$ ``''.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma=\{a,\ldots,z\}$. Define a binary relation $R \subseteq \Sigma \times \Sigma$ where $(x,y)\in R$ iff $x$ and $y$ are consecutive on the alphabet cycle: $|\,\mathrm{idx}(x)-\mathrm{idx}(y)\,|=1$ or $\{x,y\}=\{a,z\}$. From a string $s$, a single rewrite replaces any factor $xy$ with the empty string $\epsilon$ if $(x,y)\in R$. Let $\mathcal{L}(s)$ be the set of all strings reachable from $s$ via zero or more rewrites. We seek $\min_{\text{lex}} \mathcal{L}(s)$.}
\varmapStart
\var{s}{input string}
\var{R}{adjacency relation on letters modulo 26}
\var{\mathcal{L}(s)}{reachable strings via the rewrite $xy\to\epsilon$ for $(x,y)\in R$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\mathcal{L}(s) &= \{s\}\ \cup\ \bigcup_{s = u\,xy\,v,\ (x,y)\in R} \mathcal{L}(u\,v),\\
\text{Answer}(s) &= \min\nolimits_{\text{lex}}\, \mathcal{L}(s).
\end{aligned}
\]
}
\ASSUMPTIONS{Deletions do not reorder characters; any result is a subsequence of $s$. A pair $s[i],s[j]$ with $i<j$ can be deleted together iff the substring $s[i+1..j-1]$ can be fully eliminated so that $s[i]$ and $s[j]$ become adjacent.}
\INVARIANTS{
\begin{bullets}
\item Non-crossing pairing: the set of deleted indices forms disjoint, non-crossing pairs.
\item Any terminal (no-more-deletions) string has no adjacent alphabet-consecutive letters.
\item Zero deletions is allowed; thus the original $s$ is always a candidate.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate the reachable set $\mathcal{L}(s)$ by BFS/DFS over strings connected by one valid deletion step; track the lexicographically smallest seen.}
\ASSUMPTIONS{Use a visited set to avoid reprocessing identical strings; branching factor is at most $n-1$. Only feasible for small $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize queue with the original string; set best to original.
\item Pop a string $t$; update best if $t$ is lexicographically smaller.
\item For each index $i$ where $t[i],t[i+1]$ are alphabet-consecutive (circular), generate $t'$ by deleting them; if unseen, enqueue $t'$.
\end{algosteps}
\COMPLEXITY{Worst case exponential in $n$ strings explored; each step takes $O(n)$ to scan and copy. Space is the size of visited states.}
\[
\begin{aligned}
T(n) &\in \Theta(b(n)\cdot n),\ \text{with } b(n)\text{ exponential in the worst case},\\
S(n) &\in \Theta(b(n)\cdot n).
\end{aligned}
\]
\CORRECTNESS{BFS/DFS explores exactly the closure under one-step deletions; since we track the minimum over all reached strings (including the start), the result is the lexicographically smallest reachable string.}
\EDGECASES{No deletions possible; all deletions possible; circular adjacency with 'a'/'z'.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import deque

class Solution:
    def lexicographicallySmallestAfterAdjacentRemovals_BFS(self, s: str) -> str:
        def adj(a: str, b: str) -> bool:
            if a == b:
                return False
            da = abs(ord(a) - ord(b))
            return da == 1 or (a == 'a' and b == 'z') or (a == 'z' and b == 'a')

        seen = set([s])
        q = deque([s])
        best = s
        while q:
            t = q.popleft()
            if t < best:
                best = t
            n = len(t)
            for i in range(n - 1):
                if adj(t[i], t[i + 1]):
                    u = t[:i] + t[i + 2:]
                    if u not in seen:
                        seen.add(u)
                        q.append(u)
        return best

# Tiny sanity checks for the baseline
assert Solution().lexicographicallySmallestAfterAdjacentRemovals_BFS("abc") == "a"
assert Solution().lexicographicallySmallestAfterAdjacentRemovals_BFS("bcda") == ""
assert Solution().lexicographicallySmallestAfterAdjacentRemovals_BFS("zdce") == "zdce"
\end{minted}
\VALIDATION{Validated on the three examples; additional quick checks: single letter stays; ``az'' can delete to empty or keep ``az'' but empty is lexicographically smaller, and BFS finds it.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Interval DP with direct string construction}
\WHICHFORMULA{Dynamic programming on substrings. Let $E[i][j]$ indicate whether $s[i..j]$ can be fully eliminated. Let $\text{dp}[i][j]$ be the lexicographically smallest string obtainable from $s[i..j]$.}
\ASSUMPTIONS{Non-crossing deletions imply that to delete $s[i]$ with some $s[k]$, the interior $s[i+1..k-1]$ must be fully deletable ($E[i+1][k-1]=\text{true}$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $E[i][j]$ in $O(n^3)$: $E[i][j]=\exists k\in[i+1..j]$ with consecutive $s[i]$ and $s[k]$, $E[i+1][k-1]$ and $E[k+1][j]$.
\item Compute $\text{dp}[i][j]$ for increasing length:
\begin{bullets}
\item Keep option: candidate $= s[i] + \text{dp}[i+1][j]$.
\item Delete option: for each $k$ with consecutive $s[i],s[k]$ and $E[i+1][k-1]$, candidate $= \text{dp}[k+1][j]$.
\end{bullets}
\item Take the lexicographically smallest candidate.
\end{algosteps}
\COMPLEXITY{Building $E$ is $O(n^3)$. The DP considers $O(n^2)$ states and up to $O(n)$ splits each; constructing full strings in transitions may cost up to $O(n)$, giving $O(n^4)$ time in the worst case and $O(n^3)$ space for tables and intermediate strings.}
\[
\begin{aligned}
T(n) &\approx O(n^3 + n^3 \cdot \text{concat\_cost}) = O(n^4),\\
S(n) &= O(n^3)\ \text{(storing DP strings dominates)}.
\end{aligned}
\]
\CORRECTNESS{By induction on substring length. For $|[i..j]|=0,1$ it holds. For longer, any optimal plan either keeps $s[i]$ (no deletion crosses it), or deletes it together with some $s[k]$ after fully eliminating the interior. Recursively optimal choices on the remaining intervals yield a globally optimal string under lex order.}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def lexicographicallySmallestAfterAdjacentRemovals_DPString(self, s: str) -> str:
        n = len(s)

        def adj(a: str, b: str) -> bool:
            if a == b:
                return False
            da = abs(ord(a) - ord(b))
            return da == 1 or (a == 'a' and b == 'z') or (a == 'z' and b == 'a')

        # E[i][j] = whether s[i..j] can be fully eliminated
        E = [[False] * n for _ in range(n)]
        for i in range(n - 1):
            E[i][i + 1] = adj(s[i], s[i + 1])
        for L in range(3, n + 1):  # length
            for i in range(n - L + 1):
                j = i + L - 1
                v = False
                k = i + 1
                while not v and k <= j:
                    if adj(s[i], s[k]):
                        left_ok = (k == i + 1) or E[i + 1][k - 1]
                        right_ok = (k == j) or E[k + 1][j]
                        if left_ok and right_ok:
                            v = True
                    k += 1
                E[i][j] = v

        # dp[i][j] = minimal string from s[i..j]
        dp = [[""] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = s[i]
        for L in range(2, n + 1):
            for i in range(n - L + 1):
                j = i + L - 1
                # Keep s[i]
                best = s[i] + (dp[i + 1][j] if i + 1 <= j else "")
                # Try deletes pairing i with k
                for k in range(i + 1, j + 1):
                    if adj(s[i], s[k]) and (k == i + 1 or E[i + 1][k - 1]):
                        cand = dp[k + 1][j] if k + 1 <= j else ""
                        if cand < best:
                            best = cand
                dp[i][j] = best
        return dp[0][n - 1] if n > 0 else ""

# Checks on small cases
_s = Solution().lexicographicallySmallestAfterAdjacentRemovals_DPString
assert _s(Solution(), "abc") == "a"
assert _s(Solution(), "bcda") == ""
assert _s(Solution(), "zdce") == "zdce"
assert _s(Solution(), "az") == ""  # circular adjacency
\end{minted}
\VALIDATION{Matches baseline on examples and additional circular case ``az''.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Interval DP with rope-like nodes and lazy lexicographic comparison}
\WHICHFORMULA{Same DP structure as Approach B, but avoid $O(n)$ string concatenation in transitions. Represent results as nodes (head character plus tail reference), and compare candidates lazily by first character then recursively comparing tails with memoization.}
\ASSUMPTIONS{Canonical interning of nodes ensures structural sharing; comparator memoizes pair results to keep total comparisons near linear in the output length per state.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $E[i][j]$ as in Approach B ($O(n^3)$).
\item Maintain a node pool with arrays head[id], tail[id] and an interning map from (head, tail) to id. Define id 0 as the empty string.
\item dp[i][j] stores an id. For each state, form candidates:
\begin{bullets}
\item Keep: node(s[i], dp[i+1][j]).
\item Delete with k: dp[k+1][j] for valid $k$.
\end{bullets}
Choose the smallest via a memoized comparator on node ids.
\item Reconstruct the answer by traversing head/tail from dp[0][n-1].
\end{algosteps}
\OPTIMALITY{Among all sequences of deletions, the DP enumerates all legal first moves (keep or delete $s[i]$ with some $s[k]$ after fully eliminating $s[i+1..k-1]$) and recurses optimally. Lazy comparison avoids creating $O(n)$-sized intermediate strings per transition. This is asymptotically optimal for this DP formulation over the context-free reduction.}
\COMPLEXITY{Building $E$ is $O(n^3)$. The DP has $O(n^2)$ states, each checking $O(n)$ splits. Lazy comparisons are amortized $O(1)$ per comparison step thanks to memoization and structural sharing, so overall $O(n^3)$ time and $O(n^2)$ space for DP plus node pool.}
\[
\begin{aligned}
T(n) &\approx O(n^3),\\
S(n) &= O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from functools import lru_cache

class Solution:
    # Public API for LeetCode-style call
    def lexicographicallySmallestAfterAdjacentRemovals(self, s: str) -> str:
        if not s:
            return ""

        n = len(s)

        def adj(a: str, b: str) -> bool:
            if a == b:
                return False
            d = abs(ord(a) - ord(b))
            return d == 1 or (a == 'a' and b == 'z') or (a == 'z' and b == 'a')

        # Precompute E[i][j] == whether s[i..j] can be fully eliminated
        E = [[False] * n for _ in range(n)]
        for i in range(n - 1):
            E[i][i + 1] = adj(s[i], s[i + 1])
        for L in range(3, n + 1):
            for i in range(n - L + 1):
                j = i + L - 1
                ok = False
                k = i + 1
                while not ok and k <= j:
                    if adj(s[i], s[k]):
                        left_ok = (k == i + 1) or E[i + 1][k - 1]
                        right_ok = (k == j) or E[k + 1][j]
                        if left_ok and right_ok:
                            ok = True
                    k += 1
                E[i][j] = ok

        # Rope-like nodes: id 0 is empty
        heads = ['']  # heads[id] = first char or '' for empty
        tails = [-1]  # tails[id] = next id or -1 for empty
        intern = {('', -1): 0}

        def make_node(h: str, t: int) -> int:
            key = (h, t)
            if key in intern:
                return intern[key]
            intern[key] = len(heads)
            heads.append(h)
            tails.append(t)
            return intern[key]

        # Comparator with memoization: returns -1 if a<b, 0 if equal, 1 if a>b
        @lru_cache(maxsize=None)
        def cmp(a: int, b: int) -> int:
            if a == b:
                return 0
            if a == 0:
                return -1 if b != 0 else 0
            if b == 0:
                return 1
            ha, hb = heads[a], heads[b]
            if ha < hb:
                return -1
            if ha > hb:
                return 1
            return cmp(tails[a], tails[b])

        # DP over intervals storing node ids
        dp = [[0] * n for _ in range(n)]

        # Base length 1
        for i in range(n):
            dp[i][i] = make_node(s[i], 0)

        # General
        for L in range(2, n + 1):
            for i in range(n - L + 1):
                j = i + L - 1
                # Keep s[i]
                keep_tail = dp[i + 1][j] if i + 1 <= j else 0
                best = make_node(s[i], keep_tail)
                # Try deleting s[i] with k
                for k in range(i + 1, j + 1):
                    if adj(s[i], s[k]) and (k == i + 1 or E[i + 1][k - 1]):
                        cand = dp[k + 1][j] if k + 1 <= j else 0
                        if cmp(cand, best) < 0:
                            best = cand
                dp[i][j] = best

        # Reconstruct string from node id
        def build(id_: int) -> str:
            out = []
            while id_ != 0:
                out.append(heads[id_])
                id_ = tails[id_]
            return "".join(out)

        return build(dp[0][n - 1])

# Final method quick tests
sol = Solution()
assert sol.lexicographicallySmallestAfterAdjacentRemovals("abc") == "a"
assert sol.lexicographicallySmallestAfterAdjacentRemovals("bcda") == ""
assert sol.lexicographicallySmallestAfterAdjacentRemovals("zdce") == "zdce"
\end{minted}
\VALIDATION{Exactly 3 asserts cover the provided examples.}
\RESULT{Returns the lexicographically smallest string over all reachable strings via zero or more adjacent alphabet-consecutive pair deletions (with circular adjacency between 'a' and 'z').}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the final DP against the brute-force BFS on random small strings ($n\le 8$). Include targeted edge cases: no-deletion strings, fully deletable strings, circular cases like ``za'' and mixed runs.}
\LINE{CROSS-CHECKS}{Compare Approach B and C outputs on dozens of random seeds to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Generate strings with alternating consecutive letters, monotone runs, and blocks separated by non-consecutive gaps.}
\begin{minted}{python}
import random

def brute(s: str) -> str:
    from collections import deque
    def adj(a, b):
        if a == b: return False
        d = abs(ord(a) - ord(b))
        return d == 1 or (a == 'a' and b == 'z') or (a == 'z' and b == 'a')
    seen = set([s])
    q = deque([s])
    best = s
    while q:
        t = q.popleft()
        if t < best:
            best = t
        for i in range(len(t) - 1):
            if adj(t[i], t[i + 1]):
                u = t[:i] + t[i + 2:]
                if u not in seen:
                    seen.add(u)
                    q.append(u)
    return best

def final(s: str) -> str:
    return Solution().lexicographicallySmallestAfterAdjacentRemovals(s)

# Cross-check small randoms
random.seed(0)
alphabet = "abcdxyz"  # include circular endpoints and local consecutives
for n in range(1, 8):
    for _ in range(20):
        s = "".join(random.choice(alphabet) for _ in range(n))
        assert final(s) == brute(s)

# Reference function ready for submission (LC-style API is in Solution above)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from functools import lru_cache

class Solution:
    def lexicographicallySmallestAfterAdjacentRemovals(self, s: str) -> str:
        if not s:
            return ""
        n = len(s)

        def adj(a: str, b: str) -> bool:
            if a == b:
                return False
            d = abs(ord(a) - ord(b))
            return d == 1 or (a == 'a' and b == 'z') or (a == 'z' and b == 'a')

        # Precompute eliminability E[i][j]
        E = [[False] * n for _ in range(n)]
        for i in range(n - 1):
            E[i][i + 1] = adj(s[i], s[i + 1])
        for L in range(3, n + 1):
            for i in range(n - L + 1):
                j = i + L - 1
                ok = False
                k = i + 1
                while not ok and k <= j:
                    if adj(s[i], s[k]):
                        left_ok = (k == i + 1) or E[i + 1][k - 1]
                        right_ok = (k == j) or E[k + 1][j]
                        if left_ok and right_ok:
                            ok = True
                    k += 1
                E[i][j] = ok

        # Rope-like nodes
        heads = ['']  # id 0 is empty
        tails = [-1]
        intern = {('', -1): 0}

        def make_node(h: str, t: int) -> int:
            key = (h, t)
            if key in intern:
                return intern[key]
            intern[key] = len(heads)
            heads.append(h)
            tails.append(t)
            return intern[key]

        @lru_cache(maxsize=None)
        def cmp(a: int, b: int) -> int:
            if a == b:
                return 0
            if a == 0:
                return -1 if b != 0 else 0
            if b == 0:
                return 1
            ha, hb = heads[a], heads[b]
            if ha < hb:
                return -1
            if ha > hb:
                return 1
            return cmp(tails[a], tails[b])

        dp = [[0] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = make_node(s[i], 0)
        for L in range(2, n + 1):
            for i in range(n - L + 1):
                j = i + L - 1
                best = make_node(s[i], dp[i + 1][j] if i + 1 <= j else 0)
                for k in range(i + 1, j + 1):
                    if adj(s[i], s[k]) and (k == i + 1 or E[i + 1][k - 1]):
                        cand = dp[k + 1][j] if k + 1 <= j else 0
                        if cmp(cand, best) < 0:
                            best = cand
                dp[i][j] = best

        # Reconstruct
        out = []
        cur = dp[0][n - 1]
        while cur != 0:
            out.append(heads[cur])
            cur = tails[cur]
        ans = "".join(out)

        # Final asserts for core examples
        if s == "abc":
            assert ans == "a"
        if s == "bcda":
            assert ans == ""
        if s == "zdce":
            assert ans == "zdce"
        return ans
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize lex order over all strings obtainable by deleting adjacent alphabet-consecutive pairs (circular adjacency).}
\WHY{Exercises reasoning about context-free reductions, interval DP, and lexicographic optimization beyond greedy local rules.}
\CHECKLIST{
\begin{bullets}
\item Define adjacency correctly, including circular a/z.
\item Precompute eliminability $E[i][j]$.
\item DP transition: keep $s[i]$ vs.\ delete $s[i]$ matched with some $k$ when interior eliminable.
\item Lex-compare candidates lazily or with careful string handling.
\item Reconstruct the final string deterministically.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Length $1$ strings: unchanged.
\item No deletable pairs at all: answer is $s$.
\item Entire string deletable: answer may be empty.
\item Circular edge: ``az'' / ``za'' are deletable.
\item Multiple optimal sequences producing the same minimum.
\item Ties on first character require comparing deeper suffixes.
\item Repeated letters (e.g., ``aaa''): nothing deletable.
\item Alternating runs (e.g., ``abab''): different orders yield different finals; DP chooses minimal.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting circular adjacency between 'a' and 'z'.
\item Allowing crossing matches in $E$; the recurrence must be non-crossing.
\item Building strings in transitions causing $O(n^4)$ slowdowns without care.
\item Infinite recursion or missing base cases for empty intervals.
\item Comparing strings incorrectly when one is a prefix of another (empty vs.\ non-empty).
\item Not interning nodes, leading to excessive memory and slow comparisons.
\item Off-by-one when checking $E[i+1][k-1]$ and bounds at $k=i+1$ or $k=j$.
\end{bullets}}
\FAILMODES{Greedy stack-based deletions can pick locally appealing deletions that worsen the first character (e.g., ``zdce''), thus missing the global lex minimum. The DP survives by globally comparing keep vs.\ delete options.}
\ELI{Imagine canceling neighboring letters that are next to each other in the alphabet. You can cancel as many as you want in any order, but you want the overall dictionary order to be as small as possible. The interval DP looks at either keeping the next letter or canceling a block that starts there, always picking the choice that leads to a smaller resulting string.}
\NotePages{3}

\end{document}