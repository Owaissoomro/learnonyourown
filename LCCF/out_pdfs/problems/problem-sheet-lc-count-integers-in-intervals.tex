% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Count Integers in Intervals}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/count-integers-in-intervals/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given an \textbf{empty} set of intervals, implement a data structure that can:
\begin{bullets}
\item \textbf{Add} an interval to the set of intervals.
\item \textbf{Count} the number of integers that are present in \textbf{at least one} interval.
\end{bullets}
Implement the \texttt{CountIntervals} class:
\begin{bullets}
\item \texttt{CountIntervals()} Initializes the object with an empty set of intervals.
\item \texttt{void add(int left, int right)} Adds the interval \([left, right]\) to the set of intervals.
\item \texttt{int count()} Returns the number of integers that are present in \textbf{at least one} interval.
\end{bullets}
\textbf{Note} that an interval \([left, right]\) denotes all the integers \(x\) where \(left \le x \le right\).

\textbf{Example 1:}

Input
\begin{BreakableEquation*}
\texttt{["CountIntervals", "add", "add", "count", "add", "count"]}
\end{BreakableEquation*}
\begin{BreakableEquation*}
\texttt{[[], [2, 3], [7, 10], [], [5, 8], []]}
\end{BreakableEquation*}

Output
\begin{BreakableEquation*}
\texttt{[null, null, null, 6, null, 8]}
\end{BreakableEquation*}

Explanation

\begin{minipage}[t]{0.98\linewidth}\ttfamily\footnotesize
CountIntervals countIntervals = new CountIntervals();\quad // initialize the object with an empty set of intervals.\\
countIntervals.add(2, 3);\quad // add [2, 3] to the set of intervals.\\
countIntervals.add(7, 10);\quad // add [7, 10] to the set of intervals.\\
countIntervals.count();\quad // return 6\\
\phantom{countIntervals.count();}\quad // the integers 2 and 3 are present in the interval [2, 3].\\
\phantom{countIntervals.count();}\quad // the integers 7, 8, 9, and 10 are present in the interval [7, 10].\\
countIntervals.add(5, 8);\quad // add [5, 8] to the set of intervals.\\
countIntervals.count();\quad // return 8\\
\phantom{countIntervals.count();}\quad // the integers 2 and 3 are present in the interval [2, 3].\\
\phantom{countIntervals.count();}\quad // the integers 5 and 6 are present in the interval [5, 8].\\
\phantom{countIntervals.count();}\quad // the integers 7 and 8 are present in the intervals [5, 8] and [7, 10].\\
\phantom{countIntervals.count();}\quad // the integers 9 and 10 are present in the interval [7, 10].
\end{minipage}

\textbf{Constraints:}
\begin{bullets}
\item \(1 \le left \le right \le 10^9\).
\item At most \(10^5\) calls in total will be made to \texttt{add} and \texttt{count}.
\item At least \textbf{one} call will be made to \texttt{count}.
\end{bullets}}
\BREAKDOWN{We need a dynamic structure that supports interval union updates and returns the total number of covered integers. The core is maintaining the measure (cardinality) of the union of closed integer intervals as updates arrive online.}
\ELI{Keep track of which numbers are covered by at least one added interval, without double-counting overlaps.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An online sequence of operations on a class:
\begin{bullets}
\item \texttt{CountIntervals()} constructs an empty structure.
\item \texttt{add(left: int, right: int)} with \(1 \le left \le right \le 10^9\).
\item \texttt{count()} with no arguments.
\end{bullets}}
\OUTPUTS{\texttt{count()} returns a single integer: the number of distinct integers contained in the union of all intervals added so far.}
\SAMPLES{Example A
\begin{BreakableEquation*}
\texttt{ops}=[\text{"CountIntervals"},\text{"add"},\text{"count"}],\quad \texttt{args}=[[],[5,5],[]]\Rightarrow \texttt{out}=[\text{null},\text{null},1]
\end{BreakableEquation*}
Example B
\begin{BreakableEquation*}
\texttt{ops}=[\text{"CountIntervals"},\text{"add"},\text{"add"},\text{"count"}],\ \texttt{args}=[[],[1,3],[3,6],[]]\Rightarrow \texttt{out}=[\text{null},\text{null},\text{null},6]
\end{BreakableEquation*}
since \([1,3]\cup[3,6]=[1,6]\) has length \(6\).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let \(\mathcal{I}=\{[l_i,r_i]\}_{i=1}^m\) be the multiset of intervals added so far. Let
\begin{BreakableEquation*}
U=\bigcup_{i=1}^m [l_i,r_i]\cap \mathbb{Z}
\end{BreakableEquation*}
be the set of integers covered by at least one interval. The query \texttt{count()} returns \(|U|\).}
\varmapStart
\var{[l_i,r_i]}{the \(i\)-th added closed interval of integers}
\var{U}{current covered integer set}
\var{C}{current covered count \(=|U|\)}
\varmapEnd
\GOVERN{
\[
C=\left|\bigcup_{i=1}^m \{x\in\mathbb{Z}: l_i\le x\le r_i\}\right|,\qquad
|[a,b]\cap\mathbb{Z}|=\max(0,b-a+1).
\]
}
\ASSUMPTIONS{Intervals are closed and integral; order of additions is arbitrary; multiple additions may overlap and should not be double-counted.}
\INVARIANTS{
\begin{bullets}
\item Disjoint-union view: the covered set can be represented as a disjoint family of closed integer intervals; their lengths sum to \(C\).
\item Monotonicity: \(C\) is non-decreasing as only additions occur.
\item Idempotence on covered region: adding an already covered sub-interval leaves \(C\) unchanged.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Track all covered integers explicitly in a hash set; union on every add, size on count.}
\ASSUMPTIONS{Works only when intervals are tiny; serves as a correctness baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a set \(S\) of covered integers.
\item On \texttt{add(l,r)}, insert all integers \(x\) with \(l\le x\le r\) into \(S\).
\item On \texttt{count()}, return \(|S|\).
\end{algosteps}
\COMPLEXITY{Let \(L\) be the sum of lengths of all added intervals. Time \(T\) and space \(S\) scale with \(L\), which is infeasible for large coordinates.}
\[
\begin{aligned}
T(\text{adds}) &= \sum_{\text{adds}} (r-l+1) = L,\\
T(\text{count}) &= O(1),\quad S = \Theta(|S|)\le L.
\end{aligned}
\]
\CORRECTNESS{Set union ensures no double-counting; the size equals the number of covered integers by construction.}
\EDGECASES{Empty not applicable; duplicates and overlaps are naturally handled by set idempotence; adjacent intervals add both endpoints.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline: explicit set of covered integers (for tiny ranges only).
class CountIntervalsNaive:
    def __init__(self):
        self.S = set()

    def add(self, left: int, right: int) -> None:
        # Insert all integers in [left, right]
        for x in range(left, right + 1):
            self.S.add(x)

    def count(self) -> int:
        return len(self.S)

# Provide a Solution class per LC contract context (not used here).
class Solution:
    def demo(self) -> int:
        ci = CountIntervalsNaive()
        ci.add(1, 2)
        ci.add(2, 3)
        return ci.count()

# Tiny sanity checks (small ranges only).
ci = CountIntervalsNaive()
ci.add(2, 3)
ci.add(7, 10)
assert ci.count() == 6
ci.add(5, 8)
assert ci.count() == 8
ci2 = CountIntervalsNaive()
ci2.add(5, 5)
assert ci2.count() == 1
\end{minted}
\VALIDATION{Checked given example and a single-point interval.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Maintain Disjoint Intervals via Sorted Lists}
\WHICHFORMULA{Represent the covered set as a sorted, disjoint list of intervals; on add, merge overlaps and keep a running covered length.}
\ASSUMPTIONS{Use two parallel sorted arrays of starts and ends; bisect to find merge window; subtract removed lengths and add the new merged length.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep arrays \(\texttt{starts}\) and \(\texttt{ends}\), disjoint and sorted, and a total length \(C\).
\item To add \([l,r]\), locate insertion point by \(\texttt{bisect\_left(starts, l)}\), absorb a touching previous interval if any, then absorb all subsequent intervals with start \(\le r+1\).
\item Insert the merged \([L,R]\) and update \(C \leftarrow C - \text{removed} + (R-L+1)\).
\item \texttt{count()} returns \(C\).
\end{algosteps}
\COMPLEXITY{Each add may delete or insert in arrays: \(O(k)\) element moves for \(k\) merged intervals; search is \(O(\log n)\). This is typically fast, but worst-case \(O(n)\) per add.}
\[
\begin{aligned}
T_{\text{add}} &= O(\log n + k + \text{shifts}) = O(n)\ \text{worst-case},\\
T_{\text{count}} &= O(1),\quad S = O(n).
\end{aligned}
\]
\CORRECTNESS{The list remains disjoint and sorted; the union length equals the sum of interval lengths, maintained incrementally.}
\textbf{Code (Improved)}
\begin{minted}{python}
from bisect import bisect_left

class CountIntervalsMerge:
    def __init__(self):
        self.starts = []
        self.ends = []
        self.total = 0

    def add(self, left: int, right: int) -> None:
        l, r = left, right
        n = len(self.starts)
        i = bisect_left(self.starts, l)

        # Try to merge with the previous interval if it touches/overlaps.
        if i > 0 and self.ends[i - 1] >= l - 1:
            i -= 1
            l = min(l, self.starts[i])
            r = max(r, self.ends[i])
            self.total -= (self.ends[i] - self.starts[i] + 1)
            del self.starts[i]
            del self.ends[i]

        # Merge subsequent overlapping/touching intervals.
        while i < len(self.starts) and self.starts[i] <= r + 1:
            r = max(r, self.ends[i])
            self.total -= (self.ends[i] - self.starts[i] + 1)
            del self.starts[i]
            del self.ends[i]

        # Insert the merged interval.
        self.starts.insert(i, l)
        self.ends.insert(i, r)
        self.total += (r - l + 1)

    def count(self) -> int:
        return self.total

# LC helper class presence.
class Solution:
    def demo_merge(self) -> int:
        ci = CountIntervalsMerge()
        ci.add(1, 3)
        ci.add(5, 7)
        ci.add(3, 5)  # merges all to [1,7]
        return ci.count()

# Checks on edge-ish inputs (small sizes).
ci = CountIntervalsMerge()
ci.add(1, 1)
ci.add(2, 2)
assert ci.count() == 2
ci.add(2, 5)  # becomes [1,5]
assert ci.count() == 5
ci.add(7, 7)
ci.add(6, 6)  # becomes [1,7]
assert ci.count() == 7
\end{minted}
\VALIDATION{Verified monotonic growth and merging of touching intervals into a single block.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Dynamic Segment Tree With Cover Flags}
\WHICHFORMULA{Use a dynamic segment tree over \([1,10^9]\) that stores the covered length in each node and a cover flag for fully covered segments. Range-update on \([l,r]\) and sum via the root.}
\ASSUMPTIONS{Coordinates are large; we create nodes lazily only where needed. Each update touches \(O(\log U)\) nodes where \(U=10^9\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Each node stores: pointers to children, a boolean \texttt{cover} meaning its entire segment is covered, and \texttt{val} the covered length in the segment.
\item To add \([l,r]\), recurse; if the current segment lies entirely in \([l,r]\), mark covered and set \texttt{val} to segment length, pruning children.
\item Otherwise push into children, update their \texttt{val}, and set current \texttt{val} to left.val + right.val. If \texttt{val} equals segment length, mark covered and prune.
\item \texttt{count()} returns root.\texttt{val}.
\end{algosteps}
\OPTIMALITY{Any online data structure must account for potentially \(\Theta(\log U)\) segment boundaries. The dynamic segment tree attains \(O(\log U)\) per add and \(O(1)\) per count, which is optimal up to constants for comparison-based range-set unions over large universes.}
\COMPLEXITY{Let \(U=10^9\).}
\[
\begin{aligned}
T_{\text{add}} &= O(\log U)\ \text{amortized},\quad T_{\text{count}}=O(1),\\
S &= O(M),\ \text{number of created nodes} \le O(Q\log U)\ \text{for }Q\text{ adds}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final LC-ready class: CountIntervals with dynamic segment tree.
class Node:
    __slots__ = ("left", "right", "val", "cover")
    def __init__(self):
        self.left = None   # left child
        self.right = None  # right child
        self.val = 0       # covered length in this segment
        self.cover = False # True if this whole segment is fully covered

class CountIntervals:
    def __init__(self):
        self.U = 1
        self.V = 10**9
        self.root = Node()

    def add(self, left: int, right: int) -> None:
        def update(node: Node, L: int, R: int, ql: int, qr: int) -> None:
            if node.cover or qr < L or R < ql:
                return
            if ql <= L and R <= qr:
                node.cover = True
                node.left = None
                node.right = None
                node.val = R - L + 1
                return
            mid = (L + R) // 2
            if node.left is None:
                node.left = Node()
            if node.right is None:
                node.right = Node()
            update(node.left, L, mid, ql, qr)
            update(node.right, mid + 1, R, ql, qr)
            node.val = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)
            if node.val == (R - L + 1):
                # Entire segment covered; compress.
                node.cover = True
                node.left = None
                node.right = None
            else:
                node.cover = False

        update(self.root, self.U, self.V, left, right)

    def count(self) -> int:
        return self.root.val

# Provide a Solution class by convention.
class Solution:
    def build(self):
        return CountIntervals()

# Exactly 3 mini-tests mirroring the prompt behavior.
ci = CountIntervals()
ci.add(2, 3)
ci.add(7, 10)
assert ci.count() == 6
ci.add(5, 8)
assert ci.count() == 8
ci2 = CountIntervals()
ci2.add(1, 10**9)
assert ci2.count() == 10**9
\end{minted}
\VALIDATION{Three asserts: the prompt's example, and a full-span interval \([1,10^9]\) yielding \(10^9\).}
\RESULT{The structure reports the covered cardinality of the union of all added intervals, merging overlaps and adjacency implicitly via the segment tree.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for merging behavior, adjacency, duplicates, and extremes; cross-check against a merge-list implementation on modest coordinate ranges.}
\LINE{CROSS-CHECKS}{For many random operations on small domains, ensure the dynamic segment tree and the merge-list produce identical counts after each operation.}
\LINE{EDGE-CASE GENERATOR}{Generate touching intervals, nested intervals, repeated re-additions, and scattered singletons.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

class CountIntervalsMerge:
    from bisect import bisect_left
    def __init__(self):
        self.starts = []
        self.ends = []
        self.total = 0
    def add(self, left: int, right: int) -> None:
        from bisect import bisect_left
        l, r = left, right
        i = bisect_left(self.starts, l)
        if i > 0 and self.ends[i - 1] >= l - 1:
            i -= 1
            l = min(l, self.starts[i]); r = max(r, self.ends[i])
            self.total -= (self.ends[i] - self.starts[i] + 1)
            del self.starts[i]; del self.ends[i]
        while i < len(self.starts) and self.starts[i] <= r + 1:
            r = max(r, self.ends[i])
            self.total -= (self.ends[i] - self.starts[i] + 1)
            del self.starts[i]; del self.ends[i]
        self.starts.insert(i, l); self.ends.insert(i, r)
        self.total += (r - l + 1)
    def count(self) -> int:
        return self.total

class Node:
    __slots__ = ("left", "right", "val", "cover")
    def __init__(self):
        self.left = None; self.right = None
        self.val = 0; self.cover = False

class CountIntervals:
    def __init__(self):
        self.U, self.V = 1, 10**9
        self.root = Node()
    def add(self, left: int, right: int) -> None:
        def upd(nd: Node, L: int, R: int, ql: int, qr: int):
            if nd.cover or qr < L or R < ql: return
            if ql <= L and R <= qr:
                nd.cover = True; nd.left = None; nd.right = None
                nd.val = R - L + 1; return
            m = (L + R) // 2
            if nd.left is None: nd.left = Node()
            if nd.right is None: nd.right = Node()
            upd(nd.left, L, m, ql, qr)
            upd(nd.right, m + 1, R, ql, qr)
            nd.val = nd.left.val + nd.right.val
            if nd.val == (R - L + 1):
                nd.cover = True; nd.left = None; nd.right = None
            else:
                nd.cover = False
        upd(self.root, self.U, self.V, left, right)
    def count(self) -> int:
        return self.root.val

def cross_check():
    random.seed(0)
    # Restrict to small domain for cross-check ease with merge structure.
    domL, domR = 1, 2000
    for _ in range(5):
        A = CountIntervals()
        B = CountIntervalsMerge()
        for _ in range(500):
            l = random.randint(domL, domR)
            r = random.randint(domL, domR)
            if l > r: l, r = r, l
            A.add(l, r); B.add(l, r)
            assert A.count() == B.count()
    # Adversarial touching chains
    A = CountIntervals(); B = CountIntervalsMerge()
    for i in range(1, 501):
        A.add(i, i); B.add(i, i)
    assert A.count() == B.count() == 500
    for i in range(1, 500):
        A.add(i, i + 1); B.add(i, i + 1)
    assert A.count() == B.count() == 500

cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final LC class: CountIntervals using a dynamic segment tree.
class Node:
    __slots__ = ("left", "right", "val", "cover")
    def __init__(self):
        self.left = None
        self.right = None
        self.val = 0
        self.cover = False

class CountIntervals:
    def __init__(self):
        self.U = 1
        self.V = 10**9
        self.root = Node()

    def add(self, left: int, right: int) -> None:
        def update(node: Node, L: int, R: int, ql: int, qr: int) -> None:
            if node.cover or qr < L or R < ql:
                return
            if ql <= L and R <= qr:
                node.cover = True
                node.left = None
                node.right = None
                node.val = R - L + 1
                return
            mid = (L + R) // 2
            if node.left is None:
                node.left = Node()
            if node.right is None:
                node.right = Node()
            update(node.left, L, mid, ql, qr)
            update(node.right, mid + 1, R, ql, qr)
            node.val = node.left.val + node.right.val
            if node.val == (R - L + 1):
                node.cover = True
                node.left = None
                node.right = None
            else:
                node.cover = False

        update(self.root, self.U, self.V, left, right)

    def count(self) -> int:
        return self.root.val

# Minimal LC Solution class presence.
class Solution:
    def build(self):
        return CountIntervals()

# Sanity asserts (non-exhaustive).
ci = CountIntervals()
ci.add(2, 3)
ci.add(7, 10)
assert ci.count() == 6
ci.add(5, 8)
assert ci.count() == 8
ci_full = CountIntervals()
ci_full.add(1, 10**9)
assert ci_full.count() == 10**9
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain the union length of dynamically added integer intervals and answer counts online.}
\WHY{This tests interval-union data structures, lazy propagation, and handling very large coordinate ranges.}
\CHECKLIST{
\begin{bullets}
\item Is the structure monotone and free of double-counting?
\item Does add handle adjacency (\(r+1=l\)) as merge?
\item Are children pruned when a node becomes fully covered?
\item Is the covered length maintained correctly at each node?
\item Are extreme coordinates handled without overflow in Python?
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Re-adding the exact same interval.
\item Adding sub-intervals fully inside covered ranges.
\item Touching intervals like \([1,3]\) and \([4,6]\).
\item Single-point intervals.
\item Very large intervals reaching boundaries \(1\) or \(10^9\).
\item Many small singleton adds forming a continuous block.
\item Alternating disjoint and overlapping intervals.
\item Deeply nested intervals.
\item Large number of operations (\(10^5\)).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to set \texttt{val} when marking a node covered.
\item Not pruning children when a node becomes fully covered (blows memory).
\item Omitting the early-return when a node is already \texttt{cover}=True.
\item Off-by-one on integer lengths: use \(R-L+1\).
\item Merging only overlaps but not adjacency (\(r+1=l\)).
\item Recomputing \texttt{val} without both children initialized.
\item Using a dense array segment tree over \(10^9\) (impossible).
\item Overflow concerns in other languages if not using 64-bit integers.
\end{bullets}}
\FAILMODES{Naive set enumerations explode with large ranges; sorted-list approaches can hit \(O(n)\) per add in adversarial sequences; the dynamic segment tree sustains \(O(\log U)\) per add regardless of coordinates.}
\ELI{Think of the number line chopped into power-of-two blocks. When you mark a block as fully covered, you stop caring about its tiny details. Count just sums up how many positions are covered across these blocks.}
\NotePages{3}

\end{document}