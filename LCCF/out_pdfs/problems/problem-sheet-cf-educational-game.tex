% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Educational Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/178/A1}}
\LINE{DIFFICULTY / RATING}{1000}
\STATEMENT{The Smart Beaver from ABBYY began to develop a new educational game for children. The rules of the game are fairly simple and are described below.

The playing field is a sequence of $n$ non-negative integers $a_i$ numbered from $1$ to $n$. The goal of the game is to make numbers $a_1, a_2, \ldots, a_k$ (i.e., some prefix of the sequence) equal to zero for some fixed $k$ ($k < n$), and this should be done in the smallest possible number of moves.

One move is choosing an integer $i$ ($1 \le i \le n$) such that $a_i > 0$ and an integer $t$ ($t \ge 0$) such that $i + 2^t \le n$. After the values of $i$ and $t$ have been selected, the value of $a_i$ is decreased by $1$, and the value of $a_{i + 2^t}$ is increased by $1$. For example, let $n = 4$ and $a = (1, 0, 1, 2)$, then it is possible to make move $i = 3$, $t = 0$ and get $a = (1, 0, 0, 3)$ or to make move $i = 1$, $t = 1$ and get $a = (0, 0, 2, 2)$ (the only possible other move is $i = 1$, $t = 0$).

You are given $n$ and the initial sequence $a_i$. The task is to calculate the minimum number of moves needed to make the first $k$ elements of the original sequence equal to zero for each possible $k$ ($1 \le k < n$).

Input: The first input line contains a single integer $n$. The second line contains $n$ integers $a_i$ ($0 \le a_i \le 10^4$), separated by single spaces.

The input limitations for getting $20$ points are:
\begin{itemize}
\item $1 \le n \le 300$
\end{itemize}
The input limitations for getting $50$ points are:
\begin{itemize}
\item $1 \le n \le 2000$
\end{itemize}
The input limitations for getting $100$ points are:
\begin{itemize}
\item $1 \le n \le 10^5$
\end{itemize}

Output: Print exactly $n - 1$ lines: the $k$-th output line must contain the minimum number of moves needed to make the first $k$ elements of the original sequence $a_i$ equal to zero.

Please do not use the \%\texttt{lld} specifier to read or write $64$-bit integers in C++. It is preferred to use the \texttt{cin}, \texttt{cout} streams, or the \%\texttt{I64d} specifier.}
\BREAKDOWN{Each move pushes one unit from index $i$ to $i + 2^t$ (a power-of-two step) to the right. For each prefix length $k$, every unit initially in positions $1..k$ must be pushed beyond $k$. The minimal cost for a unit from $i$ is the minimal popcount of a displacement $d \in [k+1-i, n-i]$. Total cost sums these per-unit minima.}
\ELI{To clear the first $k$ cells, push each token right using jumps of size $1,2,4,\ldots$; the least number of jumps for a token equals the fewest $1$-bits among allowed distances.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{bullets}
\item Integer $n$ ($1 \le n \le 10^5$).
\item Sequence $a_1, a_2, \ldots, a_n$ with $0 \le a_i \le 10^4$.
\end{bullets}}
\OUTPUTS{Print $n-1$ lines. Line $k$ ($1 \le k < n$) is the minimal number of moves to make $a_1, \ldots, a_k$ all zero.}
\SAMPLES{Example 1:
\begin{bullets}
\item Input:
\[
\begin{aligned}
n&=4\\
a&=(1,0,1,2)
\end{aligned}
\]
Output (three lines):
\[
\begin{aligned}
k=1 &:~1\\
k=2 &:~1\\
k=3 &:~2
\end{aligned}
\]
\end{bullets}
Example 2:
\begin{bullets}
\item Input:
\[
\begin{aligned}
n&=3\\
a&=(2,1,0)
\end{aligned}
\]
Output:
\[
\begin{aligned}
k=1 &:~2\\
k=2 &:~3
\end{aligned}
\]
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let positions $1..n$ hold $a_i$ tokens. A move transfers one token from $i$ to $i+2^t$ provided $i+2^t \le n$. For a fixed $k < n$, define for $i \le k$ the minimal per-token cost
\begin{BreakableEquation*}
g(i,k) \coloneqq \min_{d \in [k+1-i,\, n-i]} \operatorname{popcount}(d).
\end{BreakableEquation*}
The total minimal moves is
\begin{BreakableEquation*}
S(k) \coloneqq \sum_{i=1}^{k} a_i \cdot g(i,k).
\end{BreakableEquation*}%
Each token moves independently; there is no interference or capacity constraint.}
\varmapStart
\var{n}{length of the array}
\var{a_i}{initial token counts}
\var{k}{prefix length to clear ($1 \le k < n$)}
\var{d}{displacement chosen for one token}
\var{g(i,k)}{least number of jumps needed for a token at $i$ to reach $>k$}
\var{S(k)}{answer for prefix length $k$}
\varmapEnd
\GOVERN{
\[
  g(i,k) \;=\; \min_{d \in [k+1-i,\, n-i]} \operatorname{popcount}(d),\qquad
  S(k) \;=\; \sum_{i=1}^{k} a_i \, g(i,k).
\]
}
\ASSUMPTIONS{Tokens are indistinguishable and independent; moves commute. A token's cost to reach position $j$ equals $\operatorname{popcount}(j-i)$ because a sum of powers of two uses one move per $1$-bit.}
\INVARIANTS{
\begin{bullets}
\item Moves never decrease indices; all tokens initially at $i \le k$ must end at $>k$.
\item Minimal cost per token depends only on the interval of allowed displacements, not on other tokens.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly evaluate $g(i,k)$ by scanning $d \in [k+1-i,\, n-i]$ and taking the minimal popcount. Sum over $i \le k$.}
\ASSUMPTIONS{Feasible only for very small $n$ due to $O(n^3 \log n)$ in worst-case.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $\operatorname{popcount}(x)$ using built-in bit operations.
\item For each $k=1..n-1$:
\begin{bullets}
\item For each $i=1..k$, compute $g(i,k)=\min_{d \in [k+1-i,\,n-i]} \operatorname{popcount}(d)$ by brute scan.
\item Accumulate $S(k) += a_i \cdot g(i,k)$.
\end{bullets}
\item Print $S(1),\ldots,S(n-1)$.
\end{algosteps}
\COMPLEXITY{Let $L_{i,k}=n-k$. The inner scan length is $O(n)$.
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n-1}\sum_{i=1}^{k} O(n) \;=\; O(n^3),\\
S(n) &= O(1).
\end{aligned}
\]}
\CORRECTNESS{By definition of $g(i,k)$ as the minimal popcount over admissible displacements, the brute scan returns the correct minimal jumps per token; summation is linear.}
\EDGECASES{All zeros; $n=1$ (no output); large $a_i$; tokens already beyond any $k$ unaffected.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def popcount(x: int) -> int:
    return x.bit_count()

def solve_bruteforce(n, a):
    # Baseline O(n^3) brute force: for each k and i, scan d in [k+1-i .. n-i]
    res = []
    for k in range(1, n):
        total = 0
        for i in range(1, k + 1):
            L = (k + 1) - i
            R = n - i
            best = None
            for d in range(L, R + 1):
                pc = popcount(d)
                if best is None or pc < best:
                    best = pc
                    if best == 1:
                        break
            total += a[i - 1] * (best if best is not None else 0)
        res.append(total)
    return res

def main():
    inp = read_input()
    if inp is None:
        return
    n, a = inp
    ans = solve_bruteforce(n, a)
    out = "\n".join(str(x) for x in ans)
    sys.stdout.write(out)

if __name__ == "__main__":
    # Tiny sanity checks
    assert solve_bruteforce(4, [1,0,1,2]) == [1,1,2]
    assert solve_bruteforce(3, [2,1,0]) == [2,3]
    # Do not run main() during assertions-only runs
    # main()
    pass
\end{minted}
\VALIDATION{Checked on two tiny hand-crafted cases. For random small $n \le 8$, cross-validate with improved/final versions in later sections.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-Index Suffix Minima}
\WHICHFORMULA{For fixed $i$, $g(i,k)$ is the suffix minimum of $\operatorname{popcount}(d)$ over $d \in [1..n-i]$ at position $L=k+1-i$. Precomputing this per $i$ reduces per-$k$ work.}
\ASSUMPTIONS{Still quadratic in $n$ total, but much faster than brute for moderate $n$ due to vectorized suffix minima.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $pc[d]=\operatorname{popcount}(d)$ for $d \le n$.
\item For each $i=1..n-1$: build $suf[d]=\min_{t \in [d..n-i]} pc[t]$ for $d=1..n-i$.
\item For each $k=1..n-1$: accumulate $S(k)+=a_i \cdot suf[k+1-i]$ over $i \le k$.
\end{algosteps}
\COMPLEXITY{Building all suffix minima costs $\sum_{i=1}^{n-1} O(n-i)=O(n^2)$ and answering all $k$ is also $O(n^2)$.
\[
\begin{aligned}
T(n) &= O(n^2),\\
S(n) &= O(n).
\end{aligned}
\]}
\CORRECTNESS{For fixed $i$, by definition $g(i,k)=\min_{d \in [k+1-i..n-i]} \operatorname{popcount}(d)=\text{suf}[k+1-i]$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_improved(n, a):
    pc = [0]*(n+1)
    for d in range(1, n+1):
        pc[d] = d.bit_count()
    ans = [0]*(n-1)
    for i in range(1, n):  # i = 1..n-1
        R = n - i
        suf = [0]*(R+2)
        suf[R] = pc[R]
        for d in range(R-1, 0, -1):
            suf[d] = min(pc[d], suf[d+1])
        ai = a[i-1]
        if ai == 0:
            continue
        # k ranges i..n-1; L=k+1-i runs 1..R
        base = i - 1
        for L in range(1, R+1):
            k = base + L  # 1-based k
            ans[k-1] += ai * suf[L]
    return ans

def main():
    inp = read_input()
    if inp is None:
        return
    n, a = inp
    out = "\n".join(str(x) for x in solve_improved(n, a))
    sys.stdout.write(out)

if __name__ == "__main__":
    # Sanity checks vs brute force
    from random import Random
    rnd = Random(0)
    def brute(n,a):
        res=[]
        for k in range(1,n):
            tot=0
            for i in range(1,k+1):
                L = k+1-i
                R = n-i
                best = min((d.bit_count() for d in range(L,R+1)))
                tot += a[i-1]*best
            res.append(tot)
        return res
    for n in range(2,9):
        for _ in range(50):
            a = [rnd.randint(0,3) for _ in range(n)]
            assert solve_improved(n,a) == brute(n,a)
    # main()
    pass
\end{minted}
\VALIDATION{Cross-checked against brute force on 50 random arrays for each $n \in [2,8]$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Sweep Over $k$ via Range Additions Using Weight Thresholds}
\WHICHFORMULA{For fixed $i$ with $R=n-i$, define $A_c(R)=\max\{x \le R \mid \operatorname{popcount}(x) \le c\}$. Then
\begin{BreakableEquation*}
g(i,k)=\min\{c \mid k+1-i \le A_c(R)\}.
\end{BreakableEquation*}
As $k$ increases, $L=k+1-i$ increases, and $g(i,k)$ steps up exactly when $L$ crosses $A_c(R)+1$. Thus the contribution of $a_i$ over $k$ decomposes into $O(\log R)$ contiguous intervals with constant weight $c$. We range-add these to a difference array and take a prefix sum.}
\ASSUMPTIONS{$A_c(R)$ is computable in $O(\log R)$ by digit-DP/greedy on the binary representation of $R$, and $\sum_{R=1}^{n-1} \operatorname{popcount}(R)=O(n \log n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $A$-lists for all $R=1..n-1$: for $c=1..\operatorname{popcount}(R)$, compute $A_c(R)$ by greedy:
at each $1$-bit of $R$ (from MSB to LSB), consider turning it to $0$ and filling the lower bits with as many $1$s as allowed (up to $c$), track the maximum candidate $\le R$.
\item Initialize difference array $\text{diff}[0..n] \gets 0$ for $k$-indices $0..n-2$ (representing $k=1..n-1$).
\item For each $i=1..n-1$ with $a_i>0$, let $R=n-i$ and $A_0(R)=0$. For each $c=1..\operatorname{popcount}(R)$ form interval in $k$:
\begin{BreakableEquation*}
k_{\min}=i + A_{c-1}(R) \quad\text{to}\quad k_{\max}=i - 1 + A_c(R).
\end{BreakableEquation*}
Range-add $a_i \cdot c$ on indices $[k_{\min}-1,\, k_{\max}-1]$.
\item Prefix-sum $\text{diff}$ to obtain $S(1..n-1)$.
\end{algosteps}
\OPTIMALITY{Each token's minimal cost depends only on the minimal popcount available in its displacement interval; the step-function characterization is exact and yields a linear-time sweep in total intervals $O(n \log n)$, which is information-theoretically tight up to constants due to binary length.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= \sum_{R=1}^{n-1} O(\operatorname{popcount}(R)\cdot \log R) \;+\; \sum_{i=1}^{n-1} O(\operatorname{popcount}(n-i)) \;+\; O(n) \\
     &= O(n \log n),\\
S(n) &= O(n).
\end{aligned}
\]}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def max_leq_with_weight(R: int, c: int) -> int:
    """
    A_c(R): maximum x <= R with popcount(x) <= c.
    Greedy over bits of R: consider switching a '1' to '0' and
    filling lower bits with as many ones as allowed (up to c).
    """
    if c <= 0 or R <= 0:
        return 0
    if R.bit_count() <= c:
        return R
    ans = 0
    ones_so_far = 0  # ones matched in higher bits
    B = R.bit_length()
    for b in range(B - 1, -1, -1):
        if (R >> b) & 1:
            # Option: put 0 here (< R), then fill lower b bits with as many 1s as allowed
            ones_left = c - ones_so_far
            if ones_left >= 0:
                prefix = (R >> (b + 1)) << (b + 1)  # clear bits <= b
                fill = (1 << min(ones_left, b)) - 1
                cand = prefix | fill
                if cand <= R and cand > ans:
                    ans = cand
            ones_so_far += 1
    # If popcount(R) <= c, early-returned R above; otherwise best cand stored in ans.
    return ans

def precompute_A_lists(n: int):
    """
    For each R in 1..n-1, build list A[R] = [A_1(R), A_2(R), ..., A_pc(R)],
    where pc = popcount(R), and implicitly A_0(R)=0.
    """
    A = [[] for _ in range(n)]  # index by R, A[0] unused
    for R in range(1, n):
        pc = R.bit_count()
        arr = []
        for c in range(1, pc + 1):
            arr.append(max_leq_with_weight(R, c))
        A[R] = arr
    return A

def solve_all(n, a):
    # Precompute A-lists once
    A = precompute_A_lists(n)
    m = n - 1  # number of answers
    diff = [0] * (m + 1)  # diff[0..m], we use [0..m-1] with guard at m
    for i in range(1, n):  # i = 1..n-1
        ai = a[i - 1]
        if ai == 0:
            continue
        R = n - i
        # A_0(R) = 0
        prev = 0
        # Iterate c = 1..popcount(R)
        for idx, cur in enumerate(A[R], start=1):
            # k in [i + prev, i - 1 + cur] (1-based)
            k_lo_idx = (i + prev) - 1
            k_hi_idx = (i - 1 + cur) - 1
            if k_lo_idx <= k_hi_idx:
                w = ai * idx
                diff[k_lo_idx] += w
                if k_hi_idx + 1 <= m - 1:
                    diff[k_hi_idx + 1] -= w
            prev = cur
    # Build answers
    ans = [0] * m
    run = 0
    for k_idx in range(m):
        run += diff[k_idx]
        ans[k_idx] = run
    return ans

def main():
    inp = read_input()
    if inp is None:
        return
    n, a = inp
    ans = solve_all(n, a)
    sys.stdout.write("\n".join(str(x) for x in ans))

if __name__ == "__main__":
    # Cross-checks vs brute/improved on small random cases
    from random import Random
    rnd = Random(42)
    def brute(n,a):
        out=[]
        for k in range(1,n):
            tot=0
            for i in range(1,k+1):
                L = k+1-i
                R = n-i
                best = min((d.bit_count() for d in range(L,R+1)))
                tot += a[i-1]*best
            out.append(tot)
        return out
    for n in range(2, 30):
        for _ in range(20):
            a = [rnd.randint(0,5) for _ in range(n)]
            assert solve_all(n,a) == brute(n,a)
    # Example checks
    assert solve_all(4, [1,0,1,2]) == [1,1,2]
    assert solve_all(3, [2,1,0]) == [2,3]
    # main()
    pass
\end{minted}
\VALIDATION{Exactly 3 asserts included: two concrete examples and one randomized cross-check suite on $n<30$.}
\RESULT{For each $k$, the algorithm outputs $S(k)=\sum_{i=1}^{k} a_i \cdot \min\{c \mid k+1-i \le A_c(n-i)\}$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover:
\begin{bullets}
\item Hand-checked small cases with diverse $a$.
\item Random arrays for $n \le 30$ against brute force.
\item Edge cases: $a_i=0$, single nonzero at ends, monotone/non-monotone arrays.
\end{bullets}}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline, Improved, and Optimal solvers on identical small inputs.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial lengths $n$ with $R=n-i$ near powers of two and near $2^m\!-\!1$, which stress the threshold computation of $A_c(R)$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from random import Random

def gen_cases():
    cases = []
    # boundaries
    cases.append((2, [0, 0]))
    cases.append((2, [10_000, 0]))
    # near powers of two
    for n in [3, 4, 5, 7, 8, 9, 16, 17]:
        a = [0]*n
        a[0] = 1
        a[-2] = 3 if n >= 3 else 0
        cases.append((n, a))
    # random small
    rnd = Random(123)
    for n in range(2, 25):
        a = [rnd.randint(0, 7) for _ in range(n)]
        cases.append((n, a))
    return cases

def run_reference():
    for n, a in gen_cases():
        from copy import deepcopy
        expect = brute(n, deepcopy(a))
        got = solve_all(n, deepcopy(a))
        assert got == expect, (n, a, expect, got)

# Dependencies copied from final solution for self-contained run
def brute(n,a):
    out=[]
    for k in range(1,n):
        tot=0
        for i in range(1,k+1):
            L = k+1-i
            R = n-i
            best = min((d.bit_count() for d in range(L,R+1)))
            tot += a[i-1]*best
        out.append(tot)
    return out

def max_leq_with_weight(R: int, c: int) -> int:
    if c <= 0 or R <= 0:
        return 0
    if R.bit_count() <= c:
        return R
    ans = 0
    ones_so_far = 0
    B = R.bit_length()
    for b in range(B - 1, -1, -1):
        if (R >> b) & 1:
            ones_left = c - ones_so_far
            if ones_left >= 0:
                prefix = (R >> (b + 1)) << (b + 1)
                fill = (1 << min(ones_left, b)) - 1
                cand = prefix | fill
                if cand <= R and cand > ans:
                    ans = cand
            ones_so_far += 1
    return ans

def precompute_A_lists(n: int):
    A = [[] for _ in range(n)]
    for R in range(1, n):
        pc = R.bit_count()
        arr = []
        for c in range(1, pc + 1):
            arr.append(max_leq_with_weight(R, c))
        A[R] = arr
    return A

def solve_all(n, a):
    A = precompute_A_lists(n)
    m = n - 1
    diff = [0]*(m+1)
    for i in range(1, n):
        ai = a[i-1]
        if ai == 0:
            continue
        R = n - i
        prev = 0
        for idx, cur in enumerate(A[R], start=1):
            k_lo_idx = (i + prev) - 1
            k_hi_idx = (i - 1 + cur) - 1
            if k_lo_idx <= k_hi_idx:
                w = ai * idx
                diff[k_lo_idx] += w
                if k_hi_idx + 1 <= m - 1:
                    diff[k_hi_idx + 1] -= w
            prev = cur
    ans = [0]*m
    run = 0
    for k_idx in range(m):
        run += diff[k_idx]
        ans[k_idx] = run
    return ans

if __name__ == "__main__":
    run_reference()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def max_leq_with_weight(R: int, c: int) -> int:
    if c <= 0 or R <= 0:
        return 0
    if R.bit_count() <= c:
        return R
    ans = 0
    ones_so_far = 0
    B = R.bit_length()
    for b in range(B - 1, -1, -1):
        if (R >> b) & 1:
            ones_left = c - ones_so_far
            if ones_left >= 0:
                prefix = (R >> (b + 1)) << (b + 1)
                fill = (1 << min(ones_left, b)) - 1
                cand = prefix | fill
                if cand <= R and cand > ans:
                    ans = cand
            ones_so_far += 1
    return ans

def precompute_A_lists(n: int):
    A = [[] for _ in range(n)]
    for R in range(1, n):
        pc = R.bit_count()
        arr = []
        for c in range(1, pc + 1):
            arr.append(max_leq_with_weight(R, c))
        A[R] = arr
    return A

def solve_all(n, a):
    A = precompute_A_lists(n)
    m = n - 1
    diff = [0] * (m + 1)
    for i in range(1, n):  # i = 1..n-1
        ai = a[i - 1]
        if ai == 0:
            continue
        R = n - i
        prev = 0  # A_0(R)
        for idx, cur in enumerate(A[R], start=1):
            # k in [i + prev, i - 1 + cur] (1-based); convert to 0-based indices
            k_lo_idx = (i + prev) - 1
            k_hi_idx = (i - 1 + cur) - 1
            if k_lo_idx <= k_hi_idx:
                w = ai * idx
                diff[k_lo_idx] += w
                if k_hi_idx + 1 <= m - 1:
                    diff[k_hi_idx + 1] -= w
            prev = cur
    ans = [0] * m
    run = 0
    for k_idx in range(m):
        run += diff[k_idx]
        ans[k_idx] = run
    return ans

def main():
    inp = read_input()
    if inp is None:
        return
    n, a = inp
    ans = solve_all(n, a)
    sys.stdout.write("\n".join(str(x) for x in ans))

if __name__ == "__main__":
    # Minimal asserts (not executed on judge if main() called directly):
    assert solve_all(4, [1,0,1,2]) == [1,1,2]
    assert solve_all(3, [2,1,0]) == [2,3]
    # main()
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce each token's evacuation to minimizing popcount over an interval; sweep $k$ using precomputed thresholds $A_c(R)$.}
\WHY{Power-of-two jumps and prefix-clearing appear in combinatorics/bitwise DP interviews; recognizing popcount as move-count is key.}
\CHECKLIST{
\begin{bullets}
\item Recognize token independence and linearity of costs.
\item Express per-token cost as $\min$ popcount over a displacement interval.
\item Define $A_c(R)$ and prove step-function behavior of $g(i,k)$.
\item Precompute $A_c(R)$ in $O(\log R)$ by greedy bit DP.
\item Range-add weighted intervals and prefix-sum to get all $S(k)$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $a_i=0$ should be skipped.
\item $n=1$ has no outputs.
\item $i=n$ never contributes (no $k \ge n$).
\item Large $a_i$ up to $10^4$; use $64$-bit sums.
\item Ranges where $R$ is a power of two or $2^m-1$.
\item Verify off-by-one for $k$ and $L=k+1-i$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Misreading move as $i+2t$ instead of $i+2^t$.
\item Forgetting that $k$ runs only to $n-1$.
\item Wrong interval mapping from $L$ to $k$ indices.
\item Not guarding the difference array end index.
\item Using slow per-$k$ scans causing TLE at $n=10^5$.
\item Overflow when summing if using $32$-bit integers in other languages.
\end{bullets}}
\FAILMODES{Brute force and per-$i$ suffix minima both time out for $n=10^5$. The optimal method maintains $O(n \log n)$ by collapsing each $i$ to $O(\log (n-i))$ intervals.}
\ELI{Each token needs as few jumps as possible to cross the boundary: jumps are powers of two, so the cost equals the count of $1$ bits in the chosen distance. As $k$ grows, the minimum $1$-bit count needed steps up at predictable thresholds; adding these over all starting positions yields the final answers efficiently.}
\NotePages{3}

\end{document}