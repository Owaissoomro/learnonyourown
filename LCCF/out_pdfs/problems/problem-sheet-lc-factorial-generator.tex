% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Factorial Generator}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/factorial-generator/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{You are given a nonnegative integer $n$. Return the list $ans$ of length $n{+}1$ such that $ans[i] = i!$ for every $0 \le i \le n$. Here $0! = 1$ by convention. Assume $0 \le n \le 1000$. Languages with arbitrary precision integers should return exact values; in fixed width languages, assume big integer support is available.}
\BREAKDOWN{Compute all factorials from $0!$ through $n!$ inclusive efficiently. Use the recurrence $i! = i \times (i{-}1)!$ with $0! = 1$ and accumulate results in order.}
\ELI{Build the list by starting at $1$ and multiplying by the next integer each time.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single integer $n$ with $0 \le n \le 1000$. In LeetCode form: method parameter \texttt{n: int}.}
\OUTPUTS{A list of length $n{+}1$ where the $i$-th element equals $i!$, i.e., \texttt{List[int]} in Python. The list is in increasing index order from $0!$ to $n!$.}
\SAMPLES{
\begin{bullets}
\item Input: $n=0$; Output: $[1]$.
\item Input: $n=5$; Output: $[1, 1, 2, 6, 24, 120]$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n \in \mathbb{Z}_{\ge 0}$. Define a sequence $(f_i)_{i=0}^{n}$ with $f_0 = 1$ and $f_i = i \cdot f_{i-1}$ for $1 \le i \le n$. Output the vector $(f_0, f_1, \ldots, f_n)$.}
\varmapStart
\var{n}{upper index bound}
\var{f_i}{the factorial value $i!$}
\var{ans}{the list $[f_0, f_1, \ldots, f_n]$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
f_0 &= 1,\\
f_i &= i \cdot f_{i-1} \quad \text{for } 1 \le i \le n.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are zero based. All arithmetic is in unbounded integers, so no overflow occurs.}
\INVARIANTS{
\begin{bullets}
\item After processing index $i$, we have $f_i = i!$ by repeated multiplication.
\item Monotonicity: for $i \ge 1$, $f_i \ge f_{i-1}$.
\item Nonnegativity: $f_i \ge 0$ for all $i$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct definition $i! = i \times (i{-}1)!$ used naively for each $i$ independently.}
\ASSUMPTIONS{Compute $k!$ recursively for each $k$ from $0$ to $n$ without memoization. This repeats work but is simple.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define a recursive function $F(k)$ with $F(0)=1$ and $F(k)=k \cdot F(k{-}1)$.
\item For each $k$ from $0$ to $n$, append $F(k)$ to the answer list.
\item Return the answer list.
\end{algosteps}
\COMPLEXITY{Each $F(k)$ takes $\Theta(k)$ multiplications; summing $k=1$ to $n$ gives $\Theta(n^2)$ time. Space is $O(n)$ for the output plus $O(n)$ maximum recursion depth on the call stack.}
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n} \Theta(k) = \Theta\!\left(\frac{n(n{+}1)}{2}\right) = \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{By definition, $F(k)$ returns $k!$. The answer is $[F(0),F(1),\ldots,F(n)]$, which matches the specification.}
\EDGECASES{Handles $n=0$ returning $[1]$. For large $n$, recursion depth may be a limitation in some languages.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def factorialGenerator(self, n: int) -> List[int]:
        def F(k: int) -> int:
            if k == 0:
                return 1
            return k * F(k - 1)
        return [F(k) for k in range(n + 1)]

# Basic asserts (tiny cases)
s = Solution()
assert s.factorialGenerator(0) == [1]
assert s.factorialGenerator(1) == [1, 1]
assert s.factorialGenerator(5) == [1, 1, 2, 6, 24, 120]
\end{minted}
\VALIDATION{Checked base cases $n=0,1$ and a small composite case $n=5$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Dynamic programming with a running product: compute each $i!$ from $(i{-}1)!$ in $O(1)$ additional work, avoiding recomputation.}
\ASSUMPTIONS{Iterative single pass, no recursion; store results in a list as we go.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \texttt{ans} as an empty list and \texttt{curr = 1} for $0!$.
\item For $i$ from $0$ to $n$:
  \begin{bullets}
  \item If $i=0$, append \texttt{curr} to \texttt{ans}.
  \item Else set \texttt{curr *= i} and append \texttt{curr}.
  \end{bullets}
\item Return \texttt{ans}.
\end{algosteps}
\COMPLEXITY{Runs in $\Theta(n)$ time and uses $O(n)$ space for the output; only $O(1)$ extra working memory beyond the output list.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S(n) = \Theta(n).
\end{aligned}
\]
\CORRECTNESS{Maintains the invariant that after iteration $i$, \texttt{curr} equals $i!$ and \texttt{ans[i]} stores that value.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def factorialGenerator(self, n: int) -> List[int]:
        ans: List[int] = []
        curr = 1  # 0! = 1
        for i in range(0, n + 1):
            if i == 0:
                ans.append(curr)
            else:
                curr *= i
                ans.append(curr)
            # Invariant: ans[i] == i!
        return ans

# Checks on edge inputs
s = Solution()
assert s.factorialGenerator(0) == [1]
assert s.factorialGenerator(2) == [1, 1, 2]
assert s.factorialGenerator(6) == [1, 1, 2, 6, 24, 120, 720]
\end{minted}
\VALIDATION{Validated invariants on $n=0,2,6$; no recursion depth risk.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Single pass iterative DP with preallocation to avoid dynamic list resizing overhead.}
\ASSUMPTIONS{Applicable when $0 \le n \le 1000$ and arbitrary precision integers are available.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Allocate a list \texttt{ans} of length $n{+}1$ filled with $1$.
\item For $i$ from $1$ to $n$, set \texttt{ans[i] = ans[i - 1] * i}.
\item Return \texttt{ans}.
\end{algosteps}
\OPTIMALITY{Computing every factorial value requires at least $\Omega(n)$ multiplications; this method achieves $\Theta(n)$ with minimal constant factors and $O(1)$ extra working memory beyond the output.}
\COMPLEXITY{Time $\Theta(n)$; space $\Theta(n)$ for the output.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S(n) = \Theta(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def factorialGenerator(self, n: int) -> List[int]:
        ans: List[int] = [1] * (n + 1)
        for i in range(1, n + 1):
            ans[i] = ans[i - 1] * i
        return ans

# Exactly 3 asserts
s = Solution()
assert s.factorialGenerator(1) == [1, 1]
assert s.factorialGenerator(5) == [1, 1, 2, 6, 24, 120]
assert s.factorialGenerator(10)[-1] == 3628800
\end{minted}
\VALIDATION{Three asserts including a tail check for $10!$.}
\RESULT{Returns the list $[0!, 1!, \ldots, n!]$ with exact integer values.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover base cases, small $n$, and a moderate $n$ to verify growth. Property: for $n \ge 1$, the ratio \texttt{ans[i] // ans[i-1]} equals $i$ for all $i \in [1,n]$.}
\LINE{CROSS-CHECKS}{Compare outputs from the baseline, improved, and final methods on a set of small $n$ to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Produce deterministic inputs including $0$, $1$, small integers, and a moderate integer such as $20$.}
\begin{minted}{python}
from typing import List, Iterable

def gen_edge_cases() -> Iterable[int]:
    # Deterministic edge and representative cases
    return [0, 1, 2, 5, 10, 20]

def oracle(n: int) -> List[int]:
    ans = [1] * (n + 1)
    for i in range(1, n + 1):
        ans[i] = ans[i - 1] * i
    return ans

def property_check(ans: List[int]) -> bool:
    for i in range(1, len(ans)):
        if ans[i - 1] == 0 or ans[i] // ans[i - 1] != i:
            return False
    return True
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def factorialGenerator(self, n: int) -> List[int]:
        # Preallocate and fill using the recurrence ans[i] = ans[i-1] * i
        ans: List[int] = [1] * (n + 1)
        for i in range(1, n + 1):
            ans[i] = ans[i - 1] * i
        return ans

# Self-checks against the oracle and property
if __name__ == "__main__":
    s = Solution()
    def oracle(n: int) -> List[int]:
        a = [1] * (n + 1)
        for i in range(1, n + 1):
            a[i] = a[i - 1] * i
        return a

    tests = [0, 1, 2, 3, 5, 10, 20]
    for n in tests:
        out = s.factorialGenerator(n)
        assert out == oracle(n)
        # property: ratio test
        for i in range(1, len(out)):
            assert out[i] // out[i - 1] == i
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Generate $[0!,1!,\ldots,n!]$ by a single pass that multiplies by the next index each time.}
\WHY{This pattern appears in warmups and as a subroutine inside combinatorics problems that need factorial tables.}
\CHECKLIST{
\begin{bullets}
\item Confirm $0! = 1$ and include index $0$ in the output.
\item Use iterative DP, not per index recomputation.
\item Preallocate list of size $n{+}1$ if performance matters.
\item Validate invariants: $ans[i] = i \times ans[i{-}1]$.
\item Guard trivial inputs $n=0$ and $n=1$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=0$ should return $[1]$.
\item $n=1$ should return $[1,1]$.
\item Moderate $n$ such as $20$ to verify growth.
\item Very large $n$ in languages without big integers may overflow; problem assumes big integers.
\item Ensure indices are contiguous from $0$ to $n$ with no skips.
\item Avoid trailing or leading extra values beyond $n$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to include $0!$.
\item Using recursion that hits recursion limits.
\item Recomputing each factorial from scratch causing $O(n^2)$ time.
\item Mutating a shared list incorrectly across calls.
\item Integer overflow in fixed width languages if big integers are not used.
\item Off by one in loop bounds, e.g., stopping at $n{-}1$.
\end{bullets}
}
\FAILMODES{The recursive baseline fails for large $n$ due to recursion depth and extra work; the iterative DP avoids both issues and scales linearly.}
\ELI{Start with $1$ for $0!$. Each step, multiply by the next number to get the next factorial and append it. This builds the whole list in order with no wasted work.}
\NotePages{3}

\end{document}