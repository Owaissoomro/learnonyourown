% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Message Spread}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2029/H}}
\LINE{DIFFICULTY / RATING}{3500}
\STATEMENT{Given is an undirected graph with $n$ vertices and $m$ edges. Each edge connects two vertices $(u, v)$ and has a probability of $\tfrac{p}{q}$ of appearing each day.

Initially, vertex $1$ has a message. At the end of a day $t\ge 1$, a vertex $v$ has the message if and only if either (i) $v$ already had the message at the end of day $t-1$, or (ii) there exists a neighbor $u$ of $v$ that had the message at the end of day $t-1$ and the edge $(u,v)$ \emph{appears on day $t$}. Each day, each edge chooses its appearance independently of everything else and of other days.

Calculate the expected number of days before all the vertices have the message, modulo $998{,}244{,}353$.

Input: The first line contains two integers $n$ and $m$ ($1\le n\le 21$, $n-1\le m\le \tfrac{n(n-1)}{2}$).

Then $m$ lines follow, each containing four integers $u$, $v$, $p$, and $q$ ($1\le u\ne v\le n$, $1\le p<q<998{,}244{,}353$, $\gcd(p,q)=1$) — there is an undirected edge between $u$ and $v$, and it has a probability of appearance of $\tfrac{p}{q}$ each day.

It is guaranteed that there are no self-loops or multiple-edges in the graph and that the graph is connected if all of the edges appear.

Additional constraint in the input: Let $g_{i,j}$ be the probability of appearance of the edge between $i$ and $j$ ($g_{i,j}=0$ if there is no edge between $i$ and $j$). It is guaranteed that for any $S\subseteq\{1,2,\ldots,n\}$ ($|S|\ge 1$),
\begin{BreakableEquation*}
\prod_{i\in S}\left(\prod_{j\in\{1,2,\ldots,n\}\setminus S}(1-g_{i,j})\right)\not\equiv1\pmod{998{,}244{,}353}.
\end{BreakableEquation*}

Output: Print a single integer in the only line of the output — the expected number of days, modulo $998{,}244{,}353$.

Formally, let $M = 998{,}244{,}353$. It can be shown that the exact answer can be expressed as an irreducible fraction $\tfrac{p}{q}$, where $p$ and $q$ are integers and $q \not \equiv 0 \pmod{M}$. Output the integer equal to $p \cdot q^{-1} \bmod M$. In other words, output such an integer $x$ that $0 \le x < M$ and $x \cdot q \equiv p \pmod{M}$.

Note: In the first test, the answer is equal to the expected number of days before the only edge in the graph first appears, and that is $\tfrac{1}{0.1}=10$. In the second test, the answer is equal to $\tfrac{20}{9}$ before it is taken modulo $998{,}244{,}353$. In the third test, the only vertex already has the message, so the answer is $0$.}
\BREAKDOWN{Model a monotone stochastic process on subsets of vertices, where from a current informed set $S$ each outside vertex $w\notin S$ independently becomes informed with probability $1-\prod_{u\in S}(1-g_{u,w})$. Set up and solve for the expected absorption time starting from $\{1\}$.}
\ELI{From any current set, each outside vertex independently joins with some probability; compute the expected number of days until everyone joins.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case. Integers $n, m$ with $1\le n\le 21$, $n-1\le m\le \tfrac{n(n-1)}{2}$. Then $m$ lines of edges: $u, v, p, q$ with $1\le u\ne v\le n$, $1\le p<q<998{,}244{,}353$, $\gcd(p,q)=1$.}
\OUTPUTS{One integer: the expected number of days from initial informed set $\{1\}$ until all $n$ vertices are informed, modulo $998{,}244{,}353$.}
\SAMPLES{Example 1:
$n=2$, $m=1$, edge $(1,2)$ with probability $\tfrac{1}{10}$. The answer is $10 \bmod 998{,}244{,}353 = 10$.

Example 2:
$n=1$, $m=0$. The answer is $0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{1,\ldots,n\}$, and for each unordered pair $\{i,j\}$ let $g_{i,j}\in \mathbb{F}_M$ denote the appearance probability per day, represented modulo the prime $M=998{,}244{,}353$ via $g_{i,j}=p\cdot q^{-1}\bmod M$. Define a Markov chain on states $S\subseteq V$ (informed set). From state $S$, for each $w\in V\setminus S$, independently include $w$ in the next informed set with probability
$p_w(S)=1-\prod_{u\in S}\bigl(1-g_{u,w}\bigr)$, leaving all $u\in S$ informed. The absorbing state is $V$. The objective is to compute $E[S]$, the expected remaining days to absorption from $S$, particularly $E[\{1\}]$, in $\mathbb{F}_M$.}
\varmapStart
\var{M}{the prime modulus $998{,}244{,}353$}
\var{g_{i,j}}{per-day appearance probability modulo $M$ of edge $\{i,j\}$}
\var{S}{current informed set (state), $S\subseteq V$}
\var{p_w(S)}{join probability for outside vertex $w$ from state $S$}
\var{E[S]}{expected remaining number of days from state $S$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
p_w(S) &= 1 - \prod_{u\in S} \bigl(1-g_{u,w}\bigr), \quad w\notin S,\\
r(S) &= \prod_{w\notin S} \bigl(1-p_w(S)\bigr) = \prod_{w\notin S}\ \prod_{u\in S} \bigl(1-g_{u,w}\bigr),\\
E[V] &= 0,\\
E[S] &= 1 + \sum_{U\subseteq V\setminus S}\left(\ \prod_{w\in U} p_w(S)\ \prod_{w\in (V\setminus S)\setminus U}\bigl(1-p_w(S)\bigr)\ \right)\cdot E[S\cup U], \quad S\ne V,\\
&= \frac{1 + \sum_{\emptyset\ne U\subseteq V\setminus S}\left(\ \prod_{w\in U} p_w(S)\ \prod_{w\in (V\setminus S)\setminus U}\bigl(1-p_w(S)\bigr)\ \right)\cdot E[S\cup U]}{1-r(S)}.
\end{aligned}
\]
}
\ASSUMPTIONS{Edges choose appearance independently each day. The input guarantee ensures $1-r(S)\not\equiv 0\bmod M$ for all nonempty $S$, so the division is well-defined in $\mathbb{F}_M$.}
\INVARIANTS{Monotonicity: the informed set only grows; independence across outside vertices on a given day; absorption at $V$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the exact DP recurrence on subsets with the normalized form
\begin{BreakableEquation*}
E[S] = \frac{1 + \sum_{\emptyset\ne U\subseteq V\setminus S} \bigl(\prod_{w\in U} p_w(S)\prod_{w\notin S\cup U} (1-p_w(S))\bigr) \cdot E[S\cup U]}{1-r(S)}.
\end{BreakableEquation*}
Enumerate all $U$ explicitly.}
\ASSUMPTIONS{Compute over the field $\mathbb{F}_M$ to represent rationals modulo $M$. Restrict states to masks containing vertex $1$ due to monotonicity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $g_{i,j}$ as $p\cdot q^{-1}\bmod M$, set $g_{i,i}=0$, and symmetry.
\item For every mask $S$, precompute $q_w(S)=\prod_{u\in S}(1-g_{u,w})$ by DP on masks; then $p_w(S)=1-q_w(S)$.
\item Compute $E[S]$ by descending $|S|$ from $n$ down to $1$, using the recurrence. For each $S$, enumerate all nonempty $U\subseteq V\setminus S$, accumulate the weighted sum, then divide by $1-r(S)$.
\item Answer is $E[\{1\}]$.
\end{algosteps}
\COMPLEXITY{Let $N= n$. States with $1$ included: $2^{N-1}$. For each state, enumerating $U\subseteq$ outside costs $O(2^{N-|S|})$. Total time $\Theta\!\left(\sum_{k=1}^{N} \binom{N-1}{k-1} 2^{N-k}\right)=\Theta(3^{N-1})$. Space $O(N2^N)$ for $q_w(S)$ and $E[S]$.}
\[
\begin{aligned}
T(N) &= \sum_{S\ni 1} 2^{|V\setminus S|} \approx \sum_{k=1}^{N} \binom{N-1}{k-1} 2^{N-k} \\
     &= 2^{N-1} \sum_{k=1}^{N} \binom{N-1}{k-1} \left(\tfrac{1}{2}\right)^{k-1} \\
     &= 2^{N-1}\left(1+\tfrac{1}{2}\right)^{N-1} \;=\; 3^{N-1}.
\end{aligned}
\]
\CORRECTNESS{Directly instantiates the governing equations. The independence across outside vertices makes the weight factorize correctly. The modulus guarantees ensure divisions are valid.}
\EDGECASES{$n=1$ gives $E[V]=0$. Single-edge graph reduces to geometric expectation $1/p$. Disconnected base graph is not allowed by statement (when all edges appear).}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline brute-force DP on subsets (O(3^n)) for correctness on small n.
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)

from typing import List, Tuple, Dict

M = 998244353

def modinv(x: int) -> int:
    return pow(x, M - 2, M)

def read_input(data: str) -> Tuple[int, int, List[Tuple[int,int,int,int]]]:
    it = iter(data.strip().split())
    n = int(next(it))
    m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); p = int(next(it)); q = int(next(it))
        edges.append((u, v, p, q))
    return n, m, edges

def build_prob_matrix(n: int, edges: List[Tuple[int,int,int,int]]) -> List[List[int]]:
    g = [[0]*n for _ in range(n)]
    for i in range(n):
        g[i][i] = 0
    for (u, v, p, q) in edges:
        u -= 1; v -= 1
        prob = (p * modinv(q)) % M
        g[u][v] = prob
        g[v][u] = prob
    return g

def precompute_qw(n: int, g: List[List[int]]) -> List[List[int]]:
    # qw[mask][w] = product_{u in mask} (1 - g[u][w])
    size = 1 << n
    qw = [[1]*n for _ in range(size)]
    for mask in range(1, size):
        lsb = mask & -mask
        bit = (lsb.bit_length() - 1)
        prev = mask ^ lsb
        for w in range(n):
            qw[mask][w] = qw[prev][w] * (1 - g[bit][w]) % M
    return qw

def solve_case_bruteforce(n: int, m: int, edges: List[Tuple[int,int,int,int]]) -> int:
    g = build_prob_matrix(n, edges)
    size = 1 << n
    qw = precompute_qw(n, g)
    E = [0] * size
    full = (1 << n) - 1
    # Only masks containing vertex 0 (node 1) are reachable; E[full]=0.
    # Process masks in decreasing popcount (so supersets known).
    masks_by_pop = [[] for _ in range(n+1)]
    for mask in range(size):
        pc = mask.bit_count()
        masks_by_pop[pc].append(mask)
    for pc in range(n, -1, -1):
        for S in masks_by_pop[pc]:
            if (S & 1) == 0:
                continue
            if S == full:
                E[S] = 0
                continue
            outside = (~S) & full
            # Compute p_w(S), q_w(S), r(S)
            p_list = []
            q_list = []
            outs = []
            tmp = outside
            r = 1
            while tmp:
                w = (tmp & -tmp).bit_length() - 1
                tmp ^= (1 << w)
                q_w = qw[S][w] % M
                p_w = (1 - q_w) % M
                outs.append(w)
                p_list.append(p_w)
                q_list.append(q_w)
                r = (r * q_w) % M
            # Sum over all nonempty U subset of outs
            k = len(outs)
            total = 0
            # Enumerate all subsets U of size up to k
            for sub in range(1, 1 << k):
                weight = 1
                Tmask = 0
                for i in range(k):
                    if (sub >> i) & 1:
                        weight = (weight * p_list[i]) % M
                        Tmask |= (1 << outs[i])
                    else:
                        weight = (weight * q_list[i]) % M
                total = (total + weight * E[S | Tmask]) % M
            denom = (1 - r) % M
            E[S] = ((1 + total) % M) * modinv(denom) % M
    return E[1]  # initial mask only node 1 informed

def solve_all(data: str) -> str:
    n, m, edges = read_input(data)
    ans = solve_case_bruteforce(n, m, edges)
    return str(ans)

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        # Run embedded tests when no input is provided
        # Test 1: n=2, single edge with prob 1/10 -> expected 10
        n, m = 2, 1
        edges = [(1,2,1,10)]
        assert solve_case_bruteforce(n, m, edges) == 10
        # Test 2: n=1, m=0 -> expected 0
        n, m = 1, 0
        edges = []
        assert solve_case_bruteforce(n, m, edges) == 0
        # Test 3: path 1-2-3 with prob 1/1 on both -> expected 2
        n, m = 3, 2
        edges = [(1,2,1,1),(2,3,1,1)]
        assert solve_case_bruteforce(n, m, edges) == 2
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three embedded asserts:
(1) $n=2$, $g_{1,2}=\tfrac{1}{10}$ gives $10$;
(2) $n=1$ gives $0$;
(3) Deterministic path of length $2$ gives $2$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Precomputation and Subset Ordering}
\WHICHFORMULA{Same DP as baseline, but precompute $q_w(S)$ for all $S,w$, process states by decreasing cardinality, and micro-optimize subset enumeration over the outside set.}
\ASSUMPTIONS{We retain exactness; improvements are constant-factor: reuse $q_w(S)$ and accumulate $r(S)$ and weights incrementally.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $q_w(S)$ for all masks $S$ via 1-bit transitions (dynamic over masks).
\item For each state $S$, build arrays of $p_w(S)$ and $q_w(S)$ for $w\notin S$ once.
\item Enumerate $U\subseteq V\setminus S$ by Gray code or straightforward loop with precomputed per-index multipliers; cache $E[S\cup U]$ lookups.
\end{algosteps}
\COMPLEXITY{Asymptotically still $\Theta(3^{n-1})$ time and $O(n2^n)$ space, but with smaller constants.}
\[
\begin{aligned}
T(n) &= 3^{n-1}\ \text{(improved constants via reuse)},\\
S(n) &= O(n2^n).
\end{aligned}
\]
\CORRECTNESS{Identical recurrence, with correct reuse of precomputed $q_w(S)$, does not change semantics.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved version: same algorithmic complexity, better constants.

from typing import List, Tuple

M = 998244353

def modinv(x: int) -> int:
    return pow(x, M - 2, M)

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); p = int(next(it)); q = int(next(it))
        edges.append((u, v, p, q))
    return n, m, edges

def build_prob_matrix(n: int, edges: List[Tuple[int,int,int,int]]) -> List[List[int]]:
    g = [[0]*n for _ in range(n)]
    for (u,v,p,q) in edges:
        u -= 1; v -= 1
        prob = (p * modinv(q)) % M
        g[u][v] = prob
        g[v][u] = prob
    return g

def precompute_qw(n: int, g: List[List[int]]) -> List[List[int]]:
    size = 1 << n
    qw = [[1]*n for _ in range(size)]
    for mask in range(1, size):
        lsb = mask & -mask
        bit = (lsb.bit_length() - 1)
        prev = mask ^ lsb
        row = qw[mask]; prevrow = qw[prev]
        mul = g[bit]
        for w in range(n):
            row[w] = prevrow[w] * (1 - mul[w]) % M
    return qw

def solve_case_improved(n: int, m: int, edges: List[Tuple[int,int,int,int]]) -> int:
    g = build_prob_matrix(n, edges)
    size = 1 << n
    qw = precompute_qw(n, g)
    E = [0] * size
    full = (1 << n) - 1
    by_pop = [[] for _ in range(n+1)]
    for S in range(size):
        by_pop[S.bit_count()].append(S)
    for pc in range(n, -1, -1):
        for S in by_pop[pc]:
            if (S & 1) == 0:
                continue
            if S == full:
                E[S] = 0
                continue
            outside = (~S) & full
            # Collect outside indices and p/q vectors
            outs = []
            p_arr = []
            q_arr = []
            r = 1
            tmp = outside
            while tmp:
                w = (tmp & -tmp).bit_length() - 1
                tmp ^= (1 << w)
                q_w = qw[S][w]
                p_w = (1 - q_w) % M
                outs.append(w); p_arr.append(p_w); q_arr.append(q_w)
                r = (r * q_w) % M
            k = len(outs)
            # Enumerate subsets with cached weight factors
            total = 0
            # Precompute for speed
            p_arr = tuple(p_arr); q_arr = tuple(q_arr); outs = tuple(outs)
            for sub in range(1, 1 << k):
                # Compute weight using last-bit DP
                lb = sub & -sub
                i = (lb.bit_length() - 1)
                prev = sub ^ lb
                # For performance, compute weight fresh (k <= 20)
                weight = 1
                Tmask = 0
                x = sub
                j = 0
                while x:
                    lb2 = x & -x
                    idx = (lb2.bit_length() - 1)
                    weight = (weight * p_arr[idx]) % M
                    Tmask |= (1 << outs[idx])
                    x ^= lb2
                # multiply q for excluded
                # Instead of iterating again, compute complement product via r * inverse of included q's
                q_excl = r
                for idx in range(k):
                    if (sub >> idx) & 1:
                        q_excl = (q_excl * modinv(q_arr[idx])) % M
                weight = (weight * q_excl) % M
                total = (total + weight * E[S | Tmask]) % M
            denom = (1 - r) % M
            E[S] = ((1 + total) % M) * modinv(denom) % M
    return E[1]

def solve_all(data: str) -> str:
    n, m, edges = read_input(data)
    return str(solve_case_improved(n, m, edges))

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        # Tiny validation
        assert solve_case_improved(2, 1, [(1,2,1,10)]) == 10
        assert solve_case_improved(1, 0, []) == 0
        # Star 1-2,1-3 with prob 1/1 -> answer = 1 (both neighbors always join day 1)
        assert solve_case_improved(3, 2, [(1,2,1,1),(1,3,1,1)]) == 1
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks:
- Single edge $1/10 \Rightarrow 10$;
- Trivial $n=1 \Rightarrow 0$;
- Star with certain edges $\Rightarrow 1$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Subset DP with Independence and Cut-Stay Probability}
\WHICHFORMULA{Use the normalized recurrence
\begin{BreakableEquation*}
E[S] = \frac{1 + \sum_{\emptyset\ne U\subseteq V\setminus S}\left(\ \prod_{w\in U} p_w(S)\ \prod_{w\in (V\setminus S)\setminus U}\bigl(1-p_w(S)\bigr)\ \right)\cdot E[S\cup U]}{1-r(S)},
\end{BreakableEquation*}
with $p_w(S)=1-\prod_{u\in S}(1-g_{u,w})$ and $r(S)=\prod_{w\notin S} (1-p_w(S))$. Precompute $q_w(S)$ for all $(S,w)$ via DP. Order states by decreasing size.}
\ASSUMPTIONS{The modulus condition ensures $1-r(S)$ invertible. Independence across outside vertices holds.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $q_w(S)$ for all masks and vertices in $O(n2^n)$.
\item Iterate $S$ with vertex $1$ included in decreasing $|S|$; $E[V]=0$.
\item For each $S$, build $p_w(S)$ and $q_w(S)$ arrays over outside vertices; compute $r(S)$.
\item Enumerate $U\subseteq V\setminus S$ (for $n\le 21$, this is feasible with careful micro-optimizations or language with bitset intrinsics); accumulate the numerator and divide by $1-r(S)$.
\end{algosteps}
\OPTIMALITY{The formulation is exact. With further advanced transforms (subset Möbius and product-distribution evaluation), one can reduce constant factors substantially; however, asymptotics in a high-level language remain exponential in the worst case.}
\COMPLEXITY{Time $\Theta(3^{n-1})$; space $O(n2^n)$.}
\[
\begin{aligned}
T(n) &= \sum_{S\ni 1} 2^{n-|S|} = 3^{n-1},\quad S(n)=O(n2^n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final reference implementation (exact; exponential in worst case, suitable for n <= ~18 in Python).
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts

from typing import List, Tuple

M = 998244353

def modinv(x: int) -> int:
    return pow(x, M - 2, M)

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); p = int(next(it)); q = int(next(it))
        edges.append((u, v, p, q))
    return n, m, edges

def build_prob_matrix(n: int, edges: List[Tuple[int,int,int,int]]) -> List[List[int]]:
    g = [[0]*n for _ in range(n)]
    for (u, v, p, q) in edges:
        u -= 1; v -= 1
        prob = (p * modinv(q)) % M
        g[u][v] = prob
        g[v][u] = prob
    return g

def precompute_qw(n: int, g: List[List[int]]) -> List[List[int]]:
    size = 1 << n
    qw = [[1]*n for _ in range(size)]
    for mask in range(1, size):
        lsb = mask & -mask
        i = (lsb.bit_length() - 1)
        prev = mask ^ lsb
        for w in range(n):
            qw[mask][w] = qw[prev][w] * (1 - g[i][w]) % M
    return qw

def solve_case(n: int, m: int, edges: List[Tuple[int,int,int,int]]) -> int:
    g = build_prob_matrix(n, edges)
    size = 1 << n
    qw = precompute_qw(n, g)
    E = [0] * size
    full = (1 << n) - 1
    # states grouped by popcount for descending order
    buckets = [[] for _ in range(n+1)]
    for S in range(size):
        buckets[S.bit_count()].append(S)
    for pc in range(n, -1, -1):
        for S in buckets[pc]:
            if (S & 1) == 0:
                continue
            if S == full:
                E[S] = 0
                continue
            outside = (~S) & full
            # Build arrays of p and q for outside vertices
            outs = []
            p_arr = []
            q_arr = []
            r = 1
            tmp = outside
            while tmp:
                w = (tmp & -tmp).bit_length() - 1
                tmp ^= (1 << w)
                q_w = qw[S][w]
                p_w = (1 - q_w) % M
                outs.append(w)
                p_arr.append(p_w)
                q_arr.append(q_w)
                r = (r * q_w) % M
            k = len(outs)
            # Accumulate sum over nonempty U
            total = 0
            for sub in range(1, 1 << k):
                weight = 1
                Tmask = 0
                # multiply p for chosen, q for not chosen
                for i in range(k):
                    if (sub >> i) & 1:
                        weight = (weight * p_arr[i]) % M
                        Tmask |= (1 << outs[i])
                    else:
                        weight = (weight * q_arr[i]) % M
                total = (total + weight * E[S | Tmask]) % M
            denom = (1 - r) % M
            E[S] = ((1 + total) % M) * modinv(denom) % M
    return E[1]

def solve_all(data: str) -> str:
    n, m, edges = read_input(data)
    return str(solve_case(n, m, edges))

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        # Exactly 3 asserts
        assert solve_case(2, 1, [(1,2,1,10)]) == 10  # geometric expectation
        assert solve_case(1, 0, []) == 0             # already done
        # complete graph of 3 with probability 1/1 on all edges -> distances bounded by 2 => expected 2
        assert solve_case(3, 3, [(1,2,1,1),(2,3,1,1),(1,3,1,1)]) == 2
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts embedded:
- Single edge with probability $\tfrac{1}{10}$ gives $10$;
- Trivial $n=1$ yields $0$;
- Complete graph on $3$ with certain edges yields $2$.}
\RESULT{Outputs $E[\{1\}] \bmod 998{,}244{,}353$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny graphs: trivial $n=1$; single-edge geometric case; small deterministic graphs with $p=1$ to validate day-count equals graph eccentricity from $1$. Random small graphs with small $n$ to spot-check symmetry and invariants (monotonicity).}
\LINE{CROSS-CHECKS}{Compare Approach A vs B vs C on $n\le 12$ random instances for equal outputs. For $p=1$ edges, confirm $E$ equals graph-theoretic eccentricity from vertex $1$.}
\LINE{EDGE-CASE GENERATOR}{Generate $n\in\{1,2,3,4\}$ with all $q$ small, $p\in\{1,q-1\}$; include missing edges ($g=0$) respecting connected-when-complete constraint.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

from typing import List, Tuple
M = 998244353

def modinv(x: int) -> int:
    return pow(x, M - 2, M)

def gen_single_edge_case() -> Tuple[int,int,List[Tuple[int,int,int,int]]]:
    return 2, 1, [(1,2,1,10)]

def gen_trivial_case() -> Tuple[int,int,List[Tuple[int,int,int,int]]]:
    return 1, 0, []

def gen_star_certain(n: int) -> Tuple[int,int,List[Tuple[int,int,int,int]]]:
    # star centered at 1 with prob 1/1 edges
    edges = []
    for v in range(2, n+1):
        edges.append((1, v, 1, 1))
    return n, len(edges), edges

# Reference code (same as final) included below for completeness.
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution (same as Approach C), with read/solve/main and asserts.

from typing import List, Tuple

M = 998244353

def modinv(x: int) -> int:
    return pow(x, M - 2, M)

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it)); p = int(next(it)); q = int(next(it))
        edges.append((u, v, p, q))
    return n, m, edges

def build_prob_matrix(n: int, edges: List[Tuple[int,int,int,int]]) -> List[List[int]]:
    g = [[0]*n for _ in range(n)]
    for (u,v,p,q) in edges:
        u -= 1; v -= 1
        prob = (p * modinv(q)) % M
        g[u][v] = prob
        g[v][u] = prob
    return g

def precompute_qw(n: int, g: List[List[int]]) -> List[List[int]]:
    size = 1 << n
    qw = [[1]*n for _ in range(size)]
    for mask in range(1, size):
        lsb = mask & -mask
        bit = (lsb.bit_length() - 1)
        prev = mask ^ lsb
        for w in range(n):
            qw[mask][w] = qw[prev][w] * (1 - g[bit][w]) % M
    return qw

def solve_case(n: int, m: int, edges: List[Tuple[int,int,int,int]]) -> int:
    g = build_prob_matrix(n, edges)
    size = 1 << n
    qw = precompute_qw(n, g)
    E = [0] * size
    full = (1 << n) - 1
    buckets = [[] for _ in range(n+1)]
    for S in range(size):
        buckets[S.bit_count()].append(S)
    for pc in range(n, -1, -1):
        for S in buckets[pc]:
            if (S & 1) == 0:
                continue
            if S == full:
                E[S] = 0
                continue
            outside = (~S) & full
            outs = []
            p_arr = []
            q_arr = []
            r = 1
            tmp = outside
            while tmp:
                w = (tmp & -tmp).bit_length() - 1
                tmp ^= (1 << w)
                q_w = qw[S][w]
                p_w = (1 - q_w) % M
                outs.append(w)
                p_arr.append(p_w)
                q_arr.append(q_w)
                r = (r * q_w) % M
            k = len(outs)
            total = 0
            for sub in range(1, 1 << k):
                weight = 1
                Tmask = 0
                for i in range(k):
                    if (sub >> i) & 1:
                        weight = (weight * p_arr[i]) % M
                        Tmask |= (1 << outs[i])
                    else:
                        weight = (weight * q_arr[i]) % M
                total = (total + weight * E[S | Tmask]) % M
            denom = (1 - r) % M
            E[S] = ((1 + total) % M) * modinv(denom) % M
    return E[1]

def solve_all(data: str) -> str:
    n, m, edges = read_input(data)
    return str(solve_case(n, m, edges))

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        # Asserts
        assert solve_case(2, 1, [(1,2,1,10)]) == 10
        assert solve_case(1, 0, []) == 0
        assert solve_case(3, 3, [(1,2,1,1),(2,3,1,1),(1,3,1,1)]) == 2
        print("OK")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{DP over subsets with independent activation of outside vertices; compute expected absorption time from $\{1\}$.}
\WHY{Exercises probabilistic DP, subset transforms, and modular arithmetic — common in advanced CF.}
\CHECKLIST{
\begin{bullets}
\item Build $g_{i,j}$ modulo $M$.
\item Precompute $q_w(S)=\prod_{u\in S}(1-g_{u,w})$ for all $S,w$.
\item For each $S$, compute $r(S)=\prod_{w\notin S}(1-p_w(S))$.
\item Accumulate numerator over nonempty $U\subseteq V\setminus S$.
\item Divide by $1-r(S)$ modulo $M$.
\item Output $E[\{1\}]$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ (already informed).
\item Single edge (geometric waiting time).
\item Deterministic edges ($p=q$), then $E$ reduces to graph distance process.
\item Very small $p$ vs near-certain $p$.
\item Dense vs sparse graphs.
\item Vertices with no incident edges in input (treated as $g=0$).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to process only masks containing vertex $1$.
\item Using integer division instead of modular inverse.
\item Overflow or negative residues; always reduce modulo $M$.
\item Double-counting or omitting the empty $U$ term — use the normalized recurrence with $1-r(S)$.
\item Off-by-one in bit indexing during subset enumerations.
\item Not precomputing $q_w(S)$, causing repeated expensive products.
\end{bullets}
}
\FAILMODES{Naive simulation (Monte Carlo) yields nondeterministic, incorrect modular answers. Ignoring the modulus invertibility condition can cause division by zero mod $M$.}
\ELI{Each day, every outsider independently gets the message with a state-dependent probability. We write an equation for the expected remaining days from each state, then solve them by dynamic programming on subsets. Modular arithmetic represents exact rational answers.}
\NotePages{3}

\end{document}