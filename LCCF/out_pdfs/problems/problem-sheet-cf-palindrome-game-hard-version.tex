% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Palindrome Game (hard version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1527/B2}}
\LINE{DIFFICULTY / RATING}{1900}
\STATEMENT{The only difference between the easy and hard versions is that the given string $s$ in the easy version is initially a palindrome, this condition is not always true for the hard version.

A palindrome is a string that reads the same left to right and right to left. For example, ``101101'' is a palindrome, while ``0101'' is not.

Alice and Bob are playing a game on a string $s$ of length $n$ consisting of the characters `0' and `1'. Both players take alternate turns with Alice going first.

In each turn, the player can perform one of the following operations:
\begin{enumerate}
\item Choose any $i$ ($1 \le i \le n$), where $s[i] = $ `0' and change $s[i]$ to `1'. Pay 1 dollar.
\item Reverse the whole string, pay 0 dollars. This operation is only allowed if the string is currently not a palindrome, and the last operation was not reverse. That is, if Alice reverses the string, then Bob cannot reverse in the next move, and vice versa.
\end{enumerate}

Reversing a string means reordering its letters from the last to the first. For example, ``01001'' becomes ``10010'' after reversing.

The game ends when every character of string becomes `1'. The player who spends minimum dollars till this point wins the game and it is a draw if both spend equal dollars. If both players play optimally, output whether Alice wins, Bob wins, or if it is a draw.

Input:
The first line contains a single integer $t$ ($1 \le t \le 10^3$). Then $t$ test cases follow.

The first line of each test case contains a single integer $n$ ($1 \le n \le 10^3$).

The second line of each test case contains the string $s$ of length $n$, consisting of the characters `0' and `1'. It is guaranteed that the string $s$ contains at least one `0'.

Note that there is no limit on the sum of $n$ over test cases.

Output:
For each test case print a single word in a new line:
\begin{itemize}
\item ``ALICE'', if Alice will win the game,
\item ``BOB'', if Bob will win the game,
\item ``DRAW'', if the game ends in a draw.
\end{itemize}

Note:
In the first test case of example,
\begin{itemize}
\item in the $1$-st move, Alice will use the $2$-nd operation to reverse the string, since doing the $1$-st operation will result in her loss anyway. This also forces Bob to use the $1$-st operation.
\item in the $2$-nd move, Bob has to perform the $1$-st operation, since the $2$-nd operation cannot be performed twice in a row. All characters of the string are `1', game over.
\end{itemize}

In the second test case of example,
\begin{itemize}
\item in the $1$-st move Alice has to perform the $1$-st operation, since the string is currently a palindrome.
\item in the $2$-nd move Bob reverses the string.
\item in the $3$-rd move Alice again has to perform the $1$-st operation. All characters of the string are `1', game over.
\end{itemize}}
\BREAKDOWN{Compute counts that determine the outcome under optimal play: the number of zeros and the number of mismatched symmetric pairs. Use a small case distinction to decide ALICE vs BOB vs DRAW.}
\ELI{Count how many mismatched pairs and how many zeros exist; if there is any mismatch Alice almost always wins, except a single special draw case; otherwise use the easy-version rule on palindromes.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.
\begin{bullets}
\item $t$: integer, $1 \le t \le 10^3$.
\item For each test: $n$: integer, $1 \le n \le 10^3$.
\item $s$: binary string of length $n$ with at least one `0'.
\end{bullets}}
\OUTPUTS{For each test case, print exactly one of ALICE, BOB, DRAW on its own line, describing the winner under optimal play.}
\SAMPLES{Example 1:
\begin{tcolorbox}
Input
\begin{verbatim}
2
5
01011
3
010
\end{verbatim}
Output
\begin{verbatim}
DRAW
BOB
\end{verbatim}
\end{tcolorbox}
Explanation: In the first test, it is the unique special draw case. In the second, the string is a palindrome with two zeros but no middle zero; Bob wins.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $s \in \{0,1\}^n$, define:
\[
z = \#\{i : s_i = 0\},\quad
m = \#\{i : 1 \le i \le \lfloor n/2 \rfloor,\ s_i \ne s_{n+1-i}\}.
\]
The outcome is a function $\mathrm{win}(s) \in \{\text{ALICE}, \text{BOB}, \text{DRAW}\}$ determined by $(z,m)$ and the middle character if $n$ is odd.}
\varmapStart
\var{n}{string length}
\var{s}{binary string}
\var{z}{number of zeros in $s$}
\var{m}{number of mismatched symmetric pairs}
\var{c}{middle character when $n$ is odd; undefined otherwise}
\varmapEnd
\GOVERN{
\[
\mathrm{win}(s)=
\begin{cases}
\text{BOB}, & m=0\ \wedge\ z=1,\\
\text{ALICE}, & m=0\ \wedge\ (n\ \text{odd})\ \wedge\ s_{\frac{n+1}{2}}=0\ \wedge\ z\ge 3\ \text{and}\ z\ \text{odd},\\
\text{BOB}, & m=0\ \text{ and not the above},\\[4pt]
\text{DRAW}, & m=1\ \wedge\ (n\ \text{odd})\ \wedge\ s_{\frac{n+1}{2}}=0\ \wedge\ z=2,\\
\text{ALICE}, & \text{otherwise (i.e., } m>0\ \text{and not the special draw).}
\end{cases}
\]
}
\ASSUMPTIONS{Standard zero-based or one-based indexing is fine as long as symmetry pairs $(i,n+1-i)$ are consistent. At least one zero exists in $s$.}
\INVARIANTS{
\begin{bullets}
\item Each mismatched pair requires exactly one future $0 \to 1$ flip to become matched (turns it into `11').
\item A reverse is free but only usable when $m>0$ and not twice consecutively; its sole effect is to pass turn advantage.
\item When $m=0$, the game reduces to the easy version with no useful reverses.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate counts: total zeros $z$ and mismatches $m$. Decide via a small case analysis derived from the editorial game theory.}
\ASSUMPTIONS{We assume optimal play; the reverse move only matters to flip initiative when $m>0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $z$ and $m$ in $O(n)$.
\item If $m=0$ (palindrome), return BOB if $z=1$, return ALICE if $n$ odd, center is `0', and $z$ is odd ($\ge 3$), else BOB.
\item If $m>0$, return DRAW only in the special case $m=1$, $n$ odd, center is `0', and $z=2$; otherwise ALICE.
\end{algosteps}
\COMPLEXITY{Each test scans $s$ once.}
\[
\begin{aligned}
T(n) &= O(n) \\
S(n) &= O(1)
\end{aligned}
\]
\CORRECTNESS{Mismatches force one paid flip each; reverses cannot change $z$ or $m$, only turn order. The known optimal-play outcomes collapse to the stated cases.}
\EDGECASES{All ones is excluded by input. Single zero in a palindrome yields BOB. The unique draw: exactly one mismatch, exactly two zeros with a middle zero.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def outcome(s: str) -> str:
    n = len(s)
    z = s.count('0')
    m = sum(1 for i in range(n // 2) if s[i] != s[n - 1 - i])
    if m == 0:
        if z == 1:
            return "BOB"
        # odd-length center matters only if it's zero; then parity of zeros decides
        if n % 2 == 1 and s[n // 2] == '0' and z % 2 == 1:
            return "ALICE"
        return "BOB"
    # m > 0
    if n % 2 == 1 and s[n // 2] == '0' and z == 2 and m == 1:
        return "DRAW"
    return "ALICE"

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(t):
        n = int(next(it))
        s = next(it)
        assert len(s) == n
        tests.append(s)
    return t, tests

def solve_case(s: str) -> str:
    return outcome(s)

def solve_all(tests):
    return [solve_case(s) for s in tests]

def main():
    # basic asserts (unit checks)
    assert outcome("0") == "BOB"
    assert outcome("01") == "ALICE"
    assert outcome("010") == "BOB"
    assert outcome("01011") == "DRAW"
    data = sys.stdin.read()
    if data.strip():
        t, tests = read_input(data)
        ans = solve_all(tests)
        sys.stdout.write("\n".join(ans))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked tiny palindromes and the special draw input. Compared behavior when $m=0$ to the easy-version rule.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{No complex data structure is needed; the improvement is purely the direct formula in $O(n)$ without any simulation of moves.}
\ASSUMPTIONS{Only $(z,m)$ and the middle character influence optimal play; reverses are only tempo moves.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item One pass: count $z$ and $m$; read middle bit if $n$ is odd.
\item Apply the explicit decision tree.
\item Print the winner string.
\end{algosteps}
\COMPLEXITY{Linear time, constant memory; identical asymptotics but minimal constant factors.}
\[
\begin{aligned}
T(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{Follows from standard analysis: each mismatch consumes one dollar eventually; reverse exists to neutralize advantage, producing the sole draw case when that neutralization is exact.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def outcome(s: str) -> str:
    n = len(s)
    z = s.count('0')
    m = sum(1 for i in range(n // 2) if s[i] != s[n - 1 - i])
    if m == 0:
        if z == 1:
            return "BOB"
        if n % 2 == 1 and s[n // 2] == '0' and z % 2 == 1:
            return "ALICE"
        return "BOB"
    if n % 2 == 1 and s[n // 2] == '0' and z == 2 and m == 1:
        return "DRAW"
    return "ALICE"

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(t):
        n = int(next(it))
        s = next(it)
        tests.append(s)
    return t, tests

def solve_case(s: str) -> str:
    return outcome(s)

def solve_all(tests):
    return [solve_case(s) for s in tests]

def main():
    # edge-input checks
    assert outcome("0001") == "ALICE"  # m>0, not special
    assert outcome("1110") == "ALICE"  # one zero, m=1
    assert outcome("11011") == "BOB"   # palindrome, single middle zero
    data = sys.stdin.read()
    if data.strip():
        t, tests = read_input(data)
        print("\n".join(solve_all(tests)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts cover non-palindrome generic, single middle zero, and small even strings.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Closed-form case analysis on $(z,m)$ with one special draw case: $m=1$, $z=2$, odd $n$ and middle zero. Otherwise, when $m>0$, ALICE wins; when $m=0$, reduce to easy-version outcome.}
\ASSUMPTIONS{Players are optimal; reverse cannot be repeated and is only available when $m>0$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count $z$ and $m$ in one pass.
\item If $m=0$, apply easy-case rule: $z=1 \Rightarrow$ BOB; else if middle zero and $z$ odd $\Rightarrow$ ALICE; else BOB.
\item If $m>0$, check the single special draw, else ALICE.
\end{algosteps}
\OPTIMALITY{This matches known editorial results and is tight: no faster-than-$O(n)$ approach exists in the unit-cost RAM without additional structure since all bits may influence $(z,m)$.}
\COMPLEXITY{Linear time, constant extra space.}
\[
\begin{aligned}
T(n) &= O(n)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def outcome(s: str) -> str:
    n = len(s)
    z = s.count('0')
    m = sum(1 for i in range(n // 2) if s[i] != s[n - 1 - i])
    if m == 0:
        if z == 1:
            return "BOB"
        if n % 2 == 1 and s[n // 2] == '0' and z % 2 == 1:
            return "ALICE"
        return "BOB"
    if n % 2 == 1 and s[n // 2] == '0' and z == 2 and m == 1:
        return "DRAW"
    return "ALICE"

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(t):
        n = int(next(it))
        s = next(it)
        tests.append(s)
    return t, tests

def solve_case(s: str) -> str:
    return outcome(s)

def solve_all(tests):
    return [solve_case(s) for s in tests]

def main():
    # exactly 3 asserts
    assert outcome("01011") == "DRAW"
    assert outcome("010") == "BOB"
    assert outcome("01") == "ALICE"
    data = sys.stdin.read()
    if data.strip():
        t, tests = read_input(data)
        print("\n".join(solve_all(tests)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts: the special draw, a palindrome case, and a simple non-palindrome.}
\RESULT{Print ALICE, BOB, or DRAW per test case following the rules above.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-check corner cases: single-character, two-character, palindrome with one zero, palindrome with many zeros and middle zero, non-palindromes with varying mismatches including the special draw case.}
\LINE{CROSS-CHECKS}{For random small $n$, compare a naive minimax (not included here) against the closed-form to verify equivalence; for hand-crafted cases, ensure reverses do not change $(z,m)$.}
\LINE{EDGE-CASE GENERATOR}{Produce strings with: $m=0$ and $z=1$; $m=0$ and odd middle zero with $z$ odd; $m=1$ with middle zero and $z=2$; general $m>0$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_pal_with_single_zero(n):
    assert n >= 1
    s = ['1'] * n
    if n % 2 == 1:
        s[n // 2] = '0'
    else:
        s[0] = '0'
        s[-1] = '0'
        # fix to single zero by mirroring to center in odd case; for even keep simple n=2
        if n > 2:
            s = ['1'] * n
            s[n // 2 - 1] = '0'
            s[n // 2] = '0'
    return "".join(s)

def gen_special_draw():
    # n odd, middle zero, exactly two zeros, one mismatch
    # Example: "01011"
    return "01011"

def gen_nonpal_generic(n):
    # ensure at least one mismatch and multiple zeros
    s = list("1" * n)
    s[0] = '0'
    s[-1] = '1'
    if n % 2 == 1:
        s[n // 2] = '0'
    return "".join(s)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def outcome(s: str) -> str:
    n = len(s)
    z = s.count('0')
    m = sum(1 for i in range(n // 2) if s[i] != s[n - 1 - i])
    if m == 0:
        if z == 1:
            return "BOB"
        if n % 2 == 1 and s[n // 2] == '0' and z % 2 == 1:
            return "ALICE"
        return "BOB"
    if n % 2 == 1 and s[n // 2] == '0' and z == 2 and m == 1:
        return "DRAW"
    return "ALICE"

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        t = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(t):
        n = int(next(it))
        s = next(it)
        tests.append(s)
    return t, tests

def solve_case(s: str) -> str:
    return outcome(s)

def solve_all(tests):
    return [solve_case(s) for s in tests]

def main():
    # quick sanity
    assert outcome("0") == "BOB"
    assert outcome("01011") == "DRAW"
    data = sys.stdin.read()
    if data.strip():
        t, tests = read_input(data)
        print("\n".join(solve_all(tests)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Decide the winner by counting zeros and mismatched pairs; apply a tight case distinction.}
\WHY{Classic impartial game with a free reverse move that only changes initiative; appears frequently in logic/game-theory interview puzzles.}
\CHECKLIST{
\begin{bullets}
\item Count $z$ and $m$ correctly.
\item Check if $s$ is a palindrome ($m=0$).
\item If palindrome: handle $z=1$ and the odd-middle-zero parity case.
\item If not palindrome: check the single special draw case.
\item Otherwise declare ALICE.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=1$, $s=0$ $\Rightarrow$ BOB.
\item $n=2$, $s=01$ $\Rightarrow$ ALICE.
\item Palindrome with $z=1$ $\Rightarrow$ BOB.
\item Palindrome with odd $n$, middle zero, $z$ odd ($\ge 3$) $\Rightarrow$ ALICE.
\item Non-palindrome with exactly two zeros and middle zero and $m=1$ $\Rightarrow$ DRAW.
\item All other non-palindromes $\Rightarrow$ ALICE.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Miscounting $m$: only compare pairs $(i,n-1-i)$ for $i<n/2$.
\item Forgetting that only $0 \to 1$ flips are allowed.
\item Treating reverse as usable on palindromes (it is not).
\item Missing the special draw: $m=1$, $z=2$, odd $n$ with middle zero.
\item Confusing 0-based vs 1-based indexing for the middle position.
\item Assuming $z$ parity alone decides outcome in non-palindromes.
\end{bullets}}
\FAILMODES{Any approach that ignores the reverse-tempo draw case will mislabel a DRAW as ALICE. Miscounting mismatches can invert results.}
\ELI{You pay \$1 each time you flip a `0' to `1'. If the string is already symmetric, it behaves like the easy version. If it is not, Alice's first-move advantage plus the reverse option usually secures a win, except in a single balanced case that ends in a draw.}
\NotePages{3}

\end{document}