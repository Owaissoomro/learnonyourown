% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Bottom-Tier Reversals}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1558/C}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{You are given a permutation: an array $a = [a_1, a_2, \ldots, a_n]$ of distinct integers from $1$ to $n$. The length of the permutation $n$ is odd.

You need to sort the permutation in increasing order.

In one step, you can choose any prefix of the permutation with an odd length and reverse it. Formally, if $a = [a_1, a_2, \ldots, a_n]$, you can choose any odd integer $p$ between $1$ and $n$, inclusive, and set $a$ to $[a_p, a_{p-1}, \ldots, a_1, a_{p+1}, a_{p+2}, \ldots, a_n]$.

Find a way to sort $a$ using no more than $\tfrac{5n}{2}$ reversals of the above kind, or determine that such a way does not exist. The number of reversals does not have to be minimized.

Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 100$). Description of the test cases follows.

The first line of each test case contains a single integer $n$ ($3 \le n \le 2021$; $n$ is odd) — the length of the permutation.

The second line contains $n$ distinct integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le n$) — the permutation itself.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2021$.

Output: For each test case, if it is impossible to sort the given permutation in at most $\tfrac{5n}{2}$ reversals, print a single integer $-1$.

Otherwise, print an integer $m$ ($0 \le m \le \tfrac{5n}{2}$), denoting the number of reversals in your sequence of steps, followed by $m$ integers $p_i$ ($1 \le p_i \le n$; $p_i$ is odd), denoting the lengths of the prefixes of $a$ to be reversed, in chronological order.

Note: In the first test case, the permutation is already sorted. Any even number of reversals of the length $3$ prefix does not change that fact.

In the second test case, after reversing the prefix of length $3$ the permutation will change to $[5, 4, 3, 2, 1]$, and then after reversing the prefix of length $5$ the permutation will change to $[1, 2, 3, 4, 5]$.

In the third test case, it is impossible to sort the permutation.}
\BREAKDOWN{Exploit invariants preserved by odd-length prefix reversals. If feasible, place the two largest remaining values $i$ and $i-1$ into positions $i$ and $i-1$ using a fixed $5$-move template, and iterate downward by $2$.}
\ELI{Odd-length prefix reversals keep each number on indices of the same parity; we can lock the array from the end in chunks of two with a fixed sequence of moves.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each case:
\begin{bullets}
\item Integer $n$ (odd), $3 \le n \le 2021$.
\item Permutation $a_1, \ldots, a_n$ of $\{1,\ldots,n\}$.
\end{bullets}}
\OUTPUTS{For each test:
\begin{bullets}
\item If impossible, print $-1$.
\item Else print $m$ ($0 \le m \le \tfrac{5n}{2}$) and then $m$ odd integers $p_i$ ($1 \le p_i \le n$) indicating odd-length prefix reversals in order. Any valid sequence is accepted.
\end{bullets}}
\SAMPLES{
Example 1:
\begin{bullets}
\item Input
\[
\begin{aligned}
1\\
3\\
1~2~3
\end{aligned}
\]
\item Output
\[
\begin{aligned}
0
\end{aligned}
\]
\end{bullets}
Example 2:
\begin{bullets}
\item Input
\[
\begin{aligned}
1\\
5\\
2~1~4~3~5
\end{aligned}
\]
\item Output
\[
\begin{aligned}
-1
\end{aligned}
\]
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{State is a permutation $a \in S_n$ with $n$ odd. A move chooses odd $p$ and applies $a \leftarrow (a_1,\ldots,a_p)^{\mathrm{rev}} \cdot (a_{p+1},\ldots,a_n)$. Goal: reach identity permutation $(1,2,\ldots,n)$ within $\tfrac{5n}{2}$ moves if possible.}
\varmapStart
\var{a}{current permutation}
\var{n}{odd length of the permutation}
\var{p}{odd prefix length to reverse}
\var{i}{current largest odd target index being fixed}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Parity invariant: For every value }v,\ \operatorname{parity}(\operatorname{pos}(v)) = \operatorname{parity}(v)\ \text{under odd-prefix reversals}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{1-indexed arrays. All values are distinct in $[1..n]$. Only odd $p$ moves are allowed.}
\INVARIANTS{
\begin{bullets}
\item Parity of each element's position equals its value parity, and is preserved by any odd-length prefix reversal.
\item The relative multiset of elements is preserved; only positions change.
\item Once a suffix is locked in place, future operations never touch it.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the standard $5$-move template to place a pair $(i-1,i)$ into $(i-1,i)$ for $i=n,n-2,\ldots,3$. First check the parity feasibility condition.}
\ASSUMPTIONS{We locate positions via linear scans (Python \texttt{list.index}), leading to $O(n^2)$ time overall, which is fine for $n \le 2021$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If there exists $j$ with $a_j \bmod 2 \ne j \bmod 2$, output $-1$ (impossible).
\item For $i \gets n, n-2, \ldots, 3$:
  \begin{bullets}
  \item Reverse prefix of length $\operatorname{pos}(i)$.
  \item Reverse prefix of length $\operatorname{pos}(i-1)-1$.
  \item Reverse prefix of length $\operatorname{pos}(i-1)+1$.
  \item Reverse prefix $3$.
  \item Reverse prefix $i$.
  \end{bullets}
\item Output the sequence of odd prefix lengths.
\end{algosteps}
\COMPLEXITY{Each pair uses exactly $5$ moves; total $\tfrac{5(n-1)}{2} \le \tfrac{5n}{2}$ moves. Linear scans per step yield $O(n)$ per operation, giving $O(n^2)$ time and $O(1)$ extra space.}
\[
\begin{aligned}
\#\text{moves} &= 5\cdot \frac{n-1}{2} \le \frac{5n}{2},\\
T(n) &= O\!\left(\frac{5(n-1)}{2}\cdot n\right)=O(n^2),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{The $5$-move template ensures after the sequence, elements $i$ and $i-1$ land in positions $i$ and $i-1$. Parity feasibility ensures existence; suffix locking ensures progress.}
\EDGECASES{Already sorted arrays; $n=3$ minimal case; impossible cases where some $a_j$ has parity different from $j$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def reverse_prefix(a, p, ops):
    assert p % 2 == 1 and 1 <= p <= len(a)
    a[:p] = reversed(a[:p])
    ops.append(p)

def pos(a, val):
    # 1-indexed position
    return a.index(val) + 1

def feasible(a):
    # Parity of position equals parity of value must hold
    for j, v in enumerate(a, start=1):
        if (j ^ v) & 1:
            return False
    return True

def construct_ops_baseline(a):
    n = len(a)
    if not feasible(a):
        return [-1]
    ops = []
    # Work from the end in pairs (i-1, i)
    for i in range(n, 1, -2):
        # Step 1: bring i to front
        p1 = pos(a, i)
        reverse_prefix(a, p1, ops)
        # Step 2: bring i-1 to position 2 via p2-1 then p2+1
        p2 = pos(a, i - 1)
        reverse_prefix(a, p2 - 1, ops)
        p3 = pos(a, i - 1)
        reverse_prefix(a, p3 + 1, ops)
        # Step 4: adjust to have i at position 1, i-1 at 2
        reverse_prefix(a, 3, ops)
        # Step 5: send them to positions i and i-1
        reverse_prefix(a, i, ops)
    return ops

def apply_ops(a, ops):
    b = a[:]
    if ops == [-1]:
        return b
    for p in ops:
        assert p % 2 == 1
        b[:p] = reversed(b[:p])
    return b

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it)
        arr = [next(it) for _ in range(n)]
        cases.append((n, arr))
    return cases

def solve_case(n, arr):
    a = arr[:]  # work on a copy
    ops = construct_ops_baseline(a)
    if ops == [-1]:
        return "-1"
    assert len(ops) <= (5 * n) // 2
    # Verify correctness
    sorted_a = apply_ops(arr[:], ops)
    assert sorted_a == sorted(arr)
    # Output per CF style: m and then the list
    out = [str(len(ops)), " ".join(map(str, ops)) if ops else ""]
    return "\n".join([x for x in out if x != ""])

def solve_all():
    cases = read_input()
    if not cases:
        return
    out_lines = []
    for n, arr in cases:
        out_lines.append(solve_case(n, arr))
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    # Feasible and already sorted
    assert construct_ops_baseline([1,2,3]) != [-1]
    assert apply_ops([1,2,3], construct_ops_baseline([1,2,3])) == [1,2,3]
    # Reverse sorted n=5
    arr = [5,4,3,2,1]
    ops = construct_ops_baseline(arr[:])
    assert ops != [-1]
    assert apply_ops(arr[:], ops) == sorted(arr)
    # Impossible parity case
    assert construct_ops_baseline([2,1,4,3,5]) == [-1]

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Three asserts:
\begin{bullets}
\item $[1,2,3]$ stays sorted.
\item $[5,4,3,2,1]$ becomes sorted.
\item $[2,1,4,3,5]$ is correctly rejected as impossible.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Position Tracking}
\WHICHFORMULA{Maintain a position map $\text{pos}[v]$ updated after each prefix reversal. Updating only the affected prefix in $O(p)$ time avoids repeated full scans for positions, simplifying and slightly speeding practice implementations.}
\ASSUMPTIONS{We keep both the array and a 1-indexed position map in sync.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $\text{pos}[v] = \operatorname{pos}(v)$ for all $v$.
\item For $i=n,n-2,\ldots,3$, apply the same $5$-move template, but compute positions from $\text{pos}[\cdot]$.
\item After reversing a prefix of length $p$, update $\text{pos}$ for indices $1..p$ by mapping $k \mapsto p+1-k$.
\end{algosteps}
\COMPLEXITY{Same asymptotic $O(n^2)$ time; smaller constants from avoiding repeated scans.}
\[
\begin{aligned}
T(n) &= O\!\left(\sum \limits_{\text{ops}} p\right) = O(n^2), \quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Identical move template and invariants; only bookkeeping differs.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def reverse_prefix_with_pos(a, p, pos, ops):
    assert p % 2 == 1 and 1 <= p <= len(a)
    # Reverse prefix in-place
    a[:p] = reversed(a[:p])
    # Update pos for affected values in 1..p (1-indexed)
    for k in range(1, p + 1):
        v = a[k - 1]
        pos[v] = k
    ops.append(p)

def feasible(a):
    for j, v in enumerate(a, start=1):
        if (j ^ v) & 1:
            return False
    return True

def construct_ops_with_pos(a):
    n = len(a)
    if not feasible(a):
        return [-1]
    pos = [0] * (n + 1)
    for i, v in enumerate(a, start=1):
        pos[v] = i
    ops = []
    for i in range(n, 1, -2):
        p1 = pos[i]
        reverse_prefix_with_pos(a, p1, pos, ops)
        p2 = pos[i - 1]
        reverse_prefix_with_pos(a, p2 - 1, pos, ops)
        p3 = pos[i - 1]
        reverse_prefix_with_pos(a, p3 + 1, pos, ops)
        reverse_prefix_with_pos(a, 3, pos, ops)
        reverse_prefix_with_pos(a, i, pos, ops)
    return ops

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it)
        arr = [next(it) for _ in range(n)]
        cases.append((n, arr))
    return cases

def solve_case(n, arr):
    a = arr[:]
    ops = construct_ops_with_pos(a)
    if ops == [-1]:
        return "-1"
    assert len(ops) <= (5 * n) // 2
    # Verify result
    b = arr[:]
    for p in ops:
        assert p % 2 == 1
        b[:p] = reversed(b[:p])
    assert b == sorted(arr)
    out = [str(len(ops)), " ".join(map(str, ops)) if ops else ""]
    return "\n".join([x for x in out if x != ""])

def solve_all():
    cases = read_input()
    if not cases:
        return
    out_lines = []
    for n, arr in cases:
        out_lines.append(solve_case(n, arr))
    sys.stdout.write("\n".join(out_lines))

# Minimal checks
def _self_test():
    assert construct_ops_with_pos([1,2,3]) != [-1]
    arr = [5,4,3,2,1]
    ops = construct_ops_with_pos(arr[:])
    b = arr[:]
    for p in ops:
        b[:p] = reversed(b[:p])
    assert b == [1,2,3,4,5]
    assert construct_ops_with_pos([2,1,4,3,5]) == [-1]

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Checks include sorted case, reverse-sorted case, and an impossible parity case.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{The $5$-move template per pair is standard and tight for this constraint set; feasibility is exactly the parity condition. The method is optimal up to constant factors with respect to the problem's required upper bound $\tfrac{5n}{2}$.}
\ASSUMPTIONS{Odd $n$; only odd-length prefix reversals; parity feasibility must hold.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Verify feasibility: for all $j$, $a_j \equiv j \pmod{2}$. If not, print $-1$.
\item For $i=n,n-2,\ldots,3$, apply the move sequence:
\begin{bullets}
\item $p_1=\operatorname{pos}(i)$; reverse $p_1$.
\item $p_2=\operatorname{pos}(i-1)$; reverse $p_2-1$.
\item $p_3=\operatorname{pos}(i-1)$; reverse $p_3+1$.
\item Reverse $3$.
\item Reverse $i$.
\end{bullets}
\item Output the sequence of $p$.
\end{algosteps}
\OPTIMALITY{Each pair is handled with exactly $5$ moves, meeting the official $\tfrac{5n}{2}$ cap. The parity condition is both necessary and sufficient.}
\COMPLEXITY{$O(n^2)$ time, $O(n)$ space with a position map, or $O(1)$ extra space with scans.}
\[
\begin{aligned}
T(n) &= O(n^2),\quad S(n)=O(n)\ \text{(map)}\ \text{or}\ O(1)\ \text{(scan)}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def feasible(a):
    for j, v in enumerate(a, start=1):
        if (j ^ v) & 1:
            return False
    return True

def reverse_prefix_with_pos(a, p, pos, ops):
    assert p % 2 == 1 and 1 <= p <= len(a)
    a[:p] = reversed(a[:p])
    for k in range(1, p + 1):
        pos[a[k - 1]] = k
    ops.append(p)

def solve_one(arr):
    n = len(arr)
    if not feasible(arr):
        return [-1]
    a = arr[:]
    pos = [0] * (n + 1)
    for i, v in enumerate(a, start=1):
        pos[v] = i
    ops = []
    for i in range(n, 1, -2):
        p1 = pos[i]
        reverse_prefix_with_pos(a, p1, pos, ops)
        p2 = pos[i - 1]
        reverse_prefix_with_pos(a, p2 - 1, pos, ops)
        p3 = pos[i - 1]
        reverse_prefix_with_pos(a, p3 + 1, pos, ops)
        reverse_prefix_with_pos(a, 3, pos, ops)
        reverse_prefix_with_pos(a, i, pos, ops)
    assert len(ops) <= (5 * n) // 2
    return ops

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it)
        arr = [next(it) for _ in range(n)]
        cases.append((n, arr))
    return cases

def solve_all():
    cases = read_input()
    if not cases:
        return
    out_lines = []
    for n, arr in cases:
        ops = solve_one(arr)
        if ops == [-1]:
            out_lines.append("-1")
        else:
            out_lines.append(str(len(ops)))
            out_lines.append(" ".join(map(str, ops)) if ops else "")
    sys.stdout.write("\n".join(out_lines))

# Exactly 3 asserts
def _self_test():
    assert solve_one([1,2,3]) != [-1]
    ops = solve_one([5,4,3,2,1])
    b = [5,4,3,2,1]
    if ops != [-1]:
        for p in ops:
            b[:p] = reversed(b[:p])
        assert b == [1,2,3,4,5]
    assert solve_one([2,1,4,3,5]) == [-1]

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Three asserts:
\begin{bullets}
\item Feasible and sorted $[1,2,3]$ remains sorted.
\item Reverse-sorted $[5,4,3,2,1]$ becomes sorted using odd prefixes only.
\item Parity-infeasible $[2,1,4,3,5]$ is rejected with $-1$.
\end{bullets}}
\RESULT{Either $-1$ (impossible) or a sequence of $\le \tfrac{5n}{2}$ odd prefix lengths that sorts the permutation.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Deterministic unit tests: parity feasibility detection; small hand-crafted permutations; check that all printed $p_i$ are odd and that the final array equals sorted order.}
\LINE{CROSS-CHECKS}{Compare outputs of baseline and improved implementations on the same small inputs; both should agree on feasibility and yield valid sequences.}
\LINE{EDGE-CASE GENERATOR}{Systematically try all permutations for $n=3,5$ that satisfy parity feasibility to ensure the constructor works; avoid randomness for determinism.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def all_feasible_perms(n):
    # Generate permutations where parity of position equals parity of value
    # Deterministic but exponential; use only for tiny n in offline checks.
    import itertools
    for perm in itertools.permutations(range(1, n+1)):
        ok = True
        for i, v in enumerate(perm, start=1):
            if (i ^ v) & 1:
                ok = False
                break
        if ok:
            yield list(perm)

def verify_ops(arr, ops):
    b = arr[:]
    if ops == [-1]:
        return False
    for p in ops:
        if p % 2 == 0 or p < 1 or p > len(b):
            return False
        b[:p] = reversed(b[:p])
    return b == sorted(arr)

# Quick sanity for n=3
for perm in all_feasible_perms(3):
    from copy import deepcopy
    ops = (lambda a: __import__("sys").modules[__name__].solve_one(a))(deepcopy(perm))
    assert ops == [-1] or verify_ops(perm, ops)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def feasible(a):
    for j, v in enumerate(a, start=1):
        if (j ^ v) & 1:
            return False
    return True

def reverse_prefix_with_pos(a, p, pos, ops):
    assert p % 2 == 1 and 1 <= p <= len(a)
    a[:p] = reversed(a[:p])
    for k in range(1, p + 1):
        pos[a[k - 1]] = k
    ops.append(p)

def solve_one(arr):
    n = len(arr)
    if not feasible(arr):
        return [-1]
    a = arr[:]
    pos = [0] * (n + 1)
    for i, v in enumerate(a, start=1):
        pos[v] = i
    ops = []
    for i in range(n, 1, -2):
        p1 = pos[i]
        reverse_prefix_with_pos(a, p1, pos, ops)
        p2 = pos[i - 1]
        reverse_prefix_with_pos(a, p2 - 1, pos, ops)
        p3 = pos[i - 1]
        reverse_prefix_with_pos(a, p3 + 1, pos, ops)
        reverse_prefix_with_pos(a, 3, pos, ops)
        reverse_prefix_with_pos(a, i, pos, ops)
    assert len(ops) <= (5 * n) // 2
    return ops

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it)
        arr = [next(it) for _ in range(n)]
        cases.append((n, arr))
    return cases

def solve_all():
    cases = read_input()
    if not cases:
        return
    out_lines = []
    for n, arr in cases:
        ops = solve_one(arr)
        if ops == [-1]:
            out_lines.append("-1")
        else:
            out_lines.append(str(len(ops)))
            out_lines.append(" ".join(map(str, ops)) if ops else "")
    sys.stdout.write("\n".join(out_lines))

# Reference asserts
def _self_test():
    assert solve_one([1,2,3]) != [-1]
    ops = solve_one([5,4,3,2,1])
    b = [5,4,3,2,1]
    for p in ops:
        b[:p] = reversed(b[:p])
    assert b == [1,2,3,4,5]
    assert solve_one([2,1,4,3,5]) == [-1]

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Sort a permutation using only odd-length prefix reversals, or report impossibility.}
\WHY{Tests understanding of invariants under constrained operations and constructive algorithms with guaranteed move bounds.}
\CHECKLIST{
\begin{bullets}
\item Check parity feasibility: $a_j \equiv j \pmod{2}$ for all $j$.
\item Iterate $i=n,n-2,\ldots,3$.
\item Apply the $5$-move template precisely.
\item Keep moves odd and within $[1..n]$.
\item Lock the suffix and never touch it.
\item Verify total moves $\le \tfrac{5n}{2}$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=3$ minimal odd size.
\item Already sorted input.
\item Reverse-sorted but feasible inputs.
\item Parity-violating inputs (impossible).
\item Cases where $\operatorname{pos}(i-1)=2$ (uses a no-op $p=1$).
\item Large $n$ near the upper limit.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Accidentally using an even prefix length.
\item Forgetting that $\operatorname{pos}(i-1)+1 \le n$ is guaranteed since $\operatorname{pos}(i-1)$ is even.
\item Off-by-one errors in 1-indexed position computations.
\item Not updating the position map after reversals.
\item Printing format: $-1$ alone vs. $m$ then the sequence.
\item Exceeding the move cap by adding extra cosmetic operations.
\end{bullets}}
\FAILMODES{Any approach that ignores the parity invariant will fail on infeasible inputs. Greedy placements without the $5$-move scaffold can break the odd-prefix constraint mid-way.}
\ELI{Because odd-length prefix reversals preserve parity of positions, only numbers starting on the correct parity can ever reach their targets. With that check passed, a fixed sequence of five odd-prefix reversals can place two numbers at a time from the end, quickly finishing the sort.}
\NotePages{3}

\end{document}