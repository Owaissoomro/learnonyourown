% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Non-overlapping Intervals}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/non-overlapping-intervals/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given an array of intervals \texttt{intervals} where \texttt{intervals[i] = [\textit{start\_i}, \textit{end\_i}]}, return \emph{the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping}.\\
\textbf{Note} that intervals which only touch at a point are \textbf{non-overlapping}. For example, \texttt{[1, 2]} and \texttt{[2, 3]} are non-overlapping.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{intervals = [[1,2],[2,3],[3,4],[1,3]]}\\
\quad \textbf{Output:} \texttt{1}\\
\quad \textbf{Explanation:} \texttt{[1,3]} can be removed and the rest of the intervals are non-overlapping.

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{intervals = [[1,2],[1,2],[1,2]]}\\
\quad \textbf{Output:} \texttt{2}\\
\quad \textbf{Explanation:} You need to remove two \texttt{[1,2]} to make the rest of the intervals non-overlapping.

\textbf{Example 3:}

\quad \textbf{Input:} \texttt{intervals = [[1,2],[2,3]]}\\
\quad \textbf{Output:} \texttt{0}\\
\quad \textbf{Explanation:} You do not need to remove any of the intervals since they are already non-overlapping.

\textbf{Constraints:}
\begin{itemize}
\item \texttt{1 \le intervals.length \le } $10^5$
\item \texttt{intervals[i].length == 2}
\item \texttt{$-5 \times 10^4 \le$ start\_i $<$ end\_i $\le 5 \times 10^4$}
\end{itemize}
}
\BREAKDOWN{We want the minimum removals so that no two kept intervals overlap. Equivalently, maximize the number of non-overlapping intervals to keep, then subtract from $n$. This is classic interval scheduling.}
\ELI{Pick as many intervals as possible that end earliest; remove the rest.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{intervals} of length $n$ with entries \texttt{[start\_i, end\_i]} where integers satisfy $-5 \times 10^4 \le \textit{start\_i} < \textit{end\_i} \le 5 \times 10^4$.}
\OUTPUTS{Return a single integer: the minimum number of intervals to remove so the remaining intervals are pairwise non-overlapping. Intervals that only touch at endpoints are allowed.}
\SAMPLES{
Example A: \texttt{[[1,2],[2,3],[3,4],[1,3]]} $\to$ \texttt{1}.\\
Example B: \texttt{[[1,2],[1,2],[1,2]]} $\to$ \texttt{2}.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $I=\{1,\ldots,n\}$ index intervals with $[s_i,e_i)$ and $s_i<e_i$. Choose a subset $S\subseteq I$ maximizing $|S|$ such that no two intervals in $S$ overlap. The answer is $n-|S|$.}
\varmapStart
\var{n}{number of intervals}
\var{[s_i,e_i)}{half-open representation of the $i$-th interval; touching at endpoints is allowed}
\var{S}{subset of indices chosen to keep}
\var{A}{final answer, the minimum removals}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{maximize } |S| \\
&\text{subject to } \forall i\ne j\in S:\ \ e_i \le s_j \ \ \text{or}\ \ e_j \le s_i,\\
&A = n - |S|.
\end{aligned}
\]
}
\ASSUMPTIONS{Endpoints are integers; touching at endpoints is allowed, so using half-open $[s,e)$ simplifies non-overlap as $e_i \le s_j$ or $e_j \le s_i$.}
\INVARIANTS{
\begin{itemize}
\item Sorting by non-decreasing end time does not change feasibility and enables a greedy optimal solution.
\item In an optimal schedule, there is a solution that picks the interval with the earliest finishing time among all feasible first choices.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute the maximum set of non-overlapping intervals via $O(n^2)$ DP after sorting by end times; removals $= n - \max\_i \text{dp}[i]$.}
\ASSUMPTIONS{Sort by end time to align transitions: a schedule ending at $i$ can extend any $j<i$ with $e_j \le s_i$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort intervals by end time ascending.
\item dp[i] = 1 + $\max\{\text{dp}[j] \mid j<i, e_j \le s_i\}$; else $1$ if none.
\item Return $n - \max_i \text{dp}[i]$.
\end{algosteps}
\COMPLEXITY{$O(n^2)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= \Theta(n \log n) + \Theta(n^2) \\
     &= \Theta(n^2),\quad S(n)=\Theta(n).
\end{aligned}
\]
\CORRECTNESS{dp[i] is the optimal keep-count for schedules ending at $i$. The recurrence considers all compatible predecessors, so $\max_i \text{dp}[i]$ is the optimal number of intervals to keep.}
\EDGECASES{Single interval; all pairwise-disjoint; all identical; mixed touching endpoints; negative coordinates.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        n = len(intervals)
        if n <= 1:
            return 0
        ivs = sorted(intervals, key=lambda x: (x[1], x[0]))
        dp = [1] * n
        for i in range(n):
            si, ei = ivs[i][0], ivs[i][1]
            for j in range(i):
                sj, ej = ivs[j][0], ivs[j][1]
                if ej <= si:
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
        keep = max(dp)
        return n - keep

# Basic asserts (LC-style)
if __name__ == "__main__":
    sol = Solution()
    assert sol.eraseOverlapIntervals([[1,2],[2,3],[3,4],[1,3]]) == 1
    assert sol.eraseOverlapIntervals([[1,2],[1,2],[1,2]]) == 2
    assert sol.eraseOverlapIntervals([[1,2],[2,3]]) == 0
    assert sol.eraseOverlapIntervals([]) == 0
    assert sol.eraseOverlapIntervals([[0,1]]) == 0
\end{minted}
\VALIDATION{Verified on the three official examples and trivial edge cases: empty list returns 0; single interval returns 0.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Greedy by Earliest Finish}
\WHICHFORMULA{Classic interval scheduling: sort by end time and greedily keep any interval starting after the last kept end; removals $= n - \text{kept}$.}
\ASSUMPTIONS{Touching is allowed: keep next if $s \ge \text{cur\_end}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort intervals by end time ascending.
\item Initialize cur\_end $=-\infty$, kept $=0$.
\item For each $[s,e]$ in order: if $s \ge \text{cur\_end}$, keep it and set cur\_end $=e$.
\item Return $n - \text{kept}$.
\end{algosteps}
\COMPLEXITY{Sorting dominates: $O(n \log n)$ time, $O(1)$ extra space aside from sorting.}
\[
\begin{aligned}
T(n) &= \Theta(n \log n),\quad S(n)=\Theta(1)\ \text{(in-place sort)}.
\end{aligned}
\]
\CORRECTNESS{Earliest-finish greedy is optimal: an exchange argument shows any optimal solution can be transformed to one that first takes the earliest finishing interval without reducing the number kept.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        n = len(intervals)
        if n <= 1:
            return 0
        intervals.sort(key=lambda x: (x[1], x[0]))
        kept = 0
        cur_end = float("-inf")
        for s, e in intervals:
            if s >= cur_end:
                kept += 1
                cur_end = e
        return n - kept

if __name__ == "__main__":
    sol = Solution()
    assert sol.eraseOverlapIntervals([[1,2],[2,3],[3,4],[1,3]]) == 1
    assert sol.eraseOverlapIntervals([[1,2],[1,2],[1,2]]) == 2
    assert sol.eraseOverlapIntervals([[1,2],[2,3]]) == 0
    # touching endpoints allowed
    assert sol.eraseOverlapIntervals([[0,1],[1,2],[2,2+1]]) == 0  # [2,3]
\end{minted}
\VALIDATION{Checks include touching endpoints, duplicates, and already non-overlapping cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Greedy by Start With In-Place Removal Choice}
\WHICHFORMULA}{Sort by start; sweep and when overlap occurs, remove the interval with the larger end (keep the one that ends earlier) to minimize future conflicts.}
\ASSUMPTIONS{Overlap if next start $< \text{prev\_end}$. On overlap, set $\text{prev\_end}=\min(\text{prev\_end}, e)$ and increment removals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort by start ascending.
\item Initialize prev\_end to $-\infty$, removals to $0$, and a flag for first interval.
\item For each $[s,e]$:
  \begin{itemize}
  \item If $s \ge \text{prev\_end}$, accept and set prev\_end $= e$.
  \item Else, overlap: increment removals and set prev\_end $=\min(\text{prev\_end}, e)$ to keep the earlier finishing interval.
  \end{itemize}
\item Return removals.
\end{algosteps}
\OPTIMALITY{This is equivalent to earliest-finish selection: on each conflict, discarding the later-finishing interval preserves feasibility and maximizes remaining room, yielding the same kept set size as the classic end-sorted greedy.}
\COMPLEXITY{$O(n \log n)$ time due to sort; $O(1)$ extra space.}
\[
\begin{aligned}
T(n) &= \Theta(n \log n),\quad S(n)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) <= 1:
            return 0
        intervals.sort(key=lambda x: (x[0], x[1]))
        removals = 0
        prev_end = float("-inf")
        first = True
        for s, e in intervals:
            if first:
                prev_end = e
                first = False
                continue
            if s >= prev_end:
                prev_end = e
            else:
                removals += 1
                if e < prev_end:
                    prev_end = e
        return removals

if __name__ == "__main__":
    sol = Solution()
    # Exactly 3 asserts
    assert sol.eraseOverlapIntervals([[1,2],[2,3],[3,4],[1,3]]) == 1
    assert sol.eraseOverlapIntervals([[1,2],[1,2],[1,2]]) == 2
    assert sol.eraseOverlapIntervals([[1,2],[2,3]]) == 0
\end{minted}
\VALIDATION{Three asserts cover conflicting intervals, identical duplicates, and already non-overlapping inputs.}
\RESULT{Return the minimal number of intervals to remove. Ties are irrelevant because only the count is requested.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests with examples, random small cases comparing DP vs Greedy, and edge cases: empty input, one interval, all touching, nested intervals, negative coordinates.}
\LINE{CROSS-CHECKS}{For small $n$, compare Approach A (DP) and Approach C (Greedy) outputs across enumerated interval sets to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate intervals with identical endpoints, chains of touching intervals, and dense overlaps to stress the overlap-resolution rule.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import itertools

def gen_touching_chain(n: int) -> List[List[int]]:
    return [[i, i+1] for i in range(n)]

def gen_all_identical(n: int, a: int = 0, b: int = 1) -> List[List[int]]:
    return [[a, b] for _ in range(n)]

def gen_dense_overlaps(n: int) -> List[List[int]]:
    # intervals [0, k] for k=1..n => heavy overlaps
    return [[0, i+1] for i in range(n)]

def brute_dp(intervals: List[List[int]]) -> int:
    # O(n^2) DP baseline (same as Approach A)
    n = len(intervals)
    if n <= 1:
        return 0
    ivs = sorted(intervals, key=lambda x: (x[1], x[0]))
    dp = [1] * n
    for i in range(n):
        for j in range(i):
            if ivs[j][1] <= ivs[i][0]:
                dp[i] = max(dp[i], dp[j] + 1)
    keep = max(dp)
    return n - keep

def greedy(intervals: List[List[int]]) -> int:
    # Approach C
    if len(intervals) <= 1:
        return 0
    ivs = sorted(intervals, key=lambda x: (x[0], x[1]))
    removals = 0
    prev_end = float("-inf")
    first = True
    for s, e in ivs:
        if first:
            prev_end = e
            first = False
            continue
        if s >= prev_end:
            prev_end = e
        else:
            removals += 1
            if e < prev_end:
                prev_end = e
    return removals

def cross_check_small():
    cases = []
    cases.append([[1,2],[2,3],[3,4],[1,3]])
    cases.append([[1,2],[1,2],[1,2]])
    cases.append([[1,2],[2,3]])
    cases.append(gen_touching_chain(5))
    cases.append(gen_all_identical(5, 0, 2))
    cases.append(gen_dense_overlaps(6))
    for ivs in cases:
        assert greedy(ivs) == brute_dp(ivs)
    # Enumerate tiny spaces
    points = [0,1,2]
    tiny = []
    for a,b in itertools.product(points, points):
        if a < b:
            tiny.append([a,b])
    for subset_bits in range(1, 1 << len(tiny)):
        ivs = [tiny[i] for i in range(len(tiny)) if (subset_bits>>i)&1]
        assert greedy(ivs) == brute_dp(ivs)

if __name__ == "__main__":
    cross_check_small()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        # Greedy: sort by start; on overlap, remove the one with larger end.
        n = len(intervals)
        if n <= 1:
            return 0
        intervals.sort(key=lambda x: (x[0], x[1]))
        removals = 0
        prev_end = float("-inf")
        first = True
        for s, e in intervals:
            if first:
                prev_end = e
                first = False
                continue
            if s >= prev_end:
                prev_end = e
            else:
                removals += 1
                if e < prev_end:
                    prev_end = e
        return removals

if __name__ == "__main__":
    sol = Solution()
    # Official examples
    assert sol.eraseOverlapIntervals([[1,2],[2,3],[3,4],[1,3]]) == 1
    assert sol.eraseOverlapIntervals([[1,2],[1,2],[1,2]]) == 2
    assert sol.eraseOverlapIntervals([[1,2],[2,3]]) == 0
    # Extra checks
    assert sol.eraseOverlapIntervals([]) == 0
    assert sol.eraseOverlapIntervals([[0,1]]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Min removals equals total intervals minus the maximum number of non-overlapping intervals you can keep.}
\WHY{A canonical greedy appears in many scheduling and sweep-line interview problems; recognizing earliest-finish-time optimality is key.}
\CHECKLIST{
\begin{bullets}
\item Sort by the right key (end time for simplest greedy).
\item Define non-overlap precisely: touching at endpoints is allowed.
\item Decide whether to count kept or removals; ensure consistent return.
\item On overlap, prefer the interval with the smaller end (keeps more room).
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All intervals identical.
\item Already non-overlapping.
\item Long interval containing many short intervals.
\item Chains that only touch at endpoints.
\item Negative coordinates.
\item Single interval or empty input.
\item Multiple intervals sharing the same end.
\item Very large $n$ up to $10^5$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Treating touching intervals as overlapping (should be allowed).
\item Sorting by start then keeping always can fail without the ``remove larger end'' rule.
\item Off-by-one in comparisons ($<$ vs $\le$ at endpoints).
\item Forgetting to update the current end when keeping an interval.
\item Returning kept count instead of removals.
\item Not handling empty or single-element arrays.
\end{bullets}
}
\FAILMODES{Greedy by longest duration fails; greedy by earliest start fails. Correct greedy is by earliest finish, or start-sorted with ``drop larger end'' on conflicts.}
\ELI{Pick intervals that finish earliest to fit as many as possible without overlap. The ones you cannot fit are exactly the intervals you must remove.}
\NotePages{3}

\end{document}