% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximum Number of Intersections on the Chart}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximum-number-of-intersections-on-the-chart/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an integer array $y$ of length $n \ge 2$. Consider the polyline (line chart) formed by connecting consecutive points $(i, y_i)$ and $(i+1, y_{i+1})$ with straight segments for all $i \in \{0,\ldots,n-2\}$.

For a real number $h$, define the number of intersections between the horizontal line $Y=h$ and the chart as the number of indices $i \in \{0,\ldots,n-2\}$ such that:
\begin{BreakableEquation*}
h \in \bigl(\min(y_i,y_{i+1}),~\max(y_i,y_{i+1})\bigr]
\end{BreakableEquation*}
That is, horizontal segments with $y_i = y_{i+1}$ never contribute; a segment contributes if $h$ lies strictly above its lower endpoint and up to and including its upper endpoint. When $Y=h$ passes through a vertex where two segments meet, this convention ensures that the meeting point is counted once overall.

Return the maximum possible number of intersections over all real $h$.}
\BREAKDOWN{Turn each consecutive pair $(y_i,y_{i+1})$ into a one-dimensional interval $(\min,\max]$ on the $y$-axis. The task becomes: among these $n-1$ intervals, find the maximum number covering the same height $h$. Use a sweep line over interval endpoints with careful half-open semantics.}
\ELI{Count how many up or down edges of the chart are cut by some horizontal ruler; slide the ruler to the height where it cuts the most.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Array $y$ of $n$ integers, $2 \le n \le 2\cdot 10^5$ in typical constraints. Values $y_i$ are integers with absolute value up to, say, $10^9$; duplicates and negatives are allowed.}
\OUTPUTS{An integer equal to $\max_{h \in \mathbb{R}} \left|\{\, i \in [0,n-2] : h \in (\min(y_i,y_{i+1}), \max(y_i,y_{i+1})] \,\}\right|$.}
\SAMPLES{
Example 1: $y=[1,3,2,5]$.

Intervals: $(1,3],(2,3],(2,5]$. For $h=2.5$, all three contain $h$, so the answer is $3$.

Example 2: $y=[5,5,5]$.

All segments are horizontal, so no horizontal line strictly crosses any segment; the answer is $0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $I_i = (a_i,b_i]$ for $i=0,\ldots,n-2$, where $a_i=\min(y_i,y_{i+1})$ and $b_i=\max(y_i,y_{i+1})$. For $a_i=b_i$ we drop $I_i$ as empty. Define
\begin{BreakableEquation*}
f(h) \coloneqq \sum_{i=0}^{n-2} \mathbf{1}\{\,h \in I_i\,\},\quad \text{and we seek } \max_{h \in \mathbb{R}} f(h).
\end{BreakableEquation*}
}
\varmapStart
\var{n}{number of points, length of $y$}
\var{y_i}{chart ordinate at abscissa $i$}
\var{I_i}{interval $(\min(y_i,y_{i+1}),\max(y_i,y_{i+1})]$ for segment $i$}
\var{h}{horizontal level being probed}
\var{f(h)}{number of intervals covering $h$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\max_{h \in \mathbb{R}} f(h) \quad \text{with} \quad f(h) = \sum_{i=0}^{n-2}\mathbf{1}\bigl(h \in (a_i,b_i]\bigr).
\end{BreakableEquation*}
}
\ASSUMPTIONS{If $y_i=y_{i+1}$ then the corresponding segment is horizontal and contributes no intersection for any $h$, so its interval is empty and can be ignored. Counting with $(\min,\max]$ prevents double counting at shared vertices.}
\INVARIANTS{
\begin{bullets}
\item $f(h)$ is piecewise-constant in $h$ and changes only at endpoints $a_i$ or $b_i$.
\item Using half-open $(\min,\max]$ ensures $f$ does not overcount a joint; maxima occur either at some $b_i$ or just above some $a_i$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Evaluate $f(h)$ on a finite candidate set of heights $h$ that contains at least one representative from every plateau where $f$ is constant: all distinct endpoints $y_i$ and midpoints between consecutive distinct sorted $y$ values.}
\ASSUMPTIONS{Integer inputs; counting rule is $h \in (\min,\max]$. Horizontal segments ($y_i=y_{i+1}$) are ignored.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the set $C$ of candidate heights: all $y_i$ and all midpoints $\tfrac{y_i+y_{i+1}}{2}$ for $i=0,\ldots,n-2$.
\item For each $h \in C$, count segments $i$ with $h \in (\min(y_i,y_{i+1}),\max(y_i,y_{i+1})]$.
\item Return the maximum count over all $h \in C$.
\end{algosteps}
\COMPLEXITY{For $n$ points and $O(n)$ candidates, each count is $O(n)$, so overall $T(n)=O(n^2)$; space $S(n)=O(1)$ beyond input.}
\[
\begin{aligned}
T(n) &= O(n)\text{ candidates} \times O(n)\text{ per evaluation} \\
     &= O(n^2).
\end{aligned}
\]
\CORRECTNESS{Between any two consecutive distinct endpoint heights, $f(h)$ is constant; at endpoints, the half-open convention defines $f$ unambiguously. Thus sampling all endpoints and midpoints attains the global maximum.}
\EDGECASES{Equal adjacent values ($y_i=y_{i+1}$) contribute nothing; duplicate heights are fine; negative values are fine; a strictly increasing or decreasing array yields answer $1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxIntersections(self, y: List[int]) -> int:
        n = len(y)
        if n <= 1:
            return 0
        # Build candidate heights: endpoints and local midpoints
        candidates = set()
        for v in y:
            candidates.add(float(v))
        for i in range(n - 1):
            candidates.add((y[i] + y[i + 1]) / 2.0)
        # Count intersections at each candidate height using (min, max]
        def count_at(h: float) -> int:
            cnt = 0
            for i in range(n - 1):
                a, b = y[i], y[i + 1]
                if a == b:
                    continue
                lo, hi = (a, b) if a < b else (b, a)
                if h > lo and h <= hi:
                    cnt += 1
            return cnt
        ans = 0
        for h in candidates:
            ans = max(ans, count_at(h))
        return ans

# Basic asserts
sol = Solution()
assert sol.maxIntersections([1, 3, 2, 5]) == 3
assert sol.maxIntersections([5, 5, 5]) == 0
assert sol.maxIntersections([0, 10, 0]) == 2
assert sol.maxIntersections([1, 2]) == 1
\end{minted}
\VALIDATION{Checked strictly monotone (answer 1), all equal (answer 0), and a peak (answer 2).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Sweep Over Endpoints}
\WHICHFORMULA{Reduce to maximum overlap of half-open intervals $(a_i,b_i]$ using an event sweep. Avoid floating point by mapping to doubled integer coordinates to encode open/closed boundaries.}
\ASSUMPTIONS{For each non-horizontal segment with endpoints $(a,b)$, add $+1$ at $2\cdot \min(a,b)+1$ (just after the open left endpoint) and $-1$ at $2\cdot \max(a,b)+2$ (just after the inclusive right endpoint). The running prefix sum gives coverage counts at interleaved half-integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an event multiset (dictionary) $E$.
\item For each $i$, if $y_i \ne y_{i+1}$, let $lo=\min(y_i,y_{i+1})$, $hi=\max(y_i,y_{i+1})$; do $E[2\cdot lo+1] \mathrel{+}=1$ and $E[2\cdot hi+2] \mathrel{+}=-1$.
\item Sweep keys of $E$ in ascending order, maintaining a prefix sum; update the maximum observed sum.
\end{algosteps}
\COMPLEXITY{Sorting $O(n)$ events dominates: $T(n)=O(n\log n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n \log n) \quad \text{(event sorting)}.
\end{aligned}
\]
\CORRECTNESS{The doubling scheme places $+1$ strictly after $lo$ and retains coverage up to and including $hi$; thus the prefix sum equals $f(h)$ for heights between consecutive original integers or exactly at integers where defined, achieving the global maximum.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
from collections import defaultdict

class Solution:
    def maxIntersections(self, y: List[int]) -> int:
        n = len(y)
        events = defaultdict(int)
        for i in range(n - 1):
            a, b = y[i], y[i + 1]
            if a == b:
                continue
            lo, hi = (a, b) if a < b else (b, a)
            start = 2 * lo + 1   # just after the open left endpoint
            end = 2 * hi + 2     # just after the inclusive right endpoint
            events[start] += 1
            events[end] -= 1
        if not events:
            return 0
        curr = 0
        best = 0
        for x in sorted(events.keys()):
            curr += events[x]
            if curr > best:
                best = curr
        return best

# Cross-checks vs brute force on small randoms
def brute_max(y: List[int]) -> int:
    n = len(y)
    cands = set(float(v) for v in y)
    for i in range(n - 1):
        cands.add((y[i] + y[i + 1]) / 2.0)
    def count_at(h: float) -> int:
        cnt = 0
        for i in range(n - 1):
            a, b = y[i], y[i + 1]
            if a == b:
                continue
            lo, hi = (a, b) if a < b else (b, a)
            if h > lo and h <= hi:
                cnt += 1
        return cnt
    return max((count_at(h) for h in cands), default=0)

sol = Solution()
assert sol.maxIntersections([1, 3, 2, 5]) == 3
assert sol.maxIntersections([5, 5, 5]) == 0
assert sol.maxIntersections([0, 10, 0]) == 2
assert sol.maxIntersections([1, 2]) == 1
# Additional small stress
import random
random.seed(0)
for _ in range(200):
    n = random.randint(2, 10)
    arr = [random.randint(-5, 5) for _ in range(n)]
    assert sol.maxIntersections(arr) == brute_max(arr)
\end{minted}
\VALIDATION{Compared against the $O(n^2)$ brute force on hundreds of random small arrays; matched on crafted edge cases (all equal, peak, valley, monotone).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Event Sweep with Integer-Lifted Endpoints}
\WHICHFORMULA{Same event sweep as Approach B; it is optimal up to sorting lower bound. Use only integer arithmetic and a single pass to compute the maximum overlap of $(\min,\max]$ intervals.}
\ASSUMPTIONS{Inputs can be large in magnitude; Python integers are unbounded. If adopting a compiled language, use 64-bit integers for the lifted coordinates $2y_i+\{1,2\}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each non-horizontal segment, emit two integer events at $2\cdot \min + 1$ with $+1$ and at $2\cdot \max + 2$ with $-1$.
\item Sort the event positions and scan, maintaining a running sum and the maximum.
\item Return the maximum.
\end{algosteps}
\OPTIMALITY{Any algorithm must read all $n-1$ segments, and distinguishing relative order of $O(n)$ arbitrary real endpoints requires $\Omega(n \log n)$ comparisons in the worst case. The sweep achieves this bound.}
\COMPLEXITY{$T(n)=O(n\log n)$ time for sorting events and $S(n)=O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n\log n), \qquad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
from collections import defaultdict

class Solution:
    def maxIntersections(self, y: List[int]) -> int:
        n = len(y)
        if n <= 1:
            return 0
        events = defaultdict(int)
        for i in range(n - 1):
            a, b = y[i], y[i + 1]
            if a == b:
                continue
            lo, hi = (a, b) if a < b else (b, a)
            events[2 * lo + 1] += 1
            events[2 * hi + 2] -= 1
        if not events:
            return 0
        curr = 0
        best = 0
        for pos in sorted(events):
            curr += events[pos]
            if curr > best:
                best = curr
        return best

# Exactly 3 asserts
sol = Solution()
assert sol.maxIntersections([1, 3, 2, 5]) == 3
assert sol.maxIntersections([5, 5, 5]) == 0
assert sol.maxIntersections([0, 10, 0]) == 2
\end{minted}
\VALIDATION{Verified on two simple examples and one peak/valley example.}
\RESULT{The returned integer is the maximum number of chart segments simultaneously cut by some horizontal line $Y=h$ under the $(\min,\max]$ counting convention, which counts a shared vertex as a single intersection.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on canonical cases: all equal, strictly monotone, single peak or valley, random small arrays cross-checked against a brute force. Property: Answer $\le n-1$.}
\LINE{CROSS-CHECKS}{Compare the $O(n^2)$ brute force with the sweep on random arrays of size up to 10 for many seeds.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with duplicates, zeros, negatives, alternations to stress local extrema and repeated heights.}
\begin{minted}{python}
from typing import List
from collections import defaultdict
import random

def brute_max(y: List[int]) -> int:
    n = len(y)
    if n <= 1:
        return 0
    cands = set(float(v) for v in y)
    for i in range(n - 1):
        cands.add((y[i] + y[i + 1]) / 2.0)
    def count_at(h: float) -> int:
        cnt = 0
        for i in range(n - 1):
            a, b = y[i], y[i + 1]
            if a == b:
                continue
            lo, hi = (a, b) if a < b else (b, a)
            if h > lo and h <= hi:
                cnt += 1
        return cnt
    return max((count_at(h) for h in cands), default=0)

class Solution:
    def maxIntersections(self, y: List[int]) -> int:
        n = len(y)
        events = defaultdict(int)
        for i in range(n - 1):
            a, b = y[i], y[i + 1]
            if a == b:
                continue
            lo, hi = (a, b) if a < b else (b, a)
            events[2 * lo + 1] += 1
            events[2 * hi + 2] -= 1
        curr = 0
        best = 0
        for pos in sorted(events):
            curr += events[pos]
            if curr > best:
                best = curr
        return best

# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_equal(n: int, v: int) -> List[int]:
    return [v] * n

def gen_monotone(n: int, start: int, step: int) -> List[int]:
    return [start + i * step for i in range(n)]

def gen_alt(n: int, a: int, b: int) -> List[int]:
    return [a if i % 2 == 0 else b for i in range(n)]

# Cross-checks
random.seed(1)
sol = Solution()
# Canonical cases
assert sol.maxIntersections([1, 3, 2, 5]) == 3
assert sol.maxIntersections([5, 5, 5]) == 0
assert sol.maxIntersections([0, 10, 0]) == 2
assert sol.maxIntersections([1, 2]) == 1
# Families
for n in range(2, 9):
    arr = gen_all_equal(n, 7)
    assert sol.maxIntersections(arr) == 0
    arr = gen_monotone(n, -3, 2)
    assert sol.maxIntersections(arr) == 1
    arr = gen_monotone(n, 10, -1)
    assert sol.maxIntersections(arr) == 1
    arr = gen_alt(n, -2, 3)
    assert sol.maxIntersections(arr) == brute_max(arr)
# Randoms
for _ in range(200):
    n = random.randint(2, 12)
    arr = [random.randint(-8, 8) for _ in range(n)]
    assert sol.maxIntersections(arr) == brute_max(arr)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
from collections import defaultdict

class Solution:
    def maxIntersections(self, y: List[int]) -> int:
        """
        Return the maximum number of intersections between the horizontal line Y=h
        and the chart that connects consecutive points (i, y[i]) with straight segments.
        Counting uses (min, max]: horizontal segments contribute nothing.
        """
        n = len(y)
        if n <= 1:
            return 0
        events = defaultdict(int)
        for i in range(n - 1):
            a, b = y[i], y[i + 1]
            if a == b:
                continue  # horizontal segment contributes nothing
            lo, hi = (a, b) if a < b else (b, a)
            # Lift to integers to encode open/closed ends: (lo, hi] -> +1 after lo, -1 after hi
            events[2 * lo + 1] += 1
            events[2 * hi + 2] -= 1
        if not events:
            return 0
        curr = 0
        best = 0
        for pos in sorted(events):
            curr += events[pos]
            if curr > best:
                best = curr
        return best

# Self-checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxIntersections([1, 3, 2, 5]) == 3
    assert sol.maxIntersections([5, 5, 5]) == 0
    assert sol.maxIntersections([0, 10, 0]) == 2
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reduce to maximum overlap over $(\min,\max]$ intervals for consecutive pairs and sweep their endpoints.}
\WHY{Common pattern in geometry and sweepline interview questions: count overlaps at a best level without brute force.}
\CHECKLIST{
\begin{bullets}
\item Build intervals only for non-horizontal segments.
\item Use half-open $(\min,\max]$ to avoid double counting at vertices.
\item Encode open/closed with integer lifting or reliable tie-breaking.
\item Sweep events in sorted order, maintain running count and maximum.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item All values equal $\Rightarrow 0$.
\item Strictly monotone array $\Rightarrow 1$.
\item Peaks/valleys like $[0,10,0]$ or $[10,0,10]$ $\Rightarrow 2$.
\item Repeated heights around a peak, e.g., $[2,5,5,2]$.
\item Large magnitudes and negatives.
\item Consecutive duplicates interspersed with changes.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Counting both endpoints of touching segments at a vertex without half-open fix.
\item Forgetting to ignore horizontal segments ($y_i=y_{i+1}$).
\item Floating point comparisons at endpoints leading to off-by-one behavior.
\item Processing event tie-breaks in the wrong order; use integer lifting to avoid.
\item Overflow in other languages if doubling endpoints without 64-bit integers.
\item Missing the case when no events exist (answer should be $0$).
\end{bullets}
}
\FAILMODES{Brute-force sampling only at endpoints misses the interior plateaus where the maximum occurs; naive inclusive intervals $[\min,\max]$ double count at joints. The proposed sweep with $(\min,\max]$ and integer lifting addresses both.}
\ELI{Turn each slanted chart edge into a vertical interval on the $y$-axis. The best horizontal line is one that passes through the most of these intervals. Counting overlaps with a single sorted pass finds that best line quickly and correctly.}
\NotePages{3}

\end{document}