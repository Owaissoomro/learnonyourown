% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Balanced Stone Heaps}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1623/C}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{There are $n$ heaps of stone. The $i$-th heap has $h_i$ stones. You want to change the number of stones in the heap by performing the following process once:

\begin{bullets}
\item You go through the heaps from the $3$-rd heap to the $n$-th heap, in this order.
\item Let $i$ be the number of the current heap.
\item You can choose a number $d$ ($0 \le 3 \cdot d \le h_i$), move $d$ stones from the $i$-th heap to the $(i - 1)$-th heap, and $2 \cdot d$ stones from the $i$-th heap to the $(i - 2)$-th heap.
\item So after that $h_i$ is decreased by $3 \cdot d$, $h_{i - 1}$ is increased by $d$, and $h_{i - 2}$ is increased by $2 \cdot d$.
\item You can choose different or same $d$ for different operations. Some heaps may become empty, but they still count as heaps.
\end{bullets}

What is the maximum number of stones in the smallest heap after the process?

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 2 \cdot 10^5$). Description of the test cases follows.

The first line of each test case contains a single integer $n$ ($3 \le n \le 2 \cdot 10^5$).

The second lines of each test case contains $n$ integers $h_1, h_2, h_3, \ldots, h_n$ ($1 \le h_i \le 10^9$).

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

Output:
For each test case, print the maximum number of stones that the smallest heap can contain.

Note:
In the first test case, the initial heap sizes are $[1, 2, 10, 100]$. We can move the stones as follows.

\begin{bullets}
\item move $3$ stones and $6$ from the $3$-rd heap to the $2$-nd and $1$ heap respectively. The heap sizes will be $[7, 5, 1, 100]$;
\item move $6$ stones and $12$ stones from the last heap to the $3$-rd and $2$-nd heap respectively. The heap sizes will be $[7, 17, 7, 82]$.
\end{bullets}

In the second test case, the last heap is $1$, and we can not increase its size.

In the third test case, it is better not to move any stones.

In the last test case, the final achievable configuration of the heaps can be $[3, 5, 3, 4, 3, 3]$.}
\BREAKDOWN{We must maximize the minimum heap value after one leftward redistribution pass where each move reduces heap $i$ by $3 \cdot d$ and increases $i-1$ and $i-2$ by $d$ and $2 \cdot d$. This is a feasibility check on a candidate minimum via greedy simulation from right to left, wrapped in binary search.}
\ELI{Binary search the answer $x$ and check if we can keep every heap at least $x$ by pushing surplus from right to left in $1:2$ chunks, never forwarding stones that arrive after a heap's turn.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case:
\begin{bullets}
\item $n$ (integer), $3 \le n \le 2 \cdot 10^5$.
\item Array $h[1..n]$ with $1 \le h_i \le 10^9$.
\item Over all test cases, $\sum n \le 2 \cdot 10^5$.
\end{bullets}}
\OUTPUTS{For each test case, a single integer: the maximum achievable value of $\min_i h_i$ after the process.}
\SAMPLES{Example 1

Input
\begin{tcolorbox}
2\\
3\\
1\ 1\ 1\\
4\\
1\ 2\ 10\ 100
\end{tcolorbox}
Output
\begin{tcolorbox}
1\\
7
\end{tcolorbox}

Example 2

Input
\begin{tcolorbox}
2\\
3\\
2\ 2\ 2\\
5\\
1\ 2\ 3\ 4\ 5
\end{tcolorbox}
Output
\begin{tcolorbox}
2\\
2
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $h \in \mathbb{Z}_{\ge 0}^n$, one pass over $i=3,\ldots,n$ applies operations $h_i \leftarrow h_i - 3d_i$, $h_{i-1} \leftarrow h_{i-1} + d_i$, $h_{i-2} \leftarrow h_{i-2} + 2d_i$ with integer $d_i \ge 0$ and $3d_i \le h_i$ at the time of step $i$. Objective: maximize $x$ such that final $h_i \ge x$ for all $i$.}
\varmapStart
\var{n}{number of heaps}
\var{h_i}{initial stones in heap $i$}
\var{x}{candidate minimum heap value}
\var{d_i}{integer number of $3$-stone groups moved from heap $i$}
\var{b_i}{working copy during feasibility check}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Feasibility of }x:\ \exists d_3,\ldots,d_n \in \mathbb{Z}_{\ge 0} \\
&\text{such that }\forall i\in\{3,\ldots,n\}:\ 3d_i \le h_i^{\text{at step }i},\\
&\text{and final }h_1,h_2,\ldots,h_n \text{ satisfy } h_i \ge x,\\
&\text{with updates } h_i \gets h_i - 3d_i,\ h_{i-1} \gets h_{i-1} + d_i,\ h_{i-2} \gets h_{i-2} + 2d_i.
\end{aligned}
\]
}
\ASSUMPTIONS{Single pass leftward only; $d_i$ integral; later heaps may contribute to earlier heaps after their turn, which cannot be forwarded further by those earlier heaps.}
\INVARIANTS{
\begin{bullets}
\item Total stones conserved: $\sum_i h_i$ remains constant.
\item For any heap $i$, the number of $3$-stone groups removed at its turn is at most $\left\lfloor \tfrac{h_i^{\text{initial}}}{3}\right\rfloor$.
\item Right-to-left greedy can cap extractions from $i$ by $\min\!\big(\left\lfloor \tfrac{b_i - x}{3}\right\rfloor,\left\lfloor \tfrac{h_i}{3}\right\rfloor\big)$ to avoid forwarding late arrivals.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Exhaust over candidate $x$ from $0$ up to $\max(h)$ and test feasibility with a greedy right-to-left pass that respects the per-heap extraction cap.}
\ASSUMPTIONS{Suitable only for tiny inputs; correctness prioritized over performance.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For $x$ from $0$ to $\max(h)$:
\item Copy $h$ to $b$. For $i=n,n-1,\ldots,3$:
\begin{bullets}
\item If $b_i < x$, then $x$ infeasible.
\item Let $s = b_i - x$ and $g = \min\!\big(\left\lfloor s/3 \right\rfloor,\left\lfloor h_i/3 \right\rfloor\big)$. Do $b_{i-1}{+}{=}g$, $b_{i-2}{+}{=}2g$.
\end{bullets}
\item If $b_1 \ge x$ and $b_2 \ge x$, mark $x$ feasible. Track the maximum feasible $x$.
\end{algosteps}
\COMPLEXITY{For each test case with $n$ heaps and $H=\max(h)$, the baseline is $O(n \cdot H)$, which is exponential in bits of input size and thus impractical for worst-case $H=10^9$. Space $O(n)$.}
\[
\begin{aligned}
T(n) &= \sum_{x=0}^{H} O(n) \\
     &= O(n \cdot H).
\end{aligned}
\]
\CORRECTNESS{The greedy right-to-left feasibility pass is canonical: any surplus above $x$ at $i$ can be safely pushed left while capping by $\left\lfloor h_i/3 \right\rfloor$ to honor that heap $i$ cannot forward stones it receives later. If after processing all $i\ge 3$, both $b_1,b_2 \ge x$, then a valid sequence of $d_i$ exists.}
\EDGECASES{Minimal $n=3$; heaps already balanced; very large last heap; all heaps equal; inability to increase due to mod-$3$ constraints handled by flooring.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def max_min_baseline_one(h: List[int]) -> int:
    n = len(h)
    H = max(h)
    def can(x: int) -> bool:
        b = h[:]  # working copy
        # process from right to left
        for i in range(n - 1, 1, -1):
            if b[i] < x:
                return False
            surplus = b[i] - x
            # cannot use more than original h[i] in 3-stone groups at heap i
            g = min(surplus // 3, h[i] // 3)
            b[i - 1] += g
            b[i - 2] += 2 * g
        return b[0] >= x and b[1] >= x

    ans = 0
    for x in range(H + 1):
        if can(x):
            ans = x
    return ans

# CF-style API wrappers (baseline)
def read_input() -> List[List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append(arr)
    return cases

def solve_case(h: List[int]) -> int:
    # Baseline solver
    return max_min_baseline_one(h)

def solve_all(cases: List[List[int]]) -> List[int]:
    return [solve_case(h) for h in cases]

# Tiny asserts (baseline; keep cases small to avoid slowness)
assert max_min_baseline_one([1, 1, 1]) == 1
assert max_min_baseline_one([1, 2, 10, 100]) == 7
assert max_min_baseline_one([2, 2, 2]) == 2

def main():
    cases = read_input()
    ans = solve_all(cases)
    import sys
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    # Skip running baseline main by default to avoid slowness on large inputs.
    # Uncomment the following line to run baseline on provided stdin.
    # main()
    pass
\end{minted}
\VALIDATION{Checked on tiny arrays for correctness; the flooring and cap by original $h_i$ ensure we do not forward late-arriving stones.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Binary search the optimal minimum $x$ in $[0,\max(h)]$, using the same greedy feasibility. This reduces the outer loop from $H$ to $O(\log H)$.}
\ASSUMPTIONS{Monotonicity: If a target $x$ is feasible, then any $x' \le x$ is also feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define feasibility check $\text{can}(x)$ as in Approach A with right-to-left greedy and the extraction cap.
\item Binary search $x$ in $[0,\max(h)]$ for the maximum feasible value.
\item Return the best feasible $x$.
\end{algosteps}
\COMPLEXITY{Feasibility is $O(n)$, and binary search performs $O(\log \max(h))$ checks. Overall $O(n \log \max(h))$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O\!\big(n \log \max(h)\big).
\end{aligned}
\]
\CORRECTNESS{Monotonicity holds because requiring a smaller minimum cannot invalidate a previously valid redistribution. The greedy capping by $\lfloor h_i/3 \rfloor$ preserves the single-pass constraint that a heap cannot forward stones it receives later.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

def max_min_improved_one(h: List[int]) -> int:
    n = len(h)

    def can(x: int) -> bool:
        b = h[:]  # working copy
        for i in range(n - 1, 1, -1):
            if b[i] < x:
                return False
            surplus = b[i] - x
            g = min(surplus // 3, h[i] // 3)  # cap by original h[i]
            b[i - 1] += g
            b[i - 2] += 2 * g
        return b[0] >= x and b[1] >= x

    lo, hi = 0, max(h)
    ans = 0
    while lo <= hi:
        mid = (lo + hi) // 2
        if can(mid):
            ans = mid
            lo = mid + 1
        else:
            hi = mid - 1
    return ans

# Same CF-style API
def read_input() -> List[List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append(arr)
    return cases

def solve_case(h: List[int]) -> int:
    return max_min_improved_one(h)

def solve_all(cases: List[List[int]]) -> List[int]:
    return [solve_case(h) for h in cases]

# Asserts
assert max_min_improved_one([1, 1, 1]) == 1
assert max_min_improved_one([1, 2, 10, 100]) == 7
assert max_min_improved_one([2, 2, 2]) == 2
\end{minted}
\VALIDATION{Edge cases verified: $n=3$; homogeneous arrays; a very large last heap with small earlier heaps.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Binary search on the answer with a linear-time feasibility check that greedily pushes surplus from right to left, limiting extraction at heap $i$ by both surplus and $\left\lfloor h_i/3 \right\rfloor$.}
\ASSUMPTIONS{Non-decreasing feasibility in $x$; integers and floor divisions enforce the indivisibility of moves.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set search range $[0, \max(h)]$.
\item For a candidate $x$, copy $h$ to $b$ and traverse $i=n,n-1,\ldots,3$:
\begin{bullets}
\item If $b_i < x$, return infeasible.
\item Let $g = \min\!\big(\left\lfloor (b_i - x)/3 \right\rfloor, \left\lfloor h_i/3 \right\rfloor\big)$.
\item Update $b_{i-1}{+}{=}g$, $b_{i-2}{+}{=}2g$.
\end{bullets}
\item After the loop, check $b_1 \ge x$ and $b_2 \ge x$.
\item Binary search to find the maximum feasible $x$.
\end{algosteps}
\OPTIMALITY{A standard exchange argument shows that pushing as much surplus as possible from the right never reduces feasibility for earlier heaps, due to the fixed $1{:}2$ distribution and the single-pass restriction. Monotonicity yields optimality via binary search.}
\COMPLEXITY{For each test case, time $O(n \log \max(h))$ and space $O(n)$.}
\[
\begin{aligned}
T(n) &= O\!\big(n \log \max(h)\big).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

def max_min_heap(h: List[int]) -> int:
    n = len(h)

    def can(x: int) -> bool:
        b = h[:]  # working copy that collects leftward pushes
        for i in range(n - 1, 1, -1):
            if b[i] < x:
                return False
            surplus = b[i] - x
            # Limit by original h[i] to avoid forwarding late-arriving stones
            g = min(surplus // 3, h[i] // 3)
            b[i - 1] += g
            b[i - 2] += 2 * g
        return b[0] >= x and b[1] >= x

    lo, hi = 0, max(h)
    ans = 0
    while lo <= hi:
        mid = (lo + hi) // 2
        if can(mid):
            ans = mid
            lo = mid + 1
        else:
            hi = mid - 1
    return ans

# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
def read_input() -> List[List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append(arr)
    return cases

def solve_case(h: List[int]) -> int:
    return max_min_heap(h)

def solve_all(cases: List[List[int]]) -> List[int]:
    return [solve_case(h) for h in cases]

# Exactly 3 asserts / I/O mini-tests
assert max_min_heap([1, 1, 1]) == 1
assert max_min_heap([1, 2, 10, 100]) == 7
assert max_min_heap([3, 5, 3, 4, 3, 3]) == 3

def main():
    cases = read_input()
    ans = solve_all(cases)
    import sys
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts cover uniform, illustrative, and already-balanced cases.}
\RESULT{For each test, print the maximal achievable minimum heap size after one pass. No tie-breaking beyond the numeric maximum is needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on hand-crafted small arrays; random stress with small $n$ comparing baseline vs optimal; edge cases like $n=3$, large trailing heap, all equal heaps.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (linear scan) and Approach C (binary search) for many tiny random instances to ensure equivalence.}
\LINE{EDGE-CASE GENERATOR}{Produce arrays with: all ones; arithmetic progressions; a spike at the end; random values in small ranges, to exercise divisibility and capping by $\lfloor h_i/3 \rfloor$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_all_ones(n: int, v: int = 1):
    return [v] * n

def gen_trailing_spike(n: int, base: int, spike: int):
    a = [base] * (n - 1) + [spike]
    return a

def gen_arith_progression(n: int, a0: int, d: int):
    return [a0 + i * d for i in range(n)]

def brute_force_check(h):
    # slow baseline (use small inputs)
    from copy import deepcopy
    n = len(h)
    H = max(h)
    def can(x):
        b = deepcopy(h)
        for i in range(n - 1, 1, -1):
            if b[i] < x: return False
            s = b[i] - x
            g = min(s // 3, h[i] // 3)
            b[i-1] += g
            b[i-2] += 2 * g
        return b[0] >= x and b[1] >= x
    ans = 0
    for x in range(H + 1):
        if can(x): ans = x
    return ans

def optimal_check(h):
    return max_min_heap(h)

# Cross-check on random tiny cases
random.seed(0)
for n in range(3, 9):
    for _ in range(50):
        arr = [random.randint(1, 15) for __ in range(n)]
        assert brute_force_check(arr) == optimal_check(arr)

# Boundary-style checks
assert optimal_check(gen_all_ones(3)) == 1
assert optimal_check(gen_trailing_spike(5, 1, 100)) >= 1
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

def max_min_heap(h: List[int]) -> int:
    n = len(h)

    def can(x: int) -> bool:
        b = h[:]  # working copy that collects leftward pushes
        for i in range(n - 1, 1, -1):
            if b[i] < x:
                return False
            surplus = b[i] - x
            # Limit by original h[i] to avoid forwarding late-arriving stones
            g = min(surplus // 3, h[i] // 3)
            b[i - 1] += g
            b[i - 2] += 2 * g
        return b[0] >= x and b[1] >= x

    lo, hi = 0, max(h)
    ans = 0
    while lo <= hi:
        mid = (lo + hi) // 2
        if can(mid):
            ans = mid
            lo = mid + 1
        else:
            hi = mid - 1
    return ans

def read_input() -> List[List[int]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append(arr)
    return cases

def solve_case(h: List[int]) -> int:
    return max_min_heap(h)

def solve_all(cases: List[List[int]]) -> List[int]:
    return [solve_case(h) for h in cases]

# Sanity asserts
assert max_min_heap([1, 1, 1]) == 1
assert max_min_heap([1, 2, 10, 100]) == 7
assert max_min_heap([2, 2, 2]) == 2

def main():
    cases = read_input()
    ans = solve_all(cases)
    import sys
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Binary search the maximum feasible minimum; simulate feasibility from right to left, capping extraction by both surplus and $\lfloor h_i/3 \rfloor$.}
\WHY{Greedy feasibility with monotonic answers is a common CF motif; this problem tests careful modeling of single-pass constraints.}
\CHECKLIST{
\begin{bullets}
\item Define $\text{can}(x)$ with a working copy $b$.
\item Traverse $i=n\to 3$; if $b_i<x$ then infeasible.
\item Compute $g=\min\big(\lfloor (b_i-x)/3\rfloor,\lfloor h_i/3\rfloor\big)$.
\item Update $b_{i-1}{+}{=}g$, $b_{i-2}{+}{=}2g$.
\item Check $b_1,b_2 \ge x$.
\item Binary search for the maximal feasible $x$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $n=3$ only first two can receive; last cannot receive.
\item All heaps equal.
\item Very large $h_n$ vs small others.
\item Arrays where $(b_i-x)$ is not divisible by $3$.
\item Cases where $b_i$ grows due to right contributions, but $h_i/3$ capping matters.
\item Minimal values $h_i=1$.
\item Tight sums where answer equals $\left\lfloor \tfrac{\sum h_i}{n}\right\rfloor$ or slightly less due to locality constraints.
\item Long chains where early heaps are initially tiny.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to cap by original $\lfloor h_i/3 \rfloor$, which wrongly forwards late-arriving stones.
\item Iterating left-to-right in feasibility, which breaks the greedy invariant.
\item Off-by-one on indices when updating $i-1$ and $i-2$.
\item Not checking $b_1$ and $b_2$ at the end.
\item Overflow not an issue in Python, but be mindful in other languages.
\item Misusing strict vs floor division in $g$.
\item Using the mutated $b[i]$ to cap groups instead of original $h[i]$.
\item Binary search bounds incorrect (e.g., starting at $1$ when answer could be $0$).
\end{bullets}}
\FAILMODES{Approaches that try to simulate the forward pass without binary search may miss optimality; naive DP across all $d_i$ choices explodes. Ignoring the cap by original $h_i$ produces infeasible chaining of transfers.}
\ELI{We guess an answer $x$ and check if we can keep every heap at least $x$ by shaving off chunks of $3$ from the right and pushing them left in $1{:}2$. We never reuse stones that arrive later at a heap, so we cap how much it can forward by its original size. Binary search finds the best $x$.}
\NotePages{3}

\end{document}