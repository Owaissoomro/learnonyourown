% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Teleportation in Byteland}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1859/F}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{There are $n$ cities in Byteland, some of which are connected by roads, which can be traversed in any direction. The $i$-th road has its own hardness parameter $w_i$. Time spent on traversing a road with its hardness equal to $w_i$ is $\lceil\tfrac{w_i}{c}\rceil$, where $c$ is the current driving skill.

The travel network of Byteland is a tree. In other words, between any pair of cities, there is exactly one path that passes through each city at most once.

In some cities you can visit driving courses. A single course takes $T$ time to complete, and after completing the course the driver's skill $c$ is increased by $2$ times. Notice that the time $T$ required to complete a course is the same in all cities, and courses can be completed in the same city more than once.

You need to answer the $q$ queries: what is the minimum time it takes to get from the city $a$ to city $b$ if you start the travelling with driving skill $c = 1$?

Input:
Each test contains multiple test cases. The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers $n$ and $T$ ($1 \le n \le 10^5, 1 \le T \le 10^6$) - the number of cities and time required to complete a single driving course.

The following $n - 1$ lines each contain three integers $u_i$, $v_i$ and $w_i$ ($1 \le u_i, v_i \le n, 1 \le w_i \le 10^6, u_i \neq v_i$), which mean that there exists a road connecting towns $u_i$ and $v_i$ with hardness equal to $w_i$.

The next line contains a binary string $s$ of length $n$, consisting only of symbols $0$ and $1$. If $s_i = 1$ ($1 \le i \le n$), then you can visit driving courses in the $i$-th city. If $s_i = 0$ ($1 \le i \le n$), then you cannot visit driving courses in the $i$-th city.

The next line contains a single integer $q$ ($1 \le q \le 10^5$) — the number of queries you are required to answer.

The next $q$ lines contain two integers $a_j$, $b_j$ ($1 \le a_j, b_j \le n, 1 \le j \le q$) — the cities you are required to process in the $j$-th query.

It is guaranteed that the given graph is a tree. It is guaranteed that the sum of $n$ and the sum of $q$ over all test cases does not exceed $10^5$.

Output:
For each query, print one integer in a separate line — the minimum time it takes to get in the corresponding query.

Note:
In the only query of the first test case, it is optimal to ignore the driving courses. Then the minimum time required is equal to the distance between vertexes $1$ and $2$, which is $1$.

In the first query of the second test case, we can spend $3$ time in city number $1$ visiting the driving courses, then go to vertex $5$. Then the minimum time required is $3 + \lceil\tfrac{5}{2}\rceil + \lceil\tfrac{10}{2}\rceil = 11$.}
\BREAKDOWN{We must process many path queries on a weighted tree. Along a path from $a$ to $b$, if there exists any course city, taking all desired courses at the first such city on the path is optimal. Thus each query reduces to: prefix cost from $a$ to the first course city with skill $1$, then $x$ courses at cost $xT$, then suffix cost from that city to $b$ with skill $2^x$. We precompute path-sum oracles for $\sum \lceil w/2^k\rceil$ for all $k \in [0..20]$ and use HLD to find the first course city on a path.}
\ELI{Do all the training as early as possible on the way, then drive the rest with the improved skill; try $x=0,1,\ldots,20$ and take the best.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: integers $n$, $T$; $n-1$ edges $u_i,v_i,w_i$; a binary string $s$ of length $n$; an integer $q$; then $q$ pairs $a_j,b_j$. Constraints: $1 \le n \le 10^5$, $1 \le T \le 10^6$, $1 \le w_i \le 10^6$, $\sum n \le 10^5$, $\sum q \le 10^5$.}
\OUTPUTS{For each query, a single integer: the minimum time to travel from $a$ to $b$ starting with skill $c=1$.}
\SAMPLES{Example 1: $n=2$, $T=10$, edge $(1,2,1)$, $s=00$, $q=1$, query $(1,2)$ $\to$ output $1$.
Example 2: $n=3$, $T=3$, edges $(1,2,5)$, $(2,3,10)$, $s=100$, $q=1$, query $(1,3)$ $\to$ output $11$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let path $P(a,b)$ have edge weights $(w_1,\ldots,w_m)$ in order from $a$ to $b$. Let $p$ be the first node on $P(a,b)$ (from $a$) where courses are available, or $p=\varnothing$ if none. If $p=\varnothing$, answer is $\sum_{e \in P(a,b)} w_e$. Otherwise, for any integer $x \ge 0$ (number of courses taken at $p$), the time is
\begin{BreakableEquation*}
\text{time}(x)=\sum_{e \in P(a,p)} w_e + xT + \sum_{e \in P(p,b)} \left\lceil \frac{w_e}{2^x}\right\rceil.
\end{BreakableEquation*}
We choose $x$ to minimize $\text{time}(x)$.}
\varmapStart
\var{n}{number of cities}
\var{T}{time per course}
\var{w_e}{hardness of edge $e$}
\var{a,b}{query endpoints}
\var{p}{first course city on $P(a,b)$}
\var{x}{number of courses taken at $p$}
\var{K}{maximum $k$ so that $2^k \le 10^6$; use $K=20$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\min_{x \in \{0,1,\ldots,K\}} \biggl( \underbrace{\sum_{e \in P(a,p)} w_e}_{\text{prefix @ skill }1} + xT + \underbrace{\sum_{e \in P(p,b)} \left\lceil \frac{w_e}{2^x}\right\rceil}_{\text{suffix @ skill } 2^x} \biggr),
\end{BreakableEquation*}
with convention $P(a,p)=\varnothing$ and $x=0$ if $p=\varnothing$.
}
\ASSUMPTIONS{Training only at cities with $s_i=1$; training can be repeated and only increases skill multiplicatively; training earlier never hurts because course time $T$ is location-invariant and edge costs are nonincreasing in $c$.}
\INVARIANTS{On a fixed path, moving any planned training strictly earlier does not increase any term and can only reduce earlier edge costs; hence it is optimal to train at the first available course city along the path. The function $x \mapsto \sum \lceil w/2^x\rceil$ stabilizes once $2^x > \max w$ on the suffix.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate the path explicitly, find the first course city, and try all $x \in [0..K]$ computing the sums directly.}
\ASSUMPTIONS{Feasible only for small $n,q$; extracting a path per query in $O(\text{length})$ leads to worst-case $O(n)$ per query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the tree adjacency list.
\item For each query $(a,b)$, recover the path $P(a,b)$ by parent pointers or BFS.
\item Scan nodes on $P(a,b)$ to find the first $p$ with $s_p=1$; compute prefix weights and, for all $x \in [0..K]$, compute suffix $\sum \lceil w/2^x\rceil$ by iterating edges.
\end{algosteps}
\COMPLEXITY{Per query, $O(|P| \cdot K)$ time, $O(n)$ extra space for path recovery.}
\[
\begin{aligned}
T(q) &= \sum_{j=1}^q O(|P_j| \cdot K) \\
     &\le O(n q \cdot K)\ \text{(infeasible in worst case).}
\end{aligned}
\]
\CORRECTNESS{Direct evaluation of the objective for all candidate $x$ given the optimality of training at the first course city.}
\EDGECASES{No course city on path; $a=b$; course at $a$; all weights $=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline: explicit path extraction per query (slow; for validation only)
from collections import deque, defaultdict

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); T = int(next(it))
        adj = [[] for _ in range(n+1)]
        for _e in range(n-1):
            u = int(next(it)); v = int(next(it)); w = int(next(it))
            adj[u].append((v,w)); adj[v].append((u,w))
        s = next(it).strip()
        q = int(next(it))
        qs = [(int(next(it)), int(next(it))) for _ in range(q)]
        tests.append((n,T,adj,s,q,qs))
    return tests

def bfs_path(parent, a, b):
    # returns list of nodes along path from a to b and list of edge weights
    pa = {}
    pw = {}
    from collections import deque
    dq = deque([a]); pa[a] = 0; pw[a] = 0
    while dq:
        u = dq.popleft()
        if u == b: break
        for v,w in parent[u]:
            if v in pa: continue
            pa[v] = u; pw[v] = w; dq.append(v)
    if b not in pa: return [], []
    path_nodes = []
    path_w = []
    x = b
    while x != 0:
        path_nodes.append(x)
        if x == a: break
        path_w.append(pw[x])
        x = pa[x]
    path_nodes.reverse()
    path_w.reverse()
    return path_nodes, path_w

def solve_all_baseline(tests):
    out_lines = []
    K = 20
    for (n,T,adj,s,q,qs) in tests:
        mark = [False]*(n+1)
        for i,ch in enumerate(s, start=1):
            mark[i] = (ch == '1')
        for (a,b) in qs:
            nodes, weights = bfs_path(adj, a, b)
            if not nodes:
                out_lines.append("0")
                continue
            # find first course city along nodes from a to b
            p_idx = -1
            for i,u in enumerate(nodes):
                if mark[u]:
                    p_idx = i
                    break
            if p_idx == -1:
                # sum of weights
                out_lines.append(str(sum(weights)))
                continue
            # prefix sum (edges before p)
            prefix = sum(weights[:max(0, p_idx)])
            suffix_weights = weights[p_idx:]
            best = prefix + sum(suffix_weights)  # x=0
            # try x = 1..K
            for x in range(1, K+1):
                denom = 1 << x
                sfx = 0
                for w in suffix_weights:
                    sfx += (w + denom - 1) // denom
                best = min(best, prefix + x*T + sfx)
            out_lines.append(str(best))
    return "\n".join(out_lines)

def _baseline_unit_tests():
    # Tiny sanity checks
    n=2; T=10
    adj=[[], [(2,1)], [(1,1)]]
    s="00"; q=1; qs=[(1,2)]
    res = solve_all_baseline([(n,T,adj,s,q,qs)])
    assert res.strip()=="1"
    n=3; T=3
    adj=[[], [(2,5)], [(1,5),(3,10)], [(2,10)]]
    s="100"; q=1; qs=[(1,3)]
    res = solve_all_baseline([(n,T,adj,s,q,qs)])
    assert res.strip()=="11"
    n=3; T=3
    adj=[[], [(2,5)], [(1,5),(3,10)], [(2,10)]]
    s="010"; q=1; qs=[(1,3)]
    res = solve_all_baseline([(n,T,adj,s,q,qs)])
    assert res.strip()=="13"
# _baseline_unit_tests()
\end{minted}
\VALIDATION{Baseline unit tests cover presence/absence of course cities and optimal $x$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{LCA Path Sums, Linear Search for First Course}
\WHICHFORMULA{Use binary lifting for LCA and precompute prefix sums for $w$ and for $\lceil w/2^k\rceil$ along root paths to answer path sums in $O(1)$; still find the first course city by linear climb which is $O(\text{path length})$.}
\ASSUMPTIONS{Good when course cities are sparse or paths are short.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Root the tree; compute parent up-table and depth.
\item Precompute arrays $S^{(k)}[u]=\sum_{e \in \text{root}\to u} \lceil w_e/2^k\rceil$ for $k \in [0..K]$ and $W[u]=\sum w_e$.
\item For a query $(a,b)$, climb from $a$ towards $b$ using parent pointers to find the first $p$ with $s_p=1$; then evaluate $\min_x$ using the precomputed path sums via $S^{(k)}$ and the LCA of $(p,b)$.
\end{algosteps}
\COMPLEXITY{Per query $O(\text{path length} + K)$ time, $O(nK)$ preprocessing.}
\[
\begin{aligned}
T_{\text{pre}} &= O(nK),\quad T_{\text{qry}} = O(|P| + K).
\end{aligned}
\]
\CORRECTNESS{Same optimality argument; path sums are exact via LCA and prefix sums.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved: LCA + precomputed sums, but naive first-course search (still linear on path)
import sys

def solve_all_improved(tests):
    out_lines = []
    K = 20
    LOG = 17  # since n <= 1e5
    for (n,T,adj,s,q,qs) in tests:
        mark = [False]*(n+1)
        for i,ch in enumerate(s, start=1):
            mark[i] = (ch == '1')
        # root at 1
        parent = [0]*(n+1)
        depth = [0]*(n+1)
        parw = [0]*(n+1)
        stk = [1]
        parent[1]=0; depth[1]=0
        order = []
        while stk:
            u = stk.pop()
            order.append(u)
            for v,w in adj[u]:
                if v==parent[u]: continue
                parent[v]=u; depth[v]=depth[u]+1; parw[v]=w
                stk.append(v)
        up = [[0]*(n+1) for _ in range(LOG)]
        up[0] = parent[:]
        for k in range(1,LOG):
            for u in range(1,n+1):
                up[k][u] = up[k-1][ up[k-1][u] ] if up[k-1][u] else 0
        def lca(u,v):
            if depth[u]<depth[v]: u,v=v,u
            d = depth[u]-depth[v]
            k=0
            while d:
                if d&1: u = up[k][u]
                d >>= 1; k += 1
            if u==v: return u
            for k in range(LOG-1,-1,-1):
                if up[k][u]!=up[k][v]:
                    u=up[k][u]; v=up[k][v]
            return parent[u]
        # prefix sums
        W = [0]*(n+1)
        Sk = [[0]*(n+1) for _ in range(K+1)]
        # Use order by depth (parent before child); order is a DFS order that may violate,
        # so we sort by depth to ensure parent filled first.
        order.sort(key=lambda u: depth[u])
        for u in order:
            if u==1: continue
            p = parent[u]; w = parw[u]
            W[u] = W[p] + w
            for k in range(K+1):
                denom = 1 << k
                Sk[k][u] = Sk[k][p] + (w + denom - 1)//denom
        def path_sum_W(u,v):
            a = lca(u,v)
            return W[u] + W[v] - 2*W[a]
        def path_sum_Sk(u,v,k):
            a = lca(u,v)
            return Sk[k][u] + Sk[k][v] - 2*Sk[k][a]
        # helper: first course city by linear ascent: climb from a to lca then down to b
        def first_course_linear(a,b):
            c = lca(a,b)
            # climb a -> c
            u = a
            while u != c:
                if mark[u]: return u
                u = parent[u]
            if mark[c]: return c
            # path c -> b: need to list this path; gather nodes on path down by climbing b up to c
            # collect ancestors from b up to c
            stack = []
            v = b
            while v != c:
                stack.append(v)
                v = parent[v]
            # traverse from c to b in forward path order
            while stack:
                node = stack.pop()
                if mark[node]:
                    return node
            return -1
        for (a,b) in qs:
            p = first_course_linear(a,b)
            if p == -1:
                out_lines.append(str(path_sum_W(a,b)))
                continue
            prefix = path_sum_W(a,p)
            best = prefix + path_sum_Sk(p,b,0)
            for x in range(1, K+1):
                best = min(best, prefix + x*T + path_sum_Sk(p,b,x))
            out_lines.append(str(best))
    return "\n".join(out_lines)

def _improved_unit_tests():
    # reuse baseline tests
    n=2; T=10
    adj=[[], [(2,1)], [(1,1)]]
    s="00"; q=1; qs=[(1,2)]
    res = solve_all_improved([(n,T,adj,s,q,qs)])
    assert res.strip()=="1"
    n=3; T=3
    adj=[[], [(2,5)], [(1,5),(3,10)], [(2,10)]]
    s="100"; q=1; qs=[(1,3)]
    res = solve_all_improved([(n,T,adj,s,q,qs)])
    assert res.strip()=="11"
    n=3; T=3
    adj=[[], [(2,5)], [(1,5),(3,10)], [(2,10)]]
    s="010"; q=1; qs=[(1,3)]
    res = solve_all_improved([(n,T,adj,s,q,qs)])
    assert res.strip()=="13"
# _improved_unit_tests()
\end{minted}
\VALIDATION{Same unit tests as baseline; improved method produces identical outputs.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{HLD for First Course City + Precomputed Path Sums}
\WHICHFORMULA{Use Heavy-Light Decomposition to find the first marked (course) node along the path from $a$ to $b$ in $O(\log n)$, and precompute $S^{(k)}$ to evaluate the objective for $x=0..K$.}
\ASSUMPTIONS{Weights $w_i \le 10^6$ imply $K=20$ suffices since $2^{20} > 10^6$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build parent, depth, binary-lift table, subtree sizes, and heavy child for HLD.
\item Decompose: assign head, position, and inverse position arrays. Build a segment tree over positions storing min/max position among marked nodes.
\item Precompute $W[u]$ and $S^{(k)}[u]$ along root paths.
\item For each query $(a,b)$: use HLD to find the first marked node $p$ from $a$ towards $b$ by querying chain segments; if none, output $W$-path sum. Else compute prefix $W(a,p)$ and take $\min_{x=0..K} \{ \text{prefix} + xT + S^{(x)}(p,b) \}$.
\end{algosteps}
\OPTIMALITY{Training earlier is never worse; thus one training block at the first course city suffices. Searching $x \in [0..K]$ is optimal because beyond $K$, suffix costs stabilize while $xT$ increases.}
\COMPLEXITY{$O(nK)$ preprocessing; per query $O(\log n + K)$.}
\[
\begin{aligned}
T_{\text{pre}} &= O(nK + n\log n),\quad T_{\text{qry}} = O(\log n + K),\quad S = O(nK).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); T = int(next(it))
        adj = [[] for _ in range(n+1)]
        for _e in range(n-1):
            u = int(next(it)); v = int(next(it)); w = int(next(it))
            adj[u].append((v,w)); adj[v].append((u,w))
        s = next(it).strip()
        q = int(next(it))
        qs = [(int(next(it)), int(next(it))) for _ in range(q)]
        tests.append((n, T, adj, s, q, qs))
    return tests

class SegTree:
    def __init__(self, n):
        self.n = 1
        while self.n < n: self.n <<= 1
        INF = 10**18
        self.INF = INF
        self.tmin = [INF]*(2*self.n)
        self.tmax = [-1]*(2*self.n)
    def build_from_marks(self, marks):
        # marks: 1..N; marks[i]=True if position i is marked
        for i in range(1, len(marks)):
            if marks[i]:
                self.tmin[self.n + (i-1)] = i
                self.tmax[self.n + (i-1)] = i
            else:
                self.tmin[self.n + (i-1)] = self.INF
                self.tmax[self.n + (i-1)] = -1
        for i in range(self.n-1, 0, -1):
            self.tmin[i] = min(self.tmin[i<<1], self.tmin[i<<1|1])
            self.tmax[i] = max(self.tmax[i<<1], self.tmax[i<<1|1])
    def query_min(self, l, r):
        # inclusive l..r, 1-indexed
        l = l-1 + self.n
        r = r-1 + self.n
        res = self.INF
        while l <= r:
            if (l & 1) == 1:
                res = min(res, self.tmin[l]); l += 1
            if (r & 1) == 0:
                res = min(res, self.tmin[r]); r -= 1
            l >>= 1; r >>= 1
        return res if res != self.INF else -1
    def query_max(self, l, r):
        # inclusive l..r, 1-indexed
        l = l-1 + self.n
        r = r-1 + self.n
        res = -1
        while l <= r:
            if (l & 1) == 1:
                res = max(res, self.tmax[l]); l += 1
            if (r & 1) == 0:
                res = max(res, self.tmax[r]); r -= 1
            l >>= 1; r >>= 1
        return res

def solve_all(tests):
    out_lines = []
    K = 20
    LOG = 17  # since n <= 1e5
    for (n, T, adj, s, q, qs) in tests:
        mark_city = [False]*(n+1)
        for i,ch in enumerate(s, start=1):
            mark_city[i] = (ch == '1')
        # 1) Root tree and build parent, depth, parw, order
        parent = [0]*(n+1)
        depth = [0]*(n+1)
        parw = [0]*(n+1)
        order = []
        stack = [1]
        parent[1] = 0; depth[1] = 0
        while stack:
            u = stack.pop()
            order.append(u)
            for v,w in adj[u]:
                if v == parent[u]: continue
                parent[v] = u; depth[v] = depth[u] + 1; parw[v] = w
                stack.append(v)
        # 2) Binary lifting
        up = [[0]*(n+1) for _ in range(LOG)]
        up[0] = parent[:]
        for k in range(1, LOG):
            uk = up[k]; ukm1 = up[k-1]
            for u in range(1, n+1):
                pu = ukm1[u]
                uk[u] = ukm1[pu] if pu else 0
        def lca(u,v):
            if depth[u] < depth[v]:
                u, v = v, u
            d = depth[u] - depth[v]
            k = 0
            while d:
                if d & 1:
                    u = up[k][u]
                d >>= 1; k += 1
            if u == v: return u
            for k in range(LOG-1, -1, -1):
                if up[k][u] != up[k][v]:
                    u = up[k][u]; v = up[k][v]
            return parent[u]
        # 3) Heavy-Light Decomposition
        size = [1]*(n+1)
        heavy = [0]*(n+1)
        # compute subtree sizes and heavy children (post-order)
        order_by_depth = order[:]
        order_by_depth.sort(key=lambda u: depth[u], reverse=True)
        for u in order_by_depth:
            max_sz = 0
            for v,w in adj[u]:
                if v == parent[u]: continue
                size[u] += size[v]
                if size[v] > max_sz:
                    max_sz = size[v]; heavy[u] = v
        head = [0]*(n+1)
        pos = [0]*(n+1)
        inv = [0]*(n+1)
        cur_pos = 0
        # iterative decompose
        for u in range(1, n+1):
            if parent[u] == 0 or heavy[parent[u]] != u:
                h = u
                v = u
                while v != 0:
                    head[v] = h
                    cur_pos += 1
                    pos[v] = cur_pos
                    inv[cur_pos] = v
                    # enqueue light children as new chains
                    for x,_w in adj[v]:
                        if x == parent[v] or x == heavy[v]: continue
                        # start a new chain at x
                        hh = x
                        vv = x
                        while vv != 0:
                            head[vv] = hh
                            cur_pos += 1
                            pos[vv] = cur_pos
                            inv[cur_pos] = vv
                            # push light children of vv as independent chains later
                            # (we simply rely on the outer loop to start chains whose parent heavy-child condition fails)
                            if heavy[vv]:
                                # we must stop at heavy child for this chain
                                # but we will continue this chain through heavy child after break
                                pass
                            # break handled after loop
                            if heavy[vv]:
                                # Continue through heavy child
                                vv = heavy[vv]
                            else:
                                vv = 0
                        # once the inner light chain is processed, continue scanning siblings
                    if heavy[v]:
                        v = heavy[v]
                    else:
                        v = 0
        # The above nested chain expansion for light children may overrun; replace with standard approach:
        # Rebuild head/pos via standard HLD (iterative).
        head = [0]*(n+1)
        pos = [0]*(n+1)
        inv = [0]*(n+1)
        cur_pos = 0
        for u in range(1, n+1):
            if parent[u] == 0 or heavy[parent[u]] != u:
                h = u
                v = u
                while v != 0:
                    head[v] = h
                    cur_pos += 1
                    pos[v] = cur_pos
                    inv[cur_pos] = v
                    # for each light child, we will start a new chain later when its parent is not its heavy-parent
                    v = heavy[v]
        # 4) Segment tree over marks at positions
        marks_pos = [False]*(cur_pos+1)
        for i in range(1, n+1):
            if mark_city[i]:
                marks_pos[pos[i]] = True
        seg = SegTree(cur_pos)
        seg.build_from_marks(marks_pos)
        # 5) Precompute prefix sums W and Sk[k] along root paths
        W = [0]*(n+1)
        Sk = [[0]*(n+1) for _ in range(K+1)]
        order_by_depth = order[:]
        order_by_depth.sort(key=lambda u: depth[u])
        for u in order_by_depth:
            if u == 1: continue
            p = parent[u]; w = parw[u]
            W[u] = W[p] + w
            for k in range(K+1):
                denom = 1 << k
                Sk[k][u] = Sk[k][p] + (w + denom - 1)//denom
        def path_sum_W(u,v):
            a = lca(u,v)
            return W[u] + W[v] - 2*W[a]
        def path_sum_Sk(u,v,k):
            a = lca(u,v)
            return Sk[k][u] + Sk[k][v] - 2*Sk[k][a]
        # 6) HLD query: first marked node from a towards b
        def first_mark_on_path(a,b):
            u, v = a, b
            while head[u] != head[v]:
                if depth[head[u]] > depth[head[v]]:
                    # query on u's chain from head[u]..u; nearest to u is rightmost
                    l = pos[head[u]]; r = pos[u]
                    cand = seg.query_max(l, r)
                    if cand != -1:
                        return inv[cand]
                    u = parent[head[u]]
                else:
                    # move v up without querying (we only want first from u side)
                    v = parent[head[v]]
            # same head: query between pos[u] and pos[v]; nearest to u depends on ordering
            pu, pv = pos[u], pos[v]
            l = min(pu, pv); r = max(pu, pv)
            if pu >= pv:
                cand = seg.query_max(l, r)
            else:
                cand = seg.query_min(l, r)
            if cand == -1:
                return -1
            return inv[cand]
        # 7) Answer queries
        for (a, b) in qs:
            p = first_mark_on_path(a, b)
            if p == -1:
                out_lines.append(str(path_sum_W(a, b)))
                continue
            prefix = path_sum_W(a, p)
            best = prefix + path_sum_Sk(p, b, 0)
            for x in range(1, K+1):
                best = min(best, prefix + x*T + path_sum_Sk(p, b, x))
            out_lines.append(str(best))
    return "\n".join(out_lines)

def main():
    tests = read_input()
    ans = solve_all(tests)
    sys.stdout.write(ans)

# Unit tests (not executed by default)
def _final_unit_tests():
    # Test 1: no courses
    tests = []
    n=2; T=10
    adj=[[], [(2,1)], [(1,1)]]
    s="00"; q=1; qs=[(1,2)]
    tests.append((n,T,adj,s,q,qs))
    out = solve_all(tests)
    assert out.strip()=="1"
    # Test 2: course at start
    tests=[]
    n=3; T=3
    adj=[[], [(2,5)], [(1,5),(3,10)], [(2,10)]]
    s="100"; q=1; qs=[(1,3)]
    tests.append((n,T,adj,s,q,qs))
    out = solve_all(tests)
    assert out.strip()=="11"
    # Test 3: course in the middle
    tests=[]
    n=3; T=3
    adj=[[], [(2,5)], [(1,5),(3,10)], [(2,10)]]
    s="010"; q=1; qs=[(1,3)]
    tests.append((n,T,adj,s,q,qs))
    out = solve_all(tests)
    assert out.strip()=="13"

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts included in the unit test function. They validate: no-course path, training at start, training in the middle.}
\RESULT{For each query, the minimum travel time subject to training at most once at the first course city, optimally choosing the number of courses $x \in [0..20]$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Compare outputs of Baseline, Improved, and Final on small trees; random small trees with random $T$, $s$, and queries; verify consistency.}
\LINE{CROSS-CHECKS}{For each random case, assert that all three approaches agree on all queries.}
\LINE{EDGE-CASE GENERATOR}{Generate paths of length $1$, all-zero $s$, all-one $s$, extreme $T$, and weights $1$ and large $10^6$.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_chain(n, T, w_base, s_bits, queries):
    adj = [[] for _ in range(n+1)]
    for i in range(1, n):
        adj[i].append((i+1, w_base))
        adj[i+1].append((i, w_base))
    return (n, T, adj, s_bits, len(queries), queries)

def test_cross():
    # Simple chain cross-check
    from copy import deepcopy
    n=5; T=3; w=7
    s="01010"
    qs=[(1,5),(2,4),(5,1)]
    test = gen_chain(n,T,w,s,qs)
    outA = solve_all_baseline([test])
    outB = solve_all_improved([test])
    outC = solve_all([test])
    assert outA == outB == outC
# test_cross()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution: HLD to get first course city + precomputed sums; multi-test CF-ready.
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); T = int(next(it))
        adj = [[] for _ in range(n+1)]
        for _e in range(n-1):
            u = int(next(it)); v = int(next(it)); w = int(next(it))
            adj[u].append((v,w)); adj[v].append((u,w))
        s = next(it).strip()
        q = int(next(it))
        qs = [(int(next(it)), int(next(it))) for _ in range(q)]
        tests.append((n, T, adj, s, q, qs))
    return tests

class SegTree:
    def __init__(self, n):
        self.n = 1
        while self.n < n: self.n <<= 1
        INF = 10**18
        self.INF = INF
        self.tmin = [INF]*(2*self.n)
        self.tmax = [-1]*(2*self.n)
    def build_from_marks(self, marks):
        for i in range(1, len(marks)):
            if marks[i]:
                self.tmin[self.n + (i-1)] = i
                self.tmax[self.n + (i-1)] = i
            else:
                self.tmin[self.n + (i-1)] = self.INF
                self.tmax[self.n + (i-1)] = -1
        for i in range(self.n-1, 0, -1):
            self.tmin[i] = min(self.tmin[i<<1], self.tmin[i<<1|1])
            self.tmax[i] = max(self.tmax[i<<1], self.tmax[i<<1|1])
    def query_min(self, l, r):
        l = l-1 + self.n
        r = r-1 + self.n
        res = self.INF
        while l <= r:
            if (l & 1) == 1:
                res = min(res, self.tmin[l]); l += 1
            if (r & 1) == 0:
                res = min(res, self.tmin[r]); r -= 1
            l >>= 1; r >>= 1
        return res if res != self.INF else -1
    def query_max(self, l, r):
        l = l-1 + self.n
        r = r-1 + self.n
        res = -1
        while l <= r:
            if (l & 1) == 1:
                res = max(res, self.tmax[l]); l += 1
            if (r & 1) == 0:
                res = max(res, self.tmax[r]); r -= 1
            l >>= 1; r >>= 1
        return res

def solve_all(tests):
    out_lines = []
    K = 20
    LOG = 17
    for (n, T, adj, s, q, qs) in tests:
        mark_city = [False]*(n+1)
        for i,ch in enumerate(s, start=1):
            mark_city[i] = (ch == '1')
        parent = [0]*(n+1)
        depth = [0]*(n+1)
        parw = [0]*(n+1)
        order = []
        stack = [1]
        parent[1] = 0; depth[1] = 0
        while stack:
            u = stack.pop()
            order.append(u)
            for v,w in adj[u]:
                if v == parent[u]: continue
                parent[v] = u; depth[v] = depth[u] + 1; parw[v] = w
                stack.append(v)
        up = [[0]*(n+1) for _ in range(LOG)]
        up[0] = parent[:]
        for k in range(1, LOG):
            uk = up[k]; ukm1 = up[k-1]
            for u in range(1, n+1):
                pu = ukm1[u]
                uk[u] = ukm1[pu] if pu else 0
        def lca(u,v):
            if depth[u] < depth[v]:
                u, v = v, u
            d = depth[u] - depth[v]
            k = 0
            while d:
                if d & 1:
                    u = up[k][u]
                d >>= 1; k += 1
            if u == v: return u
            for k in range(LOG-1, -1, -1):
                if up[k][u] != up[k][v]:
                    u = up[k][u]; v = up[k][v]
            return parent[u]
        size = [1]*(n+1)
        heavy = [0]*(n+1)
        order_by_depth = order[:]
        order_by_depth.sort(key=lambda u: depth[u], reverse=True)
        for u in order_by_depth:
            max_sz = 0
            for v,w in adj[u]:
                if v == parent[u]: continue
                size[u] += size[v]
                if size[v] > max_sz:
                    max_sz = size[v]; heavy[u] = v
        head = [0]*(n+1)
        pos = [0]*(n+1)
        inv = [0]*(n+1)
        cur_pos = 0
        for u in range(1, n+1):
            if parent[u] == 0 or heavy[parent[u]] != u:
                v = u
                while v != 0:
                    head[v] = u
                    cur_pos += 1
                    pos[v] = cur_pos
                    inv[cur_pos] = v
                    v = heavy[v]
        marks_pos = [False]*(cur_pos+1)
        for i in range(1, n+1):
            if mark_city[i]:
                marks_pos[pos[i]] = True
        seg = SegTree(cur_pos)
        seg.build_from_marks(marks_pos)
        W = [0]*(n+1)
        Sk = [[0]*(n+1) for _ in range(K+1)]
        order_by_depth = order[:]
        order_by_depth.sort(key=lambda u: depth[u])
        for u in order_by_depth:
            if u == 1: continue
            p = parent[u]; w = parw[u]
            W[u] = W[p] + w
            for k in range(K+1):
                denom = 1 << k
                Sk[k][u] = Sk[k][p] + (w + denom - 1)//denom
        def path_sum_W(u,v):
            a = lca(u,v)
            return W[u] + W[v] - 2*W[a]
        def path_sum_Sk(u,v,k):
            a = lca(u,v)
            return Sk[k][u] + Sk[k][v] - 2*Sk[k][a]
        def first_mark_on_path(a,b):
            u, v = a, b
            while head[u] != head[v]:
                if depth[head[u]] > depth[head[v]]:
                    l = pos[head[u]]; r = pos[u]
                    cand = seg.query_max(l, r)
                    if cand != -1:
                        return inv[cand]
                    u = parent[head[u]]
                else:
                    v = parent[head[v]]
            pu, pv = pos[u], pos[v]
            l = min(pu, pv); r = max(pu, pv)
            if pu >= pv:
                cand = seg.query_max(l, r)
            else:
                cand = seg.query_min(l, r)
            return inv[cand] if cand != -1 else -1
        for (a, b) in qs:
            p = first_mark_on_path(a, b)
            if p == -1:
                out_lines.append(str(path_sum_W(a, b)))
                continue
            prefix = path_sum_W(a, p)
            best = prefix + path_sum_Sk(p, b, 0)
            for x in range(1, K+1):
                cand = prefix + x*T + path_sum_Sk(p, b, x)
                if cand < best: best = cand
            out_lines.append(str(best))
    return "\n".join(out_lines)

def main():
    tests = read_input()
    ans = solve_all(tests)
    sys.stdout.write(ans)

# Asserts for sanity (not executed by default)
def _unit_tests_reference():
    tests = []
    n=2; T=10
    adj=[[], [(2,1)], [(1,1)]]
    s="00"; q=1; qs=[(1,2)]
    tests.append((n,T,adj,s,q,qs))
    assert solve_all(tests).strip()=="1"
    tests=[]
    n=3; T=3
    adj=[[], [(2,5)], [(1,5),(3,10)], [(2,10)]]
    s="100"; q=1; qs=[(1,3)]
    tests.append((n,T,adj,s,q,qs))
    assert solve_all(tests).strip()=="11"
    tests=[]
    n=3; T=3
    adj=[[], [(2,5)], [(1,5),(3,10)], [(2,10)]]
    s="010"; q=1; qs=[(1,3)]
    tests.append((n,T,adj,s,q,qs))
    assert solve_all(tests).strip()=="13"

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the first course city along a path and optimize $x$ courses using precomputed path sums for divisions by powers of two.}
\WHY{Combines two classic patterns: HLD path queries and piecewise-constant cost under multiplicative scaling.}
\CHECKLIST{
\begin{bullets}
\item Precompute $S^{(k)}$ for $k=0..20$ and $W$.
\item Build LCA and HLD (head, pos, inv, heavy).
\item Segment tree returns leftmost/rightmost mark by range.
\item For each query: first mark $p$ from $a$ to $b$.
\item If none, answer $W(a,b)$; else try $x=0..20$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item No course city on the path.
\item $a=b$ (answer $0$).
\item Course city at $a$ (prefix $=0$).
\item Large $T$ makes $x=0$ optimal.
\item All $w_i=1$; for large $x$, suffix cost equals number of edges.
\item Very deep trees: avoid recursion limit by iterative DFS.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Wrong direction on the final HLD segment: choose leftmost vs rightmost by comparing positions.
\item Off-by-one in segment tree range queries; use inclusive indices.
\item Overflow in sums: use 64-bit integers (Python int is unbounded).
\item Forgetting that $p$ may not be the LCA of $(p,b)$ in a rooted tree.
\item Building $S^{(k)}$ must use $\lceil (w)/2^k\rceil = (w + 2^k - 1)//2^k$.
\item Reinitializing per test case; avoid shared mutable state across tests.
\end{bullets}
}
\FAILMODES{Linear scanning of the path for the first course city leads to $O(n)$ per query and will TLE. The HLD-based method remains $O(\log n)$ per query.}
\ELI{Train as early as you can on the route, because it helps more edges. Try a few doubling levels and pick the sweet spot that balances training time $T$ versus reduced driving time. Heavy-Light Decomposition lets us quickly find where to train; prefix sums let us price the route fast.}
\NotePages{3}

\end{document}