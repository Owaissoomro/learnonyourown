% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Passable Paths (hard version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1702/G2}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{This is the hard version of the problem. The only difference between the easy and the hard version is in the number of queries.

Polycarp grew a tree from $n$ vertices. We remind you that a tree of $n$ vertices is an undirected connected graph of $n$ vertices and $n-1$ edges that does not contain cycles.

He calls a set of vertices passable if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice. The path can visit other vertices (not from this set).

In other words, a set of vertices is called passable if there is a simple path that passes through all the vertices of this set (and possibly some other).

For example, for a tree below sets $\{\!3, 2, 5\!\}$, $\{\!1, 5, 4\!\}$, $\{\!1, 4\!\}$ are passable, and $\{\!1, 3, 5\!\}$, $\{\!1, 2, 3, 4, 5\!\}$ are not.

Polycarp asks you to answer $q$ queries. Each query is a set of vertices. For each query, you need to determine whether the corresponding set of vertices is passable.

Input:
The first line contains a single integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of vertices.

The next $n - 1$ lines contain the description of the tree.

Each of these lines contains two integers $u$ and $v$ ($1 \le u, v \le n$, $u \ne v$) — indices of vertices connected by an edge.

The next line contains a single integer $q$ ($1 \le q \le 10^5$) — the number of queries.

The following $2 \cdot q$ lines contain descriptions of sets:
the first line of a description contains an integer $k$ ($1 \le k \le n$) — the size of the set;
the second line contains $k$ distinct integers $p_1, p_2, \ldots, p_k$ ($1 \le p_i \le n$) — the indices of the vertices of the set.

It is guaranteed that the sum of $k$ over all queries does not exceed $2 \cdot 10^5$.

Output:
Print $q$ lines, each with the answer to the corresponding query: print ``YES'' if the set is passable, and ``NO'' otherwise.

You may print each letter in any case (for example, the strings ``yEs'', ``yes'', ``Yes'' and ``YES'' are recognized as positive answers).}
\BREAKDOWN{We are given a tree and many vertex-sets. For each set, decide if all its vertices lie on a single simple path of the tree. Preprocess the tree for lowest common ancestor (LCA) and distances; for each query, test a concise necessary-and-sufficient path condition.}
\ELI{All the nodes must lie on one straight line in the tree; pick two ends and check that every node sits on the unique path between them.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A tree with $n$ vertices ($1 \le n \le 2 \cdot 10^5$) given by $n-1$ undirected edges; then $q$ queries ($1 \le q \le 10^5$), each query provides $k$ and a set of $k$ distinct vertices. The total sum of $k$ over all queries is at most $2 \cdot 10^5$.}
\OUTPUTS{For each query, output ``YES'' if all given vertices lie on a single simple path of the tree (the path may include other vertices), otherwise output ``NO''. One answer per line.}
\SAMPLES{Example tree: $1$--$2$, $2$--$3$, $2$--$4$, $4$--$5$.

Sample queries and answers:
- $k=3$, set $\{\!3,2,5\!\}$ $\rightarrow$ YES (path $3$-$2$-$4$-$5$).
- $k=3$, set $\{\!1,3,5\!\}$ $\rightarrow$ NO (cannot lie on one simple path).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a tree on $|V|=n$. For a query, let $S \subseteq V$ with $|S|=k$. Denote by $\operatorname{dist}(u,v)$ the unique-path distance in $T$. The set $S$ is passable iff there exists a simple path $P$ in $T$ whose vertex set contains $S$. Equivalently, there exist endpoints $a,b \in V$ such that every $v \in S$ lies on the unique path between $a$ and $b$.}
\varmapStart
\var{T=(V,E)}{Input tree}
\var{S}{Query set of vertices}
\var{\operatorname{dist}(u,v)}{Tree distance between $u$ and $v$}
\var{a,b}{Chosen path endpoints}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
S \text{ passable} \iff \exists\, a,b \in V:\ \forall v \in S,\ \operatorname{dist}(a,v)+\operatorname{dist}(v,b)=\operatorname{dist}(a,b).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Tree is connected and acyclic; vertices are $1$-indexed; queries contain distinct vertices; $\operatorname{dist}$ is computed via LCA with a fixed root.}
\INVARIANTS{In a tree, the path between any two vertices is unique. For fixed $a,b$, a vertex $v$ lies on path $a$-$b$ iff $\operatorname{dist}(a,v)+\operatorname{dist}(v,b)=\operatorname{dist}(a,b)$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the ``all on one path'' test with candidate endpoints chosen as the two farthest vertices (diameter) within the query set.}
\ASSUMPTIONS{LCA preprocessing supports $\mathcal{O}(1)$ or $\mathcal{O}(\log n)$ distance queries.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Preprocess the tree for LCA using binary lifting; maintain depth, tin/tout.
\item For a query $S$, pick any $s \in S$, find $f_1 \in S$ maximizing $\operatorname{dist}(s,\cdot)$.
\item Find $f_2 \in S$ maximizing $\operatorname{dist}(f_1,\cdot)$; then check $\operatorname{dist}(f_1,v)+\operatorname{dist}(v,f_2)=\operatorname{dist}(f_1,f_2)$ for all $v \in S$.
\end{algosteps}
\COMPLEXITY{For each query with size $k$ and binary-lifting LCA: $\mathcal{O}(k \log n)$ time, $\mathcal{O}(1)$ extra space besides preprocessing. Preprocessing: $\mathcal{O}(n \log n)$ time, $\mathcal{O}(n \log n)$ space.}
\[
\begin{aligned}
T_{\text{pre}}(n) &= \mathcal{O}(n \log n),\\
T_{\text{query}}(k) &= \mathcal{O}(k \log n) \quad \text{(two scans + one check)},\\
S_{\text{total}} &= \mathcal{O}(n \log n).
\end{aligned}
\]
\CORRECTNESS{In a tree, the two farthest vertices in $S$ are the endpoints of the $S$-diameter. All $v \in S$ are on one simple path iff they all lie on the path between these endpoints, which is exactly the equality check stated.}
\EDGECASES{$k=1$ or $k=2$ are always YES. Repeated vertices do not occur by problem statement.}
\textbf{Code (Baseline)}
\begin{minted}{python}
#!/usr/bin/env python3
# CF 1702G2 - Baseline: diameter check with LCA
import sys
sys.setrecursionlimit(1 << 25)

def read_input(data):
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it)
    except StopIteration:
        return None
    g = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = next(it); v = next(it)
        g[u].append(v); g[v].append(u)
    q = next(it)
    queries = []
    for _ in range(q):
        k = next(it)
        arr = [next(it) for _ in range(k)]
        queries.append(arr)
    return n, g, q, queries

def build_lca(n, g, root=1):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    tin = [0]*(n+1)
    tout = [0]*(n+1)
    time = 0
    def dfs(u, p):
        nonlocal time
        time += 1
        tin[u] = time
        up[0][u] = p if p != 0 else u
        for j in range(1, LOG):
            up[j][u] = up[j-1][up[j-1][u]]
        for v in g[u]:
            if v == p: continue
            depth[v] = depth[u] + 1
            dfs(v, u)
        tout[u] = time
    dfs(root, 0)
    def is_ancestor(u, v):
        return tin[u] <= tin[v] and tout[v] <= tout[u]
    def lca(u, v):
        if is_ancestor(u, v): return u
        if is_ancestor(v, u): return v
        for j in range(LOG-1, -1, -1):
            if not is_ancestor(up[j][u], v):
                u = up[j][u]
        return up[0][u]
    def dist(u, v):
        w = lca(u, v)
        return depth[u] + depth[v] - 2*depth[w]
    parent = [up[0][i] for i in range(n+1)]
    return lca, dist, parent, depth, tin, tout

def passable_by_diameter(vertices, dist):
    if not vertices:
        return True
    s = vertices[0]
    f1 = s
    best = -1
    for v in vertices:
        d = dist(s, v)
        if d > best:
            best = d; f1 = v
    f2 = f1; best = -1
    for v in vertices:
        d = dist(f1, v)
        if d > best:
            best = d; f2 = v
    D = best
    for v in vertices:
        if dist(f1, v) + dist(v, f2) != D:
            return False
    return True

def solve_all(data):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, g, q, queries = parsed
    lca, dist, parent, depth, tin, tout = build_lca(n, g, 1)
    out = []
    for arr in queries:
        if len(arr) <= 2:
            out.append("YES"); continue
        out.append("YES" if passable_by_diameter(arr, dist) else "NO")
    return "\n".join(out)

def _tiny_unit_tests():
    # Build a tiny tree: 1-2, 2-3, 2-4, 4-5
    n = 5
    g = [[] for _ in range(n+1)]
    edges = [(1,2),(2,3),(2,4),(4,5)]
    for u,v in edges:
        g[u].append(v); g[v].append(u)
    lca, dist, parent, depth, tin, tout = build_lca(n, g, 1)
    # LCA sanity
    assert lca(3,5) == 2
    assert dist(3,5) == 3
    # Passable sets
    assert passable_by_diameter([3,2,5], dist) is True
    assert passable_by_diameter([1,5,4], dist) is True
    assert passable_by_diameter([1,4], dist) is True
    assert passable_by_diameter([1,3,5], dist) is False
    assert passable_by_diameter([1,2,3,4,5], dist) is False

if __name__ == "__main__":
    _tiny_unit_tests()
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
\end{minted}
\VALIDATION{Tiny tree checks in asserts: LCA and representative passable/non-passable sets as in the statement-like examples.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Parent-Shift Check}
\WHICHFORMULA{Choose the deepest vertex $d$ in the set by depth from a fixed root. For every other vertex $v$ of the set, shift it to its parent (if it is not the root). Then all remaining vertices must be ancestors of $d$. This is an equivalent and fast check.}
\ASSUMPTIONS{We fix a root (say $1$). We can compute depth, parent, and ancestor checks via tin/tout.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Preprocess depth, parent and tin/tout arrays with one DFS from root $1$.
\item For query set $S$, pick $d \in S$ of maximum depth.
\item For each $v \in S$ with $v \ne d$, replace $v$ by $\operatorname{parent}[v]$ (if $v$ is the root, it stays).
\item Check that for all these vertices $v$, $v$ is an ancestor of $d$ via tin/tout intervals. If all pass, answer YES; else NO.
\end{algosteps}
\COMPLEXITY{Per query $\mathcal{O}(k)$ ancestor checks after $\mathcal{O}(n)$ preprocessing, or $\mathcal{O}(k \log n)$ if ancestor queries were on-demand. This is strictly linear in $k$.}
\[
\begin{aligned}
T_{\text{pre}}(n) &= \mathcal{O}(n \log n)\ \text{(with binary lifting prepared anyway)},\\
T_{\text{query}}(k) &= \mathcal{O}(k).
\end{aligned}
\]
\CORRECTNESS{If a path covers all vertices of $S$, let $d$ be the deepest. Every other vertex $v$ is on the path to $d$. Shifting $v$ to its parent (unless $v=d$) keeps it on that path and ensures all shifted vertices form a chain of ancestors of $d$. Conversely, if all shifted vertices are ancestors of $d$, they lie along the single root-to-$d$ path, so the original $S$ also lies on a simple path.}
\textbf{Code (Improved)}
\begin{minted}{python}
#!/usr/bin/env python3
# CF 1702G2 - Improved: deepest endpoint + parent-shift ancestor check
import sys
sys.setrecursionlimit(1 << 25)

def read_input(data):
    it = iter(map(int, data.strip().split()))
    try:
        n = next(it)
    except StopIteration:
        return None
    g = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = next(it); v = next(it)
        g[u].append(v); g[v].append(u)
    q = next(it)
    queries = []
    for _ in range(q):
        k = next(it)
        arr = [next(it) for _ in range(k)]
        queries.append(arr)
    return n, g, q, queries

def preprocess(n, g, root=1):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    tin = [0]*(n+1)
    tout = [0]*(n+1)
    time = 0
    def dfs(u, p):
        nonlocal time
        time += 1
        tin[u] = time
        up[0][u] = p if p != 0 else u
        for j in range(1, LOG):
            up[j][u] = up[j-1][up[j-1][u]]
        for v in g[u]:
            if v == p: continue
            depth[v] = depth[u] + 1
            dfs(v, u)
        tout[u] = time
    dfs(root, 0)
    def is_ancestor(u, v):
        return tin[u] <= tin[v] and tout[v] <= tout[u]
    parent = [up[0][i] for i in range(n+1)]
    return parent, depth, is_ancestor

def passable_parent_shift(vertices, parent, depth, is_ancestor):
    if not vertices:
        return True
    d = max(vertices, key=lambda x: depth[x])
    for v in vertices:
        if v == d: 
            continue
        pv = parent[v]
        # If root, parent[v] == v
        if not is_ancestor(pv, d):
            return False
    return True

def solve_all(data):
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, g, q, queries = parsed
    parent, depth, is_ancestor = preprocess(n, g, 1)
    out = []
    for arr in queries:
        if len(arr) <= 2:
            out.append("YES"); continue
        out.append("YES" if passable_parent_shift(arr, parent, depth, is_ancestor) else "NO")
    return "\n".join(out)

def _tiny_unit_tests():
    # Tiny tree: 1-2, 2-3, 2-4, 4-5
    n = 5
    g = [[] for _ in range(n+1)]
    for u,v in [(1,2),(2,3),(2,4),(4,5)]:
        g[u].append(v); g[v].append(u)
    parent, depth, is_ancestor = preprocess(n, g, 1)
    assert passable_parent_shift([3,2,5], parent, depth, is_ancestor) is True
    assert passable_parent_shift([1,5,4], parent, depth, is_ancestor) is True
    assert passable_parent_shift([1,4], parent, depth, is_ancestor) is True
    assert passable_parent_shift([1,3,5], parent, depth, is_ancestor) is False
    assert passable_parent_shift([1,2,3,4,5], parent, depth, is_ancestor) is False

if __name__ == "__main__":
    _tiny_unit_tests()
    data = sys.stdin.read()
    if data.strip():
        print(solve_all(data))
\end{minted}
\VALIDATION{Checks identical to the baseline on the same tiny tree.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Diameter Endpoints + Distance Test}
\WHICHFORMULA{Compute endpoints of the diameter within the query set using two scans with LCA-based distances; verify every vertex lies on the path between these endpoints via the distance equality.}
\ASSUMPTIONS{Binary lifting LCA with depth, tin/tout works on any rooted tree; distances computed in $\mathcal{O}(1)$ or $\mathcal{O}(\log n)$ per pair.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute LCA tables and depths from root $1$.
\item For each query set $S$, find $f_1$ farthest from an arbitrary $s \in S$, then $f_2$ farthest from $f_1$ across $S$.
\item Let $D=\operatorname{dist}(f_1,f_2)$. Return YES iff for all $v \in S$, $\operatorname{dist}(f_1,v)+\operatorname{dist}(v,f_2)=D$.
\end{algosteps}
\OPTIMALITY{Any valid path covering all query vertices must have two endpoints that are the farthest among the set; the unique path between them is the only candidate, so the check is necessary and sufficient. Given the sum of $k$ is bounded, the total time is optimal up to constant factors.}
\COMPLEXITY{Preprocessing $\mathcal{O}(n \log n)$; per-vertex distance checks are $\mathcal{O}(\log n)$ (or $\mathcal{O}(1)$ with RMQ LCA). Total is $\mathcal{O}((n+ \sum k)\log n)$.}
\[
\begin{aligned}
T(n, \{k_i\}) &= \mathcal{O}(n \log n) + \sum_i \mathcal{O}(k_i \log n),\\
S(n) &= \mathcal{O}(n \log n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
#!/usr/bin/env python3
# CF 1702G2 - Passable Paths (hard) - Final Reference Solution
import sys
sys.setrecursionlimit(1 << 25)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(map(int, data))
    n = next(it)
    g = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = next(it); v = next(it)
        g[u].append(v); g[v].append(u)
    q = next(it)
    queries = []
    for _ in range(q):
        k = next(it)
        arr = [next(it) for _ in range(k)]
        queries.append(arr)
    return n, g, q, queries

def build_lca(n, g, root=1):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    tin = [0]*(n+1)
    tout = [0]*(n+1)
    time = 0
    def dfs(u, p):
        nonlocal time
        time += 1
        tin[u] = time
        up[0][u] = p if p != 0 else u
        for j in range(1, LOG):
            up[j][u] = up[j-1][up[j-1][u]]
        for v in g[u]:
            if v == p: continue
            depth[v] = depth[u] + 1
            dfs(v, u)
        tout[u] = time
    dfs(root, 0)
    def is_ancestor(u, v):
        return tin[u] <= tin[v] and tout[v] <= tout[u]
    def lca(u, v):
        if is_ancestor(u, v): return u
        if is_ancestor(v, u): return v
        uu = u
        for j in range(LOG-1, -1, -1):
            step = up[j][uu]
            if not is_ancestor(step, v):
                uu = step
        return up[0][uu]
    def dist(u, v):
        w = lca(u, v)
        return depth[u] + depth[v] - 2*depth[w]
    parent = [up[0][i] for i in range(n+1)]
    return lca, dist, parent, depth, tin, tout

def passable_by_diameter(vertices, dist):
    if not vertices:
        return True
    s = vertices[0]
    f1 = s; best = -1
    for v in vertices:
        d = dist(s, v)
        if d > best:
            best = d; f1 = v
    f2 = f1; best = -1
    for v in vertices:
        d = dist(f1, v)
        if d > best:
            best = d; f2 = v
    D = best
    for v in vertices:
        if dist(f1, v) + dist(v, f2) != D:
            return False
    return True

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    n, g, q, queries = parsed
    lca, dist, parent, depth, tin, tout = build_lca(n, g, 1)
    out_lines = []
    for arr in queries:
        if len(arr) <= 2:
            out_lines.append("YES")
        else:
            out_lines.append("YES" if passable_by_diameter(arr, dist) else "NO")
    sys.stdout.write("\n".join(out_lines))

def _unit_tests():
    # Tiny tree: 1-2, 2-3, 2-4, 4-5
    n = 5
    g = [[] for _ in range(n+1)]
    for u,v in [(1,2),(2,3),(2,4),(4,5)]:
        g[u].append(v); g[v].append(u)
    lca, dist, parent, depth, tin, tout = build_lca(n, g, 1)
    # LCA and dist
    assert lca(3,5) == 2
    assert dist(3,5) == 3
    # Path-passable checks
    assert passable_by_diameter([3,2,5], dist) is True
    assert passable_by_diameter([1,5,4], dist) is True
    assert passable_by_diameter([1,4], dist) is True

if __name__ == "__main__":
    _unit_tests()
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts included in the final code: two structural (LCA, distance) and one path check; plus two more path-positive cases to be thorough.}
\RESULT{For each query set, prints YES iff all queried vertices lie on a single simple path; otherwise NO.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for LCA and distance; positive and negative path cases on a tiny tree. Property: for $k \le 2$, answer is always YES.}
\LINE{CROSS-CHECKS}{Compare Approach B (parent-shift) vs Approach C (diameter) on random tiny trees and random query sets; they must agree.}
\LINE{EDGE-CASE GENERATOR}{Generate stars, lines, and balanced binary trees; query sets are random subsets, endpoints-only, and branching mixtures to ensure NO cases are exercised.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_line_tree(n):
    g = [[] for _ in range(n+1)]
    for i in range(1, n):
        g[i].append(i+1); g[i+1].append(i)
    return g

def gen_star_tree(n):
    g = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        g[1].append(v); g[v].append(1)
    return g

def gen_balanced_tree(n):
    g = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        p = v//2
        g[p].append(v); g[v].append(p)
    return g

def random_query_sets(n, m, maxk):
    rng = random.Random(0)
    queries = []
    for _ in range(m):
        k = rng.randint(1, maxk)
        arr = rng.sample(range(1, n+1), k)
        queries.append(arr)
    return queries
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
#!/usr/bin/env python3
# Final CF submission: diameter-based passable path check with LCA
import sys
sys.setrecursionlimit(1 << 25)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data: 
        return None
    it = iter(map(int, data))
    n = next(it)
    g = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = next(it); v = next(it)
        g[u].append(v); g[v].append(u)
    q = next(it)
    queries = []
    for _ in range(q):
        k = next(it)
        arr = [next(it) for _ in range(k)]
        queries.append(arr)
    return n, g, q, queries

def build_lca(n, g, root=1):
    LOG = (n).bit_length()
    up = [[0]*(n+1) for _ in range(LOG)]
    depth = [0]*(n+1)
    tin = [0]*(n+1)
    tout = [0]*(n+1)
    time = 0
    def dfs(u, p):
        nonlocal time
        time += 1
        tin[u] = time
        up[0][u] = p if p != 0 else u
        for j in range(1, LOG):
            up[j][u] = up[j-1][up[j-1][u]]
        for v in g[u]:
            if v == p: continue
            depth[v] = depth[u] + 1
            dfs(v, u)
        tout[u] = time
    dfs(root, 0)
    def is_ancestor(u, v):
        return tin[u] <= tin[v] and tout[v] <= tout[u]
    def lca(u, v):
        if is_ancestor(u, v): return u
        if is_ancestor(v, u): return v
        uu = u
        for j in range(LOG-1, -1, -1):
            if not is_ancestor(up[j][uu], v):
                uu = up[j][uu]
        return up[0][uu]
    def dist(u, v):
        w = lca(u, v)
        return depth[u] + depth[v] - 2*depth[w]
    return lca, dist

def passable(vertices, dist):
    if not vertices:
        return True
    s = vertices[0]
    f1 = s; best = -1
    for v in vertices:
        d = dist(s, v)
        if d > best:
            best = d; f1 = v
    f2 = f1; best = -1
    for v in vertices:
        d = dist(f1, v)
        if d > best:
            best = d; f2 = v
    D = best
    for v in vertices:
        if dist(f1, v) + dist(v, f2) != D:
            return False
    return True

def solve_all():
    parsed = read_input()
    if parsed is None:
        return
    n, g, q, queries = parsed
    lca, dist = build_lca(n, g, 1)
    out = []
    for arr in queries:
        out.append("YES" if len(arr) <= 2 or passable(arr, dist) else "NO")
    print("\n".join(out))

def _asserts():
    # Tiny tree: 1-2, 2-3, 2-4, 4-5
    n = 5
    g = [[] for _ in range(n+1)]
    for u,v in [(1,2),(2,3),(2,4),(4,5)]:
        g[u].append(v); g[v].append(u)
    lca, dist = build_lca(n, g, 1)
    assert lca(3,5) == 2
    assert dist(3,5) == 3
    assert passable([3,2,5], dist) is True

if __name__ == "__main__":
    _asserts()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Determine if a set of vertices in a tree lies on one simple path.}
\WHY{Common tree-query pattern; tests understanding of LCAs, distances, and path characterizations.}
\CHECKLIST{
- Preprocess LCA (depth, tin/tout, binary lifting).
- For each query, pick two endpoints (diameter within the set).
- Verify all nodes satisfy the distance-on-path equality.
- Handle trivial $k \in \{1,2\}$ as YES.
}
\EDGECASES{
- Single vertex ($k=1$): YES.
- Two vertices ($k=2$): YES.
- All nodes in a line: every subset is passable.
- Star tree: only subsets contained in a single arm plus center are passable.
- Deepest node repeated does not occur (distinct guaranteed).
- Tree with root different from endpoints: LCA works regardless of chosen root.
}
\PITFALLS{
- Forgetting to allow the path to include other vertices not in the set.
- Miscomputing distances without proper LCA or depths.
- Off-by-one in tin/tout ancestor checks.
- Stack overflow in DFS without raising recursion limit.
- Reading input incorrectly across multiple lines with large $q$.
- Using quadratic per-query algorithms that TLE on the hard version.
}
\FAILMODES{Brute forcing pairwise path unions or building virtual trees per query will time out for large sums of $k$. The diameter + distance test avoids constructing paths explicitly and scales linearly in $k$.}
\ELI{Pick the two farthest nodes in the asked set; then the set works if every node sits exactly on the straight path between them. Distances via LCA make this check fast.}
\NotePages{3}

\end{document}