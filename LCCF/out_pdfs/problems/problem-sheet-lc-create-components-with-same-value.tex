% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Create Components With Same Value}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/create-components-with-same-value/}}
\LINE{DIFFICULTY / RATING}{Hard}
\STATEMENT{There is an undirected tree with $n$ nodes labeled from $0$ to $n-1$. You are given a 0-indexed integer array \texttt{nums} of length $n$ where \texttt{nums[i]} represents the value of the $i$th node. You are also given a 2D integer array \texttt{edges} of length $n-1$ where \texttt{edges[i]} $=$ [\texttt{a\_i}, \texttt{b\_i}] indicates that there is an edge between nodes \texttt{a\_i} and \texttt{b\_i} in the tree.\\
You are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all \texttt{nums[i]} for which node $i$ is in the component.\\
Return the maximum number of edges you can delete, such that every connected component in the tree has the same value.\\

Example 1:\\
Input: \texttt{nums = [6,2,2,2,6]}, \texttt{edges = [[0,1],[1,2],[1,3],[3,4]]}\\
Output: \texttt{2}\\
Explanation: We can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3], and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.\\

Example 2:\\
Input: \texttt{nums = [2]}, \texttt{edges = []}\\
Output: \texttt{0}\\
Explanation: There are no edges to be deleted.\\

Constraints:
\begin{bullets}
\item $1 \le n \le 2 \times 10^4$
\item \texttt{nums.length} $= n$
\item $1 \le \texttt{nums[i]} \le 50$
\item \texttt{edges.length} $= n-1$
\item \texttt{edges[i].length} $= 2$
\item $0 \le \texttt{edges[i][0]}, \texttt{edges[i][1]} \le n-1$
\item \texttt{edges} represents a valid tree.
\end{bullets}}
\BREAKDOWN{Split the tree by deleting edges so that all resulting components have equal sum. If the total sum is $T$ and there are $k$ components, each must sum to $S=T/k$. We must choose $k$ and cuts consistent with subtree sums.}
\ELI{Try to cut off subtrees whose sums hit a target value; the largest feasible number of such equal-sum chunks gives the maximum deletions.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An integer array \texttt{nums} of length $n$ with $1 \le \texttt{nums[i]} \le 50$, and an array \texttt{edges} of $n-1$ pairs describing an undirected tree on nodes $0,\ldots,n-1$.}
\OUTPUTS{Return an integer: the maximum number of edges that can be deleted so that every connected component has the same sum of node values.}
\SAMPLES{Example A: \texttt{nums = [6,2,2,2,6]}, \texttt{edges = [[0,1],[1,2],[1,3],[3,4]]} $\to$ \texttt{2}.\\
Example B: \texttt{nums = [2]}, \texttt{edges = []} $\to$ \texttt{0}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a tree, $|V|=n$, and node weights $\{w_i\}_{i=0}^{n-1}$ with $w_i=\texttt{nums[i]}$. Total sum $T=\sum_{i=0}^{n-1} w_i$. Choose a set of edges $F \subseteq E$ to delete so that each connected component of $(V,E\setminus F)$ has equal sum $S$. Maximize $|F|$.}
\varmapStart
\var{n}{number of nodes}
\var{w_i}{weight of node $i$}
\var{T}{total weight $\sum_i w_i$}
\var{k}{number of resulting components}
\var{S}{target component sum $S=T/k$}
\var{F}{set of deleted edges; $|F|=k-1$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Find } k \in \{1,\ldots,n\} \text{ with } k \mid T \text{ and } S=\tfrac{T}{k} \ge \max_i w_i,\\
&\text{such that there exists a partition of } V \text{ into } k \text{ connected parts each summing to } S,\\
&\text{maximize } |F|=k-1.
\end{aligned}
\]
}
\ASSUMPTIONS{Tree is connected and acyclic. Node weights are positive integers, hence $k \le T/\max_i w_i$.}
\INVARIANTS{During a DFS that accumulates subtree sums toward $S$, any subtree accumulating exactly $S$ can be cut and treated as $0$ upstream; any accumulation exceeding $S$ makes $S$ infeasible.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try component counts $k$ from the theoretical maximum $\lfloor T/\max w_i \rfloor$ down to $1$. For each $k$ with $k \mid T$, set $S=T/k$ and run a single DFS that greedily cuts subtrees whose sum reaches $S$. The first feasible $k$ yields the maximum deletions $k-1$.}
\ASSUMPTIONS{Recursive DFS with increased recursion limit; skip $k$ not dividing $T$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $T=\sum \texttt{nums}$ and $M=\max \texttt{nums}$; set $k_{\max}=\min(n,\lfloor T/M \rfloor)$.
\item For $k$ from $k_{\max}$ down to $1$: if $T \bmod k \ne 0$, continue. Let $S=T/k$.
\item Run DFS from any root. Sum child returns plus the node value. If the sum equals $S$, return $0$ upstream (cut here). If it exceeds $S$, fail. If the root returns $0$, success; answer is $k-1$.
\end{algosteps}
\COMPLEXITY{At most $d(T)$ DFS runs, where $d(T)$ is the number of divisors of $T$, but the naive loop iterates many $k$ and skips most cheaply. Each DFS is $O(n)$. Space $O(n)$.}
\[
\begin{aligned}
T(n) &\le O\bigl(n \cdot d(T)\bigr) + O(k_{\max}) \\
S(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{If the DFS never exceeds $S$ and cuts exactly when summing to $S$, each cut forms a component of sum $S$. The root returning $0$ ensures all nodes are partitioned into components of sum $S$. Searching $k$ from large to small gives the maximal feasible $k$, hence the maximal deletions $k-1$.}
\EDGECASES{Single node; star trees; chains; when $M$ equals $T$ so $k_{\max}=1$; values causing many small cuts.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import sys

class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        sys.setrecursionlimit(1_000_000)
        n = len(nums)
        if n == 1:
            return 0
        g = [[] for _ in range(n)]
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)
        total = sum(nums)
        M = max(nums)
        k_max = min(n, total // M)

        def feasible(k: int) -> bool:
            target = total // k
            seen = [False] * n

            def dfs(u: int, p: int) -> int:
                s = nums[u]
                for v in g[u]:
                    if v == p:
                        continue
                    s += dfs(v, u)
                    if s > target:
                        # Early prune
                        return total + 1  # sentinel beyond target
                if s == target:
                    return 0  # cut here
                return s

            res = dfs(0, -1)
            return res == 0

        for k in range(k_max, 0, -1):
            if total % k != 0:
                continue
            if feasible(k):
                return k - 1
        return 0

# Quick checks (LeetCode samples)
assert Solution().componentValue([6,2,2,2,6], [[0,1],[1,2],[1,3],[3,4]]) == 2
assert Solution().componentValue([2], []) == 0
# Additional tiny cases
assert Solution().componentValue([1,1], [[0,1]]) == 1  # two nodes, both 1 -> split into 2 components
\end{minted}
\VALIDATION{Checked the two samples and an extra tiny case where both nodes have value 1, allowing one deletion.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Candidate Generation via Divisors}
\WHICHFORMULA{Instead of scanning all $k$, enumerate only divisors $k$ of $T$ and bound by $k \le \min(n,\lfloor T/M \rfloor)$. This caps the number of DFS trials to $d(T)$, which is small for $T \le 10^6$.}
\ASSUMPTIONS{Same greedy DFS cutting strategy; divisor enumeration in $O(\sqrt{T})$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $T$, $M$, and build adjacency.
\item Enumerate divisors $\mathcal{D}$ of $T$; keep only $k \in \mathcal{D}$ with $k \le \min(n, \lfloor T/M \rfloor)$.
\item Sort candidates $k$ in descending order and test feasibility via one DFS per $k$; return the first success as $k-1$.
\end{algosteps}
\COMPLEXITY{Enumerating divisors in $O(\sqrt{T})$; at most $d(T)$ DFS calls, each $O(n)$. This strictly improves over the baseline loop.}
\[
\begin{aligned}
T(n) &= O\bigl(n \cdot d(T) + \sqrt{T}\bigr),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Same as baseline; restricting to divisors does not miss any feasible $k$, since $S=T/k$ must be integral. Testing in descending $k$ yields the maximum deletions.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import sys
import math

class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        sys.setrecursionlimit(1_000_000)
        n = len(nums)
        if n == 1:
            return 0
        g = [[] for _ in range(n)]
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)
        total = sum(nums)
        M = max(nums)
        k_cap = min(n, total // M)

        # Enumerate divisors of total
        divs = []
        for d in range(1, int(math.isqrt(total)) + 1):
            if total % d == 0:
                divs.append(d)
                if d * d != total:
                    divs.append(total // d)
        # Only k up to the cap
        cand = [k for k in divs if k <= k_cap]
        cand.sort(reverse=True)

        def feasible(k: int) -> bool:
            target = total // k

            def dfs(u: int, p: int) -> int:
                s = nums[u]
                for v in g[u]:
                    if v == p:
                        continue
                    s += dfs(v, u)
                    if s > target:
                        return target + 1
                return 0 if s == target else s

            return dfs(0, -1) == 0

        for k in cand:
            if feasible(k):
                return k - 1
        return 0

# Assertions
assert Solution().componentValue([6,2,2,2,6], [[0,1],[1,2],[1,3],[3,4]]) == 2
assert Solution().componentValue([2], []) == 0
# Another check: chain of 3 with nums [2,2,2]; total=6 -> k=3 possible
assert Solution().componentValue([2,2,2], [[0,1],[1,2]]) == 2
\end{minted}
\VALIDATION{Tested samples and a chain where three components of sum 2 are feasible, giving two deletions.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divisor Candidates + Iterative Postorder DP}
\WHICHFORMULA{Precompute a rooted tree order once, then for each candidate $k$ perform an iterative postorder pass that accumulates subtree sums and cuts when they reach $S=T/k$. This avoids recursion overhead and is cache-friendly.}
\ASSUMPTIONS{Tree is rooted at 0. Parent and postorder arrays reused across candidates.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency, root at 0; compute parent array and preorder stack to produce a postorder list of nodes.
\item Enumerate candidate $k$ as divisors of $T$ with $k \le \min(n,\lfloor T/M \rfloor)$; sort descending.
\item For each $k$, set $S=T/k$; copy nums into a work array \texttt{acc}. Sweep nodes in postorder: add children sums to parent; if a node sum equals $S$, set it to 0 (cut); if it exceeds $S$, fail this $k$. Success iff root becomes 0. Return $k-1$.}
\end{algosteps}
\OPTIMALITY{No algorithm can avoid checking at least one feasible $k$; restricting to divisors gives a near-tight bound $d(T)$ candidates. Each check is linear in $n$, yielding time $O(n \cdot d(T) + \sqrt{T})$, which is optimal up to small factors for this approach.}
\COMPLEXITY{Preprocessing $O(n)$. Each candidate pass $O(n)$. Total $O(n \cdot d(T) + \sqrt{T})$ time, $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O\bigl(n \cdot d(T) + \sqrt{T}\bigr),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import math

class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        if n == 1:
            return 0
        # Build adjacency
        g = [[] for _ in range(n)]
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)

        total = sum(nums)
        M = max(nums)
        k_cap = min(n, total // M)

        # Root at 0; build parent and postorder once
        parent = [-1] * n
        order = []
        stack = [0]
        parent[0] = -2  # mark visited
        while stack:
            u = stack.pop()
            order.append(u)
            for v in g[u]:
                if parent[v] == -1:
                    parent[v] = u
                    stack.append(v)
        post = order[::-1]

        # Enumerate candidate k (divisors of total) in descending order, capped
        divs = []
        for d in range(1, int(math.isqrt(total)) + 1):
            if total % d == 0:
                if d <= k_cap:
                    divs.append(d)
                q = total // d
                if q != d and q <= k_cap:
                    divs.append(q)
        divs.sort(reverse=True)

        for k in divs:
            target = total // k
            acc = nums[:]  # working sums
            ok = True
            for u in post:
                if acc[u] > target:
                    ok = False
                    break
                if acc[u] == target:
                    # Cut here: contribute 0 to parent
                    if parent[u] >= 0:
                        acc[parent[u]] += 0
                    acc[u] = 0
                else:
                    # Propagate to parent
                    if parent[u] >= 0:
                        acc[parent[u]] += acc[u]
            if ok and acc[0] == 0:
                return k - 1
        return 0

# Exact 3 asserts (I/O mini-tests)
assert Solution().componentValue([6,2,2,2,6], [[0,1],[1,2],[1,3],[3,4]]) == 2
assert Solution().componentValue([2], []) == 0
assert Solution().componentValue([1,1,1,1], [[0,1],[1,2],[2,3]]) == 3  # 4 components of sum 1
\end{minted}
\VALIDATION{The final code passes the provided examples and a path of four nodes with all ones, where three deletions are possible.}
\RESULT{Return the maximum deletions $k-1$, where $k$ is the greatest feasible number of equal-sum components partitioning the tree.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify base cases (single node), uniform weights, chains, stars, and cases where only $k=1$ works. Compare outputs across the three implementations on small graphs.}
\LINE{CROSS-CHECKS}{For small $n$, enumerate all subsets of edges that produce connected components and check feasibility to validate the algorithm outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate trees like chains, stars, and balanced binary trees with random small weights, keeping sums small to enable brute-force verification.}
\begin{minted}{python}
from typing import List, Tuple
import itertools
import random

def brute_force_max_deletions(nums: List[int], edges: List[List[int]]) -> int:
    # Brute force for very small n: try all subsets of edges and check connected components
    n = len(nums)
    m = len(edges)
    best = 0
    # Enumerate edge keep subsets; only forests with exactly c components have m' = n - c edges
    # We will test deletions d and seek feasibility
    for mask in range(1 << m):
        kept = []
        for i in range(m):
            if (mask >> i) & 1:
                kept.append(tuple(edges[i]))
        # Check if kept edges form a forest spanning n nodes (no cycles): Union-Find
        parent = list(range(n))
        def find(x):
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x
        def unite(a, b):
            ra, rb = find(a), find(b)
            if ra == rb:
                return False
            parent[rb] = ra
            return True
        ok = True
        for a, b in kept:
            if not unite(a, b):
                ok = False
                break
        if not ok:
            continue
        # Count components
        reps = {}
        for v in range(n):
            reps.setdefault(find(v), []).append(v)
        # Check sums equal
        sums = set(sum(nums[v] for v in comp) for comp in reps.values())
        if len(sums) == 1:
            deletions = m - len(kept)
            best = max(best, deletions)
    return best

class ReferenceSolution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        # Use the optimal Approach C
        import math
        n = len(nums)
        if n == 1:
            return 0
        g = [[] for _ in range(n)]
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)
        total = sum(nums)
        M = max(nums)
        k_cap = min(n, total // M)
        parent = [-1] * n
        order = []
        st = [0]
        parent[0] = -2
        while st:
            u = st.pop()
            order.append(u)
            for v in g[u]:
                if parent[v] == -1:
                    parent[v] = u
                    st.append(v)
        post = order[::-1]
        divs = []
        for d in range(1, int(math.isqrt(total)) + 1):
            if total % d == 0:
                if d <= k_cap:
                    divs.append(d)
                q = total // d
                if q != d and q <= k_cap:
                    divs.append(q)
        divs.sort(reverse=True)
        for k in divs:
            target = total // k
            acc = nums[:]
            ok = True
            for u in post:
                if acc[u] > target:
                    ok = False
                    break
                if acc[u] == target:
                    acc[u] = 0
                if parent[u] >= 0:
                    acc[parent[u]] += acc[u]
            if ok and acc[0] == 0:
                return k - 1
        return 0

def small_random_tree(n: int) -> List[List[int]]:
    import random
    edges = []
    for v in range(1, n):
        u = random.randrange(0, v)
        edges.append([u, v])
    return edges

# Deterministic tests
nums = [6,2,2,2,6]
edges = [[0,1],[1,2],[1,3],[3,4]]
assert ReferenceSolution().componentValue(nums, edges) == 2

nums = [2]
edges = []
assert ReferenceSolution().componentValue(nums, edges) == 0

# Cross-check brute on tiny instances
random.seed(0)
for n in range(2, 8):
    for _ in range(20):
        ed = small_random_tree(n)
        nums = [random.randint(1, 5) for _ in range(n)]
        got = ReferenceSolution().componentValue(nums, ed)
        brute = brute_force_max_deletions(nums, ed)
        assert got == brute
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import math

class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        if n == 1:
            return 0
        # Build adjacency once
        g = [[] for _ in range(n)]
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)

        total = sum(nums)
        maxv = max(nums)
        k_cap = min(n, total // maxv)

        # Rooting and postorder for iterative DP
        parent = [-1] * n
        order = []
        st = [0]
        parent[0] = -2
        while st:
            u = st.pop()
            order.append(u)
            for v in g[u]:
                if parent[v] == -1:
                    parent[v] = u
                    st.append(v)
        post = order[::-1]

        # Enumerate divisors of total as candidates for k
        cand = []
        for d in range(1, int(math.isqrt(total)) + 1):
            if total % d == 0:
                if d <= k_cap:
                    cand.append(d)
                q = total // d
                if q != d and q <= k_cap:
                    cand.append(q)
        cand.sort(reverse=True)

        for k in cand:
            target = total // k
            acc = nums[:]
            ok = True
            for u in post:
                if acc[u] > target:
                    ok = False
                    break
                if acc[u] == target:
                    acc[u] = 0
                if parent[u] >= 0:
                    acc[parent[u]] += acc[u]
            if ok and acc[0] == 0:
                return k - 1
        return 0

# Sample asserts
assert Solution().componentValue([6,2,2,2,6], [[0,1],[1,2],[1,3],[3,4]]) == 2
assert Solution().componentValue([2], []) == 0
assert Solution().componentValue([1,1,1,1], [[0,1],[0,2],[0,3]]) == 3
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize deletions so that all components have equal sum; equivalently, find the largest feasible $k$ such that $T$ splits into $k$ connected parts each summing to $T/k$.}
\WHY{Combines tree DP with number theory (divisors), a common pattern in hard interview problems on trees.}
\CHECKLIST{
\begin{bullets}
\item Compute $T$ and $M=\max(\texttt{nums})$.
\item Generate candidate $k \mid T$ with $k \le \min(n,\lfloor T/M \rfloor)$.
\item Root the tree and prepare postorder.
\item For each candidate, sweep postorder: cut when sum hits $T/k$, fail if exceeding.
\item First success in descending $k$ gives the answer $k-1$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ returns $0$.
\item $M=T$ implies only $k=1$ is possible.
\item All ones: $k$ can be as large as $n$.
\item Star vs chain structures.
\item Large $n$ with small $T$ divisors.
\item Components forming only at non-root nodes must still zero out the root at the end.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to cap $k$ by $n$ and $\lfloor T/M \rfloor$.
\item Not checking $k \mid T$.
\item Allowing subtree sums to exceed target without early abort.
\item Using recursion without increasing stack limit (or not using iterative postorder).
\item Double-counting cuts by propagating after zeroing a subtree incorrectly.
\item Failing to verify that the root ends with sum $0$.
\end{bullets}
}
\FAILMODES{Naively trying all $k$ from $1$ to $n$ with a DFS per $k$ can be slower than necessary; skipping non-divisors and reusing traversal order avoids timeouts. Greedy cuts must be aligned with postorder; pre- or mid-order can overcount.}
\ELI{Add up each subtree; whenever you hit the target sum, pretend you cut that subtree away and send zero upward. If you can do that everywhere and end with zero at the root, you found a valid equal-sum partition. Pick the largest $k$ that works.}
\NotePages{3}

\end{document}