% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Time to Make Array Sum At Most x}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/minimum-time-to-make-array-sum-at-most-x/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given two \textbf{0-indexed} integer arrays \texttt{nums1} and \texttt{nums2} of equal length. Every second, for all indices $0 \le i < \texttt{nums1.length}$, value of \texttt{nums1[}i\texttt{]} is incremented by \texttt{nums2[}i\texttt{]}. \textbf{After} this is done, you can do the following operation:
\begin{bullets}
\item Choose an index $0 \le i < \texttt{nums1.length}$ and make \texttt{nums1[}i\texttt{]} $= 0$.
\end{bullets}
You are also given an integer $x$.
Return the \emph{minimum} time in which you can make the sum of all elements of \texttt{nums1} to be \emph{less than or equal} to $x$, or $-1$ if this is not possible.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{nums1 = [1,2,3]}, \texttt{nums2 = [1,2,3]}, \texttt{x = 4}

\quad \textbf{Output:} \texttt{3}

\quad \textbf{Explanation:}
For the 1st second, we apply the operation on $i = 0$. Therefore \texttt{nums1} $= [0,2+2,3+3] = [0,4,6]$.
For the 2nd second, we apply the operation on $i = 1$. Therefore \texttt{nums1} $= [0+1,0,6+3] = [1,0,9]$.
For the 3rd second, we apply the operation on $i = 2$. Therefore \texttt{nums1} $= [1+1,0+2,0] = [2,2,0]$.
Now sum of \texttt{nums1} $= 4$. It can be shown that these operations are optimal, so we return $3$.

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{nums1 = [1,2,3]}, \texttt{nums2 = [3,3,3]}, \texttt{x = 4}

\quad \textbf{Output:} \texttt{-1}

\quad \textbf{Explanation:} It can be shown that the sum of \texttt{nums1} will always be greater than $x$, no matter which operations are performed.

\textbf{Constraints:}
\begin{bullets}
\item $1 \le \texttt{nums1.length} \le 10^3$
\item $1 \le \texttt{nums1[}i\texttt{]} \le 10^3$
\item $0 \le \texttt{nums2[}i\texttt{]} \le 10^3$
\item $\texttt{nums1.length} == \texttt{nums2.length}$
\item $0 \le x \le 10^6$
\end{bullets}}
\BREAKDOWN{We must find the minimum integer time $t$ such that by choosing one index to reset to $0$ after each of the $t$ increments, the final sum of \texttt{nums1} is $\le x$. Model the optimal schedule for a fixed $t$, then search for the smallest feasible $t$.}
\ELI{Sort by growth rates \texttt{nums2}, optimally reset in the last seconds, and use DP to compute the best reduction for a given $t$; binary search $t$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integer arrays \texttt{nums1}, \texttt{nums2} of equal length $n$ with $1 \le n \le 10^3$, where $1 \le \texttt{nums1[}i\texttt{]} \le 10^3$ and $0 \le \texttt{nums2[}i\texttt{]} \le 10^3$, and an integer $x$ with $0 \le x \le 10^6$.}
\OUTPUTS{Return the minimum integer time $t \ge 0$ such that the final sum of \texttt{nums1} after $t$ seconds and $t$ operations (one per second, setting a chosen index to $0$ after the increment) is $\le x$, or return $-1$ if impossible.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{nums1=[1,2,3]}, \texttt{nums2=[1,2,3]}, \texttt{x=4}. Output: \texttt{3}.
\item Input: \texttt{nums1=[1,2,3]}, \texttt{nums2=[3,3,3]}, \texttt{x=4}. Output: \texttt{-1}.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n$ be the length. At each second, all entries increase by \texttt{nums2}, then exactly one index is reset to $0$. For a fixed time $t$, we may reset up to $K=\min(t,n)$ distinct indices once each, optimally scheduled in the last $K$ seconds. Sorting indices by \texttt{nums2} ascending yields an order in which the $j$-th reset from the end contributes $(K-j)\cdot \texttt{nums2[i]}$ to the final array, while unchosen indices contribute $\texttt{nums1[i]} + t\cdot\texttt{nums2[i]}$.}
\varmapStart
\var{n}{array length}
\var{\texttt{a[i]}}{\texttt{nums1[i]}}
\var{\texttt{b[i]}}{\texttt{nums2[i]}}
\var{S_1}{\(\sum_i \texttt{a[i]}\)}
\var{S_2}{\(\sum_i \texttt{b[i]}\)}
\var{t}{candidate time}
\var{K}{\(\min(t,n)\), number of distinct resets}
\var{w_j}{weight \(t-K+j\) for the \(j\)-th chosen in sorted-by-\texttt{b} order}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{FinalSum}(t)\;=\;S_1 + t\,S_2 \;-\; \max_{\substack{\text{choose }K\text{ items}\\\text{respecting sorted-by }b\text{ order}}}\;\sum_{j=1}^{K}\bigl(\texttt{a[item}_j] + w_j \cdot \texttt{b[item}_j]\bigr).
\end{BreakableEquation*}
Feasible iff $\text{FinalSum}(t)\le x$. The function is monotone in $t$ (once $t\ge n$, the minimal achievable final sum stabilizes), so we can binary search $t\in[0,n]$.
}
\ASSUMPTIONS{We only need to reset each chosen index at most once, and optimally within the last $K$ seconds. Sorting by growth \texttt{b} and assigning increasing weights maximizes the gain by rearrangement.}
\INVARIANTS{
\begin{bullets}
\item For fixed $t$, using fewer than $K=\min(t,n)$ distinct resets cannot improve the minimal final sum since weights are $\ge 1$ and $\texttt{a[i]}\ge 1$.
\item For $t\ge n$, the optimal final sum is constant with $t$ because both base and gain grow by $S_2$ per extra second.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{For each $t=0,1,\ldots,n$, compute the maximum gain via a simple DP over the sorted-by-\texttt{nums2} list using weights $w_k=t-K+k$. Pick the smallest feasible $t$.}
\ASSUMPTIONS{We iterate all $t$ up to $n$. This is acceptable as a clarity-first baseline, though not optimal.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort indices by \texttt{nums2} ascending.
\item For each $t=0..n$: set $K=\min(t,n)$ and weights $w_k=t-K+k$.
\item 1D DP over $k=0..K$ (descending updates): $\text{dp}[0]=0$, $\text{dp}[k]=\max(\text{dp}[k],\,\text{dp}[k-1]+\texttt{a[i]}+w_k\cdot\texttt{b[i]})$.
\item If $S_1+tS_2-\text{dp}[K]\le x$, return $t$.
\item If none works, return $-1$.
\end{algosteps}
\COMPLEXITY{Let $n$ be the length. Per $t$, DP is $O(nK)\le O(n^2)$. Scanning all $t$ gives $O(n^3)$ worst-case time; space $O(n)$.}
\[
\begin{aligned}
T(n) &= \sum_{t=0}^{n} O(n\cdot \min(t,n)) \\
     &= O\!\left(\sum_{t=0}^{n} n\cdot t\right) = O(n^3). \\
\end{aligned}
\]
\CORRECTNESS{Follows from the governing model: resets are used once each and placed in the last $K$ seconds; the DP maximizes the gain with the required positional weights.}
\EDGECASES{All \texttt{nums2} zero; single element; $x$ very small or very large; $t=0$ (no operations).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class SolutionBaseline:
    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:
        n = len(nums1)
        order = sorted(range(n), key=lambda i: nums2[i])
        a = [nums1[i] for i in order]
        b = [nums2[i] for i in order]
        S1 = sum(a)
        S2 = sum(b)
        if S1 <= x:
            return 0
        # Try all t from 1 to n
        for t in range(1, n + 1):
            K = min(t, n)
            if K == 0:
                cur = S1
            else:
                # dp[k] = max gain using k items so far
                NEG = -10**30
                dp = [NEG] * (K + 1)
                dp[0] = 0
                w0 = t - K + 1  # weight for the first picked item
                for i in range(n):
                    ai, bi = a[i], b[i]
                    # update k descending
                    for k in range(K, 0, -1):
                        w = w0 + (k - 1)
                        cand = dp[k - 1] + ai + w * bi
                        if cand > dp[k]:
                            dp[k] = cand
                gain = dp[K]
                cur = S1 + t * S2 - gain
            if cur <= x:
                return t
        return -1

# basic checks
if __name__ == "__main__":
    sb = SolutionBaseline()
    assert sb.minimumTime([1,2,3],[1,2,3],4) == 3
    assert sb.minimumTime([1,2,3],[3,3,3],4) == -1
    assert sb.minimumTime([5],[0],5) == 0
\end{minted}
\VALIDATION{Verified on the provided examples and a few tiny edge cases.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use binary search on $t \in [0,n]$ leveraging monotonic feasibility, and reuse the same $O(nK)$ DP to check a given $t$.}
\ASSUMPTIONS{Feasibility is monotone in $t$, and final sum stabilizes for $t \ge n$, so search domain is bounded by $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pre-sort indices by \texttt{nums2} ascending and precompute $S_1,S_2$.
\item Define \texttt{feasible(t)} that computes $K=\min(t,n)$ and the DP gain to test $S_1+tS_2-\text{gain}\le x$.
\item Binary search smallest $t$ with \texttt{feasible(t)} true; if none in $[0,n]$, return $-1$.
\end{algosteps}
\COMPLEXITY{Binary search adds a $\log n$ factor, yielding $O(n^2 \log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(\log n) \cdot O(n\cdot \min(t,n)) \le O(n^2 \log n). \\
\end{aligned}
\]
\CORRECTNESS{By the model and rearrangement argument, the DP check is exact. Monotonicity ensures binary search returns the minimum feasible $t$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class SolutionImproved:
    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:
        n = len(nums1)
        order = sorted(range(n), key=lambda i: nums2[i])
        a = [nums1[i] for i in order]
        b = [nums2[i] for i in order]
        S1 = sum(a)
        S2 = sum(b)

        if S1 <= x:
            return 0

        def feasible(t: int) -> bool:
            K = min(t, n)
            if K == 0:
                return S1 <= x
            NEG = -10**30
            dp = [NEG] * (K + 1)
            dp[0] = 0
            w0 = t - K + 1
            for i in range(n):
                ai, bi = a[i], b[i]
                for k in range(K, 0, -1):
                    w = w0 + (k - 1)
                    cand = dp[k - 1] + ai + w * bi
                    if cand > dp[k]:
                        dp[k] = cand
            gain = dp[K]
            cur = S1 + t * S2 - gain
            return cur <= x

        lo, hi = 0, n
        ans = -1
        while lo <= hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        return ans

# basic checks
if __name__ == "__main__":
    si = SolutionImproved()
    assert si.minimumTime([1,2,3],[1,2,3],4) == 3
    assert si.minimumTime([1,2,3],[3,3,3],4) == -1
    assert si.minimumTime([5,1],[0,0],4) == 1  # reset the 1 once
\end{minted}
\VALIDATION{Checked against examples; an extra case with zeros in \texttt{nums2}; binary search agrees with direct scan on small cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Binary search on $t\in[0,n]$; the check uses a tight $O(nK)$ 1D DP over the sorted-by-\texttt{nums2} sequence with weights $w_k=t-K+k$. Early exit on $t=0$ and impossibility if not feasible at $t=n$.}
\ASSUMPTIONS{Weights are $\ge 1$, so exactly $K=\min(t,n)$ items are selected; schedule resets in the last $K$ seconds.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pre-sort indices by \texttt{nums2} ascending; compute arrays \texttt{a}, \texttt{b}, and sums $S_1,S_2$.
\item If $S_1 \le x$, return $0$.
\item Binary search minimal $t$ with DP-feasible check; if not feasible at $t=n$, return $-1$.
\end{algosteps}
\OPTIMALITY{The DP is an exact maximization under the ordering constraint; binary search finds the minimal feasible $t$. For $t\ge n$, minimal achievable final sum stabilizes; thus the search space $[0,n]$ is sufficient.}
\COMPLEXITY{Time $O(n^2 \log n)$; space $O(n)$. On $n\le 10^3$, this comfortably fits within limits.}
\[
\begin{aligned}
T(n) &= O(\log n)\cdot \max_t O(n\cdot \min(t,n)) \le O(n^2\log n), \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:
        n = len(nums1)
        order = sorted(range(n), key=lambda i: nums2[i])
        a = [nums1[i] for i in order]
        b = [nums2[i] for i in order]
        S1 = sum(a)
        S2 = sum(b)

        if S1 <= x:
            return 0

        def feasible(t: int) -> bool:
            K = min(t, n)
            if K == 0:
                return S1 <= x
            NEG = -10**30
            dp = [NEG] * (K + 1)
            dp[0] = 0
            w0 = t - K + 1  # weight for the 1st selected item
            for i in range(n):
                ai, bi = a[i], b[i]
                # update descending in k to avoid reuse
                for k in range(K, 0, -1):
                    w = w0 + (k - 1)
                    cand = dp[k - 1] + ai + w * bi
                    if cand > dp[k]:
                        dp[k] = cand
            gain = dp[K]
            cur = S1 + t * S2 - gain
            return cur <= x

        lo, hi = 0, n
        ans = -1
        while lo <= hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        return ans

# exact 3 asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumTime([1,2,3],[1,2,3],4) == 3
    assert sol.minimumTime([1,2,3],[3,3,3],4) == -1
    assert sol.minimumTime([5,1],[0,0],4) == 1
\end{minted}
\VALIDATION{Three asserts: the two provided examples and a zero-growth case.}
\RESULT{Return the minimum $t$ if feasible, else $-1$. Ties do not apply since we search the minimum $t$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for edge cases: $t=0$, all \texttt{nums2}=0, single element, impossible cases, and random small instances cross-checking baseline vs optimal.}
\LINE{CROSS-CHECKS}{Compare Approach A (scan) vs Approach C (binary search) on small $n$ to ensure identical results; compare with Approach B as well.}
\LINE{EDGE-CASE GENERATOR}{Generate small random arrays with bounded values to explore corner cases like many zeros in \texttt{nums2} and tight $x$.}
\begin{minted}{python}
import random
from typing import List

# Reuse classes from above by redefining here for completeness in this cell.

class SolutionBaseline:
    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:
        n = len(nums1)
        order = sorted(range(n), key=lambda i: nums2[i])
        a = [nums1[i] for i in order]
        b = [nums2[i] for i in order]
        S1 = sum(a)
        S2 = sum(b)
        if S1 <= x:
            return 0
        for t in range(1, n + 1):
            K = min(t, n)
            NEG = -10**30
            dp = [NEG] * (K + 1)
            dp[0] = 0
            w0 = t - K + 1
            for i in range(n):
                ai, bi = a[i], b[i]
                for k in range(K, 0, -1):
                    w = w0 + (k - 1)
                    cand = dp[k - 1] + ai + w * bi
                    if cand > dp[k]:
                        dp[k] = cand
            cur = S1 + t * S2 - dp[K]
            if cur <= x:
                return t
        return -1

class Solution:
    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:
        n = len(nums1)
        order = sorted(range(n), key=lambda i: nums2[i])
        a = [nums1[i] for i in order]
        b = [nums2[i] for i in order]
        S1 = sum(a)
        S2 = sum(b)
        if S1 <= x:
            return 0
        def feasible(t: int) -> bool:
            K = min(t, n)
            if K == 0:
                return S1 <= x
            NEG = -10**30
            dp = [NEG] * (K + 1)
            dp[0] = 0
            w0 = t - K + 1
            for i in range(n):
                ai, bi = a[i], b[i]
                for k in range(K, 0, -1):
                    w = w0 + (k - 1)
                    cand = dp[k - 1] + ai + w * bi
                    if cand > dp[k]:
                        dp[k] = cand
            gain = dp[K]
            return S1 + t * S2 - gain <= x
        lo, hi = 0, n
        ans = -1
        while lo <= hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        return ans

def brute_check(n=6, trials=200, seed=0):
    random.seed(seed)
    sb = SolutionBaseline()
    so = Solution()
    for _ in range(trials):
        m = random.randint(1, n)
        nums1 = [random.randint(1, 5) for _ in range(m)]
        nums2 = [random.randint(0, 5) for _ in range(m)]
        # Choose x around possible sums
        S1 = sum(nums1)
        S2 = sum(nums2)
        x = random.randint(0, S1 + S2 * m)
        a = sb.minimumTime(nums1, nums2, x)
        b = so.minimumTime(nums1, nums2, x)
        assert a == b, (nums1, nums2, x, a, b)
    return True

if __name__ == "__main__":
    assert brute_check(n=6, trials=100, seed=42)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:
        n = len(nums1)
        order = sorted(range(n), key=lambda i: nums2[i])
        a = [nums1[i] for i in order]
        b = [nums2[i] for i in order]
        S1 = sum(a)
        S2 = sum(b)

        if S1 <= x:
            return 0

        def feasible(t: int) -> bool:
            K = min(t, n)
            if K == 0:
                return S1 <= x
            NEG = -10**30
            dp = [NEG] * (K + 1)
            dp[0] = 0
            w0 = t - K + 1
            for i in range(n):
                ai, bi = a[i], b[i]
                for k in range(K, 0, -1):
                    w = w0 + (k - 1)
                    cand = dp[k - 1] + ai + w * bi
                    if cand > dp[k]:
                        dp[k] = cand
            gain = dp[K]
            cur = S1 + t * S2 - gain
            return cur <= x

        lo, hi = 0, n
        ans = -1
        while lo <= hi:
            mid = (lo + hi) // 2
            if feasible(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        return ans

if __name__ == "__main__":
    sol = Solution()
    assert sol.minimumTime([1,2,3],[1,2,3],4) == 3
    assert sol.minimumTime([1,2,3],[3,3,3],4) == -1
    assert sol.minimumTime([5,1],[0,0],4) == 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Binary search the minimal $t$; for each $t$, maximize the gain via 1D DP over items sorted by growth \texttt{nums2}, with positional weights $w_k=t-K+k$.}
\WHY{This pattern appears in scheduling/ordering DP problems where action positions change contributions linearly and sorting by a key plus DP yields optimality.}
\CHECKLIST{
\begin{bullets}
\item Compute $S_1,S_2$; handle $t=0$ early.
\item Sort by \texttt{nums2} ascending once.
\item For given $t$, set $K=\min(t,n)$ and weights $w_k=t-K+k$.
\item 1D DP descending in $k$ to avoid reuse.
\item Check $S_1 + t S_2 - \text{dp}[K] \le x$.
\item Binary search $t\in[0,n]$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $t=0$ and $S_1 \le x$ immediately.
\item All \texttt{nums2}=0: only \texttt{nums1} matters; at most one reset per second reduces one element to $0$.
\item Single element arrays.
\item $x=0$.
\item Very large $x$ making answer $0$.
\item Impossible even at $t=n$.
\item Duplicate \texttt{nums2} values.
\item \texttt{nums2} contains zeros and positives mixed.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Updating DP in ascending $k$ (bug: item reused within same stage).
\item Forgetting that the reset happens after increment.
\item Using more than one reset per index in the model (unnecessary for final sum).
\item Not sorting by \texttt{nums2} before DP; breaks rearrangement optimality.
\item Weight formula off-by-one: it is $t-K+k$.
\item Searching $t$ beyond $n$ unnecessarily without noting stabilization.
\end{bullets}
}
\FAILMODES{Brute-forcing schedules is exponential and times out; greedy without DP fails when \texttt{nums1} terms shift the best picks under different $t$ and positions. The DP+sort survives such adversarial mixes.}
\ELI{Think of each index as growing at speed \texttt{nums2[i]}. You get to stop growth and reset it once near the end. Sort by speed, and assign later resets to faster ones. A small DP picks which ones to reset given how many seconds you have.}
\NotePages{3}

\end{document}