% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Disconnect Path in a Binary Matrix by at Most One Flip}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/}}
\LINE{DIFFICULTY / RATING}{Medium}
\STATEMENT{You are given a 0-indexed \texttt{m x n} binary matrix \texttt{grid}. You can move from a cell \texttt{(row, col)} to any of the cells \texttt{(row + 1, col)} or \texttt{(row, col + 1)} that has the value \texttt{1}. The matrix is disconnected if there is no path from \texttt{(0, 0)} to \texttt{(m - 1, n - 1)}.

You can flip the value of at most one (possibly none) cell. You cannot flip the cells \texttt{(0, 0)} and \texttt{(m - 1, n - 1)}. Return \texttt{true} if it is possible to make the matrix disconnect or \texttt{false} otherwise.

Note that flipping a cell changes its value from \texttt{0} to \texttt{1} or from \texttt{1} to \texttt{0}.

Example 1:

Input: \texttt{grid = [[1,1,1],[1,0,0],[1,1,1]]}

Output: \texttt{true}

Explanation: We can change the cell shown in the diagram above. There is no path from \texttt{(0, 0)} to \texttt{(2, 2)} in the resulting grid.

Example 2:

Input: \texttt{grid = [[1,1,1],[1,0,1],[1,1,1]]}

Output: \texttt{false}

Explanation: It is not possible to change at most one cell such that there is not path from \texttt{(0, 0)} to \texttt{(2, 2)}.

Constraints:
\begin{bullets}
\item \texttt{m == grid.length}
\item \texttt{n == grid[i].length}
\item \texttt{1 <= m, n <= 1000}
\item \texttt{1 <= m * n <= 10\textsuperscript{5}}
\item \texttt{grid[i][j]} is either \texttt{0} or \texttt{1}.
\item \texttt{grid[0][0] == grid[m - 1][n - 1] == 1}.
\end{bullets}}
\BREAKDOWN{Model the grid as a DAG over cells with value 1 and edges to the right and down. Determine whether the minimum number of internal vertices whose removal disconnects start and end is at most 1. Use reachability computations to detect unique layers or two internally vertex-disjoint monotone paths.}
\ELI{There is a right/down path made of 1s; if every step level has at least two options that still lead to the end, then one flip cannot block all paths; otherwise some single cell is a bottleneck you can flip to cut the path.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{On LeetCode, you implement \texttt{class Solution} with method \texttt{isPossibleToCutPath(self, grid: List[List[int]]) -> bool}, where \texttt{grid} is an \texttt{m x n} list of lists containing 0 or 1, with \texttt{grid[0][0] = grid[m-1][n-1] = 1} and \texttt{1 \le m \times n \le 10^5}. Only right and down moves are allowed along cells equal to 1.}
\OUTPUTS{Return \texttt{True} if by flipping at most one non-endpoint cell (1 to 0 or 0 to 1) you can make there be no path from \texttt{(0,0)} to \texttt{(m-1,n-1)}; otherwise return \texttt{False}.}
\SAMPLES{
Example 1:
\begin{itemize}
\item Input: \texttt{grid = [[1,1,1],[1,0,0],[1,1,1]]}
\item Output: \texttt{True}
\end{itemize}
Example 2:
\begin{itemize}
\item Input: \texttt{grid = [[1,1,1],[1,0,1],[1,1,1]]}
\item Output: \texttt{False}
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a directed acyclic graph formed by cells $(i,j)$ with $grid[i][j]=1$. For each $(i,j)\in V$, add edges to $(i{+}1,j)$ and $(i,j{+}1)$ if those cells are in $V$. Let $s=(0,0)$ and $t=(m{-}1,n{-}1)$. We ask whether the minimum $s$--$t$ vertex cut size, excluding $s,t$, is $\le 1$.}
\varmapStart
\var{m,n}{grid dimensions}
\var{V}{set of vertices $(i,j)$ with $grid[i][j]=1$}
\var{E}{edges from $(i,j)$ to $(i{+}1,j)$ and $(i,j{+}1)$ when present}
\var{s,t}{source $(0,0)$ and sink $(m{-}1,n{-}1)$}
\var{d(i,j)}{layer index $i{+}j$}
\var{R,S}{reachability indicators from $s$ and to $t$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
R_{0,0}&=1,\quad R_{i,j}=1 \iff grid[i][j]=1 \land \bigl((i>0\land R_{i-1,j}=1)\lor (j>0\land R_{i,j-1}=1)\bigr),\\
S_{m-1,n-1}&=1,\quad S_{i,j}=1 \iff grid[i][j]=1 \land \bigl((i{+}1<m\land S_{i+1,j}=1)\lor (j{+}1<n\land S_{i,j+1}=1)\bigr).
\end{aligned}
\]
Let $C_d=\lvert\{(i,j): i{+}j=d,\ R_{i,j}=1,\ S_{i,j}=1\}\rvert$. If $\min_{1\le d\le m{+}n{-}3} C_d = 1$, flipping that unique vertex disconnects. If $\min C_d \ge 2$, there exist two internally vertex-disjoint $s$--$t$ paths, so no single flip suffices.
}
\ASSUMPTIONS{Only right/down moves; $grid[0][0]=grid[m-1][n-1]=1$; flips cannot be applied to $s$ or $t$; $m\cdot n\le 10^5$ so linear-time DP is feasible.}
\INVARIANTS{
\begin{bullets}
\item Monotone layering: every edge increases $d=i{+}j$ by exactly 1.
\item If some layer has exactly one $s$--$t$ reachable vertex (excluding $d=0,m{+}n{-}2$), that vertex is a cut point.
\item If every intermediate layer has at least two such vertices, there exist two internally vertex-disjoint monotone paths from $s$ to $t$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Find one $s$--$t$ path $P$ and delete all internal vertices of $P$; if no path remains, then a single flip suffices by Menger's theorem (min cut equals max number of internally vertex-disjoint paths).}
\ASSUMPTIONS{We can compute one monotone path by greedy using a DP that marks cells that can still reach $t$. BFS/DFS with right/down edges suffices to test reachability.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If there is no path from $s$ to $t$, return True (already disconnected).
\item Compute a DP $S$ that marks whether each cell can reach $t$ by right/down moves.
\item Greedily walk from $s$ to $t$, each time choosing a neighbor that is $1$ and has $S=1$, to obtain a path $P$.
\item Flip all internal vertices of $P$ to $0$ and test reachability again. If disconnected, return True; else False.
\end{algosteps}
\COMPLEXITY{Two reachability scans and one greedy walk are linear.}
\[
\begin{aligned}
T(m,n) &= \Theta(mn),\quad S(m,n)=\Theta(mn).
\end{aligned}
\]
\CORRECTNESS{If after removing all internal vertices of one path there is still a path, then there exist at least two internally vertex-disjoint paths, so one flip cannot disconnect. Otherwise, max number of internally vertex-disjoint paths is 1, hence min vertex cut is 1, so one flip suffices.}
\EDGECASES{Single cell $1{\times}1$ returns False; single row or column where an interior $1$ exists returns True; grids initially disconnected return True. Endpoints are never flipped.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Deque, Tuple
from collections import deque

class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])

        def exists_path(g: List[List[int]]) -> bool:
            if g[0][0] == 0 or g[m - 1][n - 1] == 0:
                return False
            dq: Deque[Tuple[int, int]] = deque([(0, 0)])
            seen = [[False] * n for _ in range(m)]
            seen[0][0] = True
            while dq:
                i, j = dq.popleft()
                if i == m - 1 and j == n - 1:
                    return True
                if i + 1 < m and not seen[i + 1][j] and g[i + 1][j] == 1:
                    seen[i + 1][j] = True
                    dq.append((i + 1, j))
                if j + 1 < n and not seen[i][j + 1] and g[i][j + 1] == 1:
                    seen[i][j + 1] = True
                    dq.append((i, j + 1))
            return False

        # If already disconnected, flipping none suffices.
        if not exists_path(grid):
            return True

        # DP: can reach target (to_end)
        to_end = [[False] * n for _ in range(m)]
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if grid[i][j] == 1:
                    if i == m - 1 and j == n - 1:
                        to_end[i][j] = True
                    else:
                        to_end[i][j] = ((i + 1 < m and to_end[i + 1][j]) or
                                        (j + 1 < n and to_end[i][j + 1]))

        # Greedily construct one s->t path that always stays on cells with to_end=True.
        i = j = 0
        path: List[Tuple[int, int]] = [(0, 0)]
        while not (i == m - 1 and j == n - 1):
            moved = False
            if i + 1 < m and grid[i + 1][j] == 1 and to_end[i + 1][j]:
                i += 1
                moved = True
            elif j + 1 < n and grid[i][j + 1] == 1 and to_end[i][j + 1]:
                j += 1
                moved = True
            if not moved:
                # Defensive: if something is inconsistent, stop.
                break
            path.append((i, j))

        # Remove internal nodes of this path and test again.
        g2 = [row[:] for row in grid]
        for (x, y) in path[1:-1]:
            g2[x][y] = 0

        return not exists_path(g2)


# Simple sanity checks (baseline)
if __name__ == "__main__":
    sol = Solution()
    assert sol.isPossibleToCutPath([[1, 1, 1], [1, 0, 0], [1, 1, 1]]) is True
    assert sol.isPossibleToCutPath([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) is False
    assert sol.isPossibleToCutPath([[1]]) is False
    assert sol.isPossibleToCutPath([[1, 0, 1]]) is True  # flip middle 1x3 interior if it exists (here path already broken)
\end{minted}
\VALIDATION{Baseline verifies provided examples; also tests $1{\times}1$ and a single-row case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use two linear DPs to compute reachability from start and to end, then count on each anti-diagonal $d=i{+}j$ the number of cells that lie on some $s$--$t$ path. If any intermediate diagonal has exactly one such cell, flipping it disconnects; otherwise at least two internally vertex-disjoint paths exist.}
\ASSUMPTIONS{Right/down DAG layering ensures every edge increases $d$ by one; by a standard min-cut argument in layered DAGs with unit vertex capacities (excluding $s,t$), the minimum cut equals the minimum layer count.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $R_{i,j}$: reachable from start by right/down moves.
\item Compute $S_{i,j}$: can reach end by right/down moves.
\item If $S_{0,0}=0$, return True (already disconnected).
\item For each $d\in\{1,\ldots,m{+}n{-}3\}$, count $C_d=\#\{(i,j): i{+}j=d, R_{i,j}=1, S_{i,j}=1\}$.
\item If any $C_d=1$, return True; else return False.
\end{algosteps}
\COMPLEXITY{Two passes over the grid and one scan of all cells.}
\[
\begin{aligned}
T(m,n) &= \Theta(mn),\quad S(m,n)=\Theta(mn).
\end{aligned}
\]
\CORRECTNESS{Any $s$--$t$ path increases $d$ by 1 at each step; thus it intersects each intermediate layer exactly once. If some layer has a unique $s$--$t$ reachable vertex, every path must pass through it, so flipping it disconnects. If each layer has at least two, by a flow/path decomposition there exist two internally vertex-disjoint monotone paths; hence one flip cannot disconnect.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])

        # R: reachable from start
        R = [[False] * n for _ in range(m)]
        if grid[0][0] == 1:
            R[0][0] = True
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    continue
                if i > 0 and R[i - 1][j]:
                    R[i][j] = True
                if j > 0 and R[i][j - 1]:
                    R[i][j] = True

        # S: can reach end
        S = [[False] * n for _ in range(m)]
        if grid[m - 1][n - 1] == 1:
            S[m - 1][n - 1] = True
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if grid[i][j] == 0:
                    continue
                if i + 1 < m and S[i + 1][j]:
                    S[i][j] = True
                if j + 1 < n and S[i][j + 1]:
                    S[i][j] = True
                # keep True at the sink

        # Already disconnected?
        if not S[0][0]:
            return True

        # Count per diagonal (exclude endpoints' diagonals)
        # We can compute counts in a single pass.
        counts = [0] * (m + n - 1)
        for i in range(m):
            for j in range(n):
                if R[i][j] and S[i][j]:
                    counts[i + j] += 1

        # If any intermediate diagonal has exactly one candidate, flipping it cuts all paths.
        for d in range(1, m + n - 2):
            if counts[d] == 1:
                return True
        return False


# Sanity checks for improved version
if __name__ == "__main__":
    sol = Solution()
    assert sol.isPossibleToCutPath([[1, 1, 1], [1, 0, 0], [1, 1, 1]]) is True
    assert sol.isPossibleToCutPath([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) is False
    assert sol.isPossibleToCutPath([[1]]) is False
    assert sol.isPossibleToCutPath([[1, 1, 1, 1]]) is True  # single row with interior
\end{minted}
\VALIDATION{Validated on provided samples and linear grids to ensure diagonal counts detect unique bottlenecks.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Two-pass reachability with layer-count bottleneck detection is optimal: $O(mn)$ time and $O(mn)$ space, matching the input size; it exactly computes whether the min internal vertex cut is $\le 1$.}
\ASSUMPTIONS{Monotone right/down DAG; endpoints fixed to 1 and cannot be flipped; vertex capacities are unit for internal nodes.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $R$ and $S$ as in Approach B.
\item If $S[0][0]=0$, return True.
\item Aggregate $C_d$ over $d=i{+}j$ and return True iff any $C_d=1$ for $1\le d\le m{+}n{-}3$.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must at least read all entries of the grid in the worst case, implying an $\Omega(mn)$ lower bound. The method runs in $\Theta(mn)$ time and $\Theta(mn)$ space.}
\COMPLEXITY{Same as Approach B.}
\[
\begin{aligned}
T(m,n) &= \Theta(mn),\quad S(m,n)=\Theta(mn).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])

        # Reachable from start
        R = [[False] * n for _ in range(m)]
        if grid[0][0] == 1:
            R[0][0] = True
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    continue
                if i > 0 and R[i - 1][j]:
                    R[i][j] = True
                if j > 0 and R[i][j - 1]:
                    R[i][j] = True

        # Can reach end
        S = [[False] * n for _ in range(m)]
        if grid[m - 1][n - 1] == 1:
            S[m - 1][n - 1] = True
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if grid[i][j] == 0:
                    continue
                if i + 1 < m and S[i + 1][j]:
                    S[i][j] = True
                if j + 1 < n and S[i][j + 1]:
                    S[i][j] = True

        # Already disconnected
        if not S[0][0]:
            return True

        # Count nodes that lie on some s-t path per diagonal
        counts = [0] * (m + n - 1)
        for i in range(m):
            for j in range(n):
                if R[i][j] and S[i][j]:
                    counts[i + j] += 1

        for d in range(1, m + n - 2):
            if counts[d] == 1:
                return True
        return False


# Final mini-tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.isPossibleToCutPath([[1, 1, 1], [1, 0, 0], [1, 1, 1]]) is True
    assert sol.isPossibleToCutPath([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) is False
    assert sol.isPossibleToCutPath([[1]]) is False
\end{minted}
\VALIDATION{Three asserts: the two examples and the $1{\times}1$ case.}
\RESULT{Return True iff the minimum internal vertex cut between start and end is at most 1; equivalently, no two internally vertex-disjoint right/down paths exist.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify examples; exercise corner cases (single row/column; $1{\times}1$; sparse and dense grids); cross-check implementations on random small grids for consistency.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved vs Final on randomly generated $m{\times}n \le 6$ grids to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Create deterministic tiny cases covering: no path; exactly one path; two disjoint paths; single row/column; blocked near start/end.}
\begin{minted}{python}
from typing import List, Tuple
import random

def gen_small_cases() -> List[List[List[int]]]:
    cases = []
    # Hand-crafted
    cases.append([[1]])  # trivial
    cases.append([[1,1,1,1]])  # single row
    cases.append([[1],[1],[1]])  # single column
    cases.append([[1,0,0],[1,1,1],[0,0,1]])  # unique bottleneck
    cases.append([[1,1,1],[1,0,1],[1,1,1]])  # two disjoint paths
    cases.append([[1,0,1],[0,0,1],[1,1,1]])  # already disconnected
    # Deterministic random small grids
    rng = random.Random(42)
    for m in range(2, 5):
        for n in range(2, 5):
            for _ in range(3):
                g = [[1 if rng.random() < 0.7 else 0 for _ in range(n)] for __ in range(m)]
                g[0][0] = 1
                g[m-1][n-1] = 1
                cases.append(g)
    return cases

# Reference solution (final approach)
class SolutionRef:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        R = [[False]*n for _ in range(m)]
        if grid[0][0] == 1:
            R[0][0] = True
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0: continue
                if i > 0 and R[i-1][j]: R[i][j] = True
                if j > 0 and R[i][j-1]: R[i][j] = True
        S = [[False]*n for _ in range(m)]
        if grid[m-1][n-1] == 1:
            S[m-1][n-1] = True
        for i in range(m-1, -1, -1):
            for j in range(n-1, -1, -1):
                if grid[i][j] == 0: continue
                if i + 1 < m and S[i+1][j]: S[i][j] = True
                if j + 1 < n and S[i][j+1]: S[i][j] = True
        if not S[0][0]: return True
        counts = [0]*(m+n-1)
        for i in range(m):
            for j in range(n):
                if R[i][j] and S[i][j]:
                    counts[i+j] += 1
        for d in range(1, m+n-2):
            if counts[d] == 1:
                return True
        return False

def cross_check():
    # Baseline and Improved copies
    from collections import deque
    class Baseline:
        def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
            m, n = len(grid), len(grid[0])
            def exists_path(g: List[List[int]]) -> bool:
                if g[0][0]==0 or g[m-1][n-1]==0: return False
                dq = deque([(0,0)]); seen = [[False]*n for _ in range(m)]
                seen[0][0] = True
                while dq:
                    i,j = dq.popleft()
                    if (i,j) == (m-1,n-1): return True
                    if i+1<m and not seen[i+1][j] and g[i+1][j]==1:
                        seen[i+1][j]=True; dq.append((i+1,j))
                    if j+1<n and not seen[i][j+1] and g[i][j+1]==1:
                        seen[i][j+1]=True; dq.append((i,j+1))
                return False
            if not exists_path(grid): return True
            to_end = [[False]*n for _ in range(m)]
            for i in range(m-1,-1,-1):
                for j in range(n-1,-1,-1):
                    if grid[i][j]==0: continue
                    if (i,j)==(m-1,n-1): to_end[i][j]=True
                    else:
                        to_end[i][j] = (i+1<m and to_end[i+1][j]) or (j+1<n and to_end[i][j+1])
            i=j=0; path=[(0,0)]
            while (i,j)!=(m-1,n-1):
                if i+1<m and grid[i+1][j]==1 and to_end[i+1][j]: i+=1
                elif j+1<n and grid[i][j+1]==1 and to_end[i][j+1]: j+=1
                else: break
                path.append((i,j))
            g2=[row[:] for row in grid]
            for (x,y) in path[1:-1]: g2[x][y]=0
            return not exists_path(g2)
    class Improved(SolutionRef):
        pass
    base = Baseline(); imp = Improved(); ref = SolutionRef()
    for g in gen_small_cases():
        b = base.isPossibleToCutPath([row[:] for row in g])
        i = imp.isPossibleToCutPath([row[:] for row in g])
        r = ref.isPossibleToCutPath([row[:] for row in g])
        assert b == i == r, f"Mismatch on grid {g}: {b}, {i}, {r}"

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])

        # Reachable from start
        R = [[False] * n for _ in range(m)]
        if grid[0][0] == 1:
            R[0][0] = True
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    continue
                if i > 0 and R[i - 1][j]:
                    R[i][j] = True
                if j > 0 and R[i][j - 1]:
                    R[i][j] = True

        # Can reach end
        S = [[False] * n for _ in range(m)]
        if grid[m - 1][n - 1] == 1:
            S[m - 1][n - 1] = True
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if grid[i][j] == 0:
                    continue
                if i + 1 < m and S[i + 1][j]:
                    S[i][j] = True
                if j + 1 < n and S[i][j + 1]:
                    S[i][j] = True

        # Already disconnected?
        if not S[0][0]:
            return True

        counts = [0] * (m + n - 1)
        for i in range(m):
            for j in range(n):
                if R[i][j] and S[i][j]:
                    counts[i + j] += 1

        for d in range(1, m + n - 2):
            if counts[d] == 1:
                return True
        return False


# Quick asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.isPossibleToCutPath([[1, 1, 1], [1, 0, 0], [1, 1, 1]]) is True
    assert sol.isPossibleToCutPath([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) is False
    assert sol.isPossibleToCutPath([[1]]) is False
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute start and end reachability; if any intermediate diagonal has exactly one $s$--$t$ reachable cell, flip it to disconnect; else impossible with one flip.}
\WHY{This tests ability to model monotone grid paths as layered DAGs and to use min-cut/max-disjoint-paths reasoning under tight time constraints.}
\CHECKLIST{
\begin{bullets}
\item Build $R$ from start (left/top transitions).
\item Build $S$ to end (right/bottom transitions).
\item If $S[0][0]=0$ return True.
\item Count $C_d$ for $d=1\dots m{+}n{-}3$.
\item Return True if any $C_d=1$, else False.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $1{\times}1$ grid: must return False (cannot flip endpoints).
\item Single row or column: returns True iff there exists any interior $1$.
\item Already disconnected grid: return True.
\item Narrow bottleneck at first or last step (just after start or just before end).
\item Large $m{\times}n$ up to $10^5$ cells: ensure linear pass, no recursion overflow.
\item Grids with many zeros near start/end that still allow a winding path.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to exclude endpoints when interpreting the diagonal counts.
\item Using recursion for DFS on large grids leading to recursion depth errors.
\item Accidentally allowing moves other than right/down.
\item Mishandling boundaries when filling $R$ and $S$ DP tables.
\item Misinterpreting the ``already disconnected'' case; must return True.
\item Mutating the input grid across tests unintentionally.
\end{bullets}
}
\FAILMODES{A naive ``try flipping each cell'' is $O(mn(m{+}n))$ and times out for $10^5$ cells. The proposed DP method remains $O(mn)$ and handles worst cases.}
\ELI{We mark which cells can be reached from the start and which can reach the end. If somewhere in the middle there is exactly one cell that all valid paths must pass, flipping it breaks all paths. If there are always at least two choices, then even flipping one cell leaves another route.}
\NotePages{3}

\end{document}