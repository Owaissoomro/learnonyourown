% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — The Skyline Problem}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/the-skyline-problem/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{A city's \textbf{skyline} is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return \emph{the \textbf{skyline} formed by these buildings collectively}.

The geometric information of each building is given in the array \texttt{buildings} where \texttt{buildings[i] = [left\_i, right\_i, height\_i]}:
\begin{bullets}
\item \texttt{left\_i} is the x coordinate of the left edge of the $i$th building.
\item \texttt{right\_i} is the x coordinate of the right edge of the $i$th building.
\item \texttt{height\_i} is the height of the $i$th building.
\end{bullets}

You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height \texttt{0}.

The \textbf{skyline} should be represented as a list of ``key points'' sorted by their x-coordinate in the form \texttt{[[x1,y1],[x2,y2],\ldots]}. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate \texttt{0} and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.

\textbf{Note:} There must be no consecutive horizontal lines of equal height in the output skyline. For instance, \texttt{[\ldots,[2,3],[4,5],[7,5],[11,5],[12,7],\ldots]} is not acceptable; the three lines of height $5$ should be merged into one in the final output as such: \texttt{[\ldots,[2,3],[4,5],[12,7],\ldots]}.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]}

\quad \textbf{Output:} \texttt{[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]}

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{buildings = [[0,2,3],[2,5,3]]}

\quad \textbf{Output:} \texttt{[[0,3],[5,0]]}

\textbf{Constraints:}
\begin{bullets}
\item $1 \le \texttt{buildings.length} \le 10^{4}$.
\item $0 \le \texttt{left\_i} < \texttt{right\_i} \le 2^{31} - 1$.
\item $1 \le \texttt{height\_i} \le 2^{31} - 1$.
\item \texttt{buildings} is sorted by \texttt{left\_i} in non-decreasing order.
\end{bullets}}
\BREAKDOWN{Model the skyline as the upper envelope of overlapping rectangles. Identify all x-coordinates where the maximum height changes, and output those as key points with their corresponding heights, ensuring no consecutive equal heights.}
\ELI{Sweep from left to right, always knowing the tallest active building; record a point whenever the tallest height changes.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode function: \texttt{getSkyline(self, buildings)} where \texttt{buildings} is a list of lists \texttt{[left\_i, right\_i, height\_i]} with integer entries satisfying the constraints above.}
\OUTPUTS{A list of key points \texttt{[[x\_1,y\_1],[x\_2,y\_2],\ldots,[x\_k,y\_k]]}, sorted by $x$, describing the skyline. The last point must have height $0$. No two consecutive points may have the same height.}
\SAMPLES{\textbf{Sample A:} \texttt{[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]} $\to$ \texttt{[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]}

\textbf{Sample B:} \texttt{[[0,2,3],[2,5,3]]} $\to$ \texttt{[[0,3],[5,0]]}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let buildings be intervals $[l_i, r_i)$ with heights $h_i$. Define the height profile
\begin{BreakableEquation*}
H(x) = \max\{\, h_i \mid i \text{ and } l_i \le x < r_i \,\}, \quad \text{with the convention }\max\varnothing=0.
\end{BreakableEquation*}
The skyline is the sequence of breakpoints $(x_j, H(x_j))$ where $H$ changes value as $x$ increases, plus a final point at the maximum right endpoint with height $0$.}
\varmapStart
\var{l_i}{left edge of building $i$}
\var{r_i}{right edge of building $i$}
\var{h_i}{height of building $i$}
\var{H(x)}{upper envelope height at position $x$}
\var{X}{sorted list of all distinct edges $\{l_i, r_i\}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
H(x) &= \max_{i :\, l_i \le x < r_i} h_i,\\
\text{Skyline} &= \bigl\{(x, H(x)) \,\big|\, x \in X,\ H(x^-)\ne H(x)\bigr\} \cup \{(x_{\max}, 0)\},\\
x_{\max} &= \max_i r_i.
\end{aligned}
\]
}
\ASSUMPTIONS{All inputs are integers; buildings are closed on the left and open on the right, $[l_i,r_i)$, ensuring no double counting at shared edges; ties in height are immaterial to correctness, only the maximum matters.}
\INVARIANTS{
\begin{bullets}
\item Between consecutive distinct edges in $X$, $H(x)$ is constant.
\item The skyline list never has two consecutive points with the same height.
\item The skyline always starts at the leftmost edge with nonzero height if any, and ends at $x_{\max}$ with height $0$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Sample height at each distinct x-edge and compute $H(x)$ by scanning all buildings. Emit a key point when the height changes.}
\ASSUMPTIONS{Edges are at integer coordinates given in input; height only changes at building edges under the $[l_i,r_i)$ convention.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Collect and sort all distinct x-edges $X=\{l_i,r_i\}$.
\item For each $x\in X$ in ascending order, compute $H(x)=\max\{h_i: l_i\le x<r_i\}$ by scanning all buildings.
\item Append $(x,H(x))$ whenever it differs from the previous height; this automatically includes the final $(x_{\max},0)$.
\end{algosteps}
\COMPLEXITY{Let $n$ be the number of buildings and $m=\lvert X\rvert\le 2n$. Each height query scans all $n$ buildings.}
\[
\begin{aligned}
T(n) &= O(mn) = O(n^2),\\
S(n) &= O(m) \text{ for storing edges and the output.}
\end{aligned}
\]
\CORRECTNESS{Heights only change at edges in $X$; thus sampling exactly at $X$ captures all change points. Emitting only when height changes prevents consecutive plateaus of equal height. Using $[l_i,r_i)$ ensures buildings ending at $x$ are not counted at $x$, yielding the correct drop to $0$ at $x_{\max}$.}
\EDGECASES{No buildings; disjoint clusters with ground in between; multiple buildings sharing edges; identical heights overlapping; very tall building fully covering smaller ones.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        # Baseline: sample at every distinct edge, scan all buildings to get height at x
        if not buildings:
            return []
        xs = sorted(set([x for l, r, h in buildings for x in (l, r)]))
        res: List[List[int]] = []
        prev_h = -1  # sentinel to force first point
        for x in xs:
            h = 0
            for l, r, hh in buildings:
                if l <= x < r:
                    if hh > h:
                        h = hh
            if h != prev_h:
                res.append([x, h])
                prev_h = h
        # res already includes the final drop to 0 at the last edge under [l,r) convention
        # Sanity: ensure last point is height 0 at rightmost edge
        if res and res[-1][1] != 0:
            res.append([xs[-1], 0])
        return res

# Tiny checks (LC style)
if __name__ == "__main__":
    s = Solution()
    assert s.getSkyline([[0,2,3],[2,5,3]]) == [[0,3],[5,0]]
    assert s.getSkyline([[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]) == \
           [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
    # Edge: nested buildings
    assert s.getSkyline([[1,10,5],[2,9,7],[3,8,3]]) == [[1,5],[2,7],[9,5],[10,0]]
\end{minted}
\VALIDATION{Manual checks: drop to zero at the global right edge; merging adjacent equal heights; correctness on gaps where height is $0$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Sweep Line with Max-Heap (Lazy Removal)}
\WHICHFORMULA{Process start/end events sorted by $x$; maintain a max-heap of active building heights keyed by their right edges. Append a key point when the current max height changes.}
\ASSUMPTIONS{Heights only change at event coordinates; removing expired buildings is handled lazily by popping any heap entries whose right edge $\le x$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each building $(l,r,h)$, create events $(l,-h,r)$ and $(r,0,0)$; sort events by $x$, breaking ties so starts come before ends via negative height.
\item Sweep events from left to right, pushing starts into a heap of pairs $(-h,r)$.
\item At each $x$, pop heap entries whose $r \le x$; the current height is $0$ if heap empty, else $-heap[0][0]$.
\item If the height differs from the previously recorded height, output a key point $(x,\text{height})$.
\end{algosteps}
\COMPLEXITY{Sorting $2n$ events dominates. Each building is pushed and popped at most once.}
\[
\begin{aligned}
T(n) &= O(n \log n),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{At each event coordinate, the heap represents exactly the active buildings covering any $x$ immediately to the right. Lazy removal ensures expired buildings do not contribute. Emitting only on height change ensures no consecutive equal-height segments.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import heapq

class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        # Sweep line with max-heap and lazy deletions by right edge
        events: List[Tuple[int, int, int]] = []
        for l, r, h in buildings:
            events.append((l, -h, r))  # start
            events.append((r, 0, 0))   # end marker
        events.sort()
        res: List[List[int]] = []
        heap: List[Tuple[int, int]] = [(0, float('inf'))]  # (-height, right)
        prev_h = 0
        i = 0
        n = len(events)
        while i < n:
            x = events[i][0]
            # push all starts at x
            while i < n and events[i][0] == x:
                _, neg_h, r = events[i]
                if neg_h != 0:
                    heapq.heappush(heap, (neg_h, r))
                i += 1
            # remove expired
            while heap and heap[0][1] <= x:
                heapq.heappop(heap)
            cur_h = -heap[0][0] if heap else 0
            if not res or cur_h != prev_h:
                res.append([x, cur_h])
                prev_h = cur_h
        return res

# Tiny checks (LC style)
if __name__ == "__main__":
    s = Solution()
    assert s.getSkyline([[0,2,3],[2,5,3]]) == [[0,3],[5,0]]
    assert s.getSkyline([[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]) == \
           [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
    # Gap scenario
    assert s.getSkyline([[0,1,1],[3,4,1]]) == [[0,1],[1,0],[3,1],[4,0]]
\end{minted}
\VALIDATION{Events with identical $x$ are grouped; starts processed before ends via sorting ensure correct rises; removing all entries with $r \le x$ yields correct drops at edges.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Divide \& Conquer with Skyline Merge}
\WHICHFORMULA{Recursively compute skylines of halves and merge two skyline polylines in linear time of their lengths, akin to merge in mergesort.}
\ASSUMPTIONS{Merging two valid skylines by sweeping both lists and taking pointwise max yields the combined skyline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Base case: a single building $(l,r,h)$ maps to skyline $[[l,h],[r,0]]$.
\item Recurse on left and right halves of the building list sorted by $l$.
\item Merge the two skylines by walking pointers, tracking current heights $h_1,h_2$ and appending $[x,\max(h_1,h_2)]$ on change.
\end{algosteps}
\OPTIMALITY{Each level merges linear in the number of edges, over $O(\log n)$ levels, giving $O(n \log n)$ time and $O(n)$ extra space, which matches known lower bounds under comparison-based models.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= 2T(n/2) + O(n) = O(n \log n),\\
S(n) &= O(n) \text{ for recursion and merged output.}
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        if not buildings:
            return []
        buildings.sort(key=lambda b: (b[0], b[1], b[2]))

        def single(b: List[int]) -> List[List[int]]:
            l, r, h = b
            return [[l, h], [r, 0]]

        def merge(s1: List[List[int]], s2: List[List[int]]) -> List[List[int]]:
            i = j = 0
            h1 = h2 = 0
            res: List[List[int]] = []

            def append_point(x: int, h: int) -> None:
                if res and res[-1][0] == x:
                    # same x; keep only the latest height (max will be applied before call)
                    res[-1][1] = h
                elif not res or res[-1][1] != h:
                    res.append([x, h])

            while i < len(s1) and j < len(s2):
                if s1[i][0] < s2[j][0]:
                    x = s1[i][0]; h1 = s1[i][1]; i += 1
                elif s1[i][0] > s2[j][0]:
                    x = s2[j][0]; h2 = s2[j][1]; j += 1
                else:
                    x = s1[i][0]
                    h1 = s1[i][1]; h2 = s2[j][1]
                    i += 1; j += 1
                append_point(x, max(h1, h2))

            while i < len(s1):
                append_point(s1[i][0], max(s1[i][1], h2))
                h1 = s1[i][1]
                i += 1
            while j < len(s2):
                append_point(s2[j][0], max(h1, s2[j][1]))
                h2 = s2[j][1]
                j += 1

            # Compact to remove any accidental consecutive equal heights and ensure final drop to 0 exists
            comp: List[List[int]] = []
            for x, h in res:
                if not comp or comp[-1][1] != h:
                    comp.append([x, h])
            if comp and comp[-1][1] != 0:
                comp.append([comp[-1][0], 0])  # ensure termination; x will be overridden by next merges
            return comp

        def dc(arr: List[List[int]], lo: int, hi: int) -> List[List[int]]:
            if lo == hi:
                return single(arr[lo])
            mid = (lo + hi) // 2
            left = dc(arr, lo, mid)
            right = dc(arr, mid + 1, hi)
            return merge(left, right)

        ans = dc(buildings, 0, len(buildings) - 1)
        # Final compact pass and fix last x to global rightmost edge
        compact: List[List[int]] = []
        for x, h in ans:
            if not compact or compact[-1][1] != h:
                compact.append([x, h])
            else:
                compact[-1][0] = x  # same height at same time is harmless; keep the latest x
        # Ensure last point is at the maximum right edge and height 0
        max_r = max(r for _, r, _ in buildings)
        if not compact or compact[-1][0] != max_r or compact[-1][1] != 0:
            # If last height already 0 but x differs, update x to max_r
            if compact and compact[-1][1] == 0:
                compact[-1][0] = max_r
            else:
                compact.append([max_r, 0])
        return compact

# Tiny checks (LC style)
if __name__ == "__main__":
    s = Solution()
    assert s.getSkyline([[0,2,3],[2,5,3]]) == [[0,3],[5,0]]
    assert s.getSkyline([[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]) == \
           [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
    # Overlapping with equal heights
    assert s.getSkyline([[1,5,3],[2,4,3]]) == [[1,3],[5,0]]
\end{minted}
\VALIDATION{Exactly 3 asserts provided, matching examples and a tie-height case.}
\RESULT{A list of $(x,y)$ key points, strictly increasing in $x$, with no consecutive equal heights, ending at the rightmost building edge with height $0$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify: examples; disjoint clusters; nested buildings; shared edges; plateaus with same heights; strictly increasing heights; strictly decreasing heights; single building.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (baseline) and Approach C (optimal) on small randomized sets to ensure identical skylines.}
\LINE{EDGE-CASE GENERATOR}{Produce random buildings with possible equal edges and heights, enforce $l<r$, and small coordinate ranges for easy visual verification.}
\begin{minted}{python}
from typing import List, Tuple
import random

def gen_buildings(n: int, xlim: int = 20, hlim: int = 10, seed: int = 0) -> List[List[int]]:
    random.seed(seed)
    bs = []
    for _ in range(n):
        l = random.randint(0, xlim-1)
        r = random.randint(l+1, xlim)
        h = random.randint(1, hlim)
        bs.append([l, r, h])
    bs.sort()
    return bs

def skyline_baseline(buildings: List[List[int]]) -> List[List[int]]:
    if not buildings: return []
    xs = sorted(set([x for l, r, h in buildings for x in (l, r)]))
    res = []
    prev = -1
    for x in xs:
        h = 0
        for l, r, hh in buildings:
            if l <= x < r:
                if hh > h: h = hh
        if h != prev:
            res.append([x, h])
            prev = h
    if res and res[-1][1] != 0:
        res.append([xs[-1], 0])
    return res

def skyline_opt(buildings: List[List[int]]) -> List[List[int]]:
    # Reuse Approach C's Solution class
    class Solution:
        def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
            if not buildings:
                return []
            buildings.sort(key=lambda b: (b[0], b[1], b[2]))
            def single(b):
                l, r, h = b
                return [[l, h], [r, 0]]
            def merge(s1, s2):
                i = j = 0
                h1 = h2 = 0
                res = []
                def app(x, h):
                    if res and res[-1][0] == x:
                        res[-1][1] = h
                    elif not res or res[-1][1] != h:
                        res.append([x, h])
                while i < len(s1) and j < len(s2):
                    if s1[i][0] < s2[j][0]:
                        x = s1[i][0]; h1 = s1[i][1]; i += 1
                    elif s1[i][0] > s2[j][0]:
                        x = s2[j][0]; h2 = s2[j][1]; j += 1
                    else:
                        x = s1[i][0]; h1 = s1[i][1]; h2 = s2[j][1]; i += 1; j += 1
                    app(x, max(h1, h2))
                while i < len(s1):
                    app(s1[i][0], max(s1[i][1], h2)); h1 = s1[i][1]; i += 1
                while j < len(s2):
                    app(s2[j][0], max(h1, s2[j][1])); h2 = s2[j][1]; j += 1
                comp = []
                for x, h in res:
                    if not comp or comp[-1][1] != h:
                        comp.append([x, h])
                if comp and comp[-1][1] != 0:
                    comp.append([comp[-1][0], 0])
                return comp
            def dc(arr, lo, hi):
                if lo == hi:
                    return single(arr[lo])
                m = (lo+hi)//2
                return merge(dc(arr, lo, m), dc(arr, m+1, hi))
            ans = dc(buildings, 0, len(buildings)-1)
            compact = []
            for x, h in ans:
                if not compact or compact[-1][1] != h:
                    compact.append([x, h])
                else:
                    compact[-1][0] = x
            max_r = max(r for _, r, _ in buildings)
            if not compact or compact[-1][0] != max_r or compact[-1][1] != 0:
                if compact and compact[-1][1] == 0:
                    compact[-1][0] = max_r
                else:
                    compact.append([max_r, 0])
            return compact
    return Solution().getSkyline(buildings)

if __name__ == "__main__":
    # Cross-check on random small cases
    for seed in range(10):
        b = gen_buildings(8, xlim=15, hlim=8, seed=seed)
        a = skyline_baseline(b)
        c = skyline_opt(b)
        assert a == c, (b, a, c)
    # Boundary cases
    assert skyline_opt([]) == []
    assert skyline_opt([[1,2,1]]) == [[1,1],[2,0]]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import heapq

class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        # Sweep-line with max-heap; standard accepted solution on LC
        events = []
        for l, r, h in buildings:
            events.append((l, -h, r))
            events.append((r, 0, 0))
        events.sort()
        res: List[List[int]] = []
        heap = [(0, float('inf'))]  # (-height, right)
        prev_h = 0
        i, n = 0, len(events)
        while i < n:
            x = events[i][0]
            # process all events at x
            while i < n and events[i][0] == x:
                _, neg_h, r = events[i]
                if neg_h != 0:
                    heapq.heappush(heap, (neg_h, r))
                i += 1
            # remove expired buildings
            while heap and heap[0][1] <= x:
                heapq.heappop(heap)
            cur_h = -heap[0][0] if heap else 0
            if not res or res[-1][1] != cur_h:
                res.append([x, cur_h])
                prev_h = cur_h
        return res

# Asserts (examples)
if __name__ == "__main__":
    s = Solution()
    assert s.getSkyline([[0,2,3],[2,5,3]]) == [[0,3],[5,0]]
    assert s.getSkyline([[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]) == \
           [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain the tallest active building while sweeping across edges; emit a point whenever that tallest height changes.}
\WHY{This is a canonical sweep-line plus heap problem testing event ordering, lazy deletions, and output normalization.}
\CHECKLIST{
\begin{bullets}
\item Build and sort events: starts before ends at same $x$.
\item Push starts; pop all expired ends with $r \le x$.
\item Compare current height to previous; emit if changed.
\item Ensure the final point ends at the global rightmost edge with height $0$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Buildings sharing the same start or end $x$.
\item A building fully contained within another.
\item Multiple buildings with equal heights.
\item Disjoint clusters with ground between them.
\item Tall, short, tall patterns causing multiple changes at same $x$.
\item Very last drop to $0$ at the global right edge.
\item Empty input.
\item Single building.
\item Large coordinates but small count.
\item Plateaus from overlapping equal heights.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Failing to remove expired buildings when $r = x$ (must use $[l,r)$).
\item Not processing all events at the same $x$ together.
\item Emitting duplicate consecutive heights.
\item Incorrect tie-breaking: handling starts after ends at same $x$.
\item Using a min-heap without negating heights.
\item Forgetting to include ground segments between clusters.
\item Not ending the skyline with height $0$.
\item Mutating output when merging skylines at identical $x$ coordinates.
\end{bullets}}
\FAILMODES{Naive coordinate sweep over a dense range times out; incorrect event ordering yields spurious points; failing to pop all expired buildings leaves stale heights and wrong plateaus. The presented sweep and D\&C survive all such cases.}
\ELI{Imagine a city line where you always stand at the tallest building at each position. As you walk left to right, every time the tallest building changes, drop a pin with the new height. Those pins are exactly the skyline key points, ending with a final pin back at ground level.}
\NotePages{3}

\end{document}