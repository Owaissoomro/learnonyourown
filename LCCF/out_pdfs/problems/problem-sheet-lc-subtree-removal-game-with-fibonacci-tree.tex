% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Subtree Removal Game with Fibonacci Tree}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/subtree-removal-game-with-fibonacci-tree/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an undirected tree with $n$ nodes labeled $1$ to $n$ and an array of $n-1$ edges. In one move, you may remove an edge, which splits one connected component into two components.

Define the Fibonacci sequence as $F_0=1$, $F_1=1$, and $F_k=F_{k-1}+F_{k-2}$ for $k\ge 2$.

The tree is called a \emph{Fibonacci tree} if $n$ is a Fibonacci number and it is possible to repeatedly remove edges so that every time you split a component of size $F_k$ into two components whose sizes are exactly $F_{k-1}$ and $F_{k-2}$, and then continue recursively on both components until all components have size $1$.

Return \texttt{true} if the given tree is a Fibonacci tree, otherwise return \texttt{false}.}
\BREAKDOWN{Check whether $n$ is Fibonacci. If so, recursively try to find an edge that splits the current component of size $F_k$ into sizes $F_{k-1}$ and $F_{k-2}$; cut it and recurse on both sides. Use subtree sizes while ignoring already removed edges.}
\ELI{Keep cutting the tree along edges so that each piece size follows Fibonacci numbers; report if this is possible for the whole tree.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode method \texttt{isFibonacciTree(self, n: int, edges: List[List[int]]) -\textgreater{} bool}.\\
- \texttt{n}: number of nodes, integer with $1\le n\le 2\cdot 10^5$.\\
- \texttt{edges}: list of $n-1$ pairs \texttt{[u, v]} with $1\le u, v\le n$, describing an undirected tree.}
\OUTPUTS{Return \texttt{True} if the tree can be decomposed via Fibonacci-constrained edge removals down to singletons; otherwise \texttt{False}.}
\SAMPLES{Example 1: \\
Input: \texttt{n = 1}, \texttt{edges = []}. Output: \texttt{True}.\\
Example 2: \\
Input: \texttt{n = 4}, \texttt{edges = [[1,2],[2,3],[3,4]]}. Output: \texttt{False} (since $4$ is not a Fibonacci number).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G=(V,E)$ be a tree with $|V|=n$. Let $\{F_k\}_{k\ge 0}$ be Fibonacci numbers with $F_0=1$, $F_1=1$. The predicate is: Does there exist a sequence of edges $e_1,\ldots,e_m$ such that if we remove them in order, then each connected component encountered of size $F_k$ is split into sizes $F_{k-1}$ and $F_{k-2}$, until all components have size $1$?}
\varmapStart
\var{n}{number of vertices}
\var{F_k}{Fibonacci numbers with $F_0=1$, $F_1=1$}
\var{G}{the input tree}
\var{E'}{set of already removed edges}
\var{k}{index with $F_k=|C|$ for a current component $C$}
\var{s(u)}{subtree size of $u$ in a temporary rooting of $C$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&n\in \{F_k\}_{k\ge 0}, \\
&\text{Every component } C \text{ of size } F_k \text{ has an edge } (x,p(x)) \text{ s.t. } \min(s(x),\,|C|-s(x))\in\{F_{k-1},F_{k-2}\}, \\
&\text{Recursively holds for both resulting components.}
\end{aligned}
\]
}
\ASSUMPTIONS{The input is a valid tree. Indices in edges are $1$-based but can be converted to $0$-based internally. A component is explored by DFS while ignoring removed edges.}
\INVARIANTS{Subtree sizes within a component sum to the component size. If a component size is not Fibonacci, the predicate is false. A valid split strictly decreases the Fibonacci index, so recursion terminates.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all candidate cut edges in the current component that match target sizes $F_{k-1}$ or $F_{k-2}$ using subtree sizes; recurse on both sides. No fancy data structures beyond adjacency lists and edge-removal flags.}
\ASSUMPTIONS{We can recompute subtree sizes from scratch for the current component at each recursion level.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute Fibonacci numbers up to $n$ and map $n\mapsto k$ when $n=F_k$; otherwise return \texttt{False}.
\item Maintain an \emph{edge removed} boolean array; initially all \texttt{False}.
\item Recursive function \texttt{solve(root, k)}: DFS to compute subtree sizes within the component reachable from \texttt{root} ignoring removed edges; find any node $x$ with $s(x)\in\{F_{k-1},F_{k-2}\}$ and parent $p(x)$.
\item Remove edge $(x,p(x))$; recurse on $x$ with $k'$ matching $s(x)$, and on $p(x)$ with the complementary index; return \texttt{True} iff both succeed.
\item If no candidate edge found, return \texttt{False}. Base case: $F_0=F_1=1$ returns \texttt{True}.
\end{algosteps}
\COMPLEXITY{In the worst case we may scan most of the component to try candidates each level. Each edge is removed once; recomputing subtree sizes per level costs $O(|C|)$. Summed over levels, $O(n\log n)$ in practice since Fibonacci indices decrease and components shrink; space $O(n)$.}
\[
\begin{aligned}
T(n) &\approx T(F_{k-1}) + T(F_{k-2}) + O(F_k) \\
     &= O\!\left(\sum_{i=0}^{k} F_i\right)=O(F_{k+1})=O(n)
\end{aligned}
\]
\CORRECTNESS{If a valid Fibonacci decomposition exists, at each step there is an edge that yields the target sizes; the DFS finds such an edge since it computes all subtree sizes; recursing on both sides maintains the invariant that each component size is Fibonacci and strictly decreases the index. Conversely, if the algorithm returns \texttt{True}, it certifies a full sequence of valid cuts.}
\EDGECASES{$n=1$; a single edge $n=2$; non-Fibonacci $n$; highly skewed path; star shapes that are not decomposable despite Fibonacci $n$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple
import sys
sys.setrecursionlimit(1_000_000)

class Solution:
    def isFibonacciTree(self, n: int, edges: List[List[int]]) -> bool:
        # Build adjacency with edge ids
        adj = [[] for _ in range(n)]
        for i, (u, v) in enumerate(edges):
            u -= 1; v -= 1
            adj[u].append((v, i))
            adj[v].append((u, i))
        removed = [False] * (n - 1)

        # Fibonacci up to n: F0=1, F1=1
        fib = [1, 1]
        while fib[-1] < n:
            fib.append(fib[-1] + fib[-2])
        if fib[-1] != n:
            # Not a Fibonacci size
            return False
        idx_of = {val: i for i, val in enumerate(fib)}

        def dfs_sizes(root: int) -> Tuple[List[int], List[int], List[int], int, int]:
            """Return (parent, parent_edge, size, found_node, found_target_index) for the component of root.
            found_node == -1 if no subtree matches target."""
            parent = [-1] * n
            pedge = [-1] * n
            size = [0] * n
            order = []

            # Build component via stack, ignoring removed edges
            stack = [root]
            parent[root] = root
            while stack:
                u = stack.pop()
                order.append(u)
                for v, e in adj[u]:
                    if removed[e] or v == parent[u]:
                        continue
                    parent[v] = u
                    pedge[v] = e
                    stack.append(v)

            # Post-order size compute
            for u in reversed(order):
                s = 1
                for v, e in adj[u]:
                    if removed[e] or parent[v] != u:
                        continue
                    s += size[v]
                size[u] = s
            return parent, pedge, size, order[0], len(order)

        def find_cut(root: int, k: int) -> Tuple[int, int, int, List[int], List[int], List[int]]:
            """Find a node x (x != root) such that subtree size equals F[k-1] or F[k-2].
            Return (x, parent[x], pedge[x], parent, pedge, size); or (-1, -1, -1, ... ) if none."""
            parent, pedge, size, any_node, comp_sz = dfs_sizes(root)
            # Ensure component size matches F[k]
            if comp_sz != fib[k]:
                return -1, -1, -1, parent, pedge, size
            t1 = fib[k - 1] if k - 1 >= 0 else None
            t2 = fib[k - 2] if k - 2 >= 0 else None
            # Search over nodes; skip root itself when it's the DFS root (parent[root] == root)
            for u in range(n):
                if parent[u] == -1:
                    continue
                if u == root:
                    continue
                if t1 is not None and size[u] == t1:
                    return u, parent[u], pedge[u], parent, pedge, size
                if t2 is not None and size[u] == t2:
                    return u, parent[u], pedge[u], parent, pedge, size
            return -1, -1, -1, parent, pedge, size

        def solve(root: int, k: int) -> bool:
            if fib[k] <= 2:
                return True
            x, px, ecut, parent, pedge, size = find_cut(root, k)
            if x == -1:
                return False
            # Determine which target we matched
            if size[x] == fib[k - 1]:
                ka, kb = k - 1, k - 2
                ra, rb = x, px
            elif size[x] == fib[k - 2]:
                ka, kb = k - 2, k - 1
                ra, rb = x, px
            else:
                return False
            removed[ecut] = True
            ok_a = solve(ra, ka)
            if not ok_a:
                return False
            ok_b = solve(rb, kb)
            return ok_b

        k = idx_of[n]
        # Pick any node (0) as starting root
        return solve(0, k)

# Tiny sanity checks for the baseline
if __name__ == "__main__":
    sol = Solution()
    assert sol.isFibonacciTree(1, []) is True
    assert sol.isFibonacciTree(2, [[1, 2]]) is True
    # 3-node path is decomposable: 3 -> (2,1) -> (1,1,1)
    assert sol.isFibonacciTree(3, [[1, 2], [2, 3]]) is True
    # 4 is not Fibonacci
    assert sol.isFibonacciTree(4, [[1, 2], [2, 3], [3, 4]]) is False
\end{minted}
\VALIDATION{Validated trivial cases: $n=1$, $n=2$ edge, path of length $3$, and non-Fibonacci $n=4$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Memoized Component Sizes and Early Exit}
\WHICHFORMULA{Same recursive splitting, but with early exit once a valid cut is found, and careful reuse of arrays within each level to minimize overhead.}
\ASSUMPTIONS{Edge removals partition the tree; at most one successful cut is needed per level. The Fibonacci index strictly decreases, giving $O(n\log n)$-ish time and $O(n)$ memory.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute Fibonacci numbers and index map.
\item For a component, one DFS computes parents and subtree sizes; when a target size is found, stop searching further.
\item Remove the cut edge and recurse on both sides with corresponding Fibonacci indices.
\end{algosteps}
\COMPLEXITY{Each edge is considered $O(1)$ times across levels; DFS per level is linear in current component size. Overall $O(n)$ to $O(n\log n)$ time; $O(n)$ space.}
\[
\begin{aligned}
T(n) &= T(F_{k-1}) + T(F_{k-2}) + O(F_k) \\
     &= O(n)
\end{aligned}
\]
\CORRECTNESS{Maintains the invariant that each component size is Fibonacci and reduces to two valid subproblems; if no cut exists, returns \texttt{False}.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
import sys
sys.setrecursionlimit(1_000_000)

class Solution:
    def isFibonacciTree(self, n: int, edges: List[List[int]]) -> bool:
        # Build adjacency with edge ids
        adj = [[] for _ in range(n)]
        for i, (u, v) in enumerate(edges):
            u -= 1; v -= 1
            adj[u].append((v, i))
            adj[v].append((u, i))
        removed = [False] * (n - 1)

        # Fibonacci up to n
        fib = [1, 1]
        while fib[-1] < n:
            fib.append(fib[-1] + fib[-2])
        if fib[-1] != n:
            return False
        idx_of = {val: i for i, val in enumerate(fib)}

        parent = [-1] * n
        pedge = [-1] * n
        size = [0] * n

        def build_component(root: int) -> List[int]:
            stack = [root]
            parent[root] = root
            nodes = []
            while stack:
                u = stack.pop()
                nodes.append(u)
                for v, e in adj[u]:
                    if removed[e] or v == parent[u]:
                        continue
                    parent[v] = u
                    pedge[v] = e
                    stack.append(v)
            # compute sizes in postorder
            for u in reversed(nodes):
                s = 1
                for v, e in adj[u]:
                    if removed[e] or parent[v] != u:
                        continue
                    s += size[v]
                size[u] = s
            return nodes

        def solve(root: int, k: int) -> bool:
            if fib[k] <= 2:
                return True
            # reset parent markers only for visited nodes
            nodes = build_component(root)
            if len(nodes) != fib[k]:
                return False
            t1 = fib[k - 1]
            t2 = fib[k - 2]
            cut_node = -1
            for u in nodes:
                if u == root:
                    continue
                if size[u] == t1 or size[u] == t2:
                    cut_node = u
                    break
            if cut_node == -1:
                return False
            ecut = pedge[cut_node]
            p = parent[cut_node]
            removed[ecut] = True
            if size[cut_node] == t1:
                return solve(cut_node, k - 1) and solve(p, k - 2)
            else:
                return solve(cut_node, k - 2) and solve(p, k - 1)

        return solve(0, idx_of[n])

# Tiny checks for the improved version
if __name__ == "__main__":
    sol = Solution()
    assert sol.isFibonacciTree(1, []) is True
    assert sol.isFibonacciTree(2, [[1, 2]]) is True
    assert sol.isFibonacciTree(3, [[1, 2], [2, 3]]) is True
    assert sol.isFibonacciTree(4, [[1, 2], [2, 3], [3, 4]]) is False
\end{minted}
\VALIDATION{Same edge cases as baseline; both versions agree on small crafted examples.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Recursive Decomposition via Subtree Sizes}
\WHICHFORMULA{Fibonacci-guided recursive edge cutting using subtree sizes and ignoring removed edges; identical to known optimal solutions for Fibonacci tree decomposition checks.}
\ASSUMPTIONS{Tree structure; Fibonacci index strictly decreases by $1$ or $2$ per split; DFS is linear in component size.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute Fibonacci numbers up to $n$ and build a map value $\to$ index.
\item Maintain a \texttt{removed} flag per edge.
\item For a component of size $F_k$, compute subtree sizes and find a node whose subtree is $F_{k-1}$ or $F_{k-2}$; cut the edge to its parent.
\item Recurse on both resulting components with indices $k-1$ and $k-2$ accordingly until sizes $\le 2$.
\end{algosteps}
\OPTIMALITY{Each edge is cut at most once; each DFS traverses only its component. The total work over the recursion forms a telescoping sum dominated by $O(n)$ or $O(n\log n)$ depending on implementation details. This is asymptotically optimal since we must at least read the whole tree.}
\COMPLEXITY{Time $O(n)$ to $O(n\log n)$; space $O(n)$.}
\[
\begin{aligned}
T(n) &= T(F_{k-1}) + T(F_{k-2}) + O(F_k) = O(n)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
import sys
sys.setrecursionlimit(1_000_000)

class Solution:
    def isFibonacciTree(self, n: int, edges: List[List[int]]) -> bool:
        # Build adjacency with undirected edge ids
        adj = [[] for _ in range(n)]
        for i, (u, v) in enumerate(edges):
            u -= 1; v -= 1
            adj[u].append((v, i))
            adj[v].append((u, i))
        removed = [False] * (n - 1)

        # Precompute Fibonacci numbers up to n (F0=1, F1=1)
        fib = [1, 1]
        while fib[-1] < n:
            fib.append(fib[-1] + fib[-2])
        if fib[-1] != n:
            return False
        idx_of = {val: i for i, val in enumerate(fib)}

        parent = [-1] * n
        pedge = [-1] * n
        size = [0] * n

        def build_component(root: int) -> List[int]:
            # Iterative DFS to collect nodes and parents of the current component
            nodes = []
            stack = [root]
            parent[root] = root
            while stack:
                u = stack.pop()
                nodes.append(u)
                for v, e in adj[u]:
                    if removed[e] or v == parent[u]:
                        continue
                    parent[v] = u
                    pedge[v] = e
                    stack.append(v)
            # Compute subtree sizes in postorder
            for u in reversed(nodes):
                s = 1
                for v, e in adj[u]:
                    if removed[e] or parent[v] != u:
                        continue
                    s += size[v]
                size[u] = s
            return nodes

        def solve(root: int, k: int) -> bool:
            if fib[k] <= 2:
                return True
            nodes = build_component(root)
            if len(nodes) != fib[k]:
                return False
            t1, t2 = fib[k - 1], fib[k - 2]
            cut_node = -1
            for u in nodes:
                if u == root:
                    continue
                if size[u] == t1 or size[u] == t2:
                    cut_node = u
                    break
            if cut_node == -1:
                return False
            ecut = pedge[cut_node]
            p = parent[cut_node]
            removed[ecut] = True
            # Recurse on both components with appropriate indices
            if size[cut_node] == t1:
                return solve(cut_node, k - 1) and solve(p, k - 2)
            else:
                return solve(cut_node, k - 2) and solve(p, k - 1)

        return solve(0, idx_of[n])

# Exactly 3 asserts as small I/O mini-tests
if __name__ == "__main__":
    sol = Solution()
    # Positive: path of 5 nodes is decomposable
    assert sol.isFibonacciTree(5, [[1,2],[2,3],[3,4],[4,5]]) is True
    # Negative: n not Fibonacci
    assert sol.isFibonacciTree(6, [[1,2],[2,3],[3,4],[4,5],[5,6]]) is False
    # Star with 5 nodes is not decomposable under Fibonacci rule
    assert sol.isFibonacciTree(5, [[1,2],[1,3],[1,4],[1,5]]) is False
\end{minted}
\VALIDATION{Three asserts: positive path of size $5$; negative $n=6$; negative star with $n=5$.}
\RESULT{Return \texttt{True} iff the input tree admits a full Fibonacci decomposition by edge removals; otherwise \texttt{False}.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on trivial sizes ($n\in\{1,2,3,4\}$), random small trees for cross-check, adversarial shapes: paths, stars, brooms.}
\LINE{CROSS-CHECKS}{Compare Approach A, B, and C on randomly generated trees with small $n\le 12$ where a brute-force enumerator can be used, ensuring agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate trees with $n$ equal to Fibonacci numbers and non-Fibonacci numbers; produce shapes: star, path, and near-balanced trees.}
\begin{minted}{python}
from typing import List
import random

def gen_path(n: int) -> List[List[int]]:
    return [[i, i+1] for i in range(1, n)]

def gen_star(n: int) -> List[List[int]]:
    return [[1, i] for i in range(2, n+1)]

def gen_random_tree(n: int, seed: int = 0) -> List[List[int]]:
    random.seed(seed)
    edges = []
    for v in range(2, n+1):
        u = random.randint(1, v-1)
        edges.append([u, v])
    return edges

# Reference final solution (Approach C)
class Solution:
    def isFibonacciTree(self, n: int, edges: List[List[int]]) -> bool:
        import sys
        sys.setrecursionlimit(1_000_000)
        adj = [[] for _ in range(n)]
        for i, (u, v) in enumerate(edges):
            u -= 1; v -= 1
            adj[u].append((v, i))
            adj[v].append((u, i))
        removed = [False] * (n - 1)
        fib = [1, 1]
        while fib[-1] < n:
            fib.append(fib[-1] + fib[-2])
        if fib[-1] != n:
            return False
        idx_of = {val: i for i, val in enumerate(fib)}
        parent = [-1] * n
        pedge = [-1] * n
        size = [0] * n
        def build_component(root: int):
            nodes = []
            stack = [root]
            parent[root] = root
            while stack:
                u = stack.pop()
                nodes.append(u)
                for v, e in adj[u]:
                    if removed[e] or v == parent[u]:
                        continue
                    parent[v] = u
                    pedge[v] = e
                    stack.append(v)
            for u in reversed(nodes):
                s = 1
                for v, e in adj[u]:
                    if removed[e] or parent[v] != u:
                        continue
                    s += size[v]
                size[u] = s
            return nodes
        def solve(root: int, k: int) -> bool:
            if fib[k] <= 2:
                return True
            nodes = build_component(root)
            if len(nodes) != fib[k]:
                return False
            t1, t2 = fib[k - 1], fib[k - 2]
            cut_node = -1
            for u in nodes:
                if u == root:
                    continue
                if size[u] == t1 or size[u] == t2:
                    cut_node = u
                    break
            if cut_node == -1:
                return False
            ecut = pedge[cut_node]
            p = parent[cut_node]
            removed[ecut] = True
            if size[cut_node] == t1:
                return solve(cut_node, k - 1) and solve(p, k - 2)
            else:
                return solve(cut_node, k - 2) and solve(p, k - 1)
        return solve(0, idx_of[n])

if __name__ == "__main__":
    sol = Solution()
    # Quick smoke tests
    assert sol.isFibonacciTree(1, []) is True
    assert sol.isFibonacciTree(5, gen_path(5)) is True
    assert sol.isFibonacciTree(5, gen_star(5)) is False
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple
import sys
sys.setrecursionlimit(1_000_000)

class Solution:
    def isFibonacciTree(self, n: int, edges: List[List[int]]) -> bool:
        # Build adjacency with undirected edge ids
        adj = [[] for _ in range(n)]
        for i, (u, v) in enumerate(edges):
            u -= 1; v -= 1
            adj[u].append((v, i))
            adj[v].append((u, i))
        removed = [False] * (n - 1)

        # Precompute Fibonacci numbers up to n (F0=1, F1=1)
        fib = [1, 1]
        while fib[-1] < n:
            fib.append(fib[-1] + fib[-2])
        if fib[-1] != n:
            return False
        idx_of = {val: i for i, val in enumerate(fib)}

        parent = [-1] * n
        pedge = [-1] * n
        size = [0] * n

        def build_component(root: int):
            # Iterative DFS to collect nodes and parents of the current component
            nodes = []
            stack = [root]
            parent[root] = root
            while stack:
                u = stack.pop()
                nodes.append(u)
                for v, e in adj[u]:
                    if removed[e] or v == parent[u]:
                        continue
                    parent[v] = u
                    pedge[v] = e
                    stack.append(v)
            # Compute subtree sizes in postorder
            for u in reversed(nodes):
                s = 1
                for v, e in adj[u]:
                    if removed[e] or parent[v] != u:
                        continue
                    s += size[v]
                size[u] = s
            return nodes

        def solve(root: int, k: int) -> bool:
            if fib[k] <= 2:
                return True
            nodes = build_component(root)
            if len(nodes) != fib[k]:
                return False
            t1, t2 = fib[k - 1], fib[k - 2]
            cut_node = -1
            for u in nodes:
                if u == root:
                    continue
                if size[u] == t1 or size[u] == t2:
                    cut_node = u
                    break
            if cut_node == -1:
                return False
            ecut = pedge[cut_node]
            p = parent[cut_node]
            removed[ecut] = True
            if size[cut_node] == t1:
                return solve(cut_node, k - 1) and solve(p, k - 2)
            else:
                return solve(cut_node, k - 2) and solve(p, k - 1)

        return solve(0, idx_of[n])

# Reference asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.isFibonacciTree(1, []) is True
    assert sol.isFibonacciTree(3, [[1,2],[2,3]]) is True
    assert sol.isFibonacciTree(4, [[1,2],[2,3],[3,4]]) is False
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Check if a tree can be decomposed by edge removals so that component sizes strictly follow consecutive Fibonacci numbers.}
\WHY{Tests recursive decomposition, tree traversals, and constructive proofs; common in hard interviews and contests.}
\CHECKLIST{
- Verify $n$ is Fibonacci; if not, return \texttt{False}.
- Build adjacency with identifiable edges.
- Maintain \texttt{removed} flags and avoid traversing across removed edges.
- DFS to compute subtree sizes in the current component.
- Find a node with target size $F_{k-1}$ or $F_{k-2}$ and cut its parent edge.
- Recurse on both components with indices $k-1$ and $k-2$.
- Base out when size $\le 2$.}
\EDGECASES{
- $n=1$ or $n=2$. 
- Non-Fibonacci $n$.
- Components size mismatch due to a wrong root or stale arrays.
- Star with Fibonacci $n$ that is not decomposable.
- Path vs balanced shapes.
- Multiple candidates for cut; any valid one suffices.}
\PITFALLS{
- Forgetting to skip removed edges during DFS.
- Selecting the DFS root itself as a cut node (no parent edge to remove).
- Off-by-one in Fibonacci indices and base cases.
- Reusing parent/size arrays across components without reinitializing relevant entries.
- 1-based vs 0-based indexing for edges.
- Not increasing recursion limit for deep trees.}
\FAILMODES{Naive greedy that always cuts the first matching node without verifying component size equality may fail. Ignoring removed edges leads to incorrect subtree sizes. If $n$ is not a Fibonacci number, any approach that proceeds further wastes time.}
\ELI{We keep splitting the tree at just the right edge so that part sizes follow the Fibonacci pattern. If we can split all the way down to single nodes, the answer is true; otherwise false.}
\NotePages{3}

\end{document}