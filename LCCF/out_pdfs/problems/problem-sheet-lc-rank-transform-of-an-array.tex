% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Rank Transform of an Array}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/rank-transform-of-an-array/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given an array of integers \texttt{arr}, replace each element with its rank.

The rank represents how large the element is. The rank has the following rules:
\begin{bullets}
\item Rank is an integer starting from 1.
\item The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
\item Rank should be as small as possible.
\end{bullets}

Examples:
\begin{bullets}
\item Input: \texttt{arr = [40, 10, 20, 30]}; Output: \texttt{[4, 1, 2, 3]}. Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.
\item Input: \texttt{arr = [100, 100, 100]}; Output: \texttt{[1, 1, 1]}. Explanation: Same elements share the same rank.
\item Input: \texttt{arr = [37, 12, 28, 9, 100, 56, 80, 5, 12]}; Output: \texttt{[5, 3, 4, 2, 8, 6, 7, 1, 3]}.
\end{bullets}

Constraints:
\begin{bullets}
\item $0 \le \text{len}(\texttt{arr}) \le 10^5$.
\item $-10^9 \le \texttt{arr}[i] \le 10^9$.
\end{bullets}}
\BREAKDOWN{Compute the relative order among distinct values, map each distinct value to its rank (1-based by increasing order), and replace each entry with the mapped rank. Handle duplicates so equal values share the same rank.}
\ELI{Compress the numbers to their sorted positions, giving equal numbers the same smallest possible position starting from 1.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single list \texttt{arr} of integers, with length $n$ where $0 \le n \le 10^5$ and each element in the range $[-10^9, 10^9]$.}
\OUTPUTS{A list of length $n$ where each element is replaced by its rank among the distinct values of \texttt{arr}, with ranks starting at 1 and increasing with the value; equal inputs receive equal ranks.}
\SAMPLES{Example A: Input \texttt{arr = [20, 20, 10]}; Output \texttt{[2, 2, 1]}. Example B: Input \texttt{arr = []}; Output \texttt{[]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A = (a_1,\ldots,a_n)$ and let $U = \{a_1,\ldots,a_n\}$ be the set of distinct values. Let $u_{(1)} < u_{(2)} < \cdots < u_{(k)}$ be the sorted distinct values in $U$. Define rank function $r:\mathbb{Z}\to \mathbb{Z}_{\ge 1}$ on $U$ by $r(u_{(j)}) = j$ for $j=1,\ldots,k$. The output is $R = (r(a_1),\ldots,r(a_n))$.}
\varmapStart
\var{n}{length of the input array}
\var{U}{set of distinct values in the array}
\var{u_{(j)}}{the $j$-th smallest distinct value}
\var{r(x)}{rank of value $x$ among distinct values, starting at 1}
\var{R_i}{rank assigned to $a_i$, i.e., $R_i = r(a_i)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall i \in \{1,\ldots,n\}:\quad R_i = 1 + \lvert \{\, v \in U \mid v < a_i \,\} \rvert
\end{BreakableEquation*}
}
\ASSUMPTIONS{Values are comparable under the usual total order on integers. Ties are permitted and must map to equal ranks.}
\INVARIANTS{
\begin{bullets}
\item If $a_i = a_j$ then $R_i = R_j$ by definition of $r$ on $U$.
\item If $a_i < a_j$ then $R_i \le R_j$ and in fact $R_i < R_j$ if $a_i \ne a_j$.
\item $\min R = 1$ and $\max R = \lvert U \rvert$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use $R_i = 1 + \lvert \{ v \in U \mid v < a_i \} \rvert$. Compute this set naively for each $i$ by scanning the entire array and collecting strictly smaller values into a set.}
\ASSUMPTIONS{We can afford $O(n^2)$ time for clarity; memory is $O(n)$ in the worst case for the temporary set.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each position $i$, initialize an empty set $S$.
\item Scan all elements $a_j$; if $a_j < a_i$, insert $a_j$ into $S$.
\item Set $R_i \gets \lvert S \rvert + 1$. Return all $R_i$.
\end{algosteps}
\COMPLEXITY{For each of $n$ positions we scan $n$ values and insert into a hash set. Expected time $O(n^2)$; space $O(n)$ for the set in the worst case.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} O(n) = O(n^2) \\
S(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{The set $S$ for index $i$ contains exactly the distinct values strictly less than $a_i$, so $\lvert S \rvert$ equals the count of distinct smaller values. Adding 1 yields the required 1-based rank. Equal values produce equal sets and thus equal ranks.}
\EDGECASES{Empty array returns empty list. All-equal arrays yield all 1's. Negative and large values are handled identically by comparisons.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        n = len(arr)
        res: List[int] = []
        for i in range(n):
            x = arr[i]
            smaller = set()
            for y in arr:
                if y < x:
                    smaller.add(y)
            res.append(len(smaller) + 1)
        return res

# Baseline checks
s = Solution()
assert s.arrayRankTransform([40, 10, 20, 30]) == [4, 1, 2, 3]
assert s.arrayRankTransform([100, 100, 100]) == [1, 1, 1]
assert s.arrayRankTransform([]) == []
\end{minted}
\VALIDATION{The asserts cover a mixed-order example, an all-equal example, and the empty input.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sort and Sweep to Assign Ranks}
\WHICHFORMULA{Sort indices by their values. Sweep in increasing order and assign a new rank whenever the value changes. This directly realizes the definition while avoiding quadratic scans.}
\ASSUMPTIONS{Sorting is $O(n \log n)$. We track the last seen value to assign the same rank to duplicates.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Form pairs $(a_i, i)$ and sort by $a_i$.
\item Initialize \texttt{rank} to 0 and \texttt{prev} to \texttt{None}. For each sorted pair:
\begin{bullets}
\item If $a_i \ne \texttt{prev}$, increment \texttt{rank} and set \texttt{prev} to $a_i$.
\item Set $R_i \gets \texttt{rank}$.
\end{bullets}
\item Return $R$.
\end{algosteps}
\COMPLEXITY{Dominated by sorting.}
\[
\begin{aligned}
T(n) &= O(n \log n) \\
S(n) &= O(n) \text{ for output and sorting structures}
\end{aligned}
\]
\CORRECTNESS{Because the sweep processes values in nondecreasing order, each distinct value gets the next integer rank. Equal values are contiguous in the sort and thus receive the same rank.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        n = len(arr)
        res = [0] * n
        pairs = sorted((v, i) for i, v in enumerate(arr))
        rank = 0
        prev = None
        for v, i in pairs:
            if v != prev:
                rank += 1
                prev = v
            res[i] = rank
        return res

# Improved checks
s = Solution()
assert s.arrayRankTransform([40, 10, 20, 30]) == [4, 1, 2, 3]
assert s.arrayRankTransform([100, 100, 100]) == [1, 1, 1]
assert s.arrayRankTransform([37, 12, 28, 9, 100, 56, 80, 5, 12]) == [5, 3, 4, 2, 8, 6, 7, 1, 3]
\end{minted}
\VALIDATION{Covers all provided examples, including duplicates appearing in multiple positions.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Coordinate Compression via Sorted Unique Values}
\WHICHFORMULA{Compute the sorted unique values once, map each value to its 1-based index, and transform the array by dictionary lookup.}
\ASSUMPTIONS{Sorting the $k$ distinct values costs $O(k \log k)$ with $k \le n$, and lookups are $O(1)$ expected time via hashing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $V \gets \text{sorted}(\text{set}(\texttt{arr}))$.
\item Build a dictionary \texttt{rank} with \texttt{rank[V[j]] = j+1}.
\item Return \texttt{[rank[x] for x in arr]}.
\end{algosteps}
\OPTIMALITY{This is optimal up to the sorting lower bound on distinct values for comparison-based models. The mapping then applies in linear time.}
\COMPLEXITY{Let $k$ be the number of distinct values.}
\[
\begin{aligned}
T(n) &= O(n + k \log k) \le O(n \log n) \\
S(n) &= O(n + k)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        if not arr:
            return []
        uniq = sorted(set(arr))
        rank = {v: i + 1 for i, v in enumerate(uniq)}
        return [rank[x] for x in arr]

# Final checks (exactly 3)
s = Solution()
assert s.arrayRankTransform([40, 10, 20, 30]) == [4, 1, 2, 3]
assert s.arrayRankTransform([100, 100, 100]) == [1, 1, 1]
assert s.arrayRankTransform([]) == []
\end{minted}
\VALIDATION{Three focused asserts cover mixed, duplicate-only, and empty cases.}
\RESULT{Each array element is replaced by its 1-based rank among the distinct values, with ties sharing ranks and ranks as small as possible.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests include: empty input; all-equal; strictly increasing; strictly decreasing; mixed with negatives and positives; repeated scattered duplicates. Property: applying the transform twice is idempotent.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach A, B, and C on small random arrays to ensure they match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of sizes $\{0,1,2,10\}$; values from small sets (e.g., $\{-1,0,1\}$) to force duplicates; also monotone sequences and alternating patterns.}
\begin{minted}{python}
from typing import List
import random

def brute_rank(arr: List[int]) -> List[int]:
    res = []
    for x in arr:
        smaller = set(y for y in arr if y < x)
        res.append(len(smaller) + 1)
    return res

class SortSweep:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        n = len(arr)
        res = [0] * n
        for rank, (v, i) in enumerate(sorted((v, i) for i, v in enumerate(arr)), start=1):
            if rank == 1 or v != arr[sorted((val, idx) for idx, val in enumerate(arr))[rank-2][1]]:
                pass
        # Simpler: standard sweep
        pairs = sorted((v, i) for i, v in enumerate(arr))
        rank = 0
        prev = None
        for v, i in pairs:
            if v != prev:
                rank += 1
                prev = v
            res[i] = rank
        return res

class SolutionRef:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        uniq = sorted(set(arr))
        rank = {v: i + 1 for i, v in enumerate(uniq)}
        return [rank[x] for x in arr]

# Cross-check small randoms deterministically
random.seed(0)
for n in range(0, 21):
    for _ in range(10):
        arr = [random.randint(-5, 5) for _ in range(n)]
        a = brute_rank(arr)
        b = SortSweep().arrayRankTransform(arr)
        c = SolutionRef().arrayRankTransform(arr)
        assert a == b == c

# Edge scenarios
assert SolutionRef().arrayRankTransform([]) == []
assert SolutionRef().arrayRankTransform([1]) == [1]
assert SolutionRef().arrayRankTransform([3, 3, 3, 3]) == [1, 1, 1, 1]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        # Coordinate compression: map each distinct value to its 1-based index after sorting.
        if not arr:
            return []
        uniq = sorted(set(arr))
        rank = {v: i + 1 for i, v in enumerate(uniq)}
        return [rank[x] for x in arr]

# Sanity tests
if __name__ == "__main__":
    s = Solution()
    assert s.arrayRankTransform([40, 10, 20, 30]) == [4, 1, 2, 3]
    assert s.arrayRankTransform([100, 100, 100]) == [1, 1, 1]
    assert s.arrayRankTransform([37, 12, 28, 9, 100, 56, 80, 5, 12]) == [5, 3, 4, 2, 8, 6, 7, 1, 3]
    assert s.arrayRankTransform([]) == []
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Assign 1-based ranks to each value based on its position in the sorted order of distinct values.}
\WHY{A frequent compression primitive used in sorting, coordinate compression, and Fenwick/segment tree problems.}
\CHECKLIST{
\begin{bullets}
\item Build sorted unique list of values.
\item Map each value to 1-based index.
\item Replace each element by its mapped rank.
\item Verify duplicates map to the same rank.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Empty array.
\item All elements identical.
\item Already sorted ascending.
\item Sorted descending.
\item Mixed negatives and positives.
\item Large magnitude values near bounds.
\item Single element.
\item Two distinct values only.
\item Many duplicates interleaved.
\item Non-contiguous value gaps.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one ranks (forgetting to start from 1).
\item Accidentally ranking by positions instead of distinct values.
\item Not handling empty input cleanly.
\item Using unstable updates that give different ranks for equal values.
\item Overflow is not an issue in Python, but beware in fixed-width languages.
\item Inefficient $O(n^2)$ approach on large $n$ causing TLE.
\item Mutating while iterating over the same list unnecessarily.
\item Forgetting that dictionary iteration order is irrelevant; use explicit sorting.
\end{bullets}
}
\FAILMODES{Quadratic brute force times out near $n=10^5$. Counting sort is infeasible due to the large value range. Sorting unique values and hashing remains robust and fast.}
\ELI{Sort the different numbers you see, give them labels 1, 2, 3, ... in order, and then write down each number's label in the array. Equal numbers get the same label.}
\NotePages{3}

\end{document}