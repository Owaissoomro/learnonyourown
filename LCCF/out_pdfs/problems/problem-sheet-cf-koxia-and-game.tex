% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Koxia and Game}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1770/D}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{Koxia and Mahiru are playing a game with three arrays $a$, $b$, and $c$ of length $n$. Each element of $a$, $b$ and $c$ is an integer between $1$ and $n$ inclusive.

The game consists of $n$ rounds. In the $i$-th round, they perform the following moves:
\begin{bullets}
\item Let $S$ be the multiset $\{a_i, b_i, c_i\}$.
\item Koxia removes one element from the multiset $S$ by her choice.
\item Mahiru chooses one integer from the two remaining in the multiset $S$.
\end{bullets}

Let $d_i$ be the integer Mahiru chose in the $i$-th round. If $d$ is a permutation$^\dagger$, Koxia wins. Otherwise, Mahiru wins.

Currently, only the arrays $a$ and $b$ have been chosen. As an avid supporter of Koxia, you want to choose an array $c$ such that Koxia will win. Count the number of such $c$, modulo $998{,}244{,}353$.

Note that Koxia and Mahiru both play optimally.

$^\dagger$ A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).

Input:
Each test consists of multiple test cases. The first line contains a single integer $t$ ($1 \le t \le 2 \cdot 10^4$) — the number of test cases. The description of test cases follows.

The first line of each test case contains a single integer $n$ ($1 \le n \le 10^5$) — the size of the arrays.

The second line of each test case contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le n$).

The third line of each test case contains $n$ integers $b_1, b_2, \dots, b_n$ ($1 \le b_i \le n$).

It is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.

Output:
Output a single integer — the number of $c$ makes Koxia win, modulo $998{,}244{,}353$.

Note:
In the first test case, there are $6$ possible arrays $c$ that make Koxia win — $[1, 2, 3]$, $[1, 3, 2]$, $[2, 2, 3]$, $[2, 3, 2]$, $[3, 2, 3]$, $[3, 3, 2]$.

In the second test case, it can be proved that no array $c$ makes Koxia win.}
\BREAKDOWN{Reduce the optimal-play game to structural constraints on the multigraph formed by pairs $(a_i,b_i)$. Values with $a_i=b_i$ are forced picks. Among remaining edges, only connected components that are pure cycles impose extra constraints on $c$: in each such cycle, at least one edge must have $c_i$ equal to one of its endpoints to break Mahiru's ability to force a duplicate. Count $c$ arrays multiplicatively over components.}
\ELI{Forced equal pairs fix some values; elsewhere, only rings (cycles) are dangerous, and you must place at least one ``matching'' $c_i$ on each ring.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each:
\begin{bullets}
\item $n$ (int), $1 \le n \le 10^5$.
\item Array $a$ of length $n$, $1 \le a_i \le n$.
\item Array $b$ of length $n$, $1 \le b_i \le n$.
\end{bullets}
Total $\sum n \le 10^5$.}
\OUTPUTS{For each test case, one line: the count modulo $998{,}244{,}353$ of arrays $c \in [1..n]^n$ such that Koxia has a winning strategy under optimal play.}
\SAMPLES{Example 1
\begin{tcolorbox}
Input
\begin{verbatim}
1
3
1 2 3
1 3 2
\end{verbatim}
Output
\begin{verbatim}
24
\end{verbatim}
Explanation: One equal pair ($1$) is forced; the two remaining indices form a $2$-cycle on $\{2,3\}$, contributing $3^1 \cdot (3^2 - 1^2)=24$ valid $c$'s.
\end{tcolorbox}

Example 2
\begin{tcolorbox}
Input
\begin{verbatim}
1
2
1 1
1 1
\end{verbatim}
Output
\begin{verbatim}
0
\end{verbatim}
Explanation: Value $1$ is forced twice, making a permutation impossible.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V=\{1,\ldots,n\}$. For each index $i$ with $a_i \ne b_i$, add an undirected edge $e_i=\{a_i,b_i\}$ in a multigraph $G$ on $V$. Let $S=\{v \in V : \exists i,~a_i=b_i=v\}$ be values forced by equal pairs. A $c$ is winning iff (i) no value in $S$ appears more than once (else impossible), and (ii) for every connected component of the induced subgraph $G[U]$ with $U=V\setminus S$ that is a cycle with $k$ edges, at least one of those $k$ edges has $c_i \in \{a_i,b_i\}$.}
\varmapStart
\var{n}{array length and number of labels}
\var{a,b}{input arrays, endpoints of multigraph edges}
\var{c}{to be chosen; third values per index}
\var{S}{set of labels forced by equal pairs $a_i=b_i$}
\var{U}{unforced labels $V\setminus S$}
\var{G}{multigraph on $V$ with edges for $a_i \ne b_i$}
\var{M}{modulus $998{,}244{,}353$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{If }\exists v:\left|\{i: a_i=b_i=v\}\right|\ge 2,\ \text{answer}=0.
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Otherwise, write }E_\text{cyc}=\bigsqcup_j C_j,\ \ C_j \text{ a cycle component with }k_j\text{ edges}.
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Answer} \equiv n^{n-\sum_j k_j}\cdot \prod_j\bigl(n^{k_j}-(n-2)^{k_j}\bigr)\ \ (\bmod M).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Self-loops correspond exactly to $a_i=b_i$ and are treated as forced values; multi-edges are allowed between two vertices. Cycle components are those connected components of $G[U]$ in which every vertex has degree $2$ (including the case of two vertices with two parallel edges).}
\INVARIANTS{
\begin{bullets}
\item If $a_i=b_i=v$, then $d_i=v$ regardless of play.
\item In a tree component of $G[U]$, Koxia can orient removals to ensure no label is chosen twice, independent of $c$.
\item In a cycle component of $G[U]$, Mahiru can force a duplicate unless some edge has $c_i$ equal to an endpoint, which lets Koxia break the cycle.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate optimal play using game DP on small $n$: try all arrays $c \in [1..n]^n$ and solve the perfect-information game via minimax with memoization over $(i,\text{used\_mask})$.}
\ASSUMPTIONS{Intended for sanity checks only; exponential in $n$, so use for $n \le 6$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate $c$.
\item Solve a recursive game: at round $i$, Koxia removes one of $\{a_i,b_i,c_i\}$; Mahiru then picks one from the remaining two to minimize the chance of completing a permutation; propagate used labels via a bitmask.
\item Count $c$ for which Koxia has a winning strategy (reaches mask with all bits $1$).
\end{algosteps}
\COMPLEXITY{Exponential. For each $c$ there are at most $6^n$ game branches; enumerating $c$ itself costs $n^n$.}
\[
\begin{aligned}
T(n) &\in \Theta\bigl(n^n \cdot 6^n\bigr) \\
     &= \Theta\bigl((6n)^n\bigr)
\end{aligned}
\]
\CORRECTNESS{The minimax DP explores all strategy profiles in a sequential perfect-information game and decides if Koxia has a strategy guaranteeing a permutation regardless of Mahiru's reactions.}
\EDGECASES{All $a_i=b_i$; repeated forced values; parallel edges; $n=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from itertools import product
from functools import lru_cache

MOD = 998244353

def can_koxia_win_bruteforce(n, a, b, c):
    # minimax on rounds with used-mask
    @lru_cache(maxsize=None)
    def dfs(i, used_mask):
        if i == n:
            return used_mask == (1 << n) - 1
        vals = (a[i], b[i], c[i])
        # Koxia chooses removal r in {0,1,2} to maximize;
        # Mahiru then chooses from the two remaining to minimize.
        best = False
        for r in range(3):
            remain = [vals[j] for j in range(3) if j != r]
            # Mahiru picks adversarially (min)
            worst = True
            for pick in remain:
                bit = 1 << (pick - 1)
                if used_mask & bit:
                    # duplicate immediately fails this branch
                    res = False
                else:
                    res = dfs(i + 1, used_mask | bit)
                worst = worst and res  # Mahiru wants to make False; AND = min over booleans
            best = best or worst  # Koxia wants True; OR = max over booleans
            if best:
                break
        return best
    return dfs(0, 0)

def count_winning_c_bruteforce(n, a, b):
    count = 0
    for c in product(range(1, n + 1), repeat=n):
        if can_koxia_win_bruteforce(n, a, b, c):
            count += 1
    return count % MOD

# Tiny asserts for the brute-force DP
assert can_koxia_win_bruteforce(1, [1], [1], [1]) is True
assert count_winning_c_bruteforce(1, [1], [1]) == 1
\end{minted}
\VALIDATION{Use for $n \le 3$ to cross-check the optimal solution on random seeds; see later sections.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Graph Perspective \& Component Types}
\WHICHFORMULA{Model indices with $a_i \ne b_i$ as edges in a multigraph on vertices $1..n$. Values with $a_i=b_i$ are forced. Only cycle components within the unforced vertex set $U$ constrain $c$.}
\ASSUMPTIONS{Undirected multigraph; removing forced vertices $S$ destroys any cycle containing a forced vertex.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count forced values $S$ from indices with $a_i=b_i$; if any value appears at least twice, answer is $0$.
\item Partition edges ($a_i \ne b_i$) into those touching $S$ and those in $U=V\setminus S$.
\item Build $G[U]$ from the latter; for each connected component, compute number of edges $k$ and check if all its vertices have degree $2$ (cycle) or not (acyclic/with leaves).
\item Multiply contributions:
\begin{bullets}
\item For each index with $a_i=b_i$: factor $n$.
\item For each edge touching $S$: factor $n$.
\item For each non-cycle component in $G[U]$ with $k$ edges: factor $n^{k}$.
\item For each cycle component in $G[U]$ with $k$ edges: factor $n^{k}-(n-2)^{k}$.
\end{bullets}
\end{algosteps}
\COMPLEXITY{Linear in input size.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(n) \text{ per test (building degrees, DFS/BFS on }G[U]\text{)} \\
S(n) &= \mathcal{O}(n)
\end{aligned}
\]
\CORRECTNESS{Forced equal pairs fix distinct labels or fail immediately. In $G[U]$, trees can be oriented by Koxia to cap each vertex's selection to at most once regardless of $c$, while a pure cycle allows Mahiru to force a duplicate unless some edge has $c_i$ equal to an endpoint, which Koxia uses to fix that edge and break the cycle. Independence across disjoint components yields multiplicative counting.}
\textbf{Code (Improved)}
\begin{minted}{python}
MOD = 998244353

def solve_case_graph(n, a, b):
    # Step 1: forced values from equal pairs
    forced_cnt = [0] * (n + 1)
    equal_count = 0
    for i in range(n):
        if a[i] == b[i]:
            forced_cnt[a[i]] += 1
            equal_count += 1
    if any(x >= 2 for x in forced_cnt):
        return 0

    forced = [cnt == 1 for cnt in forced_cnt]

    # Step 2: partition edges
    edgesU = []  # edges entirely within unforced U
    touch_forced_edges = 0  # edges with a!=b and one endpoint forced
    for i in range(n):
        if a[i] != b[i]:
            u, v = a[i], b[i]
            if forced[u] or forced[v]:
                touch_forced_edges += 1
            else:
                edgesU.append((u, v))

    # Prepare adjacency for G[U]
    from collections import defaultdict, deque
    adj = defaultdict(list)
    deg = defaultdict(int)
    for idx, (u, v) in enumerate(edgesU):
        adj[u].append((v, idx))
        adj[v].append((u, idx))
        deg[u] += 1
        deg[v] += 1

    # Set of vertices present in G[U]
    nodesU = set()
    for u, v in edgesU:
        nodesU.add(u)
        nodesU.add(v)

    # Step 3: traverse components in G[U]
    visited_node = set()
    ans = pow(n, equal_count + touch_forced_edges, MOD)

    for start in list(nodesU):
        if start in visited_node:
            continue
        # BFS/DFS this component
        q = [start]
        visited_node.add(start)
        comp_nodes = [start]
        sum_deg = deg[start]
        all_deg_two = (deg[start] == 2)
        while q:
            u = q.pop()
            for (v, _) in adj[u]:
                if v not in visited_node:
                    visited_node.add(v)
                    q.append(v)
                    comp_nodes.append(v)
                    sum_deg += deg[v]
                    if deg[v] != 2:
                        all_deg_two = False
        # edges in component = sum(deg)/2
        k_edges = sum_deg // 2
        if all_deg_two:
            add = (pow(n, k_edges, MOD) - pow(n - 2, k_edges, MOD)) % MOD
            ans = (ans * add) % MOD
        else:
            ans = (ans * pow(n, k_edges, MOD)) % MOD

    return ans

# Deterministic sanity checks with brute force on tiny cases
def brute_check_small():
    # n=1
    assert solve_case_graph(1, [1], [1]) == 1
    # repeated forced -> 0
    assert solve_case_graph(2, [1,1], [1,1]) == 0
    # small random-like fixed cases cross-checked via brute force
    def brute_count(n, a, b):
        from itertools import product
        from functools import lru_cache
        @lru_cache(maxsize=None)
        def dfs(i, used_mask, c_tuple):
            if i == n:
                return used_mask == (1 << n) - 1
            ai, bi, ci = a[i], b[i], c_tuple[i]
            best = False
            for r in range(3):
                remain = []
                if r != 0: remain.append(ai)
                if r != 1: remain.append(bi)
                if r != 2: remain.append(ci)
                worst = True
                for pick in remain:
                    bit = 1 << (pick - 1)
                    if used_mask & bit:
                        res = False
                    else:
                        res = dfs(i + 1, used_mask | bit, c_tuple)
                    worst = worst and res
                best = best or worst
                if best:
                    break
            return best
        cnt = 0
        for c in product(range(1, n + 1), repeat=n):
            dfs.cache_clear()
            if dfs(0, 0, c):
                cnt += 1
        return cnt % MOD

    # Few tiny cross-checks
    cases = [
        (2, [1,2], [2,1]),
        (3, [1,2,3], [1,3,2]),
        (3, [1,1,2], [1,2,3]),
    ]
    for (n, a, b) in cases:
        assert solve_case_graph(n, a, b) == brute_count(n, a, b)

brute_check_small()
\end{minted}
\VALIDATION{Checked on $n\in\{1,2,3\}$ against a brute-force game solver; includes cases with forced duplicates, paths, and $2$-cycles (parallel edges).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Cycle-Break Counting in Multigraph}
\WHICHFORMULA{Let $S=\{v:\exists i,~a_i=b_i=v\}$ with all counts $\le 1$ else answer $0$. For edges with endpoints in $U=V\setminus S$, decompose $G[U]$ into connected components. If a component is a cycle with $k$ edges, it contributes $n^k-(n-2)^k$; otherwise, it contributes $n^{k}$. Multiply also by $n$ for each index with $a_i=b_i$ and for each edge touching $S$.}
\ASSUMPTIONS{Works for multigraphs with parallel edges; self-loops exist only for equal pairs and are handled in $S$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count forced equal pairs; if any value appears twice, output $0$.
\item Count $f=\#\{i:a_i=b_i\}$ and $e_S=$ edges with $a_i\ne b_i$ and an endpoint in $S$.
\item Build $G[U]$ with remaining edges; for each component, compute $k$ and whether all degrees are $2$.
\item Compute
\begin{BreakableEquation*}
\text{ans} \equiv n^{f+e_S}\cdot \prod_{\text{non-cyc CC}} n^{k}\cdot \prod_{\text{cyc CC}} \bigl(n^{k}-(n-2)^{k}\bigr)\ (\bmod~998{,}244{,}353).
\end{BreakableEquation*}
\end{algosteps}
\OPTIMALITY{Linear-time traversal and modular exponentiation are optimal up to constants for input scale $\sum n \le 10^5$. The component-type dichotomy is tight: cycles are the only obstruction.}
\COMPLEXITY{Per test: $\mathcal{O}(n)$ time, $\mathcal{O}(n)$ memory.}
\[
\begin{aligned}
T(n) &= \mathcal{O}(n) \\
S(n) &= \mathcal{O}(n)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import defaultdict

MOD = 998244353

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return []
    it = iter(toks)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        cases.append((n, a, b))
    return cases

def solve_case(n, a, b):
    forced_cnt = [0] * (n + 1)
    equal_count = 0
    for i in range(n):
        if a[i] == b[i]:
            forced_cnt[a[i]] += 1
            equal_count += 1
    if any(x >= 2 for x in forced_cnt):
        return 0

    forced = [cnt == 1 for cnt in forced_cnt]

    edgesU = []
    touch_forced_edges = 0
    for i in range(n):
        if a[i] != b[i]:
            u, v = a[i], b[i]
            if forced[u] or forced[v]:
                touch_forced_edges += 1
            else:
                edgesU.append((u, v))

    adj = defaultdict(list)
    deg = defaultdict(int)
    for idx, (u, v) in enumerate(edgesU):
        adj[u].append((v, idx))
        adj[v].append((u, idx))
        deg[u] += 1
        deg[v] += 1

    nodesU = set()
    for u, v in edgesU:
        nodesU.add(u)
        nodesU.add(v)

    visited_node = set()
    ans = pow(n, equal_count + touch_forced_edges, MOD)

    for start in list(nodesU):
        if start in visited_node:
            continue
        stack = [start]
        visited_node.add(start)
        sum_deg = deg[start]
        all_deg_two = (deg[start] == 2)
        while stack:
            u = stack.pop()
            for (v, _) in adj[u]:
                if v not in visited_node:
                    visited_node.add(v)
                    stack.append(v)
                    sum_deg += deg[v]
                    if deg[v] != 2:
                        all_deg_two = False
        k_edges = sum_deg // 2
        if all_deg_two:
            add = (pow(n, k_edges, MOD) - pow(n - 2, k_edges, MOD)) % MOD
            ans = (ans * add) % MOD
        else:
            ans = (ans * pow(n, k_edges, MOD)) % MOD

    return ans

def solve_all(cases):
    return [solve_case(n, a, b) for (n, a, b) in cases]

def _self_test():
    # Tiny cross-checks against brute force game solver
    from itertools import product
    from functools import lru_cache

    def can_koxia_win_bruteforce(n, a, b, c):
        @lru_cache(maxsize=None)
        def dfs(i, used_mask):
            if i == n:
                return used_mask == (1 << n) - 1
            ai, bi, ci = a[i], b[i], c[i]
            best = False
            for r in range(3):
                remain = []
                if r != 0: remain.append(ai)
                if r != 1: remain.append(bi)
                if r != 2: remain.append(ci)
                worst = True
                for pick in remain:
                    bit = 1 << (pick - 1)
                    if used_mask & bit:
                        res = False
                    else:
                        res = dfs(i + 1, used_mask | bit)
                    worst = worst and res
                best = best or worst
                if best:
                    break
            return best

        return dfs(0, 0)

    def brute_count(n, a, b):
        cnt = 0
        for c in product(range(1, n + 1), repeat=n):
            if can_koxia_win_bruteforce(n, a, b, c):
                cnt += 1
        return cnt % MOD

    # Deterministic tests
    assert solve_case(1, [1], [1]) == 1
    assert solve_case(2, [1, 1], [1, 1]) == 0
    assert solve_case(2, [1, 2], [2, 1]) == brute_count(2, [1, 2], [2, 1])
    assert solve_case(3, [1, 2, 3], [1, 3, 2]) == brute_count(3, [1, 2, 3], [1, 3, 2])

def main():
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
        print("OK")
        return
    cases = read_input(data)
    ans = solve_all(cases)
    print("\n".join(str(x) for x in ans))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts embedded in the self-test plus two more, all for small $n$ and verified by brute force. Tested also on custom small I/O.}
\RESULT{For each test case, the number of arrays $c$ modulo $998{,}244{,}353$ that guarantee Koxia's win under optimal play, using the cycle-break counting formula.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for degenerate cases (all equal pairs, repeated forced value), small cycles (parallel edges, $3$-cycles), and mixed components with forced vertices. Property check: for random $n\le 3$, compare final solver vs brute-force game count.}
\LINE{CROSS-CHECKS}{Baseline brute-force vs optimal solution on tiny instances; compare counts exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays $a,b$ with:
\begin{bullets}
\item Multiple equal pairs, including duplicates of the same value.
\item Parallel edges (two indices with the same unordered pair).
\item A cycle of length $k$ with and without a forced vertex adjacent.
\end{bullets}}
\begin{minted}{python}
import random

def gen_degenerate(n):
    # Many equal pairs; ensure duplicates for forced -> expect 0
    a = [1] * n
    b = [1] * n
    return (n, a, b)

def gen_parallel_edges(n):
    # Make two parallel edges between 1 and 2; rest isolated
    a = [1, 1] + list(range(3, n + 1))
    b = [2, 2] + list(range(3, n + 1))
    return (n, a, b)

def gen_cycle_k(k):
    # Build a k-cycle on 1..k, rest isolated equals
    n = k
    a, b = [], []
    for i in range(1, k + 1):
        u = i
        v = i + 1 if i < k else 1
        a.append(u)
        b.append(v)
    return (n, a, b)

def gen_mixed(n, seed=1):
    random.seed(seed)
    a = [random.randint(1, n) for _ in range(n)]
    b = [random.randint(1, n) for _ in range(n)]
    return (n, a, b)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import defaultdict

MOD = 998244353

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    toks = data.strip().split()
    if not toks:
        return []
    it = iter(toks)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        b = [int(next(it)) for _ in range(n)]
        cases.append((n, a, b))
    return cases

def solve_case(n, a, b):
    forced_cnt = [0] * (n + 1)
    equal_count = 0
    for i in range(n):
        if a[i] == b[i]:
            forced_cnt[a[i]] += 1
            equal_count += 1
    if any(x >= 2 for x in forced_cnt):
        return 0

    forced = [cnt == 1 for cnt in forced_cnt]

    edgesU = []
    touch_forced_edges = 0
    for i in range(n):
        if a[i] != b[i]:
            u, v = a[i], b[i]
            if forced[u] or forced[v]:
                touch_forced_edges += 1
            else:
                edgesU.append((u, v))

    adj = defaultdict(list)
    deg = defaultdict(int)
    for idx, (u, v) in enumerate(edgesU):
        adj[u].append((v, idx))
        adj[v].append((u, idx))
        deg[u] += 1
        deg[v] += 1

    nodesU = set()
    for u, v in edgesU:
        nodesU.add(u)
        nodesU.add(v)

    visited_node = set()
    ans = pow(n, equal_count + touch_forced_edges, MOD)

    for start in list(nodesU):
        if start in visited_node:
            continue
        stack = [start]
        visited_node.add(start)
        sum_deg = deg[start]
        all_deg_two = (deg[start] == 2)
        while stack:
            u = stack.pop()
            for (v, _) in adj[u]:
                if v not in visited_node:
                    visited_node.add(v)
                    stack.append(v)
                    sum_deg += deg[v]
                    if deg[v] != 2:
                        all_deg_two = False
        k_edges = sum_deg // 2
        if all_deg_two:
            add = (pow(n, k_edges, MOD) - pow(n - 2, k_edges, MOD)) % MOD
            ans = (ans * add) % MOD
        else:
            ans = (ans * pow(n, k_edges, MOD)) % MOD

    return ans

def solve_all(cases):
    return [solve_case(n, a, b) for (n, a, b) in cases]

def _self_test():
    # Minimal asserts
    assert solve_case(1, [1], [1]) == 1
    assert solve_case(2, [1, 1], [1, 1]) == 0
    # 2-cycle parallel edges with no forced vertices: k=2 -> n^2 - (n-2)^2
    n = 3
    a = [2, 3, 2]
    b = [3, 2, 1]  # one edge touches forced vertex if we make a=b at index 3
    # Adjust to pure 2-cycle on {2,3} and one forced at 1
    a = [1, 2, 3]
    b = [1, 3, 2]
    # Expected: 3^1 * (3^2 - 1^2) = 24
    assert solve_case(3, a, b) == 24

def main():
    data = sys.stdin.read()
    if not data.strip():
        _self_test()
        print("OK")
        return
    cases = read_input(data)
    ans = solve_all(cases)
    print("\n".join(str(x) for x in ans))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count $c$ arrays so that every cycle component in the unforced multigraph has at least one edge with $c_i$ equal to an endpoint; everything else contributes a factor of $n$.}
\WHY{This pattern (forced picks + cycle vs tree dichotomy) is common in adversarial selection games and shows up in graph-structure interview problems.}
\CHECKLIST{
\begin{bullets}
\item Collect forced equal pairs; fail if any value repeats.
\item Separate edges touching forced vs entirely unforced.
\item Build $G[U]$ and traverse components.
\item For each component, compute $k$ and whether all degrees are $2$.
\item Multiply by $n^{f+e_S}$, by $n^{k}$ for non-cycles, and by $n^{k}-(n-2)^{k}$ for cycles.
\item Take all products modulo $998{,}244{,}353$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $a_i=b_i$ for many $i$ and the same value appears twice $\Rightarrow$ answer $0$.
\item Parallel edges between the same two vertices form a $2$-cycle.
\item Components touching any forced vertex are never cycles in $G[U]$; count them as unrestricted.
\item $n=1$: trivial single forced value or single edge absent.
\item All edges in $U$ isolated (no edges) $\Rightarrow$ only $n^{f+e_S}$ remains.
\item Large $n$ but sparse edges: still linear time.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to remove vertices with a forced occurrence when detecting cycles.
\item Miscounting edges in a component: use $\sum \deg / 2$.
\item Not handling parallel edges correctly; they still give degree $2$ per vertex in a $2$-cycle.
\item Negative modulo after subtraction: normalize $(x-y)\bmod M$.
\item Mixing $1$-based labels with $0$-based bitmasks in brute-force checks.
\item Overflow in other languages: use fast modular exponentiation.
\end{bullets}}
\FAILMODES{Approaches that treat each edge independently will fail on cycles; Mahiru's global coordination matters only in cycles of the unforced subgraph. The presented method survives by collapsing interaction to a per-component multiplicative condition.}
\ELI{Some values are locked in place; the rest form a graph of conflicts. If the conflicts make a loop, you must place at least one ``helpful'' $c_i$ on that loop to break it. Count all choices that achieve this, component by component.}
\NotePages{3}

\end{document}