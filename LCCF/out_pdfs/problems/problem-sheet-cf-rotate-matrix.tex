% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Rotate Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/640/H}}
\LINE{DIFFICULTY / RATING}{CF: 640/H, Rating: 2400}
\STATEMENT{You are given a square matrix of integer numbers. Rotate it $90^\circ$ clockwise (see examples for clarification of rotation).

Input: The input consists of $n$ lines ($1 \le n \le 10$, $n$ is not given explicitly). Each of the lines contains $n$ space-separated integers; $j$-th integer in $i$-th line corresponds to matrix element $m_{ij}$ ($1 \le m_{ij} \le 100$).

Output: Output the rotated matrix in the same format as the input.}
\BREAKDOWN{Parse all non-empty lines to form an $n \times n$ matrix, infer $n$ from the number of lines, then compute the $90^\circ$ clockwise rotation and print it row by row.}
\ELI{Transpose the matrix, then reverse each row to rotate $90^\circ$ clockwise.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A square matrix given as $n$ non-empty lines, each containing $n$ integers in $[1,100]$; $n$ is unknown a priori but satisfies $1 \le n \le 10$.}
\OUTPUTS{An $n \times n$ matrix which is the input matrix rotated $90^\circ$ clockwise, printed in the same format: $n$ lines, each with $n$ space-separated integers.}
\SAMPLES{Example 1

Input:
1 2
3 4

Output:
3 1
4 2

Example 2

Input:
1 2 3
4 5 6
7 8 9

Output:
7 4 1
8 5 2
9 6 3}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \in \mathbb{Z}^{n \times n}$ be the input matrix. Define $B \in \mathbb{Z}^{n \times n}$ as the matrix obtained by rotating $A$ by $90^\circ$ clockwise.}
\varmapStart
\var{n}{matrix dimension ($1 \le n \le 10$)}
\var{A[i][j]}{entry in row $i$, column $j$ of input matrix with $0 \le i,j < n$}
\var{B[i][j]}{entry in row $i$, column $j$ of rotated matrix}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
B[i][j] = A[n-1-j][i] \quad \text{for } 0 \le i,j < n.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are zero-based in the formulation; input lines are well-formed, with exactly $n$ integers per non-empty line.}
\INVARIANTS{The multiset of entries is preserved; i.e., $\{A[i][j]\} = \{B[i][j]\}$. Row/column sums are permuted accordingly: for each $i$, $\sum_j B[i][j] = \sum_j A[j][n-1-i]$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the direct mapping $B[i][j] = A[n-1-j][i]$ to construct a new matrix.}
\ASSUMPTIONS{Matrix is square and fits in memory; $n \le 10$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read all non-empty input lines; set $n$ to the number of lines; parse each line into a row of integers.
\item Allocate $B$ as an $n \times n$ zero matrix.
\item For each $i,j$, assign $B[i][j] \leftarrow A[n-1-j][i]$.
\item Print $B$ row by row, space-separated.
\end{algosteps}
\COMPLEXITY{Time $T(n)=\Theta(n^2)$; space $S(n)=\Theta(n^2)$ for the output matrix.}
\[
\begin{aligned}
T(n) &= n^2 \text{ element moves},\\
S(n) &= n^2 \text{ integers for } B.
\end{aligned}
\]
\CORRECTNESS{The mapping enumerates every pair $(i,j)$ exactly once and assigns it the element from the preimage position of a $90^\circ$ clockwise rotation, matching the governing equation.}
\EDGECASES{$n=1$ (identity), repeated numbers, leading/trailing spaces, and empty lines (ignored).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def read_input(data: str) -> List[List[int]]:
    lines = [ln.strip() for ln in data.splitlines() if ln.strip() != ""]
    if not lines:
        return []
    n = len(lines)
    mat: List[List[int]] = []
    for idx, ln in enumerate(lines):
        row = list(map(int, ln.split()))
        assert len(row) == n, f"Row {idx} length {len(row)} != n {n}"
        mat.append(row)
    return mat

def rotate_new(mat: List[List[int]]) -> List[List[int]]:
    n = len(mat)
    res = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            res[i][j] = mat[n - 1 - j][i]
    return res

def solve_case(mat: List[List[int]]) -> List[List[int]]:
    if not mat:
        return []
    return rotate_new(mat)

def solve_all(data: str) -> str:
    mat = read_input(data)
    if not mat:
        return ""
    rot = solve_case(mat)
    out_lines = [" ".join(str(x) for x in row) for row in rot]
    return "\n".join(out_lines)

def _tests() -> None:
    # 1x1
    assert solve_all("5\n") == "5"
    # 2x2
    s = "1 2\n3 4\n"
    expect = "3 1\n4 2"
    assert solve_all(s) == expect
    # 3x3
    s3 = "1 2 3\n4 5 6\n7 8 9\n"
    expect3 = "7 4 1\n8 5 2\n9 6 3"
    assert solve_all(s3) == expect3
    # malformed (non-square) should assert
    try:
        read_input("1 2 3\n4 5 6\n")
        assert False, "Expected assertion for non-square"
    except AssertionError:
        pass

def main() -> None:
    data = sys.stdin.read()
    if data.strip() == "":
        _tests()
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked 1x1, 2x2, and 3x3 examples; ensured malformed non-square input triggers an assertion in parsing.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{In-Place via Transpose + Reverse Rows}
\WHICHFORMULA{Exploit the decomposition of a $90^\circ$ clockwise rotation into transpose, then reverse each row: $A \gets \text{reverse\_rows}(\text{transpose}(A))$.}
\ASSUMPTIONS{Square matrix; in-place mutation is acceptable.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse the matrix $A$.
\item Transpose in place: for all $0 \le i < j < n$, swap $A[i][j]$ and $A[j][i]$.
\item For each row $i$, reverse $A[i]$ in place.
\item Output the mutated $A$.
\end{algosteps}
\COMPLEXITY{Transposition plus row reversals both visit each element $O(1)$ times.}
\[
\begin{aligned}
T(n) &= \Theta(n^2),\quad S(n) = \Theta(1) \text{ extra (in-place)}.
\end{aligned}
\]
\CORRECTNESS{Transpose reflects across the main diagonal; reversing each row then maps $(r,c)$ to $(c, n-1-r)$, which matches the clockwise rotation mapping.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List

def read_input(data: str) -> List[List[int]]:
    lines = [ln.strip() for ln in data.splitlines() if ln.strip() != ""]
    if not lines:
        return []
    n = len(lines)
    mat: List[List[int]] = []
    for idx, ln in enumerate(lines):
        row = list(map(int, ln.split()))
        assert len(row) == n, f"Row {idx} length {len(row)} != n {n}"
        mat.append(row)
    return mat

def rotate_inplace(mat: List[List[int]]) -> None:
    n = len(mat)
    # transpose
    for i in range(n):
        for j in range(i + 1, n):
            mat[i][j], mat[j][i] = mat[j][i], mat[i][j]
    # reverse rows
    for i in range(n):
        mat[i].reverse()

def solve_case(mat: List[List[int]]) -> List[List[int]]:
    if not mat:
        return []
    rotate_inplace(mat)
    return mat

def solve_all(data: str) -> str:
    mat = read_input(data)
    if not mat:
        return ""
    rot = solve_case(mat)
    out_lines = [" ".join(str(x) for x in row) for row in rot]
    return "\n".join(out_lines)

def _tests() -> None:
    assert solve_all("5\n") == "5"
    assert solve_all("1 2\n3 4\n") == "3 1\n4 2"
    assert solve_all("1 2 3\n4 5 6\n7 8 9\n") == "7 4 1\n8 5 2\n9 6 3"

def main() -> None:
    data = sys.stdin.read()
    if data.strip() == "":
        _tests()
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Validated on 1x1, 2x2, 3x3 cases; confirms in-place mutation yields the correct rotated output.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Pythonic One-Liner with zip and Slicing}
\WHICHFORMULA{Use $B = \text{list}(\text{zip}(*A[::-1]))$ to realize the same rotation succinctly; convert tuples to lists.}
\ASSUMPTIONS{Square matrix; Python standard library only.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read the matrix $A$ from all non-empty lines.
\item Compute $B = [\text{list}(row) \text{ for row in } \text{zip}(*A[::-1])]$.
\item Print $B$ row by row.
\end{algosteps}
\OPTIMALITY{Any algorithm must touch all $n^2$ elements; this achieves the information-theoretic lower bound with minimal overhead and clear code.}
\COMPLEXITY{$\Theta(n^2)$ time and $\Theta(n^2)$ space to materialize the rotated matrix.}
\[
\begin{aligned}
T(n) &= \Theta(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List

def read_input(data: str) -> List[List[int]]:
    lines = [ln.strip() for ln in data.splitlines() if ln.strip() != ""]
    if not lines:
        return []
    n = len(lines)
    mat: List[List[int]] = []
    for idx, ln in enumerate(lines):
        row = list(map(int, ln.split()))
        assert len(row) == n, f"Row {idx} length {len(row)} != n {n}"
        mat.append(row)
    return mat

def rotate_clockwise(mat: List[List[int]]) -> List[List[int]]:
    # Pythonic: rotate 90 degrees clockwise
    return [list(row) for row in zip(*mat[::-1])]

def solve_case(mat: List[List[int]]) -> List[List[int]]:
    if not mat:
        return []
    return rotate_clockwise(mat)

def solve_all(data: str) -> str:
    mat = read_input(data)
    if not mat:
        return ""
    rot = solve_case(mat)
    return "\n".join(" ".join(str(x) for x in row) for row in rot)

def _tests() -> None:
    # Exactly 3 asserts
    assert solve_all("5\n") == "5"
    assert solve_all("1 2\n3 4\n") == "3 1\n4 2"
    assert solve_all("1 2 3\n4 5 6\n7 8 9\n") == "7 4 1\n8 5 2\n9 6 3"

def main() -> None:
    data = sys.stdin.read()
    if data.strip() == "":
        _tests()
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts cover $n=1$, $n=2$, and $n=3$ canonical rotations.}
\RESULT{Print the rotated matrix with rows on separate lines and single spaces between integers; no trailing spaces.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for $n=1,2,3$; randomized small $n \le 5$ matrices checking equivalence of three implementations; malformed inputs should raise an assertion during parsing.}
\LINE{CROSS-CHECKS}{Compare outputs of the direct mapping, in-place transpose+reverse, and zip-based implementations on identical inputs.}
\LINE{EDGE-CASE GENERATOR}{Deterministically generate constant matrices, identity-like patterns, and increasing sequences to ensure positions map correctly.}
\begin{minted}{python}
import sys
from typing import List
import random

def read_input(data: str) -> List[List[int]]:
    lines = [ln.strip() for ln in data.splitlines() if ln.strip() != ""]
    if not lines:
        return []
    n = len(lines)
    mat: List[List[int]] = []
    for idx, ln in enumerate(lines):
        row = list(map(int, ln.split()))
        assert len(row) == n, f"Row {idx} length {len(row)} != n {n}"
        mat.append(row)
    return mat

def rotate_new(mat: List[List[int]]) -> List[List[int]]:
    n = len(mat)
    res = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            res[i][j] = mat[n-1-j][i]
    return res

def rotate_inplace(mat: List[List[int]]) -> None:
    n = len(mat)
    for i in range(n):
        for j in range(i+1, n):
            mat[i][j], mat[j][i] = mat[j][i], mat[i][j]
    for i in range(n):
        mat[i].reverse()

def rotate_zip(mat: List[List[int]]) -> List[List[int]]:
    return [list(row) for row in zip(*mat[::-1])]

def _random_matrix(n: int, seed: int = 0) -> List[List[int]]:
    rng = random.Random(seed)
    return [[rng.randint(1, 9) for _ in range(n)] for _ in range(n)]

def _property_tests() -> None:
    # Cross-check A vs B vs C on small n
    for n in range(1, 6):
        for seed in range(7):
            A = _random_matrix(n, seed)
            B = rotate_new(A)
            C = rotate_zip(A)
            A_copy = [row[:] for row in A]
            rotate_inplace(A_copy)
            assert B == C == A_copy
    # Deterministic patterns
    A = [[i*n + j for j in range(n)] for i in range(n)]
    B = rotate_new(A)
    C = rotate_zip(A)
    A_copy = [row[:] for row in A]
    rotate_inplace(A_copy)
    assert B == C == A_copy

def solve_all(data: str) -> str:
    mat = read_input(data)
    if not mat:
        return ""
    rot = rotate_zip(mat)
    return "\n".join(" ".join(str(x) for x in row) for row in rot)

def main() -> None:
    data = sys.stdin.read()
    if data.strip() == "":
        _property_tests()
        # Basic concrete cases
        assert solve_all("5\n") == "5"
        assert solve_all("1 2\n3 4\n") == "3 1\n4 2"
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List

def read_input(data: str) -> List[List[int]]:
    lines = [ln.strip() for ln in data.splitlines() if ln.strip() != ""]
    if not lines:
        return []
    n = len(lines)
    mat: List[List[int]] = []
    for idx, ln in enumerate(lines):
        row = list(map(int, ln.split()))
        assert len(row) == n, f"Row {idx} length {len(row)} != n {n}"
        mat.append(row)
    return mat

def rotate_clockwise(mat: List[List[int]]) -> List[List[int]]:
    return [list(row) for row in zip(*mat[::-1])]

def solve_case(mat: List[List[int]]) -> List[List[int]]:
    if not mat:
        return []
    return rotate_clockwise(mat)

def solve_all(data: str) -> str:
    mat = read_input(data)
    if not mat:
        return ""
    rot = solve_case(mat)
    return "\n".join(" ".join(str(x) for x in row) for row in rot)

def _tests() -> None:
    assert solve_all("5\n") == "5"
    assert solve_all("1 2\n3 4\n") == "3 1\n4 2"
    assert solve_all("1 2 3\n4 5 6\n7 8 9\n") == "7 4 1\n8 5 2\n9 6 3"

def main() -> None:
    data = sys.stdin.read()
    if data.strip() == "":
        _tests()
        return
    sys.stdout.write(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Rotate an $n \times n$ integer matrix $90^\circ$ clockwise and print it.}
\WHY{Tests reading without explicit $n$, array index mapping, and clean output formatting under time pressure.}
\CHECKLIST{Read all non-empty lines; verify square shape; choose rotation method; print with single spaces and newlines; avoid trailing spaces.}
\EDGECASES{$n=1$; all equal elements; leading/trailing whitespace; blank lines; maximum $n=10$; negative or zero not present but robust parsing still needed; non-square input should be rejected.}
\PITFALLS{Off-by-one in mapping $A[n-1-j][i]$; forgetting in-place transpose loop bounds ($j>i$ only); not reversing each row after transpose; printing tuples from zip without converting to lists; mishandling empty input.}
\FAILMODES{Parsing by tokens only (loses row boundaries) can break shape validation; assuming $n$ is provided leads to wrong reads; using naive string joins may introduce extra spaces. The provided solutions avoid these.}
\ELI{Turn the grid on its side: swap rows and columns (transpose), then flip each row. Or just pick each new cell from the old one by the formula $B[i][j] = A[n-1-j][i]$.}
\NotePages{3}

\end{document}