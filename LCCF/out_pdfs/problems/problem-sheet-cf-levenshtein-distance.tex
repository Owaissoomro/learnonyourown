% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Levenshtein distance}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/530/G}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{Levenshtein distance between two strings of letters is calculated as the minimal total cost of a sequence of edit actions that converts one of the strings into the other one. The allowed edit actions are:
\begin{itemize}
\item substitution: the cost of substituting one letter with another is equal to the absolute difference of index numbers of these letters in English alphabet;
\item insertion/deletion: the cost of inserting a letter into a string or deleting a letter from a string is equal to the index number of this letter in English alphabet (see examples).
\end{itemize}
You are given two strings. Find the Levenshtein distance between them.

Input: The input data consists of two lines, each line contains a string of lowercase Latin letters. Each string is between 1 and 100 letters long, inclusive.

Output: Output a single integer — the Levenshtein distance between the strings.

Note: In the first example you should replace a with b (cost 1), r with u (cost 3) and c with g (cost 4).

In the second example you should insert r (cost 18) and replace m with n (cost 1).}
\BREAKDOWN{Define a dynamic program over prefixes of the two strings. Establish base costs for inserting or deleting prefixes and a recurrence that considers delete, insert, and substitute with the given weights. Compute the minimum total cost.}
\ELI{This is the classic edit distance where substitutions cost the alphabet index difference and inserts/deletes cost the letter index itself.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two lines: string $s$ and string $t$. Each is a nonempty string of lowercase English letters, length in $[1,100]$.}
\OUTPUTS{A single integer: the minimal total cost to transform $s$ into $t$ using the allowed edits and costs.}
\SAMPLES{Example 1:
\begin{itemize}
\item Input:
\begin{itemize}
\item[] arc
\item[] bug
\end{itemize}
\item Output:
\begin{itemize}
\item[] 8
\end{itemize}
\end{itemize}
Example 2:
\begin{itemize}
\item Input:
\begin{itemize}
\item[] am
\item[] arn
\end{itemize}
\item Output:
\begin{itemize}
\item[] 19
\end{itemize}
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s=s_1s_2\ldots s_n$ and $t=t_1t_2\ldots t_m$ with $s_i,t_j\in\{\text{a},\ldots,\text{z}\}$. Define the weight $w(c)\in\{1,\ldots,26\}$ as the index of letter $c$ in the English alphabet ($w(\text{a})=1,\ldots,w(\text{z})=26$). We seek
\begin{BreakableEquation*}
\min \text{ total cost of edits to transform } s \to t,
\end{BreakableEquation*}
where allowed edits are delete $x$ with cost $w(x)$, insert $y$ with cost $w(y)$, substitute $x\to y$ with cost $\lvert w(x)-w(y)\rvert$.}
\varmapStart
\var{s}{source string of length $n$}
\var{t}{target string of length $m$}
\var{w(c)}{alphabet index of letter $c$ in $1..26$}
\var{dp[i,j]}{minimum cost to transform $s_{1..i}$ into $t_{1..j}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&dp[0,0]=0,\\
&dp[i,0]=\sum_{k=1}^{i} w(s_k)\quad (1\le i\le n),\qquad
dp[0,j]=\sum_{k=1}^{j} w(t_k)\quad (1\le j\le m),\\
&dp[i,j]=\min\Big(
dp[i-1,j]+w(s_i),\;
dp[i,j-1]+w(t_j),\;
dp[i-1,j-1]+\lvert w(s_i)-w(t_j)\rvert
\Big)\quad (1\le i\le n,\,1\le j\le m).
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are 1-based in the formulas. All costs are nonnegative integers. Any sequence of edits is allowed so long as it transforms $s$ into $t$.}
\INVARIANTS{
\begin{itemize}
\item Monotonic frontier: $dp[i,j]\le dp[i+1,j]+w(s_{i+1})$ and $dp[i,j]\le dp[i,j+1]+w(t_{j+1})$ by construction.
\item Optimal substructure: any optimal edit script for $(i,j)$ ends with one of the three operations, yielding the recurrence.
\item Nonnegativity: $dp[i,j]\ge 0$ and increases only by the nonnegative operation costs.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the direct optimal substructure to enumerate the three choices recursively on prefixes.}
\ASSUMPTIONS{Intended for very small inputs due to exponential branching; demonstrates the recurrence without memoization.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define $f(i,j)$ as the minimal cost to transform $s_{1..i}$ into $t_{1..j}$.
\item Base cases: $f(0,j)=\sum_{k=1}^j w(t_k)$, $f(i,0)=\sum_{k=1}^i w(s_k)$.
\item Recurse: $f(i,j)=\min\{f(i-1,j)+w(s_i),\;f(i,j-1)+w(t_j),\;f(i-1,j-1)+\lvert w(s_i)-w(t_j)\rvert\}$.
\end{algosteps}
\COMPLEXITY{Without memoization the time is exponential in $\max(n,m)$; space is $O(n+m)$ due to recursion depth.}
\[
\begin{aligned}
T(n,m) &= T(n-1,m)+T(n,m-1)+T(n-1,m-1)+O(1) \\
       &= \Theta(3^{\min(n,m)}) \text{ in the worst case.}
\end{aligned}
\]
\CORRECTNESS{Follows from the optimal substructure: any optimal final step must be one of delete, insert, or substitute, each reducing the problem to a strictly smaller prefix pair. Base cases account for transforming to or from the empty string via only insertions or deletions.}
\EDGECASES{Identical strings yield cost 0. Transforming to the empty string costs the sum of weights of deleted letters; from empty to a string costs the sum of weights of inserted letters.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)

from typing import Tuple

def weight(c: str) -> int:
    return ord(c) - 96  # 'a'->1 ... 'z'->26

def sum_weights(s: str) -> int:
    return sum(weight(ch) for ch in s)

def dist_naive(s: str, t: str, i: int, j: int) -> int:
    if i == 0:
        return sum_weights(t[:j])
    if j == 0:
        return sum_weights(s[:i])
    return min(
        dist_naive(s, t, i - 1, j) + weight(s[i - 1]),  # delete s[i-1]
        dist_naive(s, t, i, j - 1) + weight(t[j - 1]),  # insert t[j-1]
        dist_naive(s, t, i - 1, j - 1) + abs(weight(s[i - 1]) - weight(t[j - 1])),  # substitute
    )

def compute_distance_naive(s: str, t: str) -> int:
    return dist_naive(s, t, len(s), len(t))

def read_input() -> Tuple[str, str]:
    import sys
    data = sys.stdin.read().splitlines()
    if not data:
        return "", ""
    s = data[0].strip()
    t = data[1].strip() if len(data) > 1 else ""
    return s, t

def solve_case(s: str, t: str) -> str:
    # Warning: exponential; use only for very small inputs.
    return str(compute_distance_naive(s, t))

def main() -> None:
    s, t = read_input()
    if s != "" or t != "":
        print(solve_case(s, t))

if __name__ == "__main__":
    # Tiny sanity asserts (keep sizes small due to exponential runtime)
    assert compute_distance_naive("a", "a") == 0
    assert compute_distance_naive("arc", "bug") == 8  # 1+3+4
    assert compute_distance_naive("", "abc") == 1 + 2 + 3
    main()
\end{minted}
\VALIDATION{Checked equal strings, empty-to-nonempty, and a small substitution-only example.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Bottom-up dynamic programming fills an $(n+1)\times(m+1)$ table using the recurrence; avoids exponential recomputation.}
\ASSUMPTIONS{Two-dimensional DP is feasible for $n,m\le 100$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $w(c)$ for letters.
\item Initialize first row and column with cumulative sums of weights.
\item Fill $dp[i][j]$ by taking the minimum of delete, insert, and substitute transitions.
\end{algosteps}
\COMPLEXITY{Time $O(nm)$ and space $O(nm)$, which is efficient for $n,m\le 100$ and strictly improves on the exponential baseline.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm),\quad S(n,m)=\Theta(nm).
\end{aligned}
\]
\CORRECTNESS{Each cell uses the optimal costs of strictly smaller subproblems. Initialization matches the cost of pure insertions or deletions. The DP thus computes the optimal value by induction on $(i+j)$.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts

from typing import List, Tuple

def weight(c: str) -> int:
    return ord(c) - 96

def compute_distance_dp(s: str, t: str) -> int:
    n, m = len(s), len(t)
    dp: List[List[int]] = [[0]*(m+1) for _ in range(n+1)]
    for i in range(1, n+1):
        dp[i][0] = dp[i-1][0] + weight(s[i-1])
    for j in range(1, m+1):
        dp[0][j] = dp[0][j-1] + weight(t[j-1])
    for i in range(1, n+1):
        si = s[i-1]
        wsi = weight(si)
        for j in range(1, m+1):
            tj = t[j-1]
            wtj = weight(tj)
            dp[i][j] = min(
                dp[i-1][j] + wsi,                 # delete s[i-1]
                dp[i][j-1] + wtj,                 # insert t[j-1]
                dp[i-1][j-1] + abs(wsi - wtj)     # substitute
            )
    return dp[n][m]

def read_input() -> Tuple[str, str]:
    import sys
    data = sys.stdin.read().splitlines()
    if not data:
        return "", ""
    s = data[0].strip()
    t = data[1].strip() if len(data) > 1 else ""
    return s, t

def solve_case(s: str, t: str) -> str:
    return str(compute_distance_dp(s, t))

def main() -> None:
    s, t = read_input()
    if s != "" or t != "":
        print(solve_case(s, t))

if __name__ == "__main__":
    # Deterministic checks
    assert compute_distance_dp("arc", "bug") == 8
    assert compute_distance_dp("am", "arn") == 19
    assert compute_distance_dp("a", "z") == 25
    main()
\end{minted}
\VALIDATION{Verified substitution-only case, combined insert+substitute case, and a case where substitution beats delete+insert.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Same DP transitions, but store only the previous row to reduce memory to $O(m)$.}
\ASSUMPTIONS{Row-wise dependency allows rolling array; strings of length up to 100 make both time and memory trivial.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep two arrays: previous row and current row of length $m+1$.
\item Initialize the previous row as costs from empty $s$ to $t_{1..j}$.
\item For each $i=1..n$, set $cur[0]=cur[0]$ initialization and fill $cur[j]$ via the three transitions using $prev$ and $cur$.
\end{algosteps}
\OPTIMALITY{The DP recurrence is optimal by standard exchange/inductive arguments. Space is minimized to $O(m)$ since each row depends only on the previous row. Time is $O(nm)$ and matches the lower bound needed to inspect all pairs of characters in the worst case.}
\COMPLEXITY{Time $O(nm)$, space $O(m)$.}
\[
\begin{aligned}
T(n,m) &= \Theta(nm),\quad S(n,m)=\Theta(m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts

from typing import Tuple, List

def weight(c: str) -> int:
    return ord(c) - 96

def compute_distance_rolling(s: str, t: str) -> int:
    n, m = len(s), len(t)
    prev: List[int] = [0]*(m+1)
    for j in range(1, m+1):
        prev[j] = prev[j-1] + weight(t[j-1])
    for i in range(1, n+1):
        cur: List[int] = [0]*(m+1)
        cur[0] = prev[0] + weight(s[i-1])
        wsi = weight(s[i-1])
        for j in range(1, m+1):
            wtj = weight(t[j-1])
            delete_cost = prev[j] + wsi          # delete s[i-1]
            insert_cost = cur[j-1] + wtj         # insert t[j-1]
            subst_cost  = prev[j-1] + abs(wsi - wtj)
            cur[j] = min(delete_cost, insert_cost, subst_cost)
        prev = cur
    return prev[m]

def read_input() -> Tuple[str, str]:
    import sys
    data = sys.stdin.read().splitlines()
    if not data:
        return "", ""
    s = data[0].strip()
    t = data[1].strip() if len(data) > 1 else ""
    return s, t

def solve_case(s: str, t: str) -> str:
    return str(compute_distance_rolling(s, t))

def main() -> None:
    s, t = read_input()
    if s != "" or t != "":
        print(solve_case(s, t))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert compute_distance_rolling("arc", "bug") == 8
    assert compute_distance_rolling("am", "arn") == 19
    assert compute_distance_rolling("a"*5, "a"*5) == 0
    main()
\end{minted}
\VALIDATION{Three checks: pure substitutions, insert+substitute mix, and identical strings.}
\RESULT{Print a single integer: the minimal total edit cost with delete/insert costs $w(c)$ and substitution costs $\lvert w(x)-w(y)\rvert$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for base cases, random small strings, and adversarial cases where substitution vs delete+insert differs.}
\LINE{CROSS-CHECKS}{For small strings, cross-check the rolling-array result against the full-table DP and the naive recursion.}
\LINE{EDGE-CASE GENERATOR}{Generate empty-to-nonempty, identical strings, and strings with letters at alphabet extremes (a, z) to stress substitution vs insert+delete.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

import random
from typing import Tuple

def weight(c: str) -> int:
    return ord(c) - 96

def compute_distance_dp(s: str, t: str) -> int:
    n, m = len(s), len(t)
    dp = [[0]*(m+1) for _ in range(n+1)]
    for i in range(1, n+1):
        dp[i][0] = dp[i-1][0] + weight(s[i-1])
    for j in range(1, m+1):
        dp[0][j] = dp[0][j-1] + weight(t[j-1])
    for i in range(1, n+1):
        wsi = weight(s[i-1])
        for j in range(1, m+1):
            wtj = weight(t[j-1])
            dp[i][j] = min(
                dp[i-1][j] + wsi,
                dp[i][j-1] + wtj,
                dp[i-1][j-1] + abs(wsi - wtj),
            )
    return dp[n][m]

def compute_distance_rolling(s: str, t: str) -> int:
    n, m = len(s), len(t)
    prev = [0]*(m+1)
    for j in range(1, m+1):
        prev[j] = prev[j-1] + weight(t[j-1])
    for i in range(1, n+1):
        cur = [0]*(m+1)
        cur[0] = prev[0] + weight(s[i-1])
        wsi = weight(s[i-1])
        for j in range(1, m+1):
            wtj = weight(t[j-1])
            cur[j] = min(
                prev[j] + wsi,
                cur[j-1] + wtj,
                prev[j-1] + abs(wsi - wtj),
            )
        prev = cur
    return prev[m]

def rand_string(L: int) -> str:
    return "".join(chr(97 + random.randrange(26)) for _ in range(L))

def self_check() -> None:
    random.seed(0)
    # Boundaries
    assert compute_distance_dp("", "") == 0
    assert compute_distance_dp("", "abc") == 1 + 2 + 3
    assert compute_distance_dp("zzz", "") == 26*3
    # Cross-check random small cases
    for n in range(0, 6):
        for m in range(0, 6):
            for _ in range(20):
                s = rand_string(n)
                t = rand_string(m)
                a = compute_distance_dp(s, t)
                b = compute_distance_rolling(s, t)
                assert a == b
    # Adversarial: substitution cheaper than delete+insert
    assert compute_distance_dp("a", "z") == 25  # vs 1+26=27

if __name__ == "__main__":
    self_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts

from typing import Tuple, List

def weight(c: str) -> int:
    return ord(c) - 96

def compute_distance(s: str, t: str) -> int:
    n, m = len(s), len(t)
    prev: List[int] = [0]*(m+1)
    for j in range(1, m+1):
        prev[j] = prev[j-1] + weight(t[j-1])
    for i in range(1, n+1):
        cur: List[int] = [0]*(m+1)
        cur[0] = prev[0] + weight(s[i-1])
        wsi = weight(s[i-1])
        for j in range(1, m+1):
            wtj = weight(t[j-1])
            delete_cost = prev[j] + wsi
            insert_cost = cur[j-1] + wtj
            subst_cost  = prev[j-1] + abs(wsi - wtj)
            cur[j] = min(delete_cost, insert_cost, subst_cost)
        prev = cur
    return prev[m]

def read_input() -> Tuple[str, str]:
    import sys
    data = sys.stdin.read().splitlines()
    if not data:
        return "", ""
    s = data[0].strip()
    t = data[1].strip() if len(data) > 1 else ""
    return s, t

def solve_case(s: str, t: str) -> str:
    return str(compute_distance(s, t))

def main() -> None:
    s, t = read_input()
    if s != "" or t != "":
        print(solve_case(s, t))

if __name__ == "__main__":
    # Sanity asserts
    assert compute_distance("arc", "bug") == 8
    assert compute_distance("am", "arn") == 19
    assert compute_distance("a", "z") == 25
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute a weighted edit distance where delete/insert costs are letter indices and substitution costs are absolute index differences.}
\WHY{Weighted edit distances appear in string alignment with heterogeneous costs; recognizing and formulating the DP quickly is key in interviews.}
\CHECKLIST{
\begin{itemize}
\item Define $w(c)$ correctly: a$\to$1, z$\to$26.
\item Set base rows and columns as cumulative sums.
\item Use absolute difference for substitution cost.
\item Fill DP in correct order; consider rolling array to save memory.
\item Print a single integer.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item Identical strings: answer is 0.
\item One string empty: sum of weights of the other string.
\item Single-character transforms: compare substitution vs delete+insert.
\item Repeated letters causing cumulative base costs.
\item Extremes: a$\leftrightarrow$z where substitution is cheaper than delete+insert.
\item Very short vs very long length differences.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Forgetting absolute value in substitution cost.
\item Off-by-one indexing in DP table.
\item Misinitializing $dp[i,0]$ or $dp[0,j]$.
\item Using character code directly instead of 1-based alphabet index.
\item Overflow is not an issue in Python, but ensure integers are used.
\item Not trimming input lines; trailing spaces may break results.
\end{itemize}}
\FAILMODES{
\begin{itemize}
\item Naive recursion times out for moderate lengths; use DP.
\item Greedy local choices (e.g., always substitute) can be suboptimal globally.
\item Misinterpreting substitution cost as $w(x)+w(y)$ instead of $\lvert w(x)-w(y)\rvert$ inflates answers.
\end{itemize}}
\ELI{We measure how hard it is to turn one word into another, where changing a letter costs how far apart they are in the alphabet, and adding or removing a letter costs that letter's index. A small dynamic program over prefixes gives the exact minimum cost.}
\NotePages{3}

\end{document}