% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Transpose Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/transpose-matrix/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Given a 2D integer array \texttt{matrix}, return the transpose of \texttt{matrix}. The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

Example 1:

Input: \texttt{matrix = [[1,2,3],[4,5,6],[7,8,9]]}

Output: \texttt{[[1,4,7],[2,5,8],[3,6,9]]}

Example 2:

Input: \texttt{matrix = [[1,2,3],[4,5,6]]}

Output: \texttt{[[1,4],[2,5],[3,6]]}

Constraints:
\begin{bullets}
\item $m = \texttt{len(matrix)}$
\item $n = \texttt{len(matrix[i])}$
\item $1 \le m, n \le 1000$
\item $1 \le m \times n \le 10^5$
\item $-10^9 \le \texttt{matrix[i][j]} \le 10^9$
\end{bullets}}
\BREAKDOWN{Compute an $n \times m$ matrix where entry $(i,j)$ is the original entry $(j,i)$. Allocate the output with swapped dimensions and fill by iterating all pairs.}
\ELI{Swap rows with columns: the item at row $r$, col $c$ moves to row $c$, col $r$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of $m$ lists, each of length $n$, containing integers within $[-10^9, 10^9]$. Sizes satisfy $1 \le m, n \le 1000$ and $1 \le m \times n \le 10^5$.}
\OUTPUTS{A new list of $n$ lists of length $m$ such that for all valid $i,j$, $\texttt{out}[i][j] = \texttt{matrix}[j][i]$.}
\SAMPLES{Example A: Input \texttt{[[1,2],[3,4],[5,6]]} $\to$ Output \texttt{[[1,3,5],[2,4,6]]}. Example B: Input \texttt{[[42]]} $\to$ Output \texttt{[[42]]}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $M \in \mathbb{Z}^{m \times n}$ be the input matrix. Produce $T \in \mathbb{Z}^{n \times m}$ with entries $T_{i,j} = M_{j,i}$ for all valid indices.}
\varmapStart
\var{m}{number of rows of the input}
\var{n}{number of columns of the input}
\var{M}{input matrix in $\mathbb{Z}^{m \times n}$}
\var{T}{transpose matrix in $\mathbb{Z}^{n \times m}$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall~i \in [0,n-1],~\forall~j \in [0,m-1]:\quad T[i,j] = M[j,i].
\end{BreakableEquation*}
}
\ASSUMPTIONS{Zero-based indexing for implementation; all rows in \texttt{matrix} have equal length $n$.}
\INVARIANTS{
\begin{bullets}
\item Output shape is always $n \times m$.
\item Each original element $M[j,i]$ appears exactly once in $T[i,j]$.
\item No mutation of $M$ during construction of $T$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct definition: assign $T[i][j] \leftarrow M[j][i]$ for all $i \in [0,n)$, $j \in [0,m)$.}
\ASSUMPTIONS{Allocate a fresh $n \times m$ list of lists; iterate nested loops over all pairs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $m \leftarrow \texttt{len(matrix)}$, $n \leftarrow \texttt{len(matrix[0])}$.
\item Create \texttt{out} as a list of $n$ rows, each a list of $m$ zeros.
\item For $r$ in $[0,m)$ and $c$ in $[0,n)$, set \texttt{out[c][r] = matrix[r][c]}.
\end{algosteps}
\COMPLEXITY{Touches each of the $m \times n$ elements once; uses $n \times m$ extra space for output.}
\[
\begin{aligned}
T(m,n) &= \Theta(mn), \\
S(m,n) &= \Theta(mn) \text{ for the returned matrix.}
\end{aligned}
\]
\CORRECTNESS{By construction, each entry $(r,c)$ of the input is written exactly once to $(c,r)$ of the output, which matches the transpose definition.}
\EDGECASES{Single row ($m=1$), single column ($n=1$), and rectangular ($m \ne n$) are all handled uniformly.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0])
        out = [[0] * m for _ in range(n)]
        for r in range(m):
            row = matrix[r]
            for c in range(n):
                out[c][r] = row[c]
        return out

# Tests (baseline)
s = Solution()
assert s.transpose([[1,2,3],[4,5,6],[7,8,9]]) == [[1,4,7],[2,5,8],[3,6,9]]
assert s.transpose([[1,2,3],[4,5,6]]) == [[1,4],[2,5],[3,6]]
assert s.transpose([[42]]) == [[42]]
\end{minted}
\VALIDATION{The asserts cover square, rectangular, and $1 \times 1$ matrices.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use Python's iterator unpacking with \texttt{zip(*matrix)} to transpose rows to columns in a memory-efficient, concise way, then map tuples back to lists.}
\ASSUMPTIONS{Relies on all rows having equal length; \texttt{zip} stops at the shortest row, which equals $n$ under the problem constraints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute \texttt{zip(*matrix)} which yields column-wise tuples.
\item Convert each tuple to a list.
\item Return the list of converted columns.
\end{algosteps}
\COMPLEXITY{Still linear in the number of elements; constant-factor improvement and very concise code.}
\[
\begin{aligned}
T(m,n) &= \Theta(mn).
\end{aligned}
\]
\CORRECTNESS{Python's \texttt{zip} pairs the $c$-th element of each row, producing exactly the $c$-th column of the transpose.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        return [list(col) for col in zip(*matrix)]

# Tests (improved)
s = Solution()
assert s.transpose([[1,2,3],[4,5,6],[7,8,9]]) == [[1,4,7],[2,5,8],[3,6,9]]
assert s.transpose([[1,2,3],[4,5,6]]) == [[1,4],[2,5],[3,6]]
assert s.transpose([[5],[6],[7]]) == [[5,6,7]]
\end{minted}
\VALIDATION{Covers square, wide, and tall matrices to ensure correct shape and values.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Single-pass write into preallocated output using cache-friendly row reads and column writes. This matches the lower bound of visiting each element once.}
\ASSUMPTIONS{All rows have equal length; output allocated as $n \times m$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $m, n$.
\item Allocate $n \times m$ output.
\item For each $r$ in $[0,m)$ and $c$ in $[0,n)$, write \texttt{out[c][r] = matrix[r][c]}.
\end{algosteps}
\OPTIMALITY{Any correct algorithm must inspect all $mn$ inputs; thus $\Omega(mn)$ time is necessary. The method uses $O(mn)$ time and optimal $O(mn)$ output space.}
\COMPLEXITY{Linear in the number of elements, with minimal overhead.}
\[
\begin{aligned}
T(m,n) &= \Theta(mn).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0])
        out = [[0] * m for _ in range(n)]
        for r, row in enumerate(matrix):
            for c, val in enumerate(row):
                out[c][r] = val
        return out

# Exact 3 asserts
s = Solution()
assert s.transpose([[1,2,3],[4,5,6],[7,8,9]]) == [[1,4,7],[2,5,8],[3,6,9]]
assert s.transpose([[1,2,3],[4,5,6]]) == [[1,4],[2,5],[3,6]]
assert s.transpose([[7],[8],[9],[10]]) == [[7,8,9,10]]
\end{minted}
\VALIDATION{Three asserts match the platform's examples and include a tall matrix.}
\RESULT{Return the transposed matrix with shape $n \times m$; element order within each row corresponds to original column order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify shapes for tall, wide, and square matrices; test random matrices against a simple oracle (\texttt{zip(*matrix)}); include boundary sizes like $1 \times 1$, $1 \times n$, and $m \times 1$.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A and B on small random inputs to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate matrices with extremes: min/max values, single row, single column, and mixed signs.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_matrix(m: int, n: int, lo: int = -3, hi: int = 3) -> List[List[int]]:
    random.seed(m * 10007 + n)
    return [[random.randint(lo, hi) for _ in range(n)] for _ in range(m)]

def transpose_ref(mat: List[List[int]]) -> List[List[int]]:
    return [list(col) for col in zip(*mat)]

def test_cross():
    from typing import List
    class A:
        def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
            m = len(matrix); n = len(matrix[0])
            out = [[0]*m for _ in range(n)]
            for r in range(m):
                for c in range(n):
                    out[c][r] = matrix[r][c]
            return out
    a = A()
    # small grid of sizes
    for m in range(1,5):
        for n in range(1,5):
            mat = gen_matrix(m, n)
            assert a.transpose(mat) == transpose_ref(mat)

test_cross()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        # Preallocate output and write once per element
        m = len(matrix)
        n = len(matrix[0])
        out = [[0] * m for _ in range(n)]
        for r, row in enumerate(matrix):
            for c, val in enumerate(row):
                out[c][r] = val
        return out

# Sanity tests
if __name__ == "__main__":
    s = Solution()
    assert s.transpose([[1,2,3],[4,5,6],[7,8,9]]) == [[1,4,7],[2,5,8],[3,6,9]]
    assert s.transpose([[1,2,3],[4,5,6]]) == [[1,4],[2,5],[3,6]]
    assert s.transpose([[42]]) == [[42]]
    # Randomized cross-check
    import random
    random.seed(0)
    for m in range(1,6):
        for n in range(1,6):
            mat = [[random.randint(-5,5) for _ in range(n)] for _ in range(m)]
            out = s.transpose(mat)
            ref = [list(col) for col in zip(*mat)]
            assert out == ref
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Return a new matrix where element at $(r,c)$ moves to $(c,r)$.}
\WHY{Matrices and their transposes are fundamental; this tests indexing, allocation, and iteration discipline.}
\CHECKLIST{
\begin{bullets}
\item Read $m, n$ correctly from the input structure.
\item Allocate output with shape $n \times m$.
\item Loop order: write \texttt{out[c][r]} from \texttt{matrix[r][c]}.
\item Handle rectangular cases ($m \ne n$).
\item Do not mutate input; return a fresh matrix.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $1 \times 1$ matrix.
\item Single row ($m=1$).
\item Single column ($n=1$).
\item Tall vs.\ wide matrices.
\item Negative and large values within bounds.
\item Maximum size subject to $m \times n \le 10^5$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Swapping $m$ and $n$ but not allocating correctly.
\item Index order mistake: writing \texttt{out[r][c]} instead of \texttt{out[c][r]}.
\item Assuming square matrix and using in-place swaps (not applicable here).
\item Misusing \texttt{zip} with ragged rows (not allowed by constraints).
\item Forgetting to convert tuples to lists when using \texttt{zip}.
\item Off-by-one errors in loops.
\end{bullets}
}
\FAILMODES{Any approach that assumes $m=n$ fails on rectangular inputs. Using \texttt{zip} without converting to lists may mismatch expected output type if a platform requires lists.}
\ELI{Copy the table but swap the roles of rows and columns. The item at row $r$ and column $c$ in the original becomes the item at row $c$ and column $r$ in the answer.}
\NotePages{3}

\end{document}