% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Longest Increasing Path in a Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/longest-increasing-path-in-a-matrix/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given an \(m \times n\) integer matrix \texttt{matrix}, return the length of the longest increasing path in \texttt{matrix}. From each cell, you can move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (wrap-around is not allowed).

Example 1:

Input: \texttt{matrix = [[9,9,4],[6,6,8],[2,1,1]]}

Output: \texttt{4}

Explanation: The longest increasing path is \([1, 2, 6, 9]\).

Example 2:

Input: \texttt{matrix = [[3,4,5],[3,2,6],[2,2,1]]}

Output: \texttt{4}

Explanation: The longest increasing path is \([3, 4, 5, 6]\). Moving diagonally is not allowed.

Example 3:

Input: \texttt{matrix = [[1]]}

Output: \texttt{1}

Constraints:
\begin{bullets}
\item \(\texttt{m} = \text{len}(\texttt{matrix})\).
\item \(\texttt{n} = \text{len}(\texttt{matrix[i]})\).
\item \(1 \le m, n \le 200\).
\item \(0 \le \texttt{matrix[i][j]} \le 2^{31} - 1\).
\end{bullets}}
\BREAKDOWN{Model the grid as a directed acyclic graph where edges go from a cell to its strictly larger neighbors. Then compute the longest path length over this DAG, using either DFS with memoization or topological layering.}
\ELI{Treat each cell as a node and move only to bigger numbers; the answer is the longest chain you can walk without going down or staying equal.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of lists of integers \texttt{matrix} with shape \(m \times n\), where \(1 \le m, n \le 200\) and entries in \([0, 2^{31}-1]\).}
\OUTPUTS{An integer: the maximum length of a strictly increasing path moving only in the four cardinal directions.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{[[9,9,4],[6,6,8],[2,1,1]]} \(\to\) Output: \texttt{4}
\item Input: \texttt{[[3,4,5],[3,2,6],[2,2,1]]} \(\to\) Output: \texttt{4}
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let grid indices be \(\{0,\ldots,m-1\} \times \{0,\ldots,n-1\}\). Define a directed graph \(G=(V,E)\) with \(V=\{(i,j)\}\) and \(((i,j)\to (i',j')) \in E\) iff \((i',j')\) is a 4-neighbor of \((i,j)\) and \(A_{i',j'} > A_{i,j}\). The objective is
\begin{BreakableEquation*}
\max_{v \in V} \operatorname{dist}^+(v),
\end{BreakableEquation*}
where \(\operatorname{dist}^+(v)\) is the length (in nodes) of the longest directed path starting at \(v\).}
\varmapStart
\var{m,n}{grid dimensions}
\var{A_{i,j}}{value at cell \((i,j)\)}
\var{E}{directed edges from lower to higher neighboring values}
\var{f(i,j)}{longest increasing path length starting at \((i,j)\)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
f(i,j) \;=\; 1 + \max_{(i',j') \in \mathcal{N}(i,j),\, A_{i',j'} > A_{i,j}} f(i',j') \quad\text{with}\quad f(i,j)=1 \text{ if no larger neighbor},
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{Answer} \;=\; \max_{0 \le i < m,\; 0 \le j < n} f(i,j).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Strictly increasing moves imply acyclicity, so dynamic programming or topological layering is valid. Grid boundaries are hard walls; no diagonal moves.}
\INVARIANTS{
\begin{bullets}
\item Along any valid path, values strictly increase: \(A_{v_0} < A_{v_1} < \cdots\).
\item Memoized \(f(i,j)\) once computed never changes (DAG).
\item Topological layers by outdegree zero shrink each round in Kahn's algorithm. 
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Naively explore all increasing paths via DFS from every cell without memoization; take the maximum length encountered.}
\ASSUMPTIONS{Because moves are strictly increasing, paths are simple and finite, but subproblems repeat heavily.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each cell \((i,j)\), run a DFS that tries all 4 neighbors with larger values.
\item Track the best length reached from that start; update a global maximum.
\item Return the global maximum over all starts.
\end{algosteps}
\COMPLEXITY{In the worst case with many plateaus of near-increasing values, subproblems repeat exponentially. Space is \(O(\text{path length})\) for recursion depth.}
\[
\begin{aligned}
T(m,n) &\;\text{can be exponential in } mn \text{ without memoization},\\
S(m,n) &\in O(mn) \text{ in the worst case due to recursion stack across calls}.
\end{aligned}
\]
\CORRECTNESS{Every strictly increasing path is explored from its starting cell. The maximum over all starts equals the longest path length by definition.}
\EDGECASES{Single cell grid; all equal values; strictly increasing snake; large flat plateaus.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        dirs: List[Tuple[int,int]] = [(1,0), (-1,0), (0,1), (0,-1)]

        def dfs(i: int, j: int) -> int:
            best = 1
            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:
                    best = max(best, 1 + dfs(ni, nj))
            return best

        ans = 0
        for i in range(m):
            for j in range(n):
                ans = max(ans, dfs(i, j))
        return ans

# Basic asserts (small cases; this baseline is correct but inefficient)
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestIncreasingPath([[1]]) == 1
    assert sol.longestIncreasingPath([[9,9,4],[6,6,8],[2,1,1]]) == 4
    assert sol.longestIncreasingPath([[3,4,5],[3,2,6],[2,2,1]]) == 4
\end{minted}
\VALIDATION{Checked on the three examples; also implicitly validates that no diagonal or boundary-crossing moves occur.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Top-down DFS with memoization computes each \(f(i,j)\) once on the DAG defined by increasing edges.}
\ASSUMPTIONS{Acyclicity from strict increases makes memoization sound; 4-neighborhood only.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a cache \(\texttt{dp}[i][j]\) storing the longest path length from \((i,j)\).
\item DFS from each cell; if \(\texttt{dp}[i][j]\) is known, return it.
\item Transition to neighbors with larger values; take \(1+\) maximum child length.
\item Track and return the maximum over all cells.
\end{algosteps}
\COMPLEXITY{Each state \((i,j)\) is computed once and considers at most 4 neighbors. Time \(O(mn)\), space \(O(mn)\) for the cache plus recursion depth.}
\[
\begin{aligned}
T(m,n) &\in O(mn),\\
S(m,n) &\in O(mn).
\end{aligned}
\]
\CORRECTNESS{By DAG DP, the recurrence for \(f(i,j)\) is exact; memoization ensures values are consistent and reused.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        dp = [[0]*n for _ in range(m)]
        dirs: List[Tuple[int,int]] = [(1,0), (-1,0), (0,1), (0,-1)]

        def dfs(i: int, j: int) -> int:
            if dp[i][j] != 0:
                return dp[i][j]
            best = 1
            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:
                    best = max(best, 1 + dfs(ni, nj))
            dp[i][j] = best
            return best

        ans = 0
        for i in range(m):
            for j in range(n):
                ans = max(ans, dfs(i, j))
        return ans

# Asserts for correctness on representative cases
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestIncreasingPath([[1]]) == 1
    assert sol.longestIncreasingPath([[9,9,4],[6,6,8],[2,1,1]]) == 4
    assert sol.longestIncreasingPath([[3,4,5],[3,2,6],[2,2,1]]) == 4
    # Flat grid
    assert sol.longestIncreasingPath([[7,7],[7,7]]) == 1
\end{minted}
\VALIDATION{Validated on examples and an all-equal grid where the answer must be 1.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Kahn-style topological layering on the DAG with edges from lower to higher values. The number of layers equals the longest path length.}
\ASSUMPTIONS{Edges only from a cell to strictly larger neighbors; thus no cycles.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute outdegree for each cell as the number of neighbors with larger values.
\item Initialize a queue with all outdegree-zero cells (local maxima); set length \(\ell = 0\).
\item While the queue is nonempty: process the whole layer, decrementing neighbors' outdegrees along reverse edges (from lower to higher). Push any that drop to zero. Increment \(\ell\).
\item Return \(\ell\).
\end{algosteps}
\OPTIMALITY{Each layer peels one step of the longest path from the top; the number of layers equals the height of the DAG, i.e., the longest path length. This is tight and runs in linear time in the number of edges.}
\COMPLEXITY{Each edge and node is processed \(O(1)\) times.}
\[
\begin{aligned}
T(m,n) &\in O(mn), \\
S(m,n) &\in O(mn).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple
from collections import deque

class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        dirs: List[Tuple[int,int]] = [(1,0), (-1,0), (0,1), (0,-1)]
        outdeg = [[0]*n for _ in range(m)]

        # Compute outdegree: edges to strictly larger neighbors
        for i in range(m):
            for j in range(n):
                for di, dj in dirs:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:
                        outdeg[i][j] += 1

        # Start with local maxima (outdegree 0)
        q = deque()
        for i in range(m):
            for j in range(n):
                if outdeg[i][j] == 0:
                    q.append((i, j))

        layers = 0
        while q:
            layers += 1
            for _ in range(len(q)):
                i, j = q.popleft()
                # For reverse edges: from lower neighbor u to current v=(i,j) with A[u] < A[v]
                for di, dj in dirs:
                    pi, pj = i + di, j + dj
                    if 0 <= pi < m and 0 <= pj < n and matrix[pi][pj] < matrix[i][j]:
                        outdeg[pi][pj] -= 1
                        if outdeg[pi][pj] == 0:
                            q.append((pi, pj))
        return layers

# Exactly 3 asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.longestIncreasingPath([[1]]) == 1
    assert sol.longestIncreasingPath([[9,9,4],[6,6,8],[2,1,1]]) == 4
    assert sol.longestIncreasingPath([[3,4,5],[3,2,6],[2,2,1]]) == 4
\end{minted}
\VALIDATION{Three asserts match the official examples.}
\RESULT{Returns the maximum length of any strictly increasing path; ties are irrelevant, only the length is returned.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on trivial \(1 \times 1\) and all-equal grids; monotone ramps; random small grids cross-checked between DFS-memo and topo methods.}
\LINE{CROSS-CHECKS}{For small \(m,n \le 5\), compare results from Approach B and C on random seeds; they must match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate grids of constants, strictly increasing rows/columns, checkerboards, and random noise; ensure boundaries and no diagonal moves.}
\begin{minted}{python}
import random
from typing import List, Tuple
from collections import deque

# Deterministic generators for boundaries, degenerates, adversarials
def gen_constant(m: int, n: int, val: int) -> List[List[int]]:
    return [[val for _ in range(n)] for _ in range(m)]

def gen_ramp(m: int, n: int) -> List[List[int]]:
    # strictly increasing by row-major index
    return [[i*n + j for j in range(n)] for i in range(m)]

def gen_checker(m: int, n: int, a: int = 0, b: int = 1) -> List[List[int]]:
    return [[a if (i + j) % 2 == 0 else b for j in range(n)] for i in range(m)]

def gen_random(m: int, n: int, seed: int = 0, lo: int = 0, hi: int = 50) -> List[List[int]]:
    rnd = random.Random(seed)
    return [[rnd.randint(lo, hi) for _ in range(n)] for _ in range(m)]

# Reference Code (DFS + memo)
class SolutionRef:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        dp = [[0]*n for _ in range(m)]
        dirs: List[Tuple[int,int]] = [(1,0), (-1,0), (0,1), (0,-1)]
        def dfs(i: int, j: int) -> int:
            if dp[i][j] != 0: return dp[i][j]
            best = 1
            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:
                    best = max(best, 1 + dfs(ni, nj))
            dp[i][j] = best
            return best
        return max(dfs(i,j) for i in range(m) for j in range(n))

# Topological layering implementation (Approach C)
class SolutionTopo:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]: return 0
        m, n = len(matrix), len(matrix[0])
        dirs: List[Tuple[int,int]] = [(1,0), (-1,0), (0,1), (0,-1)]
        outdeg = [[0]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                for di, dj in dirs:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:
                        outdeg[i][j] += 1
        q = deque((i, j) for i in range(m) for j in range(n) if outdeg[i][j] == 0)
        layers = 0
        while q:
            layers += 1
            for _ in range(len(q)):
                i, j = q.popleft()
                for di, dj in dirs:
                    pi, pj = i + di, j + dj
                    if 0 <= pi < m and 0 <= pj < n and matrix[pi][pj] < matrix[i][j]:
                        outdeg[pi][pj] -= 1
                        if outdeg[pi][pj] == 0:
                            q.append((pi, pj))
        return layers

# Cross-checks
def cross_check():
    ref = SolutionRef()
    topo = SolutionTopo()
    # Deterministic cases
    cases = [
        gen_constant(1,1,5),
        gen_constant(3,3,7),
        gen_ramp(2,3),
        gen_checker(3,3,0,1),
        [[9,9,4],[6,6,8],[2,1,1]],
        [[3,4,5],[3,2,6],[2,2,1]],
    ]
    for idx, mat in enumerate(cases):
        a = ref.longestIncreasingPath(mat)
        b = topo.longestIncreasingPath(mat)
        assert a == b, (idx, a, b)

    # Random cases
    for seed in range(10):
        mat = gen_random(5, 5, seed=seed, lo=0, hi=20)
        a = ref.longestIncreasingPath(mat)
        b = topo.longestIncreasingPath(mat)
        assert a == b, ("seed", seed, a, b)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        # DFS + memoization (top-down DP)
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        dp = [[0]*n for _ in range(m)]
        dirs: List[Tuple[int,int]] = [(1,0), (-1,0), (0,1), (0,-1)]

        def dfs(i: int, j: int) -> int:
            if dp[i][j] != 0:
                return dp[i][j]
            best = 1
            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:
                    cand = 1 + dfs(ni, nj)
                    if cand > best:
                        best = cand
            dp[i][j] = best
            return best

        ans = 0
        for i in range(m):
            for j in range(n):
                v = dfs(i, j)
                if v > ans:
                    ans = v
        return ans

if __name__ == "__main__":
    sol = Solution()
    assert sol.longestIncreasingPath([[1]]) == 1
    assert sol.longestIncreasingPath([[9,9,4],[6,6,8],[2,1,1]]) == 4
    assert sol.longestIncreasingPath([[3,4,5],[3,2,6],[2,2,1]]) == 4
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute the longest strictly increasing path in a grid using DAG DP or topological layering.}
\WHY{A classic graph-on-grid problem testing modeling skill and choosing between DFS with memoization or BFS layering.}
\CHECKLIST{
\begin{bullets}
\item Build edges only to strictly larger neighbors.
\item Decide DP method: DFS memo or Kahn layering.
\item Implement transitions; cache or layer count.
\item Scan all cells; track global maximum if using DFS.
\item Validate on trivial and plateau cases.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item \(1 \times 1\) grid.
\item All cells equal \(\Rightarrow 1\).
\item Strictly increasing along a snake path.
\item Large flat regions with isolated peaks.
\item Non-square grids, e.g., \(1 \times n\) or \(m \times 1\).
\item Values near \(2^{31}-1\).
\item Multiple disjoint maxima with same length.
\item Grids with repeated values blocking movement.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using non-strict comparison (\(\ge\)) instead of \(>\).
\item Forgetting to bound-check indices.
\item Not memoizing DFS leading to exponential time.
\item Recursion limit issues on deep paths (rare for \(200 \times 200\), but iterative works too).
\item Miscomputing outdegrees for Kahn's algorithm.
\item Counting edges instead of nodes in path length.
\item Accidentally allowing diagonal moves.
\item Reusing a global cache across test runs without reset.
\end{bullets}}
\FAILMODES{Brute-force without memoization can time out on crafted grids with many increasing options; the DAG DP and topological BFS both run in \(O(mn)\) and handle these inputs efficiently.}
\ELI{Only step onto bigger numbers. If you remember the best you can do from each tile, you solve each tile once. Alternatively, peel off the grid layer by layer from the highest points; the number of peels is the answer.}
\NotePages{3}

\end{document}