% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Rainbow Triples}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1408/H}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{You are given a sequence $a_1, a_2, \ldots, a_n$ of non-negative integers.

You need to find the largest number $m$ of triples $(i_1, j_1, k_1)$, $(i_2, j_2, k_2)$, \ldots, $(i_m, j_m, k_m)$ such that:
\begin{bullets}
\item $1 \le i_p < j_p < k_p \le n$ for each $p$ in $1, 2, \ldots, m$;
\item $a_{i_p} = a_{k_p} = 0$, $a_{j_p} \ne 0$;
\item all $a_{j_1}, a_{j_2}, \ldots, a_{j_m}$ are different;
\item all $i_1, j_1, k_1, i_2, j_2, k_2, \ldots, i_m, j_m, k_m$ are different.
\end{bullets}

Input: The first line of input contains one integer $t$ ($1 \le t \le 500{,}000$): the number of test cases.

The first line of each test case contains one integer $n$ ($1 \le n \le 500{,}000$).

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le n$).

The total sum of $n$ is at most $500{,}000$.

Output: For each test case, print one integer $m$: the largest number of proper triples that you can find.

Note: In the first two test cases, there are not enough elements even for a single triple, so the answer is $0$. In the third test case we can select one triple $(1, 2, 3)$. In the fourth test case we can select two triples $(1, 3, 5)$ and $(2, 4, 6)$. In the fifth test case we can select one triple $(1, 2, 3)$. We cannot select two triples $(1, 2, 3)$ and $(4, 5, 6)$, because $a_2 = a_5$.}
\BREAKDOWN{We must maximize the count of disjoint triples with zeros at ends and distinct non-zero middle values. The core constraints are index disjointness, zero resources on both sides, and uniqueness of middle colors.}
\ELI{Use zeros as scarce resources: each triple consumes one left zero and one right zero around a middle index with a unique non-zero value; allocate these resources to maximize how many unique colors can be sandwiched.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: integer $n$ and an array of $n$ integers $a_i$ with $0 \le a_i \le n$. Sum of $n$ over all tests $\le 500{,}000$.}
\OUTPUTS{For each test case, output a single integer $m$: the maximum number of triples satisfying the constraints.}
\SAMPLES{Example thought experiments:
\begin{bullets}
\item $[1,1,1] \to 0$ (no zeros).
\item $[0,2,0] \to 1$ (triple $(1,2,3)$).
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $a\in\{0,1,\ldots,n\}^n$, choose a maximum-size set $T$ of triples $(i,j,k)$ with $i<j<k$, $a_i=a_k=0$, $a_j\ne 0$, indices pairwise disjoint across $T$, and middle values $a_j$ all distinct.}
\varmapStart
\var{Z}{set of indices with $a_i=0$; $|Z|=z$}
\var{V}{set of distinct non-zero values in $a$}
\var{T}{chosen set of triples, to be maximized}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{maximize}\quad & |T| \\
\text{subject to}\quad & (i,j,k)\in T \implies i<j<k,\ a_i=a_k=0,\ a_j\ne 0,\\
& (i,j,k),(i',j',k')\in T,\ (i,j,k)\ne (i',j',k') \implies \{i,j,k\}\cap\{i',j',k'\}=\varnothing,\\
& (i,j,k),(i',j',k')\in T \implies a_j \ne a_{j'}.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are 1-based; values in $[0,n]$. Zeros can be reused neither as left nor as right endpoints; each color value can be used at most once as a middle.}
\INVARIANTS{
\begin{bullets}
\item $|T| \le \lfloor z/2 \rfloor$ since each triple consumes two distinct zeros.
\item $|T| \le |V|$ due to distinct middle values.
\item Any feasible set $T$ can be reordered by increasing $j$ without changing feasibility.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{A coarse upper bound is $\min\big(\lfloor z/2\rfloor,\ \#\{\text{distinct non-zero values}\}\big)$. As a simple baseline, also require each chosen value has at least one zero to its left and one to its right.}
\ASSUMPTIONS{We ignore subtle resource conflicts among zeros and just cap by availability and basic sandwichability.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $z=$ number of zeros and set $V$ of distinct non-zero values.
\item Keep only values that appear at some index with a zero before and a zero after.
\item Return $\min\big(\lfloor z/2\rfloor,\ |V_{\text{sandwichable}}|\big)$.
\end{algosteps}
\COMPLEXITY{Linear scan with sets: $T(n)=O(n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n)\ \text{to count zeros and detect sandwichable values},\\
S(n) &= O(n)\ \text{for sets and counters}.
\end{aligned}
\]
\CORRECTNESS{This is an admissible upper bound that is exact for many simple layouts, but it can be pessimistic when resource conflicts are resolvable or optimistic when conflicts are tight; it serves as a baseline.}
\EDGECASES{All zeros or all non-zeros; zeros concentrated at one side; repeated values only.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def solve_case_baseline(a: List[int]) -> int:
    n = len(a)
    zeros = [i for i, x in enumerate(a) if x == 0]
    z = len(zeros)
    if z < 2:
        return 0
    pref0 = [0] * (n + 1)
    for i in range(n):
        pref0[i + 1] = pref0[i] + (1 if a[i] == 0 else 0)
    suf0 = [0] * (n + 2)
    for i in range(n - 1, -1, -1):
        suf0[i] = suf0[i + 1] + (1 if a[i] == 0 else 0)
    sandwichable = set()
    for i, x in enumerate(a):
        if x != 0 and pref0[i] >= 1 and suf0[i + 1] >= 1:
            sandwichable.add(x)
    return min(z // 2, len(sandwichable))

def read_input_tokens(data: List[str]) -> List[List[int]]:
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append(arr)
    return cases

def solve_all_baseline(tokens: List[str]) -> List[int]:
    cases = read_input_tokens(tokens)
    return [solve_case_baseline(a) for a in cases]

def main():
    data = sys.stdin.read().strip().split()
    if not data:
        # Self-checks
        assert solve_case_baseline([1,1,1]) == 0
        assert solve_case_baseline([0,2,0]) == 1
        assert solve_case_baseline([0,1,0,1,0]) == 1
        print("OK")
        return
    ans = solve_all_baseline(data)
    out = sys.stdout
    out.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Tiny checks included in main; additionally, $[0,0,1,1]\to 0$, $[0,1,0,2,0]\to 2$ under this baseline (upper bound).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy With Two-Sided Zero Pools}
\WHICHFORMULA{Process indices left-to-right, maintaining seen-left zeros and unseen-right zeros. Greedily assign the latest possible left zero and the earliest possible right zero to each new color.}
\ASSUMPTIONS{This heuristic often achieves the optimum but can fail in adversarial layouts when a near right zero would be more valuable later as a left zero.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pre-list all zero positions; maintain two structures: a stack of available left zeros and a queue of remaining right zeros.
\item Scan indices $i=1..n$. On zero, move it from right-queue to left-stack (unless already consumed).
\item On a new color and if both sides are non-empty, assign left: pop from left-stack; right: pop from right-queue; mark color used.
\end{algosteps}
\COMPLEXITY{Linear: each index and zero is processed once; $T(n)=O(n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Always valid (produces disjoint triples and distinct colors) and never exceeds $\lfloor z/2\rfloor$, but not always optimal due to myopic right-zero consumption.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque
from typing import List

def solve_case_greedy(a: List[int]) -> int:
    n = len(a)
    zeros = [i for i, x in enumerate(a) if x == 0]
    right = deque(zeros)  # available future zeros
    left = []             # seen but unused zeros
    used = set()
    ans = 0
    for i, x in enumerate(a):
        if x == 0:
            # Move current zero from right to left if still present
            if right and right[0] == i:
                right.popleft()
            # This zero is now available on the left if not already consumed
            left.append(i)
        else:
            if x in used:
                continue
            # Ensure right deque discards any zeros <= i (shouldn't happen if maintained)
            while right and right[0] <= i:
                # Defensive, though logic avoids this
                right.popleft()
            if left and right:
                used.add(x)
                left.pop()      # use latest left zero
                right.popleft() # use earliest right zero > i
                ans += 1
    return ans

def read_input_tokens(data: List[str]) -> List[List[int]]:
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append(arr)
    return cases

def solve_all_greedy(tokens: List[str]) -> List[int]:
    cases = read_input_tokens(tokens)
    return [solve_case_greedy(a) for a in cases]

def main():
    data = sys.stdin.read().strip().split()
    if not data:
        # Self-checks (heuristic correctness on simple cases)
        assert solve_case_greedy([0,2,0]) == 1
        assert solve_case_greedy([1,1,1]) == 0
        assert solve_case_greedy([0,1,0,2,0]) in (2, 1)
        # Counterexample where greedy is suboptimal:
        # [0,1,0,2,0,3,0] optimum is 2, greedy may get 1 or 2 depending on tie-handling.
        print("OK")
        return
    ans = solve_all_greedy(data)
    out = sys.stdout
    out.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Includes sanity asserts. Note: This greedy is safe but can be suboptimal; see Review \& Pitfalls.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Binary Search on Triples with Feasibility Check via Reserved Right Zeros}
\WHICHFORMULA{Fix $t$ and reserve the last $t$ zeros as right endpoints. Then greedily select up to $t$ distinct colors at positions strictly before the first reserved-right zero, ensuring at time of selecting the $(r{+}1)$-st color we have seen at least $r{+}1$ non-reserved zeros (to serve as left endpoints). Binary search the maximum feasible $t$.}
\ASSUMPTIONS{Feasibility monotonicity in $t$: if $t$ is feasible, then any $t' \le t$ is feasible by discarding triples.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $Z$ be the sorted zero positions, $z=|Z|$. If $2t>z$, $t$ infeasible.
\item Reserve the last $t$ zeros: $Z_R = \{Z[z-t],\ldots,Z[z-1]\}$ and set cutoff $c=Z[z-t]$.
\item Scan $i=1..n$:
\begin{bullets}
\item Maintain $h =$ number of non-reserved zeros seen so far (i.e., zeros in $\{Z[0],\ldots,Z[z-t-1]\}$ with position $<i$).
\item On a non-zero $a_i$ with $i<c$ and a new color, if current selected $r<t$ and $h>r$, select it ($r\leftarrow r+1$).
\end{bullets}
\item $t$ is feasible iff we can reach $r=t$. Binary search $t\in[0,\min(\lfloor z/2\rfloor,\ |V|)]$.
\end{algosteps}
\OPTIMALITY{By exchange: any solution with $t$ triples can shift all right endpoints to the last $t$ zeros without harming feasibility and without violating distinctness. With this reservation, any chosen middle must lie before the earliest reserved-right zero; the greedy left-allocation condition $h>r$ is necessary and sufficient. Monotonicity yields an $O(n\log n)$ optimization via binary search.}
\COMPLEXITY{$T(n)=O(n\log n)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n)\ \text{per feasibility check} \times O(\log n)\ \text{for binary search},\\
S(n) &= O(n)\ \text{to store zeros and used-color flags}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List

def can_make(a: List[int], t: int) -> bool:
    n = len(a)
    zeros = [i for i, x in enumerate(a) if x == 0]
    z = len(zeros)
    if t == 0:
        return True
    if 2 * t > z:
        return False
    cutoff = zeros[z - t]  # first reserved-right zero position
    # Greedily pick up to t distinct colors before cutoff
    used = set()
    r = 0      # selected middles so far
    have = 0   # non-reserved zeros seen so far
    non_reserved_set = set(zeros[:z - t])
    for i, x in enumerate(a):
        if i >= cutoff:
            # no more middles allowed; we can still count zeros but it won't affect selection
            if x == 0 and i in non_reserved_set:
                # this non-reserved zero is not before cutoff; doesn't help as left for middles < cutoff
                pass
            continue
        if x == 0:
            if i in non_reserved_set:
                have += 1
        else:
            if x in used:
                continue
            if r < t and have > r:
                used.add(x)
                r += 1
                if r == t:
                    return True
    return r == t

def solve_case_optimal(a: List[int]) -> int:
    zeros = sum(1 for x in a if x == 0)
    distinct_vals = len({x for x in a if x != 0})
    hi = min(zeros // 2, distinct_vals)
    lo = 0
    # Binary search maximum feasible t
    while lo < hi:
        mid = (lo + hi + 1) // 2
        if can_make(a, mid):
            lo = mid
        else:
            hi = mid - 1
    return lo

def read_input_tokens(data: List[str]) -> List[List[int]]:
    it = iter(data)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append(arr)
    return cases

def solve_all(tokens: List[str]) -> List[int]:
    cases = read_input_tokens(tokens)
    return [solve_case_optimal(a) for a in cases]

def main():
    data = sys.stdin.read().split()
    if not data:
        # Exactly 3 asserts
        assert solve_case_optimal([1,1,1]) == 0
        assert solve_case_optimal([0,2,0]) == 1
        assert solve_case_optimal([0,1,0,2,0,3,0]) == 2
        print("OK")
        return
    ans = solve_all(data)
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts:
\begin{bullets}
\item $[1,1,1]\to 0$.
\item $[0,2,0]\to 1$.
\item $[0,1,0,2,0,3,0]\to 2$ (demonstrates non-trivial planning).
\end{bullets}}
\RESULT{Outputs the maximum number of disjoint triples meeting all constraints, using an $O(n\log n)$ algorithm.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on degenerate arrays (no zeros, all zeros), alternating zeros and values, clustered zeros, repeated colors, and adversarial placements. Property: answer $\le \min(\lfloor z/2\rfloor, |V|)$.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Optimal on random small arrays; Baseline provides an upper bound or a near value; Optimal should be $\le$ Baseline and satisfy all constraints.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with zeros only on one side; interleave zeros every other position; repeat a single color many times; mix many distinct colors sparsely.}
\begin{minted}{python}
import random

def gen_case(n: int, maxv: int, p_zero: float) -> list:
    a = []
    for _ in range(n):
        if random.random() < p_zero:
            a.append(0)
        else:
            a.append(random.randint(1, maxv))
    return a

def brute_upper(a: list) -> int:
    z = sum(1 for x in a if x == 0)
    distinct_vals = len({x for x in a if x != 0})
    return min(z // 2, distinct_vals)

def randomized_sanity():
    from collections import Counter
    for _ in range(200):
        n = random.randint(1, 40)
        a = gen_case(n, maxv=min(10, n), p_zero=random.random())
        ub = brute_upper(a)
        opt = solve_case_optimal(a)
        assert 0 <= opt <= ub
    # Hand-crafted
    assert solve_case_optimal([0,1,0,2,0,3,0]) == 2
    assert solve_case_optimal([0,0,0]) == 0
    assert solve_case_optimal([0,1,1,0,2,2,0,3,3,0]) >= 2

if __name__ == "__main__":
    randomized_sanity()
    print("Randomized sanity OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import List

def can_make(a: List[int], t: int) -> bool:
    zeros = [i for i, x in enumerate(a) if x == 0]
    z = len(zeros)
    if t == 0:
        return True
    if 2 * t > z:
        return False
    cutoff = zeros[z - t]  # earliest reserved right-zero position
    non_reserved = set(zeros[:z - t])
    used = set()
    have = 0  # count of non-reserved zeros seen so far (left capacity)
    r = 0     # selected middles
    for i, x in enumerate(a):
        if i >= cutoff:
            continue
        if x == 0:
            if i in non_reserved:
                have += 1
        else:
            if x in used:
                continue
            if r < t and have > r:
                used.add(x)
                r += 1
                if r == t:
                    return True
    return r == t

def solve_case(a: List[int]) -> int:
    z = sum(1 for x in a if x == 0)
    distinct_vals = len({x for x in a if x != 0})
    hi = min(z // 2, distinct_vals)
    lo = 0
    while lo < hi:
        mid = (lo + hi + 1) // 2
        if can_make(a, mid):
            lo = mid
        else:
            hi = mid - 1
    return lo

def read_input(tokens: List[str]) -> List[List[int]]:
    it = iter(tokens)
    t = int(next(it))
    cases = []
    for _ in range(t):
        n = int(next(it))
        arr = [int(next(it)) for _ in range(n)]
        cases.append(arr)
    return cases

def solve_all(tokens: List[str]) -> List[int]:
    cases = read_input(tokens)
    return [solve_case(a) for a in cases]

def main():
    data = sys.stdin.read().split()
    if not data:
        # Simple deterministic tests
        assert solve_case([1,1,1]) == 0
        assert solve_case([0,2,0]) == 1
        assert solve_case([0,1,0,2,0,3,0]) == 2
        print("OK")
        return
    ans = solve_all(data)
    sys.stdout.write("\n".join(map(str, ans)))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize disjoint triples by allocating two zeros (left/right) per chosen unique middle color.}
\WHY{This tests multi-constraint greedy design, exchange arguments, and feasibility checking with binary search under tight resource coupling.}
\CHECKLIST{
\begin{bullets}
\item Count zero positions and distinct non-zero values.
\item Binary search on $t$ up to $\min(\lfloor z/2\rfloor, |V|)$.
\item For a fixed $t$, reserve the last $t$ zeros as right endpoints.
\item Greedily select distinct colors before cutoff with left-capacity check $h>r$.
\item Return the maximum feasible $t$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item No zeros or only one zero $\Rightarrow 0$.
\item Zeros all on one side of all non-zeros $\Rightarrow 0$.
\item Repeated single color everywhere $\Rightarrow \le 1$.
\item Dense zeros with sparse colors.
\item Colors appearing only outside the usable window.
\item Arrays where naive left/right greedy fails but reservation method succeeds.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one at the cutoff zero index.
\item Accidentally counting reserved-right zeros as left capacity.
\item Forgetting color uniqueness across the entire selection.
\item Miscomputing feasibility when $t=0$ or $2t>z$.
\item Using 1-based vs 0-based indices inconsistently.
\item Overrunning binary search bounds without monotonicity.
\end{bullets}}
\FAILMODES{The two-pool greedy can consume an early right zero that would be more valuable later as a left zero, losing optimality. The reservation-based feasibility avoids this by fixing all right endpoints to the tail zeros.}
\ELI{Think of putting aside the last $t$ zeros as your right brackets. Now walk from the left and every time you see a new color before the first reserved right bracket, use it only if you have more left brackets than colors used so far. The biggest $t$ for which this is possible is the answer.}
\NotePages{3}

\end{document}