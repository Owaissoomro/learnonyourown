% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Nastya and Unexpected Guest}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1340/C}}
\LINE{DIFFICULTY / RATING}{2400}
\STATEMENT{If the girl does not go to Denis, then Denis will go to the girl. Using this rule, the young man left home, bought flowers and went to Nastya.

On the way from Denis's house to the girl's house is a road of $n$ lines. This road can not be always crossed in one green light. Foreseeing this, the good mayor decided to place safety islands in some parts of the road. Each safety island is located after a line, as well as at the beginning and at the end of the road. Pedestrians can relax on them, gain strength and wait for a green light.

Denis came to the edge of the road exactly at the moment when the green light turned on. The boy knows that the traffic light first lights up $g$ seconds green, and then $r$ seconds red, then again $g$ seconds green and so on.

Formally, the road can be represented as a segment $[0, n]$. Initially, Denis is at point $0$. His task is to get to point $n$ in the shortest possible time.

He knows many different integers $d_1, d_2, \ldots, d_m$, where $0 \le d_i \le n$ — are the coordinates of points, in which the safety islands are located. Only at one of these points, the boy can be at a time when the red light is on.

Unfortunately, Denis is not always able to control himself because of the excitement, so some restrictions are imposed:
\begin{itemize}
\item He must always move while the green light is on because it is difficult to stand when so beautiful girl is waiting for you. Denis can change his position by $\pm 1$ in $1$ second. While doing so, he must always stay inside the segment $[0, n]$.
\item He can change his direction only on the safety islands (because it is safe). This means that if in the previous second the boy changed his position by $+1$ and he walked on a safety island, then he can change his position by $\pm 1$. Otherwise, he can change his position only by $+1$. Similarly, if in the previous second he changed his position by $-1$, on a safety island he can change position by $\pm 1$, and at any other point by $-1$.
\item At the moment when the red light is on, the boy must be on one of the safety islands. He can continue moving in any direction when the green light is on.
\end{itemize}

Denis has crossed the road as soon as his coordinate becomes equal to $n$.

This task was not so simple, because it is possible that it is impossible to cross the road. Since Denis has all thoughts about his love, he could not solve this problem and asked us to help him. Find the minimal possible time for which he can cross the road according to these rules, or find that it is impossible to do.

Input:
The first line contains two integers $n$ and $m$ $(1 \le n \le 10^6, 2 \le m \le \min(n + 1, 10^4))$ — road width and the number of safety islands.

The second line contains $m$ distinct integers $d_1, d_2, \ldots, d_m$ $(0 \le d_i \le n)$ — the points where the safety islands are located. It is guaranteed that there are $0$ and $n$ among them.

The third line contains two integers $g, r$ $(1 \le g, r \le 1000)$ — the time that the green light stays on and the time that the red light stays on.

Output:
Output a single integer — the minimum time for which Denis can cross the road with obeying all the rules.

If it is impossible to cross the road output $-1$.

Note:
In the first test, the optimal route is:
\begin{itemize}
\item for the first green light, go to $7$ and return to $3$. In this case, we will change the direction of movement at the point $7$, which is allowed, since there is a safety island at this point. In the end, we will be at the point of $3$, where there is also a safety island. The next $11$ seconds we have to wait for the red light.
\item for the second green light reaches $14$. Wait for the red light again.
\item for $1$ second go to $15$. As a result, Denis is at the end of the road.
\end{itemize}
In total, $45$ seconds are obtained.

In the second test, it is impossible to cross the road according to all the rules.}
\BREAKDOWN{Sort the safety islands, then model green phases as transitions between islands if one can traverse a total distance at most $g$ while continuously moving and turning only on islands. Minimize the number of red cycles waited and account for the final partial green to reach $n$.}
\ELI{Think of hopping from island to island each green period, up to distance $g$ per hop; each hop costs one red wait, except the last one when you finish.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case:
\begin{itemize}
\item Integers $n, m$ with $1 \le n \le 10^6$, $2 \le m \le \min(n+1, 10^4)$.
\item Array $d$ of $m$ distinct integers with $0 \le d_i \le n$, containing $0$ and $n$.
\item Integers $g, r$ with $1 \le g, r \le 1000$.
\end{itemize}}
\OUTPUTS{A single integer: minimal time to reach $n$ obeying the rules, or $-1$ if impossible.}
\SAMPLES{Example 1:
\begin{itemize}
\item Input:
\begin{itemize}
\item $n=15$, $m=6$
\item $d=[0, 3, 7, 10, 14, 15]$
\item $g=11$, $r=11$
\end{itemize}
\item Output: $45$
\end{itemize}
Example 2:
\begin{itemize}
\item Input:
\begin{itemize}
\item $n=10$, $m=3$
\item $d=[0, 6, 10]$
\item $g=5$, $r=5$
\end{itemize}
\item Output: $-1$
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the safety islands be sorted coordinates $0=d_0<d_1<\cdots<d_{m-1}=n$. From an island $i$ at the beginning of a green phase, Denis can continuously move along the line, turning only at islands, for at most $g$ seconds, and must be on some island when red starts. We build an unweighted graph on indices $\{0,\ldots,m-1\}$ with an edge from $i$ to any $j$ such that $|d_j-d_i|\le g$. Each edge corresponds to one full green phase followed by a red wait. Reaching $n$ within a green phase from island $i$ when $n-d_i\le g$ ends immediately without waiting an extra red. We seek the minimum total time.}
\varmapStart
\var{n}{road length}
\var{m}{number of safety islands}
\var{d_i}{sorted island coordinates}
\var{g}{green duration}
\var{r}{red duration}
\var{\text{dist}[i]}{minimum number of red periods needed to be ready to start a green at island $i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let } \text{adj}(i)=\{\, j \mid |d_j-d_i|\le g \,\}. \\
&\text{dist}[0]=0,\quad \text{dist}[j]=\min_{i\in \text{adj}(j)} \text{dist}[i]+1. \\
&\text{Answer }= \min_{i:\,n-d_i\le g} \bigl(\text{dist}[i]\cdot(g+r) + (n-d_i)\bigr).
\end{aligned}
\]
}
\ASSUMPTIONS{Islands include $0$ and $n$; coordinates are integers; movement speed is $1$; during green one must always move; turns are allowed only at island positions; during red Denis is stationary on an island.}
\INVARIANTS{
\begin{itemize}
\item Distances along the line between islands are $d_{i+1}-d_i\ge 1$.
\item BFS over indices using the $\le g$ reach set explores each island at most once.
\item Final phase time is at most $g$ and adds no red wait.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use BFS on the island graph: from island $i$, try every other island $j$ and connect if $|d_j-d_i|\le g$. This builds the minimal number of red periods to reach each island at the boundary between greens.}
\ASSUMPTIONS{Naively scanning all $m$ islands for each popped node is acceptable only as a baseline ($O(m^2)$).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort the island coordinates and find the index of $0$.
\item BFS starting from index $0$; for each popped index $i$, scan all indices $j$ and enqueue any unvisited with $|d_j-d_i|\le g$, setting $\text{dist}[j]=\text{dist}[i]+1$.
\item Track the minimal total time for any $i$ with $n-d_i\le g$ as $\text{dist}[i]\cdot(g+r)+(n-d_i)$.
\end{algosteps}
\COMPLEXITY{Let $m$ be the number of islands.}
\[
\begin{aligned}
T(m) &= O(m^2) \text{ in the worst case due to full scans per BFS pop},\\
S(m) &= O(m) \text{ for queues and distance arrays}.
\end{aligned}
\]
\CORRECTNESS{BFS on this unweighted graph yields the minimum number of red phases to position Denis at islands at green boundaries. Adding the last partial green to $n$ yields the minimal total time.}
\EDGECASES{Direct reach in the first green ($n-d_0\le g$); impossible case when no island beyond $0$ is reachable; multiple islands at the same minimal red count.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 1340C — Nastya and Unexpected Guest (Baseline O(m^2) BFS)
# Includes: read_input(), solve_case(), solve_all(), main()+guard, and asserts.

from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read().decode()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    m = int(next(it))
    d = [int(next(it)) for _ in range(m)]
    g = int(next(it)); r = int(next(it))
    return n, m, d, g, r

def solve_case(inp):
    n, m, d, g, r = inp
    d.sort()
    idx0 = d.index(0)
    # BFS distances in number of reds
    INF = 10**18
    dist = [INF]*m
    dist[idx0] = 0
    q = deque([idx0])
    ans = INF
    # If can finish directly
    if n - d[idx0] <= g:
        ans = min(ans, (n - d[idx0]))
    # BFS
    while q:
        i = q.popleft()
        # Try all j (baseline O(m))
        for j in range(m):
            if dist[j] != INF:
                continue
            if abs(d[j] - d[i]) <= g:
                dist[j] = dist[i] + 1
                q.append(j)
                # Check finish from j
                if n - d[j] <= g:
                    cand = dist[j]*(g + r) + (n - d[j])
                    if cand < ans:
                        ans = cand
    return -1 if ans == INF else ans

def solve_all(data):
    parsed = read_input(data)
    if parsed is None:
        return ""
    return str(solve_case(parsed)) + "\n"

def _run_tests():
    # Test 1: Direct finish
    data = "8 4\n0 3 5 8\n9 7\n"
    assert solve_all(data).strip() == "8"
    # Test 2: Example-style (45)
    data = "15 6\n0 3 7 10 14 15\n11 11\n"
    assert solve_all(data).strip() == "45"
    # Test 3: Impossible
    data = "10 3\n0 6 10\n5 5\n"
    assert solve_all(data).strip() == "-1"

if __name__ == "__main__":
    data = sys.stdin.buffer.read()
    if data.strip():
        sys.stdout.write(solve_all(data.decode()))
    else:
        _run_tests()
        print("OK")
\end{minted}
\VALIDATION{Three asserts included: direct finish, a multi-hop case yielding $45$, and an impossible case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Expansion via Ordered Linked Set}
\WHICHFORMULA{From island $i$, the set of islands reachable within one green phase is a contiguous index interval in the sorted array: all $j$ with $|d_j-d_i|\le g$. Instead of scanning all $m$ each time, maintain a doubly linked list of unvisited indices and remove neighbors as we visit them.}
\ASSUMPTIONS{Indices correspond to sorted coordinates; each index is removed at most once, yielding near-linear total scans.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $d$ and locate the index of $0$.
\item Build arrays $\text{prev}[i]=i-1$ and $\text{next}[i]=i+1$ as a linked list of unvisited nodes.
\item BFS from $0$; for each popped $i$, sweep right: $j=\text{next}[i]$ while $j\neq -1$ and $d[j]-d[i]\le g$, enqueue $j$ and remove it from the list, continuing with the next right. Similarly sweep left from $i$ using $\text{prev}$.
\item Update the best answer whenever $n-d[j]\le g$.
\end{algosteps}
\COMPLEXITY{Total each index is removed once; sweeps pass over each removed neighbor once.}
\[
\begin{aligned}
T(m) &= O(m) \text{ sweeps } + O(m) \text{ BFS } = O(m),\\
S(m) &= O(m).
\end{aligned}
\]
\CORRECTNESS{Every reachable island within one green phase from $i$ lies in the contiguous interval bounded by $d[i]-g$ and $d[i]+g$. Removing as we visit prevents reconsideration and preserves BFS levels (number of reds).}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF 1340C — Improved BFS with doubly linked list of unvisited indices.

from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read().decode()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    m = int(next(it))
    d = [int(next(it)) for _ in range(m)]
    g = int(next(it)); r = int(next(it))
    return n, m, d, g, r

def solve_case(inp):
    n, m, d, g, r = inp
    d.sort()
    idx0 = d.index(0)
    INF = 10**18
    dist = [-1]*m
    # Doubly linked list of unvisited indices
    prev = [i-1 for i in range(m)]
    nxt = [i+1 for i in range(m)]
    prev[0] = -1
    nxt[m-1] = -1
    alive = [True]*m

    def remove(i):
        # Remove i from the linked list if alive
        if not alive[i]:
            return
        L, R = prev[i], nxt[i]
        if L != -1:
            nxt[L] = R
        if R != -1:
            prev[R] = L
        alive[i] = False

    q = deque()
    dist[idx0] = 0
    q.append(idx0)
    remove(idx0)

    ans = 10**18
    if n - d[idx0] <= g:
        ans = min(ans, n - d[idx0])

    while q:
        i = q.popleft()
        # Sweep right
        j = nxt[i]
        while j != -1 and d[j] - d[i] <= g:
            jj = nxt[j]
            dist[j] = dist[i] + 1
            q.append(j)
            remove(j)
            if n - d[j] <= g:
                cand = dist[j]*(g + r) + (n - d[j])
                if cand < ans:
                    ans = cand
            j = jj
        # Sweep left
        j = prev[i]
        while j != -1 and d[i] - d[j] <= g:
            jj = prev[j]
            dist[j] = dist[i] + 1
            q.append(j)
            remove(j)
            if n - d[j] <= g:
                cand = dist[j]*(g + r) + (n - d[j])
                if cand < ans:
                    ans = cand
            j = jj

    return -1 if ans == 10**18 else ans

def solve_all(data):
    parsed = read_input(data)
    if parsed is None:
        return ""
    return str(solve_case(parsed)) + "\n"

def _run_tests():
    # Direct finish
    data = "8 4\n0 3 5 8\n9 7\n"
    assert solve_all(data).strip() == "8"
    # Multi-hop 45
    data = "15 6\n0 3 7 10 14 15\n11 11\n"
    assert solve_all(data).strip() == "45"
    # Impossible
    data = "10 3\n0 6 10\n5 5\n"
    assert solve_all(data).strip() == "-1"

if __name__ == "__main__":
    data = sys.stdin.buffer.read()
    if data.strip():
        sys.stdout.write(solve_all(data.decode()))
    else:
        _run_tests()
        print("OK")
\end{minted}
\VALIDATION{Same three asserts as baseline, now with the optimized approach.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{BFS with Interval Expansion and Final Partial Green}
\WHICHFORMULA{Perform BFS over islands; from $i$ expand to all indices $j$ with $|d_j-d_i|\le g$ using a deletable ordered list, computing the minimal number of red waits. The final step adds the time to $n$ if $n-d_i\le g$.}
\ASSUMPTIONS{Coordinates are integers; $m\le 10^4$, $g,r\le 1000$; the linked-list sweep removes each index once, yielding $O(m)$ expansion beyond sorting.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort islands and build a doubly linked list over indices $0..m-1$.
\item Initialize BFS at index of $0$, remove it from the list.
\item For each popped $i$, sweep right and left while $|d_j-d_i|\le g$, enqueueing and removing each $j$.
\item Track candidate answers for any $j$ with $n-d_j\le g$ as $\text{dist}[j]\cdot(g+r)+(n-d_j)$.
\item Return the minimum candidate, or $-1$ if none.
\end{algosteps}
\OPTIMALITY{BFS guarantees minimal red waits. Among states with equal red waits, taking the smallest remaining distance yields the minimal total time because the final segment contributes directly and no extra red is added. The linked list ensures each island is considered at most once, making it asymptotically optimal for this graph.}
\COMPLEXITY{Sorting dominates.}
\[
\begin{aligned}
T(m) &= O(m\log m) \text{ (sort)} + O(m) \text{ (BFS expansions)},\\
S(m) &= O(m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF 1340C — Final Reference Implementation (optimized BFS with linked list)

from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read().decode()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    m = int(next(it))
    d = [int(next(it)) for _ in range(m)]
    g = int(next(it)); r = int(next(it))
    return n, m, d, g, r

def solve_case(inp):
    n, m, d, g, r = inp
    d.sort()
    idx0 = d.index(0)
    INF = 10**18
    dist = [-1]*m

    prev = [i-1 for i in range(m)]
    nxt = [i+1 for i in range(m)]
    prev[0] = -1
    nxt[m-1] = -1
    alive = [True]*m

    def remove(i):
        if not alive[i]:
            return
        L, R = prev[i], nxt[i]
        if L != -1:
            nxt[L] = R
        if R != -1:
            prev[R] = L
        alive[i] = False

    q = deque([idx0])
    dist[idx0] = 0
    remove(idx0)

    ans = INF
    if n - d[idx0] <= g:
        ans = min(ans, n - d[idx0])

    while q:
        i = q.popleft()
        # Right sweep
        j = nxt[i]
        while j != -1 and d[j] - d[i] <= g:
            jj = nxt[j]
            dist[j] = dist[i] + 1
            q.append(j)
            remove(j)
            if n - d[j] <= g:
                cand = dist[j]*(g + r) + (n - d[j])
                if cand < ans:
                    ans = cand
            j = jj
        # Left sweep
        j = prev[i]
        while j != -1 and d[i] - d[j] <= g:
            jj = prev[j]
            dist[j] = dist[i] + 1
            q.append(j)
            remove(j)
            if n - d[j] <= g:
                cand = dist[j]*(g + r) + (n - d[j])
                if cand < ans:
                    ans = cand
            j = jj

    return -1 if ans == INF else ans

def solve_all(data):
    parsed = read_input(data)
    if parsed is None:
        return ""
    return str(solve_case(parsed)) + "\n"

def _run_tests():
    # 1) Direct finish in first green
    data = "8 4\n0 3 5 8\n9 7\n"
    assert solve_all(data).strip() == "8"
    # 2) Multi-hop case (matches described 45s route)
    data = "15 6\n0 3 7 10 14 15\n11 11\n"
    assert solve_all(data).strip() == "45"
    # 3) Impossible to progress
    data = "10 3\n0 6 10\n5 5\n"
    assert solve_all(data).strip() == "-1"

if __name__ == "__main__":
    data = sys.stdin.buffer.read()
    if data.strip():
        sys.stdout.write(solve_all(data.decode()))
    else:
        _run_tests()
        print("OK")
\end{minted}
\VALIDATION{Exactly three asserts: direct finish, multi-hop with answer $45$, and an impossible case.}
\RESULT{Minimum time equals the number of full cycles $(g+r)$ multiplied by the minimal red waits to reach a suitable island, plus the final remaining distance to $n$ within one last green; if no such path exists, return $-1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: direct finish within first green; multi-hop requiring waits between greens; impossible case with no progress.}
\LINE{CROSS-CHECKS}{Compare outputs from Baseline (A), Improved (B), and Final (C) on small crafted cases to ensure consistency.}
\LINE{EDGE-CASE GENERATOR}{Generate small random instances with $m\le 8$, random $d$ including $0,n$, random $g,r\le 5$ and cross-check the three solvers.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random
from collections import deque

def brute_force_time(n, d, g, r):
    # Very small n brute (state: position, dir, t mod (g+r), on_island_only_during_red)
    # For testing tiny instances only; returns minimal time or None.
    mset = set(d)
    period = g + r
    # State: (pos, dir, t_mod, phase), dir in {-1, +1}, phase 0=green,1=red
    # Start: at 0, green, t_mod=0; we must move immediately.
    from heapq import heappush, heappop
    INF = 10**9
    dist = {}
    pq = []
    # Try both initial directions if possible
    for dir0 in (+1, -1):
        if 0 <= 0 + dir0 <= n:
            heappush(pq, (0, 0, dir0, 0, 0))  # time, pos, dir, t_mod, phase
            dist[(0, dir0, 0, 0)] = 0
    best = INF
    while pq:
        t, x, dx, tm, ph = pq[0]
        heappop(pq)
        if x == n:
            best = t
            break
        # Advance one second
        nt = t + 1
        ntm = (tm + 1) % period
        nph = ph
        if ph == 0 and ntm == g % period:
            nph = 1  # red starts
        if ph == 1 and ntm == 0:
            nph = 0  # green starts
        # During red, must be on island and cannot move
        if ph == 1:
            if x not in mset:
                continue
            key = (x, dx, ntm, nph)
            if dist.get(key, 10**9) > nt:
                dist[key] = nt
                heappush(pq, (nt, x, dx, ntm, nph))
            continue
        # ph == 0 (green): must move; can change direction only on islands
        cand_dirs = [dx]
        if x in mset:
            cand_dirs = [-1, 1]
        for ndx in cand_dirs:
            nx = x + ndx
            if 0 <= nx <= n:
                key = (nx, ndx, ntm, nph)
                if dist.get(key, 10**9) > nt:
                    dist[key] = nt
                    heappush(pq, (nt, nx, ndx, ntm, nph))
    return None if best == INF else best

def generator_small():
    random.seed(0)
    for n in range(4, 9):
        for _ in range(50):
            m = random.randint(2, min(n+1, 8))
            pts = sorted(set([0, n] + random.sample(range(1, n), m-2)))
            g = random.randint(1, 5)
            r = random.randint(1, 5)
            yield n, pts, g, r

def test_cross_check():
    from collections import deque
    # Final solver reused here
    def solve(n, d, g, r):
        data = f"{n} {len(d)}\n" + " ".join(map(str, d)) + f"\n{g} {r}\n"
        from io import StringIO
        return int(__import__("sys").modules[__name__ + "_final"].solve_all(data).strip())
    # Load final solver into a separate module-like namespace
    import types
    mod = types.SimpleNamespace()
    code = r'''
from collections import deque
def solve_all(data):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    d = [int(next(it)) for _ in range(m)]
    g = int(next(it)); r = int(next(it))
    d.sort()
    idx0 = d.index(0)
    INF = 10**18
    dist = [-1]*m
    prev = [i-1 for i in range(m)]
    nxt = [i+1 for i in range(m)]
    prev[0] = -1
    nxt[m-1] = -1
    alive = [True]*m
    def remove(i):
        if not alive[i]: return
        L, R = prev[i], nxt[i]
        if L != -1: nxt[L] = R
        if R != -1: prev[R] = L
        alive[i] = False
    q = deque([idx0]); dist[idx0]=0; remove(idx0)
    ans = 10**18
    if n - d[idx0] <= g: ans = min(ans, n - d[idx0])
    while q:
        i = q.popleft()
        j = nxt[i]
        while j != -1 and d[j] - d[i] <= g:
            jj = nxt[j]
            dist[j] = dist[i] + 1
            q.append(j); remove(j)
            if n - d[j] <= g:
                cand = dist[j]*(g+r) + (n - d[j])
                if cand < ans: ans = cand
            j = jj
        j = prev[i]
        while j != -1 and d[i] - d[j] <= g:
            jj = prev[j]
            dist[j] = dist[i] + 1
            q.append(j); remove(j)
            if n - d[j] <= g:
                cand = dist[j]*(g+r) + (n - d[j])
                if cand < ans: ans = cand
            j = jj
    return str(-1 if ans==10**18 else ans)
'''
    mod_name = __name__ + "_final"
    import sys as _sys
    _sys.modules[mod_name] = mod
    exec(code, _sys.modules[mod_name].__dict__)
    # Cross-check on tiny instances with brute-force simulator
    for n, pts, g, r in generator_small():
        bf = brute_force_time(n, pts, g, r)
        # Build input for final solver
        data = f"{n} {len(pts)}\n" + " ".join(map(str, pts)) + f"\n{g} {r}\n"
        out = int(_sys.modules[mod_name].solve_all(data))
        if bf is None:
            assert out == -1
        else:
            assert out == bf

if __name__ == "__main__":
    test_cross_check()
    print("CROSS-CHECK OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final ready-to-submit solution (same as Approach C), with I/O and asserts.

from collections import deque
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read().decode()
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    m = int(next(it))
    d = [int(next(it)) for _ in range(m)]
    g = int(next(it)); r = int(next(it))
    return n, m, d, g, r

def solve_case(inp):
    n, m, d, g, r = inp
    d.sort()
    idx0 = d.index(0)
    INF = 10**18
    dist = [-1]*m
    prev = [i-1 for i in range(m)]
    nxt = [i+1 for i in range(m)]
    prev[0] = -1
    nxt[m-1] = -1
    alive = [True]*m
    def remove(i):
        if not alive[i]: return
        L, R = prev[i], nxt[i]
        if L != -1: nxt[L] = R
        if R != -1: prev[R] = L
        alive[i] = False
    q = deque([idx0]); dist[idx0]=0; remove(idx0)
    ans = INF
    if n - d[idx0] <= g:
        ans = min(ans, n - d[idx0])
    while q:
        i = q.popleft()
        j = nxt[i]
        while j != -1 and d[j] - d[i] <= g:
            jj = nxt[j]
            dist[j] = dist[i] + 1
            q.append(j); remove(j)
            if n - d[j] <= g:
                cand = dist[j]*(g + r) + (n - d[j])
                if cand < ans: ans = cand
            j = jj
        j = prev[i]
        while j != -1 and d[i] - d[j] <= g:
            jj = prev[j]
            dist[j] = dist[i] + 1
            q.append(j); remove(j)
            if n - d[j] <= g:
                cand = dist[j]*(g + r) + (n - d[j])
                if cand < ans: ans = cand
            j = jj
    return -1 if ans == INF else ans

def solve_all(data):
    parsed = read_input(data)
    if parsed is None:
        return ""
    return str(solve_case(parsed)) + "\n"

def _run_tests():
    # Direct finish
    data = "8 4\n0 3 5 8\n9 7\n"
    assert solve_all(data).strip() == "8"
    # Multi-hop 45
    data = "15 6\n0 3 7 10 14 15\n11 11\n"
    assert solve_all(data).strip() == "45"
    # Impossible
    data = "10 3\n0 6 10\n5 5\n"
    assert solve_all(data).strip() == "-1"

if __name__ == "__main__":
    data = sys.stdin.buffer.read()
    if data.strip():
        sys.stdout.write(solve_all(data.decode()))
    else:
        _run_tests()
        print("OK")
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{BFS over islands with per-node expansion to all islands within distance $g$, counting red waits, then add the final partial green to finish.}
\WHY{Classic CF problem mixing time windows with movement constraints; tests ability to reduce to graph search and implement efficient neighbor enumeration.}
\CHECKLIST{
\begin{itemize}
\item Sort islands and find indices.
\item Initialize BFS from $0$; remove visited indices from the ordered set.
\item Expand left and right while $|d_j-d_i|\le g$.
\item Update candidate answer when $n-d_j\le g$.
\item Output minimal time or $-1$.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item Immediate finish when $n\le g$.
\item Large gap greater than $g$ blocking progress.
\item Many tightly spaced islands.
\item $g=1$ or $r=1$ extremes.
\item Duplicate input coordinates (must be distinct by problem).
\item $m=\min(n+1,10^4)$ near upper bound.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Forgetting to sort $d$ and to keep $0,n$.
\item Off-by-one in left/right sweeps.
\item Not removing visited indices, leading to $O(m^2)$ or revisits.
\item Overflowing answer if impossible (use a clear sentinel).
\item Not checking the final partial green reachability ($n-d_i\le g$).
\item Mishandling input parsing with extra spaces or newlines.
\end{itemize}}
\FAILMODES{Naive $O(m^2)$ scans may TLE at upper bounds. Incorrectly modeling transitions can miscount red waits. The linked-list BFS survives by removing each index once and ensuring correct BFS layering.}
\ELI{We can only rest at islands when the light is red. So each green light is like a single hop along the islands up to $g$ units. Count how many reds we must wait until we get close enough, then dash to the finish during the last green.}
\NotePages{3}

\end{document}