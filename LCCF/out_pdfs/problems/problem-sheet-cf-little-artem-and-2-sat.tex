% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Little Artem and 2-SAT}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/641/F}}
\LINE{DIFFICULTY / RATING}{CF: 641/F, Rating: 3000}
\STATEMENT{Little Artem is a very smart programmer. He knows many different difficult algorithms. Recently he has mastered in 2-SAT one.

In computer science, 2-satisfiability (abbreviated as 2-SAT) is the special case of the problem of determining whether a conjunction (logical AND) of disjunctions (logical OR) have a solution, in which all disjunctions consist of no more than two arguments (variables). For the purpose of this problem we consider only 2-SAT formulas where each disjunction consists of exactly two arguments.

Consider the following 2-SAT problem as an example: $(!x_{1} \text{ OR } x_{2}) \text{ AND } (x_{3} \text{ OR }!x_{4}) \text{ AND } \ldots \text{ AND } (x_{2n-1} \text{ OR } x_{2n})$. Note that there might be negations in 2-SAT formula (like for $x_1$ and for $x_4$).

Artem now tries to solve as many problems with 2-SAT as possible. He found a very interesting one, which he can not solve yet. Of course, he asks you to help him.

The problem is: given two 2-SAT formulas $f$ and $g$, determine whether their sets of possible solutions are the same. Otherwise, find any variables assignment $x$ such that $f(x) \ne g(x)$.

Input:
The first line of the input contains three integers $n$, $m_1$ and $m_2$ ($1 \le n \le 1000$, $1 \le m_1, m_2 \le n^2$) — the number of variables, the number of disjunctions in the first formula and the number of disjunctions in the second formula, respectively.

Next $m_1$ lines contain the description of 2-SAT formula $f$. The description consists of exactly $m_1$ pairs of integers $x_i$ ($-n \le x_i \le n$, $x_i \ne 0$) each on a separate line, where $x_i > 0$ corresponds to the variable without negation, while $x_i < 0$ corresponds to the variable with negation. Each pair gives a single disjunction. Next $m_2$ lines contain formula $g$ in the similar format.

Output:
If both formulas share the same set of solutions, output a single word ``SIMILAR'' (without quotes). Otherwise output exactly $n$ integers $x_i$ ($x_i \in \{0, 1\}$) — any set of values $x$ such that $f(x) \ne g(x)$.

Note:
First sample has two equal formulas, so they are similar by definition.

In second sample if we compute first function with $x_1 = 0$ and $x_2 = 0$ we get the result $0$, because $(0 \; \mathrm{OR} \; 0) = 0$. But the second formula is $1$, because $(0 \; \mathrm{OR} \; !0) = (0 \; \mathrm{OR} \; 1) = 1$.}
\BREAKDOWN{We must compare two 2-CNF formulas for logical equivalence. If not equivalent, produce a witness assignment where their truth values differ. Use implication graphs for each formula: check satisfiability, mutual entailment of clauses via reachability, and construct a witness by solving with forced unit literals.}
\ELI{Two 2-SATs are the same if they imply exactly the same two-literal clauses; if not, pick a clause one implies that the other does not, force it false, and extend to a satisfying assignment of the other.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m_1, m_2$. Then $m_1$ lines, each with a pair $(a, b)$ describing a clause $(a \lor b)$ for $f$. Then $m_2$ lines, each with a pair $(c, d)$ describing a clause $(c \lor d)$ for $g$. Each literal is an integer in $[-n, n] \setminus \{0\}$: positive means $x_i$, negative means $\lnot x_i$.}
\OUTPUTS{If equivalent, print SIMILAR. Otherwise print $n$ integers in $\{0,1\}$ giving an assignment that makes $f$ and $g$ differ.}
\SAMPLES{Example 1:
$n=2$, $m_1=1$, $m_2=1$, $f$: $(1 \; 2)$, $g$: $(1 \; 2)$. Output: SIMILAR.

Example 2:
$n=2$, $m_1=1$, $m_2=1$, $f$: $(1 \; 2)$, $g$: $(1 \; -2)$. Output could be: $0~0$ (then $f=0$, $g=1$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let variables be $X = \{x_1,\ldots,x_n\}$. Each formula is a 2-CNF: a conjunction of clauses, each clause a disjunction of two literals. A signed integer $\ell \in \{\pm 1,\ldots,\pm n\}$ denotes literal $\text{lit}(\ell) = x_{|\ell|}$ if $\ell > 0$ or $\lnot x_{|\ell|}$ if $\ell < 0$.}
\varmapStart
\var{n}{number of variables}
\var{m_1, m_2}{number of clauses in $f$ and $g$ respectively}
\var{(a_k,b_k)}{the $k$-th clause of $f$ as a pair of signed integers}
\var{(c_t,d_t)}{the $t$-th clause of $g$}
\var{G_f, G_g}{implication graphs with $2n$ nodes (one per literal)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Clause }(u \lor v) &\equiv (\lnot u \rightarrow v) \land (\lnot v \rightarrow u).\\
\text{Model}(F) &= \{x \in \{0,1\}^n : \forall (u\lor v)\in F,\; u(x)\lor v(x)=1\}.\\
F \equiv G &\iff \forall x \in \{0,1\}^n,\; F(x)=G(x).\\
G \models (u \lor v) &\iff \text{reach}_{G}(\lnot u, v).
\end{aligned}
\]
}
\ASSUMPTIONS{Variables are indexed $1\ldots n$. Multiple identical clauses may appear. Clauses may use the same variable twice (e.g., $(x_i \lor x_i)$, i.e., unit).}
\INVARIANTS{In a 2-SAT implication graph, a formula is unsatisfiable iff some variable and its negation lie in the same strongly connected component. If $p$ reaches $q$ in the implication graph, then $G \models (p \rightarrow q)$, hence $G \models (\lnot p \lor q)$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate assignments for very small $n$ and compare $f(x)$ and $g(x)$.}
\ASSUMPTIONS{Only feasible for tiny $n$ (e.g., $n \le 18$). Useful as a correctness oracle for unit tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse both formulas.
\item For each assignment $x \in \{0,1\}^n$, evaluate $f(x)$ and $g(x)$.
\item If any mismatch, print the assignment; otherwise print SIMILAR.
\end{algosteps}
\COMPLEXITY{Brute-force $T(n)=\Theta(2^n(m_1+m_2))$, $S(n)=\Theta(1)$.}
\[
\begin{aligned}
T(n) &= 2^n \cdot O(m_1+m_2).\\
\end{aligned}
\]
\CORRECTNESS{Exhaustive enumeration checks all possibilities; if none differ, the formulas are equivalent.}
\EDGECASES{Unit-like clauses $(\ell \lor \ell)$; contradictory formulas; repeated clauses.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def eval_clause(lit: int, assignment: List[int]) -> int:
    v = abs(lit) - 1
    val = assignment[v]
    if lit < 0:
        val ^= 1
    return val

def eval_cnf(n: int, clauses: List[Tuple[int, int]], assignment: List[int]) -> int:
    for a, b in clauses:
        if eval_clause(a, assignment) | eval_clause(b, assignment):
            continue
        return 0
    return 1

def brute_find_witness(n: int, f: List[Tuple[int,int]], g: List[Tuple[int,int]]) -> Tuple[bool, List[int]]:
    if n > 18:
        # Not feasible; indicate unknown
        return (False, [])
    total = 1 << n
    for mask in range(total):
        assignment = [(mask >> i) & 1 for i in range(n)]
        vf = eval_cnf(n, f, assignment)
        vg = eval_cnf(n, g, assignment)
        if vf != vg:
            return (True, assignment)
    return (False, [])

# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
def read_input() -> Tuple[int, List[Tuple[int,int]], List[Tuple[int,int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, [], [])
    it = iter(data)
    n = int(next(it))
    m1 = int(next(it))
    m2 = int(next(it))
    f = []
    for _ in range(m1):
        a = int(next(it)); b = int(next(it))
        f.append((a, b))
    g = []
    for _ in range(m2):
        c = int(next(it)); d = int(next(it))
        g.append((c, d))
    return (n, f, g)

def solve_all():
    n, f, g = read_input()
    if n == 0:
        return
    ok, assn = brute_find_witness(n, f, g)
    if not ok:
        print("SIMILAR")
    else:
        print(" ".join(str(x) for x in assn))

def main():
    solve_all()

if __name__ == "__main__":
    # asserts (run manually if desired)
    n = 2
    f = [(1, 2)]
    g = [(1, 2)]
    ok, assn = brute_find_witness(n, f, g)
    assert ok is False

    n = 2
    f = [(1, 2)]
    g = [(1, -2)]
    ok, assn = brute_find_witness(n, f, g)
    assert ok and len(assn) == 2

    # main()  # disabled for baseline tests
    pass
\end{minted}
\VALIDATION{Checked two tiny examples: identical formulas return SIMILAR; a differing single clause yields a 2-bit witness.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Mutual Entailment by SAT with Units}
\WHICHFORMULA{Two CNFs $F,G$ are equivalent iff $F \models C$ for every clause $C$ of $G$ and $G \models C$ for every clause $C$ of $F$. Test entailment of $(u \lor v)$ by solving $G \land \lnot u \land \lnot v$ for satisfiability (unsat means entailed).}
\ASSUMPTIONS{2-SAT remains 2-SAT after adding unit clauses; we can run a linear-time 2-SAT solver per query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a standard 2-SAT solver for a given clause set with optional unit literals.
\item Test satisfiability of each base formula; if both unsat, output SIMILAR; if exactly one sat, output any model of the sat one.
\item For each clause of $F$, test if $G \land \lnot u \land \lnot v$ is unsatisfiable; if satisfiable, that model witnesses $G=1$ and $F=0$.
\item Symmetrically, for each clause of $G$ against $F$.
\item If all entailed both ways, output SIMILAR.
\end{algosteps}
\COMPLEXITY{In worst case $O\big((m_1+m_2)\cdot (n+m)\big)$ for $m$ edges; acceptable for moderate sizes but large constants.}
\[
\begin{aligned}
T &\approx (m_1+m_2)\cdot O(n+m) \\
\end{aligned}
\]
\CORRECTNESS{If $G \land \lnot u \land \lnot v$ is satisfiable, then there exists a model of $G$ falsifying $(u \lor v)$; otherwise, $G \models (u \lor v)$. Mutual entailment implies equivalence.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

def _idx(lit: int) -> Tuple[int, int]:
    v = abs(lit) - 1
    is_true = 1 if lit > 0 else 0
    return v, is_true

def _to_node(v: int, is_true: int) -> int:
    return 2 * v + (1 if is_true else 0)

def _neg(node: int) -> int:
    return node ^ 1

class TwoSAT:
    def __init__(self, n: int):
        self.n = n
        self.N = 2 * n
        self.g = [[] for _ in range(self.N)]
        self.gr = [[] for _ in range(self.N)]

    def add_clause(self, a: int, b: int):
        va, ta = _idx(a)
        vb, tb = _idx(b)
        A = _to_node(va, ta)
        B = _to_node(vb, tb)
        self.g[_neg(A)].append(B)
        self.g[_neg(B)].append(A)
        self.gr[B].append(_neg(A))
        self.gr[A].append(_neg(B))

    def add_unit_literal(self, lit: int):
        v, t = _idx(lit)
        L = _to_node(v, t)
        self.g[_neg(L)].append(L)
        self.gr[L].append(_neg(L))

    def satisfiable(self) -> Tuple[bool, List[int]]:
        N = self.N
        used = [False] * N
        order = []

        # iterative DFS for order
        for s in range(N):
            if used[s]:
                continue
            stack = [(s, 0)]
            while stack:
                u, it = stack.pop()
                if it == 0:
                    if used[u]:
                        continue
                    used[u] = True
                    stack.append((u, 1))
                    for v in self.g[u]:
                        if not used[v]:
                            stack.append((v, 0))
                else:
                    order.append(u)

        comp = [-1] * N
        j = 0
        for s in reversed(order):
            if comp[s] != -1:
                continue
            stack = [s]
            comp[s] = j
            while stack:
                u = stack.pop()
                for v in self.gr[u]:
                    if comp[v] == -1:
                        comp[v] = j
                        stack.append(v)
            j += 1

        assignment = [0] * self.n
        for i in range(self.n):
            if comp[2 * i] == comp[2 * i + 1]:
                return (False, [])
            assignment[i] = 1 if comp[2 * i + 1] > comp[2 * i] else 0
        return (True, assignment)

def solve_equivalence_via_units(n: int, f: List[Tuple[int,int]], g: List[Tuple[int,int]]) -> Tuple[bool, List[int]]:
    satF = TwoSAT(n)
    satG = TwoSAT(n)
    for a, b in f:
        satF.add_clause(a, b)
    for c, d in g:
        satG.add_clause(c, d)
    okF, assnF = satF.satisfiable()
    okG, assnG = satG.satisfiable()
    if not okF and not okG:
        return (True, [])
    if okF and not okG:
        return (False, assnF)
    if okG and not okF:
        return (False, assnG)

    # Both satisfiable: mutual entailment by SAT with units
    def witness_from(solver_base: TwoSAT, clauses_other: List[Tuple[int,int]], want_satisfy_base: bool) -> Tuple[bool, List[int]]:
        # want_satisfy_base=True means we look for assignment satisfying 'solver_base' and falsifying one clause in clauses_other.
        for u, v in clauses_other:
            # falsify (u or v): force not u, not v
            S = TwoSAT(n)
            S.g = [lst[:] for lst in solver_base.g]
            S.gr = [lst[:] for lst in solver_base.gr]
            def force_not(lit: int):
                # add unit for negation of lit
                S.add_unit_literal(-lit)
            force_not(u)
            force_not(v)
            ok, assn = S.satisfiable()
            if ok:
                return (True, assn)
        return (False, [])
    # Check: if some clause in F is not entailed by G, we can satisfy G and falsify that clause (witness G=1, F=0)
    got, assn = witness_from(satG, f, True)
    if got:
        return (False, assn)
    # Symmetric direction: satisfy F and falsify some clause of G (witness F=1, G=0)
    got, assn = witness_from(satF, g, True)
    if got:
        return (False, assn)
    return (True, [])

# Same API/signature as baseline; deterministic; with asserts
def read_input() -> Tuple[int, List[Tuple[int,int]], List[Tuple[int,int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, [], [])
    it = iter(data)
    n = int(next(it)); m1 = int(next(it)); m2 = int(next(it))
    f = [(int(next(it)), int(next(it))) for _ in range(m1)]
    g = [(int(next(it)), int(next(it))) for _ in range(m2)]
    return (n, f, g)

def solve_all():
    n, f, g = read_input()
    if n == 0:
        return
    eq, assn = solve_equivalence_via_units(n, f, g)
    if eq:
        print("SIMILAR")
    else:
        print(" ".join(map(str, assn)))

def main():
    solve_all()

if __name__ == "__main__":
    # Edge inputs checks
    n = 2; f = [(1, 1), (-1, -1)]; g = [(1, 1), (-1, -1)]
    eq, assn = solve_equivalence_via_units(n, f, g)
    assert eq

    n = 2; f = [(1, 2)]; g = [(1, -2)]
    eq, assn = solve_equivalence_via_units(n, f, g)
    assert not eq and len(assn) == 2

    n = 1; f = [(1, 1)]; g = [(-1, -1)]
    eq, assn = solve_equivalence_via_units(n, f, g)
    assert not eq and (assn == [1] or assn == [0])

    # main()  # disabled in this snippet
    pass
\end{minted}
\VALIDATION{Covers identical unsatisfiable formulas, a simple differing clause, and contradictory single-variable pair to ensure witness construction works.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Implication Closure via SCC DAG + Bitset Reachability}
\WHICHFORMULA{Use implication graphs. For each formula, compute SCC condensation DAG and its transitive closure as bitsets. A clause $(u \lor v)$ is entailed iff $\text{comp}(\lnot u)$ reaches $\text{comp}(v)$. Mutual entailment decides equivalence. For a witness, solve 2-SAT on the other formula with units $\lnot u$ and $\lnot v$.}
\ASSUMPTIONS{Both formulas over the same $n$. Two 2-CNFs are equivalent iff they entail each other’s clauses. Unsatisfiable formulas entail all clauses; handle sat/unsat cases first.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build implication graphs $G_f, G_g$ with $2n$ nodes.
\item Compute SCC ids and satisfiability for each. If both unsat, SIMILAR. If exactly one sat, output a model of the sat one.
\item Build condensation DAGs and compute reachability bitsets via reverse topological DP.
\item Check all clauses of $F$ against $G$ using bitset reachability; if some $(u \lor v)$ is not entailed, run 2-SAT on $G$ with unit literals $\lnot u$, $\lnot v$ to obtain witness with $G=1, F=0$.
\item Symmetrically check clauses of $G$; if none fail, output SIMILAR.
\end{algosteps}
\OPTIMALITY{With $2n \le 2000$, bitset closure over the condensation DAG yields near $O((V^2 + E)\cdot W)$ with $W$ machine-word factor; fast and memory-light. It avoids per-clause SAT.}
\COMPLEXITY{Let $V=2n \le 2000$, $E \le 2m$.}
\[
\begin{aligned}
T(n) &\approx O(V+E) \text{ (SCC)} + O(E) \text{ (condensation)} + O(\tilde V^2/64 + \tilde E\cdot \tilde V/64) \text{ (bitsets)} + O(m_1+m_2) \text{ (queries)}\\
S(n) &\approx O(V + E) \text{ to store graphs and bitsets.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

def lit_to_node(n: int, lit: int) -> int:
    v = abs(lit) - 1
    return 2 * v + (1 if lit > 0 else 0)

def neg_node(u: int) -> int:
    return u ^ 1

def add_clause_edges(n: int, g: List[List[int]], gr: List[List[int]], a: int, b: int):
    A = lit_to_node(n, a); B = lit_to_node(n, b)
    g[neg_node(A)].append(B)
    g[neg_node(B)].append(A)
    gr[B].append(neg_node(A))
    gr[A].append(neg_node(B))

def scc_kosaraju(g: List[List[int]], gr: List[List[int]]) -> Tuple[List[int], List[int]]:
    N = len(g)
    used = [False] * N
    order: List[int] = []
    # iterative DFS for order
    for s in range(N):
        if used[s]:
            continue
        st = [(s, 0)]
        while st:
            u, it = st.pop()
            if it == 0:
                if used[u]:
                    continue
                used[u] = True
                st.append((u, 1))
                for v in g[u]:
                    if not used[v]:
                        st.append((v, 0))
            else:
                order.append(u)
    comp = [-1] * N
    j = 0
    for s in reversed(order):
        if comp[s] != -1:
            continue
        st = [s]
        comp[s] = j
        while st:
            u = st.pop()
            for v in gr[u]:
                if comp[v] == -1:
                    comp[v] = j
                    st.append(v)
        j += 1
    return comp, order  # order not used further except for assignment heuristic

def sat_assignment_from_comp(n: int, comp: List[int]) -> Tuple[bool, List[int]]:
    N = 2 * n
    assign = [0] * n
    for i in range(n):
        if comp[2 * i] == comp[2 * i + 1]:
            return (False, [])
        assign[i] = 1 if comp[2 * i + 1] > comp[2 * i] else 0
    return (True, assign)

def build_condensation(n: int, g: List[List[int]], comp: List[int]) -> Tuple[int, List[List[int]]]:
    N = 2 * n
    C = max(comp) + 1
    dag: List[set] = [set() for _ in range(C)]
    for u in range(N):
        cu = comp[u]
        for v in g[u]:
            cv = comp[v]
            if cu != cv:
                dag[cu].add(cv)
    dag_list: List[List[int]] = [sorted(list(adj)) for adj in dag]
    return C, dag_list

def topo_order_dag(C: int, dag: List[List[int]]) -> List[int]:
    indeg = [0] * C
    for u in range(C):
        for v in dag[u]:
            indeg[v] += 1
    from collections import deque
    dq = deque([u for u in range(C) if indeg[u] == 0])
    order: List[int] = []
    while dq:
        u = dq.popleft()
        order.append(u)
        for v in dag[u]:
            indeg[v] -= 1
            if indeg[v] == 0:
                dq.append(v)
    return order

def closure_bitsets(C: int, dag: List[List[int]], topo: List[int]) -> List[int]:
    # bitset as Python int, bit i means reach i
    reach = [0] * C
    for u in range(C):
        reach[u] = 1 << u
    for u in reversed(topo):  # process reverse topological to pull from children
        mask = reach[u]
        for v in dag[u]:
            mask |= reach[v]
        reach[u] = mask
    return reach

def formula_build_graph(n: int, clauses: List[Tuple[int,int]]) -> Tuple[List[List[int]], List[List[int]]]:
    N = 2 * n
    g = [[] for _ in range(N)]
    gr = [[] for _ in range(N)]
    for a, b in clauses:
        add_clause_edges(n, g, gr, a, b)
    return g, gr

def entails_via_reach(n: int, reach: List[int], comp: List[int], clause: Tuple[int,int]) -> bool:
    a, b = clause
    A = lit_to_node(n, a)
    B = lit_to_node(n, b)
    ca = comp[neg_node(A)]
    cb = comp[B]
    return (reach[ca] >> cb) & 1 == 1

def solve_equiv(n: int, f: List[Tuple[int,int]], g: List[Tuple[int,int]]) -> Tuple[bool, List[int]]:
    # Build graphs
    gf, grf = formula_build_graph(n, f)
    gg, grg = formula_build_graph(n, g)

    # SCC and satisfiability
    compF, _ = scc_kosaraju(gf, grf)
    compG, _ = scc_kosaraju(gg, grg)
    okF, assnF = sat_assignment_from_comp(n, compF)
    okG, assnG = sat_assignment_from_comp(n, compG)
    if not okF and not okG:
        return (True, [])
    if okF and not okG:
        return (False, assnF)
    if okG and not okF:
        return (False, assnG)

    # Condensation DAGs and closures
    CF, dagF = build_condensation(n, gf, compF)
    CG, dagG = build_condensation(n, gg, compG)
    topoF = topo_order_dag(CF, dagF)
    topoG = topo_order_dag(CG, dagG)
    reachF = closure_bitsets(CF, dagF, topoF)
    reachG = closure_bitsets(CG, dagG, topoG)

    # Check F clauses are entailed by G
    for cl in f:
        if not entails_via_reach(n, reachG, compG, cl):
            # Build witness: satisfy G, falsify cl by forcing not-a and not-b
            # Add units by edges (A -> !A), (B -> !B)
            N = 2 * n
            g2 = [lst[:] for lst in gg]
            gr2 = [lst[:] for lst in grg]
            a, b = cl
            A = lit_to_node(n, a)
            B = lit_to_node(n, b)
            # Force not-a: add (A -> !A)
            g2[A].append(neg_node(A)); gr2[neg_node(A)].append(A)
            # Force not-b: add (B -> !B)
            g2[B].append(neg_node(B)); gr2[neg_node(B)].append(B)
            compW, _ = scc_kosaraju(g2, gr2)
            okW, assnW = sat_assignment_from_comp(n, compW)
            if okW:
                return (False, assnW)
            # In theory, non-entailment in a satisfiable G guarantees satisfiable with these units.
            # Fallback shouldn't happen.
    # Check G clauses are entailed by F
    for cl in g:
        if not entails_via_reach(n, reachF, compF, cl):
            N = 2 * n
            g2 = [lst[:] for lst in gf]
            gr2 = [lst[:] for lst in grf]
            c, d = cl
            Cn = lit_to_node(n, c)
            Dn = lit_to_node(n, d)
            g2[Cn].append(neg_node(Cn)); gr2[neg_node(Cn)].append(Cn)
            g2[Dn].append(neg_node(Dn)); gr2[neg_node(Dn)].append(Dn)
            compW, _ = scc_kosaraju(g2, gr2)
            okW, assnW = sat_assignment_from_comp(n, compW)
            if okW:
                return (False, assnW)
    return (True, [])

# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
def read_input() -> Tuple[int, List[Tuple[int,int]], List[Tuple[int,int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, [], [])
    it = iter(data)
    n = int(next(it)); m1 = int(next(it)); m2 = int(next(it))
    f = [(int(next(it)), int(next(it))) for _ in range(m1)]
    g = [(int(next(it)), int(next(it))) for _ in range(m2)]
    return (n, f, g)

def solve_all():
    n, f, g = read_input()
    if n == 0:
        return
    eq, assn = solve_equiv(n, f, g)
    if eq:
        print("SIMILAR")
    else:
        print(" ".join(map(str, assn)))

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts or I/O mini-tests
    # 1) Identical single clause -> SIMILAR
    n = 2; f = [(1, 2)]; g = [(1, 2)]
    eq, assn = solve_equiv(n, f, g)
    assert eq

    # 2) Different clause -> witness exists (e.g., 0 0 works)
    n = 2; f = [(1, 2)]; g = [(1, -2)]
    eq, assn = solve_equiv(n, f, g)
    assert not eq and len(assn) == 2

    # 3) One unsat, one sat -> witness is sat's model
    n = 1; f = [(1, 1), (-1, -1)]; g = [(1, 1)]
    eq, assn = solve_equiv(n, f, g)
    assert not eq and assn in ([1], [0])  # model of g

    # main()  # disabled in this snippet
    pass
\end{minted}
\VALIDATION{Three checks: trivial equivalence, simple inequivalence with a concrete witness, and sat/unsat asymmetry. Each covers a different branch of the algorithm.}
\RESULT{Outputs SIMILAR if and only if the formulas are equivalent. Otherwise prints an $n$-bit assignment such that exactly one of the formulas evaluates to $1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Exercise each decision branch: both unsat, one sat/one unsat, both sat with mutual entailment, and both sat with a failing entailment in each direction. Random fuzzing for small $n$ can cross-check against brute force.}
\LINE{CROSS-CHECKS}{For $n \le 10$, generate random formulas, compare Approach C’s decision and witness against Approach A’s brute-force oracle.}
\LINE{EDGE-CASE GENERATOR}{Generate degenerate unit-like clauses $(\ell,\ell)$, duplicated clauses, clauses with same variable $(x_i,\lnot x_i)$, and empty-solution cases.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_clause(n: int) -> Tuple[int,int]:
    i = random.randint(1, n)
    j = random.randint(1, n)
    li = i if random.randint(0,1) else -i
    lj = j if random.randint(0,1) else -j
    return (li, lj)

def gen_formula(n: int, m: int, seed: int = 0):
    random.seed(seed)
    return [gen_clause(n) for _ in range(m)]

def brute_equiv(n, f, g):
    # Cross-check helper using Approach A
    from itertools import product
    for vals in product([0,1], repeat=n):
        vals = list(vals)
        if eval_cnf(n, f, vals) != eval_cnf(n, g, vals):
            return False
    return True

def cross_check_trials():
    for seed in range(20):
        n = 4
        f = gen_formula(n, 6, seed)
        g = gen_formula(n, 6, seed+1000)
        eq_fast, assn = solve_equiv(n, f, g)
        eq_brut = brute_equiv(n, f, g)
        assert eq_fast == eq_brut
        if not eq_fast:
            # Verify witness indeed differs
            assert eval_cnf(n, f, assn) != eval_cnf(n, g, assn)

# Reference Code (Ready to Submit) below reproduces Approach C end-to-end.
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List, Tuple

def lit_to_node(n: int, lit: int) -> int:
    v = abs(lit) - 1
    return 2 * v + (1 if lit > 0 else 0)

def neg_node(u: int) -> int:
    return u ^ 1

def add_clause_edges(n: int, g: List[List[int]], gr: List[List[int]], a: int, b: int):
    A = lit_to_node(n, a); B = lit_to_node(n, b)
    g[neg_node(A)].append(B)
    g[neg_node(B)].append(A)
    gr[B].append(neg_node(A))
    gr[A].append(neg_node(B))

def scc_kosaraju(g: List[List[int]], gr: List[List[int]]) -> Tuple[List[int], List[int]]:
    N = len(g)
    used = [False] * N
    order: List[int] = []
    for s in range(N):
        if used[s]:
            continue
        st = [(s, 0)]
        while st:
            u, it = st.pop()
            if it == 0:
                if used[u]:
                    continue
                used[u] = True
                st.append((u, 1))
                for v in g[u]:
                    if not used[v]:
                        st.append((v, 0))
            else:
                order.append(u)
    comp = [-1] * N
    j = 0
    for s in reversed(order):
        if comp[s] != -1:
            continue
        st = [s]
        comp[s] = j
        while st:
            u = st.pop()
            for v in gr[u]:
                if comp[v] == -1:
                    comp[v] = j
                    st.append(v)
        j += 1
    return comp, order

def sat_assignment_from_comp(n: int, comp: List[int]) -> Tuple[bool, List[int]]:
    assign = [0] * n
    for i in range(n):
        if comp[2 * i] == comp[2 * i + 1]:
            return (False, [])
        assign[i] = 1 if comp[2 * i + 1] > comp[2 * i] else 0
    return (True, assign)

def build_condensation(n: int, g: List[List[int]], comp: List[int]) -> Tuple[int, List[List[int]]]:
    N = 2 * n
    C = max(comp) + 1
    dag: List[set] = [set() for _ in range(C)]
    for u in range(N):
        cu = comp[u]
        for v in g[u]:
            cv = comp[v]
            if cu != cv:
                dag[cu].add(cv)
    dag_list: List[List[int]] = [sorted(list(adj)) for adj in dag]
    return C, dag_list

def topo_order_dag(C: int, dag: List[List[int]]) -> List[int]:
    indeg = [0] * C
    for u in range(C):
        for v in dag[u]:
            indeg[v] += 1
    from collections import deque
    dq = deque([u for u in range(C) if indeg[u] == 0])
    order: List[int] = []
    while dq:
        u = dq.popleft()
        order.append(u)
        for v in dag[u]:
            indeg[v] -= 1
            if indeg[v] == 0:
                dq.append(v)
    return order

def closure_bitsets(C: int, dag: List[List[int]], topo: List[int]) -> List[int]:
    reach = [0] * C
    for u in range(C):
        reach[u] = 1 << u
    for u in reversed(topo):
        mask = reach[u]
        for v in dag[u]:
            mask |= reach[v]
        reach[u] = mask
    return reach

def formula_build_graph(n: int, clauses: List[Tuple[int,int]]) -> Tuple[List[List[int]], List[List[int]]]:
    N = 2 * n
    g = [[] for _ in range(N)]
    gr = [[] for _ in range(N)]
    for a, b in clauses:
        add_clause_edges(n, g, gr, a, b)
    return g, gr

def entails_via_reach(n: int, reach: List[int], comp: List[int], clause: Tuple[int,int]) -> bool:
    a, b = clause
    A = lit_to_node(n, a)
    B = lit_to_node(n, b)
    ca = comp[neg_node(A)]
    cb = comp[B]
    return (reach[ca] >> cb) & 1 == 1

def solve_equiv(n: int, f: List[Tuple[int,int]], g: List[Tuple[int,int]]) -> Tuple[bool, List[int]]:
    gf, grf = formula_build_graph(n, f)
    gg, grg = formula_build_graph(n, g)

    compF, _ = scc_kosaraju(gf, grf)
    compG, _ = scc_kosaraju(gg, grg)
    okF, assnF = sat_assignment_from_comp(n, compF)
    okG, assnG = sat_assignment_from_comp(n, compG)
    if not okF and not okG:
        return (True, [])
    if okF and not okG:
        return (False, assnF)
    if okG and not okF:
        return (False, assnG)

    CF, dagF = build_condensation(n, gf, compF)
    CG, dagG = build_condensation(n, gg, compG)
    topoF = topo_order_dag(CF, dagF)
    topoG = topo_order_dag(CG, dagG)
    reachF = closure_bitsets(CF, dagF, topoF)
    reachG = closure_bitsets(CG, dagG, topoG)

    for cl in f:
        if not entails_via_reach(n, reachG, compG, cl):
            a, b = cl
            A = lit_to_node(n, a)
            B = lit_to_node(n, b)
            g2 = [lst[:] for lst in gg]
            gr2 = [lst[:] for lst in grg]
            g2[A].append(neg_node(A)); gr2[neg_node(A)].append(A)
            g2[B].append(neg_node(B)); gr2[neg_node(B)].append(B)
            compW, _ = scc_kosaraju(g2, gr2)
            okW, assnW = sat_assignment_from_comp(n, compW)
            if okW:
                return (False, assnW)

    for cl in g:
        if not entails_via_reach(n, reachF, compF, cl):
            c, d = cl
            Cn = lit_to_node(n, c)
            Dn = lit_to_node(n, d)
            g2 = [lst[:] for lst in gf]
            gr2 = [lst[:] for lst in grf]
            g2[Cn].append(neg_node(Cn)); gr2[neg_node(Cn)].append(Cn)
            g2[Dn].append(neg_node(Dn)); gr2[neg_node(Dn)].append(Dn)
            compW, _ = scc_kosaraju(g2, gr2)
            okW, assnW = sat_assignment_from_comp(n, compW)
            if okW:
                return (False, assnW)

    return (True, [])

def read_input() -> Tuple[int, List[Tuple[int,int]], List[Tuple[int,int]]]:
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, [], [])
    it = iter(data)
    n = int(next(it)); m1 = int(next(it)); m2 = int(next(it))
    f = [(int(next(it)), int(next(it))) for _ in range(m1)]
    g = [(int(next(it)), int(next(it))) for _ in range(m2)]
    return (n, f, g)

def solve_all():
    n, f, g = read_input()
    if n == 0:
        return
    eq, assn = solve_equiv(n, f, g)
    if eq:
        print("SIMILAR")
    else:
        print(" ".join(map(str, assn)))

def main():
    solve_all()

if __name__ == "__main__":
    # quick self-checks
    n = 2; f = [(1, 2)]; g = [(1, 2)]
    eq, assn = solve_equiv(n, f, g)
    assert eq

    n = 2; f = [(1, 2)]; g = [(1, -2)]
    eq, assn = solve_equiv(n, f, g)
    assert not eq and len(assn) == 2

    n = 1; f = [(1, 1), (-1, -1)]; g = [(1, 1)]
    eq, assn = solve_equiv(n, f, g)
    assert not eq and assn in ([1], [0])

    # main()  # disabled here
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Equivalence of two 2-CNF formulas via mutual entailment using implication graph reachability; produce a differing assignment by forcing the negations of a non-entailed clause.}
\WHY{2-SAT implication techniques and SCC reasoning are standard; equivalence testing with efficient reachability is a deeper twist seen in advanced interviews and contests.}
\CHECKLIST{
\begin{bullets}
\item Build implication graphs for both formulas.
\item Check satisfiability (SCC no variable collides with its negation).
\item If both unsat: SIMILAR. If one sat: print its model.
\item Build condensation DAGs; compute reachability bitsets.
\item For each clause $(u \lor v)$ in $F$, test reachability $(\lnot u \rightarrow v)$ in $G$.
\item If any fails, solve $G$ with units $\lnot u, \lnot v$ to get the witness.
\item Else check clauses of $G$ against $F$ similarly.
\item If all pass: SIMILAR.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Unit-like clauses $(\ell,\ell)$.
\item Clauses $(x_i,\lnot x_i)$ (always true).
\item Duplicate clauses.
\item Unsatisfiable formulas (both or exactly one).
\item Variables unused in one or both formulas.
\item Minimal $n=1$ and maximal $n$ with sparse clauses.
\item Mixed signs and repeated variables across clauses.
\item Witness construction must flip the correct literals (force negations).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Mapping literals to nodes: ensure consistent indexing and negation via XOR 1.
\item Forgetting to add reverse edges for SCC computation.
\item Treating unsatisfiable formulas as not entailing anything (they entail everything).
\item Misinterpreting clause entailment: $(u \lor v)$ is equivalent to $(\lnot u \rightarrow v)$.
\item Building reachability on original graph instead of condensation can be costly; prefer DAG bitsets.
\item Not copying graphs when adding unit edges for witness; avoid mutating the base graph.
\item Output format: exactly $n$ integers separated by spaces.
\item Recursion depth in DFS; use iterative stacks in Python.
\end{bullets}
}
\FAILMODES{Baseline brute force explodes for moderate $n$. Per-clause SAT (Approach B) may be too slow for $m \approx n^2$. The optimal method survives by precomputing reachability once and answering all entailment queries in $O(1)$ each.}
\ELI{Turn each formula into a web of one-way roads between literal nodes. If from $\lnot u$ there is a path to $v$, then the clause $(u \lor v)$ is guaranteed by the formula. Check that each formula guarantees all the other's clauses. If one clause is missing, force it to be false and follow the roads to complete a valid assignment as a witness.}
\NotePages{3}

\end{document}