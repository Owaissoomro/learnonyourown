% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Convex Countour}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/838/E}}
\LINE{DIFFICULTY / RATING}{CF 838/E, Rating: 2300}
\STATEMENT{You are given a strictly convex polygon with $n$ vertices. It is guaranteed that no three points are collinear. You would like to take a maximum non-intersecting path on the polygon vertices that visits each point at most once.

More specifically your path can be represented as some sequence of distinct polygon vertices. Your path is the straight line segments between adjacent vertices in order. These segments are not allowed to touch or intersect each other except at the vertices in your sequence.

Given the polygon, print the maximum-length non-intersecting path that visits each point at most once.

Input: The first line of input contains a single integer $n$ ($2 \le n \le 2{,}500$), the number of points. The next $n$ lines contain two integers $x_i, y_i$ ($|x_i|, |y_i| \le 10^9$), denoting the coordinates of the $i$-th vertex. It is guaranteed that these points are listed in clockwise order.

Output: Print a single floating point number, representing the longest non-intersecting path that visits the vertices at most once.

Your answer will be accepted if it has absolute or relative error at most $10^{-9}$. More specifically, if your answer is $a$ and the jury answer is $b$, your answer will be accepted if $\dfrac{|a-b|}{\max(1,b)} \le 10^{-9}$.

Note: One optimal path (for a certain quadrilateral) is to visit points $0,1,3,2$ in order.}
\BREAKDOWN{We need the maximum total Euclidean length of a non-self-intersecting Hamiltonian path on the vertex set of a convex polygon. On convex position, any non-crossing Hamiltonian path visits vertices by alternately taking from the ends of some circular interval. This enables a clean interval dynamic programming.}
\ELI{On a convex polygon, the best non-crossing path always zigzags between the two ends of some arc; we can compute its length by growing the arc and deciding which end to connect next.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- $n$ (int), $2 \le n \le 2{,}500$.
- $n$ lines: $(x_i,y_i)$ as integers with $|x_i|,|y_i| \le 10^9$, listed in clockwise order and strictly convex.}
\OUTPUTS{One real number: the maximum possible total length of a non-intersecting path visiting each vertex at most once. Any answer within $10^{-9}$ relative or absolute error is accepted.}
\SAMPLES{Example 1:
- Input:
  4
  0 0
  1 0
  1 1
  0 1
- Output: approximately $3.4142135623$ (path $0\to1\to3\to2$: $1+\sqrt{2}+1$).

Example 2:
- Input:
  3
  0 0
  2 0
  1 1
- Output: approximately $2.8284271247$ (path $0\to2\to1$: $\sqrt{2}+\sqrt{2}$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the polygon vertices be $P_0,P_1,\ldots,P_{n-1}$ in clockwise order. Consider the complete geometric graph on these vertices with edge weights $w(i,j)=\|P_iP_j\|_2$. A feasible solution is an ordering $(v_1,\ldots,v_k)$ with all $v$ distinct, $2 \le k \le n$, such that its polyline segments do not intersect except at shared endpoints, and ideally $k=n$ (Hamiltonian path). We seek to maximize $\sum_{t=1}^{k-1} w(v_t,v_{t+1})$ over all non-crossing vertex-disjoint polylines with $k \le n$. In a strictly convex polygon, there is always an optimal solution with $k=n$.}
\varmapStart
\var{P_i}{the $i$-th vertex in clockwise order}
\var{w(i,j)}{Euclidean distance between $P_i$ and $P_j$}
\var{[l..r]}{a circular arc (interval) of consecutive vertices along the polygon}
\var{f(l,r,0/1)}{DP value on arc $[l..r]$ with last endpoint at $l$ (0) or $r$ (1)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Base: } f(l,l,0)=f(l,l,1)=0.\\
&\text{Transition for circular indices (mod }n\text{), with } r=l+L-1:\\
&f(l,r,0)=\max\big(f(l+1,r,0)+w(l,l+1),\ f(l+1,r,1)+w(l,r)\big),\\
&f(l,r,1)=\max\big(f(l,r-1,1)+w(r-1,r),\ f(l,r-1,0)+w(l,r)\big).\\
&\text{Answer: } \max_{l}\ \max\big(f(l,l+n-1,0),\ f(l,l+n-1,1)\big).
\end{aligned}
\]
}
\ASSUMPTIONS{Vertices are in strict convex position and provided in clockwise order. Non-crossing paths over convex point sets correspond to alternating selections from the ends of a circular interval. Distances are Euclidean.}
\INVARIANTS{(i) At any DP state $[l..r]$, the set of visited vertices forms a contiguous arc on the polygon. (ii) The last vertex of the partial path is an endpoint of the arc. (iii) Extending by one neighbor of the arc preserves non-crossing.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all non-crossing Hamiltonian paths by recursively growing a path from an initial edge, always adding one of the two neighbors of the current unused arc; track the best length. This is exponential, suitable only for very small $n$, but clarifies structure.}
\ASSUMPTIONS{Strict convexity ensures that at any point, the visited set is an arc and the next valid vertex is one of its two neighbors.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pick a starting pair $(s,t)$ of adjacent vertices; initialize the used arc to $[s..t]$ and current endpoint $t$.
\item Recurse: at each step, add either the predecessor of $s$ or the successor of $t$, connecting from the current endpoint; update length.
\item Track the maximum length when the arc size reaches $n$. Maximize over all initial adjacent pairs and both orientations.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ (about $2^{n-2}$ branches), space $O(n)$.}
\[
\begin{aligned}
T(n) &\approx 2\,T(n-1) \\
     &= O(2^n).
\end{aligned}
\]
\CORRECTNESS{At each step, only the two neighbors of the current arc can be added without creating crossings on a convex polygon. Enumerating both choices explores all non-crossing Hamiltonian paths.}
\EDGECASES{Small $n=2,3$; degenerate symmetric polygons; integer coordinates with large magnitude.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

Point = Tuple[float, float]

def dist(a: Point, b: Point) -> float:
    return math.hypot(a[0]-b[0], a[1]-b[1])

def brute_force_max_path(points: List[Point]) -> float:
    n = len(points)
    if n <= 1:
        return 0.0
    best = 0.0

    # Try all starting adjacent pairs (s, t) on the circle
    for s in range(n):
        t = (s + 1) % n
        used = [False] * n

        def dfs(l: int, r: int, last: int, length: float, used_count: int):
            nonlocal best
            if used_count == n:
                if length > best:
                    best = length
                return
            # Two candidates: (l-1) and (r+1) modulo n
            cand1 = (l - 1) % n
            cand2 = (r + 1) % n
            # Add cand1 if not yet used and is the correct neighbor to expand the arc
            if cand1 != (r + 1) % n and not used[cand1]:
                used[cand1] = True
                dfs(cand1, r, cand1, length + dist(points[last], points[cand1]), used_count + 1)
                used[cand1] = False
            # Add cand2
            if cand2 != (l - 1) % n and not used[cand2]:
                used[cand2] = True
                dfs(l, cand2, cand2, length + dist(points[last], points[cand2]), used_count + 1)
                used[cand2] = False

        used[s] = used[t] = True
        # Option 1: start path s -> t
        dfs(s, t, t, dist(points[s], points[t]), 2)
        # Option 2: start path t -> s
        dfs(s, t, s, dist(points[s], points[t]), 2)
        used[s] = used[t] = False

    return best

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = float(next(it)); y = float(next(it))
        pts.append((x, y))
    return pts

def main():
    pts = read_input()
    if pts is None:
        # Self-test when no stdin
        sq = [(0.0,0.0),(1.0,0.0),(1.0,1.0),(0.0,1.0)]
        val = brute_force_max_path(sq)
        assert abs(val - (2.0 + math.sqrt(2.0))) < 1e-9
        tri = [(0.0,0.0),(2.0,0.0),(1.0,1.0)]
        val2 = brute_force_max_path(tri)
        assert abs(val2 - (math.sqrt(2.0)*2.0)) < 1e-9
        print("OK")
    else:
        ans = brute_force_max_path(pts)
        print("{:.12f}".format(ans))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Asserts on a unit square and a simple triangle confirm expected values.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use interval DP on a circle: $f(l,r,0/1)$ over circular arcs with the recurrence in the model. This yields $O(n^2)$ states and $O(1)$ transitions, total $O(n^2)$ time.}
\ASSUMPTIONS{We duplicate the vertex array mod $n$ conceptually and only evaluate arcs of length $\le n$. For clarity, this version uses a direct but memory-heavier $O(n^2)$ DP tables in Python for small inputs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute a distance accessor $w(i,j)$ with circular indexing.
\item For lengths $L=1..n$, fill DP for every start $l$, with $r=l+L-1 \pmod n$.
\item Apply the two transitions for $f(l,r,0)$ and $f(l,r,1)$.
\item The answer is $\max_l \max(f(l,l+n-1,0), f(l,l+n-1,1))$.
\end{algosteps}
\COMPLEXITY{The recurrence computes $O(n^2)$ states with $O(1)$ work each.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \quad S(n)=\Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{By induction on the arc length, the DP enumerates exactly the non-crossing paths on convex arcs whose last vertex is an endpoint. The two cases correspond to joining the new vertex to either neighbor endpoint.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

Point = Tuple[float, float]

def dist(a: Point, b: Point) -> float:
    return math.hypot(a[0]-b[0], a[1]-b[1])

def dp_interval_O_n2(points: List[Point]) -> float:
    n = len(points)
    if n <= 1:
        return 0.0

    def W(i: int, j: int) -> float:
        return dist(points[i % n], points[j % n])

    # f0[l][L]: last at l; f1[l][L]: last at r, where r = l+L-1 (mod n)
    f0 = [[0.0]*(n+1) for _ in range(n)]
    f1 = [[0.0]*(n+1) for _ in range(n)]

    for L in range(2, n+1):
        for l in range(n):
            r = (l + L - 1) % n
            l1 = (l + 1) % n
            r1 = (l + L - 2) % n
            # f(l,r,0)
            # Previous arc is (l+1, r) length L-1
            f0[l][L] = max(f0[l1][L-1] + W(l, l1),
                           f1[l1][L-1] + W(l, r))
            # f(l,r,1)
            # Previous arc is (l, r-1) length L-1
            f1[l][L] = max(f1[l][L-1] + W(r1, r),
                           f0[l][L-1] + W(l, r))

    ans = 0.0
    for l in range(n):
        ans = max(ans, f0[l][n], f1[l][n])
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = float(next(it)); y = float(next(it))
        pts.append((x, y))
    return pts

def main():
    pts = read_input()
    if pts is None:
        # Self-check on small shapes
        sq = [(0.0,0.0),(1.0,0.0),(1.0,1.0),(0.0,1.0)]
        val = dp_interval_O_n2(sq)
        assert abs(val - (2.0 + math.sqrt(2.0))) < 1e-9
        tri = [(0.0,0.0),(2.0,0.0),(1.0,1.0)]
        val2 = dp_interval_O_n2(tri)
        assert abs(val2 - (math.sqrt(2.0)*2.0)) < 1e-9
        print("OK")
    else:
        print("{:.12f}".format(dp_interval_O_n2(pts)))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked on a unit square and a triangle.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Same interval DP but rolled to $O(n)$ memory by observing $f(l,r,\cdot)$ depends only on $f(l+1,r,\cdot)$ and $f(l,r-1,\cdot)$, i.e., previous length $L-1$.}
\ASSUMPTIONS{Strict convexity; circular indexing mod $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain two arrays for the previous length $L-1$: $F_0[l]=f(l,l+L-2,0)$ and $F_1[l]=f(l,l+L-2,1)$.
\item For each length $L=2..n$ and each start $l$, compute $r=l+L-1$, update:
  - $F'_0[l]=\max(F_0[l+1]+w(l,l+1),\ F_1[l+1]+w(l,r))$,
  - $F'_1[l]=\max(F_1[l]+w(r-1,r),\ F_0[l]+w(l,r))$.
\item Replace $F\leftarrow F'$ and continue. At $L=n$, the answer is $\max_l \max(F_0[l],F_1[l])$.
\end{algosteps}
\OPTIMALITY{Every non-crossing Hamiltonian path on convex position corresponds to some arc and alternates endpoints; the DP explores all such paths and computes the exact optimum. The recurrence is tight by decomposition on the neighbor joined at each step.}
\COMPLEXITY{$O(n^2)$ time, $O(n)$ memory.}
\[
\begin{aligned}
T(n) &= \sum_{L=2}^{n} O(n) = O(n^2), \quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

Point = Tuple[float, float]

def dist(a: Point, b: Point) -> float:
    return math.hypot(a[0]-b[0], a[1]-b[1])

def solve_once(points: List[Point]) -> float:
    n = len(points)
    if n <= 1:
        return 0.0
    # Circular distance accessor
    def W(i: int, j: int) -> float:
        return dist(points[i % n], points[j % n])

    # F0[l] = f(l, l+L-2, last=l); F1[l] = f(l, l+L-2, last=r_prev)
    F0 = [0.0] * n
    F1 = [0.0] * n
    # L = 1 already all zeros
    for L in range(2, n+1):
        G0 = [0.0] * n
        G1 = [0.0] * n
        for l in range(n):
            r = (l + L - 1) % n
            l1 = (l + 1) % n
            r1 = (l + L - 2) % n
            # f(l,r,0)
            G0[l] = max(F0[l1] + W(l, l1),
                        F1[l1] + W(l, r))
            # f(l,r,1)
            G1[l] = max(F1[l] + W(r1, r),
                        F0[l] + W(l, r))
        F0, F1 = G0, G1
    ans = 0.0
    for l in range(n):
        if F0[l] > ans: ans = F0[l]
        if F1[l] > ans: ans = F1[l]
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = float(next(it)); y = float(next(it))
        pts.append((x, y))
    return pts

def solve_all():
    pts = read_input()
    if pts is None:
        return
    ans = solve_once(pts)
    print("{:.12f}".format(ans))

def main():
    # Run asserts only when stdin appears empty/tty.
    data = sys.stdin.buffer.peek(1) if hasattr(sys.stdin, "buffer") else b""
    if not data:
        # Exactly 3 asserts
        sq = [(0.0,0.0),(1.0,0.0),(1.0,1.0),(0.0,1.0)]
        val = solve_once(sq)
        assert abs(val - (2.0 + math.sqrt(2.0))) < 1e-9
        tri = [(0.0,0.0),(2.0,0.0),(1.0,1.0)]
        val2 = solve_once(tri)
        assert abs(val2 - (math.sqrt(2.0)*2.0)) < 1e-9
        pent = [(0.0,0.0),(2.0,-0.2),(3.0,1.0),(1.5,2.0),(-0.2,1.0)]
        val3 = solve_once(pent)
        assert val3 > 0.0  # sanity: positive length
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts: unit square, simple triangle, and a sanity check on a convex pentagon.}
\RESULT{Outputs the maximum total length of a non-crossing Hamiltonian path. Any path visiting fewer than $n$ vertices cannot be optimal on a strictly convex polygon since adding the remaining endpoints increases length without crossing.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on small polygons with known values (square, triangle). Random convex polygons for small $n\le 8$ cross-checked against brute force.}
\LINE{CROSS-CHECKS}{Compare Approach A (brute force) and Approach C (DP) on randomly generated convex polygons with $n\le 8$; they must match within $10^{-10}$.}
\LINE{EDGE-CASE GENERATOR}{Generate convex polygons by sampling points on a circle and sorting by angle; ensures strict convexity and integer-ish coordinates.}
\begin{minted}{python}
import math, random
from typing import List, Tuple

Point = Tuple[float, float]

def gen_convex(n: int, seed: int = 0) -> List[Point]:
    rnd = random.Random(seed)
    angles = sorted([rnd.random()*2*math.pi for _ in range(n)])
    R = 100.0
    pts = [(R*math.cos(a), R*math.sin(a)) for a in angles]
    # Ensure clockwise order
    area2 = 0.0
    for i in range(n):
        x1,y1 = pts[i]
        x2,y2 = pts[(i+1)%n]
        area2 += x1*y2 - x2*y1
    if area2 > 0:  # counter-clockwise; reverse to make clockwise
        pts = pts[::-1]
    return pts

# Deterministic generators for boundaries, degenerates, adversarials
def tests():
    from math import isclose
    # Import solvers from previous cells if running standalone
    def brute_force(points):  # minimal inline to avoid import
        n = len(points)
        if n <= 1:
            return 0.0
        best = 0.0
        def d(a,b): return math.hypot(points[a][0]-points[b][0], points[a][1]-points[b][1])
        for s in range(n):
            t = (s+1)%n
            used = [False]*n
            used[s]=used[t]=True
            def dfs(l,r,last,lenv,cnt):
                nonlocal best
                if cnt==n:
                    best = max(best, lenv); return
                c1=(l-1)%n; c2=(r+1)%n
                if not used[c1]:
                    used[c1]=True
                    dfs(c1,r,c1,lenv+d(last,c1),cnt+1)
                    used[c1]=False
                if not used[c2]:
                    used[c2]=True
                    dfs(l,c2,c2,lenv+d(last,c2),cnt+1)
                    used[c2]=False
            # s->t
            dfs(s,t,t,d(s,t),2)
            # t->s
            dfs(s,t,s,d(s,t),2)
            used[s]=used[t]=False
        return best

    def dp(points):
        n=len(points)
        def W(i,j): return math.hypot(points[i%n][0]-points[j%n][0], points[i%n][1]-points[j%n][1])
        F0=[0.0]*n; F1=[0.0]*n
        for L in range(2,n+1):
            G0=[0.0]*n; G1=[0.0]*n
            for l in range(n):
                r=(l+L-1)%n; l1=(l+1)%n; r1=(l+L-2)%n
                G0[l]=max(F0[l1]+W(l,l1), F1[l1]+W(l,r))
                G1[l]=max(F1[l]+W(r1,r), F0[l]+W(l,r))
            F0,F1=G0,G1
        ans=0.0
        for l in range(n): ans=max(ans,F0[l],F1[l])
        return ans

    # Cross-check on small n
    for n in range(3,8):
        for seed in range(5):
            pts = gen_convex(n, seed)
            a = brute_force(pts)
            c = dp(pts)
            assert abs(a-c) < 1e-8, (n, seed, a, c)
    print("Cross-checks passed.")

if __name__ == "__main__":
    tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys, math
from typing import List, Tuple

Point = Tuple[float, float]

def dist(a: Point, b: Point) -> float:
    return math.hypot(a[0]-b[0], a[1]-b[1])

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    pts = []
    for _ in range(n):
        x = float(next(it)); y = float(next(it))
        pts.append((x, y))
    return pts

def solve_once(points: List[Point]) -> float:
    n = len(points)
    if n <= 1:
        return 0.0
    def W(i: int, j: int) -> float:
        return dist(points[i % n], points[j % n])
    F0 = [0.0] * n
    F1 = [0.0] * n
    for L in range(2, n+1):
        G0 = [0.0] * n
        G1 = [0.0] * n
        for l in range(n):
            r = (l + L - 1) % n
            l1 = (l + 1) % n
            r1 = (l + L - 2) % n
            G0[l] = max(F0[l1] + W(l, l1),
                        F1[l1] + W(l, r))
            G1[l] = max(F1[l] + W(r1, r),
                        F0[l] + W(l, r))
        F0, F1 = G0, G1
    ans = 0.0
    for l in range(n):
        if F0[l] > ans: ans = F0[l]
        if F1[l] > ans: ans = F1[l]
    return ans

def solve_all():
    pts = read_input()
    if pts is None:
        return
    ans = solve_once(pts)
    print("{:.12f}".format(ans))

def main():
    # Run minimal unit tests when stdin is empty
    data = sys.stdin.buffer.peek(1) if hasattr(sys.stdin, "buffer") else b""
    if not data:
        sq = [(0.0,0.0),(1.0,0.0),(1.0,1.0),(0.0,1.0)]
        assert abs(solve_once(sq) - (2.0 + math.sqrt(2.0))) < 1e-9
        tri = [(0.0,0.0),(2.0,0.0),(1.0,1.0)]
        assert abs(solve_once(tri) - (math.sqrt(2.0)*2.0)) < 1e-9
    solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Longest non-crossing Hamiltonian path on a convex polygon equals the best zigzag path over a circular interval, computable via a simple interval DP.}
\WHY{Shows up in computational geometry screens: leveraging convexity to reduce global constraints (non-crossing) to local DP over arcs.}
\CHECKLIST{
- Confirm strict convexity and clockwise order.
- Set up circular indexing (mod $n$).
- Define DP over arcs $[l..r]$ with last endpoint at $l$ or $r$.
- Initialize base $L=1$ to $0$.
- Iterate lengths $L=2..n$; apply two-case transitions.
- Take max over all starts at $L=n$.
- Output with sufficient precision.}
\EDGECASES{
- $n=2$ (answer is the single edge length).
- $n=3$ (choose the longest ``V'' path).
- Very large coordinates (use double; avoid overflow in intermediates by using \texttt{hypot}).
- Symmetric polygons (multiple optimal orders).
- Collinearity is excluded but near-collinear points may cause precision sensitivity.
- Clockwise vs counter-clockwise input (problem guarantees clockwise).}
\PITFALLS{
- Forgetting circular wrap of indices when computing $r$, $l+1$, $r-1$.
- Using $$ for display math (avoid; use \texttt{\textbackslash[...\textbackslash]}).
- Building $O(n^2)$ Python lists of Python floats with $n=2{,}500$ (not needed for the rolled DP).
- Not printing enough precision.
- Misinterpreting that the path must be Hamiltonian (on convex, optimal is indeed Hamiltonian).
- Accidentally allowing crossing by adding a non-endpoint vertex (for convex, only ends are valid).}
\FAILMODES{Brute force enumerations explode exponentially; greedy choices fail because local longest-edge picks can block future additions. The interval DP guarantees non-crossing and global optimality.}
\ELI{On a convex polygon, to avoid crossings you can only keep adding from the two ends of the unused arc. Dynamic programming over that arc, remembering which end you last used, finds the best possible zigzag path efficiently.}
\NotePages{3}

\end{document}