% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Traffic Light Controlled Intersection}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/traffic-light-controlled-intersection/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{Design a thread-safe class that controls a two-road intersection with a single traffic light.

There are exactly two one-way roads, labeled road $1$ and road $2$. At any moment, exactly one road has a green light; the other is red. Initially, the light is green for road $1$.

The system invokes the following method concurrently from multiple threads when a car arrives:
\begin{BreakableEquation*}
\texttt{carArrived(carId, roadId, direction, turnGreen, crossCar)}
\end{BreakableEquation*}
where:
\begin{bullets}
\item $\texttt{carId}$ is an integer identifier of the car.
\item $\texttt{roadId} \in \{1,2\}$ is the road on which the car arrives.
\item $\texttt{direction} \in \{1,2,3\}$ represents the intended maneuver (right, straight, left). For this problem, any car on the green road may safely proceed, so the direction does not affect synchronization logic.
\item $\texttt{turnGreen}$ is a callback that, when invoked, switches the green light to the caller's road immediately.
\item $\texttt{crossCar}$ is a callback that lets the current car cross the intersection.
\end{bullets}

Implement the class so that:
\begin{bullets}
\item No two cars cross in a conflicting way; a car crosses only when its road has the green light.
\item The number of times $\texttt{turnGreen}$ is called is minimized; i.e., call $\texttt{turnGreen}$ only when the arriving car's road is not currently green.
\end{bullets}

You may assume that the runtime will call $\texttt{carArrived}$ for each car once, possibly from different threads, and that the callbacks are provided by the judge.}
\BREAKDOWN{We must maintain a shared state indicating which road is currently green, protect that state with mutual exclusion so that changes and crossings are atomic, and ensure we call the provided $\texttt{turnGreen}$ only when switching from one road to the other.}
\ELI{Keep a lock and a variable storing which road is green; if a car is on the green road, let it cross; otherwise, switch the light and then let it cross.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{This is a concurrency design problem:
\begin{bullets}
\item Class constructor: $\texttt{TrafficLight()}$ initializes the traffic light with road $1$ green.
\item Method: $\texttt{carArrived(carId: int, roadId: int, direction: int, turnGreen: Callable[[], None], crossCar: Callable[[], None]) -> None}$ is invoked by the runtime for each arriving car, possibly concurrently.
\end{bullets}}
\OUTPUTS{No return values. The correct behavior is realized by invoking the callbacks in a thread-safe manner:
\begin{bullets}
\item If $\texttt{roadId}$ is already green, call $\texttt{crossCar()}$.
\item Otherwise, call $\texttt{turnGreen()}$ exactly once to switch the green to $\texttt{roadId}$, then call $\texttt{crossCar()}$.
\end{bullets}}
\SAMPLES{Example scenario 1 (sequential arrivals):
\begin{bullets}
\item Arrivals: $(\text{car }1, \text{road }1)$, $(\text{car }2, \text{road }1)$, $(\text{car }3, \text{road }2)$.
\item Action: cars $1$ and $2$ cross without switching; then switch once and car $3$ crosses.
\end{bullets}
Example scenario 2 (concurrent arrivals):
\begin{bullets}
\item Arrivals: $(\text{car }10, \text{road }2)$ and $(\text{car }11, \text{road }1)$ at the same time; initial green is road $1$.
\item Valid outcome: car $11$ crosses first without a switch; then switch once and car $10$ crosses.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $G \in \{1,2\}$ denote the road that currently has the green light. Each arriving car $i$ comes with its road $r_i \in \{1,2\}$. The controller must ensure:
\begin{BreakableEquation*}
\text{If } r_i \ne G \text{ then set } G \gets r_i \text{ (by calling turnGreen) before crossing.}
\end{BreakableEquation*}
All updates and crossings are executed under mutual exclusion so that the sequence of green states and crossings is linearizable.}
\varmapStart
\var{G}{current green road (shared state)}
\var{r_i}{road of arriving car $i$}
\var{\text{lock}}{mutual exclusion primitive protecting $G$ and the callbacks}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Upon car } i \text{ arrival: }&
\begin{cases}
\text{crossCar}() & \text{if } r_i = G,\\
\text{turnGreen}();~G \gets r_i;~\text{crossCar}() & \text{if } r_i \ne G.
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{Single intersection; two roads; initially $G=1$; callbacks are well-behaved and return promptly; direction does not affect safety in this abstraction.}
\INVARIANTS{
\begin{bullets}
\item Safety: Every $\texttt{crossCar}()$ occurs with $G$ equal to the crossing car's road.
\item Minimality: $\texttt{turnGreen}()$ is called if and only if the crossing car's road differs from the current $G$.
\item Mutual exclusion: All reads/writes of $G$ and invocations of the callbacks happen while holding the lock.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Maintain a single shared variable $G$ and a single mutex. On each arrival, acquire the lock, switch if needed, then cross.}
\ASSUMPTIONS{The callbacks are synchronous and safe to call while holding the mutex.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $G \gets 1$ and create a global mutex.
\item On $\texttt{carArrived}$: acquire the mutex.
\item If $G \ne \texttt{roadId}$, call $\texttt{turnGreen}()$ and set $G \gets \texttt{roadId}$.
\item Call $\texttt{crossCar}()$; release the mutex.
\end{algosteps}
\COMPLEXITY{Each arrival performs $O(1)$ work under the mutex.}
\[
\begin{aligned}
T(\text{per car}) &= O(1), \quad S(\text{shared}) = O(1).
\end{aligned}
\]
\CORRECTNESS{The lock serializes updates to $G$ and the callbacks. Because we only call $\texttt{turnGreen}$ when $G \ne \texttt{roadId}$, switches are minimized and safety holds.}
\EDGECASES{Multiple cars from the same road arriving concurrently; the first car sets $G$ (or leaves it), others proceed without extra switches. Cars from both roads arriving concurrently are ordered by the lock, producing at most one switch at the boundary where the green road changes.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LeetCode-style concurrency class + local tests.
# Including a dummy Solution class to satisfy environments that expect it.

import threading
from typing import Callable, List, Tuple

class Solution:
    pass

class TrafficLightA:
    def __init__(self):
        self.green = 1
        self.lock = threading.Lock()

    def carArrived(
        self,
        carId: int,
        roadId: int,
        direction: int,
        turnGreen: Callable[[], None],
        crossCar: Callable[[], None]
    ) -> None:
        with self.lock:
            if self.green != roadId:
                turnGreen()
                self.green = roadId
            crossCar()

# --- Tests (deterministic properties) ---

def simulate_and_check_A(arrivals: List[Tuple[int, int, int]]):
    """
    arrivals: list of (carId, roadId, direction)
    Checks:
      - No crossing occurs unless observed green == roadId.
      - Number of switches equals boundaries between consecutive crosses,
        with initial green == 1.
    """
    tl = TrafficLightA()
    events = []  # records ('turn', road), ('cross', carId, road)
    observed = {"green": 1}
    n = len(arrivals)
    barrier = threading.Barrier(n) if n > 0 else None

    def make_turn(road: int):
        def f():
            # Switch observed green for assertions and record the event.
            observed["green"] = road
            events.append(("turn", road))
        return f

    def make_cross(car: int, road: int):
        def f():
            # Safety: can only cross on green.
            assert observed["green"] == road, (
                f"Car {car} crossing on road {road} while green={observed['green']}"
            )
            events.append(("cross", car, road))
        return f

    threads = []
    for carId, roadId, direction in arrivals:
        def worker(cid=carId, rid=roadId, d=direction):
            if barrier: barrier.wait()
            tl.carArrived(cid, rid, d, make_turn(rid), make_cross(cid, rid))
        t = threading.Thread(target=worker)
        threads.append(t)
        t.start()
    for t in threads:
        t.join()

    # Compute expected minimal switches from the realized cross order.
    crosses = [e for e in events if e[0] == "cross"]
    switches = len([e for e in events if e[0] == "turn"])
    if not crosses:
        assert switches == 0
        return

    expected = 0
    prev = 1  # initial green
    for _, _, r in crosses:
        if r != prev:
            expected += 1
            prev = r
    assert switches == expected, (switches, expected)

# Tiny validations
simulate_and_check_A([(1,1,1), (2,1,2), (3,2,3)])
simulate_and_check_A([(10,2,1), (11,1,2), (12,2,3), (13,2,1)])
\end{minted}
\VALIDATION{Validated on:
\begin{bullets}
\item Three cars where two are on road $1$ then one on road $2$; zero then one switch.
\item Interleaved roads; the number of switches equals the number of road changes seen in actual crossing order, starting from green $=1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Critical Section}
\WHICHFORMULA{Keep the same mutual exclusion but keep the critical section minimal and branchless in terms of calling $\texttt{turnGreen}$ only on inequality; identical asymptotics but clean and safe.}
\ASSUMPTIONS{Callbacks are fast; a single mutex suffices to linearize the state and the callbacks.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Track a shared $G$ and a mutex.
\item Upon arrival, acquire the mutex.
\item If $G \ne \texttt{roadId}$, perform exactly one switch and update $G$.
\item Cross and release the mutex.
\end{algosteps}
\COMPLEXITY{Same as baseline: $O(1)$ per arrival; $O(1)$ space. It minimizes context switching in user code by avoiding extra checks outside the lock.}
\[
\begin{aligned}
T(n) &= O(n) \text{ over } n \text{ cars}, \quad S(n) = O(1).
\end{aligned}
\]
\CORRECTNESS{The single lock provides linearizability. The inequality guard preserves minimal switching and safety.}
\textbf{Code (Improved)}
\begin{minted}{python}
import threading
from typing import Callable, List, Tuple

class Solution:
    pass

class TrafficLightB:
    def __init__(self):
        self._green = 1
        self._mtx = threading.Lock()

    def carArrived(
        self,
        carId: int,
        roadId: int,
        direction: int,
        turnGreen: Callable[[], None],
        crossCar: Callable[[], None]
    ) -> None:
        with self._mtx:
            need_switch = (self._green != roadId)
            if need_switch:
                turnGreen()
                self._green = roadId
            crossCar()

# --- Tests identical to Approach A but run on TrafficLightB ---

def simulate_and_check_B(arrivals: List[Tuple[int, int, int]]):
    tl = TrafficLightB()
    events = []
    observed = {"green": 1}
    n = len(arrivals)
    barrier = threading.Barrier(n) if n > 0 else None

    def make_turn(road: int):
        def f():
            observed["green"] = road
            events.append(("turn", road))
        return f

    def make_cross(car: int, road: int):
        def f():
            assert observed["green"] == road
            events.append(("cross", car, road))
        return f

    threads = []
    for carId, roadId, direction in arrivals:
        def worker(cid=carId, rid=roadId, d=direction):
            if barrier: barrier.wait()
            tl.carArrived(cid, rid, d, make_turn(rid), make_cross(cid, rid))
        t = threading.Thread(target=worker)
        threads.append(t)
        t.start()
    for t in threads:
        t.join()

    crosses = [e for e in events if e[0] == "cross"]
    switches = len([e for e in events if e[0] == "turn"])
    if not crosses:
        assert switches == 0
        return
    expected = 0
    prev = 1
    for _, _, r in crosses:
        if r != prev:
            expected += 1
            prev = r
    assert switches == expected

# Validations
simulate_and_check_B([(1,1,1), (2,2,2), (3,2,1), (4,1,3)])
simulate_and_check_B([(5,2,1), (6,2,2), (7,2,3)])
\end{minted}
\VALIDATION{Checked safety and minimal switch count on mixed and single-road batches.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Minimal Switching with a Mutex}
\WHICHFORMULA{Single shared state $G$ guarded by a mutex; switch if and only if $G \ne \texttt{roadId}$, then cross. This achieves the minimal number of switches for any realized crossing order.}
\ASSUMPTIONS{Two-road intersection; callbacks are properly synchronized with the external simulator; initial green is road $1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $G \gets 1$ and a mutex.
\item For each arrival, under the mutex, compare $G$ to the car's $\texttt{roadId}$.
\item If different, call $\texttt{turnGreen}()$ and set $G \gets \texttt{roadId}$.
\item Call $\texttt{crossCar}()$ and release the mutex.
\end{algosteps}
\OPTIMALITY{Given any linearization of crossings, the minimal number of switches equals the number of times consecutive crossed roads differ, counting a possible initial switch if the first crossed road is $2$ while $G=1$. The algorithm performs exactly that number of switches, hence is optimal.}
\COMPLEXITY{$O(1)$ per car; $O(1)$ space.}
\[
\begin{aligned}
T(n) &= \Theta(n), \quad S(n) = \Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import threading
from typing import Callable, List, Tuple

class Solution:
    pass

class TrafficLight:
    def __init__(self):
        self.green = 1
        self.lock = threading.Lock()

    def carArrived(
        self,
        carId: int,
        roadId: int,
        direction: int,
        turnGreen: Callable[[], None],
        crossCar: Callable[[], None]
    ) -> None:
        with self.lock:
            if self.green != roadId:
                turnGreen()
                self.green = roadId
            crossCar()

# --- Minimal deterministic validations ---

def simulate_and_check_Final(arrivals: List[Tuple[int, int, int]]):
    tl = TrafficLight()
    events = []
    observed = {"green": 1}
    n = len(arrivals)
    barrier = threading.Barrier(n) if n > 0 else None

    def make_turn(road: int):
        def f():
            observed["green"] = road
            events.append(("turn", road))
        return f

    def make_cross(car: int, road: int):
        def f():
            assert observed["green"] == road
            events.append(("cross", car, road))
        return f

    threads = []
    for carId, roadId, direction in arrivals:
        def worker(cid=carId, rid=roadId, d=direction):
            if barrier: barrier.wait()
            tl.carArrived(cid, rid, d, make_turn(rid), make_cross(cid, rid))
        t = threading.Thread(target=worker)
        threads.append(t)
        t.start()
    for t in threads:
        t.join()

    crosses = [e for e in events if e[0] == "cross"]
    switches = len([e for e in events if e[0] == "turn"])
    if not crosses:
        assert switches == 0
        return
    expected = 0
    prev = 1
    for _, _, r in crosses:
        if r != prev:
            expected += 1
            prev = r
    assert switches == expected

# Exactly 3 assertions via three scenarios
simulate_and_check_Final([(1,1,1), (2,1,2), (3,2,3)])
simulate_and_check_Final([(10,2,1), (11,1,2)])
simulate_and_check_Final([(20,2,1), (21,2,2), (22,1,3), (23,1,1), (24,2,2)])
\end{minted}
\VALIDATION{Three scenarios:
\begin{bullets}
\item Same-road batch then other road: one switch.
\item Concurrent mixed pair: at most one switch given initial green $=1$.
\item Mixed batch: switches equal boundaries in realized cross order.
\end{bullets}}
\RESULT{A thread-safe controller with minimal green-switch invocations: switch only when the incoming car is on the non-green road.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Property-based checks:
\begin{bullets}
\item Safety: no crossing occurs when observed green $\ne$ car's road.
\item Minimality: number of switches equals road-change boundaries in realized cross order with initial green $=1$.
\item Stress: random interleavings using a barrier to start threads together.
\end{bullets}}
\LINE{CROSS-CHECKS}{Run the same random scenarios through Approaches A, B, and C; all must satisfy the same safety and minimality properties.}
\LINE{EDGE-CASE GENERATOR}{Create sequences with: all cars on one road; strict alternation between roads; bursts from one road followed by a single car from the other road; empty sequence.}
\begin{minted}{python}
import threading
import random
from typing import Callable, List, Tuple

class Solution:
    pass

class TrafficLight:
    def __init__(self):
        self.green = 1
        self.lock = threading.Lock()

    def carArrived(
        self,
        carId: int,
        roadId: int,
        direction: int,
        turnGreen: Callable[[], None],
        crossCar: Callable[[], None]
    ) -> None:
        with self.lock:
            if self.green != roadId:
                turnGreen()
                self.green = roadId
            crossCar()

def gen_scenarios(seed: int = 7) -> List[List[Tuple[int,int,int]]]:
    random.seed(seed)
    scenarios = []
    # Empty
    scenarios.append([])
    # All on road 1
    scenarios.append([(i,1,random.randint(1,3)) for i in range(1,6)])
    # All on road 2
    scenarios.append([(i,2,random.randint(1,3)) for i in range(10,15)])
    # Alternating
    scenarios.append([(i,1 + (i % 2), random.randint(1,3)) for i in range(20,30)])
    # Bursts
    scenarios.append([(30,1,1),(31,1,2),(32,1,3),(33,2,1)])
    # Random mix
    mix = []
    for i in range(40,55):
        rid = random.choice([1,2])
        mix.append((i, rid, random.randint(1,3)))
    scenarios.append(mix)
    return scenarios

def check_scenario(arrivals: List[Tuple[int,int,int]]):
    tl = TrafficLight()
    events = []
    observed = {"green": 1}
    n = len(arrivals)
    barrier = threading.Barrier(n) if n > 0 else None

    def make_turn(road: int):
        def f():
            observed["green"] = road
            events.append(("turn", road))
        return f

    def make_cross(car: int, road: int):
        def f():
            assert observed["green"] == road
            events.append(("cross", car, road))
        return f

    threads = []
    for carId, roadId, direction in arrivals:
        def worker(cid=carId, rid=roadId, d=direction):
            if barrier: barrier.wait()
            tl.carArrived(cid, rid, d, make_turn(rid), make_cross(cid, rid))
        t = threading.Thread(target=worker)
        threads.append(t)
        t.start()
    for t in threads:
        t.join()

    crosses = [e for e in events if e[0] == "cross"]
    switches = len([e for e in events if e[0] == "turn"])
    if not crosses:
        assert switches == 0
        return True
    expected = 0
    prev = 1
    for _, _, r in crosses:
        if r != prev:
            expected += 1
            prev = r
    assert switches == expected
    return True

# Run cross-checks
for scen in gen_scenarios():
    assert check_scenario(scen)

print("All reference tests passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import threading
from typing import Callable

class Solution:
    pass

class TrafficLight:
    def __init__(self):
        self.green = 1  # initial green road
        self.lock = threading.Lock()

    def carArrived(
        self,
        carId: int,
        roadId: int,
        direction: int,
        turnGreen: Callable[[], None],
        crossCar: Callable[[], None]
    ) -> None:
        # Serialize state changes and callbacks.
        with self.lock:
            if self.green != roadId:
                turnGreen()
                self.green = roadId
            crossCar()

# Simple self-check when run locally (not part of LC submission)
if __name__ == "__main__":
    import threading

    tl = TrafficLight()
    events = []
    observed = {"green": 1}
    arrivals = [(1,1,1),(2,2,2),(3,2,3),(4,1,1)]
    barrier = threading.Barrier(len(arrivals))

    def make_turn(road: int):
        def f():
            observed["green"] = road
            events.append(("turn", road))
        return f

    def make_cross(car: int, road: int):
        def f():
            assert observed["green"] == road
            events.append(("cross", car, road))
        return f

    threads = []
    for cid, rid, d in arrivals:
        def worker(c=cid, r=rid, di=d):
            barrier.wait()
            tl.carArrived(c, r, di, make_turn(r), make_cross(c, r))
        t = threading.Thread(target=worker)
        threads.append(t); t.start()
    for t in threads: t.join()

    # Expect switches equal to boundaries in realized crossing order (initial green=1).
    crosses = [e for e in events if e[0] == "cross"]
    switches = len([e for e in events if e[0] == "turn"])
    expected = 0
    prev = 1
    for _, _, r in crosses:
        if r != prev:
            expected += 1
            prev = r
    assert switches == expected
    print("OK")
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Guard a single shared green-light variable with a mutex; switch only if needed; then cross.}
\WHY{Common LC concurrency problem testing mutual exclusion, linearizability, and minimizing extraneous state changes under contention.}
\CHECKLIST{
\begin{bullets}
\item Initialize $G=1$.
\item Acquire mutex on arrival.
\item If $G \ne \texttt{roadId}$ then call $\texttt{turnGreen}()$ and set $G$.
\item Call $\texttt{crossCar}()$.
\item Release mutex.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Many cars from the same road: zero switches after the first car.
\item First car on road $2$: exactly one initial switch.
\item Strict alternation of roads: one switch per boundary.
\item No cars: zero switches.
\item Simultaneous arrivals from both roads: exactly one switch at the ordered boundary.
\item Long burst from one road followed by one car from the other: exactly one switch.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to protect both checking and switching under the same lock.
\item Calling $\texttt{turnGreen}$ unconditionally, causing extra switches.
\item Updating the local state after $\texttt{turnGreen}$ outside the lock.
\item Allowing crossing before switching completes.
\item Using multiple locks leading to deadlocks or inconsistent $G$.
\item Assuming arrival order equals crossing order without synchronization.
\end{bullets}}
\FAILMODES{Approaches without mutual exclusion can interleave checks and switches, letting a car cross on a red light or causing redundant switches. This solution serializes the critical section, preserving safety and minimality.}
\ELI{Think of one big lever that flips between road $1$ and road $2$. Only one person can hold it at a time. If it is already pointing your way, go; otherwise, flip it once and then go.}
\NotePages{3}

\end{document}