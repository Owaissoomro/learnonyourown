% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Average Salary: Departments VS Company}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/average-salary-departments-vs-company/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given a collection of employees, each with a department identifier and a salary, report all departments whose average salary is strictly greater than the company\textquotesingle s overall average salary. Output the department identifiers in increasing order.}
\BREAKDOWN{Compute the overall company average salary, then compute each department\textquotesingle s average salary, and select those departments where the department average exceeds the overall average. Use precise arithmetic to avoid floating-point pitfalls.}
\ELI{Find which departments pay, on average, more than the company average.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array/list of employee records. For algorithmic purposes here, each record is a pair $(d, s)$ where $d$ is an integer department\_id and $s$ is an integer salary. Constraints: $1 \le d \le 10^{9}$, $1 \le s \le 10^{9}$, and the number of employees $N$ satisfies $0 \le N \le 2\cdot 10^{5}$.}
\OUTPUTS{A list of distinct department\_id values sorted in increasing order such that for each returned department $d$, the average salary of employees in $d$ is strictly greater than the average salary across all employees. If $N=0$, return an empty list. Ties (equal averages) are not included.}
\SAMPLES{Example 1: input employees $=[(1,100),(1,200),(2,300),(2,400)]$ has company average $250$; department $1$ average $150$, department $2$ average $350$; output $[2]$. Example 2: input employees $=[(1,10),(2,10),(3,10)]$ has equal averages; output $[]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the set of employees be $E=\{1,\ldots,N\}$. Each employee $i$ has department $d(i)\in\mathbb{Z}_{>0}$ and salary $s(i)\in\mathbb{Z}_{>0}$. For each department $g$, define $E_g=\{i\in E:\ d(i)=g\}$, $n_g=\lvert E_g\rvert$, and $S_g=\sum_{i\in E_g}s(i)$. Let $S=\sum_{i\in E}s(i)$. We seek all $g$ such that $\dfrac{S_g}{n_g}>\dfrac{S}{N}$.}
\varmapStart
\var{N}{number of employees}
\var{d(i)}{department id of employee $i$}
\var{s(i)}{salary of employee $i$}
\var{E_g}{employee indices in department $g$}
\var{n_g}{size of department $g$}
\var{S_g}{sum of salaries in department $g$}
\var{S}{sum of all salaries}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Select department } g \text{ if and only if } S_g \cdot N > S \cdot n_g.
\end{BreakableEquation*}
}
\ASSUMPTIONS{All salaries are positive integers; departments with no employees do not appear. Comparison uses exact integer arithmetic to avoid rounding artifacts.}
\INVARIANTS{Each employee contributes exactly once to exactly one department. The totals satisfy $\sum_g S_g=S$ and $\sum_g n_g=N$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute averages by grouping after sorting employees by department. Compare department average to company average using floating-point for simplicity.}
\ASSUMPTIONS{Sorting-based grouping; acceptable $O(N\log N)$ due to sort. Floating-point precision is acceptable for small inputs but can be risky in edge cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $S=\sum s$ and $N=\lvert E\rvert$, then company average $\mu=S/N$ if $N>0$.
\item Sort employees by department id.
\item Scan the sorted list, accumulating per-department sum and count; when a department ends, compare its average to $\mu$ and record if larger.
\end{algosteps}
\COMPLEXITY{Sorting dominates.}
\[
\begin{aligned}
T(N) &= O(N \log N) \text{ for sort } + O(N) \text{ for the scan} = O(N\log N),\\
S(N) &= O(1) \text{ extra besides input and output (if sorting in-place, }O(1)\text{; else }O(N)\text{ for a copy).}
\end{aligned}
\]
\CORRECTNESS{Sorting groups equal department ids contiguously; the one pass computes exact sums and counts per group; comparing to the precomputed company average yields the correct selection.}
\EDGECASES{If $N=0$, return empty. Departments with a single employee are valid. Equal averages are excluded (strict inequality). Large salaries may risk float precision.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def departments_above_company_average(self, employees: List[Tuple[int, int]]) -> List[int]:
        # Baseline: sort by department, use float averages
        n = len(employees)
        if n == 0:
            return []
        total_sum = sum(s for _, s in employees)
        company_avg = total_sum / n

        # Work on a copy to avoid mutating caller input
        arr = list(employees)
        arr.sort(key=lambda x: x[0])

        res = []
        cur_dept = None
        cur_sum = 0
        cur_cnt = 0

        def flush():
            nonlocal cur_dept, cur_sum, cur_cnt
            if cur_dept is None:
                return
            dept_avg = cur_sum / cur_cnt
            if dept_avg > company_avg:
                res.append(cur_dept)
            # reset
            cur_dept = None
            cur_sum = 0
            cur_cnt = 0

        for d, s in arr:
            if cur_dept is None:
                cur_dept = d
            if d != cur_dept:
                flush()
                cur_dept = d
            cur_sum += s
            cur_cnt += 1
        flush()
        res.sort()
        return res

if __name__ == "__main__":
    sol = Solution()
    assert sol.departments_above_company_average([(1, 100), (1, 200), (2, 300), (2, 400)]) == [2]
    assert sol.departments_above_company_average([(1, 10), (2, 10), (3, 10)]) == []
    assert sol.departments_above_company_average([]) == []
\end{minted}
\VALIDATION{Checked empty input, equal-averages case, and a mixed case where exactly one department exceeds the company average.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Avoid sorting by aggregating per-department sums and counts using a hash map in a single pass, then compare to the company average.}
\ASSUMPTIONS{Hash map for grouping yields linear time on average. Still uses float averages for clarity.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Single pass to compute $S$ and a map $g\mapsto(S_g, n_g)$.
\item Compute $\mu=S/N$.
\item Iterate departments and compare $S_g/n_g$ to $\mu$; collect winners and sort ids at the end.
\end{algosteps}
\COMPLEXITY{Linear time and space.}
\[
\begin{aligned}
T(N) &= O(N) \text{ expected},\\
S(N) &= O(D) \text{ where } D \text{ is the number of departments}.
\end{aligned}
\]
\CORRECTNESS{Each employee contributes once to exactly one department\textquotesingle s sum and count; comparison to the global average yields the intended filter.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Dict

class Solution:
    def departments_above_company_average(self, employees: List[Tuple[int, int]]) -> List[int]:
        n = len(employees)
        if n == 0:
            return []
        total_sum = 0
        sums: Dict[int, int] = {}
        cnts: Dict[int, int] = {}
        for d, s in employees:
            total_sum += s
            sums[d] = sums.get(d, 0) + s
            cnts[d] = cnts.get(d, 0) + 1
        company_avg = total_sum / n
        res = []
        for d in sums.keys():
            if (sums[d] / cnts[d]) > company_avg:
                res.append(d)
        res.sort()
        return res

if __name__ == "__main__":
    sol = Solution()
    assert sol.departments_above_company_average([(1, 100), (1, 200), (2, 300), (2, 400)]) == [2]
    assert sol.departments_above_company_average([(1, 10), (2, 10), (3, 10)]) == []
    assert sol.departments_above_company_average([]) == []
\end{minted}
\VALIDATION{Same sanity checks as baseline; behavior is identical while avoiding sorting.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use one pass to aggregate and compare averages using integer arithmetic without division: select $g$ if and only if $S_g \cdot N > S \cdot n_g$.}
\ASSUMPTIONS{All inputs are integers; comparison via cross-multiplication avoids floating-point precision issues and division by zero.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Aggregate $S$ and per-department $(S_g, n_g)$ in one pass.
\item For each department $g$, test $S_g \cdot N > S \cdot n_g$.
\item Return the sorted list of qualifying department ids.
\end{algosteps}
\OPTIMALITY{Any solution must inspect each employee at least once, implying an $\Omega(N)$ lower bound. This approach is $O(N)$ time and $O(D)$ space, which is optimal up to constant factors for arbitrary input.}
\COMPLEXITY{Linear time and space.}
\[
\begin{aligned}
T(N) &= O(N), \\
S(N) &= O(D).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple, Dict

class Solution:
    def departments_above_company_average(self, employees: List[Tuple[int, int]]) -> List[int]:
        n = len(employees)
        if n == 0:
            return []
        total_sum = 0
        sums: Dict[int, int] = {}
        cnts: Dict[int, int] = {}
        for d, s in employees:
            total_sum += s
            sums[d] = sums.get(d, 0) + s
            cnts[d] = cnts.get(d, 0) + 1
        res = []
        # Compare using cross-multiplication to avoid floating error
        for d, ssum in sums.items():
            if ssum * n > total_sum * cnts[d]:
                res.append(d)
        res.sort()
        return res

if __name__ == "__main__":
    sol = Solution()
    assert sol.departments_above_company_average([(1, 100), (1, 200), (2, 300), (2, 400)]) == [2]
    assert sol.departments_above_company_average([(1, 10), (2, 10), (3, 10)]) == []
    assert sol.departments_above_company_average([]) == []
\end{minted}
\VALIDATION{Three asserts: a mixed case, an all-equal case, and an empty case.}
\RESULT{Return all department ids with strictly higher average than the overall company average, sorted in increasing order; ties are excluded.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: empty input; single department; multiple departments with one, many employees; equal averages; large values to ensure no overflow in Python int and correctness without floating-point.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A, B, and C on random small cases; they must match.}
\LINE{EDGE-CASE GENERATOR}{Produce deterministic random employee lists with controlled department counts and salary ranges to hit boundaries (e.g., all equal salaries, one dominant department).}
\begin{minted}{python}
from typing import List, Tuple
import random

def gen_case(n: int, dmax: int, seed: int) -> List[Tuple[int, int]]:
    rng = random.Random(seed)
    return [(rng.randint(1, dmax), rng.randint(1, 10**6)) for _ in range(n)]

class A:
    # Baseline implementation (sorting + float)
    def departments_above_company_average(self, employees: List[Tuple[int, int]]) -> List[int]:
        n = len(employees)
        if n == 0:
            return []
        total_sum = sum(s for _, s in employees)
        company_avg = total_sum / n
        arr = list(employees)
        arr.sort(key=lambda x: x[0])
        res = []
        cur_dept = None
        cur_sum = 0
        cur_cnt = 0
        def flush():
            nonlocal cur_dept, cur_sum, cur_cnt
            if cur_dept is None:
                return
            if (cur_sum / cur_cnt) > company_avg:
                res.append(cur_dept)
            cur_dept = None
            cur_sum = 0
            cur_cnt = 0
        for d, s in arr:
            if cur_dept is None:
                cur_dept = d
            if d != cur_dept:
                flush()
                cur_dept = d
            cur_sum += s
            cur_cnt += 1
        flush()
        res.sort()
        return res

class B:
    # Improved (hash maps + float)
    def departments_above_company_average(self, employees: List[Tuple[int, int]]) -> List[int]:
        n = len(employees)
        if n == 0:
            return []
        total_sum = 0
        sums = {}
        cnts = {}
        for d, s in employees:
            total_sum += s
            sums[d] = sums.get(d, 0) + s
            cnts[d] = cnts.get(d, 0) + 1
        company_avg = total_sum / n
        res = [d for d in sums if (sums[d] / cnts[d]) > company_avg]
        res.sort()
        return res

class C:
    # Optimal (hash maps + integer comparison)
    def departments_above_company_average(self, employees: List[Tuple[int, int]]) -> List[int]:
        n = len(employees)
        if n == 0:
            return []
        total_sum = 0
        sums = {}
        cnts = {}
        for d, s in employees:
            total_sum += s
            sums[d] = sums.get(d, 0) + s
            cnts[d] = cnts.get(d, 0) + 1
        res = [d for d, ssum in sums.items() if ssum * n > total_sum * cnts[d]]
        res.sort()
        return res

def cross_check():
    for seed in range(25):
        emps = gen_case(n=50, dmax=7, seed=seed)
        a = A().departments_above_company_average(emps)
        b = B().departments_above_company_average(emps)
        c = C().departments_above_company_average(emps)
        assert a == c, (seed, a, c)
        assert b == c, (seed, b, c)
    # Edge constructions
    assert C().departments_above_company_average([]) == []
    assert C().departments_above_company_average([(1, 10), (2, 10), (3, 10)]) == []
    assert C().departments_above_company_average([(1, 100), (2, 1), (2, 1)]) == [1]

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple, Dict

class Solution:
    def departments_above_company_average(self, employees: List[Tuple[int, int]]) -> List[int]:
        """
        Return sorted department ids whose average salary is strictly greater than the company average.
        employees: list of (dept_id, salary) pairs.
        """
        n = len(employees)
        if n == 0:
            return []
        total_sum = 0
        sums: Dict[int, int] = {}
        cnts: Dict[int, int] = {}
        for d, s in employees:
            total_sum += s
            sums[d] = sums.get(d, 0) + s
            cnts[d] = cnts.get(d, 0) + 1
        # Compare by cross-multiplication to avoid floating-point issues
        winners = [d for d, ssum in sums.items() if ssum * n > total_sum * cnts[d]]
        winners.sort()
        return winners

if __name__ == "__main__":
    sol = Solution()
    assert sol.departments_above_company_average([(1, 100), (1, 200), (2, 300), (2, 400)]) == [2]
    assert sol.departments_above_company_average([(1, 10), (2, 10), (3, 10)]) == []
    assert sol.departments_above_company_average([]) == []
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute departments whose average salary exceeds the company\textquotesingle s overall average, using exact comparisons.}
\WHY{Common theme: group-by aggregation and average comparison. Interviewers test careful handling of averages without precision loss and efficient one-pass aggregation.}
\CHECKLIST{%
\begin{bullets}
\item Count $N$ and sum $S$ across all employees.
\item Aggregate per-department sums and counts.
\item Compare via $S_g \cdot N > S \cdot n_g$.
\item Sort department ids in the output.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $N=0$.
\item Single employee.
\item Single department with many employees.
\item Many departments with one employee each.
\item All salaries equal (no winners).
\item Large salaries and counts (avoid overflow and float error).
\item Department average equal to company average (exclude).
\item Non-contiguous department ids.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Dividing by zero when $N=0$.
\item Using floats and getting equality misclassified due to rounding.
\item Forgetting to reset accumulators between departments in a sorted scan.
\item Not sorting the output as required.
\item Integer division truncation in some languages.
\item Overflow in fixed-width integer languages during cross-multiplication (use 64-bit or big ints).
\item Double-counting an employee or missing one in aggregation.
\item Mutating the input list inadvertently.
\end{bullets}
}
\FAILMODES{Inputs with very large salaries can break float-based approaches; integer cross-multiplication remains correct. Highly skewed department sizes can also reveal float precision issues that the optimal method avoids.}
\ELI{Group everyone by department, compute what each department pays on average, compute what the whole company pays on average, and keep only departments that beat the company average. Compare with integer math to be perfectly accurate.}
\NotePages{3}

\end{document}