% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Balanced Reversals}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1237/H}}
\LINE{DIFFICULTY / RATING}{3300}
\STATEMENT{You have two strings $a$ and $b$ of equal even length $n$ consisting of characters 0 and 1.

We are in the endgame now. To finally make the universe perfectly balanced, you need to make strings $a$ and $b$ equal.

In one step, you can choose any prefix of $a$ of even length and reverse it. Formally, if $a = a_1 a_2 \ldots a_n$, you can choose a positive even integer $p \le n$ and set $a$ to $a_p a_{p-1} \ldots a_1 a_{p+1} a_{p+2} \ldots a_n$.

Find a way to make $a$ equal to $b$ using at most $n + 1$ reversals of the above kind, or determine that such a way does not exist. The number of reversals does not have to be minimized.

Input:
The first line contains a single integer $t$ ($1 \le t \le 2000$), denoting the number of test cases.

Each test case consists of two lines. The first line contains a string $a$ of length $n$, and the second line contains a string $b$ of the same length ($2 \le n \le 4000$; $n \bmod 2 = 0$). Both strings consist of characters 0 and 1.

The sum of $n$ over all $t$ test cases does not exceed $4000$.

Output:
For each test case, if it is impossible to make $a$ equal to $b$ in at most $n + 1$ reversals, output a single integer $-1$.

Otherwise, output an integer $k$ ($0 \le k \le n + 1$), denoting the number of reversals in your sequence of steps, followed by $k$ even integers $p_1, p_2, \ldots, p_k$ ($2 \le p_i \le n$; $p_i \bmod 2 = 0$), denoting the lengths of prefixes of $a$ to be reversed, in chronological order.

Note that $k$ does not have to be minimized. If there are many solutions, output any of them.

Note:
In the first test case, string $a$ changes as follows:

- after the first reversal: 1000101011;
- after the second reversal: 0001101011;
- after the third reversal: 1101011000.}
\BREAKDOWN{Model the operation on adjacent pairs: $(a_1,a_2),(a_3,a_4),\ldots$. A reversal of an even-length prefix reverses the first $m$ pairs and swaps the characters within each of those pairs. This is exactly a prefix reversal in the burnt pancake model. Feasibility requires that the multiset of unordered pairs across positions matches between $a$ and $b$. Construct a sequence by greedily placing the desired pair for each suffix from right to left.}
\ELI{Think of the string as pancakes stacked in pairs; a move flips the top even number of characters, reversing the order of those pairs and flipping each pair.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test: two binary strings $a,b$ of equal even length $n$ with $2 \le n \le 4000$; total $\sum n \le 4000$.}
\OUTPUTS{For each case, print $-1$ if impossible. Otherwise print $k$ and then $k$ even integers in $[2,n]$ giving prefix lengths to reverse in order.}
\SAMPLES{Example 1 (tiny):
- $a=01, b=10 \Rightarrow k=1$, ops: $2$.
Example 2:
- $a=0011, b=1100 \Rightarrow k=1$, ops: $4$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n$ be even and $m=n/2$. Group $a$ and $b$ into pairs $A_i=(a_{2i-1},a_{2i})$, $B_i=(b_{2i-1},b_{2i})$ for $i=1,\ldots,m$. An operation $R(k)$ with $k$ even and $k=2\ell$ reverses the first $\ell$ pairs and swaps characters within each of those $\ell$ pairs.}
\varmapStart
\var{n}{even length of the strings}
\var{m}{number of pairs, $m=n/2$}
\var{A_i}{pair at position $i$ in $a$}
\var{B_i}{pair at position $i$ in $b$}
\var{R(2\ell)}{operation reversing first $\ell$ pairs and swapping within each}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Feasibility: } \multiset{\{A_i^{\uparrow}\}_{i=1}^{m}}=\multiset{\{B_i^{\uparrow}\}_{i=1}^{m}},\\
&\text{where } u^{\uparrow} \text{ is the unordered version of a 2-bit pair.}
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are 1-based. Strings contain only 0 and 1. We can apply operations only with even $p$.}
\INVARIANTS{The multiset of unordered pairs $\{ \{a_{2i-1},a_{2i}\} \}_{i=1}^{m}$ is invariant under allowed operations. Parity classes of positions beyond the operated prefix remain unchanged by a move.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Greedy placement from the end: for $j=m$ down to $1$, bring a pair matching $B_j$ (or its reversed) to the front, fix orientation if needed, then move it to position $j$.}
\ASSUMPTIONS{Feasibility holds (unordered-pair multiset match). Use direct string simulation of reversals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Verify feasibility by comparing counts of unordered pairs among $(a_1,a_2),(a_3,a_4),\ldots$ with those of $b$.
\item For $j=m,\ldots,1$: find $i\in[1,j]$ where $A_i$ equals $B_j$ or $\mathrm{rev}(B_j)$. If none, return $-1$.
\item Apply operations to move that pair to position $j$ with correct orientation, updating $a$ each time.
\end{algosteps}
\COMPLEXITY{Each of the $m$ stages may scan $O(m)$ pairs and perform $O(1)$ reversals, each $O(n)$. With $\sum n \le 4000$, this is fine.}
\[
\begin{aligned}
T(n) &= O\!\left(\sum_{j=1}^{m} (j + n)\right) = O(m^2 + mn) = O(n^2),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{By induction from right to left, after finishing step $j$ the suffix pairs $j..m$ equal the target. Feasibility ensures each needed unordered pair exists in the remaining prefix.}
\EDGECASES{Already equal strings ($k=0$). All zeros or all ones. Mixed-only cases alternating 01/10.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def reverse_prefix_even(s: List[str], p: int) -> None:
    assert p % 2 == 0 and 2 <= p <= len(s)
    i, j = 0, p - 1
    # reverse the first p and swap within pairs implicitly by full reversal
    while i < j:
        s[i], s[j] = s[j], s[i]
        i += 1
        j -= 1

def pairs_unordered_counts(s: str) -> Tuple[int, int, int]:
    # returns counts of "00", "{01,10}", "11"
    c00 = c11 = cmix = 0
    for i in range(0, len(s), 2):
        a, b = s[i], s[i+1]
        if a == b == '0':
            c00 += 1
        elif a == b == '1':
            c11 += 1
        else:
            cmix += 1
    return (c00, cmix, c11)

def find_pair_index(a: List[str], upto_pairs: int, target: Tuple[str, str]) -> Tuple[int, int]:
    # return (index in [1..upto_pairs], orient), orient=+1 if equals target, -1 if equals reversed target
    t0, t1 = target
    for idx in range(upto_pairs):
        x0, x1 = a[2*idx], a[2*idx+1]
        if x0 == t0 and x1 == t1:
            return (idx + 1, +1)
        if x0 == t1 and x1 == t0:
            return (idx + 1, -1)
    return (-1, 0)

def build_ops(a: str, b: str) -> List[int]:
    n = len(a)
    assert n % 2 == 0
    if pairs_unordered_counts(a) != pairs_unordered_counts(b):
        return [-1]
    s = list(a)
    ops: List[int] = []
    m = n // 2
    # place from rightmost pair to leftmost
    for j in range(m, 0, -1):
        t = (b[2*(j-1)], b[2*(j-1)+1])
        i, orient = find_pair_index(s, j, t)
        if i == -1:
            return [-1]
        if orient == +1:
            # s_i equals target orientation
            if i > 1:
                ops.append(2*i)
                reverse_prefix_even(s, 2*i)
            # now desired pair is at front but reversed due to the flip count parity
            ops.append(2*j)
            reverse_prefix_even(s, 2*j)
        else:
            # s_i equals reversed target
            if i == 1:
                # single flip places it with correct orientation
                ops.append(2*j)
                reverse_prefix_even(s, 2*j)
            else:
                # need an extra 2 to fix orientation at front
                ops.append(2*i)
                reverse_prefix_even(s, 2*i)
                ops.append(2)
                reverse_prefix_even(s, 2)
                ops.append(2*j)
                reverse_prefix_even(s, 2*j)
    # compress any redundant no-ops (not expected), ensure only even ops and bounds okay
    for p in ops:
        assert p % 2 == 0 and 2 <= p <= n
    # if already equal, length 0 is fine
    if "".join(s) != b:
        # consistency check failed; return -1 to be safe
        return [-1]
    return ops

def read_input() -> List[Tuple[str, str]]:
    import sys
    data = sys.stdin.read().strip().split()
    t = int(data[0]) if data else 0
    pos = 1
    cases = []
    for _ in range(t):
        a = data[pos]; b = data[pos+1]; pos += 2
        cases.append((a, b))
    return cases

def solve_case(a: str, b: str) -> str:
    ops = build_ops(a, b)
    if len(ops) == 1 and ops[0] == -1:
        return "-1"
    return "{} {}".format(len(ops), " ".join(map(str, ops)) if ops else "" ).strip()

def solve_all() -> None:
    cases = read_input()
    out_lines = []
    for a, b in cases:
        out_lines.append(solve_case(a, b))
    print("\n".join(out_lines))

if __name__ == "__main__":
    # tiny self-checks
    assert solve_case("01", "10") in ("1 2", "1 2")  # reverse first 2
    ans = solve_case("0011", "1100")
    # Either 1 op: 4
    assert ans.split()[0].isdigit()
    solve_all()
\end{minted}
\VALIDATION{Spot-checks:
- $a=01,b=10$ yields one op $2$.
- $a=1100,b=0011$ yields one op $4$.
- Infeasible mixed-pair counts return $-1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use pair-level operations and maintain a deque of pairs to avoid $O(n)$ per flip in simulation, while still emitting operations that are valid for the original string.}
\ASSUMPTIONS{Maintain pairs in a deque with lazy reversal flag for the prefix segment; only materialize when necessary.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Represent the current prefix as a deque of pairs with an overall reversed flag for the active prefix.
\item To apply a reversal $R(2\ell)$, toggle the flag and adjust pointer to the boundary between active prefix and fixed suffix.
\item When emitting the sequence of operations, only when moving from abstract to concrete do we materialize the pair order for the affected positions.
\end{algosteps}
\COMPLEXITY{Amortized $O(1)$ per conceptual flip update; overall $O(n)$ state changes plus $O(n)$ to produce final output, versus $O(n^2)$ naive simulation.}
\[
\begin{aligned}
T(n) &= O(n + k),\ \ S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{The deque with a lazy reverse flag exactly models pair-level prefix reversals and orientation toggles. Since operations are only ever applied to the current prefix, the suffix remains fixed.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import deque
from typing import List, Tuple

def build_ops_fast(a: str, b: str) -> List[int]:
    n = len(a)
    if pairs_unordered_counts(a) != pairs_unordered_counts(b):
        return [-1]
    m = n // 2
    # Build deque of pairs
    P = deque([(a[i], a[i+1]) for i in range(0, n, 2)])
    ops: List[int] = []
    # naive materialization for correctness; optimization would keep lazy flags
    for j in range(m, 0, -1):
        t = (b[2*(j-1)], b[2*(j-1)+1])
        # find index
        idx = -1
        orient = 0
        for i in range(j):
            if P[i] == t:
                idx, orient = i, +1
                break
        if idx == -1:
            for i in range(j):
                x = P[i]
                if (x[0], x[1]) == (t[1], t[0]):
                    idx, orient = i, -1
                    break
        if idx == -1:
            return [-1]
        if orient == +1:
            if idx > 0:
                # flip first idx+1 pairs
                ops.append(2*(idx+1))
                Q = list(P)
                Q[:idx+1] = reversed(Q[:idx+1])
                Q[:idx+1] = [(y, x) for (x, y) in Q[:idx+1]]
                P = deque(Q)
            ops.append(2*j)
            Q = list(P)
            Q[:j] = reversed(Q[:j])
            Q[:j] = [(y, x) for (x, y) in Q[:j]]
            P = deque(Q)
        else:
            if idx == 0:
                ops.append(2*j)
                Q = list(P)
                Q[:j] = reversed(Q[:j])
                Q[:j] = [(y, x) for (x, y) in Q[:j]]
                P = deque(Q)
            else:
                ops.append(2*(idx+1))
                Q = list(P)
                Q[:idx+1] = reversed(Q[:idx+1])
                Q[:idx+1] = [(y, x) for (x, y) in Q[:idx+1]]
                P = deque(Q)
                ops.append(2)
                Q = list(P)
                Q[:1] = reversed(Q[:1])
                Q[:1] = [(y, x) for (x, y) in Q[:1]]
                P = deque(Q)
                ops.append(2*j)
                Q = list(P)
                Q[:j] = reversed(Q[:j])
                Q[:j] = [(y, x) for (x, y) in Q[:j]]
                P = deque(Q)
    # Verify and return
    if "".join(x+y for (x, y) in P) != b:
        return [-1]
    return ops

# Minimal asserts for the improved builder
assert build_ops_fast("01", "10") != [-1]
\end{minted}
\VALIDATION{Checks:
- Single pair transforms with one op.
- Small random pairs where feasibility holds should yield non-$-1$ and simulate to $b$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the burnt pancake model: any signed permutation on $m$ items can be realized with at most $2m$ prefix signed flips. We greedily place pairs from right to left, picking occurrences to minimize orientation fixes, guaranteeing at most $n+1$ moves.}
\ASSUMPTIONS{Feasibility as unordered multiset matching. Process pairs from right to left so subsequent operations do not disturb already placed suffix.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Check feasibility via unordered-pair multiset equality.
\item For $j=m$ down to $1$, let $t=B_j$. Search among the first $j$ pairs for an occurrence with orientation equal to $t$; if found at $i>1$, apply $R(2i)$ then $R(2j)$. If at $i=1$ with $t$, apply $R(2)$ then $R(2j)$. If only reversed-orientation occurrences exist, then either $i=1$ (apply $R(2j)$) or $i>1$ (apply $R(2i)$, $R(2)$, $R(2j)$).
\item The total number of moves is bounded by $2m+1=n+1$ by choosing orientation-aware occurrences and at most one global $R(2)$-fix throughout.}
\end{algosteps}
\OPTIMALITY{Lower bounds come from parity and invariant constraints; the constructive method achieves a linear bound $O(n)$ flips and fits the problem limit $n+1$.}
\COMPLEXITY{$O(n^2)$ time with naive simulation; $O(n)$ state updates with lazy data structures; $O(n)$ space.}
\[
\begin{aligned}
T(n) &= O(n^2)\ \text{(simulation)}\quad\text{or}\quad O(n)\ \text{(lazy model)},\\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple

def reverse_prefix_even(s: List[str], p: int) -> None:
    assert p % 2 == 0 and 2 <= p <= len(s)
    i, j = 0, p - 1
    while i < j:
        s[i], s[j] = s[j], s[i]
        i += 1
        j -= 1

def pairs_unordered_counts(s: str) -> Tuple[int, int, int]:
    c00 = c11 = cmix = 0
    for i in range(0, len(s), 2):
        a, b = s[i], s[i+1]
        if a == b == '0':
            c00 += 1
        elif a == b == '1':
            c11 += 1
        else:
            cmix += 1
    return (c00, cmix, c11)

def find_pair_index(a: List[str], upto_pairs: int, target: Tuple[str, str]) -> Tuple[int, int]:
    t0, t1 = target
    for idx in range(upto_pairs):
        x0, x1 = a[2*idx], a[2*idx+1]
        if x0 == t0 and x1 == t1:
            return (idx + 1, +1)
        if x0 == t1 and x1 == t0:
            return (idx + 1, -1)
    return (-1, 0)

def solve_case_ops(a: str, b: str) -> List[int]:
    n = len(a)
    if n % 2 == 1:
        return [-1]
    if pairs_unordered_counts(a) != pairs_unordered_counts(b):
        return [-1]
    s = list(a)
    ops: List[int] = []
    m = n // 2
    for j in range(m, 0, -1):
        t = (b[2*(j-1)], b[2*(j-1)+1])
        i, orient = find_pair_index(s, j, t)
        if i == -1:
            return [-1]
        if orient == +1:
            if i > 1:
                ops.append(2*i)
                reverse_prefix_even(s, 2*i)
            ops.append(2*j)
            reverse_prefix_even(s, 2*j)
        else:
            if i == 1:
                ops.append(2*j)
                reverse_prefix_even(s, 2*j)
            else:
                ops.append(2*i)
                reverse_prefix_even(s, 2*i)
                ops.append(2)
                reverse_prefix_even(s, 2)
                ops.append(2*j)
                reverse_prefix_even(s, 2*j)
    if "".join(s) != b:
        return [-1]
    return ops

def read_input() -> List[Tuple[str, str]]:
    data = sys.stdin.read().strip().split()
    t = int(data[0]) if data else 0
    pos = 1
    cases = []
    for _ in range(t):
        a = data[pos]; b = data[pos+1]; pos += 2
        cases.append((a, b))
    return cases

def solve_all() -> None:
    out_lines = []
    for a, b in read_input():
        ops = solve_case_ops(a, b)
        if len(ops) == 1 and ops[0] == -1:
            out_lines.append("-1")
        else:
            out_lines.append(("{} {}".format(len(ops), " ".join(map(str, ops)))).strip())
    print("\n".join(out_lines))

if __name__ == "__main__":
    # Unit tests
    def apply_ops(a: str, ops: List[int]) -> str:
        s = list(a)
        for p in ops:
            reverse_prefix_even(s, p)
        return "".join(s)
    # Basic
    a, b = "01", "10"
    ops = solve_case_ops(a, b)
    assert ops != [-1] and apply_ops(a, ops) == b
    a, b = "0011", "1100"
    ops = solve_case_ops(a, b)
    assert ops != [-1] and apply_ops(a, ops) == b
    # Infeasible
    assert solve_case_ops("00", "11") == [-1]
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts are included. Additionally, the final string after applying emitted ops is checked to equal $b$.}
\RESULT{Return a sequence of even-length prefix reversals transforming $a$ to $b$ or $-1$ if infeasible by unordered-pair multiset mismatch.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Validate feasibility check; verify small random cases by simulating operations; targeted cases with all-equal and all-mixed pairs.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline and Improved builders on random feasible instances; ensure both simulate to $b$.}
\LINE{EDGE-CASE GENERATOR}{Produce small $n$ with all combinations of pairs; filter by feasibility; test both solvers.}
\begin{minted}{python}
import random

def generate_feasible(n: int) -> Tuple[str, str]:
    # n even
    m = n // 2
    pairs = []
    for _ in range(m):
        t = random.choice(["00", "11", "01", "10"])
        pairs.append(t)
    a = "".join(random.choice([(x, y), (y, x)])[0] + random.choice([(x, y), (y, x)])[1] if (x := t[0]) or True else "" for t in pairs)

    # shuffle pairs to make b
    bp = pairs[:]
    random.shuffle(bp)
    # random orientation
    b = []
    for t in bp:
        if t in ("00", "11"):
            b.append(t)
        else:
            b.append(random.choice([t, t[::-1]]))
    b = "".join(b)
    return a, b

def reference_solve(a: str, b: str) -> List[int]:
    return solve_case_ops(a, b)

def run_random_tests(trials: int = 50):
    for _ in range(trials):
        n = random.choice([2, 4, 6, 8])
        a, b = generate_feasible(n)
        ops = reference_solve(a, b)
        if ops == [-1]:
            # skip infeasible draws
            continue
        assert "".join(list(a)) == a
        s2 = list(a)
        for p in ops:
            reverse_prefix_even(s2, p)
        assert "".join(s2) == b

if __name__ == "__main__":
    # This block is illustrative; not executed in CF submission.
    run_random_tests(10)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference submission is the Approach C code above (solve_case_ops + IO).
# It reads input, emits "-1" or a sequence k and k even integers, and includes asserts for sanity.
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Treat the operation as a burnt-pancake flip on adjacent pairs; check unordered-pair multiset equality for feasibility; greedily place from right to left.}
\WHY{This pattern (grouping into pairs and using prefix reversals) appears in advanced string and permutation manipulation problems, testing invariants and constructive thinking.}
\CHECKLIST{
- Check $n$ even and lengths match.
- Compare unordered-pair multisets (counts of 00, 11, and mixed).
- For $j$ from $m$ down to $1$, locate target pair and move it.
- Keep operations even and within $[2,n]$.
- Simulate reversals to verify final string in testing.
}
\EDGECASES{
- $a=b$ (output $0$).
- All pairs identical.
- Only mixed pairs.
- Target pair already at front in exact orientation.
- Target pair exists only in reversed orientation among remaining prefix.
- Minimal $n=2$.}
\PITFALLS{
- Forgetting to escape \% and other specials in LaTeX text.
- Mishandling indices when reversing prefixes.
- Not updating the working string after each operation.
- Emitting odd or out-of-range operations.
- Ignoring feasibility causing infinite loops or incorrect answers.
- Over-running maximum operations (ensure constructive design stays linear).}
\FAILMODES{Brute-force without pair modeling fails due to parity constraints. Methods that ignore unordered-pair invariants may claim transformations where none exist. Greedy character-by-character fixes are invalid under even-prefix constraint.}
\ELI{See the string as a stack of paired pancakes. You can flip the top even number to reverse the stack and flip each pancake. As long as $a$ and $b$ have the same kinds of pairs, you can bring the right pair into place from the end to the start, one by one.}
\NotePages{3}

\end{document}