% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Bitwise ORs of Subarrays}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/bitwise-ors-of-subarrays/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given an integer array \texttt{arr}, return the number of distinct bitwise ORs of all the non-empty subarrays of \texttt{arr}. The bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer. A \textbf{subarray} is a contiguous non-empty sequence of elements within an array.

\textbf{Example 1:}

Input: \(\texttt{arr} = [0]\)

Output: \(1\)

Explanation: There is only one possible result: \(0\).

\textbf{Example 2:}

Input: \(\texttt{arr} = [1,1,2]\)

Output: \(3\)

Explanation: The possible subarrays are \([1], [1], [2], [1, 1], [1, 2], [1, 1, 2]\). These yield the results \(1, 1, 2, 1, 3, 3\). There are \(3\) unique values, so the answer is \(3\).

\textbf{Example 3:}

Input: \(\texttt{arr} = [1,2,4]\)

Output: \(6\)

Explanation: The possible results are \(1, 2, 3, 4, 6,\) and \(7\).

\textbf{Constraints:}
\begin{bullets}
\item \(1 \le \texttt{arr.length} \le 5 \times 10^{4}\).
\item \(0 \le \texttt{arr}[i] \le 10^{9}\).
\end{bullets}}
\BREAKDOWN{Enumerate all subarray bitwise OR results without redundancy. Use the monotonic nature of bitwise OR to bound the number of distinct ORs ending at each index. Return the size of the union over all indices.}
\ELI{As you extend a subarray, ORs can only turn bits on, never off, so per position there are only a small number of new OR values to track.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list of integers \(\texttt{arr}\) with length \(n\) where \(1 \le n \le 5 \times 10^{4}\), and each element satisfies \(0 \le \texttt{arr}[i] \le 10^{9}\).}
\OUTPUTS{An integer equal to the number of distinct values obtainable as the bitwise OR of some non-empty contiguous subarray of \(\texttt{arr}\).}
\SAMPLES{Example A: \(\texttt{arr} = [0]\) produces the set \(\{0\}\) and returns \(1\). Example B: \(\texttt{arr} = [1,1,2]\) produces the set \(\{1,2,3\}\) and returns \(3\).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given \(n \in \mathbb{N}\) and a sequence \((a_0,\ldots,a_{n-1})\) with \(a_i \in \mathbb{Z}_{\ge 0}\), define
\begin{BreakableEquation*}
S \coloneqq \bigl\{\, a_i \,\vert\, a_{i+1} \,\vert\, \cdots \,\vert\, a_j \;\bigm|\; 0 \le i \le j < n \,\bigr\}.
\end{BreakableEquation*}
Output \(|S|\).}
\varmapStart
\var{n}{length of the array}
\var{a_i}{the \(i\)-th element of the array}
\var{S}{set of all bitwise OR values of non-empty subarrays}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{For } 0 \le i \le j < n:&\quad \operatorname{OR}(i,j) \;=\; \bigl(\cdots((a_i \,\vert\, a_{i+1}) \,\vert\, a_{i+2}) \cdots \,\vert\, a_j\bigr),\\
S \; &= \;\{\, \operatorname{OR}(i,j) \mid 0 \le i \le j < n \,\},\\
\text{Answer} \; &= \; |S|.
\end{aligned}
\]
}
\ASSUMPTIONS{Integer bit-width is effectively bounded by \(W = \lfloor \log_2(\max a_i) \rfloor + 1 \le 30\) for \(a_i \le 10^{9}\). Indices are \(0\)-based.}
\INVARIANTS{
\begin{bullets}
\item Monotonicity: Extending a subarray can only add bits in OR; if \(x \subseteq y\) as subarrays with \(y\) extending \(x\), then \(\operatorname{OR}(y) \,\vert\, \operatorname{OR}(x) = \operatorname{OR}(y)\).
\item Bounded distinctness per end index: The number of distinct ORs of subarrays ending at a fixed \(j\) is at most \(W+1\).
\item Idempotence: Repeating the same value in adjacent positions cannot increase the number of distinct ORs beyond bit activations.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute \(\operatorname{OR}(i,j)\) for every \(0 \le i \le j < n\) and insert into a global set. Use associativity to update the running OR along the inner loop.}
\ASSUMPTIONS{Feasible only for small \(n\) due to quadratic subarray count; each OR update is \(O(1)\) on machine integers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an empty set \(S\).
\item For each start \(i\), set \(v \gets 0\). For each end \(j \ge i\): update \(v \gets v \,\vert\, a_j\), insert \(v\) into \(S\).
\item Return \(|S|\).
\end{algosteps}
\COMPLEXITY{There are \(\tfrac{n(n+1)}{2}\) subarrays. Each inner update is \(O(1)\), but OR values stabilize after at most \(W\) bit activations. Worst-case time \(O(n^2)\); space \(O(U)\) where \(U = |S|\).}
\[
\begin{aligned}
T(n) &= \sum_{i=0}^{n-1} (n-i) \\
     &= \frac{n(n+1)}{2} \in \Theta(n^2),\quad S(n) \in O(U).
\end{aligned}
\]
\CORRECTNESS{Every subarray is enumerated exactly once and its bitwise OR is inserted. The running OR along the inner loop equals \(\operatorname{OR}(i,j)\) by associativity and idempotence of bitwise OR.}
\EDGECASES{All zeros; single element; strictly increasing powers of two; repeated equal elements.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def subarrayBitwiseORs(self, arr: List[int]) -> int:
        n = len(arr)
        seen = set()
        for i in range(n):
            cur = 0
            for j in range(i, n):
                cur |= arr[j]
                seen.add(cur)
        return len(seen)

# Baseline sanity checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.subarrayBitwiseORs([0]) == 1
    assert sol.subarrayBitwiseORs([1, 1, 2]) == 3
    assert sol.subarrayBitwiseORs([1, 2, 4]) == 6
\end{minted}
\VALIDATION{Checked on the three given examples; add a zero-heavy case like \([0,0,0]\) which yields \(1\).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Set DP by End Index}
\WHICHFORMULA{Track \(E_j\): the set of all OR values of subarrays that end at index \(j\). Then \(E_j = \{a_j\} \cup \{x \,\vert\, a_j \mid x \in E_{j-1}\}\). The answer is \(|\bigcup_j E_j|\). Monotonicity ensures \(|E_j| \le W+1\).}
\ASSUMPTIONS{Bit-width \(W \le 30\). Using Python sets for deduplication; per index work is proportional to \(|E_{j-1}|\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \(E_{\text{prev}} \gets \varnothing\) and \(S \gets \varnothing\).
\item For each \(a_j\) in order: compute \(E_j = \{a_j\} \cup \{x \,\vert\, a_j : x \in E_{\text{prev}}\}\); set \(E_{\text{prev}} \gets E_j\); update \(S \gets S \cup E_j\).
\item Return \(|S|\).
\end{algosteps}
\COMPLEXITY{Each \(E_j\) has size at most \(W+1\). Hence total time \(O(n \cdot W)\) and space \(O(U + W)\).}
\[
\begin{aligned}
T(n) &= \sum_{j=0}^{n-1} O(|E_{j-1}|+1) \le n \cdot (W+1) \in O(nW).
\end{aligned}
\]
\CORRECTNESS{Every subarray ending at \(j\) either consists solely of \(a_j\) or extends a subarray ending at \(j-1\); OR distributes over this extension via \(x \mapsto x \,\vert\, a_j\). Union over all \(j\) captures all subarrays; sets eliminate duplicates.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def subarrayBitwiseORs(self, arr: List[int]) -> int:
        all_vals = set()
        prev = set()
        for a in arr:
            cur = {a}
            for v in prev:
                cur.add(v | a)
            all_vals |= cur
            prev = cur
        return len(all_vals)

# Improved sanity checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.subarrayBitwiseORs([0]) == 1
    assert sol.subarrayBitwiseORs([1, 1, 2]) == 3
    assert sol.subarrayBitwiseORs([1, 2, 4]) == 6
\end{minted}
\VALIDATION{Edge checks: \([0,0,0]\) gives \(1\); \([7,7,7]\) gives \(\{7\}\) thus \(1\); powers of two \([1,2,4,8]\) yield all sums of distinct bits.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{DP on OR-Frontier with Bit-Width Bound}
\WHICHFORMULA{Same recurrence \(E_j = \{a_j\} \cup \{x \,\vert\, a_j : x \in E_{j-1}\}\), implemented with in-place small-set operations and early deduplication. This achieves the information-theoretic bound \(O(nW)\).}
\ASSUMPTIONS{Input integers fit in standard Python int; number of distinct ORs per index is bounded by \(W \le 31\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain two sets: \(prev\) for \(E_{j-1}\) and \(ans\) for the union.
\item For each \(a\) in \(\texttt{arr}\), build \(cur\) by OR-ing \(a\) into all values in \(prev\) and adding \(a\) itself.
\item Union into \(ans\), assign \(prev \leftarrow cur\), continue. Return \(|ans|\).
\end{algosteps}
\OPTIMALITY{Any algorithm must in the worst case produce all distinct results; there can be \(\Theta(nW)\) unique ORs across all ends for arrays that progressively turn on bits. The DP achieves this within constant factors.}
\COMPLEXITY{Time \(O(nW)\), space \(O(U + W)\) with \(U = |\bigcup_j E_j|\).}
\[
\begin{aligned}
T(n) &= O(nW), \quad S(n) = O(U + W).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def subarrayBitwiseORs(self, arr: List[int]) -> int:
        ans: set[int] = set()
        prev: set[int] = set()
        for a in arr:
            cur: set[int] = {a}
            # OR 'a' into all previous end-at-(j-1) values
            for v in prev:
                cur.add(v | a)
            ans |= cur
            prev = cur
        return len(ans)

if __name__ == "__main__":
    sol = Solution()
    # Exactly 3 asserts
    assert sol.subarrayBitwiseORs([0]) == 1
    assert sol.subarrayBitwiseORs([1, 1, 2]) == 3
    assert sol.subarrayBitwiseORs([1, 2, 4]) == 6
\end{minted}
\VALIDATION{Checked examples; random micro-cases cross-checked against a quadratic baseline confirm equality.}
\RESULT{Return the count of unique integers obtainable as bitwise ORs over all non-empty contiguous subarrays; no tie-breaking is needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the three provided examples; add adversarial patterns: all zeros, all equal, alternating bits, increasing powers of two. Property test on small \(n\) by comparing against a quadratic baseline.}
\LINE{CROSS-CHECKS}{For \(n \le 5\) and values in \(\{0,1,2,3\}\), verify improved/optimal outputs match brute force.}
\LINE{EDGE-CASE GENERATOR}{Produce deterministic small arrays to cover boundaries: single element, duplicates, zeros, mixed bits.}
\begin{minted}{python}
from typing import List, Iterable, Tuple

def brute_subarray_bitwise_ors(arr: List[int]) -> int:
    seen = set()
    n = len(arr)
    for i in range(n):
        cur = 0
        for j in range(i, n):
            cur |= arr[j]
            seen.add(cur)
    return len(seen)

class Solution:
    def subarrayBitwiseORs(self, arr: List[int]) -> int:
        ans: set[int] = set()
        prev: set[int] = set()
        for a in arr:
            cur: set[int] = {a}
            for v in prev:
                cur.add(v | a)
            ans |= cur
            prev = cur
        return len(ans)

def small_cases() -> Iterable[List[int]]:
    vals = [0, 1, 2, 3]
    # length 1..4
    yield from ([v] for v in vals)
    for a in vals:
        for b in vals:
            yield [a, b]
    for a in vals:
        for b in vals:
            for c in vals:
                yield [a, b, c]
    # a few hand-crafted
    yield [0, 0, 0, 0]
    yield [7, 7, 7]
    yield [1, 2, 4, 8]
    yield [1, 3, 1, 3]

if __name__ == "__main__":
    sol = Solution()
    # Cross-check against brute force on small deterministic set
    for arr in small_cases():
        assert sol.subarrayBitwiseORs(arr) == brute_subarray_bitwise_ors(arr)
    # Sample prints for visual confirmation
    assert sol.subarrayBitwiseORs([0]) == 1
    assert sol.subarrayBitwiseORs([1, 1, 2]) == 3
    assert sol.subarrayBitwiseORs([1, 2, 4]) == 6
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def subarrayBitwiseORs(self, arr: List[int]) -> int:
        ans: set[int] = set()
        prev: set[int] = set()
        for a in arr:
            cur: set[int] = {a}
            for v in prev:
                cur.add(v | a)
            ans |= cur
            prev = cur
        return len(ans)

if __name__ == "__main__":
    sol = Solution()
    assert sol.subarrayBitwiseORs([0]) == 1
    assert sol.subarrayBitwiseORs([1, 1, 2]) == 3
    assert sol.subarrayBitwiseORs([1, 2, 4]) == 6
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count distinct bitwise OR results over all non-empty subarrays using a rolling set of ORs ending at each index.}
\WHY{Common interview task to exploit bitwise monotonicity and reduce quadratic enumeration to near-linear in \(n\) with a small factor \(W\).}
\CHECKLIST{
\begin{bullets}
\item Recognize OR monotonicity; maintain frontier of end-at-\(j\) ORs.
\item Update via \(E_j = \{a_j\} \cup \{x \,\vert\, a_j : x \in E_{j-1}\}\).
\item Union into global set; return its size.
\item Consider integer bit-width bound \(W \le 31\) for complexity.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Single element arrays.
\item All zeros.
\item All identical nonzero elements.
\item Alternating bits (e.g., \(5,10,5,10\)).
\item Strict powers of two.
\item Large \(n\) with small values.
\item Presence of zeros between nonzeros.
\item Leading zeros.
\item Tail zeros.
\item Maximal value \(10^{9}\).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to include the singleton \(\{a_j\}\) in \(E_j\).
\item Mutating the previous set while iterating; always build a new set.
\item Assuming \(E_j\) grows unbounded; it is bounded by bit-width.
\item Using lists instead of sets causing duplicates to blow up runtime.
\item Clearing the global set per iteration by mistake.
\item Off-by-one on indices \(i,j\) when reasoning about subarrays.
\item Misinterpreting union vs. update for global accumulation.
\item Overusing bit-length; no need to mask or limit bits in Python.
\end{bullets}
}
\FAILMODES{Naive triple-nested computations time out at \(n=5\times10^{4}\). The DP-by-end approach avoids exponential blow-up by leveraging OR monotonicity and deduplication.}
\ELI{Keep track of all OR results you can get if a subarray ends at the current position. When you add a new number, OR it with each of those and also consider the number itself. Collect all results you ever see and count them at the end.}
\NotePages{3}

\end{document}