% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Find the Lexicographically Largest String From the Box I}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/find-the-lexicographically-largest-string-from-the-box-i/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given a string \texttt{word}, and an integer \texttt{numFriends}. Alice is organizing a game for her \texttt{numFriends} friends. There are multiple rounds in the game, where in each round:
\begin{itemize}
\item \texttt{word} is split into \texttt{numFriends} \textbf{non-empty} strings, such that no previous round has had the \textbf{exact} same split.
\item All the split words are put into a box.
\end{itemize}
Find the lexicographically largest string from the box after all the rounds are finished.

\textbf{Example 1:}\\
\textbf{Input:} \texttt{word = "dbca"}, \texttt{numFriends = 2}\\
\textbf{Output:} \texttt{"dbc"}\\
\textbf{Explanation:} All possible splits are:
\begin{itemize}
\item \texttt{"d"} and \texttt{"bca"}.
\item \texttt{"db"} and \texttt{"ca"}.
\item \texttt{"dbc"} and \texttt{"a"}.
\end{itemize}

\textbf{Example 2:}\\
\textbf{Input:} \texttt{word = "gggg"}, \texttt{numFriends = 4}\\
\textbf{Output:} \texttt{"g"}\\
\textbf{Explanation:} The only possible split is: \texttt{"g"}, \texttt{"g"}, \texttt{"g"}, and \texttt{"g"}.

\textbf{Constraints:}
\begin{itemize}
\item \texttt{1 \le |word| \le 5 \times 10^3}
\item \texttt{word} consists only of lowercase English letters.
\item \texttt{1 \le numFriends \le |word|}
\end{itemize}}
\BREAKDOWN{Model each round as choosing \texttt{numFriends-1} cut positions among the \texttt{|word|-1} gaps. The box collects every piece from every such partition. We need the lexicographically maximum piece that can occur in some valid partition.}
\ELI{A piece can only be a contiguous substring; among all substrings that can appear in some valid split into \texttt{numFriends} parts, pick the lexicographically largest one.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A string \texttt{word} of length \texttt{n} with lowercase letters only; an integer \texttt{numFriends} with \texttt{1 \le numFriends \le n}.}
\OUTPUTS{Return a single string: the lexicographically largest string that can appear as one of the \texttt{numFriends} non-empty contiguous parts of \texttt{word} in some valid split.}
\SAMPLES{
Example 1:\\
Input: \texttt{word = "dbca"}, \texttt{numFriends = 2}\\
Output: \texttt{"dbc"}\\

Example 2:\\
Input: \texttt{word = "gggg"}, \texttt{numFriends = 4}\\
Output: \texttt{"g"}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let \texttt{word} be a string of length $n$. A split into $k=\texttt{numFriends}$ parts is defined by choosing $k-1$ distinct cut indices from $\{1,2,\ldots,n-1\}$. The resulting multiset $B$ contains every piece (contiguous block) from all such splits. We seek $\max_{\text{lex}} B$.}
\varmapStart
\var{n}{length of \texttt{word}}
\var{k}{\texttt{numFriends}}
\var{i,j}{substring indices with $0 \le i < j \le n$}
\var{L}{maximum allowed piece length bound, $L = n - k + 1$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{A substring } s = \texttt{word}[i:j] \text{ is feasible in some } k\text{-split } \iff \\
&\quad k \in \big[1 + \mathbf{1}_{i>0} + \mathbf{1}_{j<n}\;,\; 1 + i + (n-j)\big].
\end{aligned}
\]
For $k \ge 3$, feasibility simplifies to $|s| \le L = n - k + 1$. For $k=2$, feasible $s$ are exactly all non-empty prefixes and suffixes (but not the whole string). For $k=1$, only the whole string is feasible.
}
\ASSUMPTIONS{Cuts preserve the original order; all parts are non-empty; every distinct set of $k-1$ cut indices defines exactly one split.}
\INVARIANTS{
\begin{itemize}
\item Every piece is a contiguous substring.
\item For fixed $(i,j)$, the achievable total piece counts form an interval $\big[1 + \mathbf{1}_{i>0} + \mathbf{1}_{j<n}, 1 + n - (j-i)\big]$.
\end{itemize}
}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all ${n-1 \choose k-1}$ splits; collect all pieces; return the maximum.}
\ASSUMPTIONS{Only feasible for tiny $n$ due to combinatorial explosion.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all subsets of size $k-1$ from $\{1,\ldots,n-1\}$ as cut positions.
\item For each subset, form the $k$ parts, insert all parts into a multiset or track the running lexicographic maximum.
\item Return the maximum string seen.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ for fixed $k$ due to ${n-1 \choose k-1}$ splits; assembling parts adds $O(n)$ per split.}
\[
\begin{aligned}
T(n) &\in \Theta\!\left(\binom{n-1}{k-1}\cdot n\right), \\
S(n) &\in O(1) \text{ beyond input if we keep only the running maximum.}
\end{aligned}
\]
\CORRECTNESS{Direct enumeration covers every valid split exactly once; the maximum among all collected parts is, by definition, the desired answer.}
\EDGECASES{Handle $k=1$ (whole string), $k=n$ (all single letters), repeated letters, and ties correctly.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LeetCode-style baseline: brute force enumerate splits (only for tiny n)
from itertools import combinations

class SolutionBaseline:
    def answerString(self, word: str, numFriends: int) -> str:
        n = len(word)
        k = numFriends
        assert 1 <= k <= n
        if k == 1:
            return word
        best = ""
        # Choose k-1 cut positions from 1..n-1
        for cuts in combinations(range(1, n), k - 1):
            parts = []
            prev = 0
            for c in cuts:
                parts.append(word[prev:c])
                prev = c
            parts.append(word[prev:n])
            # Update best among all parts
            for p in parts:
                if p > best:
                    best = p
        return best

# Tiny sanity checks (avoid large n due to combinatorial explosion)
if __name__ == "__main__":
    sb = SolutionBaseline()
    assert sb.answerString("dbca", 2) == "dbc"
    assert sb.answerString("gggg", 4) == "g"
    assert sb.answerString("a", 1) == "a"
\end{minted}
\VALIDATION{Validated on the two samples and a trivial single-character case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Feasibility-Checked Substring Scan}
\WHICHFORMULA{Use the feasibility interval characterization. A substring \texttt{word[i:j]} is valid iff $k \in [1+\mathbf{1}_{i>0}+\mathbf{1}_{j<n},\,1+n-(j-i)]$. Scan all $(i,j)$ and keep the lexicographic maximum.}
\ASSUMPTIONS{Runs in $O(n^2)$ time, acceptable for $n \le 5\times 10^3$ with efficient string comparisons.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $n=\lvert\texttt{word}\rvert$, $k=\texttt{numFriends}$.
\item For each $i$ from $0$ to $n-1$, extend $j$ from $i+1$ to $n$ and test feasibility.
\item If feasible, compare \texttt{word[i:j]} with current best; keep the larger.
\end{algosteps}
\COMPLEXITY{Double loop over all substrings.}
\[
\begin{aligned}
T(n) &\in \Theta(n^2) \text{ substring comparisons},\\
S(n) &\in O(1) \text{ extra beyond input and current best.}
\end{aligned}
\]
\CORRECTNESS{By the feasibility condition, every piece that can appear in some valid split is considered; the maximum among them is the answer.}
\textbf{Code (Improved)}
\begin{minted}{python}
class SolutionFeasibilityScan:
    def answerString(self, word: str, numFriends: int) -> str:
        n = len(word)
        k = numFriends
        assert 1 <= k <= n
        if k == 1:
            return word
        best = ""
        for i in range(0, n):
            left_req = 1 if i > 0 else 0
            for j in range(i + 1, n + 1):
                right_req = 1 if j < n else 0
                L = j - i
                min_pieces = 1 + left_req + right_req
                max_pieces = 1 + n - L
                if min_pieces <= k <= max_pieces:
                    cand = word[i:j]
                    if cand > best:
                        best = cand
        return best

if __name__ == "__main__":
    sf = SolutionFeasibilityScan()
    assert sf.answerString("dbca", 2) == "dbc"
    assert sf.answerString("gggg", 4) == "g"
    # Check k=1 only whole string is allowed
    assert sf.answerString("abc", 1) == "abc"
\end{minted}
\VALIDATION{Checked on samples and a $k=1$ case; feasibility window logic ensures correctness across positions.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Tight Structural Reduction}
\WHICHFORMULA{Use the structure:
\begin{itemize}
\item If $k=1$: only the whole string can appear.
\item If $k=2$: only non-empty prefixes and suffixes can appear.
\item If $k\ge 3$: any substring with length $\le L=n-k+1$ can appear; the maximum equals $\max_i \texttt{word}[i:\min(n,i+L)]$.
\end{itemize}}
\ASSUMPTIONS{String comparisons are $O(\ell)$ in the length of the compared prefix; total work is $O(n\cdot L)$ in the worst-case, which is $\le O(n^2)$ for $n \le 5\times 10^3$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Handle $k=1$: return \texttt{word}.
\item Handle $k=2$: scan all cuts $c\in[1..n-1]$; track maximum among \texttt{word[:c]} and \texttt{word[c:]}.
\item Handle $k\ge 3$: set $L=n-k+1$; for each start $i$, compare candidate \texttt{word[i:i+L]} to the best and keep the larger.
\end{algosteps}
\OPTIMALITY{The feasibility characterization shows these are exactly the reachable pieces for each $k$ regime; scanning only those candidates is minimal and avoids enumerating splits.}
\COMPLEXITY{Worst-case time $O(n\cdot L)\le O(n^2)$, space $O(1)$ extra.}
\[
\begin{aligned}
T(n) &\le n\cdot (n-k+1) \le n^2,\\
S(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def answerString(self, word: str, numFriends: int) -> str:
        n = len(word)
        k = numFriends
        assert 1 <= k <= n
        if k == 1:
            return word
        if k == 2:
            best = ""
            # All non-empty prefixes and suffixes (but not whole string)
            for c in range(1, n):
                p = word[:c]
                s = word[c:]
                if p > best:
                    best = p
                if s > best:
                    best = s
            return best
        # k >= 3: any substring of length <= L is feasible
        L = n - k + 1
        best = ""
        # Consider the longest allowable substring per starting index
        # i.e., word[i : min(n, i+L)]
        for i in range(n):
            cand = word[i:i+L]
            if cand > best:
                best = cand
        return best

# Exact samples and targeted checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.answerString("dbca", 2) == "dbc"
    assert sol.answerString("gggg", 4) == "g"
    assert sol.answerString("leetcode", 1) == "leetcode"
\end{minted}
\VALIDATION{Three asserts: two samples and a $k=1$ case confirming the whole string is returned.}
\RESULT{Returns the lexicographically largest feasible piece given \texttt{word} and \texttt{numFriends}, with tie-breaking inherent to lexicographic order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Compare Baseline vs Feasibility Scan vs Optimal on small random cases; cover $k=1$, $k=2$, $k\ge 3$, uniform strings, strictly increasing/decreasing characters, and interior vs edge pieces.}
\LINE{CROSS-CHECKS}{For $n \le 9$, brute-force splits are feasible; verify equality across all three implementations.}
\LINE{EDGE-CASE GENERATOR}{Generate short random strings and all valid $k$ to stress feasibility limits and lexicographic comparisons.}
\begin{minted}{python}
import random
import string

def slow_bruteforce(word: str, k: int) -> str:
    # Reuse baseline approach for small n
    from itertools import combinations
    n = len(word)
    if k == 1:
        return word
    best = ""
    for cuts in combinations(range(1, n), k - 1):
        prev = 0
        for c in cuts + (n,):
            part = word[prev:c]
            if part > best:
                best = part
            prev = c
    return best

def feasibility_scan(word: str, k: int) -> str:
    n = len(word)
    if k == 1:
        return word
    best = ""
    for i in range(n):
        left_req = 1 if i > 0 else 0
        for j in range(i + 1, n + 1):
            right_req = 1 if j < n else 0
            L = j - i
            if 1 + left_req + right_req <= k <= 1 + n - L:
                cand = word[i:j]
                if cand > best:
                    best = cand
    return best

def optimal(word: str, k: int) -> str:
    # Final method
    n = len(word)
    if k == 1:
        return word
    if k == 2:
        best = ""
        for c in range(1, n):
            if word[:c] > best:
                best = word[:c]
            if word[c:] > best:
                best = word[c:]
        return best
    L = n - k + 1
    best = ""
    for i in range(n):
        cand = word[i:i+L]
        if cand > best:
            best = cand
    return best

if __name__ == "__main__":
    # Deterministic seed
    random.seed(0)
    # Cross-check small cases
    for n in range(1, 9):
        for _ in range(50):
            word = "".join(random.choice("abc") for _ in range(n))
            for k in range(1, n + 1):
                a = slow_bruteforce(word, k)
                b = feasibility_scan(word, k)
                c = optimal(word, k)
                assert a == b == c, (word, k, a, b, c)

    # Sample confirmations
    assert optimal("dbca", 2) == "dbc"
    assert optimal("gggg", 4) == "g"
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def answerString(self, word: str, numFriends: int) -> str:
        n = len(word)
        k = numFriends
        assert 1 <= k <= n
        if k == 1:
            return word
        if k == 2:
            best = ""
            for c in range(1, n):
                p = word[:c]
                s = word[c:]
                if p > best:
                    best = p
                if s > best:
                    best = s
            return best
        L = n - k + 1
        best = ""
        for i in range(n):
            cand = word[i:i+L]
            if cand > best:
                best = cand
        return best

if __name__ == "__main__":
    sol = Solution()
    # Provided examples
    assert sol.answerString("dbca", 2) == "dbc"
    assert sol.answerString("gggg", 4) == "g"
    # Additional edge checks
    assert sol.answerString("a", 1) == "a"
    assert sol.answerString("aaaaa", 2) == "aaaa"
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Pick the lexicographically largest feasible piece from all valid $k$-part splits; for $k\ge 3$, it is the maximum among substrings of length $\le n-k+1$.}
\WHY{This tests reasoning about compositions of strings, feasibility constraints, and reducing an exponential search to a linear or quadratic scan.}
\CHECKLIST{
\begin{itemize}
\item Compute $n$ and $k$.
\item If $k=1$, return \texttt{word}.
\item If $k=2$, scan prefixes and suffixes.
\item Else set $L=n-k+1$ and scan $\texttt{word}[i:i+L]$ for all $i$.
\item Track the lexicographic maximum carefully.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item $k=1$ (only whole string).
\item $k=2$ (only prefixes and suffixes; exclude whole string).
\item $k=n$ (all single letters; answer is the maximum character).
\item All characters equal.
\item Strictly increasing or decreasing strings.
\item Ties where longer string with same prefix should win.
\item Very short strings ($n=1,2$).
\item Substrings at boundaries vs interior for small $k$.
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Treating interior substrings as feasible when $k=2$ (they are not).
\item Allowing length $> n-k+1$ when $k\ge 3$.
\item Mishandling lexicographic comparisons across different lengths.
\item Off-by-one in slicing bounds (\texttt{i+L} vs \texttt{n}).
\item Forgetting that longer string wins when one is a prefix of the other.
\item Creating excessive intermediate data; prefer running maximum.
\end{itemize}
}
\FAILMODES{Brute force fails for $n$ in the thousands; feasibility scan or the optimized reduction handles all inputs within time.}
\ELI{We are picking the biggest possible chunk you could see if you cut the string into $k$ pieces in every possible way. For $k=2$, those chunks are just prefixes and suffixes. For larger $k$, any substring up to a certain length is allowed, so just choose the biggest among them.}
\NotePages{3}

\end{document}