% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Singers' Tour}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1618/E}}
\LINE{DIFFICULTY / RATING}{1700}
\STATEMENT{%
$n$ towns are arranged in a circle sequentially. The towns are numbered from $1$ to $n$ in clockwise order. In the $i$-th town, there lives a singer with a repertoire of $a_i$ minutes for each $i \in [1, n]$.

Each singer visited all $n$ towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. In addition, in each town, the $i$-th singer got inspired and came up with a song that lasts $a_i$ minutes. The song was added to his repertoire so that he could perform it in the rest of the cities.

Hence, for the $i$-th singer, the concert in the $i$-th town will last $a_i$ minutes, in the $(i + 1)$-th town the concert will last $2 \cdot a_i$ minutes, \ldots, in the $((i + k) \bmod n + 1)$-th town the duration of the concert will be $(k + 2) \cdot a_i$, \ldots, in the town $((i + n - 2) \bmod n + 1)$ — $n \cdot a_i$ minutes.

You are given an array of $b$ integer numbers, where $b_i$ is the total duration of concerts in the $i$-th town. Reconstruct any correct sequence of positive integers $a$ or say that it is impossible.

Input:
The first line contains one integer $t$ $(1 \le t \le 10^3)$ — the number of test cases. Then the test cases follow.

Each test case consists of two lines. The first line contains a single integer $n$ ($1 \le n \le 4 \cdot 10^4$) — the number of cities. The second line contains $n$ integers $b_1, b_2, \dots, b_n$ ($1 \le b_i \le 10^{9}$) — the total duration of concerts in $i$-th city.

The sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

Output:
For each test case, print the answer as follows:

If there is no suitable sequence $a$, print NO. Otherwise, on the first line print YES, on the next line print the sequence $a_1, a_2, \dots, a_n$ of $n$ integers, where $a_i$ ($1 \le a_i \le 10^{9}$) is the initial duration of repertoire of the $i$-th singer. If there are multiple answers, print any of them.

Note:
Let us consider the $1$-st test case of the example:

1. the $1$-st singer in the $1$-st city will give a concert for $3$ minutes, in the $2$-nd — for $6$ minutes, in the $3$-rd — for $9$ minutes;
2. the $2$-nd singer in the $1$-st city will give a concert for $3$ minutes, in the $2$-nd — for $1$ minute, in the $3$-rd — for $2$ minutes;
3. the $3$-rd singer in the $1$-st city will give a concert for $6$ minutes, in the $2$-nd — for $9$ minutes, in the $3$-rd — for $3$ minutes.}
\BREAKDOWN{We must invert a circulant linear transform mapping $a$ to $b$. Observe sum constraints and derive a direct formula using cyclic differences to obtain each $a_i$ in $O(n)$ time.}
\ELI{Total sums fix an average $s$, then each adjacent difference $b_{i} - b_{i-1}$ reveals $a_i$ modulo $n$; check divisibility and positivity.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{%
- Integer $t$ tests, $1 \le t \le 10^3$.\\
- For each test: integer $n$ with $1 \le n \le 4\cdot 10^4$, and an array $b_1,\dots,b_n$ with $1 \le b_i \le 10^{9}$.\\
- Across all tests, $\sum n \le 2\cdot 10^5$.}
\OUTPUTS{%
For each test, print NO if impossible. Otherwise print YES and a valid sequence of positive integers $a_1,\dots,a_n$ satisfying the rules.}
\SAMPLES{%
Example 1: $n=3$, $a=[3,1,2]$ yields $b=[10,13,13]$. Input:
3
10 13 13
Output:
YES
3 1 2

Example 2: $n=1$, $b=[7]$. Output:
YES
7}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let indices be cyclic modulo $n$. Each $b_i$ is a weighted circular sum of $a_j$ with weights $w_k = k+1$ for offsets $k \in \{0,\dots,n-1\}$.}
\varmapStart
\var{n}{number of towns/singers}
\var{a_i}{initial repertoire length of singer $i$}
\var{b_i}{total concert duration in town $i$}
\var{s}{average sum parameter $s = \dfrac{\sum b}{\tfrac{n(n+1)}{2}}$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
b_i \;=\; \sum_{j=1}^n \Big( \big((i-j)\bmod n\big) + 1 \Big)\, a_j,\qquad i=1,\dots,n.
\end{BreakableEquation*}
\begin{BreakableEquation*}
\sum_{i=1}^n b_i \;=\; \frac{n(n+1)}{2} \sum_{j=1}^n a_j \;\;\Longrightarrow\;\; s \in \mathbb{Z}_{>0}.
\end{BreakableEquation*}
\begin{BreakableEquation*}
b_{i} - b_{i-1} \;=\; s - n\,a_i \;\;\Longrightarrow\;\; a_i \;=\; \frac{s - (b_i - b_{i-1})}{n},\quad b_0:=b_n.
\end{BreakableEquation*}
}
\ASSUMPTIONS{1-based cyclic indexing; all $a_i$ must be positive integers.}
\INVARIANTS{%
- $C:=\tfrac{n(n+1)}{2}$ divides $\sum b_i$.\\
- For each $i$, $s-(b_i-b_{i-1})$ is a positive multiple of $n$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the derived identity $a_i = \dfrac{s - (b_i - b_{i-1})}{n}$ after checking $s = \dfrac{\sum b}{\tfrac{n(n+1)}{2}} \in \mathbb{Z}$.}
\ASSUMPTIONS{Cyclic difference is well-defined with $b_0=b_n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $C=\tfrac{n(n+1)}{2}$ and check $\sum b \bmod C = 0$; set $s=\dfrac{\sum b}{C}$.
\item For $i=1$ to $n$, compute $d_i=b_i-b_{i-1}$, $v_i=s-d_i$; require $v_i>0$ and $v_i \bmod n=0$.
\item Set $a_i=v_i/n$; print YES and the sequence; otherwise print NO.
\end{algosteps}
\COMPLEXITY{$O(n)$ time and $O(1)$ extra space per test.}
\[
\begin{aligned}
T(n) &= O(n) \\
S(n) &= O(1)
\end{aligned}
\]
\CORRECTNESS{By the governing equations, the necessary and sufficient conditions are divisibility by $C$ and per-index divisibility/positivity of $s-(b_i-b_{i-1})$. The reconstruction is unique under these constraints.}
\EDGECASES{$n=1$; large $b_i$; cases where exactly one index violates divisibility; all $a_i=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def reconstruct_a(b):
    n = len(b)
    C = n * (n + 1) // 2
    total = sum(b)
    if total % C != 0:
        return None
    s = total // C
    a = [0] * n
    for i in range(n):
        di = b[i] - b[i - 1]  # b[-1] is b[n-1]
        v = s - di
        if v <= 0 or v % n != 0:
            return None
        a[i] = v // n
    return a

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        b = [int(next(it)) for _ in range(n)]
        tests.append((n, b))
    return tests

def solve_case(n, b):
    a = reconstruct_a(b)
    if a is None:
        return "NO"
    return "YES\n" + " ".join(map(str, a))

def solve_all(data: str):
    tests = read_input(data)
    out_lines = []
    for n, b in tests:
        out_lines.append(solve_case(n, b))
    return "\n".join(out_lines)

def main():
    data = sys.stdin.read()
    print(solve_all(data))

if __name__ == "__main__":
    # Unit tests
    # 1) Simple n=1
    assert solve_all("1\n1\n7\n").strip() == "YES\n7"
    # 2) From a = [3,1,2]
    assert solve_all("1\n3\n10 13 13\n").strip() == "YES\n3 1 2"
    # 3) Impossible case
    res = solve_all("1\n2\n1 1\n").strip()
    assert res.startswith("NO")
    # If not running as script, still execute main
    main()
\end{minted}
\VALIDATION{Checked $n=1$; a handcrafted valid triple; and an impossible pair.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Same formula, but implement with early-exit checks and no extra allocations beyond output.}
\ASSUMPTIONS{Use single pass with constant memory; short-circuit on first violation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $C$ and test $\sum b \bmod C=0$; compute $s$.
\item Iterate indices once, computing $d_i$, $v_i$, and $a_i$; abort on violation.
\item Output answer.
\end{algosteps}
\COMPLEXITY{Still $O(n)$ time; memory $O(1)$ beyond the output array.}
\[
\begin{aligned}
T(n) &= O(n)
\end{aligned}
\]
\CORRECTNESS{Identical to Approach A; added pruning does not affect correctness.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        b = [int(next(it)) for _ in range(n)]
        tests.append((n, b))
    return tests

def reconstruct_and_print(n, b):
    C = n * (n + 1) // 2
    total = sum(b)
    if total % C != 0:
        return None
    s = total // C
    a = [0] * n
    for i in range(n):
        di = b[i] - b[i - 1]
        v = s - di
        if v <= 0 or v % n != 0:
            return None
        a[i] = v // n
    return a

def solve_case(n, b):
    a = reconstruct_and_print(n, b)
    if a is None:
        return "NO"
    return "YES\n" + " ".join(map(str, a))

def solve_all(data: str):
    tests = read_input(data)
    return "\n".join(solve_case(n, b) for n, b in tests)

def main():
    data = sys.stdin.read()
    print(solve_all(data))

if __name__ == "__main__":
    # Edge validations
    assert solve_all("1\n1\n1\n").strip() == "YES\n1"
    # Roundtrip check: generate b from a and recover
    def gen_b(a):
        n = len(a)
        b = [0]*n
        for i in range(n):
            s = 0
            for j in range(n):
                k = (i - j) % n
                s += (k + 1) * a[j]
            b[i] = s
        return b
    a0 = [5,2,4,1]
    b0 = gen_b(a0)
    out = solve_all("1\n4\n" + " ".join(map(str, b0)) + "\n").strip().splitlines()[-1]
    assert list(map(int, out.split())) == a0
    main()
\end{minted}
\VALIDATION{Checked $n=1$, and a randomized-style roundtrip via a deterministic generator for a fixed $a$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the necessary-and-sufficient conditions: $C \mid \sum b$ and $n \mid \big(s - (b_i - b_{i-1})\big)$ with positivity, reconstructing $a_i$ in one pass.}
\ASSUMPTIONS{Arithmetic in 64-bit integers is sufficient; Python integers are arbitrary precision.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Set $C=\tfrac{n(n+1)}{2}$, reject if $\sum b \not\equiv 0 \pmod C$; set $s=\dfrac{\sum b}{C}$.
\item For each $i$: compute $d=b_i-b_{i-1}$ with $b_0=b_n$, then $v=s-d$; require $v>0$ and $v \equiv 0 \pmod n$.
\item Output $a_i=v/n$.
\end{algosteps}
\OPTIMALITY{Single pass, linear time is optimal for reading the input and producing $n$ outputs.}
\COMPLEXITY{$O(n)$ time, $O(n)$ for result; arithmetic is constant-time per element in typical constraints.}
\[
\begin{aligned}
T(n) &= O(n)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        b = [int(next(it)) for _ in range(n)]
        tests.append((n, b))
    return tests

def solve_case(n, b):
    C = n * (n + 1) // 2
    total = sum(b)
    if total % C != 0:
        return "NO"
    s = total // C
    a = [0] * n
    for i in range(n):
        di = b[i] - b[i - 1]
        v = s - di
        if v <= 0 or v % n != 0:
            return "NO"
        a[i] = v // n
    return "YES\n" + " ".join(map(str, a))

def solve_all():
    out_lines = []
    for n, b in read_input():
        out_lines.append(solve_case(n, b))
    print("\n".join(out_lines))

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts
    # 1) Provided small valid case
    assert solve_case(3, [10, 13, 13]).splitlines()[-1] == "3 1 2"
    # 2) n=1
    assert solve_case(1, [42]).splitlines()[-1] == "42"
    # 3) Impossible
    assert solve_case(2, [1, 1]) == "NO"
    main()
\end{minted}
\VALIDATION{Three asserts: valid triple, $n=1$ case, and an impossible pair.}
\RESULT{Outputs YES and one valid $a$ or NO if impossible; any valid solution is accepted.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests check divisibility by $C$, per-index divisibility by $n$, positivity, small $n$, and roundtrip from a known $a$.}
\LINE{CROSS-CHECKS}{Compare reconstruction against a forward generator for random small arrays to ensure identity.}
\LINE{EDGE-CASE GENERATOR}{Produce small $n$ (including $1$), extreme values for $b_i$, and tweaks causing single-index violations.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_b(a):
    n = len(a)
    b = [0] * n
    for i in range(n):
        s = 0
        for j in range(n):
            k = (i - j) % n
            s += (k + 1) * a[j]
        b[i] = s
    return b

def adversarial_cases():
    cases = []
    # Valid cases
    cases.append([1])
    cases.append([3, 1, 2])
    cases.append([5, 2, 4, 1])
    # Inflate values
    cases.append([10**9, 10**9 - 1, 10**9 - 2])
    # Random-like fixed seeds
    cases.append([7, 11, 5, 13, 2, 3])
    return cases

def check_roundtrip():
    for a in adversarial_cases():
        b = gen_b(a)
        # Use the final solve_case
        from math import isfinite
        out = solve_case(len(b), b)
        assert out.startswith("YES")
        rec = list(map(int, out.splitlines()[-1].split()))
        assert rec == a

# Minimal embedded final solver for the above utilities
def solve_case(n, b):
    C = n * (n + 1) // 2
    total = sum(b)
    if total % C != 0:
        return "NO"
    s = total // C
    a = [0] * n
    for i in range(n):
        di = b[i] - b[i - 1]
        v = s - di
        if v <= 0 or v % n != 0:
            return "NO"
        a[i] = v // n
    return "YES\n" + " ".join(map(str, a))

# Run checks
check_roundtrip()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it))
        b = [int(next(it)) for _ in range(n)]
        tests.append((n, b))
    return tests

def solve_case(n, b):
    C = n * (n + 1) // 2
    total = sum(b)
    if total % C != 0:
        return "NO"
    s = total // C
    a = [0] * n
    for i in range(n):
        di = b[i] - b[i - 1]
        v = s - di
        if v <= 0 or v % n != 0:
            return "NO"
        a[i] = v // n
    return "YES\n" + " ".join(map(str, a))

def main():
    out = []
    for n, b in read_input():
        out.append(solve_case(n, b))
    print("\n".join(out))

if __name__ == "__main__":
    # Sanity asserts
    assert solve_case(1, [7]).splitlines()[-1] == "7"
    assert solve_case(3, [10, 13, 13]).splitlines()[-1] == "3 1 2"
    assert solve_case(2, [1, 1]) == "NO"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Reconstruct $a$ from $b$ using total-sum divisibility and cyclic difference constraints.}
\WHY{Circular-convolution inversion with structured weights is common in contests and interviews.}
\CHECKLIST{%
- Compute $C=\tfrac{n(n+1)}{2}$; check $\sum b \bmod C=0$.\\
- $s=\dfrac{\sum b}{C}$.\\
- For each $i$, compute $d=b_i-b_{i-1}$; check $v=s-d>0$ and $v \bmod n=0$.\\
- Output $a_i=v/n$.}
\EDGECASES{%
- $n=1$.\\
- Very large $b_i$ near $10^{9}$.\\
- Exactly one index with invalid divisibility.\\
- All $b_i$ equal.\\
- Alternating large/small $b_i$.\\
- Sum not divisible by $C$.\\
- Derived $a_i=0$ forbidden.\\
- Negative $v$.\\
- Overflow in languages without big integers.\\
- Input with maximum $\sum n$.}
\PITFALLS{%
- Forgetting cyclic indexing ($b_0=b_n$).\\
- Using integer division before checking divisibility.\\
- Mishandling $n=1$.\\
- Printing trailing spaces or wrong format.\\
- Mutating $b$ while iterating.\\
- Using floating-point division.\\
- Off-by-one in difference index.\\
- Not short-circuiting on early NO.\\
- Assuming uniqueness without checks.\\
- Missing positivity constraint.}
\FAILMODES{Weaker approaches guessing $a$ or solving a dense linear system are too slow or numerically unstable. The presented method is algebraically exact and linear-time.}
\ELI{First, the total sum of $b$ reveals the sum of all $a$ via a fixed multiplier. Then each adjacent difference of $b$ shows one $a_i$ after a simple division. If any step fails cleanly, the instance is impossible.}
\NotePages{3}

\end{document}