% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Design Movie Rental System}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/design-movie-rental-system/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You have a movie renting company consisting of \texttt{n} shops. You want to implement a renting system that supports searching for, booking, and returning movies. The system should also support generating a report of the currently rented movies.

Each movie is given as a 2D integer array \texttt{entries} where \texttt{entries[i] = [shop\textsubscript{i}, movie\textsubscript{i}, price\textsubscript{i}]} indicates that there is a copy of movie \texttt{movie\textsubscript{i}} at shop \texttt{shop\textsubscript{i}} with a rental price of \texttt{price\textsubscript{i}}. Each shop carries \textbf{at most one} copy of a movie \texttt{movie\textsubscript{i}}.

The system should support the following functions:
\begin{itemize}
\item \textbf{Search}: Finds the \textbf{cheapest 5 shops} that have an \textbf{unrented copy} of a given movie. The shops should be sorted by \textbf{price} in ascending order, and in case of a tie, the one with the \textbf{smaller} \texttt{shop\textsubscript{i}} should appear first. If there are less than 5 matching shops, then all of them should be returned. If no shop has an unrented copy, then an empty list should be returned.
\item \textbf{Rent}: Rents an \textbf{unrented copy} of a given movie from a given shop.
\item \textbf{Drop}: Drops off a \textbf{previously rented copy} of a given movie at a given shop.
\item \textbf{Report}: Returns the \textbf{cheapest 5 rented movies} (possibly of the same movie ID) as a 2D list \texttt{res} where \texttt{res[j] = [shop\textsubscript{j}, movie\textsubscript{j}]} describes that the \texttt{j}-th cheapest rented movie \texttt{movie\textsubscript{j}} was rented from the shop \texttt{shop\textsubscript{j}}. The movies in \texttt{res} should be sorted by \textbf{price} in ascending order, and in case of a tie, the one with the \textbf{smaller} \texttt{shop\textsubscript{j}} should appear first, and if there is still tie, the one with the \textbf{smaller} \texttt{movie\textsubscript{j}} should appear first. If there are fewer than 5 rented movies, then all of them should be returned. If no movies are currently being rented, then an empty list should be returned.
\end{itemize}

Implement the \texttt{MovieRentingSystem} class:
\begin{itemize}
\item \texttt{MovieRentingSystem(int n, int[][] entries)} Initializes the \texttt{MovieRentingSystem} object with \texttt{n} shops and the movies in \texttt{entries}.
\item \texttt{List<Integer> search(int movie)} Returns a list of shops that have an \textbf{unrented copy} of the given \texttt{movie} as described above.
\item \texttt{void rent(int shop, int movie)} Rents the given \texttt{movie} from the given \texttt{shop}.
\item \texttt{void drop(int shop, int movie)} Drops off a previously rented \texttt{movie} at the given \texttt{shop}.
\item \texttt{List<List<Integer>> report()} Returns a list of cheapest \textbf{rented} movies as described above.
\end{itemize}

\textbf{Note:} The test cases will be generated such that \texttt{rent} will only be called if the shop has an \textbf{unrented} copy of the movie, and \texttt{drop} will only be called if the shop had \textbf{previously rented} out the movie.

\textbf{Example 1:}

\begin{verbatim}
Input
["MovieRentingSystem", "search", "rent", "rent", "report", "drop", "search"]
[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]
Output
[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]

Explanation
MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);
movieRentingSystem.search(1);  // return [1, 0, 2]
movieRentingSystem.rent(0, 1); // rent movie 1 from shop 0
movieRentingSystem.rent(1, 2); // rent movie 2 from shop 1
movieRentingSystem.report();   // return [[0, 1], [1, 2]]
movieRentingSystem.drop(1, 2); // drop off movie 2 at shop 1
movieRentingSystem.search(2);  // return [0, 1]
\end{verbatim}

\textbf{Constraints:}
\begin{itemize}
\item \texttt{1 <= n <= 3 * 105}
\item \texttt{1 <= entries.length <= 105}
\item \texttt{0 <= shop\textsubscript{i} < n}
\item \texttt{1 <= movie\textsubscript{i}, price\textsubscript{i} <= 104}
\item Each shop carries \textbf{at most one} copy of a movie \texttt{movie\textsubscript{i}}.
\item At most \texttt{105} calls in total will be made to \texttt{search}, \texttt{rent}, \texttt{drop} and \texttt{report}.
\end{itemize}}
\BREAKDOWN{We must support four operations with strict ordering: per-movie search among unrented copies by (price, shop), and a global report among rented copies by (price, shop, movie). Maintain prices, the current rental state, and data structures enabling fast top-5 queries and updates.}
\ELI{Keep two leaderboards: for each movie, the cheapest available shops; and globally, the cheapest rented copies; update them on rent/drop and peek the top five when asked.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Interactive class interface.
\begin{itemize}
\item Constructor: \texttt{MovieRentingSystem(n, entries)} with \texttt{n} shops and \texttt{entries} as a list of triples \texttt{[shop, movie, price]}.
\item Operations:
\begin{itemize}
\item \texttt{search(movie: int)}.
\item \texttt{rent(shop: int, movie: int)}.
\item \texttt{drop(shop: int, movie: int)}.
\item \texttt{report()}.
\end{itemize}
\end{itemize}
Ranges per constraints in the statement.}
\OUTPUTS{
\begin{itemize}
\item \texttt{search} returns a list of up to 5 shop IDs.
\item \texttt{rent}, \texttt{drop} return nothing.
\item \texttt{report} returns a list of up to 5 pairs \texttt{[shop, movie]}.
\end{itemize}}
\SAMPLES{
Example A:
\begin{verbatim}
["MovieRentingSystem","search","rent","report"]
[[2,[[0,10,5],[1,10,4]]],[10],[1,10],[]]
-> [null,[1,0],null,[[1,10]]]
\end{verbatim}
Example B:
\begin{verbatim}
["MovieRentingSystem","rent","drop","search","report"]
[[1,[[0,5,7]]],[0,5],[0,5],[5],[]]
-> [null,null,null,[0],[]]
\end{verbatim}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $P:\{0,\ldots,n-1\}\times \mathbb{N}\to \mathbb{N}$ map $(\text{shop},\text{movie})$ to its fixed price if present. Let $U\subseteq \operatorname{dom}(P)$ be the set of unrented copies and $R\subseteq \operatorname{dom}(P)$ be the set of rented copies, disjoint with $U\cup R=\operatorname{dom}(P)$. Queries:
\begin{itemize}
\item $\text{search}(m)$ returns the 5 smallest $(P(s,m),s)$ among $\{(s,m)\in U\}$, projecting to $s$.
\item $\text{report}()$ returns the 5 smallest $(P(s,m),s,m)$ among $R$, projecting to $(s,m)$.
\item $\text{rent}(s,m)$ moves $(s,m)$ from $U$ to $R$.
\item $\text{drop}(s,m)$ moves $(s,m)$ from $R$ to $U$.
\end{itemize}}
\varmapStart
\var{n}{number of shops}
\var{P}{price map for existing copies}
\var{U}{unrented set of pairs $(s,m)$}
\var{R}{rented set of pairs $(s,m)$}
\var{H_m}{per-movie min-heap for available shops}
\var{H_R}{global min-heap for rented copies}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&U\cap R=\varnothing,\quad U\cup R=\operatorname{dom}(P).\\
&\text{search}(m):~\text{take first }k=\min(5,|U_m|)\text{ by lex order }(P(s,m),s).\\
&\text{report}():~\text{take first }k=\min(5,|R|)\text{ by lex order }(P(s,m),s,m).\\
&\text{rent}(s,m):~(s,m)\in U\Rightarrow U:=U\setminus\{(s,m)\},~R:=R\cup\{(s,m)\}.\\
&\text{drop}(s,m):~(s,m)\in R\Rightarrow R:=R\setminus\{(s,m)\},~U:=U\cup\{(s,m)\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Prices are immutable; each shop has at most one copy of any movie; operations are valid per problem note; $n$ and input sizes are within bounds.}
\INVARIANTS{
\begin{itemize}
\item Partition invariant: every existing copy is either unrented or rented.
\item Order invariant: search and report always respect tie-breaking orders as defined.
\item Price consistency: comparisons only use fixed $P(s,m)$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Maintain sets and scan-sort on each query. Sorting by the defined lexicographic keys yields the correct top-5.}
\ASSUMPTIONS{Use Python lists and sets; recompute candidates on demand without auxiliary priority queues.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build a price map $P[(s,m)]\to p$ and, for each movie, the set of currently available shops.
\item For \texttt{search(m)}: iterate available shops for $m$, collect $(p,s)$, sort, return first 5 shops.
\item Maintain a set of rented pairs; for \texttt{report()}: iterate rented pairs, collect $(p,s,m)$, sort, return first 5 pairs.
\item \texttt{rent}/\texttt{drop}: move the pair between sets.
\end{algosteps}
\COMPLEXITY{Let $E$ be number of entries and $d_m$ the available degree for movie $m$.
\[
\begin{aligned}
\text{search}(m) &:~O(d_m\log d_m) \\
\text{report}() &:~O(|R|\log |R|) \\
\text{rent}/\text{drop} &:~O(1)
\end{aligned}
\]
Worst-case per-query sorting is too slow when many queries ask for popular movies.}
\CORRECTNESS{Sorting by the lexicographic keys directly enforces tie-breaking. The partition invariant is maintained by moving pairs between the sets.}
\EDGECASES{Movies with zero available copies; fewer than 5 candidates; multiple movies sharing price; repeated rent/drop on different shops.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple, Dict, Set

class MovieRentingSystemBaseline:
    def __init__(self, n: int, entries: List[List[int]]):
        self.n = n
        # price map: (shop, movie) -> price
        self.price: Dict[Tuple[int, int], int] = {}
        # per-movie available shops
        self.avail: Dict[int, Set[int]] = {}
        # rented set of pairs
        self.rented: Set[Tuple[int, int]] = set()
        for s, m, p in entries:
            self.price[(s, m)] = p
            self.avail.setdefault(m, set()).add(s)

    def search(self, movie: int) -> List[int]:
        shops = self.avail.get(movie, set())
        # collect (price, shop) for available shops
        cand = [(self.price[(s, movie)], s) for s in shops]
        cand.sort()
        return [s for _, s in cand[:5]]

    def rent(self, shop: int, movie: int) -> None:
        if shop in self.avail.get(movie, set()):
            self.avail[movie].remove(shop)
        self.rented.add((shop, movie))

    def drop(self, shop: int, movie: int) -> None:
        if (shop, movie) in self.rented:
            self.rented.remove((shop, movie))
        self.avail.setdefault(movie, set()).add(shop)

    def report(self) -> List[List[int]]:
        cand = []
        for (s, m) in self.rented:
            cand.append((self.price[(s, m)], s, m))
        cand.sort()
        return [[s, m] for _, s, m in cand[:5]]

# Minimal LC-style wrapper (not used by judge for this design problem)
class Solution:
    pass

# Asserts (Baseline)
def _baseline_demo():
    mrs = MovieRentingSystemBaseline(3, [
        [0, 1, 5], [0, 2, 6], [0, 3, 7],
        [1, 1, 4], [1, 2, 7], [2, 1, 5]
    ])
    assert mrs.search(1) == [1, 0, 2]
    mrs.rent(0, 1)
    mrs.rent(1, 2)
    assert mrs.report() == [[0, 1], [1, 2]]
    mrs.drop(1, 2)
    assert mrs.search(2) == [0, 1]

if __name__ == "__main__":
    _baseline_demo()
\end{minted}
\VALIDATION{Checked the provided sample; verified empty report when no rentals; verified fewer-than-5 candidates truncated correctly.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Per-movie Heaps for Search; Simple Global Sorting for Report}
\WHICHFORMULA{Speed up \texttt{search(m)} by maintaining a min-heap per movie keyed by $(\text{price}, \text{shop})$ and lazily discarding stale entries. Keep \texttt{report()} as sort-over-rented for simplicity.}
\ASSUMPTIONS{Prices are static, so heap keys never change; lazy deletion with a membership set avoids $O(n)$ removals.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build price map and, for each movie $m$, a heap of $(p,s)$ and a membership set of currently available shops.
\item \texttt{search(m)}: pop stale entries until top is valid; collect up to 5 valid tops into a buffer, then push them back to keep the heap intact.
\item \texttt{rent}/\texttt{drop}: update the membership sets and push new entries to heaps as needed.
\item \texttt{report()}: iterate rented set and sort on demand.
\end{algosteps}
\COMPLEXITY{Search becomes near $O(k\log d_m)$ after amortized cleaning; report remains $O(|R|\log |R|)$.
\begin{BreakableEquation*}
T_{\text{search}}(m)\approx O(\log d_m + k\log d_m),\quad T_{\text{report}}=O(|R|\log |R|)
\end{BreakableEquation*}
}
\CORRECTNESS{Lazy deletion never returns an invalid shop because membership is checked before collecting. Sorting rented on demand preserves correct tie-breaking.}
\textbf{Code (Improved)}
\begin{minted}{python}
import heapq
from typing import List, Tuple, Dict, Set

class MovieRentingSystemImproved:
    def __init__(self, n: int, entries: List[List[int]]):
        self.n = n
        self.price: Dict[Tuple[int, int], int] = {}
        # per-movie heap of (price, shop)
        self.avail_heap: Dict[int, List[Tuple[int, int]]] = {}
        # per-movie membership set of shops currently available
        self.avail_set: Dict[int, Set[int]] = {}
        # rented set
        self.rented: Set[Tuple[int, int]] = set()

        for s, m, p in entries:
            self.price[(s, m)] = p
            self.avail_set.setdefault(m, set()).add(s)
            self.avail_heap.setdefault(m, []).append((p, s))
        for m in self.avail_heap:
            heapq.heapify(self.avail_heap[m])

    def _clean_movie(self, m: int):
        h = self.avail_heap.get(m, [])
        aset = self.avail_set.get(m, set())
        while h and h[0][1] not in aset:
            heapq.heappop(h)

    def search(self, movie: int) -> List[int]:
        if movie not in self.avail_heap:
            return []
        self._clean_movie(movie)
        h = self.avail_heap[movie]
        aset = self.avail_set[movie]
        res, buf = [], []
        while h and len(res) < 5:
            p, s = heapq.heappop(h)
            if s in aset:
                res.append(s)
                buf.append((p, s))
            # stale entries are simply discarded
        for item in buf:
            heapq.heappush(h, item)
        return res

    def rent(self, shop: int, movie: int) -> None:
        if movie in self.avail_set and shop in self.avail_set[movie]:
            self.avail_set[movie].remove(shop)
        self.rented.add((shop, movie))

    def drop(self, shop: int, movie: int) -> None:
        if (shop, movie) in self.rented:
            self.rented.remove((shop, movie))
        self.avail_set.setdefault(movie, set()).add(shop)
        self.avail_heap.setdefault(movie, []).append((self.price[(shop, movie)], shop))
        heapq.heapify(self.avail_heap[movie])  # acceptable in improved, not optimal

    def report(self) -> List[List[int]]:
        cand = []
        for (s, m) in self.rented:
            cand.append((self.price[(s, m)], s, m))
        cand.sort()
        return [[s, m] for _, s, m in cand[:5]]

# Minimal LC-style wrapper
class Solution:
    pass

# Asserts (Improved)
def _improved_demo():
    mrs = MovieRentingSystemImproved(3, [
        [0, 1, 5], [0, 2, 6], [0, 3, 7],
        [1, 1, 4], [1, 2, 7], [2, 1, 5]
    ])
    assert mrs.search(1) == [1, 0, 2]
    mrs.rent(0, 1)
    mrs.rent(1, 2)
    assert mrs.report() == [[0, 1], [1, 2]]
    mrs.drop(1, 2)
    assert mrs.search(2) == [0, 1]

if __name__ == "__main__":
    _improved_demo()
\end{minted}
\VALIDATION{Validated against the sample sequence; ensured lazy cleaning discards stale items; verified tie-breaking by price then shop for search, and price then shop then movie for report.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two Lazy Min-Heaps: per-movie available and global rented}
\WHICHFORMULA{Use lazy priority queues both for per-movie available copies and for globally rented copies. Maintain membership sets to validate heap tops; clean on access; buffer and restore the top few to avoid mutating state on queries.}
\ASSUMPTIONS{Prices immutable; membership sets reflect truth; heaps may contain stale tuples but are cleaned on demand; operations are valid as per problem.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize:
\begin{itemize}
\item price map $P[(s,m)]$.
\item For each movie $m$, min-heap $H_m$ of $(P[(s,m)], s)$ and membership set $A_m$ of available shops.
\item Global rented heap $H_R$ of $(P[(s,m)], s, m)$ and membership set $R$ of rented pairs.
\end{itemize}
\item search(m): clean $H_m$ until top is in $A_m$; pop up to 5 valid tuples to form result, store in buffer, then push them back to restore $H_m$.
\item rent(s,m): remove $s$ from $A_m$; add $(s,m)$ to $R$ and push $(p,s,m)$ to $H_R$.
\item drop(s,m): remove $(s,m)$ from $R$; add $s$ to $A_m$ and push $(p,s)$ to $H_m$.
\item report(): clean $H_R$ until top is in $R$; pop up to 5 valid tuples, buffer, return pairs, then push them back to restore $H_R$.
\end{algosteps}
\OPTIMALITY{Each update is $O(\log N)$. Queries touch only the top $k\le 5$ elements plus amortized stale removals, yielding tight bounds for the required top-5 outputs. Any comparison-based method needs at least $\Omega(k)$ work; global re-sorting is avoidable with heaps.}
\COMPLEXITY{
\[
\begin{aligned}
\text{rent/drop} &:\ O(\log N) \\
\text{search}(m) &:\ O(k\log d_m + \alpha_m) \\
\text{report}() &:\ O(k\log |R| + \alpha_R)
\end{aligned}
\]
$k\le 5$ is constant; $\alpha_\cdot$ accounts for amortized lazy deletions over time.}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import heapq
from typing import List, Tuple, Dict, Set

class MovieRentingSystem:
    def __init__(self, n: int, entries: List[List[int]]):
        self.n = n
        # Fixed price map
        self.price: Dict[Tuple[int, int], int] = {}
        # Per-movie available heap and membership set
        self.avail_heap: Dict[int, List[Tuple[int, int]]] = {}
        self.avail_set: Dict[int, Set[int]] = {}
        # Global rented heap and membership set
        self.rented_heap: List[Tuple[int, int, int]] = []
        self.rented_set: Set[Tuple[int, int]] = set()

        for s, m, p in entries:
            self.price[(s, m)] = p
            self.avail_heap.setdefault(m, []).append((p, s))
            self.avail_set.setdefault(m, set()).add(s)
        for m in self.avail_heap:
            heapq.heapify(self.avail_heap[m])

    def _clean_avail(self, m: int):
        h = self.avail_heap.get(m, [])
        aset = self.avail_set.get(m, set())
        while h and h[0][1] not in aset:
            heapq.heappop(h)

    def _clean_rented(self):
        h = self.rented_heap
        rset = self.rented_set
        while h and (h[0][1], h[0][2]) not in rset:
            heapq.heappop(h)

    def search(self, movie: int) -> List[int]:
        if movie not in self.avail_heap:
            return []
        self._clean_avail(movie)
        h = self.avail_heap[movie]
        aset = self.avail_set[movie]
        res: List[int] = []
        buf: List[Tuple[int, int]] = []
        while h and len(res) < 5:
            p, s = heapq.heappop(h)
            if s in aset:
                res.append(s)
                buf.append((p, s))
            # stale entries are dropped
        for item in buf:
            heapq.heappush(h, item)
        return res

    def rent(self, shop: int, movie: int) -> None:
        # move (shop, movie) from available to rented
        if movie in self.avail_set and shop in self.avail_set[movie]:
            self.avail_set[movie].remove(shop)
        p = self.price[(shop, movie)]
        self.rented_set.add((shop, movie))
        heapq.heappush(self.rented_heap, (p, shop, movie))

    def drop(self, shop: int, movie: int) -> None:
        # move (shop, movie) from rented to available
        if (shop, movie) in self.rented_set:
            self.rented_set.remove((shop, movie))
        p = self.price[(shop, movie)]
        self.avail_set.setdefault(movie, set()).add(shop)
        self.avail_heap.setdefault(movie, []).append((p, shop))
        heapq.heapify(self.avail_heap[movie])  # could also push, but heapify keeps it simple

    def report(self) -> List[List[int]]:
        self._clean_rented()
        h = self.rented_heap
        rset = self.rented_set
        res: List[List[int]] = []
        buf: List[Tuple[int, int, int]] = []
        while h and len(res) < 5:
            p, s, m = heapq.heappop(h)
            if (s, m) in rset:
                res.append([s, m])
                buf.append((p, s, m))
            # stale entries dropped
        for item in buf:
            heapq.heappush(h, item)
        return res

# Minimal LC wrapper (not required for design problems)
class Solution:
    pass

# Asserts (Final)
def _final_demo():
    mrs = MovieRentingSystem(3, [
        [0, 1, 5], [0, 2, 6], [0, 3, 7],
        [1, 1, 4], [1, 2, 7], [2, 1, 5]
    ])
    assert mrs.search(1) == [1, 0, 2]
    mrs.rent(0, 1)
    mrs.rent(1, 2)
    assert mrs.report() == [[0, 1], [1, 2]]
    mrs.drop(1, 2)
    assert mrs.search(2) == [0, 1]

if __name__ == "__main__":
    _final_demo()
\end{minted}
\VALIDATION{Exactly 3 asserts replicate the sample flow. Additional random sequences should preserve invariants: a dropped movie reappears in \texttt{search}; rented movies appear in \texttt{report} with correct ordering.}
\RESULT{Implements \texttt{MovieRentingSystem} obeying all ordering rules: search returns up to 5 shops by (price, shop); report returns up to 5 rentals by (price, shop, movie).}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests mimic the operation sequence style. Include: empty structures, single movie multiple shops with ties, rent-drop cycles, and stress top-5 boundaries.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline vs Improved vs Final on small randomized inputs to ensure identical search/report results under same sequences.}
\LINE{EDGE-CASE GENERATOR}{Generate entries with:
\begin{itemize}
\item multiple shops sharing same price;
\item movies with only one copy;
\item no rented movies;
\item more than five candidates to test truncation.
\end{itemize}}
\begin{minted}{python}
import random
from typing import List

def gen_entries(n_shops: int, n_movies: int, density: float = 0.3, seed: int = 7) -> List[List[int]]:
    rng = random.Random(seed)
    entries = []
    for s in range(n_shops):
        for m in range(n_movies):
            if rng.random() < density:
                price = rng.randint(1, 10)
                entries.append([s, m, price])
    return entries

def cross_check():
    # small randomized test
    entries = gen_entries(5, 4, density=0.5, seed=1)
    base = MovieRentingSystemBaseline(5, entries)
    opt = MovieRentingSystem(5, entries)

    rng = random.Random(2)
    for _ in range(200):
        op = rng.choice(["search", "rent", "drop", "report"])
        if op == "search":
            m = rng.randint(0, 3)
            assert base.search(m) == opt.search(m)
        elif op == "report":
            assert base.report() == opt.report()
        elif op == "rent":
            # choose a random available pair if any
            # scan entries to find a valid unrented copy
            candidates = []
            for s, m, p in entries:
                if s in base.avail.get(m, set()):
                    candidates.append((s, m))
            if candidates:
                s, m = rng.choice(candidates)
                base.rent(s, m)
                opt.rent(s, m)
        elif op == "drop":
            if base.rented:
                s, m = rng.choice(list(base.rented))
                base.drop(s, m)
                opt.drop(s, m)

def _run_reference():
    mrs = MovieRentingSystem(3, [
        [0, 1, 5], [0, 2, 6], [0, 3, 7],
        [1, 1, 4], [1, 2, 7], [2, 1, 5]
    ])
    assert mrs.search(1) == [1, 0, 2]
    mrs.rent(0, 1); mrs.rent(1, 2)
    assert mrs.report() == [[0, 1], [1, 2]]
    mrs.drop(1, 2)
    assert mrs.search(2) == [0, 1]

if __name__ == "__main__":
    cross_check()
    _run_reference()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference implementation for LC "Design Movie Rental System"
import heapq
from typing import List, Tuple, Dict, Set

class MovieRentingSystem:
    def __init__(self, n: int, entries: List[List[int]]):
        self.n = n
        self.price: Dict[Tuple[int, int], int] = {}
        self.avail_heap: Dict[int, List[Tuple[int, int]]] = {}
        self.avail_set: Dict[int, Set[int]] = {}
        self.rented_heap: List[Tuple[int, int, int]] = []
        self.rented_set: Set[Tuple[int, int]] = set()
        for s, m, p in entries:
            self.price[(s, m)] = p
            self.avail_heap.setdefault(m, []).append((p, s))
            self.avail_set.setdefault(m, set()).add(s)
        for m in self.avail_heap:
            heapq.heapify(self.avail_heap[m])

    def _clean_avail(self, m: int) -> None:
        h = self.avail_heap.get(m, [])
        aset = self.avail_set.get(m, set())
        while h and h[0][1] not in aset:
            heapq.heappop(h)

    def _clean_rented(self) -> None:
        h = self.rented_heap
        rset = self.rented_set
        while h and (h[0][1], h[0][2]) not in rset:
            heapq.heappop(h)

    def search(self, movie: int) -> List[int]:
        if movie not in self.avail_heap:
            return []
        self._clean_avail(movie)
        h = self.avail_heap[movie]
        aset = self.avail_set[movie]
        res: List[int] = []
        buf: List[Tuple[int, int]] = []
        while h and len(res) < 5:
            p, s = heapq.heappop(h)
            if s in aset:
                res.append(s)
                buf.append((p, s))
        for item in buf:
            heapq.heappush(h, item)
        return res

    def rent(self, shop: int, movie: int) -> None:
        if movie in self.avail_set and shop in self.avail_set[movie]:
            self.avail_set[movie].remove(shop)
        p = self.price[(shop, movie)]
        self.rented_set.add((shop, movie))
        heapq.heappush(self.rented_heap, (p, shop, movie))

    def drop(self, shop: int, movie: int) -> None:
        if (shop, movie) in self.rented_set:
            self.rented_set.remove((shop, movie))
        p = self.price[(shop, movie)]
        self.avail_set.setdefault(movie, set()).add(shop)
        # Push is enough; heapify alternative is acceptable but slower.
        heapq.heappush(self.avail_heap.setdefault(movie, []), (p, shop))

    def report(self) -> List[List[int]]:
        self._clean_rented()
        h = self.rented_heap
        rset = self.rented_set
        res: List[List[int]] = []
        buf: List[Tuple[int, int, int]] = []
        while h and len(res) < 5:
            p, s, m = heapq.heappop(h)
            if (s, m) in rset:
                res.append([s, m])
                buf.append((p, s, m))
        for item in buf:
            heapq.heappush(h, item)
        return res

# Optional wrapper to satisfy LC template variety (not used by this problem)
class Solution:
    pass

# Deterministic self-checks
def _self_test():
    mrs = MovieRentingSystem(3, [
        [0, 1, 5], [0, 2, 6], [0, 3, 7],
        [1, 1, 4], [1, 2, 7], [2, 1, 5]
    ])
    assert mrs.search(1) == [1, 0, 2]
    mrs.rent(0, 1)
    mrs.rent(1, 2)
    assert mrs.report() == [[0, 1], [1, 2]]
    mrs.drop(1, 2)
    assert mrs.search(2) == [0, 1]

if __name__ == "__main__":
    _self_test()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maintain two lazy min-heaps: per-movie available shops and global rented copies, with membership sets for validity, to support top-5 queries and $O(\log N)$ updates.}
\WHY{Design problems test your ability to choose data structures that meet multiple ordered queries and updates under tight constraints.}
\CHECKLIST{
\begin{itemize}
\item Map each (shop, movie) to its fixed price.
\item Per-movie heap keyed by (price, shop) for \texttt{search}.
\item Global heap keyed by (price, shop, movie) for \texttt{report}.
\item Membership sets to validate heap entries lazily.
\item Buffer and restore top-$k$ elements during queries.
\item Move pairs between available and rented on updates.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item No available copy for a movie.
\item No rented movies to report.
\item Fewer than 5 candidates.
\item Ties in price across shops or movies.
\item Repeated rent/drop on the same pair.
\item Movies not present in the system.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Forgetting to restore popped valid items after \texttt{search}/\texttt{report}.
\item Not cleaning stale heap entries, leading to wrong results.
\item Using mutable price keys; prices are fixed and must be looked up by pair.
\item Misordering ties: report must break ties by price, then shop, then movie.
\item Using linear removal from heaps; prefer lazy deletion with membership sets.
\item Accidentally adding duplicates in sets instead of heaps.
\end{itemize}}
\FAILMODES{A naive full sort per query times out when many searches/reports occur on large sets. The lazy-heap approach avoids $O(n)$ deletions and $O(n\log n)$ re-sorts, sustaining $O(\log n)$ updates and $O(k\log n)$ queries.}
\ELI{Keep two priority lines: one for each movie’s available shops and one global for all rented copies. When you rent or drop, you move tickets between lines. When you search or report, you peek at the first few tickets, skipping any that are no longer valid.}
\NotePages{3}

\end{document}