% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Microtransactions (hard version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1165/F2}}
\LINE{DIFFICULTY / RATING}{2000}
\STATEMENT{The only difference between easy and hard versions is constraints.

Ivan plays a computer game that contains some microtransactions to make characters look cooler. Since Ivan wants his character to be really cool, he wants to use some of these microtransactions — and he will not start playing until he gets all of them.

Each day (during the morning) Ivan earns exactly one burle.

There are $n$ types of microtransactions in the game. Each microtransaction costs $2$ burles usually and $1$ burle if it is on sale. Ivan has to order exactly $k_i$ microtransactions of the $i$-th type (he orders microtransactions during the evening).

Ivan can order any (possibly zero) number of microtransactions of any types during any day (of course, if he has enough money to do it). If the microtransaction he wants to order is on sale then he can buy it for $1$ burle and otherwise he can buy it for $2$ burles.

There are also $m$ special offers in the game shop. The $j$-th offer $(d_j, t_j)$ means that microtransactions of the $t_j$-th type are on sale during the $d_j$-th day.

Ivan wants to order all microtransactions as soon as possible. Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing.

Input:
The first line of the input contains two integers $n$ and $m$ ($1 \le n, m \le 2 \cdot 10^5$) — the number of types of microtransactions and the number of special offers in the game shop.

The second line of the input contains $n$ integers $k_1, k_2, \dots, k_n$ ($0 \le k_i \le 2 \cdot 10^5$), where $k_i$ is the number of copies of microtransaction of the $i$-th type Ivan has to order. It is guaranteed that sum of all $k_i$ is not less than $1$ and not greater than $2 \cdot 10^5$.

The next $m$ lines contain special offers. The $j$-th of these lines contains the $j$-th special offer. It is given as a pair of integers $(d_j, t_j)$ ($1 \le d_j \le 2 \cdot 10^5, 1 \le t_j \le n$) and means that microtransactions of the $t_j$-th type are on sale during the $d_j$-th day.

Output:
Print one integer — the minimum day when Ivan can order all microtransactions he wants and actually start playing.}
\BREAKDOWN{We need to find the minimum day $D$ such that with $D$ coins earned over $D$ days, Ivan can schedule discounted purchases on sale days (cost $1$) and pay full price ($2$) for any remaining items. This suggests a monotone predicate in $D$ and thus a binary search with a feasibility check.}
\ELI{Binary search the day and, for a fixed day, greedily buy discounted items at their last sale before that day; then check if leftover coins suffice to pay double for remaining items.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m$; array $k$ of length $n$ with $k_i \ge 0$ and $\sum k_i \in [1, 2 \cdot 10^5]$; $m$ pairs $(d_j, t_j)$ with $1 \le d_j \le 2 \cdot 10^5$ and $1 \le t_j \le n$.}
\OUTPUTS{One integer: the minimum day $D$ when Ivan can finish buying all required microtransactions.}
\SAMPLES{Example 1: $n=2, m=2$, $k=[1,1]$, offers $(1,1)$, $(2,2)$ $\rightarrow$ answer $2$.

Example 2: $n=1, m=0$, $k=[3]$ $\rightarrow$ answer $6$ (no sales, each costs $2$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let there be $n$ item types, $k_i$ required of type $i$. Let $\mathcal{S}_i \subseteq \{1,\ldots,D\}$ be the set of sale days (at most one coin earned per day). On day $d$, Ivan has $d$ coins earned minus prior spending. Discounted purchases on day $d$ cost $1$; otherwise $2$. We ask if there exists a schedule within $D$ days to buy all items.}
\varmapStart
\var{n}{number of types}
\var{m}{number of offers}
\var{k_i}{required items of type $i$}
\var{(d_j,t_j)}{offer: type $t_j$ is on sale on day $d_j$}
\var{D}{candidate day to finish}
\var{c(d)}{coins on hand at the start of evening day $d$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Feasible}(D) \iff \exists \text{ schedule s.t. total spend} \le D \text{ and discounted purchases occur only on their sale days.}
\end{BreakableEquation*}
}
\ASSUMPTIONS{Unlimited availability per type on sale day; purchases in the evening after morning income; buying any non-sale item costs $2$.}
\INVARIANTS{It is optimal to buy discounted items for type $i$ at its last sale day $\le D$. Remaining items (across all types) cost $2$ each and can be bought anytime as long as total coins suffice.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly try days $D=1,2,\ldots$ until feasible using a feasibility check that greedily buys discounted items on their last available sale day.}
\ASSUMPTIONS{Monotonicity: if $D$ is feasible, then any $D' \ge D$ is feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Preprocess offers as given.
\item For $D=1,2,\ldots$ up to a safe upper bound, run feasibility check.
\item Stop at the first feasible $D$.
\end{algosteps}
\COMPLEXITY{The feasibility check runs in $O(n + m + D)$. The brute-force outer loop is $O(U)$ where $U$ is the answer, leading to $O(U \cdot (n+m+U))$ in the worst case — too slow for hard constraints, but OK as a conceptual baseline.}
\[
\begin{aligned}
T_{\text{baseline}}(U) &\approx \sum_{D=1}^{U} \bigl(\Theta(n+m+D)\bigr) \\
&= \Theta\bigl(U(n+m)\bigr) + \Theta\bigl(U^2\bigr).
\end{aligned}
\]
\CORRECTNESS{Greedy purchase at the last sale day per type is optimal because moving any discounted purchase later (to its last sale day) never hurts feasibility and preserves or increases available coins earlier.}
\EDGECASES{Types with $k_i=0$; days with multiple offers of the same type; no offers at all; large $D$ upper bound.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List, Tuple
import sys
import io

def read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    k = [0] + [int(next(it)) for _ in range(n)]
    offers = []
    for _ in range(m):
        d = int(next(it)); t = int(next(it))
        offers.append((d, t))
    return n, m, k, offers

def feasible_day(D: int, n: int, k_req: List[int], offers: List[Tuple[int, int]]) -> bool:
    # Copy requirements
    need = k_req[:]  # 1-indexed
    # Last sale day for each type within [1..D]
    last = [0] * (n + 1)
    for d, t in offers:
        if d <= D and d > last[t]:
            last[t] = d
    # Bucket types by their last sale day
    buckets = [[] for _ in range(D + 1)]
    for t in range(1, n + 1):
        if need[t] > 0 and last[t] > 0:
            buckets[last[t]].append(t)
    coins = 0
    # Simulate days, earning 1 and buying discounted at last sale days
    for day in range(1, D + 1):
        coins += 1
        for t in buckets[day]:
            if need[t] == 0:
                continue
            buy = min(need[t], coins)
            need[t] -= buy
            coins -= buy
    # After all discounted purchases, pay 2 per remaining
    leftover = sum(need[1:])
    return leftover * 2 <= coins

def solve_case(n: int, m: int, k: List[int], offers: List[Tuple[int, int]]) -> int:
    total = sum(k[1:])
    # Safe upper bound: no discounts -> need 2*total days
    hi = 2 * total + m + 10
    # Brute force increase D until feasible
    for D in range(1, hi + 1):
        if feasible_day(D, n, k, offers):
            return D
    return hi

def solve_all():
    n, m, k, offers = read_input()
    ans = solve_case(n, m, k, offers)
    print(ans)

def _solve_io(s: str) -> str:
    backup_stdin = sys.stdin
    backup_stdout = sys.stdout
    try:
        sys.stdin = io.StringIO(s)
        out = io.StringIO()
        sys.stdout = out
        solve_all()
        return out.getvalue()
    finally:
        sys.stdin = backup_stdin
        sys.stdout = backup_stdout

def _run_tests():
    # Test 1: two types, each on its own day
    s = "2 2\n1 1\n1 1\n2 2\n"
    out = _solve_io(s).strip()
    assert out == "2"
    # Test 2: single type, no offers, need 3 items -> 6 days
    s = "1 0\n3\n"
    out = _solve_io(s).strip()
    assert out == "6"
    # Test 3: multiple offers for same type, last-day logic
    s = "1 3\n2\n1 1\n2 1\n2 1\n"
    out = _solve_io(s).strip()
    # Day 2: earn 2, buy 2 at cost 1 each -> 2 days
    assert out == "2"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _run_tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Covered: trivial, no-offer, and repeated-offer cases; sanity of last-sale-day greedy.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Exploit monotonicity to binary search the answer $D$. Keep the same optimal feasibility check (buy at last sale day), yielding $O((n+m+D)\log U)$ time, where $U$ is an upper bound on the answer.}
\ASSUMPTIONS{Feasibility predicate is monotone in $D$. Using last sale day buckets ensures maximal use of discounts without early spending.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Binary search $D$ in $[1, 2\sum k_i + m + 10]$.
\item For a fixed $D$, compute for each type its last sale day $\le D$ and bucket types by that day.
\item Simulate days $1\ldots D$: each day earn one coin and buy as many discounted items as possible from that bucket; finally check if remaining coins can pay $2$ per leftover item.
\end{algosteps}
\COMPLEXITY{Each feasibility check is $O(n+m+D)$; with $\log U$ checks, total time $O((n+m+U)\log U)$ and $O(n+U)$ space per check.}
\[
\begin{aligned}
T(n,m,U) &= \Theta\bigl((n+m+U)\log U\bigr).
\end{aligned}
\]
\CORRECTNESS{Delaying each discounted purchase to the last sale day weakly dominates any earlier discounted purchase schedule. Discounted items are always prioritized over full-price items, and any remaining items require $2$ coins each; thus the check is both necessary and sufficient.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import List, Tuple
import io

def read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    k = [0] + [int(next(it)) for _ in range(n)]
    offers = []
    for _ in range(m):
        d = int(next(it)); t = int(next(it))
        offers.append((d, t))
    return n, m, k, offers

def feasible_day(D: int, n: int, k_req: List[int], offers: List[Tuple[int, int]]) -> bool:
    need = k_req[:]
    last = [0] * (n + 1)
    for d, t in offers:
        if d <= D and d > last[t]:
            last[t] = d
    buckets = [[] for _ in range(D + 1)]
    for t in range(1, n + 1):
        if need[t] > 0 and last[t] > 0:
            buckets[last[t]].append(t)
    coins = 0
    for day in range(1, D + 1):
        coins += 1
        for t in buckets[day]:
            if need[t] == 0:
                continue
            buy = min(need[t], coins)
            need[t] -= buy
            coins -= buy
    leftover = sum(need[1:])
    return leftover * 2 <= coins

def solve_case(n: int, m: int, k: List[int], offers: List[Tuple[int, int]]) -> int:
    total = sum(k[1:])
    if total == 0:
        return 0
    lo, hi = 1, 2 * total + m + 10
    ans = hi
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible_day(mid, n, k, offers):
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

def solve_all():
    n, m, k, offers = read_input()
    print(solve_case(n, m, k, offers))

def _solve_io(s: str) -> str:
    backup_stdin = sys.stdin
    backup_stdout = sys.stdout
    try:
        sys.stdin = io.StringIO(s)
        out = io.StringIO()
        sys.stdout = out
        solve_all()
        return out.getvalue()
    finally:
        sys.stdin = backup_stdin
        sys.stdout = backup_stdout

def _run_tests():
    s = "2 2\n1 1\n1 1\n2 2\n"
    assert _solve_io(s).strip() == "2"
    s = "1 0\n3\n"
    assert _solve_io(s).strip() == "6"
    s = "2 1\n0 5\n3 2\n"
    # Need 5 items of type 2, one sale on day 3: buy 3 days coins -> 3 discounted, 2 left -> need 4 more coins; total 7
    assert _solve_io(s).strip() == "7"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _run_tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Edge cases with $k_i=0$; single sale mid-way; no offers.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Binary search on the day $D$ with the last-sale-day greedy feasibility check. This is the standard accepted solution for CF 1165F2.}
\ASSUMPTIONS{Unlimited buys per type on a sale day; coin accrual is exactly one per day; monotone feasibility in $D$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute a safe upper bound $U = 2\sum k_i + m + 10$.
\item Binary search $D \in [1, U]$.
\item For each $D$, assign each type $i$ to its last sale day $\le D$ (if any); on each day, spend coins on that day’s discounted bucket; at the end, ensure remaining coins cover $2$ per leftover item.
\end{algosteps}
\OPTIMALITY{Any schedule can be transformed so that each discounted item is bought on the last sale day available before $D$, never consuming earlier coins, thus maximizing flexibility. This exchange argument proves the greedy structure is optimal.}
\COMPLEXITY{Each check is $O(n+m+D)$ time and $O(n+D)$ space; overall $O((n+m+U)\log U)$ time. With constraints $n,m,\sum k_i \le 2\cdot 10^5$, this easily fits.}
\[
\begin{aligned}
T(n,m,U) &= \Theta\bigl((n+m+U)\log U\bigr).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import List, Tuple
import io

def read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    k = [0] + [int(next(it)) for _ in range(n)]
    offers = []
    for _ in range(m):
        d = int(next(it)); t = int(next(it))
        offers.append((d, t))
    return n, m, k, offers

def feasible_day(D: int, n: int, k_req: List[int], offers: List[Tuple[int, int]]) -> bool:
    need = k_req[:]  # 1-indexed
    last = [0] * (n + 1)
    for d, t in offers:
        if d <= D and d > last[t]:
            last[t] = d
    buckets = [[] for _ in range(D + 1)]
    for t in range(1, n + 1):
        if need[t] > 0 and last[t] > 0:
            buckets[last[t]].append(t)
    coins = 0
    for day in range(1, D + 1):
        coins += 1
        for t in buckets[day]:
            if need[t] == 0 or coins == 0:
                continue
            buy = min(need[t], coins)
            need[t] -= buy
            coins -= buy
    leftover = sum(need[1:])
    return leftover * 2 <= coins

def solve_case(n: int, m: int, k: List[int], offers: List[Tuple[int, int]]) -> int:
    total = sum(k[1:])
    if total == 0:
        return 0
    lo, hi = 1, 2 * total + m + 10
    ans = hi
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible_day(mid, n, k, offers):
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

def solve_all():
    n, m, k, offers = read_input()
    print(solve_case(n, m, k, offers))

def _solve_io(s: str) -> str:
    backup_stdin = sys.stdin
    backup_stdout = sys.stdout
    try:
        sys.stdin = io.StringIO(s)
        out = io.StringIO()
        sys.stdout = out
        solve_all()
        return out.getvalue()
    finally:
        sys.stdin = backup_stdin
        sys.stdout = backup_stdout

def _run_tests():
    # 1) Simple disjoint sales
    s = "2 2\n1 1\n1 1\n2 2\n"
    assert _solve_io(s).strip() == "2"
    # 2) No sales
    s = "1 0\n3\n"
    assert _solve_io(s).strip() == "6"
    # 3) Mixed: partial discount, remainder full-price
    s = "2 2\n2 1\n1 1\n2 1\n"
    # Day 2: coins 2; type1 last sale day=2, need 2 -> buy both; type2 no sale -> 1 item full price needs +2 coins on top -> need total 4 days
    assert _solve_io(s).strip() == "4"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _run_tests()
    else:
        solve_all()
\end{minted}
\VALIDATION{Exactly three I\slash O asserts covering disjoint sales, no sales, and mixed scenarios.}
\RESULT{The printed integer is the minimum day $D$ such that all purchases can be completed by the evening of day $D$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for trivial, no-offer, and mixed-offer cases; random small cases to cross-check against a slow brute force.}
\LINE{CROSS-CHECKS}{Compare the brute-force (Approach A) and the optimal (Approach C) on tiny random instances; they must match.}
\LINE{EDGE-CASE GENERATOR}{Generate cases with zero-demand types, many offers on the same type, clustered late sales, and no offers.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_case(n: int, m: int, max_day: int, max_k: int, seed: int = 0):
    random.seed(seed)
    k = [0] + [random.randint(0, max_k) for _ in range(n)]
    if sum(k[1:]) == 0:
        k[random.randint(1, n)] = 1
    offers = []
    for _ in range(m):
        d = random.randint(1, max_day)
        t = random.randint(1, n)
        offers.append((d, t))
    return n, m, k, offers

def slow_bruteforce(n, m, k, offers):
    # Increase D until feasible using the same feasibility checker
    total = sum(k[1:])
    hi = 2 * total + m + 10
    for D in range(1, hi + 1):
        if feasible_day(D, n, k, offers):
            return D
    return hi

def cross_check():
    for seed in range(20):
        n, m, k, offers = gen_case(n=4, m=6, max_day=8, max_k=3, seed=seed)
        bf = slow_bruteforce(n, m, k, offers)
        opt = solve_case(n, m, k, offers)
        assert bf == opt

# Minimal stubs of functions used above (copied from final solution)
def feasible_day(D, n, k_req, offers):
    need = k_req[:]
    last = [0] * (n + 1)
    for d, t in offers:
        if d <= D and d > last[t]:
            last[t] = d
    buckets = [[] for _ in range(D + 1)]
    for t in range(1, n + 1):
        if need[t] > 0 and last[t] > 0:
            buckets[last[t]].append(t)
    coins = 0
    for day in range(1, D + 1):
        coins += 1
        for t in buckets[day]:
            buy = min(need[t], coins)
            need[t] -= buy
            coins -= buy
    return sum(need[1:]) * 2 <= coins

def solve_case(n, m, k, offers):
    total = sum(k[1:])
    if total == 0:
        return 0
    lo, hi = 1, 2 * total + m + 10
    ans = hi
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible_day(mid, n, k, offers):
            ans = mid; hi = mid - 1
        else:
            lo = mid + 1
    return ans

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF)
import sys
from typing import List, Tuple

def read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    k = [0] + [int(next(it)) for _ in range(n)]
    offers = []
    for _ in range(m):
        d = int(next(it)); t = int(next(it))
        offers.append((d, t))
    return n, m, k, offers

def feasible_day(D: int, n: int, k_req: List[int], offers: List[Tuple[int, int]]) -> bool:
    need = k_req[:]
    last = [0] * (n + 1)
    for d, t in offers:
        if d <= D and d > last[t]:
            last[t] = d
    buckets = [[] for _ in range(D + 1)]
    for t in range(1, n + 1):
        if need[t] > 0 and last[t] > 0:
            buckets[last[t]].append(t)
    coins = 0
    for day in range(1, D + 1):
        coins += 1
        for t in buckets[day]:
            if need[t] == 0 or coins == 0:
                continue
            buy = min(need[t], coins)
            need[t] -= buy
            coins -= buy
    leftover = sum(need[1:])
    return leftover * 2 <= coins

def solve_case(n: int, m: int, k: List[int], offers: List[Tuple[int, int]]) -> int:
    total = sum(k[1:])
    if total == 0:
        return 0
    lo, hi = 1, 2 * total + m + 10
    ans = hi
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible_day(mid, n, k, offers):
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

def solve_all():
    n, m, k, offers = read_input()
    print(solve_case(n, m, k, offers))

# tiny asserts for sanity if run interactively
def _tests():
    import io
    def run_io(s: str) -> str:
        backup_in, backup_out = sys.stdin, sys.stdout
        try:
            sys.stdin = io.StringIO(s)
            out = io.StringIO(); sys.stdout = out
            solve_all()
            return out.getvalue()
        finally:
            sys.stdin, sys.stdout = backup_in, backup_out
    assert run_io("2 2\n1 1\n1 1\n2 2\n").strip() == "2"
    assert run_io("1 0\n3\n").strip() == "6"
    assert run_io("2 1\n0 5\n3 2\n").strip() == "7"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _tests()
    else:
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Binary search the minimal day and, for each candidate, greedily buy discounted items at their last sale days; remaining items cost $2$ each.}
\WHY{This pattern (monotone predicate + greedy feasibility) is common in scheduling and resource allocation problems with deadlines and discounts.}
\CHECKLIST{
- Compute safe upper bound $U=2\sum k_i + m + 10$.
- For each mid, compute last sale day per type within $[1..D]$.
- Bucket types by last sale day.
- Simulate: earn 1 per day; spend on bucket items that day.
- Check if leftover items fit in remaining coins at $2$ per item.
}
\EDGECASES{
- $\sum k_i=0$ (answer $0$).
- Types with $k_i=0$ (ignore).
- Multiple offers on same day and type.
- Offers beyond $D$ are ignored during a check.
- No offers at all (answer $2\sum k_i$).
- Large $m$ but sparse useful offers.
- All sales very early vs. very late.
}
\PITFALLS{
- Forgetting to prioritize discounts (must buy on sale).
- Buying discounted items before their last sale day wastes early coins.
- Off-by-one on day indexing.
- Not resetting need/coins per feasibility check.
- Overflow not an issue in Python, but watch performance with too-large $U$.
- Mixing 0- vs. 1-indexing of types.
}
\FAILMODES{A naive per-day greedy without last-sale grouping can overcount discounted purchases across multiple sale days for the same type. The last-sale-day bucketing prevents double counting and ensures correctness.}
\ELI{Save your coins until the last chance to get a discount on each item type; after taking all discounts you can, see if you have enough coins left to pay double for the rest. Increase the number of days until that is possible.}
\NotePages{3}

\end{document}