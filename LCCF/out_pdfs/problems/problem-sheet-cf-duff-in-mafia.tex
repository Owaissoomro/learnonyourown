% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Duff in Mafia}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/587/D}}
\LINE{DIFFICULTY / RATING}{3100}
\STATEMENT{Duff is one of the heads of Mafia in her country, Andarz Gu. Andarz Gu has $n$ cities (numbered from $1$ to $n$) connected by $m$ bidirectional roads (numbered by $1$ to $m$).

Each road has a destructing time, and a color. $i$-th road connects cities $v_i$ and $u_i$ and its color is $c_i$ and its destructing time is $t_i$.

Mafia wants to destruct a matching in Andarz Gu. A matching is a subset of roads such that no two roads in this subset has common endpoint. They can destruct these roads in parallel, i.e. the total destruction time is a maximum over destruction times of all selected roads.

They want two conditions to be satisfied:
\begin{enumerate}
\item The remaining roads form a proper coloring.
\item Destructing time of this matching is minimized.
\end{enumerate}

The remaining roads after destructing this matching form a proper coloring if and only if no two roads of the same color have same endpoint, or, in other words, edges of each color should form a matching.

There is no programmer in Mafia. That is why Duff asked for your help. Please help her and determine which matching to destruct in order to satisfy those conditions (or state that this is not possible).

Input: The first line of input contains two integers $n$ and $m$ ($2 \le n \le 5 \times 10^4$ and $1 \le m \le 5 \times 10^4$), number of cities and number of roads in the country.

The next $m$ lines contain the roads. $i$-th of them contains four integers $v_i$, $u_i$, $c_i$ and $t_i$ ($1 \le v_i, u_i \le n$, $v_i \ne u_i$ and $1 \le c_i, t_i \le 10^9$ for each $1 \le i \le m$).

Output: In the first line, print ``Yes'' if satisfying the first condition is possible and ``No'' otherwise.

If it is possible, then print two integers $t$ and $k$ in the second line, the minimum destructing time and the number of roads in the matching ($0 \le k \le \left\lfloor \tfrac{n}{2} \right\rfloor$).

In the third line print $k$ distinct integers separated by spaces, indices of the roads in the matching in any order. Roads are numbered starting from one in order of their appearance in the input.

If there is more than one solution, print any of them.

Note: Graph of Andarz Gu in the first sample case is as follows:

A solution would be to destruct the roads with crosses.

Graph of Andarz Gu in the second sample case is as follows.}
\BREAKDOWN{We must delete a set of edges that itself is a matching, so that among remaining edges, for every color, incident degree per vertex is at most one. Minimize the maximal deletion time among chosen edges and output any optimal matching or report impossibility.}
\ELI{Pick some edges to remove but never two sharing a vertex; after removal, at each vertex and for each color, keep at most one edge. Choose them so the slowest removed edge is as small as possible.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m$; then $m$ lines each with $v_i, u_i, c_i, t_i$.
\begin{bullets}
\item $2 \le n \le 5 \times 10^4$
\item $1 \le m \le 5 \times 10^4$
\item $1 \le v_i, u_i \le n$, $v_i \ne u_i$
\item $1 \le c_i, t_i \le 10^9$
\end{bullets}}
\OUTPUTS{
\begin{bullets}
\item Line 1: ``Yes'' if feasible, ``No'' otherwise.
\item If ``Yes'': Line 2: $t$ and $k$ where $t$ is the minimal possible maximum destruction time among removed edges and $k$ is the count of removed edges.
\item Line 3: $k$ distinct edge indices in any order (1-based).
\end{bullets}}
\SAMPLES{
Example 1 (feasible):
\begin{verbatim}
3 2
1 2 7 5
2 3 7 1
\end{verbatim}
One optimal answer: Yes; t=1; k=1; remove edge 2.

Example 2 (infeasible):
\begin{verbatim}
5 4
1 2 1 1
1 3 1 1
1 4 2 1
1 5 2 1
\end{verbatim}
Answer: No.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let edges be $E=\{1,\ldots,m\}$ with endpoints $(u_i,v_i)$, color $c_i$, time $t_i$. Choose $S \subseteq E$ to delete such that:
\begin{bullets}
\item $S$ is a matching: no two edges in $S$ share a vertex.
\item For every vertex $v$ and color $c$, among remaining edges $E \setminus S$, at most one incident edge at $v$ has color $c$.
\end{bullets}
Minimize $\max\{t_i: i \in S\}$ subject to feasibility.}
\varmapStart
\var{S}{set of deleted edges (must be a matching)}
\var{t^\star}{optimal maximum destruction time among deleted edges}
\var{X_i}{indicator that edge $i$ is deleted ($1$) or kept ($0$)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Matching delete:}\quad \forall v,\ \sum_{i \in E:\ v \in \{u_i,v_i\}} X_i \le 1.\\
&\text{Proper coloring remain:}\quad \forall v,\ \forall c,\ \sum_{i \in E:\ v \in \{u_i,v_i\},\ c_i=c} (1-X_i) \le 1.\\
&\text{Objective:}\quad t^\star=\min_{X\in\{0,1\}^m}\ \max\{t_i: X_i=1\}\ \text{ s.t. constraints.}
\end{aligned}
\]
}
\ASSUMPTIONS{Edges are simple (no self-loops). Multiple edges allowed. Colors are arbitrary integers.}
\INVARIANTS{
\begin{bullets}
\item If two same-colored edges meet at a vertex and both must be kept, instance is infeasible.
\item Deletions form a matching, hence each vertex contributes to at most one deletion.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all matchings $S$ and check feasibility; among feasible, minimize $\max t_i$.}
\ASSUMPTIONS{Feasible only for tiny $m$ due to combinatorial explosion.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate all subsets $S \subseteq E$ that are matchings.
\item Check if remaining edges per vertex per color have degree at most one.
\item Track minimal $\max\{t_i: i\in S\}$ and store the set.
\end{algosteps}
\COMPLEXITY{Exponential in $m$.}
\[
\begin{aligned}
T(m) &\in \Theta(3^{m/3})\ \text{(number of matchings in worst-case)}\\
S(m) &\in \Theta(m)
\end{aligned}
\]
\CORRECTNESS{Exhaustive search checks all candidate deletion matchings.}
\EDGECASES{Empty deletion ($S=\varnothing$) yields $t=0$ if already properly colored.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from itertools import combinations

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return 0, 0, []
    edges = []
    for i in range(m):
        v = int(next(it)); u = int(next(it)); c = int(next(it)); t = int(next(it))
        edges.append((v-1, u-1, c, t, i+1))
    return n, m, edges

def is_matching(edge_set, edges):
    used = set()
    for idx in edge_set:
        v, u, _, _, _ = edges[idx]
        if v in used or u in used: return False
        used.add(v); used.add(u)
    return True

def proper_after_delete(Sset, n, edges):
    by_vc = {}
    kept = [True]*len(edges)
    for idx in Sset:
        kept[idx] = False
    for i,e in enumerate(edges):
        if not kept[i]: continue
        v,u,c,_,_ = e
        for w in (v,u):
            key = (w,c)
            if key in by_vc: return False
            by_vc[key] = True
    return True

def brute_solve(n, m, edges):
    best_t = None
    best_S = []
    idxs = list(range(m))
    # tiny brute for tests (cap to small m)
    if m > 18:
        return None
    for r in range(0, m+1):
        for comb in combinations(idxs, r):
            if not is_matching(comb, edges): continue
            if not proper_after_delete(set(comb), n, edges): continue
            tmax = max([edges[i][3] for i in comb], default=0)
            if best_t is None or tmax < best_t:
                best_t = tmax
                best_S = list(comb)
    if best_t is None:
        return "No\n"
    out = []
    out.append("Yes")
    out.append(f"{best_t} {len(best_S)}")
    out.append(" ".join(str(edges[i][4]) for i in best_S))
    return "\n".join(out) + "\n"

def solve_case(data: str) -> str:
    n,m,edges = read_input(data)
    if m == 0:
        return "Yes\n0 0\n\n"
    return brute_solve(n,m,edges) or "No\n"

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Tiny self-checks for baseline
        n=3; m=2
        edges=[(0,1,7,5,1),(1,2,7,1,2)]
        ans = brute_solve(n,m,edges)
        assert ans.startswith("Yes")
        n=5; m=4
        edges=[(0,1,1,1,1),(0,2,1,1,2),(0,3,2,1,3),(0,4,2,1,4)]
        ans = brute_solve(n,m,edges)
        assert ans.strip()=="No"
        print("OK")
        return
    print(solve_case(data), end="")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{The asserts check a feasible and an infeasible tiny case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search on Threshold + 2-SAT with Pairwise Constraints}
\WHICHFORMULA{For a fixed threshold $T$, edges with $t_i>T$ cannot be deleted. Decide satisfiability via 2-SAT on variables $X_i$ (delete or keep) with pairwise clauses.}
\ASSUMPTIONS{Translate:
\begin{bullets}
\item Matching-delete: For any two edges sharing a vertex, not both deleted: $\neg(X_i \wedge X_j)$.
\item Proper-keep per $(v,c)$: For any two edges of same color at a vertex, not both kept: $\neg((\neg X_i)\wedge(\neg X_j))$.
\item Force $X_i=\text{False}$ for $t_i>T$.
\end{bullets}}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Collect all times, include $0$, and binary search minimal $T$.
\item For each $T$, build a 2-SAT instance with $m$ variables $X_i$.
\item Add pairwise implications for conflicts and per-$(v,c)$ keeps; force bad edges to be kept.
\item If satisfiable, record assignment and continue binary search.
\end{algosteps}
\COMPLEXITY{Pairwise constraints may be quadratic in worst-case per bucket at a vertex; this can time out.}
\[
\begin{aligned}
T(n,m) &\approx O(\log m)\cdot O\bigl(m + P\bigr),\ \text{with }P\text{ potentially }O(m^2) \\
\end{aligned}
\]
\CORRECTNESS{Clauses encode exactly the logical constraints. Binary search on $T$ is valid as feasibility is monotone in $T$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import defaultdict

class TwoSAT:
    def __init__(self, n):
        self.N = n
        self.g = [[] for _ in range(2*n)]
        self.gr = [[] for _ in range(2*n)]
    @staticmethod
    def neg(lit): return lit ^ 1
    @staticmethod
    def lit(var, val): return (var << 1) | (1 if val else 0)
    def add_imp(self, a, b):
        self.g[a].append(b)
        self.gr[b].append(a)
    def add_or(self, a, b):
        self.add_imp(self.neg(a), b)
        self.add_imp(self.neg(b), a)
    def add_unit(self, a):
        self.add_imp(self.neg(a), a)
    def satisfiable(self):
        n = 2*self.N
        used = [False]*n
        order = []
        def dfs(v):
            used[v] = True
            for to in self.g[v]:
                if not used[to]:
                    dfs(to)
            order.append(v)
        for v in range(n):
            if not used[v]:
                dfs(v)
        comp = [-1]*n
        j = 0
        def rdfs(v, j):
            comp[v] = j
            for to in self.gr[v]:
                if comp[to] == -1:
                    rdfs(to, j)
        for v in reversed(order):
            if comp[v] == -1:
                rdfs(v, j); j += 1
        assignment = [False]*self.N
        for i in range(self.N):
            if comp[2*i] == comp[2*i+1]:
                return False, []
            assignment[i] = comp[2*i] > comp[2*i+1]
        return True, assignment

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return 0, 0, []
    edges = []
    for i in range(m):
        v = int(next(it)); u = int(next(it)); c = int(next(it)); t = int(next(it))
        edges.append((v-1, u-1, c, t, i+1))
    return n, m, edges

def solve_with_pairwise(n, m, edges):
    times = sorted({0} | {e[3] for e in edges})
    inc = [[] for _ in range(n)]
    by_vc = defaultdict(list)
    for i,(v,u,c,t,_) in enumerate(edges):
        inc[v].append(i); inc[u].append(i)
        by_vc[(v,c)].append(i); by_vc[(u,c)].append(i)
    def feasible(T):
        ts = TwoSAT(m)
        # matching delete: for any two incident edges at a vertex, not both deleted
        for v in range(n):
            lst = inc[v]
            L = len(lst)
            for i1 in range(L):
                for i2 in range(i1+1, L):
                    a = lst[i1]; b = lst[i2]
                    ts.add_or(TwoSAT.lit(a, False), TwoSAT.lit(b, False))  # (¬Xa ∨ ¬Xb) i.e., not both True
        # proper keep per (v,c): for any two with same (v,c), not both kept
        for key, lst in by_vc.items():
            L = len(lst)
            for i1 in range(L):
                for i2 in range(i1+1, L):
                    a = lst[i1]; b = lst[i2]
                    ts.add_or(TwoSAT.lit(a, True), TwoSAT.lit(b, True))   # (Xa ∨ Xb) i.e., at least one deleted
        # force bad edges to be kept (Xi=False)
        for i, e in enumerate(edges):
            if e[3] > T:
                ts.add_unit(TwoSAT.lit(i, False))
        ok, assign = ts.satisfiable()
        return ok, assign
    lo, hi = 0, len(times)-1
    best = None
    best_assign = None
    if not feasible(times[-1])[0]:
        return "No\n"
    while lo <= hi:
        mid = (lo+hi)//2
        ok, assign = feasible(times[mid])
        if ok:
            best = times[mid]; best_assign = assign; hi = mid-1
        else:
            lo = mid+1
    S = [i+1 for i,x in enumerate(best_assign) if x]
    out = []
    out.append("Yes")
    out.append(f"{best} {len(S)}")
    out.append(" ".join(map(str, S)))
    return "\n".join(out) + "\n"

def solve_case(data: str) -> str:
    n,m,edges = read_input(data)
    if m == 0: return "Yes\n0 0\n\n"
    return solve_with_pairwise(n,m,edges)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # simple checks
        n=3; m=2
        edges=[(0,1,7,5,1),(1,2,7,1,2)]
        ans = solve_with_pairwise(n,m,edges)
        assert ans.startswith("Yes")
        n=5; m=4
        edges=[(0,1,1,1,1),(0,2,1,1,2),(0,3,2,1,3),(0,4,2,1,4)]
        ans = solve_with_pairwise(n,m,edges)
        assert ans.strip()=="No"
        print("OK")
        return
    print(solve_case(data), end="")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Pairwise version validated on small crafted cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Binary Search + 2-SAT with Linear At-Most-One Encodings}
\WHICHFORMULA{Use 2-SAT variables $X_i$ (delete) and encode two families of \emph{at-most-one} constraints with Sinz's sequential encoding to avoid quadratic blow-up:
\begin{bullets}
\item Per vertex $v$: $\sum_{i\ni v} X_i \le 1$ (deletion matching).
\item Per $(v,c)$ bucket: $\sum_{i\ni v, c_i=c} (1-X_i) \le 1$ i.e., among literals $\{\neg X_i\}$, at most one is True (keep at most one per color at a vertex).
\end{bullets}
Force $X_i=\text{False}$ for $t_i>T$; binary search minimal feasible $T$.}
\ASSUMPTIONS{Feasibility is monotone in $T$. Sinz encoding uses $O(k)$ clauses and $O(k)$ auxiliaries per bucket of size $k$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute incident lists per vertex and per $(v,c)$.
\item Binary search $T$ over $\{0\}\cup\{t_i\}$.
\item For each $T$, build a 2-SAT with $m$ base variables and auxiliary chain variables:
\begin{bullets}
\item Add sequential at-most-one constraints for $\{X_i: i\ni v\}$ for every vertex $v$.
\item Add sequential at-most-one constraints for $\{\neg X_i: i\ni v,\ c_i=c\}$ for every $(v,c)$.
\item Add unit clauses $\neg X_i$ if $t_i>T$.
\end{bullets}
\item If satisfiable, record assignment and shrink $T$; else increase $T$.
\end{algosteps}
\OPTIMALITY{Among all feasible matchings $S$, the minimal maximum time threshold $T^\star$ is found by binary search due to monotonicity, and any satisfying assignment at $T^\star$ yields an optimal deletion matching.}
\COMPLEXITY{Let $M=m$, $B$ be number of nonempty buckets across vertices and $(v,c)$.}
\[
\begin{aligned}
\text{Per }T:~&O\Bigl(M + \sum_{v} \deg(v) + \sum_{(v,c)} |B_{v,c}|\Bigr)=O(M+B).\\
\text{Total: }&O\bigl((M+B)\log M\bigr)\text{ time},\quad O(M+B)\text{ space.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import defaultdict

class TwoSAT:
    def __init__(self, n):
        self.N = n
        self.g = [[] for _ in range(2*n)]
        self.gr = [[] for _ in range(2*n)]
    def new_var(self):
        self.g.append([]); self.g.append([])
        self.gr.append([]); self.gr.append([])
        self.N += 1
        return self.N - 1
    @staticmethod
    def lit(var, val):  # val=True for positive literal
        return (var << 1) | (1 if val else 0)
    @staticmethod
    def neg(lit): return lit ^ 1
    def add_imp(self, a, b):
        self.g[a].append(b)
        self.gr[b].append(a)
    def add_or(self, a, b):
        # (a ∨ b) as implications (¬a -> b), (¬b -> a)
        self.add_imp(self.neg(a), b)
        self.add_imp(self.neg(b), a)
    def add_unit(self, a):
        # force literal a to True: (a) as (¬a -> a)
        self.add_imp(self.neg(a), a)
    def add_at_most_one(self, lits):
        # Sinz sequential encoding: at most one literal in lits is True.
        k = len(lits)
        if k <= 1: return
        s = []
        for _ in range(k-1):
            s.append(self.new_var())
        # (¬y1 ∨ s1)
        self.add_or(self.neg(lits[0]), self.lit(s[0], True))
        # middle
        for i in range(1, k-1):
            yi = lits[i]
            si = self.lit(s[i], True)
            sim1 = self.lit(s[i-1], True)
            # (¬yi ∨ si)
            self.add_or(self.neg(yi), si)
            # (¬s_{i-1} ∨ si)
            self.add_or(self.neg(sim1), si)
            # (¬yi ∨ ¬s_{i-1})
            self.add_or(self.neg(yi), self.neg(sim1))
        # (¬yk ∨ ¬s_{k-1})
        self.add_or(self.neg(lits[k-1]), self.neg(self.lit(s[k-2], True)))
    def satisfiable(self):
        n = 2*self.N
        used = [False]*n
        order = []
        def dfs(v):
            used[v] = True
            for to in self.g[v]:
                if not used[to]:
                    dfs(to)
            order.append(v)
        for v in range(n):
            if not used[v]:
                dfs(v)
        comp = [-1]*n
        j = 0
        def rdfs(v, j):
            comp[v] = j
            for to in self.gr[v]:
                if comp[to] == -1:
                    rdfs(to, j)
        for v in reversed(order):
            if comp[v] == -1:
                rdfs(v, j); j += 1
        assign = [False]*self.N
        for i in range(self.N):
            if comp[2*i] == comp[2*i+1]:
                return False, []
            assign[i] = comp[2*i] > comp[2*i+1]
        return True, assign

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); m = int(next(it))
    except StopIteration:
        return 0, 0, []
    edges = []
    for i in range(m):
        v = int(next(it)); u = int(next(it)); c = int(next(it)); t = int(next(it))
        edges.append((v-1, u-1, c, t, i+1))
    return n, m, edges

def solve_all(n, m, edges):
    # Precompute buckets
    inc = [[] for _ in range(n)]
    by_vc = defaultdict(list)
    times = {0}
    for i,(v,u,c,t,_) in enumerate(edges):
        inc[v].append(i); inc[u].append(i)
        by_vc[(v,c)].append(i); by_vc[(u,c)].append(i)
        times.add(t)
    times = sorted(times)

    def build_and_solve(T):
        ts = TwoSAT(m)
        # per-vertex: at most one deleted among incident edges
        for v in range(n):
            lits = [TwoSAT.lit(i, True) for i in inc[v]]  # Xi True means deleted
            ts.add_at_most_one(lits)
        # per-(v,c): at most one kept among incident edges of that color
        for key, lst in by_vc.items():
            lits = [TwoSAT.lit(i, False) for i in lst]  # ¬Xi True means kept
            ts.add_at_most_one(lits)
        # force bad edges to be kept
        for i,e in enumerate(edges):
            if e[3] > T:
                ts.add_unit(TwoSAT.lit(i, False))
        ok, assign = ts.satisfiable()
        return ok, assign

    # Check feasibility at max T
    ok_max, _ = build_and_solve(times[-1])
    if not ok_max:
        return "No\n"
    lo, hi = 0, len(times)-1
    bestT = times[-1]; bestAssign = None
    while lo <= hi:
        mid = (lo + hi) // 2
        T = times[mid]
        ok, assign = build_and_solve(T)
        if ok:
            bestT = T
            bestAssign = assign[:m]
            hi = mid - 1
        else:
            lo = mid + 1
    if bestAssign is None:
        # fallback to max
        _, bestAssign = build_and_solve(times[-1])
        bestT = times[-1]
    S = [i+1 for i in range(m) if bestAssign[i]]
    out = []
    out.append("Yes")
    out.append(f"{bestT} {len(S)}")
    out.append(" ".join(map(str, S)))
    return "\n".join(out) + "\n"

def solve_case(data: str) -> str:
    n, m, edges = read_input(data)
    if n == 0 and m == 0:
        return ""
    return solve_all(n, m, edges)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Exactly 3 asserts / mini-tests
        # 1) Already proper coloring -> t=0, k=0
        n=4; m=2
        edges=[(0,1,1,5,1),(2,3,1,6,2)]
        out = solve_all(n,m,edges).strip().splitlines()
        assert out[0]=="Yes"
        t,k = map(int, out[1].split())
        assert t == 0 and k == 0
        # 2) Simple conflict resolvable with one deletion (pick min time)
        n=3; m=2
        edges=[(0,1,7,5,1),(1,2,7,1,2)]
        out = solve_all(n,m,edges).strip().splitlines()
        assert out[0]=="Yes"
        t,k = map(int, out[1].split()); S = list(map(int, out[2].split())) if k>0 else []
        assert t == 1 and k == 1 and S[0] in (1,2)
        # 3) Infeasible: need two deletions at same vertex
        n=5; m=4
        edges=[(0,1,1,1,1),(0,2,1,1,2),(0,3,2,1,3),(0,4,2,1,4)]
        out = solve_all(n,m,edges).strip()
        assert out == "No"
        print("OK")
        return
    print(solve_case(data), end="")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts:
\begin{bullets}
\item Proper coloring already holds $\Rightarrow t=0, k=0$.
\item Simple resolvable conflict chooses the smaller-time deletion.
\item Constructed infeasible case reports ``No''.
\end{bullets}}
\RESULT{If feasible, prints ``Yes'', minimal threshold $t$, count $k$, and any valid matching of $k$ edges achieving $t$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover feasibility, minimality for trivial cases, and impossibility. For larger randomized tests, compare pairwise-2SAT vs. linear-2SAT on small graphs.}
\LINE{CROSS-CHECKS}{On tiny inputs ($m \le 12$), compare brute force (Approach A) against final solver (Approach C) for identical feasibility and $t$.}
\LINE{EDGE-CASE GENERATOR}{Generate stars with multiple colors at center (to trigger infeasibility), disjoint matchings (feasible with $t=0$), and chains to force unique deletion choice.}
\begin{minted}{python}
import sys, random
from collections import defaultdict

def gen_star_multi(n_leaf=3):
    n = n_leaf + 1; m = 2*n_leaf
    edges=[]
    idx=1
    for i in range(1, n_leaf+1):
        edges.append((0, i, 1, 1, idx)); idx+=1
    for i in range(1, n_leaf+1):
        edges.append((0, i, 2, 1, idx)); idx+=1
    return n, m, edges

def run_reference(n, m, edges):
    # Minimal wrapper to call final solver from section 6
    from sys import setrecursionlimit
    setrecursionlimit(1<<25)
    inc = [[] for _ in range(n)]
    by_vc = defaultdict(list)
    times = {0}
    for i,(v,u,c,t,_) in enumerate(edges):
        inc[v].append(i); inc[u].append(i)
        by_vc[(v,c)].append(i); by_vc[(u,c)].append(i)
        times.add(t)
    times = sorted(times)

    class TwoSAT:
        def __init__(self, n):
            self.N = n
            self.g = [[] for _ in range(2*n)]
            self.gr = [[] for _ in range(2*n)]
        def new_var(self):
            self.g.append([]); self.g.append([])
            self.gr.append([]); self.gr.append([])
            self.N += 1
            return self.N - 1
        @staticmethod
        def lit(var, val): return (var<<1)|(1 if val else 0)
        @staticmethod
        def neg(lit): return lit ^ 1
        def add_imp(self, a, b): self.g[a].append(b); self.gr[b].append(a)
        def add_or(self, a, b): self.add_imp(self.neg(a), b); self.add_imp(self.neg(b), a)
        def add_unit(self, a): self.add_imp(self.neg(a), a)
        def add_at_most_one(self, lits):
            k = len(lits)
            if k <= 1: return
            s = [self.new_var() for _ in range(k-1)]
            self.add_or(self.neg(lits[0]), self.lit(s[0], True))
            for i in range(1, k-1):
                yi = lits[i]
                si = self.lit(s[i], True)
                sim1 = self.lit(s[i-1], True)
                self.add_or(self.neg(yi), si)
                self.add_or(self.neg(sim1), si)
                self.add_or(self.neg(yi), self.neg(sim1))
            self.add_or(self.neg(lits[k-1]), self.neg(self.lit(s[k-2], True)))
        def satisfiable(self):
            n2 = 2*self.N
            used = [False]*n2
            order=[]
            def dfs(v):
                used[v]=True
                for to in self.g[v]:
                    if not used[to]: dfs(to)
                order.append(v)
            for v in range(n2):
                if not used[v]: dfs(v)
            comp=[-1]*n2; j=0
            def rdfs(v, j):
                comp[v]=j
                for to in self.gr[v]:
                    if comp[to]==-1: rdfs(to,j)
            for v in reversed(order):
                if comp[v]==-1: rdfs(v,j); j+=1
            assign=[False]*self.N
            for i in range(self.N):
                if comp[2*i]==comp[2*i+1]: return False,[]
                assign[i]=comp[2*i]>comp[2*i+1]
            return True, assign

    def build_and_solve(T):
        ts = TwoSAT(m)
        for v in range(n):
            ts.add_at_most_one([TwoSAT.lit(i, True) for i in inc[v]])
        for key,lst in by_vc.items():
            ts.add_at_most_one([TwoSAT.lit(i, False) for i in lst])
        for i,e in enumerate(edges):
            if e[3] > T:
                ts.add_unit(TwoSAT.lit(i, False))
        return ts.satisfiable()

    ok,_ = build_and_solve(times[-1])
    if not ok: return "No\n"
    lo,hi=0,len(times)-1; bestT=times[-1]; bestAssign=None
    while lo<=hi:
        mid=(lo+hi)//2
        ok,assign=build_and_solve(times[mid])
        if ok:
            bestT=times[mid]; bestAssign=assign[:m]; hi=mid-1
        else:
            lo=mid+1
    if bestAssign is None:
        _,bestAssign=build_and_solve(times[-1]); bestT=times[-1]
    S=[i+1 for i in range(m) if bestAssign[i]]
    return f"Yes\n{bestT} {len(S)}\n" + (" ".join(map(str,S))+"\n" if S else "\n")

def main():
    # Deterministic generators for boundaries
    n,m,edges = gen_star_multi(3)
    out = run_reference(n,m,edges)
    assert out.strip()=="No"
    # Trivial OK
    n=4; m=2
    edges=[(0,1,1,5,1),(2,3,1,6,2)]
    out = run_reference(n,m,edges)
    assert out.splitlines()[1].startswith("0 ")
    print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import defaultdict

class TwoSAT:
    def __init__(self, n):
        self.N = n
        self.g = [[] for _ in range(2*n)]
        self.gr = [[] for _ in range(2*n)]
    def new_var(self):
        self.g.append([]); self.g.append([])
        self.gr.append([]); self.gr.append([])
        self.N += 1
        return self.N - 1
    @staticmethod
    def lit(var, val):
        return (var << 1) | (1 if val else 0)
    @staticmethod
    def neg(lit): return lit ^ 1
    def add_imp(self, a, b):
        self.g[a].append(b)
        self.gr[b].append(a)
    def add_or(self, a, b):
        self.add_imp(self.neg(a), b)
        self.add_imp(self.neg(b), a)
    def add_unit(self, a):
        self.add_imp(self.neg(a), a)
    def add_at_most_one(self, lits):
        k = len(lits)
        if k <= 1: return
        s = [self.new_var() for _ in range(k-1)]
        self.add_or(self.neg(lits[0]), self.lit(s[0], True))
        for i in range(1, k-1):
            yi = lits[i]
            si = self.lit(s[i], True)
            sim1 = self.lit(s[i-1], True)
            self.add_or(self.neg(yi), si)
            self.add_or(self.neg(sim1), si)
            self.add_or(self.neg(yi), self.neg(sim1))
        self.add_or(self.neg(lits[k-1]), self.neg(self.lit(s[k-2], True)))
    def satisfiable(self):
        n = 2*self.N
        used = [False]*n
        order=[]
        def dfs(v):
            used[v]=True
            for to in self.g[v]:
                if not used[to]: dfs(to)
            order.append(v)
        for v in range(n):
            if not used[v]: dfs(v)
        comp=[-1]*n; j=0
        def rdfs(v, j):
            comp[v]=j
            for to in self.gr[v]:
                if comp[to]==-1: rdfs(to, j)
        for v in reversed(order):
            if comp[v]==-1:
                rdfs(v, j); j+=1
        assign=[False]*self.N
        for i in range(self.N):
            if comp[2*i]==comp[2*i+1]:
                return False, []
            assign[i] = comp[2*i] > comp[2*i+1]
        return True, assign

def read_input():
    data = sys.stdin.buffer.read().split()
    if not data:
        return 0,0,[]
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    edges=[]
    for i in range(m):
        v = int(next(it)); u = int(next(it)); c = int(next(it)); t = int(next(it))
        edges.append((v-1,u-1,c,t,i+1))
    return n, m, edges

def solve_all(n, m, edges):
    inc = [[] for _ in range(n)]
    by_vc = defaultdict(list)
    times = {0}
    for i,(v,u,c,t,_) in enumerate(edges):
        inc[v].append(i); inc[u].append(i)
        by_vc[(v,c)].append(i); by_vc[(u,c)].append(i)
        times.add(t)
    times = sorted(times)
    def build(T):
        ts = TwoSAT(m)
        for v in range(n):
            ts.add_at_most_one([TwoSAT.lit(i, True) for i in inc[v]])
        for key,lst in by_vc.items():
            ts.add_at_most_one([TwoSAT.lit(i, False) for i in lst])
        for i,e in enumerate(edges):
            if e[3] > T:
                ts.add_unit(TwoSAT.lit(i, False))
        return ts
    # Feasibility at max T
    ts = build(times[-1])
    ok, _ = ts.satisfiable()
    if not ok:
        return "No\n"
    lo, hi = 0, len(times)-1
    bestT = times[-1]; bestAssign = None
    while lo <= hi:
        mid = (lo+hi)//2
        ts = build(times[mid])
        ok, assign = ts.satisfiable()
        if ok:
            bestT = times[mid]
            bestAssign = assign[:m]
            hi = mid - 1
        else:
            lo = mid + 1
    if bestAssign is None:
        ts = build(times[-1])
        _, bestAssign = ts.satisfiable()
        bestT = times[-1]
    S = [i+1 for i in range(m) if bestAssign[i]]
    out = []
    out.append("Yes")
    out.append(f"{bestT} {len(S)}")
    out.append(" ".join(map(str, S)))
    return "\n".join(out) + "\n"

def main():
    data = sys.stdin.buffer.read()
    if not data.strip():
        # Self-checks
        # 1) Proper already -> t=0, k=0
        n=4; m=2
        edges=[(0,1,1,5,1),(2,3,1,6,2)]
        out = solve_all(n,m,edges).strip().splitlines()
        assert out[0]=="Yes"
        t,k = map(int, out[1].split())
        assert t==0 and k==0
        # 2) Simple resolvable conflict
        n=3; m=2
        edges=[(0,1,7,5,1),(1,2,7,1,2)]
        out = solve_all(n,m,edges).strip().splitlines()
        assert out[0]=="Yes"
        t,k = map(int, out[1].split())
        assert t==1 and k==1
        # 3) Infeasible
        n=5; m=4
        edges=[(0,1,1,1,1),(0,2,1,1,2),(0,3,2,1,3),(0,4,2,1,4)]
        out = solve_all(n,m,edges).strip()
        assert out=="No"
        print("OK")
        return
    else:
        # Reuse buffer
        sys.stdin = sys.__stdin__
        sys.stdin = open(0, "rb", buffering=0)
        # We already consumed; rebuild from data
        parts = data.split()
        if not parts:
            print("", end=""); return
        it = iter(parts)
        n = int(next(it)); m = int(next(it))
        edges=[]
        for i in range(m):
            v = int(next(it)); u = int(next(it)); c = int(next(it)); t = int(next(it))
            edges.append((v-1,u-1,c,t,i+1))
        print(solve_all(n,m,edges), end="")

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Binary search the minimal threshold $T$ and decide feasibility via 2-SAT encoding of two at-most-one families.}
\WHY{This blends matching-like constraints with per-color restrictions and is a classic 2-SAT modeling challenge appearing in hard CF rounds.}
\CHECKLIST{
\begin{bullets}
\item Build incident lists per vertex and per $(v,c)$.
\item Encode at-most-one deletions per vertex via sequential 2-SAT.
\item Encode at-most-one kept per $(v,c)$ via sequential 2-SAT on $\{\neg X_i\}$.
\item Force $\neg X_i$ for edges with $t_i>T$.
\item Binary search on $T \in \{0\}\cup\{t_i\}$; retrieve assignment and edges with $X_i=\text{True}$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $m=0$: print Yes, $t=0$, $k=0$.
\item Already proper coloring: empty deletion set, $t=0$.
\item Two or more bad edges (time $>T$) in the same $(v,c)$ bucket $\Rightarrow$ UNSAT at that $T$.
\item A vertex requiring two deletions across different colors $\Rightarrow$ infeasible.
\item Multiple edges between same pair with same color.
\item Large single bucket sizes; ensure linear encoding avoids $O(s^2)$ blow-up.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using pairwise constraints leads to quadratic clauses and TLE.
\item Forgetting to include $T=0$ in candidates misses optimal $t=0$ cases.
\item Mishandling literal polarity for $(v,c)$ buckets (use $\neg X_i$).
\item Off-by-one in edge indices (output is 1-based).
\item Not resetting 2-SAT graph per $T$ in binary search.
\item SCC assignment sign: use component order correctly to set variable values.
\end{bullets}}
\FAILMODES{Graphs forcing multiple deletions at a single vertex defeat the matching constraint; our 2-SAT catches this by at-most-one deletion per vertex. Two large same-color stars at one vertex force unsatisfiability quickly.}
\ELI{We decide which edges to delete (but never two touching) so that what remains has at most one incident edge per color at every vertex. By capping the allowed deletion time and checking if some choice exists, we can shrink the cap using binary search until it is minimal.}
\NotePages{3}

\end{document}