% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Implement Trie (Prefix Tree)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/implement-trie-prefix-tree/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{A trie (pronounced as ``try'') or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. See \url{https://en.wikipedia.org/wiki/Trie} for background.

Implement the \texttt{Trie} class:
\begin{bullets}
\item \texttt{Trie()} Initializes the trie object.
\item \texttt{void insert(String word)} Inserts the string \texttt{word} into the trie.
\item \texttt{boolean search(String word)} Returns \texttt{true} if the string \texttt{word} is in the trie (i.e., was inserted before), and \texttt{false} otherwise.
\item \texttt{boolean startsWith(String prefix)} Returns \texttt{true} if there is a previously inserted string \texttt{word} that has the prefix \texttt{prefix}, and \texttt{false} otherwise.
\end{bullets}

Example 1:

Input
\[
\begin{aligned}
\text{ops} &= [\text{"Trie"}, \text{"insert"}, \text{"search"}, \text{"search"}, \text{"startsWith"}, \text{"insert"}, \text{"search"}] \\
\text{args} &= [[], [\text{"apple"}], [\text{"apple"}], [\text{"app"}], [\text{"app"}], [\text{"app"}], [\text{"app"}]]
\end{aligned}
\]
Output
\begin{BreakableEquation*}
[\text{null}, \text{null}, \text{true}, \text{false}, \text{true}, \text{null}, \text{true}]
\end{BreakableEquation*}

Explanation

\texttt{Trie trie = new Trie();}\\
\texttt{trie.insert("apple");}\\
\texttt{trie.search("apple");}   \texttt{// return True}\\
\texttt{trie.search("app");}     \texttt{// return False}\\
\texttt{trie.startsWith("app");} \texttt{// return True}\\
\texttt{trie.insert("app");}\\
\texttt{trie.search("app");}     \texttt{// return True}

Constraints:
\begin{bullets}
\item $1 \le \texttt{word.length}, \texttt{prefix.length} \le 2000$.
\item \texttt{word} and \texttt{prefix} consist only of lowercase English letters.
\item At most $3 \times 10^4$ calls in total will be made to \texttt{insert}, \texttt{search}, and \texttt{startsWith}.
\end{bullets}
}
\BREAKDOWN{Design a data structure that supports insert, exact search, and prefix search over lowercase words. Maintain per-node children and an end-of-word marker.}
\ELI{Walk down a character tree creating nodes as needed; mark the end of inserted words; a prefix exists if you can walk the tree along its characters.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode drives tests as a sequence of operations:
\begin{bullets}
\item \texttt{ops}: an array of strings with method names, starting with \texttt{"Trie"}.
\item \texttt{args}: an array of argument arrays aligned with \texttt{ops}.
\item Each \texttt{word} or \texttt{prefix} is a nonempty string over \{a,\ldots,z\} with length in $[1,2000]$.
\end{bullets}
Internally, the class to implement is \texttt{Trie} with methods \texttt{insert}, \texttt{search}, \texttt{startsWith}.}
\OUTPUTS{For each operation:
\begin{bullets}
\item \texttt{"Trie"} returns \texttt{null}.
\item \texttt{"insert"} returns \texttt{null}.
\item \texttt{"search"} returns a boolean indicating exact membership.
\item \texttt{"startsWith"} returns a boolean indicating whether any inserted word has the given prefix.
\end{bullets}}
\SAMPLES{Example:
\[
\begin{aligned}
\text{ops} &= [\text{"Trie"}, \text{"insert"}, \text{"search"}, \text{"search"}, \text{"startsWith"}, \text{"insert"}, \text{"search"}]\\
\text{args} &= [[],[\text{"apple"}],[\text{"apple"}],[\text{"app"}],[\text{"app"}],[\text{"app"}],[\text{"app"}]]
\end{aligned}
\]
Output: \([\text{null}, \text{null}, \text{true}, \text{false}, \text{true}, \text{null}, \text{true}]\).

Tiny:
\begin{BreakableEquation*}
\text{ops}=[\text{"Trie"},\text{"search"}],\;\text{args}=[[],[\text{"a"}]]\Rightarrow[\text{null},\text{false}].
\end{BreakableEquation*}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Maintain a rooted directed tree where edges are labeled by letters in $\Sigma=\{a,\ldots,z\}$. The set of inserted words $S\subseteq \Sigma^{\ast}$ is represented by marking certain nodes as terminal. For a string $x\in\Sigma^{\ast}$, let $\delta(\text{root}, x)$ be the node reached by following $x$; if at any step there is no outgoing edge matching the next letter, $\delta$ is undefined.}
\varmapStart
\var{\Sigma}{alphabet of lowercase letters}
\var{S}{set of inserted words}
\var{V}{set of trie nodes}
\var{E}{set of directed edges labeled in $\Sigma$}
\var{\mathrm{term}(v)}{predicate: node $v$ is terminal (end of a word)}
\var{\delta(v, c)}{child of $v$ via character $c$ if it exists}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Insert}(w=c_1\cdots c_k): &&\forall i\in[1,k]:\;\; \delta(v_{i-1}, c_i)\text{ exists or create it as }v_i; \;\mathrm{term}(v_k)\leftarrow \text{true}.\\
&\text{Search}(w): &&\text{return } \big(\delta(\text{root}, w)\text{ exists}\big)\land \mathrm{term}\big(\delta(\text{root}, w)\big).\\
&\text{StartsWith}(p): &&\text{return } \big(\delta(\text{root}, p)\text{ exists}\big).
\end{aligned}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item Only lowercase letters. No deletions are required.
\item Multiple inserts of the same word are idempotent; terminal flags remain true.
\item Paths are unique by edge labels; each node has at most one child per letter.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item Path-uniqueness: From any node, there is at most one outgoing edge per $c\in\Sigma$.
\item Prefix-closure of nodes: For any $w\in S$ and any prefix $p$ of $w$, the node $\delta(\text{root}, p)$ exists.
\item Correctness of membership: $w\in S \iff \delta(\text{root}, w)$ exists and is terminal.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Represent each node as a hash map from character to child node, plus a boolean end marker. This directly encodes $\delta$ and $\mathrm{term}(\cdot)$.}
\ASSUMPTIONS{Python dictionaries provide average $O(1)$ child lookup and insertion; inputs are limited to lowercase ASCII letters.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Use a nested-dictionary node: \texttt{node = \{\}}; reserve a special key (e.g., \texttt{"\#"}) for terminal flag.
\item For \texttt{insert}, iterate characters, creating child dicts if missing; set terminal flag at the last node.
\item For \texttt{search} and \texttt{startsWith}, walk down; check terminal only for \texttt{search}.
\end{algosteps}
\COMPLEXITY{Let $L$ be the length of the argument string.
\[
\begin{aligned}
T(L) &= O(L)\ \text{for each of insert/search/startsWith} \\
S(\text{total}) &= O\Big(\sum_{w\in S} |w|\Big)\ \text{nodes in the worst case (shared prefixes deduplicated)}
\end{aligned}
\]
}
\CORRECTNESS{By construction, each character advances exactly along the corresponding labeled edge, creating it if absent during insert. Terminal flags encode exact-word membership; hence search returns true iff a terminal node is reached. Prefix check only requires reachability.}
\EDGECASES{
\begin{bullets}
\item Re-inserting the same word: remains terminal.
\item Searching a strict prefix of an inserted word: returns false unless inserted as a word.
\item Empty prefix is not provided by constraints; if it were, \texttt{startsWith("")} would be true after initialization.
\end{bullets}}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline: dict-of-dicts trie with '#' as terminal marker.
from typing import List, Optional

class Trie:
    __slots__ = ("root",)
    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        node = self.root
        for ch in word:
            nxt = node.get(ch)
            if nxt is None:
                nxt = {}
                node[ch] = nxt
            node = nxt
        node["#"] = True

    def search(self, word: str) -> bool:
        node = self.root
        for ch in word:
            node = node.get(ch)
            if node is None:
                return False
        return bool(node.get("#", False))

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for ch in prefix:
            node = node.get(ch)
            if node is None:
                return False
        return True

# Optional LeetCode harness helper for local testing
class Solution:
    def run(self, ops: List[str], args: List[List[str]]) -> List[Optional[bool]]:
        out: List[Optional[bool]] = []
        trie: Optional[Trie] = None
        for op, a in zip(ops, args):
            if op == "Trie":
                trie = Trie()
                out.append(None)
            elif op == "insert":
                assert trie is not None
                trie.insert(a[0])
                out.append(None)
            elif op == "search":
                assert trie is not None
                out.append(trie.search(a[0]))
            elif op == "startsWith":
                assert trie is not None
                out.append(trie.startsWith(a[0]))
            else:
                raise ValueError(op)
        return out

def _self_test():
    t = Trie()
    t.insert("apple")
    assert t.search("apple") is True
    assert t.search("app") is False
    assert t.startsWith("app") is True
    t.insert("app")
    assert t.search("app") is True
    # Disjoint branch
    t.insert("bat")
    assert t.startsWith("ba") is True and t.search("ba") is False
    # Solution harness check
    sol = Solution()
    ops = ["Trie","insert","search","search","startsWith","insert","search"]
    args = [[],["apple"],["apple"],["app"],["app"],["app"],["app"]]
    assert sol.run(ops, args) == [None,None,True,False,True,None,True]

if __name__ == "__main__":
    _self_test()
\end{minted}
\VALIDATION{Checked against the provided sample, plus:
\begin{bullets}
\item Shared-prefix behavior: insert \texttt{apple}, search \texttt{app} false, then insert \texttt{app} and search true.
\item Disjoint words: \texttt{bat} does not affect \texttt{apple} paths.
\end{bullets}}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Array Children}
\WHICHFORMULA{Use a compact \texttt{TrieNode} with a fixed-size children array of length 26 and a boolean \texttt{end} flag. This avoids hash overhead and can be faster and more memory-predictable.}
\ASSUMPTIONS{Alphabet is exactly 26 lowercase letters; compute child index as \texttt{ord(c) - ord('a')}.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define \texttt{TrieNode} storing \texttt{children: list[Optional[int]]} indices into a node pool and \texttt{end: bool}.
\item Maintain a list-based node pool; node 0 is the root.
\item For each operation, walk indices; create nodes on demand; toggle \texttt{end} for insert; check reachability for prefix.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline but improved constants by eliminating per-character hash lookups:
\[
\begin{aligned}
T(L) &= O(L)\ \text{with array index operations}\\
S(\text{total}) &= O(\text{number of nodes}) = O\Big(\sum_{w\in S}|w|\Big)
\end{aligned}
\]
}
\CORRECTNESS{Uniqueness of per-letter child pointers enforces a proper trie; marking \texttt{end} realizes exact-word membership. Exchange of hash maps for fixed arrays preserves semantics.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved: array-children trie using a node pool.
from typing import List, Optional

class Trie:
    __slots__ = ("ch", "end")
    def __init__(self):
        # Node pool: each node has children (list of 26 ints) and end flag
        self.ch: List[List[int]] = [[-1]*26]  # children indices; -1 denotes absent
        self.end: List[bool] = [False]

    def _idx(self, c: str) -> int:
        return ord(c) - 97  # 'a' -> 0

    def insert(self, word: str) -> None:
        u = 0
        for c in word:
            i = self._idx(c)
            v = self.ch[u][i]
            if v == -1:
                v = len(self.ch)
                self.ch[u][i] = v
                self.ch.append([-1]*26)
                self.end.append(False)
            u = v
        self.end[u] = True

    def search(self, word: str) -> bool:
        u = 0
        for c in word:
            i = self._idx(c)
            u = self.ch[u][i]
            if u == -1:
                return False
        return self.end[u]

    def startsWith(self, prefix: str) -> bool:
        u = 0
        for c in prefix:
            i = self._idx(c)
            u = self.ch[u][i]
            if u == -1:
                return False
        return True

class Solution:
    def run(self, ops: List[str], args: List[List[str]]):
        out: List[Optional[bool]] = []
        trie: Optional[Trie] = None
        for op, a in zip(ops, args):
            if op == "Trie":
                trie = Trie(); out.append(None)
            elif op == "insert":
                assert trie is not None; trie.insert(a[0]); out.append(None)
            elif op == "search":
                assert trie is not None; out.append(trie.search(a[0]))
            elif op == "startsWith":
                assert trie is not None; out.append(trie.startsWith(a[0]))
            else:
                raise ValueError(op)
        return out

def _self_test():
    t = Trie()
    for w in ["a", "ab", "abc"]:
        t.insert(w)
    assert t.search("abc") and t.search("a") and not t.search("abcd")
    assert t.startsWith("ab") and not t.startsWith("b")
    sol = Solution()
    ops = ["Trie","insert","search","startsWith"]
    args = [[],["leetcode"],["leetcode"],["leet"]]
    assert sol.run(ops, args) == [None, None, True, True]

if __name__ == "__main__":
    _self_test()
\end{minted}
\VALIDATION{Edge checks:
\begin{bullets}
\item Deep path: insert chain \texttt{a}, \texttt{ab}, \texttt{abc}, then search and prefixes.
\item Negative prefix: \texttt{startsWith("b")} after inserting only \texttt{"a"}-prefixed words.
\end{bullets}}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{For a fixed small alphabet and no deletions, the array-children trie achieves optimal $O(L)$ per operation with minimal overhead and simple implementation. We keep the node pool representation and ensure tight loops.}
\ASSUMPTIONS{Alphabet is lowercase English letters; Python implementation aims for low constant factors and determinism.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a contiguous pool of nodes; each node has 26 child indices and one boolean.
\item Map characters to indices via \texttt{ord(c) - 97}; avoid dicts and objects on the hot path.
\item On insert, create nodes lazily; on search/prefix, early-exit on missing link.
\end{algosteps}
\OPTIMALITY{Any comparison-based approach must inspect each character of the query in the worst case, giving a lower bound $\Omega(L)$. The trie walks exactly one step per character, hence $O(L)$ is tight. Space is proportional to the number of distinct prefixes, which is information-theoretically necessary to distinguish inserted strings.}
\COMPLEXITY{
\[
\begin{aligned}
T(L) &= \Theta(L)\ \text{for insert/search/startsWith}\\
S(\text{total}) &= \Theta(P)\ \text{nodes, where }P\text{ is the number of distinct prefixes inserted}
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final: optimized array-trie with tight loops and assertions.
from typing import List, Optional

class Trie:
    __slots__ = ("ch", "end")
    def __init__(self):
        self.ch: List[List[int]] = [[-1]*26]
        self.end: List[bool] = [False]

    @staticmethod
    def _idx(c: str) -> int:
        return ord(c) - 97

    def insert(self, word: str) -> None:
        u = 0
        for c in word:
            i = ord(c) - 97
            v = self.ch[u][i]
            if v == -1:
                v = len(self.ch)
                self.ch[u][i] = v
                self.ch.append([-1]*26)
                self.end.append(False)
            u = v
        self.end[u] = True

    def search(self, word: str) -> bool:
        u = 0
        for c in word:
            u = self.ch[u][ord(c) - 97]
            if u == -1:
                return False
        return self.end[u]

    def startsWith(self, prefix: str) -> bool:
        u = 0
        for c in prefix:
            u = self.ch[u][ord(c) - 97]
            if u == -1:
                return False
        return True

class Solution:
    # Helper harness for local deterministic testing; LeetCode instantiates Trie directly.
    def run(self, ops: List[str], args: List[List[str]]) -> List[Optional[bool]]:
        out: List[Optional[bool]] = []
        trie: Optional[Trie] = None
        for op, a in zip(ops, args):
            if op == "Trie":
                trie = Trie(); out.append(None)
            elif op == "insert":
                assert trie is not None; trie.insert(a[0]); out.append(None)
            elif op == "search":
                assert trie is not None; out.append(trie.search(a[0]))
            elif op == "startsWith":
                assert trie is not None; out.append(trie.startsWith(a[0]))
            else:
                raise ValueError(op)
        return out

def _tests():
    # 1) Provided example
    ops = ["Trie","insert","search","search","startsWith","insert","search"]
    args = [[],["apple"],["apple"],["app"],["app"],["app"],["app"]]
    expect = [None,None,True,False,True,None,True]
    assert Solution().run(ops, args) == expect
    # 2) Negative cases and shared prefixes
    t = Trie()
    assert not t.search("a")
    t.insert("a"); t.insert("ab")
    assert t.startsWith("a") and t.search("a") and not t.search("abc")
    # 3) Long word and prefix boundary
    longw = "z"*2000
    t.insert(longw)
    assert t.search(longw)
    assert t.startsWith("z"*1999)

if __name__ == "__main__":
    _tests()
\end{minted}
\VALIDATION{Exactly three assertions executed in the final code path:
\begin{bullets}
\item End-to-end sample matches expected output.
\item Shared-prefix membership: insert \texttt{"a"}, \texttt{"ab"}; search and prefix behave as specified.
\item Maximum-length word of length $2000$ is handled correctly for both search and prefix.
\end{bullets}}
\RESULT{Implements a trie over lowercase letters with operations \texttt{insert}, \texttt{search}, and \texttt{startsWith}, each running in $\Theta(L)$ for input length $L$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover empty-before-insert lookups, shared prefixes, negative prefixes, and maximum-length inputs; property: after inserting $w$, both \texttt{startsWith} on any prefix of $w$ is true and \texttt{search} on $w$ is true.}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved vs Final by running identical operation sequences and asserting identical outputs on random small corpora.}
\LINE{EDGE-CASE GENERATOR}{Generate random strings over \{a,\ldots,z\}, include extremes: length 1 and 2000, repeated inserts, and searches for non-inserted words sharing long prefixes.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_words(n: int, seed: int = 0) -> List[str]:
    random.seed(seed)
    out: List[str] = []
    for i in range(n):
        L = random.choice([1,2,3,10,100,2000])
        out.append("".join(random.choice("abcxyz") for _ in range(L)))
    return out

def cross_check():
    from copy import deepcopy
    # Baseline trie
    class TrieA:
        def __init__(self): self.root = {}
        def insert(self, w: str):
            node = self.root
            for ch in w:
                if ch not in node: node[ch] = {}
                node = node[ch]
            node["#"] = True
        def search(self, w: str) -> bool:
            node = self.root
            for ch in w:
                if ch not in node: return False
                node = node[ch]
            return node.get("#", False)
        def startsWith(self, p: str) -> bool:
            node = self.root
            for ch in p:
                if ch not in node: return False
                node = node[ch]
            return True
    # Final trie (copied)
    class TrieC:
        def __init__(self):
            self.ch = [[-1]*26]; self.end = [False]
        def insert(self, w: str):
            u = 0
            for c in w:
                i = ord(c)-97; v = self.ch[u][i]
                if v == -1:
                    v = len(self.ch); self.ch[u][i] = v
                    self.ch.append([-1]*26); self.end.append(False)
                u = v
            self.end[u] = True
        def search(self, w: str) -> bool:
            u = 0
            for c in w:
                u = self.ch[u][ord(c)-97]
                if u == -1: return False
            return self.end[u]
        def startsWith(self, p: str) -> bool:
            u = 0
            for c in p:
                u = self.ch[u][ord(c)-97]
                if u == -1: return False
            return True
    A, C = TrieA(), TrieC()
    words = gen_words(50, seed=1)
    # Insert half
    for w in words[:25]: A.insert(w); C.insert(w)
    # Check searches and prefixes
    for w in words:
        assert A.search(w) == C.search(w)
        # test a few prefixes
        for k in [1, min(3, len(w)), len(w)]:
            p = w[:k]
            assert A.startsWith(p) == C.startsWith(p)

if __name__ == "__main__":
    cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference implementation for LeetCode: Implement Trie (Prefix Tree)
from typing import List, Optional

class Trie:
    __slots__ = ("ch", "end")
    def __init__(self):
        # children: list of 26-int arrays; end: terminal flags
        self.ch: List[List[int]] = [[-1]*26]
        self.end: List[bool] = [False]

    def insert(self, word: str) -> None:
        u = 0
        for c in word:
            i = ord(c) - 97
            v = self.ch[u][i]
            if v == -1:
                v = len(self.ch)
                self.ch[u][i] = v
                self.ch.append([-1]*26)
                self.end.append(False)
            u = v
        self.end[u] = True

    def search(self, word: str) -> bool:
        u = 0
        for c in word:
            u = self.ch[u][ord(c) - 97]
            if u == -1:
                return False
        return self.end[u]

    def startsWith(self, prefix: str) -> bool:
        u = 0
        for c in prefix:
            u = self.ch[u][ord(c) - 97]
            if u == -1:
                return False
        return True

# Optional helper class for local runs; LC instantiates Trie directly.
class Solution:
    def run(self, ops: List[str], args: List[List[str]]) -> List[Optional[bool]]:
        out: List[Optional[bool]] = []
        trie: Optional[Trie] = None
        for op, a in zip(ops, args):
            if op == "Trie":
                trie = Trie(); out.append(None)
            elif op == "insert":
                assert trie is not None; trie.insert(a[0]); out.append(None)
            elif op == "search":
                assert trie is not None; out.append(trie.search(a[0]))
            elif op == "startsWith":
                assert trie is not None; out.append(trie.startsWith(a[0]))
            else:
                raise ValueError(op)
        return out

def _ref_tests():
    ops = ["Trie","insert","search","search","startsWith","insert","search"]
    args = [[],["apple"],["apple"],["app"],["app"],["app"],["app"]]
    expect = [None,None,True,False,True,None,True]
    assert Solution().run(ops, args) == expect
    t = Trie()
    assert not t.search("z")
    t.insert("z"*2000)
    assert t.search("z"*2000)
    assert t.startsWith("z"*1999)

if __name__ == "__main__":
    _ref_tests()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Build a prefix tree over lowercase letters to support insert, exact search, and prefix search in linear time in the string length.}
\WHY{Core data-structure design; shows comfort with tries, memory models, and API correctness—common in systems for autocomplete, dictionaries, and string indexing.}
\CHECKLIST{
\begin{bullets}
\item Chosen node representation (dict vs array) and why.
\item End-of-word marking for exact searches.
\item Iterate characters; early exit on missing edges.
\item Validate constraints and character set.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item Re-inserting an existing word must not break anything.
\item Searching a strict prefix should be false unless the prefix was inserted.
\item Prefix existence for very long strings (length $2000$).
\item Words that share entire path except last character.
\item No uppercase or non-ASCII letters appear by constraints.
\item Empty strings are not present by constraints; define behavior if asked.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to set/consult the terminal flag on \texttt{search}.
\item Using recursion for long strings, risking recursion limits.
\item Mixing up \texttt{search} and \texttt{startsWith} semantics.
\item In array-trie, off-by-one in \texttt{ord(c) - ord('a')}.
\item Accidentally sharing child arrays between nodes (shallow copies).
\item Using mutable default arguments for children structures.
\end{bullets}}
\FAILMODES{Baseline dict approach can be slightly slower due to hashing overhead; both approaches, however, maintain $O(L)$ time and are robust on adversarial sequences since no rehashing affects asymptotics significantly in Python.}
\ELI{Make a tree where each step follows a letter. To add a word, create steps if missing and mark the last node. To find a word, walk the steps and see if the last node is marked; to check a prefix, just see if you can walk all its letters.}
\NotePages{3}

\end{document}