% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Ring Road 2}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/27/D}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{It is well known that Berland has $n$ cities, which form the Silver ring — cities $i$ and $i+1$ ($1 \le i < n$) are connected by a road, as well as the cities $n$ and $1$. The goverment have decided to build $m$ new roads. The list of the roads to build was prepared. Each road will connect two cities. Each road should be a curve which lies inside or outside the ring. New roads will have no common points with the ring (except the endpoints of the road).

Now the designers of the constructing plan wonder if it is possible to build the roads in such a way that no two roads intersect (note that the roads may intersect at their endpoints). If it is possible to do, which roads should be inside the ring, and which should be outside?

Input: The first line contains two integers $n$ and $m$ ($4 \le n \le 100$, $1 \le m \le 100$). Each of the following $m$ lines contains two integers $a_i$ and $b_i$ ($1 \le a_i, b_i \le n$, $a_i \ne b_i$). No two cities will be connected by more than one road in the list. The list will not contain the roads which exist in the Silver ring.

Output: If it is impossible to build the roads in such a way that no two roads intersect, output \texttt{Impossible}. Otherwise print $m$ characters. $i$-th character should be \texttt{i}, if the road should be inside the ring, and \texttt{o} if the road should be outside the ring. If there are several solutions, output any of them.}
\BREAKDOWN{Reduce intersections to a purely combinatorial condition on chords of a circle: two roads cross on the same side iff their endpoints strictly interleave around the cycle and they do not share endpoints. Build the intersection graph of roads and check if it is bipartite; a valid 2-coloring yields inside/outside.}
\ELI{Think of each road as a chord on a circle; if some pair of chords cross, they must be put on different sides. We just need to 2-color the ``crossing'' pairs.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integers $n$ and $m$ with $4 \le n \le 100$, $1 \le m \le 100$.
- Then $m$ lines, each with two integers $a_i, b_i$ ($1 \le a_i, b_i \le n$, $a_i \ne b_i$), no duplicates, and not equal to any ring edge $\{k,k+1\}$ or $\{n,1\}$.}
\OUTPUTS{If impossible, print the single word \texttt{Impossible}. Otherwise, print a string of length $m$ over alphabet $\{\texttt{i},\texttt{o}\}$: the $i$-th character corresponds to the $i$-th given road, with \texttt{i} meaning draw inside, \texttt{o} outside.}
\SAMPLES{Example 1:
- Input:
  4 2
  1 3
  2 4
- Output (one valid):
  io

Example 2:
- Input:
  6 3
  1 4
  2 5
  3 6
- Output:
  Impossible}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the cities be placed on a circle in the order $1,2,\ldots,n$. Each candidate road $e_k=\{u_k,v_k\}$ is a chord connecting two distinct vertices. Two chords $e_p,e_q$ \emph{cross} iff they have four distinct endpoints and their endpoints strictly interleave in the circular order. We form the \emph{intersection graph} $G$ with one vertex per chord and edges between crossing pairs. The task is to determine whether $G$ is bipartite and if so, output a 2-coloring.}
\varmapStart
\var{n}{number of cities on the ring}
\var{m}{number of candidate roads}
\var{e_k=\{u_k,v_k\}}{the $k$-th road endpoints}
\var{G=(V,E)}{intersection graph on roads}
\var{c:V\to\{0,1\}}{2-coloring; map to inside/outside}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
(e_p \text{ crosses } e_q) &\iff \text{$u_p,v_p,u_q,v_q$ are all distinct and exactly one of $u_q,v_q$ lies on the arc from $u_p$ to $v_p$ in circular order}, \\
G &= (V=\{1,\ldots,m\},~E=\{\{p,q\}\mid e_p \text{ crosses } e_q\}), \\
\text{feasible} &\iff G \text{ is bipartite.}
\end{aligned}
\]
}
\ASSUMPTIONS{Vertices are labeled $1$ through $n$ in circular order. Roads that share endpoints may touch at endpoints and are not considered crossings.}
\INVARIANTS{%
- Within one side (inside or outside), no two chords with interleaving endpoints can be assigned the same side.
- Crossing relation is symmetric and irreflexive on distinct roads not sharing endpoints.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct search over assignments of roads to inside/outside with pruning by checking pairwise crossings within each side.}
\ASSUMPTIONS{Backtracking will terminate quickly only for small $m$; acceptable for sanity checks and tiny cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute a crossing predicate between any two roads.
\item Recursively assign each road to side \texttt{i} or \texttt{o}; prune whenever a newly assigned road crosses a previously assigned road on the same side.
\item If all roads are assigned, output the assignment; if no assignment survives, report \texttt{Impossible}.
\end{algosteps}
\COMPLEXITY{Worst case exponential in $m$; with pruning, still $O(2^m)$ in the worst case. Space is $O(m)$ for recursion and $O(m^2)$ for precomputed crossings.}
\[
\begin{aligned}
T(m) &\le 2\,T(m-1) + O(m) \\
     &= O(2^m).
\end{aligned}
\]
\CORRECTNESS{By construction, the search only emits assignments that never place a crossing pair on the same side. Exhaustiveness ensures that if a solution exists, it will be found.}
\EDGECASES{Handles shared endpoints (allowed), duplicate roads (disallowed by input), and ring edges (absent by input).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

def normalize_edge(a: int, b: int) -> Tuple[int, int]:
    return (a, b) if a < b else (b, a)

def crosses(e1: Tuple[int, int], e2: Tuple[int, int]) -> bool:
    a, b = normalize_edge(*e1)
    c, d = normalize_edge(*e2)
    # sharing endpoints is allowed and not a crossing
    if len({a, b, c, d}) < 4:
        return False
    # chords cross iff endpoints interleave in linear order
    return (a < c < b < d) or (c < a < d < b)

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    return n, m, edges

def solve_case_baseline(n: int, m: int, edges: List[Tuple[int, int]]) -> str:
    # precompute crossing matrix
    cross = [[False]*m for _ in range(m)]
    for i in range(m):
        for j in range(i+1, m):
            c = crosses(edges[i], edges[j])
            cross[i][j] = cross[j][i] = c

    assign = [-1]*m  # -1 unknown, 0 -> 'i', 1 -> 'o'

    def ok_place(idx: int, side: int) -> bool:
        for j in range(idx):
            if assign[j] == side and cross[idx][j]:
                return False
        return True

    res = None

    def dfs(idx: int):
        nonlocal res
        if res is not None:
            return
        if idx == m:
            res = ''.join('i' if x == 0 else 'o' for x in assign)
            return
        for side in (0, 1):
            if ok_place(idx, side):
                assign[idx] = side
                dfs(idx+1)
                assign[idx] = -1
                if res is not None:
                    return

    dfs(0)
    return res if res is not None else "Impossible"

def solve_all_baseline(data: str) -> str:
    n, m, edges = read_input(data)
    return solve_case_baseline(n, m, edges)

def _tests_baseline():
    # crossing predicate sanity
    assert crosses((1, 3), (2, 4)) is True
    assert crosses((1, 4), (2, 3)) is True
    assert crosses((1, 3), (3, 5)) is False  # shared endpoint
    assert crosses((2, 5), (1, 3)) is True
    # simple solvable case
    data = "4 2\n1 3\n2 4\n"
    out = solve_all_baseline(data)
    assert set(out) == set("io") and len(out) == 2
    # impossible triangle crossings
    data = "6 3\n1 4\n2 5\n3 6\n"
    out = solve_all_baseline(data)
    assert out == "Impossible"

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        _tests_baseline()
        print("io")  # dummy visible output for local runs
    else:
        print(solve_all_baseline(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Tiny asserts included:
- Crossing predicate checks.
- Solvable and impossible mini instances.
- Deterministic behavior without randomness.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Intersection Graph and Bipartite Check}
\WHICHFORMULA{Build graph $G$ where vertices are roads and edges connect pairs of roads that would cross if drawn on the same side. Then 2-color $G$ using BFS/DFS. If $G$ is bipartite, the coloring maps to inside/outside.}
\ASSUMPTIONS{Two chords cross iff their endpoints strictly interleave in the linear order after normalizing each pair; roads sharing endpoints do not cross.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $cross[i][j]$ for all pairs using the interleaving test.
\item Build adjacency lists for the intersection graph $G$.
\item Run BFS over connected components, assigning alternating colors; if a conflict appears, return \texttt{Impossible}.
\item Translate colors to \texttt{i}/\texttt{o} and output as a string in input order.
\end{algosteps}
\COMPLEXITY{Pairwise crossing computation is $O(m^2)$. BFS coloring is $O(m+|E_G|)\le O(m^2)$. Overall time $O(m^2)$, space $O(m^2)$.}
\[
\begin{aligned}
T(m) &= \Theta(m^2) \quad \text{(pairwise build)} + \Theta(m^2) \quad \text{(BFS)} = \Theta(m^2).
\end{aligned}
\]
\CORRECTNESS{By construction, an edge in $G$ enforces opposite sides for its endpoints. A proper 2-coloring exists iff no odd cycle is present, which is exactly the condition for being able to split the set of roads into two non-crossing groups.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple, Deque
from collections import deque

def normalize_edge(a: int, b: int) -> Tuple[int, int]:
    return (a, b) if a < b else (b, a)

def crosses(e1: Tuple[int, int], e2: Tuple[int, int]) -> bool:
    a, b = normalize_edge(*e1)
    c, d = normalize_edge(*e2)
    if len({a, b, c, d}) < 4:
        return False
    return (a < c < b < d) or (c < a < d < b)

def read_input(data: str):
    tokens = data.strip().split()
    it = iter(tokens)
    n = int(next(it)); m = int(next(it))
    edges = [(int(next(it)), int(next(it))) for _ in range(m)]
    return n, m, edges

def solve_case_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str:
    # Build intersection graph
    adj = [[] for _ in range(m)]
    for i in range(m):
        for j in range(i+1, m):
            if crosses(edges[i], edges[j]):
                adj[i].append(j)
                adj[j].append(i)
    # BFS 2-coloring
    color = [-1]*m
    for s in range(m):
        if color[s] != -1:
            continue
        color[s] = 0
        q: Deque[int] = deque([s])
        while q:
            v = q.popleft()
            for u in adj[v]:
                if color[u] == -1:
                    color[u] = color[v] ^ 1
                    q.append(u)
                elif color[u] == color[v]:
                    return "Impossible"
    return ''.join('i' if c == 0 else 'o' for c in color)

def solve_all_bipartite(data: str) -> str:
    n, m, edges = read_input(data)
    return solve_case_bipartite(n, m, edges)

def _tests_bipartite():
    # crossing tests
    assert crosses((2, 5), (1, 3)) is True
    assert crosses((1, 3), (4, 6)) is False
    # simple OK
    data = "4 2\n1 3\n2 4\n"
    out = solve_all_bipartite(data)
    assert set(out) == set("io") and len(out) == 2
    # impossible K3 of crossings
    data = "6 3\n1 4\n2 5\n3 6\n"
    assert solve_all_bipartite(data) == "Impossible"

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        _tests_bipartite()
        print("io")
    else:
        print(solve_all_bipartite(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks include crossing predicate sanity, solvable case, and an impossible triangle of crossings.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Chord Intersection Graph is Bipartite iff Feasible}
\WHICHFORMULA{Construct the chord intersection graph and 2-color it. This is optimal: any solution corresponds to a bipartition, and any bipartition yields a valid inside/outside assignment.}
\ASSUMPTIONS{Endpoints are on a common circle in order $1,\ldots,n$. Roads do not use existing ring edges and may meet at endpoints.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each pair of roads $(u_1,v_1)$, $(u_2,v_2)$, mark an edge if and only if endpoints strictly interleave: after sorting each pair so $u<v$, check $(u_1 < u_2 < v_1 < v_2)$ or $(u_2 < u_1 < v_2 < v_1)$.
\item Run BFS over all components to 2-color. If a color conflict occurs, output \texttt{Impossible}.
\item Map colors to \texttt{i}/\texttt{o} and print in input order.
\end{algosteps}
\OPTIMALITY{Necessary and sufficient: The constraint that crossing pairs must be on opposite sides is exactly captured by the bipartite requirement. The algorithm runs in $\Theta(m^2)$ time, optimal for explicitly inspecting all potential pairwise crossings.}
\COMPLEXITY{Time $\Theta(m^2)$, space $\Theta(m^2)$.}
\[
\begin{aligned}
T(m) &= \Theta\!\left(\binom{m}{2}\right) + \Theta(m + |E_G|) = \Theta(m^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple, Deque
from collections import deque

def normalize_edge(a: int, b: int) -> Tuple[int, int]:
    return (a, b) if a < b else (b, a)

def crosses(e1: Tuple[int, int], e2: Tuple[int, int]) -> bool:
    a, b = normalize_edge(*e1)
    c, d = normalize_edge(*e2)
    if len({a, b, c, d}) < 4:
        return False
    return (a < c < b < d) or (c < a < d < b)

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    return n, m, edges

def solve_case(n: int, m: int, edges: List[Tuple[int, int]]) -> str:
    # Build intersection graph
    adj = [[] for _ in range(m)]
    for i in range(m):
        for j in range(i+1, m):
            if crosses(edges[i], edges[j]):
                adj[i].append(j)
                adj[j].append(i)
    # BFS bipartite coloring
    color = [-1] * m
    for s in range(m):
        if color[s] != -1:
            continue
        color[s] = 0
        q: Deque[int] = deque([s])
        while q:
            v = q.popleft()
            for u in adj[v]:
                if color[u] == -1:
                    color[u] = color[v] ^ 1
                    q.append(u)
                elif color[u] == color[v]:
                    return "Impossible"
    return ''.join('i' if c == 0 else 'o' for c in color)

def solve_all(data: str) -> str:
    n, m, edges = read_input(data)
    return solve_case(n, m, edges)

def _tests_final():
    # crossing unit tests
    assert crosses((1, 3), (2, 4)) is True
    assert crosses((1, 4), (2, 3)) is True
    assert crosses((1, 3), (3, 5)) is False
    assert crosses((2, 5), (1, 3)) is True
    # simple solvable case
    data = "4 2\n1 3\n2 4\n"
    out = solve_all(data)
    assert set(out) == set("io") and len(out) == 2
    # impossible triangle
    data = "6 3\n1 4\n2 5\n3 6\n"
    assert solve_all(data) == "Impossible"

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        _tests_final()
        print("io")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts in the final block:
- Two crossing predicate checks and one non-crossing with shared endpoint.
- One solvable instance and one impossible instance.}
\RESULT{Print \texttt{Impossible} if no bipartition exists; otherwise, print an any valid inside/outside assignment string where crossing pairs have opposite letters.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for the crossing predicate; consistency checks across approaches using small crafted inputs; I\slash O tests for solvable and impossible cases.}
\LINE{CROSS-CHECKS}{Compare outputs of Baseline DFS and Bipartite methods for small random instances ($n \le 8$, $m \le 8$). They must agree or both report \texttt{Impossible}.}
\LINE{EDGE-CASE GENERATOR}{Generate random sets of roads avoiding ring edges and duplicates; include cases with shared endpoints, disjoint chords, and triangles of interleaving chords to force \texttt{Impossible}.}
\begin{minted}{python}
import random
from typing import List, Tuple

def gen_instance(n: int, m: int, seed: int = 0) -> str:
    random.seed(seed)
    ring = {(i, i+1) for i in range(1, n)} | {(n, 1)}
    edges = set()
    while len(edges) < m:
        a = random.randint(1, n)
        b = random.randint(1, n)
        if a == b:
            continue
        e = tuple(sorted((a, b)))
        if e in edges:
            continue
        if e in ring or (e[1] == e[0] + 1) or (e == (1, n)):
            continue
        edges.add(e)
    lines = [f"{n} {m}"] + [f"{a} {b}" for a, b in edges]
    return "\n".join(lines) + "\n"

# Reference solution (Final)
from collections import deque

def normalize_edge(a: int, b: int):
    return (a, b) if a < b else (b, a)

def crosses(e1: Tuple[int, int], e2: Tuple[int, int]) -> bool:
    a, b = normalize_edge(*e1)
    c, d = normalize_edge(*e2)
    if len({a, b, c, d}) < 4:
        return False
    return (a < c < b < d) or (c < a < d < b)

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    edges = [(int(next(it)), int(next(it))) for _ in range(m)]
    return n, m, edges

def solve_case(n: int, m: int, edges: List[Tuple[int, int]]) -> str:
    adj = [[] for _ in range(m)]
    for i in range(m):
        for j in range(i+1, m):
            if crosses(edges[i], edges[j]):
                adj[i].append(j)
                adj[j].append(i)
    color = [-1]*m
    for s in range(m):
        if color[s] != -1: continue
        color[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for u in adj[v]:
                if color[u] == -1:
                    color[u] = color[v] ^ 1
                    q.append(u)
                elif color[u] == color[v]:
                    return "Impossible"
    return ''.join('i' if c == 0 else 'o' for c in color)

def reference_main(data: str) -> str:
    n, m, edges = read_input(data)
    return solve_case(n, m, edges)

# Quick self-checks
if __name__ == "__main__":
    # Deterministic small tests
    data = "4 2\n1 3\n2 4\n"
    print(reference_main(data))  # e.g., "io"
    data = "6 3\n1 4\n2 5\n3 6\n"
    print(reference_main(data))  # "Impossible"
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple, Deque
from collections import deque

def normalize_edge(a: int, b: int) -> Tuple[int, int]:
    return (a, b) if a < b else (b, a)

def crosses(e1: Tuple[int, int], e2: Tuple[int, int]) -> bool:
    a, b = normalize_edge(*e1)
    c, d = normalize_edge(*e2)
    if len({a, b, c, d}) < 4:
        return False
    return (a < c < b < d) or (c < a < d < b)

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    edges = []
    for _ in range(m):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    return n, m, edges

def solve_case(n: int, m: int, edges: List[Tuple[int, int]]) -> str:
    adj = [[] for _ in range(m)]
    for i in range(m):
        for j in range(i+1, m):
            if crosses(edges[i], edges[j]):
                adj[i].append(j)
                adj[j].append(i)
    color = [-1] * m
    for s in range(m):
        if color[s] != -1:
            continue
        color[s] = 0
        q: Deque[int] = deque([s])
        while q:
            v = q.popleft()
            for u in adj[v]:
                if color[u] == -1:
                    color[u] = color[v] ^ 1
                    q.append(u)
                elif color[u] == color[v]:
                    return "Impossible"
    return ''.join('i' if c == 0 else 'o' for c in color)

def solve_all(data: str) -> str:
    n, m, edges = read_input(data)
    return solve_case(n, m, edges)

def _tests():
    # Unit tests
    assert crosses((1, 3), (2, 4)) is True
    assert crosses((1, 5), (2, 3)) is False
    assert crosses((2, 5), (1, 3)) is True
    # I/O tests
    assert set(solve_all("4 2\n1 3\n2 4\n")) == set("io")
    assert solve_all("6 3\n1 4\n2 5\n3 6\n") == "Impossible"

def main():
    import sys
    data = sys.stdin.read()
    if not data.strip():
        _tests()
        print("io")
    else:
        print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Partition candidate chords into two sets so that within each set no two chords interleave; equivalently, 2-color the chord intersection graph.}
\WHY{This pattern appears in planar embeddings, outerplanar decompositions, and circle graph bipartitions — a classic interview reduction to bipartite checking.}
\CHECKLIST{%
- Normalize each chord $(a,b)$ to $a<b$.
- Crossing iff $(a<c<b<d)$ or $(c<a<d<b)$ with four distinct endpoints.
- Build intersection graph, BFS/DFS 2-color components.
- Emit \texttt{Impossible} on conflict; else map colors to \texttt{i}/\texttt{o}.}
\EDGECASES{%
- Roads sharing an endpoint: allowed on the same side.
- Near-wrap chords like $(n,2)$: normalization to $(2,n)$ suffices.
- Zero or one road: always solvable.
- Dense crossings forming odd cycles: must be \texttt{Impossible}.
- Duplicate input roads: disallowed by statement.
- Ring edges: excluded by statement.}
\PITFALLS{%
- Treating shared endpoints as crossings (incorrect).
- Forgetting to normalize endpoints before the interleaving test.
- Using only $a<c<b<d$ but not the symmetric case.
- Mishandling input parsing or off-by-one indices.
- Assuming geometry beyond the combinatorial circle order.
- Failing to color disconnected components.}
\FAILMODES{Greedy local placement can fail on global constraints (odd cycles of crossings). The bipartite reduction survives by detecting conflicts during BFS.}
\ELI{Make a graph where we connect two roads if they would bump into each other on the same side. If we can color this graph with two colors, draw one color inside and the other outside; if not, it is impossible.}
\NotePages{3}

\end{document}