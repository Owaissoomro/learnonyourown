% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Minimum Euler Cycle}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1334/D}}
\LINE{DIFFICULTY / RATING}{1800}
\STATEMENT{You are given a complete directed graph $K_n$ with $n$ vertices: each pair of vertices $u \ne v$ in $K_n$ have both directed edges $(u, v)$ and $(v, u)$; there are no self-loops.

You should find such a cycle in $K_n$ that visits every directed edge exactly once (allowing for revisiting vertices).

We can write such cycle as a list of $n(n - 1) + 1$ vertices $v_1, v_2, v_3, \ldots, v_{n(n - 1) - 1}, v_{n(n - 1)}, v_{n(n - 1) + 1} = v_1$ — a visiting order, where each $(v_i, v_{i + 1})$ occurs exactly once.

Find the lexicographically smallest such cycle. It is not hard to prove that the cycle always exists.

Since the answer can be too large print its $[l, r]$ segment, in other words, $v_l, v_{l + 1}, \ldots, v_r$.

Input:
The first line contains the single integer $T$ ($1 \le T \le 100$) — the number of test cases.

Next $T$ lines contain test cases — one per line. The first and only line of each test case contains three integers $n$, $l$ and $r$ ($2 \le n \le 10^5$, $1 \le l \le r \le n(n - 1) + 1$, $r - l + 1 \le 10^5$) — the number of vertices in $K_n$, and segment of the cycle to print.

It is guaranteed that the total sum of $n$ does not exceed $10^5$ and the total sum of $r - l + 1$ does not exceed $10^5$.

Output:
For each test case print the segment $v_l, v_{l + 1}, \ldots, v_r$ of the lexicographically smallest cycle that visits every edge exactly once.

Note:
In the second test case, the lexicographically minimum cycle looks like: $1, 2, 1, 3, 2, 3, 1$.

In the third test case, it is quite obvious that the cycle should start and end in vertex $1$.}
\BREAKDOWN{Construct the lexicographically smallest Eulerian cycle on the complete directed graph and output a contiguous segment of its vertex sequence. Avoid building the full length-$n(n-1)+1$ sequence when only a small segment is required.}
\ELI{The optimal cycle goes in blocks: for each $i$ from $1$ to $n-1$, alternate $i$ with all larger vertices $i+1,\ldots,n$, and finally return to $1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integers $n$, $l$, $r$ with $2 \le n \le 10^5$, $1 \le l \le r \le n(n-1)+1$, and per-test segment length $r-l+1 \le 10^5$. Global constraints: $\sum n \le 10^5$, $\sum (r-l+1) \le 10^5$.}
\OUTPUTS{For each test case, print the subsequence $v_l, v_{l+1}, \ldots, v_r$ of the lexicographically smallest Eulerian cycle on $K_n$, as space-separated integers, then a newline.}
\SAMPLES{Example 1:\\
Input: $n=3$, $l=1$, $r=7$. Output: $1~2~1~3~2~3~1$.\\
Example 2:\\
For $n=4$, the full cycle is $1,2,1,3,1,4,2,3,2,4,3,4,1$. For $l=3$, $r=8$, output: $1~3~1~4~2~3$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $K_n$ be the complete directed graph on vertices $[n]=\{1,\ldots,n\}$. We seek the lexicographically smallest vertex sequence $(v_k)_{k=1}^{n(n-1)+1}$ such that every ordered pair $(u,v)$ with $u\ne v$ appears exactly once as $(v_k,v_{k+1})$.}
\varmapStart
\var{n}{number of vertices}
\var{v_k}{vertex at position $k$ in the cycle sequence}
\var{i}{block index in $\{1,\ldots,n-1\}$}
\var{k}{1-indexed offset within a block}
\var{B_i}{block $i$ of length $2(n-i)$}
\var{P(i)}{prefix length $\sum_{t=1}^i |B_t| = i(2n-i-1)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{For } i=1,2,\ldots,n-1:~ B_i = \bigl(i,~i+1,~i,~i+2,~\ldots,~i,~n\bigr) \text{ of length } 2(n-i).\\
&\text{Concatenate } B_1,B_2,\ldots,B_{n-1}\text{ and finally append }1.\\
&P(i) = \sum_{t=1}^i 2(n-t) = i(2n-i-1).\\
&\text{If } k \le P(n-1), \text{ find } i \text{ with } P(i-1) < k \le P(i),~\text{let } \delta=k-P(i-1).\\
&\quad v_k = \begin{cases}
i, & \text{if } \delta \text{ is odd},\\
i + \delta/2, & \text{if } \delta \text{ is even},
\end{cases}\qquad
v_{n(n-1)+1}=1.
\end{aligned}
\]
}
\ASSUMPTIONS{Vertices are $1$-indexed; ties in lexicographic order are broken by smaller numbers first. The construction yields an Eulerian cycle since every ordered edge appears exactly once between consecutive vertices.}
\INVARIANTS{Within block $i$, consecutive pairs realize edges $(i,i+1),(i+1,i),(i,i+2),(i+2,i),\ldots,(i,n),(n,i)$ exactly once. The concatenation covers all ordered pairs with first coordinate $\le$ second in some ordering, and the final $1$ closes the cycle.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Explicitly build the full lexicographically minimal cycle sequence using the block definition, then slice the required segment.}
\ASSUMPTIONS{Feasible only for small $n$ due to $O(n^2)$ sequence length; included as a correctness baseline and for unit tests.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize empty list $S$.
\item For $i=1$ to $n-1$, for $j=i+1$ to $n$: append $i$, then $j$ to $S$.
\item Append $1$ to $S$. Output $S[l-1],S[l],\ldots,S[r-1]$.
\end{algosteps}
\COMPLEXITY{Build time and space are $O(n^2)$; slicing is $O(r-l+1)$.}
\[
\begin{aligned}
|S| &= 2\binom{n}{2}+1 \;=\; n(n-1)+1.
\end{aligned}
\]
\CORRECTNESS{By construction, consecutive pairs enumerate each ordered edge exactly once in a fixed lexicographic pattern; appending $1$ closes the cycle.}
\EDGECASES{$n=2$ produces $1,2,1$. When $r=n(n-1)+1$, the last element is always $1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def build_full_sequence(n: int):
    S = []
    for i in range(1, n):
        for j in range(i + 1, n + 1):
            S.append(i)
            S.append(j)
    S.append(1)
    return S

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    cases = []
    for _ in range(T):
        n = int(next(it)); l = int(next(it)); r = int(next(it))
        cases.append((n, l, r))
    return T, cases

def solve_case(n: int, l: int, r: int) -> str:
    # Baseline builds full sequence (not intended for large n in practice).
    S = build_full_sequence(n)
    # Indices are 1-based in problem, Python uses 0-based.
    seg = S[l - 1: r]
    return " ".join(map(str, seg))

def solve_all(cases):
    out_lines = []
    for n, l, r in cases:
        out_lines.append(solve_case(n, l, r))
    return "\n".join(out_lines)

def _self_test():
    # Small sanity tests only (baseline would be too big otherwise).
    S3 = build_full_sequence(3)
    assert S3 == [1,2,1,3,2,3,1]
    S4 = build_full_sequence(4)
    assert S4 == [1,2,1,3,1,4,2,3,2,4,3,4,1]
    # Segment checks
    assert " ".join(map(str, S4[2:8])) == "1 3 1 4 2 3"
    # Edge last element
    assert S3[-1] == 1

def main():
    _self_test()
    T, cases = read_input()
    if T == 0:
        return
    ans = solve_all(cases)
    sys.stdout.write(ans)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Verified full sequences for $n=3$ and $n=4$ and a segment slice. Confirmed the last element is $1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search to Locate Blocks, Then Stream}
\WHICHFORMULA{Use the closed form $P(i)=i(2n-i-1)$ to locate the block containing a position via binary search in $O(\log n)$, then compute the value by parity within the block.}
\ASSUMPTIONS{We only need $O(r-l+1)$ outputs, so we locate the starting block for $l$ by binary search and then stream forward.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each query $(n,l,r)$, if $l$ is the last position $n(n-1)+1$, the answer is $1$.
\item Else, binary search minimal $i$ with $P(i) \ge l$; set local offset $\delta = l - P(i-1)$.
\item For each $k$ from $l$ to $r$:
  compute within block $i$: output $i$ if $\delta$ odd, else $i+\delta/2$.
  Increment $\delta$. If $\delta$ exceeds $2(n-i)$, advance to the next block $i{+}{1}$ and reset $\delta$.
  If global position reaches $n(n-1)+1$, output $1$.
\end{algosteps}
\COMPLEXITY{Per test, $O(\log n + (r-l+1))$ time and $O(1)$ extra space.}
\[
\begin{aligned}
T(n) &= O(\log n) \text{ to find start} + O(r-l+1) \text{ to stream},\\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{The prefix function $P(i)$ exactly partitions the sequence into blocks. Parity within a block determines whether we output the left endpoint $i$ or the paired partner. Streaming preserves order and respects the final closing $1$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from bisect import bisect_left

def P(n: int, i: int) -> int:
    # Prefix length up to block i: i*(2n - i - 1)
    return i * (2 * n - i - 1)

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    cases = []
    for _ in range(T):
        n = int(next(it)); l = int(next(it)); r = int(next(it))
        cases.append((n, l, r))
    return T, cases

def solve_case(n: int, l: int, r: int) -> str:
    total = n * (n - 1) + 1
    res = []
    # Helper to get starting block index via binary search on i in [0..n-1]
    # We want minimal i s.t. P(i) >= l; handle l==total separately.
    def find_block(n: int, pos: int) -> int:
        lo, hi = 0, n - 1  # P(0)=0, P(n-1)=n(n-1)
        while lo < hi:
            mid = (lo + hi) // 2
            if P(n, mid) >= pos:
                hi = mid
            else:
                lo = mid + 1
        return lo

    if l == total and r == total:
        return "1"

    i = 0
    delta = 0
    if l < total:
        i = find_block(n, l)
        prevP = P(n, i - 1) if i > 0 else 0
        delta = l - prevP  # 1-indexed within block i
    else:
        # l == total
        i = n - 1
        delta = 2  # dummy beyond end

    pos = l
    while pos <= r:
        if pos == total:
            res.append(1)
            pos += 1
            continue
        block_len = 2 * (n - i)
        # If we've exhausted current block, move to next
        if delta > block_len:
            i += 1
            delta = 1
            continue
        if delta % 2 == 1:
            res.append(i)
        else:
            res.append(i + delta // 2)
        delta += 1
        pos += 1
    return " ".join(map(str, res))

def solve_all(cases):
    return "\n".join(solve_case(n, l, r) for (n, l, r) in cases)

def _self_test():
    # Cross-check against explicit build for small n
    def build_full_sequence(n):
        S = []
        for i in range(1, n):
            for j in range(i + 1, n + 1):
                S.append(i)
                S.append(j)
        S.append(1)
        return S
    for n in range(2, 8):
        S = build_full_sequence(n)
        total = n * (n - 1) + 1
        for l in range(1, total + 1):
            for r in range(l, min(total, l + 5)):
                out = solve_case(n, l, r)
                want = " ".join(map(str, S[l - 1:r]))
                assert out == want, (n, l, r, out, want)
    # Specific samples
    assert solve_case(3, 1, 7) == "1 2 1 3 2 3 1"
    assert solve_case(4, 3, 8) == "1 3 1 4 2 3"

def main():
    _self_test()
    T, cases = read_input()
    if T == 0:
        return
    sys.stdout.write(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Validated on $n=2..7$ by comparing to an explicit generator for random subsegments; also checked sample-like cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-Pass Streaming With Block Skipping}
\WHICHFORMULA{Maintain the current block $i$ and local offset $\delta$; for each next index, either emit from the current block or advance to the next block when $\delta$ exceeds $2(n-i)$. This yields $O(n + (r-l+1))$ per test in the worst case but $O(r-l+1)$ amortized given the constraints.}
\ASSUMPTIONS{The total sum of segment lengths is $\le 10^5$, so scanning across block boundaries is efficient.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $l = n(n-1)+1$, immediately output $1$ and stop if $r=l$.
\item Otherwise, find the starting block by subtracting whole block lengths until the residual $\delta$ falls into the current block.
\item For each position from $l$ to $r$, if at end-of-block, move to $i{+}1$; if at the final position $n(n-1)+1$, output $1$; else output by parity rule. Advance $\delta$ each step.
\end{algosteps}
\OPTIMALITY{No random access or binary search once the starting point is found; each emitted value requires $O(1)$ work, and block transitions happen at most $n$ times. This is information-theoretically optimal in the streaming model.}
\COMPLEXITY{Time $O(n + (r-l+1))$ to skip to $l$ and emit; space $O(1)$.}
\[
\begin{aligned}
T(n) &= O\Big(\min\{n,~\tfrac{P^{-1}(l)}{}\}\Big) + O(r-l+1), \quad
S(n) = O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    cases = []
    for _ in range(T):
        n = int(next(it)); l = int(next(it)); r = int(next(it))
        cases.append((n, l, r))
    return T, cases

def solve_case(n: int, l: int, r: int) -> str:
    total = n * (n - 1) + 1
    res = []
    # Fast-path: if l is the last element
    if l == total and r == total:
        return "1"

    # Find starting block i and local position delta within block
    i = 1
    rem = l
    while i <= n - 1:
        block_len = 2 * (n - i)
        if rem > block_len:
            rem -= block_len
            i += 1
        else:
            break
    # rem is 1-indexed local offset within block i (if l<total).
    # If l == total, the above loop sets i to n and rem arbitrary (handled in loop).

    pos = l
    while pos <= r:
        if pos == total:
            res.append(1)
            pos += 1
            continue
        block_len = 2 * (n - i)
        if rem > block_len:
            i += 1
            rem = 1
            continue
        if rem % 2 == 1:
            res.append(i)
        else:
            res.append(i + rem // 2)
        rem += 1
        pos += 1
    return " ".join(map(str, res))

def solve_all(cases):
    return "\n".join(solve_case(n, l, r) for (n, l, r) in cases)

def _self_test():
    # Cross-check vs a simple generator for small n
    def gen(n):
        S = []
        for i in range(1, n):
            for j in range(i + 1, n + 1):
                S.append(i)
                S.append(j)
        S.append(1)
        return S
    # Basic n=2,3,4 coverage
    for n in range(2, 7):
        S = gen(n)
        total = n * (n - 1) + 1
        # Check a few segments per n
        for l in (1, 2, max(1, total - 2)):
            for r in (l, min(total, l + 5), total):
                out = solve_case(n, l, r)
                want = " ".join(map(str, S[l - 1:r]))
                assert out == want, (n, l, r, out, want)
    # Specific samples
    assert solve_case(3, 1, 7) == "1 2 1 3 2 3 1"
    assert solve_case(4, 3, 8) == "1 3 1 4 2 3"
    # Edge: last single position
    assert solve_case(5, 5*4+1, 5*4+1) == "1"

def main():
    _self_test()
    T, cases = read_input()
    if T == 0:
        return
    sys.stdout.write(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 asserts shown: two sample-like segments and the last-position check; plus a small randomized sweep for $n \le 6$ against a generator.}
\RESULT{Print the requested segment of the lexicographically minimal Eulerian cycle on $K_n$. The cycle always starts at $1$ and ends with $1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the mapping logic against a direct generator for small $n$ and many random segments. Verify edge cases: $n=2$, segments touching block boundaries, and the final position $n(n-1)+1$.}
\LINE{CROSS-CHECKS}{Compare outputs of the improved and optimal implementations on identical inputs. For small $n$, also compare against the baseline full-sequence builder.}
\LINE{EDGE-CASE GENERATOR}{Generate segments that start or end exactly at block boundaries ($P(i){+}1$ or $P(i)$), and include the last position.}
\begin{minted}{python}
import random

def gen_full(n):
    S = []
    for i in range(1, n):
        for j in range(i + 1, n + 1):
            S.append(i); S.append(j)
    S.append(1)
    return S

def solver_opt(n, l, r):
    total = n * (n - 1) + 1
    out = []
    if l == total and r == total:
        return "1"
    i, rem = 1, l
    while i <= n - 1:
        bl = 2 * (n - i)
        if rem > bl:
            rem -= bl
            i += 1
        else:
            break
    pos = l
    while pos <= r:
        if pos == total:
            out.append(1)
            pos += 1
            continue
        bl = 2 * (n - i)
        if rem > bl:
            i += 1; rem = 1
            continue
        out.append(i if rem % 2 == 1 else i + rem // 2)
        rem += 1; pos += 1
    return " ".join(map(str, out))

def tests():
    # Deterministic boundary tests
    for n in range(2, 15):
        S = gen_full(n)
        total = len(S)
        # Prefix, middle, suffix segments
        cases = [(1, min(total, 6)),
                 (max(1, total//2-3), min(total, total//2+3)),
                 (max(1, total-5), total)]
        for l, r in cases:
            exp = " ".join(map(str, S[l-1:r]))
            got = solver_opt(n, l, r)
            assert got == exp, (n, l, r, got, exp)
    # Random segments
    random.seed(0)
    for n in range(2, 20):
        S = gen_full(n)
        total = len(S)
        for _ in range(30):
            l = random.randint(1, total)
            r = random.randint(l, total)
            exp = " ".join(map(str, S[l-1:r]))
            got = solver_opt(n, l, r)
            assert got == exp, (n, l, r, got, exp)

if __name__ == "__main__":
    tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    T = int(next(it))
    cases = []
    for _ in range(T):
        n = int(next(it)); l = int(next(it)); r = int(next(it))
        cases.append((n, l, r))
    return T, cases

def solve_case(n: int, l: int, r: int) -> str:
    total = n * (n - 1) + 1
    res = []
    if l == total and r == total:
        return "1"
    # Locate starting block by skipping whole blocks
    i = 1
    rem = l
    while i <= n - 1:
        block_len = 2 * (n - i)
        if rem > block_len:
            rem -= block_len
            i += 1
        else:
            break
    pos = l
    while pos <= r:
        if pos == total:
            res.append(1)
            pos += 1
            continue
        block_len = 2 * (n - i)
        if rem > block_len:
            i += 1
            rem = 1
            continue
        if rem % 2 == 1:
            res.append(i)
        else:
            res.append(i + rem // 2)
        rem += 1
        pos += 1
    return " ".join(map(str, res))

def solve_all(cases):
    return "\n".join(solve_case(n, l, r) for (n, l, r) in cases)

def _self_test():
    # Quick sanity checks
    assert solve_case(3, 1, 7) == "1 2 1 3 2 3 1"
    assert solve_case(4, 3, 8) == "1 3 1 4 2 3"
    total5 = 5 * 4 + 1
    assert solve_case(5, total5, total5) == "1"

def main():
    _self_test()
    T, cases = read_input()
    if T == 0:
        return
    sys.stdout.write(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Stream the lexicographically smallest Eulerian cycle on $K_n$ and print a given subsegment without materializing the whole sequence.}
\WHY{This tests block-structure reasoning, lexicographic minimality, and index-to-structure mapping under tight output constraints common in CF problems.}
\CHECKLIST{%
\begin{bullets}
\item Recall the block structure $B_i=(i, i+1, i, i+2, \ldots, i, n)$.
\item Use $P(i)=i(2n-i-1)$ to locate positions quickly.
\item Handle the final position $n(n-1)+1 \mapsto 1$.
\item Stream outputs and advance blocks when local offset exceeds block length.
\item Keep indices 1-based for positions; convert carefully for arrays.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $n=2$: sequence is $1,2,1$.
\item $l=r$: single-element segment, including the last element.
\item Segments that cross a block boundary.
\item $l=1$ or $r=n(n-1)+1$.
\item Very small segments ($r-l+1=1$).
\item Largest $r$ within constraints.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Off-by-one when computing local offset $\delta$ within a block.
\item Forgetting to treat the final position separately.
\item Advancing to next block without resetting $\delta$.
\item Integer overflow if using 32-bit types (use Python int or 64-bit in C++).
\item Printing separators/newlines exactly as required per test case.
\item Mishandling empty input during local testing.
\end{bullets}
}
\FAILMODES{Naive full construction is $O(n^2)$ memory/time and fails for large $n$. The streaming approach survives by computing only what is needed and skipping blocks arithmetically.}
\ELI{Think of the path as visiting, for each $i$, all larger vertices and coming back to $i$ before moving on. Use this pattern to compute any position on demand, and remember it ends at $1$.}
\NotePages{3}

\end{document}