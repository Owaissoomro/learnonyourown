% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximum Fruits Harvested After at Most K Steps}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array \texttt{fruits} where \texttt{fruits[i] = [position\_i, amount\_i]} depicts \texttt{amount\_i} fruits at the position \texttt{position\_i}. \texttt{fruits} is already sorted by \texttt{position\_i} in ascending order, and each \texttt{position\_i} is unique.

You are also given an integer \texttt{startPos} and an integer \texttt{k}. Initially, you are at the position \texttt{startPos}. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most \texttt{k} steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.

Return the maximum total number of fruits you can harvest.

Example 1:

Input: \texttt{fruits = [[2,8],[6,3],[8,6]]}, \texttt{startPos = 5}, \texttt{k = 4}

Output: \texttt{9}

Explanation:
\begin{bullets}
\item Move right to position 6 and harvest 3 fruits.
\item Move right to position 8 and harvest 6 fruits.
\end{bullets}
You moved 3 steps and harvested \texttt{3 + 6 = 9} fruits in total.

Example 2:

Input: \texttt{fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]]}, \texttt{startPos = 5}, \texttt{k = 4}

Output: \texttt{14}

Explanation:
\begin{bullets}
\item Harvest the 7 fruits at the starting position 5.
\item Move left to position 4 and harvest 1 fruit.
\item Move right to position 6 and harvest 2 fruits.
\item Move right to position 7 and harvest 4 fruits.
\end{bullets}
You moved \texttt{1 + 3 = 4} steps and harvested \texttt{7 + 1 + 2 + 4 = 14} fruits in total.

Example 3:

Input: \texttt{fruits = [[0,3],[6,4],[8,5]]}, \texttt{startPos = 3}, \texttt{k = 2}

Output: \texttt{0}

Explanation: You can move at most \texttt{k = 2} steps and cannot reach any position with fruits.

Constraints:
\begin{itemize}
\item \texttt{1 \le fruits.length \le 10^5}
\item \texttt{fruits[i].length == 2}
\item \texttt{0 \le startPos, position\_i \le 2 \times 10^5}
\item \texttt{position\_{i-1} < position\_i} for any \texttt{i > 0} (0-indexed)
\item \texttt{1 \le amount\_i \le 10^4}
\item \texttt{0 \le k \le 2 \times 10^5}
\end{itemize}
}
\BREAKDOWN{We must choose a path of at most \texttt{k} unit steps along the line from \texttt{startPos} that maximizes harvested fruits. Any optimal path visits an interval \([L,R]\) and its minimal step cost depends on the relative position of \texttt{startPos} to that interval. Thus, the task reduces to finding the best interval complying with the movement budget.}
\ELI{Pick a stretch of positions you can cover within \texttt{k} steps starting from \texttt{startPos} and sum all fruits on it; choose the best such stretch.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Function signature (LeetCode): \texttt{def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int}. Inputs:
\begin{itemize}
\item \texttt{fruits}: list of pairs \([\texttt{position\_i}, \texttt{amount\_i}]\), strictly increasing by \texttt{position\_i}.
\item \texttt{startPos}: integer start coordinate on the x-axis.
\item \texttt{k}: nonnegative integer maximum steps.
\end{itemize}
Valid ranges: as stated in the Constraints of the problem statement.}
\OUTPUTS{Single integer: the maximum total number of fruits harvestable within at most \texttt{k} steps.}
\SAMPLES{
Example A: \texttt{fruits=[[2,8],[6,3],[8,6]]}, \texttt{startPos=5}, \texttt{k=4} yields \texttt{9}.

Example B: \texttt{fruits=[[0,3],[6,4],[8,5]]}, \texttt{startPos=3}, \texttt{k=2} yields \texttt{0}.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let positions be \(p_1 < p_2 < \cdots < p_n\) with corresponding amounts \(a_1,\ldots,a_n \in \mathbb{Z}_{\ge 0}\). Let the start be \(s \in \mathbb{Z}_{\ge 0}\) and budget \(k \in \mathbb{Z}_{\ge 0}\). Choose indices \(L \le R\) to visit all positions in \([p_L,p_R]\). Define the minimal steps to cover \([p_L,p_R]\) starting at \(s\) by the piecewise function below. Objective: maximize \(\sum_{i=L}^{R} a_i\) subject to steps\((L,R,s) \le k\).}
\varmapStart
\var{p_i}{sorted fruit positions}
\var{a_i}{amounts at \(p_i\)}
\var{s}{start position \(\texttt{startPos}\)}
\var{k}{maximum allowed steps}
\var{L,R}{indices of leftmost and rightmost visited positions}
\varmapEnd
\GOVERN{
\[
\text{steps}(p_L,p_R;s)=
\begin{cases}
p_R - s, & s \le p_L,\\
s - p_L, & s \ge p_R,\\
(p_R - p_L) + \min(s - p_L,\; p_R - s), & p_L \le s \le p_R~.
\end{cases}
\]
Constraint: \(\text{steps}(p_L,p_R;s) \le k\). Objective: \(\max\limits_{L \le R} \sum_{i=L}^{R} a_i\).
}
\ASSUMPTIONS{Positions are unique and strictly increasing; amounts are nonnegative; it is always optimal to collect a contiguous block of positions because detours waste steps without adding new positions.}
\INVARIANTS{
\begin{bullets}
\item For any fixed \([L,R]\), the minimal steps depend only on \(p_L,p_R,s\) as defined above.
\item If \([L,R]\) is feasible, any sub-interval \([L',R'] \subseteq [L,R]\) is feasible.
\item The best solution lies within \([s-k, s+k]\) on the coordinate axis.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate one direction to visit first, then extend the other side as far as the remaining budget allows. This uses the explicit left-first and right-first costs: \(2\,(s-L) + (R-s)\) and \(2\,(R-s) + (s-L)\) respectively when \(L \le s \le R\).}
\ASSUMPTIONS{Precompute prefix sums over the sorted positions to query sums on any interval in \(O(1)\). Use binary search to determine the furthest reachable index on the opposite side.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Extract arrays \(p\) and \(a\); build prefix sums \(P\).
\item For each index \(i\) with \(p_i \le s\) (left side), compute remaining budget for the right: \(r_{\max} = s + (k - 2\,(s - p_i))\). If negative, skip. Find \(j = \max\{\,t : p_t \le r_{\max}\,\}\) by binary search and update the sum on \([i,j]\).
\item Symmetrically, for each index \(j\) with \(p_j \ge s\) (right side), compute remaining budget for the left: \(\ell_{\min} = s - (k - 2\,(p_j - s))\). Find \(i = \min\{\,t : p_t \ge \ell_{\min}\,\}\) and update the sum on \([i,j]\).
\end{algosteps}
\COMPLEXITY{For \(n\) positions, two outer scans each do \(O(n)\) iterations, each with \(O(\log n)\) binary searches.}
\[
\begin{aligned}
T(n) &= O(n \log n),\\
S(n) &= O(n) \text{ for arrays and prefix sums.}
\end{aligned}
\]
\CORRECTNESS{Every feasible path that turns at most once is captured by one of the two cases (left-first, right-first). For a fixed turn point, taking the farthest reachable opposite-side bound maximizes the harvested sum; prefix sums ensure exact interval sums.}
\EDGECASES{No fruit reachable; fruit exactly at \(\,s\); all fruits only on one side; \(\,k=0\); duplicate start inside interval; sparse large coordinates.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
import bisect

class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        # O(n log n) baseline using prefix sums and binary searches over split strategies
        if not fruits or k == 0:
            # If k == 0, only fruits at startPos can be collected
            if not fruits:
                return 0
            # binary search to see if position == startPos
            pos = [p for p, _ in fruits]
            i = bisect.bisect_left(pos, startPos)
            return fruits[i][1] if i < len(fruits) and pos[i] == startPos else 0

        pos = [p for p, _ in fruits]
        amt = [a for _, a in fruits]
        n = len(pos)
        pref = [0] * (n + 1)
        for i in range(n):
            pref[i + 1] = pref[i] + amt[i]

        def range_sum(i: int, j: int) -> int:
            if i > j:
                return 0
            i = max(i, 0)
            j = min(j, n - 1)
            return pref[j + 1] - pref[i]

        ans = 0

        # Left-first: pick i on the left, go to i, turn, then go right as far as possible
        # steps = 2*(s - p[i]) + max(0, p[j] - s)
        # This is valid only if p[i] <= s and 2*(s - p[i]) <= k
        left_limit = bisect.bisect_left(pos, startPos - k)
        right_limit = bisect.bisect_right(pos, startPos + k) - 1
        last_le_s = bisect.bisect_right(pos, startPos) - 1
        if last_le_s >= 0:
            for i in range(max(left_limit, 0), min(last_le_s, n - 1) + 1):
                left_cost = 2 * (startPos - pos[i])
                if left_cost > k:
                    continue
                rem = k - left_cost
                # furthest right position reachable after turning
                rmax = startPos + rem
                j = bisect.bisect_right(pos, rmax) - 1
                j = min(j, right_limit)
                if j >= i:
                    ans = max(ans, range_sum(i, j))

        # Right-first: pick j on the right, go to j, turn, then go left as far as possible
        # steps = 2*(p[j] - s) + max(0, s - p[i])
        first_ge_s = bisect.bisect_left(pos, startPos)
        if first_ge_s < n:
            for j in range(max(first_ge_s, 0), min(right_limit, n - 1) + 1):
                right_cost = 2 * (pos[j] - startPos)
                if right_cost > k:
                    continue
                rem = k - right_cost
                lmin = startPos - rem
                i = bisect.bisect_left(pos, lmin)
                i = max(i, left_limit)
                if i <= j:
                    ans = max(ans, range_sum(i, j))

        # Also consider staying entirely on one side (implicitly covered when rem >= 0)
        return ans

# Basic asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxTotalFruits([[2,8],[6,3],[8,6]], 5, 4) == 9
    assert sol.maxTotalFruits([[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], 5, 4) == 14
    assert sol.maxTotalFruits([[0,3],[6,4],[8,5]], 3, 2) == 0
    # k = 0 only at start
    assert sol.maxTotalFruits([[3,5]], 3, 0) == 5
    assert sol.maxTotalFruits([[2,1],[4,2]], 3, 0) == 0
\end{minted}
\VALIDATION{Validated on the three provided examples, plus corner cases with \texttt{k=0}.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use a sliding window over the sorted positions with the unified minimal-step formula
\(\text{steps}(p_L,p_R;s)\). Maintain two pointers \(L\) and \(R\) and expand \(R\), shrinking \(L\) while the window violates the budget. Track the running sum for \(O(1)\) updates.}
\ASSUMPTIONS{Contiguity of visited positions is optimal; positions are pre-sorted; the budget feasibility for a window only depends on its ends and the fixed \(s\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize \(L=0\), running sum \(S=0\), and answer \(A=0\).
\item For \(R\) from \(0\) to \(n-1\): add \(a_R\) to \(S\). While \(\text{steps}(p_L,p_R;s) > k\), subtract \(a_L\) and increment \(L\).
\item Update \(A=\max(A,S)\) at each \(R\). Return \(A\).
\end{algosteps}
\COMPLEXITY{Each index enters and leaves the window at most once.}
\[
\begin{aligned}
T(n) &= O(n),\\
S(n) &= O(1) \text{ extra (beyond input storage).}
\end{aligned}
\]
\CORRECTNESS{The window invariant maintains feasibility: shrinking \(L\) strictly decreases the required steps until the budget holds. Since amounts are nonnegative, enlarging \(R\) and shrinking \(L\) only when necessary explores all maximal feasible windows.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        if not fruits:
            return 0
        pos = [p for p, _ in fruits]
        amt = [a for _, a in fruits]
        n = len(pos)

        def steps(Lp: int, Rp: int, s: int) -> int:
            if s <= Lp:
                return Rp - s
            if s >= Rp:
                return s - Lp
            return (Rp - Lp) + min(s - Lp, Rp - s)

        # Filter to positions within [s-k, s+k] to keep window tight (optional optimization)
        import bisect
        lo = bisect.bisect_left(pos, startPos - k)
        hi = bisect.bisect_right(pos, startPos + k)
        pos = pos[lo:hi]
        amt = amt[lo:hi]
        n = len(pos)
        if n == 0:
            return 0

        ans = 0
        L = 0
        cur = 0
        for R in range(n):
            cur += amt[R]
            while L <= R and steps(pos[L], pos[R], startPos) > k:
                cur -= amt[L]
                L += 1
            ans = max(ans, cur)
        return ans

# Asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxTotalFruits([[2,8],[6,3],[8,6]], 5, 4) == 9
    assert sol.maxTotalFruits([[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], 5, 4) == 14
    assert sol.maxTotalFruits([[0,3],[6,4],[8,5]], 3, 2) == 0
    # Single-side reachability
    assert sol.maxTotalFruits([[100,5],[101,7]], 98, 3) == 5
\end{minted}
\VALIDATION{Checked on given examples and a case where only the leftmost fruit is reachable.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Single-pass sliding window using the exact minimal-step formula; optional prefilter to \([s-k, s+k]\). This achieves \(O(n)\) time and is tight for comparison-based models over sorted input.}
\ASSUMPTIONS{Positions are sorted and unique; amounts are nonnegative; the path covering a contiguous interval minimizes detours.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Pre-restrict to positions within \([s-k, s+k]\).
\item Maintain window \([L,R]\) and running sum.
\item While the window cost exceeds \(k\), advance \(L\). Track the maximum sum seen.
\end{algosteps}
\OPTIMALITY{Any feasible harvest set must be contiguous on the sorted line. For each contiguous segment, the minimal steps depend only on endpoints and \(s\). Two-pointer expansion and contraction enumerate all feasible maximal segments exactly once, giving an optimal harvest sum in linear time.}
\COMPLEXITY{Let \(m\) be the count of positions within \([s-k,s+k]\). Each index moves at most once into and out of the window.}
\[
\begin{aligned}
T(n) &= O(m) \subseteq O(n),\\
S(n) &= O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import bisect

class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        if not fruits:
            return 0

        pos = [p for p, _ in fruits]
        amt = [a for _, a in fruits]

        # Keep only potentially reachable positions
        lo = bisect.bisect_left(pos, startPos - k)
        hi = bisect.bisect_right(pos, startPos + k)
        pos = pos[lo:hi]
        amt = amt[lo:hi]
        n = len(pos)
        if n == 0:
            return 0

        def steps(Lp: int, Rp: int, s: int) -> int:
            if s <= Lp:
                return Rp - s
            if s >= Rp:
                return s - Lp
            return (Rp - Lp) + min(s - Lp, Rp - s)

        ans = 0
        L = 0
        cur = 0
        for R in range(n):
            cur += amt[R]
            while L <= R and steps(pos[L], pos[R], startPos) > k:
                cur -= amt[L]
                L += 1
            if cur > ans:
                ans = cur
        return ans

# Exactly 3 asserts (I/O mini-tests)
if __name__ == "__main__":
    sol = Solution()
    assert sol.maxTotalFruits([[2,8],[6,3],[8,6]], 5, 4) == 9
    assert sol.maxTotalFruits([[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], 5, 4) == 14
    assert sol.maxTotalFruits([[0,3],[6,4],[8,5]], 3, 2) == 0
\end{minted}
\VALIDATION{Three canonical examples pass.}
\RESULT{Maximum harvestable total fruits within the step budget, independent of the exact walking path order; tie-breaking is irrelevant since the returned value is a scalar maximum.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for given examples; boundary tests for \(\,k=0\), only-one-side reachable; dense vs. sparse positions; start inside a large gap.}
\LINE{CROSS-CHECKS}{Compare Baseline (A) vs Improved (B) vs Final (C) on small crafted cases; both must agree on outputs.}
\LINE{EDGE-CASE GENERATOR}{Enumerate tiny arrays of positions near \(\,s\) with small \(\,k\) to exhaustively compare methods deterministically.}
\begin{minted}{python}
from typing import List, Tuple
import bisect

def ref_baseline(fruits: List[List[int]], startPos: int, k: int) -> int:
    # Baseline from Approach A
    if not fruits or k == 0:
        if not fruits:
            return 0
        pos = [p for p, _ in fruits]
        i = bisect.bisect_left(pos, startPos)
        return fruits[i][1] if i < len(fruits) and pos[i] == startPos else 0
    pos = [p for p, _ in fruits]
    amt = [a for _, a in fruits]
    n = len(pos)
    pref = [0]*(n+1)
    for i in range(n):
        pref[i+1] = pref[i] + amt[i]
    def rsum(i,j): return 0 if i>j else pref[min(j,n-1)+1]-pref[max(i,0)]
    ans = 0
    left_limit = bisect.bisect_left(pos, startPos - k)
    right_limit = bisect.bisect_right(pos, startPos + k) - 1
    last_le_s = bisect.bisect_right(pos, startPos) - 1
    if last_le_s >= 0:
        for i in range(max(left_limit,0), min(last_le_s,n-1)+1):
            left_cost = 2*(startPos - pos[i])
            if left_cost > k: continue
            rem = k - left_cost
            rmax = startPos + rem
            j = bisect.bisect_right(pos, rmax) - 1
            j = min(j, right_limit)
            if j >= i:
                ans = max(ans, rsum(i,j))
    first_ge_s = bisect.bisect_left(pos, startPos)
    if first_ge_s < n:
        for j in range(max(first_ge_s,0), min(right_limit,n-1)+1):
            right_cost = 2*(pos[j] - startPos)
            if right_cost > k: continue
            rem = k - right_cost
            lmin = startPos - rem
            i = bisect.bisect_left(pos, lmin)
            i = max(i, left_limit)
            if i <= j:
                ans = max(ans, rsum(i,j))
    return ans

def ref_final(fruits: List[List[int]], startPos: int, k: int) -> int:
    # Final sliding window
    if not fruits:
        return 0
    pos = [p for p,_ in fruits]
    amt = [a for _,a in fruits]
    lo = bisect.bisect_left(pos, startPos - k)
    hi = bisect.bisect_right(pos, startPos + k)
    pos = pos[lo:hi]
    amt = amt[lo:hi]
    if not pos:
        return 0
    def steps(Lp: int, Rp: int, s: int) -> int:
        if s <= Lp: return Rp - s
        if s >= Rp: return s - Lp
        return (Rp - Lp) + min(s - Lp, Rp - s)
    ans = 0
    L = 0
    cur = 0
    for R in range(len(pos)):
        cur += amt[R]
        while L <= R and steps(pos[L], pos[R], startPos) > k:
            cur -= amt[L]
            L += 1
        if cur > ans: ans = cur
    return ans

def run_cross_checks():
    # Deterministic crafted cases
    cases = [
        ([[2,8],[6,3],[8,6]], 5, 4),
        ([[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], 5, 4),
        ([[0,3],[6,4],[8,5]], 3, 2),
        ([[5,7]], 5, 0),
        ([[1,5],[3,6],[10,4]], 0, 3),
        ([[1,2],[2,3],[3,4],[10,5],[11,6]], 2, 2),
        ([[100,5],[101,7],[102,1]], 98, 3),
    ]
    for fruits, s, k in cases:
        a = ref_baseline(fruits, s, k)
        c = ref_final(fruits, s, k)
        assert a == c, (fruits, s, k, a, c)
    return True

if __name__ == "__main__":
    assert run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import bisect

class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        if not fruits:
            return 0

        pos = [p for p, _ in fruits]
        amt = [a for _, a in fruits]

        # Restrict to potentially reachable positions
        lo = bisect.bisect_left(pos, startPos - k)
        hi = bisect.bisect_right(pos, startPos + k)
        pos = pos[lo:hi]
        amt = amt[lo:hi]
        n = len(pos)
        if n == 0:
            return 0

        def steps(Lp: int, Rp: int, s: int) -> int:
            if s <= Lp:
                return Rp - s
            if s >= Rp:
                return s - Lp
            return (Rp - Lp) + min(s - Lp, Rp - s)

        ans = 0
        L = 0
        cur = 0
        for R in range(n):
            cur += amt[R]
            while L <= R and steps(pos[L], pos[R], startPos) > k:
                cur -= amt[L]
                L += 1
            if cur > ans:
                ans = cur
        return ans

if __name__ == "__main__":
    sol = Solution()
    assert sol.maxTotalFruits([[2,8],[6,3],[8,6]], 5, 4) == 9
    assert sol.maxTotalFruits([[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], 5, 4) == 14
    assert sol.maxTotalFruits([[0,3],[6,4],[8,5]], 3, 2) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Find the maximum-sum contiguous interval of fruit positions whose minimal traversal steps from \(\,s\) do not exceed \(\,k\).}
\WHY{A classic two-pointer interval maximization with a piecewise movement-cost constraint; tests interval reasoning and sliding window skills.}
\CHECKLIST{
\begin{bullets}
\item Extract sorted positions and amounts.
\item Optionally prefilter to \([s-k, s+k]\).
\item Sliding window with steps\((p_L,p_R;s)\) feasibility.
\item Maintain running sum and update answer.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item \(\,k=0\) and fruit at start only.
\item Start outside all fruit coordinates.
\item All fruits on one side.
\item Dense fruits around \(s\) vs. sparse far away.
\item Exact boundary reach \(p = s \pm k\).
\item Single fruit entry; very large coordinates but small \(k\).
\item Multiple fruits at equal distance from \(s\) on both sides.
\item No fruits within \([s-k, s+k]\).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Using round-trip cost when start is outside \([L,R]\) (should be one-way).
\item Off-by-one in binary searches; mixing \(\,\le\) and \(<\).
\item Forgetting to shrink \(L\) until feasible.
\item Not guarding empty window before reading \(p_L\).
\item Overflow not an issue in Python, but in other languages ensure safe sums.
\item Assuming \(\,s\) coincides with a fruit position.
\item Failing to restrict to \([s-k, s+k]\) can still pass but costs time.
\item Using negative remaining budget without checking.
\end{bullets}
}
\FAILMODES{Naive enumeration of all intervals is \(O(n^2)\) and times out at \(10^5\). Using a wrong step-cost formula misses cases where \(s\) lies outside the interval. The sliding window with the correct piecewise cost avoids these.}
\ELI{You can only cover a continuous stretch of positions within your step budget. Slide a window over the sorted positions, keeping it only as large as your step limit allows, and track the best sum you see.}
\NotePages{3}

\end{document}