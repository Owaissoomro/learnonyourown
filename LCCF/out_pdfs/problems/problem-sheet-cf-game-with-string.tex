% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Game with String}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/930/B}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Vasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string $s$, consisting of small English letters, and uniformly at random chooses an integer $k$ from a segment $[0,\lvert s\rvert-1]$. He tells Vasya this string $s$, and then shifts it $k$ letters to the left, i.e., creates a new string
\begin{BreakableEquation*}
t \;=\; s_{k+1}\,s_{k+2}\,\ldots\,s_{n}\,s_{1}\,s_{2}\,\ldots\,s_{k},
\end{BreakableEquation*}
where $n=\lvert s\rvert$ and indices are cyclic. Vasya does not know the integer $k$ nor the string $t$, but he wants to guess the integer $k$. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose.

Vasya understands that he cannot guarantee that he will win, but he wants to know the probability of winning if he plays optimally. He wants you to compute this probability.

Note that Vasya wants to know the value of $k$ uniquely; it means that if there are at least two cyclic shifts of $s$ that fit the information Vasya knows, Vasya loses. Of course, at any moment of the game Vasya wants to maximize the probability of his win.

Input:
The only string contains the string $s$ of length $\ell$ ($3 \le \ell \le 5000$), consisting of small English letters only.

Output:
Print the only number — the answer for the problem. Your answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.

Formally, let your answer be $a$, and the jury's answer be $b$. Your answer is considered correct if $\dfrac{\lvert a-b\rvert}{\max(1,\lvert b\rvert)} \le 10^{-6}$.

Note:
In the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely.

In the second example if the first opened letter of $t$ is ``t'' or ``c'', then Vasya cannot guess the shift by opening only one other letter. On the other hand, if the first letter is ``i'' or ``a'', then he can open the fourth letter and determine the shift uniquely.}
\BREAKDOWN{Kolya picks a uniform cyclic shift. Vasya first learns $t_1$, then chooses one position to reveal. For a given first letter $c$, Vasya should choose an offset that maximizes how often the revealed letter uniquely identifies the original position among all positions of $c$ in $s$. The answer is the fraction of shifts for which such unique identification happens, averaged over all first letters induced by $k$.}
\ELI{For each possible first letter, peek at the position that most often gives a unique second letter so you can pinpoint the exact shift; average these wins over all shifts.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single string $s$ of length $\ell$ with $3 \le \ell \le 5000$, lowercase English letters only.}
\OUTPUTS{A single real number: the optimal win probability. Any answer within absolute or relative error $\le 10^{-6}$ is accepted.}
\SAMPLES{Examples (informal):
\begin{bullets}
\item Input: ``abc''; Output: $1$. Any first letter determines a unique position immediately after revealing one more letter.
\item Input: ``abcabc''; Output: $0$. No single extra reveal can distinguish between two identical blocks.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s \in \Sigma^n$, $\Sigma=\{a,\ldots,z\}$, $n=\lvert s\rvert$. Kolya samples $k \sim \text{Unif}\{0,\ldots,n-1\}$ and sets $t_i = s_{k+i}$ (indices modulo $n$ with values in $\{1,\ldots,n\}$). Vasya observes $t_1$ and then chooses one offset $r \in \{2,\ldots,n\}$ to reveal $t_r$. He wins iff the pair $(t_1,t_r)$ corresponds to exactly one shift $k$.}
\varmapStart
\var{n}{length of $s$}
\var{c}{a letter in $\Sigma$}
\var{I_c}{indices $i \in \{1,\ldots,n\}$ with $s_i=c$}
\var{r}{revealed position in $t$ (offset), equivalently a shift $+r-1$ in $s$}
\var{U_c(r)}{number of letters appearing exactly once among $\{s_{i+r-1} : i \in I_c\}$ modulo $n$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{Optimal win probability } P^* \;=\; \frac{1}{n} \sum_{c \in \Sigma} \max_{1 \le \delta \le n-1} U_c(1+\delta),
\end{BreakableEquation*}
where $U_c(1+\delta)$ counts how many $k$ with $t_1=c$ yield a unique second letter at offset $r=1+\delta$, hence uniquely identify $k$. Equivalently, for fixed $c$ and $\delta$, build a multiset $\{ s_{i+\delta} : i \in I_c \}$ (indices modulo $n$); $U_c$ is the number of letters with multiplicity $1$ in that multiset.}
\ASSUMPTIONS{Indices are treated cyclically modulo $n$. Vasya chooses $r$ after seeing $t_1$ but before seeing $t$. Ties (multiple consistent shifts) mean a loss.}
\INVARIANTS{
\begin{bullets}
\item For fixed $c$ and offset, shifts with the same revealed second letter are indistinguishable.
\item The optimal choice for a given $c$ is the offset maximizing the count of singleton letters in its multiset.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate all choices: for each possible first letter $c$ and each offset $r$, enumerate all candidate positions of $c$ in $s$, map them to their revealed second letters, and count singleton second letters.}
\ASSUMPTIONS{Direct counting with no preprocessing; time $O(n^3)$ in the worst case.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each letter $c \in \Sigma$, collect indices $I_c = \{i : s_i=c\}$.
\item For each offset $\delta \in \{1,\ldots,n-1\}$, form $L=\{s_{i+\delta}: i\in I_c\}$ and count how many letters in $L$ occur exactly once; keep the best over $\delta$.
\item Sum the best counts over all $c$ and divide by $n$.
\end{algosteps}
\COMPLEXITY{Let $n=\lvert s\rvert$ and let $m_c=\lvert I_c\rvert$. The baseline re-scans $m_c$ items for each of $n$ offsets for each $c$, and additionally re-counts multiplicities naively over $\Sigma$:
\[
\begin{aligned}
T(n) &= \sum_{c} \sum_{\delta=1}^{n-1} \bigl(O(m_c) + O(\lvert\Sigma\rvert)\bigr) \\
     &= O\!\left(n \sum_c m_c\right) + O(n\lvert\Sigma\rvert^2) \\
     &= O(n^2) \text{ in practice; naive variants may degrade toward } O(n^3).
\end{aligned}
\]
Space $S(n)=O(1)$ beyond input.}
\CORRECTNESS{By construction, for fixed $c$ and offset, the multiset of second letters partitions candidate shifts into indistinguishable groups; only groups of size $1$ are winnable. Maximizing singletons per $c$ is optimal; averaging over $k$ equates to dividing by $n$.}
\EDGECASES{All letters equal (probability $0$); all letters distinct (probability $1$); periodic strings with repeated blocks (often $0$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import List

def read_input() -> str:
    data = sys.stdin.read().strip().split()
    return data[0] if data else ""

def solve_case(s: str) -> float:
    n = len(s)
    # Collect positions per letter
    pos = [[] for _ in range(26)]
    for i, ch in enumerate(s):
        pos[ord(ch) - 97].append(i)
    total = 0
    for c in range(26):
        Ic = pos[c]
        if not Ic:
            continue
        best = 0
        for d in range(1, n):  # offset in s relative to the first letter position
            # Count multiplicities of revealed second letters
            cnt = [0] * 26
            for i in Ic:
                ch = s[(i + d) % n]
                cnt[ord(ch) - 97] += 1
            singles = sum(1 for x in cnt if x == 1)
            if singles > best:
                best = singles
        total += best
    return total / len(s) if s else 0.0

def solve_all() -> None:
    s = read_input()
    if not s:
        return
    ans = solve_case(s)
    # Print with sufficient precision
    print("{:.12f}".format(ans))

def _approx(a: float, b: float, tol: float = 1e-9) -> bool:
    return abs(a - b) <= tol * max(1.0, abs(b))

def _tests() -> None:
    assert _approx(solve_case("abc"), 1.0)
    assert _approx(solve_case("aaaaa"), 0.0)
    assert _approx(solve_case("abcabc"), 0.0)
    assert _approx(solve_case("abca"), 1.0)
    assert _approx(solve_case("abab"), 0.0)

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\VALIDATION{The asserts cover: all distinct letters (win always), all same letters (never win), two identical blocks (never win), a crafted case with unique determination after one reveal, and a 2-periodic case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Counting by Letter Buckets}
\WHICHFORMULA{For each letter $c$, only positions $I_c$ matter. For each offset $\delta$, we only need a $26$-bucket histogram of $\{s_{i+\delta} : i\in I_c\}$, so counting singletons is $O(26)$; scanning $I_c$ per $\delta$ costs $O(\lvert I_c\rvert)$. Summed over $c$, the total is $O(n^2)$.}
\ASSUMPTIONS{Skip letters absent from $s$. Use fixed-size arrays for histograms; 0-based indices with modulo arithmetic.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $I_c$ for all $c$.
\item For each present $c$ and each $\delta\in[1,n-1]$, build a $26$-array of counts of $s_{i+\delta}$ over $i\in I_c$.
\item Count singletons, keep the max per $c$, sum the maxima, divide by $n$.
\end{algosteps}
\COMPLEXITY{The inner scan over $I_c$ happens $n-1$ times per $c$. Summing $n\cdot \lvert I_c\rvert$ over $c$ gives $O(n^2)$. Histogram scan is $O(26)$ per offset, negligible.}
\[
\begin{aligned}
T(n) &= \sum_{c:\,I_c\neq\emptyset}\sum_{\delta=1}^{n-1} \left(O(\lvert I_c\rvert)+O(26)\right) \;=\; O(n^2), \\
S(n) &= O(26).
\end{aligned}
\]
\CORRECTNESS{Same reasoning as baseline: singleton second letters correspond bijectively to uniquely identifiable shifts for that $c$ at the chosen offset. Maximizing singletons per $c$ is optimal; linearity over uniform $k$ yields the average.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input() -> str:
    data = sys.stdin.read().strip().split()
    return data[0] if data else ""

def solve_case(s: str) -> float:
    n = len(s)
    if n == 0:
        return 0.0
    pos = [[] for _ in range(26)]
    for i, ch in enumerate(s):
        pos[ord(ch) - 97].append(i)
    total = 0
    for c in range(26):
        Ic = pos[c]
        m = len(Ic)
        if m == 0:
            continue
        best = 0
        for d in range(1, n):
            cnt = [0] * 26
            for i in Ic:
                ch = s[(i + d) % n]
                cnt[ord(ch) - 97] += 1
            singles = 0
            for a in range(26):
                if cnt[a] == 1:
                    singles += 1
            if singles > best:
                best = singles
        total += best
    return total / n

def solve_all() -> None:
    s = read_input()
    if not s:
        return
    print("{:.12f}".format(solve_case(s)))

def _approx(a: float, b: float, tol: float = 1e-9) -> bool:
    return abs(a - b) <= tol * max(1.0, abs(b))

def _tests() -> None:
    assert _approx(solve_case("abc"), 1.0)
    assert _approx(solve_case("aaaaa"), 0.0)
    assert _approx(solve_case("abcabc"), 0.0)

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\VALIDATION{Edge checks: all distinct; all equal; two repeated blocks.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Bucketed Singleton Maximization per First Letter}
\WHICHFORMULA{The provably optimal strategy is: for each observed first letter $c$, choose the offset $\delta$ that maximizes the number of singleton letters in $\{s_{i+\delta}: i\in I_c\}$. This yields the maximum number of uniquely identifiable shifts for that $c$.}
\ASSUMPTIONS{Uniform $k$ and the ability to adapt $r$ to the observed first letter $c$. Alphabet size is constant $26$, enabling $O(n^2)$ time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $I_c$ for all letters.
\item For each $c$ and $\delta\in[1,n-1]$, histogram $\{s_{i+\delta}: i\in I_c\}$ and count singletons; record the max.
\item Sum these maxima over $c$ and divide by $n$ to get the probability.
\end{algosteps}
\OPTIMALITY{Given $t_1=c$, any strategy that picks an offset $r$ induces a partition of candidate shifts by the revealed $t_r$. The number of uniquely identified shifts equals the number of singleton classes. Picking the offset that maximizes this count is optimal. Averaging over uniformly random $k$ yields the exact probability. No method can beat this per-letter maximum, hence global optimality.}
\COMPLEXITY{$O(n^2)$ time, $O(26)$ extra space.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \quad S(n)=\Theta(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input() -> str:
    data = sys.stdin.read().strip().split()
    return data[0] if data else ""

def solve_case(s: str) -> float:
    n = len(s)
    if n == 0:
        return 0.0
    pos = [[] for _ in range(26)]
    for i, ch in enumerate(s):
        pos[ord(ch) - 97].append(i)
    total = 0
    for c in range(26):
        Ic = pos[c]
        if not Ic:
            continue
        best = 0
        for d in range(1, n):
            cnt = [0] * 26
            for i in Ic:
                cnt[ord(s[(i + d) % n]) - 97] += 1
            singles = 0
            for a in range(26):
                if cnt[a] == 1:
                    singles += 1
            if singles > best:
                best = singles
        total += best
    return total / n

def solve_all() -> None:
    s = read_input()
    if not s:
        return
    ans = solve_case(s)
    print("{:.12f}".format(ans))

def _approx(a: float, b: float, tol: float = 1e-9) -> bool:
    return abs(a - b) <= tol * max(1.0, abs(b))

def _mini_tests() -> None:
    assert _approx(solve_case("abc"), 1.0)
    assert _approx(solve_case("aaaaa"), 0.0)
    assert _approx(solve_case("abcabc"), 0.0)

if __name__ == "__main__":
    _mini_tests()
    solve_all()
\end{minted}
\VALIDATION{Exactly three asserts: ``abc'' $\to 1.0$; ``aaaaa'' $\to 0.0$; ``abcabc'' $\to 0.0$.}
\RESULT{Print the optimal win probability as a real number.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on canonical patterns: all unique; all identical; repeated blocks; mixed cases like ``abca'' where the best offset yields full identification. Numerical comparison uses relative tolerance.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (baseline) and Approach C (final) on small crafted strings to ensure they match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate periodic strings ($xyxy\ldots$), constant strings, and random strings to probe extremes of 0 and 1 probabilities and intermediate cases.}
\begin{minted}{python}
import random

def gen_constant(n: int, ch: str = 'a') -> str:
    return ch * n

def gen_periodic(block: str, reps: int) -> str:
    return block * reps

def gen_random(n: int, seed: int = 0) -> str:
    rng = random.Random(seed)
    return "".join(chr(97 + rng.randrange(26)) for _ in range(n))
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input() -> str:
    data = sys.stdin.read().strip().split()
    return data[0] if data else ""

def solve_case(s: str) -> float:
    n = len(s)
    if n == 0:
        return 0.0
    pos = [[] for _ in range(26)]
    for i, ch in enumerate(s):
        pos[ord(ch) - 97].append(i)
    total = 0
    for c in range(26):
        Ic = pos[c]
        if not Ic:
            continue
        best = 0
        for d in range(1, n):
            cnt = [0] * 26
            for i in Ic:
                cnt[ord(s[(i + d) % n]) - 97] += 1
            singles = 0
            for a in range(26):
                if cnt[a] == 1:
                    singles += 1
            if singles > best:
                best = singles
        total += best
    return total / n

def solve_all() -> None:
    s = read_input()
    if not s:
        return
    print("{:.12f}".format(solve_case(s)))

def _approx(a: float, b: float, tol: float = 1e-9) -> bool:
    return abs(a - b) <= tol * max(1.0, abs(b))

def _tests() -> None:
    assert _approx(solve_case("abc"), 1.0)
    assert _approx(solve_case("aaaaa"), 0.0)
    assert _approx(solve_case("abcabc"), 0.0)
    assert _approx(solve_case("abca"), 1.0)
    assert _approx(solve_case("abab"), 0.0)

if __name__ == "__main__":
    _tests()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize, for each first letter, the number of uniquely distinguishable shifts by choosing the best second reveal offset; average over all shifts.}
\WHY{This tests reasoning about cyclic strings, optimal decision after partial observation, and turning strategy into frequency counting.}
\CHECKLIST{
\begin{bullets}
\item Build position lists per letter.
\item For each letter present, iterate offsets $1\ldots n-1$.
\item Count second-letter frequencies; tally singletons.
\item Sum maxima; divide by $n$; print with precision.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All characters identical $\Rightarrow$ probability $0$.
\item All characters distinct $\Rightarrow$ probability $1$.
\item Repeated blocks like $xyxy\ldots$ often yield $0$.
\item $n=3$ smallest allowed.
\item First letter occurring once in $s$ is always a win for that $k$.
\item Offsets $0$ or $n$ are not allowed as the second reveal (must be a different position).
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off-by-one in cyclic indices: use modulo $n$ carefully.
\item Forgetting to skip letters absent from $s$.
\item Dividing by count of occurrences instead of $n$; the average is over shifts.
\item Using floating printing with too few digits; use $\ge 10$ decimals.
\item Inefficient $O(n^3)$ loops may TLE; ensure $O(n^2)$.
\item Miscounting singletons by counting positions instead of letter buckets.
\end{bullets}}
\FAILMODES{Naive strategies that pick a fixed offset regardless of first letter can underperform. String hashing is unnecessary and risks hash collisions.}
\ELI{Group candidate shifts by what the second revealed letter would be. Pick the reveal that splits candidates most finely. Count how often this yields a unique candidate for each possible first letter, and average over all shifts.}
\NotePages{3}

\end{document}