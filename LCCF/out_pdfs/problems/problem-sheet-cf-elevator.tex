% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Elevator}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/983/C}}
\LINE{DIFFICULTY / RATING}{2400}
\STATEMENT{You work in a big office. It is a 9 floor building with an elevator that can accommodate up to 4 people. It is your responsibility to manage this elevator.

Today you are late, so there are queues on some floors already. For each person you know the floor where he currently is and the floor he wants to reach. Also, you know the order in which people came to the elevator.

According to the company's rules, if an employee comes to the elevator earlier than another one, he has to enter the elevator earlier too (even if these employees stay on different floors). Note that the employees are allowed to leave the elevator in arbitrary order.

The elevator has two commands:
\begin{itemize}
\item Go up or down one floor. The movement takes 1 second.
\item Open the doors on the current floor. During this operation all the employees who have reached their destination get out of the elevator. Then all the employees on the floor get in the elevator in the order they are queued up while it does not contradict the company's rules and there is enough space in the elevator. Each employee spends 1 second to get inside and outside the elevator.
\end{itemize}

Initially the elevator is empty and is located on the floor 1.

You are interested what is the minimum possible time you need to spend to deliver all the employees to their destination. It is not necessary to return the elevator to the floor 1.

Input:
The first line contains an integer $n$ ($1 \le n \le 2000$) — the number of employees.

The $i$-th of the next $n$ lines contains two integers $a_i$ and $b_i$ ($1 \le a_i, b_i \le 9, a_i \ne b_i$) — the floor on which an employee initially is, and the floor he wants to reach.

The employees are given in the order they came to the elevator.

Output:
Print a single integer — the minimal possible time in seconds.

Note:
Explanation for the first sample: $t = 0$, $t = 2$, $t = 3$, $t = 5$, $t = 6$, $t = 7$, $t = 9$, $t = 10$.}
\BREAKDOWN{We must schedule elevator movements and openings to minimize total time, respecting: global entry order (employee $i$ must enter before $j$ if $i<j$), capacity 4, arbitrary exit order, 1 second per floor movement, and 1 second per person for entering/exiting. The building has 9 floors, so we can exploit the small metric space and small capacity.}
\ELI{Always board people in global arrival order at their floors; between pickups, optimally drop some onboard riders to free space, taking shortest paths on a line to their destinations.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
\begin{itemize}
\item $n$ — integer, $1 \le n \le 2000$.
\item $n$ lines: $a_i$, $b_i$ — integers in $[1,9]$, $a_i \ne b_i$.
\end{itemize}}
\OUTPUTS{One integer: minimal total time in seconds to deliver all employees to their destinations (no need to return to floor 1).}
\SAMPLES{Examples consistent with format:
\begin{itemize}
\item $n=1$; $(a_1,b_1)=(1,9)$ $\Rightarrow$ answer $10$ (board at 1: 1 s; move 8 floors: 8 s; exit at 9: 1 s).
\item $n=2$; $(a_1,b_1)=(1,2)$, $(a_2,b_2)=(1,2)$ $\Rightarrow$ answer $5$ (board both at 1: 2 s; move to 2: 1 s; exit both: 2 s).
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{We consider discrete time with costs for moves and for batched open operations. Let the next-to-board index be $p$ (initially $1$), elevator floor $f\in\{1,\ldots,9\}$, and multiset $M$ of destinations of currently onboard passengers (capacity $\le 4$). At an opening on floor $g$, all $g$-destinations in $M$ exit, then a maximal prefix of employees among indices $p,p+1,\ldots$ whose $a_i=g$ enter subject to capacity. The decision is which subset of current onboard to drop before the next opening at $g$ and how to route along the line metric.}
\varmapStart
\var{n}{number of employees}
\var{a_i}{start floor of employee $i$}
\var{b_i}{destination floor of employee $i$}
\var{p}{next unboarded employee index}
\var{f}{current elevator floor}
\var{M}{multiset of onboard destination floors (size $\le 4$)}
\var{g}{target floor for next boarding, $g=a_p$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Boarding rule: }&\text{At floor }g, \text{ let }x=\#\{m\in M:m=g\}. \text{ After $x$ exits, free }=4-(|M|-x).\\
&\text{Let }r=\max\{t\ge 0:\forall j\in[p,p+t-1],~a_j=g\}.\\
&B=\min(\text{free},~r). \text{ Then } p\gets p+B,\quad M\gets (M\setminus\{g\text{-items}\})\cup \{b_p,\ldots,b_{p+B-1}\}.\\
\text{Movement on line: }& \text{To drop a subset }R\subseteq M\setminus\{g\text{-items}\}\text{ before $g$, with floor set }F=\{m: m\in R\},\\
&\text{distance }d(f\to g~|~F)=\begin{cases}
|f-g|,&F=\varnothing,\\
(R_F-L_F)+\min(|f-L_F|+|g-R_F|,~|f-R_F|+|g-L_F|),&F\ne\varnothing,
\end{cases}\\
&\text{where }L_F=\min F,\;R_F=\max F.
\end{aligned}
\]
}
\ASSUMPTIONS{Global entry order enforces that nobody can enter before an earlier-index employee, so at any open on $g$, only the next block of $a_i=g$ can enter; exits are allowed in arbitrary order. No benefit to open with zero exits/entries.}
\INVARIANTS{
\begin{itemize}
\item $|M|\le 4$ always (capacity).
\item $p$ strictly increases on each boarding step ($B\ge 1$).
\item Exiting at a floor $g$ is counted before boarding at $g$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Explicitly simulate all possible sequences of moves and opens by DFS with pruning, enforcing the global entry order and capacity.}
\ASSUMPTIONS{Small $n$ for tractability; use memoization on state $(p,f,M)$ to avoid recomputation.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item State is $(p,f,M)$; if $p=n$ finish by delivering all $M$ minimally (visit remaining destinations, count exits).
\item Otherwise, let $g=a_p$. Enumerate all subsets $R\subseteq M\setminus\{g\}$ such that after dropping $R$ and exiting $g$ at $g$, capacity allows boarding at least one.
\item For each $R$, compute minimal movement on the line to drop $R$ before $g$, then open at $g$ to exit $g$-destinations and board the forced block; recurse.
\end{algosteps}
\COMPLEXITY{Exponential in worst case (branching over subsets and layers). With memoization, states are $(p,f,M)$, where $|M|\le 4$ and $f\in[1,9]$, but still too slow for $n=2000$.}
\[
\begin{aligned}
T(n) &\approx \sum_{p=0}^{n-1} \#\text{states at layer }p \cdot O(2^{\le 4}) \\
     &\text{Intractable for large }n\text{; good only as correctness reference on tiny inputs.}
\end{aligned}
\]
\CORRECTNESS{Covers all admissible schedules by considering all subsets of pre-drops and the forced boarding at each $g$. Memoization ensures optimal substructure by state.}
\EDGECASES{No one onboard; many with same $a_i$; needing to revisit $g$ multiple times; floors at extremes 1 or 9.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from functools import lru_cache

def solve_case_bruteforce(a, b):
    n = len(a)
    floors = list(range(1, 10))

    # Precompute run lengths for each floor f
    runlen = [[0]*10 for _ in range(n+1)]
    for f in range(1, 10):
        runlen[n][f] = 0
        for i in range(n-1, -1, -1):
            runlen[i][f] = (runlen[i+1][f] + 1) if a[i] == f else 0

    def dist_line(s, g, Fset):
        if not Fset:
            return abs(s - g)
        L = min(Fset)
        R = max(Fset)
        return (R - L) + min(abs(s - L) + abs(g - R), abs(s - R) + abs(g - L))

    def finish_cost(f, M):
        if not M:
            return 0
        Fset = set(M)
        L, R = min(Fset), max(Fset)
        move = (R - L) + min(abs(f - L), abs(f - R))
        return move + len(M)

    @lru_cache(maxsize=None)
    def dp(p, f, Mtuple):
        M = list(Mtuple)
        k = len(M)
        if p == n:
            return finish_cost(f, M)
        g = a[p]
        # Count how many onboard have destination g
        x = sum(1 for m in M if m == g)
        # Indices of non-g items
        non_g_idx = [i for i, m in enumerate(M) if m != g]
        best = 10**18
        total_masks = 1 << len(non_g_idx)
        for mask in range(total_masks):
            removed_idx = set()
            for j in range(len(non_g_idx)):
                if (mask >> j) & 1:
                    removed_idx.add(non_g_idx[j])
            removed_cnt = len(removed_idx)
            remK = k - removed_cnt - x
            if remK > 3:
                continue
            # Movement to drop selected R
            Fset = set(M[i] for i in removed_idx)
            move = dist_line(f, g, Fset)
            # Exit before + at g
            exit_before = removed_cnt
            exit_at_g = x
            free = 4 - remK
            B = min(free, runlen[p][g])
            assert B >= 1
            # Build new M: keep those not removed and not equal to g
            remain = [M[i] for i in range(k) if i not in removed_idx and M[i] != g]
            # Add new boarded passengers' destinations
            for i in range(p, p + B):
                remain.append(b[i])
            remain.sort()
            cost = move + exit_before + exit_at_g + B + dp(p + B, g, tuple(remain))
            if cost < best:
                best = cost
        return best

    return dp(0, 1, tuple())

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = []
    b = []
    for _ in range(n):
        ai = int(next(it)); bi = int(next(it))
        a.append(ai); b.append(bi)
    return n, a, b

def main():
    pack = read_input()
    if pack is None:
        return
    n, a, b = pack
    ans = solve_case_bruteforce(a, b) if n <= 10 else None
    # For larger n, this baseline is too slow; do nothing here.
    if ans is not None:
        print(ans)

if __name__ == "__main__":
    # Tiny sanity tests
    assert solve_case_bruteforce([1], [9]) == 10
    assert solve_case_bruteforce([1,1], [2,2]) == 5
    # A small mixed case
    assert solve_case_bruteforce([1,2], [2,1]) == 6  # board at 1, go 1->2, drop1, board2, go 2->1, drop: 1+1+1+1+1+1=6
    main()
\end{minted}
\VALIDATION{Checked simple one- and two-person scenarios and a small mixed case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Dijkstra on Compact State Space}
\WHICHFORMULA{Treat each state $(p,f,M)$ as a node; transitions go to the next pickup floor $g=a_p$ with cost equal to minimal movement to drop some subset $R$ plus exit/entry times. Since all costs are nonnegative, use Dijkstra.}
\ASSUMPTIONS{Capacity $\le 4$ bounds $|M|$, and floors are only 9; this keeps branching (subsets of $M\setminus\{g\}$) small.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize priority queue with $(0, p=0, f=1, M=\emptyset)$.
\item Pop the best state; if $p=n$, add finishing cost and update global best.
\item Otherwise, set $g=a_p$ and relax all subset transitions $R\subseteq M\setminus\{g\}$ that allow boarding. Push resulting $(p+B, f'=g, M')$ with accumulated cost.
\item Stop when all popped distances exceed current best.
\end{algosteps}
\COMPLEXITY{State count $\approx 9 \times$ multisets of size $\le 4 \times (n+1)$; branching up to $2^4=16$. Dijkstra is workable in optimized C++; in Python may be borderline.}
\[
\begin{aligned}
T(n) &\approx O\big((\#\text{states}) \log(\#\text{states}) \cdot 16\big).
\end{aligned}
\]
\CORRECTNESS{The graph captures exactly all admissible schedules; edge costs add movement and open-operation person-times. Dijkstra yields minimal path cost.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys, heapq

def solve_case_dijkstra(a, b):
    n = len(a)
    # Precompute run lengths
    runlen = [[0]*10 for _ in range(n+1)]
    for f in range(1, 10):
        for i in range(n-1, -1, -1):
            runlen[i][f] = (runlen[i+1][f] + 1) if a[i] == f else 0

    def dist_line(s, g, Fset):
        if not Fset:
            return abs(s - g)
        L = min(Fset); R = max(Fset)
        return (R - L) + min(abs(s - L) + abs(g - R), abs(s - R) + abs(g - L))

    def finish_cost(f, M):
        if not M:
            return 0
        Fset = set(M)
        L, R = min(Fset), max(Fset)
        move = (R - L) + min(abs(f - L), abs(f - R))
        return move + len(M)

    INF = 10**18
    # Distances: dict keyed by (p, f, Mtuple)
    dist = {}
    pq = []
    start = (0, 1, tuple())
    dist[start] = 0
    heapq.heappush(pq, (0, 0, 1, ()))  # (cost, p, f, M)
    best_final = INF

    while pq:
        d, p, f, M = heapq.heappop(pq)
        if d != dist.get((p, f, M), INF):
            continue
        if d >= best_final:
            continue
        if p == n:
            best_final = min(best_final, d + finish_cost(f, list(M)))
            continue
        g = a[p]
        Mlist = list(M)
        k = len(Mlist)
        x = sum(1 for m in Mlist if m == g)
        non_g_idx = [i for i, m in enumerate(Mlist) if m != g]
        total_masks = 1 << len(non_g_idx)
        for mask in range(total_masks):
            removed_idx = set()
            for j in range(len(non_g_idx)):
                if (mask >> j) & 1:
                    removed_idx.add(non_g_idx[j])
            removed_cnt = len(removed_idx)
            remK = k - removed_cnt - x
            if remK > 3:
                continue
            Fset = set(Mlist[i] for i in removed_idx)
            move = dist_line(f, g, Fset)
            exit_before = removed_cnt
            exit_at_g = x
            free = 4 - remK
            B = min(free, runlen[p][g])
            if B <= 0:
                continue
            remain = [Mlist[i] for i in range(k) if i not in removed_idx and Mlist[i] != g]
            for i in range(p, p + B):
                remain.append(b[i])
            remain.sort()
            np = p + B
            nf = g
            nM = tuple(remain)
            nd = d + move + exit_before + exit_at_g + B
            key = (np, nf, nM)
            if nd < dist.get(key, INF):
                dist[key] = nd
                heapq.heappush(pq, (nd, np, nf, nM))

    return best_final

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = []
    b = []
    for _ in range(n):
        ai = int(next(it)); bi = int(next(it))
        a.append(ai); b.append(bi)
    return n, a, b

def main():
    pack = read_input()
    if pack is None:
        return
    n, a, b = pack
    print(solve_case_dijkstra(a, b))

if __name__ == "__main__":
    # Sanity tests (tiny)
    assert solve_case_dijkstra([1], [9]) == 10
    assert solve_case_dijkstra([1,1], [2,2]) == 5
    # Another small case
    assert solve_case_dijkstra([1,2,1], [2,1,2]) >= 0  # just runs
    main()
\end{minted}
\VALIDATION{Validated on simple scenarios; uses a priority queue to ensure minimality.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Layered DP with Line-Metric Routing}
\WHICHFORMULA{Exploit that each transition strictly increases $p$ (the next-to-board index). Do DP over layers $p=0,1,\ldots,n$. For each layer state $(f,M)$, transition to $p'=p+B$ at $g=a_p$ by optimally picking a subset $R\subseteq M\setminus\{g\}$ to drop before $g$, using the closed-form shortest distance on a line metric:
\[
d(f\to g~|~F)=
\begin{cases}
|f-g|, & F=\varnothing,\\
(R_F-L_F)+\min(|f-L_F|+|g-R_F|,~|f-R_F|+|g-L_F|), & F\ne\varnothing.
\end{cases}
\]
Finish at layer $p=n$ by visiting the remaining destinations of $M$ with cost $(R-L)+\min(|f-L|,|f-R|)+|M|$.}
\ASSUMPTIONS{Global entry order forces $g=a_p$; boarding is maximal forced block; capacity is enforced by requiring $|M\setminus R\setminus\{g\}|\le 3$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute run lengths $r[p][f]$ of consecutive $a$-floors starting at $p$ for all $f\in[1,9]$.
\item Initialize $\mathrm{dp}[0][(f=1,M=\emptyset)]=0$.
\item For $p=0$ to $n-1$, for each state $(f,M)$ in layer $p$, let $g=a_p$, count $x=\#\{m\in M:m=g\}$ and enumerate subsets $R\subseteq M\setminus\{g\}$.
\item For each $R$ with $|M|-|R|-x\le 3$, compute movement $d(f\to g|F)$ with $F=\{m:m\in R\}$, exits $|R|+x$, free $=4-(|M|-|R|-x)$, and $B=\min(\text{free},~r[p][g])$; update layer $p+B$ at $(f'=g, M')$ after dropping and boarding.
\item Answer is $\min$ over states in layer $n$ of $\mathrm{dp}[n][f,M] + \text{finish}(f,M)$.
\end{algosteps}
\OPTIMALITY{The DP graph is acyclic in $p$; transitions capture all admissible choices (which subset to drop before $g$). The line-metric closed form yields minimal movement between openings. Therefore the DP attains the global minimum.}
\COMPLEXITY{Each state explores up to $2^{\le 4}=16$ subsets. States per layer are bounded by $9\times$ multisets of size $\le 4$ reachable from prefixes of $b$, typically small in practice.
\begin{BreakableEquation*}
T(n)\approx O\Big(\sum_{p=0}^{n-1} \#\text{states}_p \cdot 16 \cdot \log K\Big),\quad S(n)=O\Big(\sum_p \#\text{states}_p\Big),
\end{BreakableEquation*}
where $\log K$ is negligible; in Python this runs comfortably for $n\le 2000$.}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def solve_case(a, b):
    n = len(a)
    # Precompute run lengths r[p][f] = consecutive a_i == f from p
    runlen = [[0]*10 for _ in range(n+1)]
    for f in range(1, 10):
        runlen[n][f] = 0
        for i in range(n-1, -1, -1):
            runlen[i][f] = (runlen[i+1][f] + 1) if a[i] == f else 0

    def dist_line(s, g, Fset):
        if not Fset:
            return abs(s - g)
        L = min(Fset); R = max(Fset)
        return (R - L) + min(abs(s - L) + abs(g - R), abs(s - R) + abs(g - L))

    def finish_cost(f, Mtuple):
        M = list(Mtuple)
        if not M:
            return 0
        Fset = set(M)
        L, R = min(Fset), max(Fset)
        move = (R - L) + min(abs(f - L), abs(f - R))
        return move + len(M)

    # dp_layers[p]: dict mapping (f, Mtuple) -> cost
    dp_layers = [dict() for _ in range(n+1)]
    dp_layers[0][(1, tuple())] = 0

    for p in range(n):
        layer = dp_layers[p]
        if not layer:
            continue
        g = a[p]
        for (f, Mtuple), cur in layer.items():
            Mlist = list(Mtuple)
            k = len(Mlist)
            # Count x = number destined to g
            x = 0
            non_g_idx = []
            for i, m in enumerate(Mlist):
                if m == g:
                    x += 1
                else:
                    non_g_idx.append(i)
            total_masks = 1 << len(non_g_idx)
            for mask in range(total_masks):
                # Compute removed indices and count
                removed_idx = []
                bit = mask
                j = 0
                while bit:
                    if bit & 1:
                        removed_idx.append(non_g_idx[j])
                    bit >>= 1
                    j += 1
                removed_cnt = len(removed_idx)
                remK = k - removed_cnt - x
                if remK > 3:
                    continue
                # Movement to drop selected R before g
                Fset = set(Mlist[i] for i in removed_idx)
                move = dist_line(f, g, Fset)
                exit_before = removed_cnt
                exit_at_g = x
                free = 4 - remK
                B = min(free, runlen[p][g])
                if B <= 0:
                    continue
                # Build new M after dropping R and g-dests, then adding new B
                removed_set = set(removed_idx)
                remain = [Mlist[i] for i in range(k) if (i not in removed_set) and (Mlist[i] != g)]
                for i in range(p, p + B):
                    remain.append(b[i])
                remain.sort()
                np = p + B
                nf = g
                nM = tuple(remain)
                nd = cur + move + exit_before + exit_at_g + B
                best = dp_layers[np].get((nf, nM))
                if best is None or nd < best:
                    dp_layers[np][(nf, nM)] = nd

    # Finalize at layer n
    ans = 10**18
    for (f, Mtuple), cur in dp_layers[n].items():
        total = cur + finish_cost(f, Mtuple)
        if total < ans:
            ans = total
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = []
    b = []
    for _ in range(n):
        ai = int(next(it)); bi = int(next(it))
        a.append(ai); b.append(bi)
    return n, a, b

def solve_all():
    pack = read_input()
    if pack is None:
        return
    n, a, b = pack
    print(solve_case(a, b))

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_case([1], [9]) == 10
    assert solve_case([1,1], [2,2]) == 5
    # A case requiring a detour to free space
    assert solve_case([1,1,1,1,1], [9,9,9,9,9]) == 34
    main()
\end{minted}
\VALIDATION{Three asserts cover trivial, batching on same floor, and capacity-constrained multi-trip scenarios.}
\RESULT{Minimal total time in seconds to deliver all employees; elevator may finish on any floor. Ties do not apply since only a numeric total is requested.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test core solver on:
\begin{itemize}
\item Single passenger; both directions (up/down).
\item Batch pickups from same floor.
\item Capacity overflow requiring intermediate deliveries.
\item Mixed starts/dests exercising arbitrary exit order.
\end{itemize}}
\LINE{CROSS-CHECKS}{Compare Baseline vs Improved vs Optimal on small $n\le 10$ random cases.}
\LINE{EDGE-CASE GENERATOR}{Create deterministic random seeds for $n\le 10$, floors $\in[1,9]$, avoiding $a_i=b_i$.}
\begin{minted}{python}
import random

def gen_small(seed=0, n=8):
    random.seed(seed)
    a = []
    b = []
    for _ in range(n):
        ai = random.randint(1, 9)
        bi = random.randint(1, 9)
        while bi == ai:
            bi = random.randint(1, 9)
        a.append(ai); b.append(bi)
    return a, b

def ref_solver_slow(a, b):
    # Use bruteforce for tiny n
    from functools import lru_cache
    n = len(a)
    runlen = [[0]*10 for _ in range(n+1)]
    for f in range(1, 10):
        for i in range(n-1, -1, -1):
            runlen[i][f] = (runlen[i+1][f] + 1) if a[i] == f else 0
    def dist_line(s, g, Fset):
        if not Fset:
            return abs(s - g)
        L = min(Fset); R = max(Fset)
        return (R - L) + min(abs(s - L) + abs(g - R), abs(s - R) + abs(g - L))
    def finish_cost(f, M):
        if not M:
            return 0
        Fset = set(M)
        L, R = min(Fset), max(Fset)
        move = (R - L) + min(abs(f - L), abs(f - R))
        return move + len(M)
    @lru_cache(maxsize=None)
    def dp(p, f, Mtuple):
        M = list(Mtuple)
        if p == n:
            return finish_cost(f, M)
        g = a[p]
        x = sum(1 for m in M if m == g)
        non_g_idx = [i for i, m in enumerate(M) if m != g]
        best = 10**18
        for mask in range(1 << len(non_g_idx)):
            rem_idx = set()
            for j in range(len(non_g_idx)):
                if (mask >> j) & 1:
                    rem_idx.add(non_g_idx[j])
            remK = len(M) - len(rem_idx) - x
            if remK > 3:
                continue
            Fset = set(M[i] for i in rem_idx)
            move = dist_line(f, g, Fset)
            free = 4 - remK
            B = min(free, runlen[p][g])
            if B <= 0:
                continue
            remain = [M[i] for i in range(len(M)) if i not in rem_idx and M[i] != g]
            for i in range(p, p+B):
                remain.append(b[i])
            remain.sort()
            cost = move + len(rem_idx) + x + B + dp(p+B, g, tuple(remain))
            best = min(best, cost)
        return best
    return dp(0, 1, tuple())

def main_test():
    # Cross-check a few seeds
    for seed in range(5):
        a, b = gen_small(seed, n=8)
        slow = ref_solver_slow(a, b)
        fast = solve_case(a, b)
        assert slow == fast, (seed, a, b, slow, fast)
    print("All tests passed.")

if __name__ == "__main__":
    main_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def solve_case(a, b):
    n = len(a)
    runlen = [[0]*10 for _ in range(n+1)]
    for f in range(1, 10):
        runlen[n][f] = 0
        for i in range(n-1, -1, -1):
            runlen[i][f] = (runlen[i+1][f] + 1) if a[i] == f else 0

    def dist_line(s, g, Fset):
        if not Fset:
            return abs(s - g)
        L = min(Fset); R = max(Fset)
        return (R - L) + min(abs(s - L) + abs(g - R), abs(s - R) + abs(g - L))

    def finish_cost(f, Mtuple):
        M = list(Mtuple)
        if not M:
            return 0
        Fset = set(M)
        L, R = min(Fset), max(Fset)
        move = (R - L) + min(abs(f - L), abs(f - R))
        return move + len(M)

    dp_layers = [dict() for _ in range(n+1)]
    dp_layers[0][(1, tuple())] = 0

    for p in range(n):
        layer = dp_layers[p]
        if not layer:
            continue
        g = a[p]
        for (f, Mtuple), cur in layer.items():
            Mlist = list(Mtuple)
            k = len(Mlist)
            x = 0
            non_g_idx = []
            for i, m in enumerate(Mlist):
                if m == g:
                    x += 1
                else:
                    non_g_idx.append(i)
            total_masks = 1 << len(non_g_idx)
            for mask in range(total_masks):
                removed_idx = []
                bit = mask
                j = 0
                while bit:
                    if bit & 1:
                        removed_idx.append(non_g_idx[j])
                    bit >>= 1
                    j += 1
                removed_cnt = len(removed_idx)
                remK = k - removed_cnt - x
                if remK > 3:
                    continue
                Fset = set(Mlist[i] for i in removed_idx)
                move = dist_line(f, g, Fset)
                free = 4 - remK
                B = min(free, runlen[p][g])
                if B <= 0:
                    continue
                removed_set = set(removed_idx)
                remain = [Mlist[i] for i in range(k) if (i not in removed_set) and (Mlist[i] != g)]
                for i in range(p, p + B):
                    remain.append(b[i])
                remain.sort()
                np = p + B
                nf = g
                nM = tuple(remain)
                nd = cur + move + removed_cnt + x + B
                best = dp_layers[np].get((nf, nM))
                if best is None or nd < best:
                    dp_layers[np][(nf, nM)] = nd

    ans = 10**18
    for (f, Mtuple), cur in dp_layers[n].items():
        total = cur + finish_cost(f, Mtuple)
        if total < ans:
            ans = total
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    a = []
    b = []
    for _ in range(n):
        ai = int(next(it)); bi = int(next(it))
        a.append(ai); b.append(bi)
    return n, a, b

def main():
    pack = read_input()
    if pack is None:
        return
    n, a, b = pack
    print(solve_case(a, b))

if __name__ == "__main__":
    # Self-checks
    assert solve_case([1], [9]) == 10
    assert solve_case([1,1], [2,2]) == 5
    assert solve_case([1,1,1,1,1], [9,9,9,9,9]) == 34
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{DP over $(p,f,M)$ where transitions go to $g=a_p$ after optimally dropping a subset of current riders using line-metric shortest routing.}
\WHY{Combines scheduling, capacity, and metric routing under a strict entry order — a classic interview stressor blending DP and geometry on a line.}
\CHECKLIST{
\begin{itemize}
\item Compute run lengths of $a_i$ per floor.
\item State: $(p,f,M)$ with $M$ a sorted tuple of destinations.
\item Enumerate subsets $R\subseteq M\setminus\{g\}$; enforce $|M|-|R|-x\le 3$.
\item Movement cost via interval formula on a line.
\item Exit costs: $|R|$ before, $x$ at $g$; boarding cost $B$.
\item Advance $p\gets p+B$, update $(f,M)$, and relax.
\item Finalize at $p=n$ by visiting remaining $M$ and adding $|M|$ exits.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item All $a_i$ equal: repeated returns to same $g$ needed.
\item Passengers with same destination floors (drop many at once).
\item Starting at floor 1 when $g\ne 1$ (movement only).
\item Already at $g$ with some $g$-dest onboard (freeing space without detour).
\item Final layer with residual $M$; ensure correct finishing movement.
\item No-op openings are never beneficial; avoid.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Forgetting exits happen before boarding at an open.
\item Allowing boarding at floors $g\ne a_p$ (violates global order).
\item Not forcing maximal boarding block at $g$ (must fill while possible).
\item Mishandling duplicates in $M$ when forming subsets and movement floors.
\item Off-by-one in run-length computation.
\item Sorting $M$ to canonicalize state keys for hashing.
\end{itemize}}
\FAILMODES{Naive brute-force explodes; Dijkstra with states to non-$g$ floors bloats the graph. The layered DP prunes by only transitioning to the next pickup floor, compressing multiple pre-drops via the line-metric formula.}
\ELI{Always go to the next person’s floor. If the elevator is too full, first drop off some riders at their floors by taking the shortest there-and-back route on a straight line of floors. When you finally open at the next person’s floor, everyone who should get out does, then you board as many as possible. Repeat.}
\NotePages{3}

\end{document}