% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Ants}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1007/D}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{There is a tree with $n$ vertices. There are also $m$ ants living on it. Each ant has its own color. The $i$-th ant has two favorite pairs of vertices: $(a_i, b_i)$ and $(c_i, d_i)$. You need to tell if it is possible to paint the edges of the tree in $m$ colors so that every ant will be able to walk between vertices from one of its favorite pairs using only edges of his color; if it is possible, you need to print which pair every ant should use.

Input:
The first line contains a single integer $n$ ($2 \le n \le 10^5$) — the number of vertices.

Each of the next $n-1$ lines contains two integers $u_i$ and $v_i$ ($1 \le u_i, v_i \le n$), meaning that there is an edge between vertices $u_i$ and $v_i$.

The next line contains a single integer $m$ ($1 \le m \le 10^4$) — the number of ants.

Each of the next $m$ lines contains four integers $a_i$, $b_i$, $c_i$, and $d_i$ ($1 \le a_i, b_i, c_i, d_i \le n$, $a_i \ne b_i, c_i \ne d_i$), meaning that pairs $(a_i, b_i)$ and $(c_i, d_i)$ are favorite for the $i$-th ant.

Output:
Print ``NO'' (without quotes) if the wanted painting is impossible.

Otherwise, print ``YES'' (without quotes). Print $m$ lines. On the $i$-th line, print $1$ if the $i$-th ant will use the first pair and $2$ otherwise. If there are multiple answers, print any.

Note:
In the sample, the second and the third edge should be painted in the first color, the first and the fifth should be painted in the second color, and the fourth should be painted in the third color.}
\BREAKDOWN{We must choose exactly one path for each ant (between one of its two pairs) such that all chosen paths are pairwise edge-disjoint. Then we can color each chosen path by that ant's color and paint the remaining edges arbitrarily. This can be modeled as a 2-SAT feasibility problem where each option is a literal and conflicts arise when two options share at least one tree edge.}
\ELI{Pick one of two routes for each ant so that routes never share edges.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Tree with $n$ vertices and $n-1$ edges $(u_i,v_i)$; integer $m$; then $m$ quadruples $(a_i,b_i,c_i,d_i)$. All vertices are in $[1,n]$.}
\OUTPUTS{Either NO if impossible; else YES and for each ant $i$ print $1$ if using $(a_i,b_i)$, otherwise $2$ if using $(c_i,d_i)$. Any valid selection is acceptable.}
\SAMPLES{Example 1 (easy possible): $n=4$ with edges $(1,2),(2,3),(3,4)$; $m=2$; ants: $(1,2)$ or $(2,3)$, and $(3,4)$ or $(2,3)$. One valid output is YES then lines: $1$ and $1$. Example 2 (impossible): $n=2$ with edge $(1,2)$; $m=2$; both ants have $(1,2)$ or $(1,2)$. Output NO.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the tree be $T=(V,E)$. For each ant $i\in\{1,\ldots,m\}$ let $P_{i,1}$ be the unique simple path between $(a_i,b_i)$ and $P_{i,2}$ the path between $(c_i,d_i)$. Choose $x_i\in\{1,2\}$ to indicate which path ant $i$ uses. Feasibility requires that these chosen paths are edge-disjoint.}
\varmapStart
\var{x_i}{choice for ant $i$: $1$ means use $(a_i,b_i)$, $2$ means use $(c_i,d_i)$}
\var{P_{i,1},P_{i,2}}{edge sets of the unique tree paths for ant $i$'s two options}
\var{E}{edge set of the given tree}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall e\in E:\quad \sum_{i=1}^m \mathbf{1}\{e\in P_{i,x_i}\} \le 1.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Simple connected tree; unique simple path between any pair of vertices; edges are undirected.}
\INVARIANTS{On a tree, two simple paths intersect in either a path (possibly empty) and edge-disjointness reduces to forbidding any shared edge. If a set of paths is pairwise edge-disjoint, they can be colored independently without conflicts.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Reduce to 2-SAT: each ant is a boolean variable choosing option 1 or 2. For any two options that share an edge, add clause forbidding choosing both simultaneously.}
\ASSUMPTIONS{Explicitly enumerate all edges on each path and build conflicts per edge by pairwise linking all options using that edge.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Root the tree and precompute parent, depth, and LCA.
\item For each ant option, enumerate all edge ids on its path by climbing to the LCA; append its literal id to every edge used.
\item For each edge, for every unordered pair of literals attached, add implications $\ell\to \neg r$ and $r\to \neg \ell$.
\item Run 2-SAT via SCC on the implication graph. If any variable and its negation are in the same component, answer NO; else extract assignment and print 1/2 accordingly.
\end{algosteps}
\COMPLEXITY{Let $k_e$ be the number of options using edge $e$. Building paths explicitly costs $O\bigl(\sum \lvert P_{i,\cdot}\rvert\bigr)$; constraints per edge cost $O\bigl(\sum_e k_e^2\bigr)$. This is worst-case heavy but correct.}
\[
\begin{aligned}
T(n,m) &= O\!\left(\sum_{i=1}^{m}\left(\lvert P_{i,1}\rvert+\lvert P_{i,2}\rvert\right) + \sum_{e\in E} k_e^2 + (m + \sum_e k_e)\right). \\
\end{aligned}
\]
\CORRECTNESS{Any two chosen options sharing an edge would force contradictory colors on that edge; the added clause forbids choosing both. Conversely, if no chosen pair conflicts per the clauses, no edge is shared by two chosen options, so coloring by ant indices is feasible.}
\EDGECASES{Identical pairs for an ant; options that are the same path; many ants using the same central edge; degenerate $n=2$, $m=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import defaultdict, deque

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    m = int(next(it))
    queries = []
    for _ in range(m):
        a = int(next(it)); b = int(next(it)); c = int(next(it)); d = int(next(it))
        queries.append((a, b, c, d))
    return n, edges, m, queries

def build_tree(n, edges):
    adj = [[] for _ in range(n + 1)]
    for idx, (u, v) in enumerate(edges):
        adj[u].append((v, idx))
        adj[v].append((u, idx))
    return adj

def prep_lca(n, adj, root=1):
    LOG = (n).bit_length()
    up = [[0] * (n + 1) for _ in range(LOG)]
    upEdge = [[-1] * (n + 1) for _ in range(LOG)]
    depth = [0] * (n + 1)
    parent = [0] * (n + 1)
    parentEdge = [-1] * (n + 1)
    # BFS
    q = deque([root])
    parent[root] = root
    parentEdge[root] = -1
    depth[root] = 0
    vis = [False] * (n + 1)
    vis[root] = True
    while q:
        u = q.popleft()
        for v, eid in adj[u]:
            if not vis[v]:
                vis[v] = True
                parent[v] = u
                parentEdge[v] = eid
                depth[v] = depth[u] + 1
                q.append(v)
    for v in range(1, n + 1):
        up[0][v] = parent[v]
        upEdge[0][v] = parentEdge[v]
    for k in range(1, LOG):
        for v in range(1, n + 1):
            up[k][v] = up[k - 1][up[k - 1][v]]
            # edge to ancestor 2^k above is not a single edge; keep -1 placeholder
            upEdge[k][v] = -1
    return up, upEdge, parent, parentEdge, depth

def lca(u, v, up, depth):
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    # raise u
    diff = depth[u] - depth[v]
    for k in range(LOG):
        if diff & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG - 1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]; v = up[k][v]
    return up[0][u]

def edges_on_path(u, v, up, parent, parentEdge, depth):
    w = lca(u, v, up, depth)
    lst = []
    x = u
    while x != w:
        lst.append(parentEdge[x])
        x = parent[x]
    x = v
    while x != w:
        lst.append(parentEdge[x])
        x = parent[x]
    return lst

def two_sat(m, implications):
    N = 2 * m
    g = [[] for _ in range(N)]
    gr = [[] for _ in range(N)]
    for a, b in implications:
        g[a].append(b)
        gr[b].append(a)
    order = []
    seen = [False] * N
    def dfs1(v):
        seen[v] = True
        for to in g[v]:
            if not seen[to]:
                dfs1(to)
        order.append(v)
    for v in range(N):
        if not seen[v]:
            dfs1(v)
    comp = [-1] * N
    def dfs2(v, c):
        comp[v] = c
        for to in gr[v]:
            if comp[to] == -1:
                dfs2(to, c)
    j = 0
    for v in reversed(order):
        if comp[v] == -1:
            dfs2(v, j)
            j += 1
    assign = [False] * m
    for i in range(m):
        if comp[2*i] == comp[2*i+1]:
            return None
        assign[i] = comp[2*i] > comp[2*i+1]  # False-literal after True-literal => True
    return assign

def solve_case(n, edges, m, queries):
    adj = build_tree(n, edges)
    up, upEdge, parent, parentEdge, depth = prep_lca(n, adj, 1)
    # For each literal, collect the set of edges it uses
    # literal id: 2*i => choose second pair (x_i = False), 2*i+1 => choose first pair (x_i = True)
    edge_to_literals = [[] for _ in range(n - 1)]
    for i, (a, b, c, d) in enumerate(queries):
        # first option literal
        lit1 = 2*i + 1
        e1 = edges_on_path(a, b, up, parent, parentEdge, depth)
        for eid in e1:
            edge_to_literals[eid].append(lit1)
        # second option literal
        lit2 = 2*i
        e2 = edges_on_path(c, d, up, parent, parentEdge, depth)
        for eid in e2:
            edge_to_literals[eid].append(lit2)
    # Build implications for conflicts on the same edge
    impl = []
    for lits in edge_to_literals:
        # remove potential duplicates
        if not lits:
            continue
        # pairwise conflicts: (li -> not lj) and (lj -> not li)
        # to reduce duplicates, we can sort and unique
        lst = sorted(set(lits))
        L = len(lst)
        for ii in range(L):
            for jj in range(ii + 1, L):
                a = lst[ii]; b = lst[jj]
                impl.append((a, b ^ 1))
                impl.append((b, a ^ 1))
    assign = two_sat(m, impl)
    if assign is None:
        return False, []
    ans = [1 if assign[i] else 2 for i in range(m)]
    return True, ans

def solve_all():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    n, edges, m, queries = parsed
    ok, ans = solve_case(n, edges, m, queries)
    out = []
    if not ok:
        out.append("NO")
    else:
        out.append("YES")
        out.extend(str(x) for x in ans)
    sys.stdout.write("\n".join(out))

def main():
    solve_all()

if __name__ == "__main__":
    # Tiny self-checks
    # 1) Possible: chain 1-2-3-4; ant1 (1,2)|(2,3); ant2 (3,4)|(2,3) -> choose 1 and 1
    n = 4
    edges = [(1,2),(2,3),(3,4)]
    queries = [(1,2,2,3),(3,4,2,3)]
    ok, ans = solve_case(n, edges, 2, queries)
    assert ok and ans[0] == 1 and ans[1] in (1,2)
    # 2) Impossible: single edge used by two ants
    n2 = 2
    edges2 = [(1,2)]
    queries2 = [(1,2,1,2),(1,2,1,2)]
    ok2, _ = solve_case(n2, edges2, 2, queries2)
    assert not ok2
    # 3) Possible: star 1-2,1-3,1-4; three ants pick disjoint spokes
    n3 = 4
    edges3 = [(1,2),(1,3),(1,4)]
    queries3 = [(1,2,1,2),(1,3,1,3),(1,4,1,4)]
    ok3, ans3 = solve_case(n3, edges3, 3, queries3)
    assert ok3 and all(x in (1,2) for x in ans3)
    # If stdin has content, run solver
    if sys.stdin.isatty():
        pass
    else:
        sys.stdin.seek(0)
        main()
\end{minted}
\VALIDATION{The asserts cover: a feasible chain, an impossible single-edge contention, and a feasible star distribution.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{2-SAT with Tree Preprocessing (LCA) and Edge Bucketing}
\WHICHFORMULA{Same 2-SAT formulation, but careful preprocessing of paths with LCA and parent-edge arrays keeps per-path enumeration straightforward and low-overhead in practice.}
\ASSUMPTIONS{Use BFS to root and lift for LCA; enumerate edges on paths by climbing to the LCA.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Root the tree once and build binary lifting tables for LCA.
\item For each option, climb to LCA to collect edge ids used; append the option's literal to those edges' buckets.
\item For each edge bucket, add pairwise conflict implications across its literals.
\item Solve the resulting 2-SAT via SCC and output a consistent selection.
\end{algosteps}
\COMPLEXITY{In practice, the LCA-based enumeration is fast for random trees; worst-case remains dominated by $\sum_e k_e^2$.}
\[
\begin{aligned}
T(n,m) &= O\!\left(n + m + \sum_{i} \lvert P_{i,1}\rvert + \lvert P_{i,2}\rvert + \sum_e k_e^2 \right).
\end{aligned}
\]
\CORRECTNESS{Identical to Approach A: every edge-level conflict is encoded as a binary clause that prevents simultaneous selection.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
import sys
from collections import deque

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it))
    except StopIteration:
        return None
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    m = int(next(it))
    queries = []
    for _ in range(m):
        a = int(next(it)); b = int(next(it)); c = int(next(it)); d = int(next(it))
        queries.append((a, b, c, d))
    return n, edges, m, queries

def build_tree(n, edges):
    adj = [[] for _ in range(n + 1)]
    for idx, (u, v) in enumerate(edges):
        adj[u].append((v, idx))
        adj[v].append((u, idx))
    return adj

def prep_lca(n, adj, root=1):
    LOG = (n).bit_length()
    up = [[0] * (n + 1) for _ in range(LOG)]
    parent = [0] * (n + 1)
    parentEdge = [-1] * (n + 1)
    depth = [0] * (n + 1)
    q = deque([root])
    parent[root] = root
    depth[root] = 0
    vis = [False] * (n + 1)
    vis[root] = True
    while q:
        u = q.popleft()
        for v, eid in adj[u]:
            if not vis[v]:
                vis[v] = True
                parent[v] = u
                parentEdge[v] = eid
                depth[v] = depth[u] + 1
                q.append(v)
    for v in range(1, n + 1):
        up[0][v] = parent[v]
    for k in range(1, LOG):
        for v in range(1, n + 1):
            up[k][v] = up[k - 1][up[k - 1][v]]
    return up, parent, parentEdge, depth

def lca(u, v, up, depth):
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    diff = depth[u] - depth[v]
    for k in range(LOG):
        if diff & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG - 1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]; v = up[k][v]
    return up[0][u]

def edges_on_path(u, v, up, parent, parentEdge, depth):
    w = lca(u, v, up, depth)
    lst = []
    x = u
    while x != w:
        lst.append(parentEdge[x])
        x = parent[x]
    x = v
    while x != w:
        lst.append(parentEdge[x])
        x = parent[x]
    return lst

def kosaraju_2sat(m, implications):
    N = 2 * m
    g = [[] for _ in range(N)]
    gr = [[] for _ in range(N)]
    for a, b in implications:
        g[a].append(b)
        gr[b].append(a)
    seen = [False] * N
    order = []
    def dfs1(v):
        seen[v] = True
        for to in g[v]:
            if not seen[to]:
                dfs1(to)
        order.append(v)
    for v in range(N):
        if not seen[v]:
            dfs1(v)
    comp = [-1] * N
    def dfs2(v, c):
        comp[v] = c
        for to in gr[v]:
            if comp[to] == -1:
                dfs2(to, c)
    j = 0
    for v in reversed(order):
        if comp[v] == -1:
            dfs2(v, j)
            j += 1
    assign = [False] * m
    for i in range(m):
        if comp[2*i] == comp[2*i+1]:
            return None
        assign[i] = comp[2*i] > comp[2*i+1]
    return assign

def solve_case(n, edges, m, queries):
    adj = build_tree(n, edges)
    up, parent, parentEdge, depth = prep_lca(n, adj, 1)
    edge_to_literals = [[] for _ in range(n - 1)]
    for i, (a, b, c, d) in enumerate(queries):
        lit_true = 2*i + 1
        for eid in edges_on_path(a, b, up, parent, parentEdge, depth):
            edge_to_literals[eid].append(lit_true)
        lit_false = 2*i
        for eid in edges_on_path(c, d, up, parent, parentEdge, depth):
            edge_to_literals[eid].append(lit_false)
    impl = []
    for lst in edge_to_literals:
        if not lst:
            continue
        s = sorted(set(lst))
        for ii in range(len(s)):
            for jj in range(ii + 1, len(s)):
                a = s[ii]; b = s[jj]
                impl.append((a, b ^ 1))
                impl.append((b, a ^ 1))
    assign = kosaraju_2sat(m, impl)
    if assign is None:
        return False, []
    return True, [1 if x else 2 for x in assign]

def read_stdin_and_solve():
    data = sys.stdin.read()
    parsed = read_input(data)
    if not parsed:
        return
    n, edges, m, queries = parsed
    ok, ans = solve_case(n, edges, m, queries)
    if not ok:
        print("NO")
    else:
        print("YES")
        for x in ans:
            print(x)

def main():
    read_stdin_and_solve()

if __name__ == "__main__":
    # Checks identical to Approach A
    n = 4; edges = [(1,2),(2,3),(3,4)]
    queries = [(1,2,2,3),(3,4,2,3)]
    ok, ans = solve_case(n, edges, 2, queries)
    assert ok and ans[0] == 1
    n2 = 2; edges2 = [(1,2)]; queries2 = [(1,2,1,2),(1,2,1,2)]
    ok2, _ = solve_case(n2, edges2, 2, queries2)
    assert not ok2
    n3 = 4; edges3 = [(1,2),(1,3),(1,4)]
    queries3 = [(1,2,1,2),(1,3,1,3),(1,4,1,4)]
    ok3, _ = solve_case(n3, edges3, 3, queries3)
    assert ok3
\end{minted}
\VALIDATION{Same sanity checks ensure basic feasibility and infeasibility cases are handled.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{2-SAT with Conflict Generation via Edge Buckets}
\WHICHFORMULA{Provably correct reduction to 2-SAT: each conflicting pair of options yields a binary clause, and a satisfying assignment maps to a valid coloring.}
\ASSUMPTIONS{Edges are uniquely identified; each path is the union of its endpoint-to-LCA climbs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute LCA, depth, parent, and parent-edge arrays.
\item For each of the $2m$ options, list all used edge ids and link that literal to those edges' buckets.
\item For each edge bucket, add mutual exclusion clauses among all attached literals.
\item Solve 2-SAT using SCC; output YES with chosen options or NO if unsatisfiable.
\end{algosteps}
\OPTIMALITY{Given the problem's clause structure, any feasible selection corresponds to a 2-SAT assignment, and any 2-SAT solution is feasible. While worst-case clause generation can be large, the formulation is tight: every edge-sharing conflict must appear in some clause.}
\COMPLEXITY{SCC runs in linear time in the number of implication edges. Clause generation depends on conflict density per edge.}
\[
\begin{aligned}
T(n,m) &= O\!\left(n + m + \sum_i (\lvert P_{i,1}\rvert+\lvert P_{i,2}\rvert) + \sum_e k_e^2 \right).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys
from collections import deque

def read_input_stream():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    m = int(next(it))
    queries = []
    for _ in range(m):
        a = int(next(it)); b = int(next(it)); c = int(next(it)); d = int(next(it))
        queries.append((a, b, c, d))
    return n, edges, m, queries

def build_adj(n, edges):
    adj = [[] for _ in range(n + 1)]
    for idx, (u, v) in enumerate(edges):
        adj[u].append((v, idx))
        adj[v].append((u, idx))
    return adj

def lca_prep(n, adj, root=1):
    LOG = (n).bit_length()
    up = [[0] * (n + 1) for _ in range(LOG)]
    parent = [0] * (n + 1)
    parentEdge = [-1] * (n + 1)
    depth = [0] * (n + 1)
    q = deque([root])
    parent[root] = root
    depth[root] = 0
    seen = [False] * (n + 1)
    seen[root] = True
    while q:
        u = q.popleft()
        for v, eid in adj[u]:
            if not seen[v]:
                seen[v] = True
                parent[v] = u
                parentEdge[v] = eid
                depth[v] = depth[u] + 1
                q.append(v)
    for v in range(1, n + 1):
        up[0][v] = parent[v]
    for k in range(1, LOG):
        for v in range(1, n + 1):
            up[k][v] = up[k - 1][up[k - 1][v]]
    return up, parent, parentEdge, depth

def lca(u, v, up, depth):
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    diff = depth[u] - depth[v]
    for k in range(LOG):
        if diff & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG - 1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def collect_edges(u, v, up, parent, parentEdge, depth):
    w = lca(u, v, up, depth)
    lst = []
    x = u
    while x != w:
        lst.append(parentEdge[x])
        x = parent[x]
    x = v
    while x != w:
        lst.append(parentEdge[x])
        x = parent[x]
    return lst

def solve_case(n, edges, m, queries):
    adj = build_adj(n, edges)
    up, parent, parentEdge, depth = lca_prep(n, adj, 1)
    edge_buckets = [[] for _ in range(n - 1)]
    for i, (a, b, c, d) in enumerate(queries):
        lit_true = 2*i + 1   # choose first pair
        for eid in collect_edges(a, b, up, parent, parentEdge, depth):
            edge_buckets[eid].append(lit_true)
        lit_false = 2*i      # choose second pair
        for eid in collect_edges(c, d, up, parent, parentEdge, depth):
            edge_buckets[eid].append(lit_false)
    N = 2 * m
    g = [[] for _ in range(N)]
    gr = [[] for _ in range(N)]
    def add_imp(a, b):
        g[a].append(b)
        gr[b].append(a)
    for lst in edge_buckets:
        if not lst:
            continue
        s = sorted(set(lst))
        for i in range(len(s)):
            for j in range(i + 1, len(s)):
                a = s[i]; b = s[j]
                add_imp(a, b ^ 1)
                add_imp(b, a ^ 1)
    seen = [False] * N
    order = []
    def dfs1(v):
        seen[v] = True
        for to in g[v]:
            if not seen[to]:
                dfs1(to)
        order.append(v)
    for v in range(N):
        if not seen[v]:
            dfs1(v)
    comp = [-1] * N
    def dfs2(v, c):
        comp[v] = c
        for to in gr[v]:
            if comp[to] == -1:
                dfs2(to, c)
    j = 0
    for v in reversed(order):
        if comp[v] == -1:
            dfs2(v, j)
            j += 1
    assign = [False] * m
    for i in range(m):
        if comp[2*i] == comp[2*i + 1]:
            return False, []
        assign[i] = comp[2*i] > comp[2*i + 1]
    ans = [1 if assign[i] else 2 for i in range(m)]
    return True, ans

def solve_all():
    parsed = read_input_stream()
    if not parsed:
        return
    n, edges, m, queries = parsed
    ok, ans = solve_case(n, edges, m, queries)
    if not ok:
        print("NO")
    else:
        print("YES")
        for x in ans:
            print(x)

def main():
    solve_all()

if __name__ == "__main__":
    # Exactly 3 asserts / I/O mini-tests
    # 1) Feasible chain
    ok, ans = solve_case(4, [(1,2),(2,3),(3,4)], 2, [(1,2,2,3),(3,4,2,3)])
    assert ok and ans[0] in (1,2) and ans[1] in (1,2)
    # 2) Impossible single edge contention
    ok2, _ = solve_case(2, [(1,2)], 2, [(1,2,1,2),(1,2,1,2)])
    assert not ok2
    # 3) Simple star feasible
    ok3, ans3 = solve_case(4, [(1,2),(1,3),(1,4)], 3, [(1,2,1,2),(1,3,1,3),(1,4,1,4)])
    assert ok3 and len(ans3) == 3
\end{minted}
\VALIDATION{Three asserts cover feasible chain, impossible contention on a single edge, and feasible star spokes.}
\RESULT{Outputs YES with a choice per ant (1 for $(a_i,b_i)$, 2 for $(c_i,d_i)$) when feasible; otherwise NO.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny trees (chains, stars), duplicated pairs, and contention on a single edge. Random small trees can be fuzzed offline by brute-force selection checking edge-disjointness.}
\LINE{CROSS-CHECKS}{Compare the 2-SAT result against a brute-force solver for $n \le 8$, $m \le 6$ to ensure correctness on random seeds.}
\LINE{EDGE-CASE GENERATOR}{Generate stars and paths where many options concentrate on the same edge to test clause creation.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_chain(n):
    edges = [(i, i+1) for i in range(1, n)]
    return edges

def gen_star(k):
    edges = [(1, i) for i in range(2, k+2)]
    return edges

def brute_feasible(n, edges, queries):
    # brute-force try all 2^m choices; check edge-disjointness
    m = len(queries)
    # build parent pointers for edges to list edges on a path (simple DFS each time for tiny n)
    adj = [[] for _ in range(n + 1)]
    for idx, (u, v) in enumerate(edges):
        adj[u].append((v, idx))
        adj[v].append((u, idx))
    def path_edges(u, v):
        # BFS to get parent and reconstruct path; for tiny n only
        from collections import deque
        q = deque([u])
        par = {u: (-1, -1)}
        while q:
            x = q.popleft()
            if x == v:
                break
            for y, eid in adj[x]:
                if y not in par:
                    par[y] = (x, eid)
                    q.append(y)
        out = []
        cur = v
        while cur != u:
            p, eid = par[cur]
            out.append(eid)
            cur = p
        return out
    paths = []
    for (a,b,c,d) in queries:
        paths.append((path_edges(a,b), path_edges(c,d)))
    for mask in range(1<<m):
        used = set()
        ok = True
        for i in range(m):
            opt = (mask>>i)&1
            for e in paths[i][opt]:
                if e in used:
                    ok = False; break
                used.add(e)
            if not ok: break
        if ok: return True
    return False

def test_small():
    random.seed(0)
    # chain
    n = 6; edges = gen_chain(n)
    queries = [(1,3,2,5),(4,6,5,6),(2,2+1,1,5)]
    assert brute_feasible(n, edges, queries) == True

if __name__ == "__main__":
    test_small()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys
from collections import deque

def read_input_stream():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it))
    edges = []
    for _ in range(n - 1):
        u = int(next(it)); v = int(next(it))
        edges.append((u, v))
    m = int(next(it))
    queries = []
    for _ in range(m):
        a = int(next(it)); b = int(next(it)); c = int(next(it)); d = int(next(it))
        queries.append((a, b, c, d))
    return n, edges, m, queries

def build_adj(n, edges):
    adj = [[] for _ in range(n + 1)]
    for idx, (u, v) in enumerate(edges):
        adj[u].append((v, idx))
        adj[v].append((u, idx))
    return adj

def lca_prep(n, adj, root=1):
    LOG = (n).bit_length()
    up = [[0] * (n + 1) for _ in range(LOG)]
    parent = [0] * (n + 1)
    parentEdge = [-1] * (n + 1)
    depth = [0] * (n + 1)
    q = deque([root])
    parent[root] = root
    depth[root] = 0
    seen = [False] * (n + 1)
    seen[root] = True
    while q:
        u = q.popleft()
        for v, eid in adj[u]:
            if not seen[v]:
                seen[v] = True
                parent[v] = u
                parentEdge[v] = eid
                depth[v] = depth[u] + 1
                q.append(v)
    for v in range(1, n + 1):
        up[0][v] = parent[v]
    for k in range(1, LOG):
        for v in range(1, n + 1):
            up[k][v] = up[k - 1][up[k - 1][v]]
    return up, parent, parentEdge, depth

def lca(u, v, up, depth):
    if depth[u] < depth[v]:
        u, v = v, u
    LOG = len(up)
    diff = depth[u] - depth[v]
    for k in range(LOG):
        if diff & (1 << k):
            u = up[k][u]
    if u == v:
        return u
    for k in range(LOG - 1, -1, -1):
        if up[k][u] != up[k][v]:
            u = up[k][u]
            v = up[k][v]
    return up[0][u]

def collect_edges(u, v, up, parent, parentEdge, depth):
    w = lca(u, v, up, depth)
    lst = []
    x = u
    while x != w:
        lst.append(parentEdge[x])
        x = parent[x]
    x = v
    while x != w:
        lst.append(parentEdge[x])
        x = parent[x]
    return lst

def solve_case(n, edges, m, queries):
    adj = build_adj(n, edges)
    up, parent, parentEdge, depth = lca_prep(n, adj, 1)
    edge_buckets = [[] for _ in range(n - 1)]
    for i, (a, b, c, d) in enumerate(queries):
        lit_true = 2*i + 1
        for eid in collect_edges(a, b, up, parent, parentEdge, depth):
            edge_buckets[eid].append(lit_true)
        lit_false = 2*i
        for eid in collect_edges(c, d, up, parent, parentEdge, depth):
            edge_buckets[eid].append(lit_false)
    N = 2 * m
    g = [[] for _ in range(N)]
    gr = [[] for _ in range(N)]
    def add_imp(a, b):
        g[a].append(b)
        gr[b].append(a)
    for lst in edge_buckets:
        if not lst:
            continue
        s = sorted(set(lst))
        for i in range(len(s)):
            for j in range(i + 1, len(s)):
                a = s[i]; b = s[j]
                add_imp(a, b ^ 1)
                add_imp(b, a ^ 1)
    seen = [False] * N
    order = []
    def dfs1(v):
        seen[v] = True
        for to in g[v]:
            if not seen[to]:
                dfs1(to)
        order.append(v)
    for v in range(N):
        if not seen[v]:
            dfs1(v)
    comp = [-1] * N
    def dfs2(v, c):
        comp[v] = c
        for to in gr[v]:
            if comp[to] == -1:
                dfs2(to, c)
    j = 0
    for v in reversed(order):
        if comp[v] == -1:
            dfs2(v, j)
            j += 1
    assign = [False] * m
    for i in range(m):
        if comp[2*i] == comp[2*i + 1]:
            return False, []
        assign[i] = comp[2*i] > comp[2*i + 1]
    ans = [1 if assign[i] else 2 for i in range(m)]
    return True, ans

def solve_all():
    parsed = read_input_stream()
    if not parsed:
        return
    n, edges, m, queries = parsed
    ok, ans = solve_case(n, edges, m, queries)
    if not ok:
        print("NO")
    else:
        print("YES")
        for x in ans:
            print(x)

def main():
    solve_all()

if __name__ == "__main__":
    # Tiny asserts
    ok, ans = solve_case(4, [(1,2),(2,3),(3,4)], 2, [(1,2,2,3),(3,4,2,3)])
    assert ok and len(ans) == 2
    ok2, _ = solve_case(2, [(1,2)], 2, [(1,2,1,2),(1,2,1,2)])
    assert not ok2
    ok3, ans3 = solve_case(4, [(1,2),(1,3),(1,4)], 3, [(1,2,1,2),(1,3,1,3),(1,4,1,4)])
    assert ok3 and all(x in (1,2) for x in ans3)
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Pick one path per ant so that the chosen paths are pairwise edge-disjoint; encode with 2-SAT by forbidding any two options that share an edge.}
\WHY{Disjoint path selection with binary choices appears in advanced interviews; reduction to 2-SAT is a common technique.}
\CHECKLIST{Identify path options; compute LCA; enumerate path edges; bucket literals per edge; add mutual exclusion clauses; run SCC; print selection.}
\EDGECASES{Identical options for an ant; many options sharing a single edge; tree with $n=2$; ants count $m=1$; pairs with endpoints equal to the root; long chain trees.}
\PITFALLS{Forgetting to deduplicate literals per edge; wrong mapping of literals and their negations; LCA off-by-one; not handling empty stdin when running asserts; mixing vertices and edge ids; not printing exactly $m$ lines after YES.}
\FAILMODES{Naive all-pairs conflict checking is $O(m^2)$; this survives by bucketing per edge. Worst-case still large if many options share one edge.}
\ELI{Treat each ant's two choices as a yes/no variable. If two choices would need the same edge, they cannot both be selected. Build all such ``cannot both'' rules and check if there is a way to pick one choice per ant that respects all rules.}
\NotePages{3}

\end{document}