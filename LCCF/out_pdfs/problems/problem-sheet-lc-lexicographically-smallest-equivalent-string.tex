% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lexicographically Smallest Equivalent String}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/lexicographically-smallest-equivalent-string/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given two strings of the same length ``s1'' and ``s2'' and a string ``baseStr''. We say s1[i] and s2[i] are equivalent characters.
\begin{itemize}
\item For example, if s1 = ``abc'' and s2 = ``cde'', then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.
\end{itemize}
Equivalent characters follow the usual rules of any equivalence relation:
\begin{itemize}
\item Reflexivity: 'a' == 'a'.
\item Symmetry: 'a' == 'b' implies 'b' == 'a'.
\item Transitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.
\end{itemize}
For example, given the equivalency information from s1 = ``abc'' and s2 = ``cde'', ``acd'' and ``aab'' are equivalent strings of baseStr = ``eed'', and ``aab'' is the lexicographically smallest equivalent string of baseStr. Return the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.
Examples:
\begin{itemize}
\item Input: s1 = ``parker'', s2 = ``morris'', baseStr = ``parser''. Output: ``makkek''. Explanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i]. The characters in each group are equivalent and sorted in lexicographical order. So the answer is ``makkek''.
\item Input: s1 = ``hello'', s2 = ``world'', baseStr = ``hold''. Output: ``hdld''. Explanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r]. So only the second letter 'o' in baseStr is changed to 'd', the answer is ``hdld''.
\item Input: s1 = ``leetcode'', s2 = ``programs'', baseStr = ``sourcecode''. Output: ``aauaaaaada''. Explanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except 'u' and 'd' are transformed to 'a', the answer is ``aauaaaaada''.
\end{itemize}
Constraints:
\begin{itemize}
\item $1 \le \text{s1.length}, \text{s2.length}, \text{baseStr.length} \le 1000$
\item $\text{s1.length} = \text{s2.length}$
\item s1, s2, and baseStr consist of lowercase English letters.
\end{itemize}}
\BREAKDOWN{Build equivalence classes over the 26 lowercase letters using the pairs $(\text{s1}[i], \text{s2}[i])$, then map each character in baseStr to the smallest letter in its class to obtain the answer.}
\ELI{Group letters that must be the same and replace each base letter by the smallest letter in its group.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Three strings: s1, s2, baseStr. Valid ranges: $1 \le |\text{s1}|, |\text{s2}|, |\text{baseStr}| \le 1000$, all lowercase English letters with $|\text{s1}| = |\text{s2}|$.}
\OUTPUTS{Return a single string: the lexicographically smallest string equivalent to baseStr under the equivalence relation generated by pairing s1[i] with s2[i] for all valid $i$.}
\SAMPLES{
\begin{itemize}
\item s1 = ``parker'', s2 = ``morris'', baseStr = ``parser'' $\to$ ``makkek''
\item s1 = ``hello'', s2 = ``world'', baseStr = ``hold'' $\to$ ``hdld''
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\Sigma = \{a,b,\ldots,z\}$ and define a relation $R \subseteq \Sigma \times \Sigma$ as the smallest equivalence relation containing the pairs $\{(\text{s1}[i], \text{s2}[i]), (\text{s2}[i], \text{s1}[i])\}$ for all $i$. For each $c \in \Sigma$, define $\mincl(c) = \min\{x \in \Sigma \mid (c,x) \in R\}$ under the natural lexicographic order. The target is $T(\text{baseStr})$ where $T$ maps each character $c$ to $\mincl(c)$.}
\varmapStart
\var{\Sigma}{lowercase alphabet}
\var{R}{equivalence relation generated by the given pairs}
\var{\mincl(c)}{lexicographically smallest representative in the class of $c$}
\var{T}{character-wise mapping $c \mapsto \mincl(c)$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
R &= \text{EqClosure}\left(\{(\text{s1}[i],\text{s2}[i]),(\text{s2}[i],\text{s1}[i]) \mid 0 \le i < |\text{s1}|\}\right),\\
\mincl(c) &= \min \{ x \in \Sigma \mid (c,x) \in R\},\\
\text{answer} &= T(\text{baseStr}) = \bigoplus_{j=0}^{|\text{baseStr}|-1} \mincl(\text{baseStr}[j]),
\end{aligned}
\]
where $\oplus$ denotes string concatenation.}
\ASSUMPTIONS{Only lowercase English letters are involved; equivalence classes partition $\Sigma$; $\min$ over a finite nonempty class is well-defined.}
\INVARIANTS{
\begin{itemize}
\item Equivalence classes are disjoint and cover $\Sigma$.
\item For any $c \in \Sigma$, $T(c)$ equals the smallest element of $[c]_R$.
\item If $c \sim d$, then $T(c) = T(d)$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Build a 26-by-26 connectivity matrix, symmetrize edges from s1/s2, compute transitive closure (Floyd–Warshall), then map each baseStr character to the smallest connected letter.}
\ASSUMPTIONS{Alphabet size is constant 26, so $O(26^3)$ is trivial.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize a $26 \times 26$ boolean matrix $M$ with $M[i][i] = \text{True}$.
\item For each $i$, set $M[s1[i]][s2[i]] = M[s2[i]][s1[i]] = \text{True}$.
\item Run Floyd–Warshall over $M$ to compute transitive closure.
\item For each character $c$ in baseStr, output the smallest $x$ such that $M[c][x]$ is True.
\end{algosteps}
\COMPLEXITY{With $n = |\text{s1}| = |\text{s2}|$ and $m = |\text{baseStr}|$: time $O(26^3 + n + m \cdot 26)$, space $O(26^2)$.}
\[
\begin{aligned}
T(n,m) &= O(26^3) + O(n) + O(m \cdot 26) \\
       &= O(1) + O(n + m) \quad \text{(since 26 is constant).}
\end{aligned}
\]
\CORRECTNESS{Transitive closure computes the exact equivalence reachability. Minimal representative per class is the smallest column with True in row $c$.}
\EDGECASES{No pairs (identity mapping only). Multiple chains merging classes. Repeated characters in s1/s2/baseStr.}
\textbf{Code (Baseline)}
\begin{minted}{python}
class Solution:
    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:
        # Map char to 0..25
        def idx(c: str) -> int:
            return ord(c) - 97

        # 26x26 adjacency with reflexivity
        M = [[False] * 26 for _ in range(26)]
        for i in range(26):
            M[i][i] = True

        n = len(s1)
        for i in range(n):
            a, b = idx(s1[i]), idx(s2[i])
            M[a][b] = True
            M[b][a] = True

        # Floyd–Warshall (26 is tiny)
        for k in range(26):
            Mk = M[k]
            for i in range(26):
                if M[i][k]:
                    Mi = M[i]
                    # Logical OR of row i with row k
                    for j in range(26):
                        if Mk[j]:
                            Mi[j] = True

        # Build result by picking smallest equivalent letter
        out = []
        for ch in baseStr:
            i = idx(ch)
            smallest = 0
            while smallest < 26 and not M[i][smallest]:
                smallest += 1
            out.append(chr(97 + smallest))
        return "".join(out)


# Basic asserts from the prompt
sol = Solution()
assert sol.smallestEquivalentString("parker", "morris", "parser") == "makkek"
assert sol.smallestEquivalentString("hello", "world", "hold") == "hdld"
assert sol.smallestEquivalentString("leetcode", "programs", "sourcecode") == "aauaaaaada"
# Edge checks
assert sol.smallestEquivalentString("", "", "abc") == "abc"
assert sol.smallestEquivalentString("a", "b", "bbb") == "aaa"
\end{minted}
\VALIDATION{Checked examples, identity-only case, and a single-pair case transforming all 'b' to 'a'.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use Disjoint Set Union (Union-Find) over 26 letters. Always make the smaller letter the parent when uniting to make representative queries $O(1)$ after path compression.}
\ASSUMPTIONS{Alphabet is fixed size, so DSU operations are effectively constant-time; union by smallest preserves minimal representative at the root.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize parent array $p[i]=i$ for $0 \le i < 26$.
\item For each pair $(a,b)$ from s1/s2, union their sets by linking the larger root to the smaller root.
\item For each character $c$ in baseStr, output the character corresponding to the root of $c$.
\end{algosteps}
\COMPLEXITY{DSU with path compression and union-by-minimal runs in $O(\alpha(26)) \approx O(1)$ per op; overall $O(n+m)$.}
\[
\begin{aligned}
T(n,m) &= O(n \cdot \alpha(26) + m \cdot \alpha(26)) = O(n+m),\\
S &= O(26).
\end{aligned}
\]
\CORRECTNESS{By always making the smallest letter the root, the representative of each set equals the lexicographically smallest element of that class, so mapping is direct via find().}
\textbf{Code (Improved)}
\begin{minted}{python}
class Solution:
    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:
        parent = list(range(26))

        def find(x: int) -> int:
            # Path compression
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x

        def unite(a: int, b: int) -> None:
            ra, rb = find(a), find(b)
            if ra == rb:
                return
            # Attach larger to smaller to keep smallest as root
            if ra < rb:
                parent[rb] = ra
            else:
                parent[ra] = rb

        for a, b in zip(s1, s2):
            ia = ord(a) - 97
            ib = ord(b) - 97
            unite(ia, ib)

        res = []
        for ch in baseStr:
            r = find(ord(ch) - 97)
            res.append(chr(97 + r))
        return "".join(res)


# Asserts (same API/signature as baseline)
sol = Solution()
assert sol.smallestEquivalentString("parker", "morris", "parser") == "makkek"
assert sol.smallestEquivalentString("hello", "world", "hold") == "hdld"
assert sol.smallestEquivalentString("leetcode", "programs", "sourcecode") == "aauaaaaada"
# Additional checks
assert sol.smallestEquivalentString("abc", "bcd", "eed") == "aab"
assert sol.smallestEquivalentString("", "", "zzz") == "zzz"
\end{minted}
\VALIDATION{Validated on examples, chained unions (abc with bcd), and identity mapping for letters with no unions.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{DSU with union-by-min representative and full path compression; directly map each base character to the root. This achieves optimal linear time in input length.}
\ASSUMPTIONS{Only lowercase letters; union operations are limited to at most $25$ effective merges.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $p[i]=i$.
\item For each $i$, union $(\text{s1}[i], \text{s2}[i])$ by attaching the larger root to the smaller root.
\item For each $c$ in baseStr, append the root letter.
\end{algosteps}
\OPTIMALITY{Lower bound is $\Omega(n+m)$ because we must read inputs and write outputs. This method matches it up to constant factors.}
\COMPLEXITY{
\[
\begin{aligned}
T(n,m) &= \Theta(n+m),\quad S = \Theta(1)\ \text{(constant 26 arrays).}
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
class Solution:
    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:
        parent = list(range(26))

        def find(x: int) -> int:
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(a: int, b: int) -> None:
            ra, rb = find(a), find(b)
            if ra == rb:
                return
            # Keep smallest as representative
            if ra < rb:
                parent[rb] = ra
            else:
                parent[ra] = rb

        for a, b in zip(s1, s2):
            union(ord(a) - 97, ord(b) - 97)

        out = []
        for ch in baseStr:
            out.append(chr(97 + find(ord(ch) - 97)))
        return "".join(out)


# Exactly 3 asserts
sol = Solution()
assert sol.smallestEquivalentString("parker", "morris", "parser") == "makkek"
assert sol.smallestEquivalentString("hello", "world", "hold") == "hdld"
assert sol.smallestEquivalentString("leetcode", "programs", "sourcecode") == "aauaaaaada"
\end{minted}
\VALIDATION{Matches all provided examples exactly.}
\RESULT{Returns the lexicographically smallest string equivalent to baseStr; ties are resolved by always selecting the smallest character in each equivalence class.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: empty-pair identity; single and chained unions; overlapping unions that merge sets; full-coverage random small inputs cross-checked against Floyd–Warshall baseline.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A and C on random cases with alphabet restricted to first $k$ letters for $k \in \{3,5,10,26\}$.}
\LINE{EDGE-CASE GENERATOR}{Produce adversarial pairs that force deep chains (e.g., a-b, b-c, c-d, \ldots) and pairs that create multiple merges from different chains.}
\begin{minted}{python}
import random

def gen_case(n_pairs: int, base_len: int, alpha: int = 26, seed: int = 0):
    random.seed(seed)
    letters = [chr(97 + i) for i in range(alpha)]
    s1 = []
    s2 = []
    for _ in range(n_pairs):
        a = random.choice(letters)
        b = random.choice(letters)
        s1.append(a)
        s2.append(b)
    base = "".join(random.choice(letters) for _ in range(base_len))
    return "".join(s1), "".join(s2), base

class Baseline:
    @staticmethod
    def solve(s1: str, s2: str, baseStr: str) -> str:
        M = [[False]*26 for _ in range(26)]
        for i in range(26):
            M[i][i] = True
        for a, b in zip(s1, s2):
            ia, ib = ord(a)-97, ord(b)-97
            M[ia][ib] = M[ib][ia] = True
        for k in range(26):
            Mk = M[k]
            for i in range(26):
                if M[i][k]:
                    Mi = M[i]
                    for j in range(26):
                        if Mk[j]:
                            Mi[j] = True
        out = []
        for ch in baseStr:
            i = ord(ch)-97
            for j in range(26):
                if M[i][j]:
                    out.append(chr(97+j))
                    break
        return "".join(out)

class Reference:
    @staticmethod
    def solve(s1: str, s2: str, baseStr: str) -> str:
        parent = list(range(26))
        def find(x: int) -> int:
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        def union(a: int, b: int) -> None:
            ra, rb = find(a), find(b)
            if ra == rb: return
            if ra < rb: parent[rb] = ra
            else: parent[ra] = rb
        for a, b in zip(s1, s2):
            union(ord(a)-97, ord(b)-97)
        return "".join(chr(97 + find(ord(c)-97)) for c in baseStr)

# Cross-check small randoms
for k in [3, 5, 10, 26]:
    for t in range(50):
        s1, s2, base = gen_case(n_pairs=20, base_len=30, alpha=k, seed=t*97 + k)
        assert Baseline.solve(s1, s2, base) == Reference.solve(s1, s2, base)

print("Cross-checks passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
class Solution:
    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:
        parent = list(range(26))

        def find(x: int) -> int:
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(a: int, b: int) -> None:
            ra, rb = find(a), find(b)
            if ra == rb:
                return
            if ra < rb:
                parent[rb] = ra
            else:
                parent[ra] = rb

        for a, b in zip(s1, s2):
            union(ord(a) - 97, ord(b) - 97)

        return "".join(chr(97 + find(ord(c) - 97)) for c in baseStr)


# Reference asserts
sol = Solution()
assert sol.smallestEquivalentString("parker", "morris", "parser") == "makkek"
assert sol.smallestEquivalentString("hello", "world", "hold") == "hdld"
assert sol.smallestEquivalentString("leetcode", "programs", "sourcecode") == "aauaaaaada"
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Construct equivalence classes from paired letters and replace each base letter with its class's smallest letter.}
\WHY{Classic DSU-on-characters problem; tests understanding of equivalence relations and canonical representatives.}
\CHECKLIST{
\begin{itemize}
\item Build DSU over 26 letters.
\item Union all paired letters with smallest-root policy.
\item Path compress on every find.
\item Map each baseStr letter via find to its representative.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item No pairs: answer equals baseStr.
\item Chains that enforce transitivity (a-b, b-c, \ldots).
\item Multiple merges from different chains.
\item Repeated characters in s1/s2/baseStr.
\item All letters in one class.
\item Disjoint classes with same sizes.
\item baseStr containing letters absent from any pair.
\item s1 and s2 including identical characters at positions.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Forgetting reflexivity if not using DSU (baseline must set $M[i][i]$).
\item Merging the smaller into the larger root (breaks minimal representative).
\item Missing path compression causing unnecessary overhead.
\item Off-by-one in letter to index mapping (use 97 for 'a').
\item Assuming non-lowercase letters.
\item Not handling empty s1/s2 (should be valid if lengths are zero).
\item Recomputing representatives without caching in non-DSU variants.
\item Mutating parent without checking same-set case.
\end{itemize}}
\FAILMODES{A graph BFS/DFS per character without union can pass but is slower. A DSU that does not enforce smallest root may output non-minimal representatives.}
\ELI{Make friendship groups of letters. For each group, pick the alphabetically first letter as the group's label. Replace each letter in the base string by its group's label to get the smallest possible string.}
\NotePages{3}

\end{document}