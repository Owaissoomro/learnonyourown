% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Lexicographically Small Enough}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1616/E}}
\LINE{DIFFICULTY / RATING}{2200}
\STATEMENT{You are given two strings $s$ and $t$ of equal length $n$. In one move, you can swap any two adjacent characters of the string $s$.

You need to find the minimal number of operations you need to make string $s$ lexicographically smaller than string $t$.

A string $a$ is lexicographically smaller than a string $b$ if and only if one of the following holds:
\begin{bullets}
\item $a$ is a prefix of $b$, but $a \ne b$;
\item in the first position where $a$ and $b$ differ, the string $a$ has a letter that appears earlier in the alphabet than the corresponding letter in $b$.
\end{bullets}

Input:

The first line of input contains one integer $q$ ($1 \le q \le 10{,}000$): the number of test cases.

The first line of each test case contains a single integer $n$ ($1 \le n \le 10^5$).

The second line of each test case contains the string $s$ consisting of $n$ lowercase English letters.

The third line of each test case contains the string $t$ consisting of $n$ lowercase English letters.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

Output:

For each test case, print in a separate line the minimal number of operations you need to make string $s$ lexicographically smaller than string $t$, or $-1$, if it is impossible.}
\BREAKDOWN{We must transform $s$ by adjacent swaps into some string $u$ with $u \prec t$ while minimizing the total swaps. Adjacent-swaps cost equals the inversion distance from the original index order to the chosen target arrangement. The decision of being lexicographically smaller is decided at the first differing index, so we can greedily grow an equal prefix to $t$ while tracking the best opportunity to place a strictly smaller letter.}
\ELI{Try to match $t$ from left to right; at each step, check the cheapest way to put any smaller letter than $t[i]$ next, and remember the best total cost; if you can continue matching $t[i]$ exactly, do so and keep going.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test:
\begin{bullets}
\item $n$ — integer, $1 \le n \le 10^5$.
\item $s$ — string of length $n$, lowercase English letters.
\item $t$ — string of length $n$, lowercase English letters.
\end{bullets}
Sum of $n$ over all tests $\le 2 \cdot 10^5$.}
\OUTPUTS{For each test case, a single integer: the minimal number of adjacent swaps to make some permutation of $s$ lexicographically smaller than $t$, or $-1$ if impossible.}
\SAMPLES{Example 1:
\begin{tcolorbox}
Input
\begin{verbatim}
3
2
ab
ba
1
b
a
3
abc
abc
\end{verbatim}
Output
\begin{verbatim}
0
-1
-1
\end{verbatim}
\end{tcolorbox}
Explanation:
\begin{bullets}
\item In the first test, $s=ab$ is already smaller than $t=ba$, so $0$.
\item In the second, no arrangement of $b$ is smaller than $a$.
\item In the third, the only arrangement equal to $t$ is not strictly smaller.
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s[0..n-1]$ be the initial string. Swapping adjacent characters corresponds to permuting the positions by adjacent transpositions. For a chosen target string $u$ that is a permutation of $s$, the minimal number of adjacent swaps to transform $s$ into $u$ equals the inversion count of the index sequence mapping $s$ to $u$. Our goal is:
\begin{BreakableEquation*}
\min \{\text{swaps}(s \to u) \mid u \text{ is a permutation of } s,\ u \prec t\}.
\end{BreakableEquation*}%
We characterize $u \prec t$ by the first index $i$ where $u[i] \ne t[i]$ and $u[i] < t[i]$.}
\varmapStart
\var{n}{length of the strings}
\var{s,t}{input strings}
\var{\pi}{permutation of positions of $s$ induced by adjacent swaps}
\var{u}{target string formed by permuting $s$ via $\pi$}
\var{C(\pi)}{adjacent-swap cost, equal to inversion count of $\pi$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
C(\pi) &= \#\{(i,j)\mid 0 \le i<j < n,\ \pi(i) > \pi(j)\},\\
\text{Ans} &= \min_{\pi}\ \bigl\{C(\pi)\ :\ s\circ \pi \prec t\bigr\}.
\end{aligned}
\]
}
\ASSUMPTIONS{Strings use the $26$ lowercase letters. Equal letters are indistinguishable for lexicographic comparison but are tracked by their positions for cost.}
\INVARIANTS{
\begin{bullets}
\item The cost to move a character at original position $p$ to the current front equals the number of still-alive positions before $p$.
\item Choosing a letter strictly smaller than $t[i]$ at position $i$ irrevocably makes the whole $u$ lexicographically smaller, so the suffix arrangement does not affect feasibility.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all distinct permutations $u$ of $s$, filter those with $u \prec t$, and compute the minimal adjacent-swap distance from $s$ to $u$ via inversion counting on a mapped index sequence.}
\ASSUMPTIONS{Feasible only for very small $n$ due to factorial blowup.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate all distinct permutations $u$ of $s$.
\item Keep only those with $u \prec t$.
\item Map $u$ back to a sequence of original indices of $s$ and count inversions in that sequence to get the swap cost.
\item Return the minimum cost over all candidates or $-1$ if none.
\end{algosteps}
\COMPLEXITY{Exponential in $n$ for enumeration, polynomial per permutation for inversion counting.}
\[
\begin{aligned}
T(n) &\in \Theta\bigl(\tfrac{n!}{\prod f_c!}\cdot (n\log n)\bigr),\quad \text{infeasible beyond tiny $n$},\\
S(n) &\in O(n + n!)\ \text{for storage if not streamed}.
\end{aligned}
\]
\CORRECTNESS{By definition of adjacent swaps, the inversion count on the index mapping equals the minimal number of adjacent transpositions to reach $u$. Enumerating all $u \prec t$ attains the minimum.}
\EDGECASES{Repeated letters, all letters identical, already smaller, and impossible cases.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from itertools import permutations
from collections import defaultdict

class BIT:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0] * (n + 1)
    def add(self, i: int, delta: int):
        i += 1
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i: int) -> int:
        if i < 0:
            return 0
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

def inversion_count(arr):
    n = len(arr)
    bit = BIT(n if n else 1)
    inv = 0
    for x in range(n):
        bit.add(x, 1)
    # count inversions in arr: number of i < j with arr[i] > arr[j]
    # standard approach traversing from right
    bit = BIT(n if n else 1)
    inv = 0
    for i in range(n - 1, -1, -1):
        ai = arr[i]
        inv += bit.sum(ai - 1)
        bit.add(ai, 1)
    return inv

def min_swaps_via_permutation_enumeration(s: str, t: str):
    n = len(s)
    if len(t) != n:
        return -1
    # Deduplicate permutations via set for tiny n
    best = None
    seen = set()
    for p in set(permutations(s, n)):
        u = ''.join(p)
        if u in seen:
            continue
        seen.add(u)
        if u >= t:
            continue
        # Map u to index sequence from s
        positions = {}
        for i, ch in enumerate(s):
            positions.setdefault(ch, []).append(i)
        idx_seq = []
        take_ptr = defaultdict(int)
        for ch in u:
            k = take_ptr[ch]
            idx_seq.append(positions[ch][k])
            take_ptr[ch] += 1
        cost = inversion_count(idx_seq)
        if best is None or cost < best:
            best = cost
    return -1 if best is None else best

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, []
    it = iter(data)
    q = int(next(it))
    tests = []
    for _ in range(q):
        n = int(next(it))
        s = next(it).strip()
        t = next(it).strip()
        tests.append((n, s, t))
    return q, tests

def solve_case(n, s, t):
    # Baseline: only safe for very small n. For larger n, fall back to -1 or small heuristic.
    if n <= 8:
        return min_swaps_via_permutation_enumeration(s, t)
    # Baseline intentionally conservative for large inputs
    # Could not compute within brute-force constraints
    return min_swaps_via_permutation_enumeration(s[:8], t[:8]) if n > 8 else -1

def solve_all():
    q, tests = read_input()
    out_lines = []
    for (n, s, t) in tests:
        ans = solve_case(n, s, t)
        out_lines.append(str(ans))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Tiny asserts for baseline core
    assert min_swaps_via_permutation_enumeration("ab", "ba") == 0
    assert min_swaps_via_permutation_enumeration("b", "a") == -1
    assert min_swaps_via_permutation_enumeration("abc", "abc") == -1
    # Uncomment to run I/O: solve_all()
    # solve_all()
\end{minted}
\VALIDATION{Checked basic cases: already smaller, impossible, and equality.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Greedy With Fenwick Tree and 26-Scan}
\WHICHFORMULA{Track the earliest available occurrence of each letter in $s$ by original position and maintain a Fenwick tree over alive positions. At step $i$, the additional cost to place a character at original position $p$ equals the count of alive positions before $p$. Check all letters strictly smaller than $t[i]$ to update a running minimum answer; then, if possible, place $t[i]$ itself to keep the prefix equal and continue.}
\ASSUMPTIONS{Alphabet size is $26$, so scanning all smaller letters per position is cheap; per-step costs are computed via a Fenwick tree in $O(\log n)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $26$ queues with the positions of each character in $s$.
\item Initialize a Fenwick tree with ones at all positions to represent alive indices.
\item Iterate $i=0$ to $n-1$:
  \begin{bullets}
  \item Compute the minimal cost among the earliest occurrences of letters $< t[i]$ via the Fenwick tree and update the answer candidate as current\_cost plus that minimal cost.
  \item If $t[i]$ is unavailable, stop; otherwise, pop its earliest occurrence, add its cost to current\_cost, and remove the position from the Fenwick tree.
  \end{bullets}
\item Return the best candidate or $-1$ if none was ever found.
\end{algosteps}
\COMPLEXITY{At each position we scan at most $26$ letters and compute constant many Fenwick queries or updates.}
\[
\begin{aligned}
T(n) &\in O\bigl(n \cdot 26 \cdot \log n\bigr),\qquad S(n) \in O(n + 26).
\end{aligned}
\]
\CORRECTNESS{Since lexicographic comparison is fixed at the first mismatch, the minimal way to become smaller at step $i$ is to take the earliest available occurrence of any character $< t[i]$. The global minimum is the minimum over all $i$ of the cost to match the prefix exactly up to $i-1$ plus that minimal deviation cost; the greedy accumulation of the equal prefix maintains feasibility and minimal prefix cost.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque

class BIT:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0] * (n + 1)
    def add(self, i: int, delta: int):
        i += 1
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i: int) -> int:
        if i < 0:
            return 0
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

INF = 10**20

def min_swaps_lex_smaller_greedy(s: str, t: str) -> int:
    n = len(s)
    if len(t) != n:
        return -1
    occ = [deque() for _ in range(26)]
    for i, ch in enumerate(s):
        occ[ord(ch) - 97].append(i)
    bit = BIT(n if n else 1)
    for i in range(n):
        bit.add(i, 1)
    ans = INF
    curr = 0
    for i in range(n):
        ti = ord(t[i]) - 97
        # Try any smaller letter
        best_smaller = INF
        for c in range(ti):
            if occ[c]:
                p = occ[c][0]
                cost = bit.sum(p) - 1
                if cost < best_smaller:
                    best_smaller = cost
        if best_smaller < INF:
            if curr + best_smaller < ans:
                ans = curr + best_smaller
        # Try to place t[i]
        if not occ[ti]:
            break
        p = occ[ti].popleft()
        curr += bit.sum(p) - 1
        bit.add(p, -1)
    return -1 if ans == INF else ans

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        q = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(q):
        n = int(next(it))
        s = next(it).decode()
        t = next(it).decode()
        tests.append((n, s, t))
    return q, tests

def solve_case(n, s, t):
    return min_swaps_lex_smaller_greedy(s, t)

def solve_all():
    q, tests = read_input()
    out = []
    for (n, s, t) in tests:
        out.append(str(solve_case(n, s, t)))
    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    # Basic checks for the improved solver
    assert min_swaps_lex_smaller_greedy("ab", "ba") == 0
    assert min_swaps_lex_smaller_greedy("b", "a") == -1
    assert min_swaps_lex_smaller_greedy("dcba", "abcd") == -1
    # Uncomment to run I/O: solve_all()
    # solve_all()
\end{minted}
\VALIDATION{Validated on simple positive, negative, and boundary-equality cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Greedy With Fenwick Tree; Proven Minimality}
\WHICHFORMULA{Maintain per-letter earliest positions and a Fenwick tree over alive indices. At position $i$, compute the minimal marginal cost to place any $c < t[i]$; the best global answer is the minimum over all $i$ of accumulated equal-prefix cost plus that marginal cost. Then continue by placing $t[i]$ if possible.}
\ASSUMPTIONS{Alphabet is small; multiple occurrences handled by queues; costs are exact via the Fenwick prefix counts.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize queues of positions for each letter in $s$ and a Fenwick tree with all ones.
\item Set accumulated cost to $0$ and answer to $+\infty$.
\item For $i=0$ to $n-1$:
\begin{bullets}
\item Let $B$ be the minimal cost among earliest occurrences of letters less than $t[i]$; update answer as $\min(\text{answer},\ \text{accumulated} + B)$ if any exists.
\item If there is no remaining $t[i]$, stop; otherwise place it, adding its cost and removing that position.
\end{bullets}
\item If answer is still $+\infty$, return $-1$; otherwise return it.
\end{algosteps}
\OPTIMALITY{Any solution that first differs at index $i$ must pay exactly the accumulated cost to match $t[0..i-1]$ plus the minimal cost to place some $c < t[i]$ at $i$. Taking the earliest available occurrence of each candidate letter is optimal for that marginal choice because it minimizes crossings. Thus the minimum over all $i$ is achieved by the described greedy evaluation.}
\COMPLEXITY{Each step performs at most $26$ Fenwick queries and constant-time updates.}
\[
\begin{aligned}
T(n) &\in O\bigl(n \cdot 26 \cdot \log n\bigr),\qquad S(n) \in O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

class BIT:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0] * (n + 1)
    def add(self, i: int, delta: int):
        i += 1
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i: int) -> int:
        if i < 0:
            return 0
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

INF = 10**20

def min_swaps_lex_smaller(s: str, t: str) -> int:
    n = len(s)
    if len(t) != n:
        return -1
    occ = [deque() for _ in range(26)]
    for i, ch in enumerate(s):
        occ[ord(ch) - 97].append(i)
    bit = BIT(n if n else 1)
    for i in range(n):
        bit.add(i, 1)
    ans = INF
    curr = 0
    for i in range(n):
        ti = ord(t[i]) - 97
        best_smaller = INF
        # scan letters smaller than t[i]
        for c in range(ti):
            if occ[c]:
                p = occ[c][0]
                cost = bit.sum(p) - 1
                if cost < best_smaller:
                    best_smaller = cost
        if best_smaller < INF:
            cand = curr + best_smaller
            if cand < ans:
                ans = cand
        # match t[i] if possible, else stop
        if not occ[ti]:
            break
        p = occ[ti].popleft()
        curr += bit.sum(p) - 1
        bit.add(p, -1)
    return -1 if ans == INF else ans

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        q = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(q):
        n = int(next(it))
        s = next(it).decode()
        t = next(it).decode()
        tests.append((n, s, t))
    return q, tests

def solve_case(n, s, t):
    return min_swaps_lex_smaller(s, t)

def solve_all():
    q, tests = read_input()
    out_lines = []
    for (n, s, t) in tests:
        out_lines.append(str(solve_case(n, s, t)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert min_swaps_lex_smaller("ab", "ba") == 0
    assert min_swaps_lex_smaller("b", "a") == -1
    assert min_swaps_lex_smaller("az", "ba") == 0  # "az" < "ba" already
    # Uncomment to run I/O:
    # solve_all()
\end{minted}
\VALIDATION{Three asserts covering positive, impossible, and trivial already-smaller scenarios.}
\RESULT{Print the minimal number of swaps or $-1$ if no arrangement of $s$ is lexicographically smaller than $t$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the core function on hand-crafted cases: already smaller, impossible, equal multiset but cannot be smaller, repeated letters, larger random small cases checked versus brute force.}
\LINE{CROSS-CHECKS}{For small $n \le 8$, compare the greedy answer with the brute-force baseline; for larger random cases, sanity-check monotonicity when appending sentinel large letters to $t$.}
\LINE{EDGE-CASE GENERATOR}{Generate strings with all equal letters, strictly increasing or decreasing letters, and near-equal $s$ and $t$ differing at late positions.}
\begin{minted}{python}
import random
from collections import defaultdict, deque

# Deterministic generators for boundaries, degenerates, adversarials
def gen_all_equal(n, ch='a'):
    s = ch * n
    t = ch * n
    return s, t

def gen_inc_dec(n):
    alpha = 'abcdefghijklmnopqrstuvwxyz'
    s = ''.join(alpha[i % 26] for i in range(n))
    t = ''.join(alpha[(i + 1) % 26] for i in range(n))
    return s, t

def gen_close_pair(n, seed=0):
    random.seed(seed)
    alpha = 'abc'
    s = ''.join(random.choice(alpha) for _ in range(n))
    t = s
    # force t to be slightly larger at a late position if possible
    for i in range(n - 1, -1, -1):
        if t[i] != 'c':
            t = t[:i] + chr(ord(t[i]) + 1) + t[i+1:]
            break
    return s, t

# Reference Code (Final Solver)
import sys

class BIT:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0] * (n + 1)
    def add(self, i: int, delta: int):
        i += 1
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i: int) -> int:
        if i < 0:
            return 0
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

INF = 10**20

def min_swaps_lex_smaller(s: str, t: str) -> int:
    n = len(s)
    if len(t) != n:
        return -1
    occ = [deque() for _ in range(26)]
    for i, ch in enumerate(s):
        occ[ord(ch) - 97].append(i)
    bit = BIT(n if n else 1)
    for i in range(n):
        bit.add(i, 1)
    ans = INF
    curr = 0
    for i in range(n):
        ti = ord(t[i]) - 97
        best_smaller = INF
        for c in range(ti):
            if occ[c]:
                p = occ[c][0]
                cost = bit.sum(p) - 1
                if cost < best_smaller:
                    best_smaller = cost
        if best_smaller < INF:
            cand = curr + best_smaller
            if cand < ans:
                ans = cand
        if not occ[ti]:
            break
        p = occ[ti].popleft()
        curr += bit.sum(p) - 1
        bit.add(p, -1)
    return -1 if ans == INF else ans

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        q = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(q):
        n = int(next(it))
        s = next(it).decode()
        t = next(it).decode()
        tests.append((n, s, t))
    return q, tests

def solve_case(n, s, t):
    return min_swaps_lex_smaller(s, t)

def solve_all():
    q, tests = read_input()
    out_lines = []
    for (n, s, t) in tests:
        out_lines.append(str(solve_case(n, s, t)))
    sys.stdout.write("\n".join(out_lines))

# Quick sanity asserts
assert min_swaps_lex_smaller("ab", "ba") == 0
assert min_swaps_lex_smaller("b", "a") == -1
s, t = gen_all_equal(3, 'a')
assert min_swaps_lex_smaller(s, t) == -1
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

class BIT:
    def __init__(self, n: int):
        self.n = n
        self.bit = [0] * (n + 1)
    def add(self, i: int, delta: int):
        i += 1
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i: int) -> int:
        if i < 0:
            return 0
        s = 0
        i += 1
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

INF = 10**20

def min_swaps_lex_smaller(s: str, t: str) -> int:
    n = len(s)
    if len(t) != n:
        return -1
    occ = [deque() for _ in range(26)]
    for i, ch in enumerate(s):
        occ[ord(ch) - 97].append(i)
    bit = BIT(n if n else 1)
    for i in range(n):
        bit.add(i, 1)
    ans = INF
    curr = 0
    for i in range(n):
        ti = ord(t[i]) - 97
        best_smaller = INF
        for c in range(ti):
            if occ[c]:
                p = occ[c][0]
                cost = bit.sum(p) - 1
                if cost < best_smaller:
                    best_smaller = cost
        if best_smaller < INF:
            cand = curr + best_smaller
            if cand < ans:
                ans = cand
        if not occ[ti]:
            break
        p = occ[ti].popleft()
        curr += bit.sum(p) - 1
        bit.add(p, -1)
    return -1 if ans == INF else ans

def read_input():
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    try:
        q = int(next(it))
    except StopIteration:
        return 0, []
    tests = []
    for _ in range(q):
        n = int(next(it))
        s = next(it).decode()
        t = next(it).decode()
        tests.append((n, s, t))
    return q, tests

def solve_case(n, s, t):
    return min_swaps_lex_smaller(s, t)

def solve_all():
    q, tests = read_input()
    out_lines = []
    for (n, s, t) in tests:
        out_lines.append(str(solve_case(n, s, t)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # simple self-checks
    assert min_swaps_lex_smaller("ab", "ba") == 0
    assert min_swaps_lex_smaller("b", "a") == -1
    assert min_swaps_lex_smaller("az", "ba") == 0
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Greedily grow an equal prefix to $t$ while tracking the cheapest opportunity to place a strictly smaller letter, using a Fenwick tree to get exact swap costs.}
\WHY{Classic interview pattern: lexicographic minimization with adjacent swaps, combining data structures (Fenwick tree) with greedy choice over a small alphabet.}
\CHECKLIST{
\begin{bullets}
\item Build queues of positions for each letter in $s$.
\item Initialize Fenwick tree of alive positions.
\item For each $i$, compute minimal smaller-letter cost and update answer.
\item If $t[i]$ not available, stop; else place it and update costs.
\item Print best answer or $-1$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $s$ already smaller than $t$ at position $0$.
\item No letter smaller than $t[0]$ exists anywhere in $s$.
\item All letters identical in both strings.
\item $s$ can match $t$ exactly but never be strictly smaller.
\item Repeated letters with sparse earlier occurrences.
\item $n=1$ trivial cases.
\item Very unbalanced frequency distributions.
\item Early unavailability of $t[i]$ halts matching.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Off by one in Fenwick prefix sums; the cost is $\text{sum}(p) - 1$.
\item Forgetting to remove used positions from the Fenwick tree.
\item Using the wrong occurrence (not the earliest) for marginal cost.
\item Overflow in other languages; use 64-bit for costs.
\item Not resetting per test case data structures.
\item Mixing $0$-indexed and $1$-indexed Fenwick operations.
\item Assuming feasibility when the equal prefix fully matches $t$.
\item Scanning all $26$ letters but forgetting empty queues.
\end{bullets}}
\FAILMODES{Brute force explodes beyond tiny $n$; greedy without a Fenwick tree misestimates swap costs; matching $t$ greedily without considering smaller letters yields suboptimal or impossible outcomes. The presented method avoids these by exact marginal cost computation and global minimum over all mismatch positions.}
\ELI{Keep the string arranged like $t$ as long as possible, and at each step look whether you can cheaply slip in a smaller letter to win immediately. A Fenwick tree tells you how many swaps it takes to bubble any candidate to the front. The best such opportunity across the positions is the answer.}
\NotePages{3}

\end{document}