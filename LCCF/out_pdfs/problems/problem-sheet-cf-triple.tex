% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Triple}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1119/H}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{You have received your birthday gifts — $n$ triples of integers! The $i$-th of them is $\{ a_{i}, b_{i}, c_{i} \}$. All numbers are greater than or equal to $0$, and strictly smaller than $2^{k}$, where $k$ is a fixed integer.

One day, you felt tired playing with triples. So you came up with three new integers $x$, $y$, $z$, and then formed $n$ arrays. The $i$-th array consists of $a_i$ repeated $x$ times, $b_i$ repeated $y$ times and $c_i$ repeated $z$ times. Thus, each array has length $(x + y + z)$.

You want to choose exactly one integer from each array such that the XOR (bitwise exclusive or) of them is equal to $t$. Output the number of ways to choose the numbers for each $t$ between $0$ and $2^{k} - 1$, inclusive, modulo $998{,}244{,}353$.

Input:
The first line contains two integers $n$ and $k$ ($1 \le n \le 10^{5}$, $1 \le k \le 17$) — the number of arrays and the binary length of all numbers.

The second line contains three integers $x$, $y$, $z$ ($0 \le x,y,z \le 10^{9}$) — the integers you chose.

Then $n$ lines follow. The $i$-th of them contains three integers $a_{i}$, $b_{i}$ and $c_{i}$ ($0 \le a_{i} , b_{i} , c_{i} \le 2^{k} - 1$) — the integers forming the $i$-th array.

Output:
Print a single line containing $2^{k}$ integers. The $i$-th of them should be the number of ways to choose exactly one integer from each array so that their XOR is equal to $t = i-1$ modulo $998{,}244{,}353$.

Note:
In the first example, the array we formed is $(1, 0, 0, 1, 1, 1)$, we have two choices to get $0$ as the XOR and four choices to get $1$.

In the second example, two arrays are $(0, 1, 1, 2)$ and $(1, 2, 2, 3)$. There are sixteen $(4 \cdot 4)$ choices in total, $4$ of them ($1 \oplus 1$ and $2 \oplus 2$, two options for each) give $0$, $2$ of them ($0 \oplus 1$ and $2 \oplus 3$) give $1$, $4$ of them ($0 \oplus 2$ and $1 \oplus 3$, two options for each) give $2$, and finally $6$ of them ($0 \oplus 3$, $2 \oplus 1$ and four options for $1 \oplus 2$) give $3$.}
\BREAKDOWN{Reformulate as computing the XOR-convolution of $n$ length-$2^k$ distributions, each supported on three values with multiplicities $x,y,z$. Apply the Walsh--Hadamard transform so the $n$-fold convolution becomes pointwise products. Exploit structure to aggregate over only three frequency arrays.}
\ELI{Turn three choices per triple into signs in the Walsh domain, multiply them up, then transform back.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integers $n, k$.
- Integers $x, y, z$.
- $n$ lines of triples $(a_i,b_i,c_i)$. All values are in $[0,2^k-1]$.}
\OUTPUTS{One line with $2^k$ integers: for each $t=0,\ldots,2^k-1$, the number of ways modulo $998{,}244{,}353$.}
\SAMPLES{Example sanity checks:
- $n=1,k=2$, $(x,y,z)=(1,0,0)$, triple $(a,b,c)=(1,2,3)$. Output: $[0,1,0,0]$.
- $n=2,k=2$, $(x,y,z)=(1,1,0)$. Triples $(0,1,0)$ and $(0,2,0)$. Output: $[1,1,1,1]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For each $i$, define a distribution $D_i \in \mathbb{N}^{\{0,\ldots,M-1\}}$ with $M=2^k$:
$D_i[a_i]{+}{=}x$, $D_i[b_i]{+}{=}y$, $D_i[c_i]{+}{=}z$. We need $H = D_1 \,\widehat{\oplus}\, D_2 \,\widehat{\oplus}\,\cdots\,\widehat{\oplus}\, D_n$, where $\widehat{\oplus}$ denotes XOR-convolution; output $H[t] \bmod 998{,}244{,}353$.}
\varmapStart
\var{M}{domain size $2^k$}
\var{A}{XOR of all $a_i$}
\var{p_i}{${}=a_i \oplus b_i$}
\var{q_i}{${}=a_i \oplus c_i$}
\var{r_i}{${}=b_i \oplus c_i = p_i \oplus q_i$}
\varmapEnd
\GOVERN{
\[
\widehat{D_i}(s) \;=\; \sum_{v} D_i[v]\,(-1)^{\langle s,v\rangle}
\;=\; (-1)^{\langle s,a_i\rangle}\bigl(x + y(-1)^{\langle s,p_i\rangle} + z(-1)^{\langle s,q_i\rangle}\bigr),
\]
\[
\widehat{H}(s) \;=\; \prod_{i=1}^n \widehat{D_i}(s),\qquad
H \;=\; \frac{1}{M}\,\mathsf{WH}(\widehat{H}),
\]
where $\mathsf{WH}$ is the Walsh transform with kernel $(-1)^{\langle s,t\rangle}$.}
\ASSUMPTIONS{XOR is bitwise over $k$ bits. Numbers fit standard integer types. $998{,}244{,}353$ is prime and $2$ is invertible modulo it.}
\INVARIANTS{The Walsh domain product equals time-domain XOR-convolution. Multiplying by $(-1)^{\langle s,A\rangle}$ in frequency shifts $H$ by XOR with $A$ in time domain.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Iterative DP over XOR states: start with $\delta_0$, and for each triple add contributions at $a_i,b_i,c_i$ with multiplicities $x,y,z$.}
\ASSUMPTIONS{Works for small $k$ or $n$ only; $O(n\cdot 2^k)$ time, $O(2^k)$ memory.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $F[0]=1$, all others $0$.
\item For each $i$, build a sparse increment: at $a_i$ add $x$, at $b_i$ add $y$, at $c_i$ add $z$ (merge equal keys).
\item New array $G[t]=\sum_{v\in\{a_i,b_i,c_i\}} F[t\oplus v]\cdot \text{mult}(v) \bmod \mathrm{MOD}$. Set $F\leftarrow G$.
\end{algosteps}
\COMPLEXITY{$T(n)=O(n\cdot 2^k)$, $S(n)=O(2^k)$.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^n O(2^k) \\
     &= O(n\cdot 2^k).
\end{aligned}
\]
\CORRECTNESS{Each stage computes the XOR-convolution with the $i$-th distribution. Associativity yields the $n$-fold convolution.}
\EDGECASES{Handle duplicated values when $a_i=b_i$ etc. Multiplicities can be zero.}
\textbf{Code (Baseline)}
\begin{minted}{python}
#!/usr/bin/env python3
import sys

MOD = 998244353

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); k = int(next(it))
    x = int(next(it)); y = int(next(it)); z = int(next(it))
    triples = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        triples.append((a, b, c))
    return n, k, x, y, z, triples

def solve_case_baseline(n, k, x, y, z, triples):
    M = 1 << k
    F = [0] * M
    F[0] = 1
    for (a, b, c) in triples:
        mults = {}
        mults[a] = mults.get(a, 0) + x
        mults[b] = mults.get(b, 0) + y
        mults[c] = mults.get(c, 0) + z
        G = [0] * M
        for t in range(M):
            ft = F[t]
            if ft == 0:
                continue
            for v, m in mults.items():
                G[t ^ v] = (G[t ^ v] + ft * (m % MOD)) % MOD
        F = G
    return F

def solve_all_baseline(data: str):
    n, k, x, y, z, triples = read_input(data)
    return solve_case_baseline(n, k, x, y, z, triples)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Self-tests
        n, k, x, y, z = 1, 2, 1, 0, 0
        triples = [(1, 2, 3)]
        ans = solve_case_baseline(n, k, x, y, z, triples)
        assert ans == [0,1,0,0]
        n, k, x, y, z = 2, 2, 1, 1, 0
        triples = [(0,1,0), (0,2,0)]
        ans = solve_case_baseline(n, k, x, y, z, triples)
        assert ans == [1,1,1,1]
        n, k, x, y, z = 2, 1, 2, 1, 1
        triples = [(0,1,1),(1,0,1)]
        ref = solve_case_baseline(n, k, x, y, z, triples)
        assert len(ref) == (1<<k)
        print("OK")
        return
    out = solve_all_baseline(data)
    print(" ".join(str(v % MOD) for v in out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Mini asserts cover distinct and duplicated choices, and a small mixed case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized via Walsh--Hadamard Transform Structure}
\WHICHFORMULA{Use $\widehat{D_i}(s)=(-1)^{\langle s,a_i\rangle}\bigl(x+y\varepsilon_p+z\varepsilon_q\bigr)$ where $\varepsilon_p=(-1)^{\langle s,p_i\rangle}$ and $\varepsilon_q=(-1)^{\langle s,q_i\rangle}$. Aggregate by counts of $(\varepsilon_p,\varepsilon_q)\in\{\pm1\}^2$ using only three Walsh transforms of frequency arrays of $p_i,q_i,r_i$.}
\ASSUMPTIONS{We can compute FWHT over integers for counts (range $[-n,n]$) and over modulo for the final inverse.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $A=\bigoplus_i a_i$, and frequency arrays $P[v]=|\{i:p_i=v\}|$, $Q[v]=|\{i:q_i=v\}|$, $R[v]=|\{i:r_i=v\}|$ for $v\in[0,M)$.
\item FWHT over integers on $P,Q,R$ to obtain $S_1,S_2,S_3$ where $S_1[s]=\sum_v P[v](-1)^{\langle s,v\rangle}$, etc.
\item For each $s$, derive counts
\[
\begin{aligned}
c_{++}&=\tfrac14(n+S_1+S_2+S_3),\quad
c_{-+}=\tfrac14(n-S_1+S_2-S_3),\\
c_{+-}&=\tfrac14(n+S_1-S_2-S_3),\quad
c_{--}=\tfrac14(n-S_1-S_2+S_3).
\end{aligned}
\]
\item Define $f_{ab}=(x+ay+bz)\bmod \mathrm{MOD}$ for $a,b\in\{\pm1\}$, compute
$T[s]=(-1)^{\langle s,A\rangle}\cdot f_{++}^{c_{++}} f_{-+}^{c_{-+}} f_{+-}^{c_{+-}} f_{--}^{c_{--}} \bmod \mathrm{MOD}$.
\item Inverse XOR-FWHT on $T$ (same butterfly) and scale by $(2^{-k}\bmod \mathrm{MOD})$.
\end{algosteps}
\COMPLEXITY{Three integer FWHTs $O(M\log M)$, one modular FWHT $O(M\log M)$, plus $O(M)$ pointwise exponentiations and multiplies. Beats baseline by removing factor $n$.}
\[
\begin{aligned}
T(n) &= O(M\log M) + O(M) = O(2^k k),\qquad S(n)=O(2^k).
\end{aligned}
\]
\CORRECTNESS{Character-based decomposition shows per-$s$ products depend only on the four counts of $(\varepsilon_p,\varepsilon_q)$, which are linear combinations of $S_1,S_2,S_3$. The global $(-1)^{\langle s,A\rangle}$ shifts the final answer by $A$ as required.}
\textbf{Code (Improved)}
\begin{minted}{python}
#!/usr/bin/env python3
import sys

MOD = 998244353

def fwht_int(a):
    n = len(a)
    step = 1
    while step < n:
        for i in range(0, n, step << 1):
            for j in range(i, i + step):
                u = a[j]
                v = a[j + step]
                a[j] = u + v
                a[j + step] = u - v
        step <<= 1

def fwht_mod(a):
    n = len(a)
    step = 1
    while step < n:
        for i in range(0, n, step << 1):
            for j in range(i, i + step):
                u = a[j]
                v = a[j + step]
                a[j] = (u + v) % MOD
                a[j + step] = (u - v) % MOD
        step <<= 1

def solve_case_improved(n, k, x, y, z, triples):
    M = 1 << k
    P = [0] * M
    Q = [0] * M
    R = [0] * M
    A = 0
    for (a, b, c) in triples:
        p = a ^ b
        q = a ^ c
        r = b ^ c  # or p ^ q
        P[p] += 1
        Q[q] += 1
        R[r] += 1
        A ^= a
    S1 = P[:]  # integer FWHT
    S2 = Q[:]
    S3 = R[:]
    fwht_int(S1)
    fwht_int(S2)
    fwht_int(S3)
    f_pp = (x + y + z) % MOD
    f_mp = (x - y + z) % MOD
    f_pm = (x + y - z) % MOD
    f_mm = (x - y - z) % MOD
    T = [0] * M
    for s in range(M):
        s1 = S1[s]; s2 = S2[s]; s3 = S3[s]
        c_pp = (n + s1 + s2 + s3) // 4
        c_mp = (n - s1 + s2 - s3) // 4
        c_pm = (n + s1 - s2 - s3) // 4
        c_mm = (n - s1 - s2 + s3) // 4
        val = 1
        if c_pp:
            val = (val * pow(f_pp, c_pp, MOD)) % MOD
        if c_mp:
            val = (val * pow(f_mp, c_mp, MOD)) % MOD
        if c_pm:
            val = (val * pow(f_pm, c_pm, MOD)) % MOD
        if c_mm:
            val = (val * pow(f_mm, c_mm, MOD)) % MOD
        if (bin(s & A).count("1") & 1) == 1:
            val = (-val) % MOD
        T[s] = val
    fwht_mod(T)
    inv2 = (MOD + 1) // 2
    invM = pow(inv2, k, MOD)  # (2^{-k} mod MOD)
    for i in range(M):
        T[i] = (T[i] * invM) % MOD
    return T

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); k = int(next(it))
    x = int(next(it)); y = int(next(it)); z = int(next(it))
    triples = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        triples.append((a, b, c))
    return n, k, x, y, z, triples

def solve_all_improved(data: str):
    n, k, x, y, z, triples = read_input(data)
    return solve_case_improved(n, k, x, y, z, triples)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Cross-check with baseline on tiny cases
        def brute(n,k,x,y,z,triples):
            M = 1<<k
            F=[0]*M; F[0]=1
            for (a,b,c) in triples:
                mults={}
                mults[a]=mults.get(a,0)+x
                mults[b]=mults.get(b,0)+y
                mults[c]=mults.get(c,0)+z
                G=[0]*M
                for t in range(M):
                    ft=F[t]
                    if ft==0: continue
                    for v,m in mults.items():
                        G[t^v]=(G[t^v]+ft*(m%MOD))%MOD
                F=G
            return F
        n,k,x,y,z=1,2,1,0,0
        triples=[(1,2,3)]
        assert solve_case_improved(n,k,x,y,z,triples)==brute(n,k,x,y,z,triples)
        n,k,x,y,z=2,2,1,1,0
        triples=[(0,1,0),(0,2,0)]
        assert solve_case_improved(n,k,x,y,z,triples)==brute(n,k,x,y,z,triples)
        n,k,x,y,z=3,3,2,1,1
        triples=[(1,2,3),(3,5,1),(7,0,4)]
        assert solve_case_improved(n,k,x,y,z,triples)==brute(n,k,x,y,z,triples)
        print("OK")
        return
    out = solve_all_improved(data)
    print(" ".join(str(v % MOD) for v in out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Compared with baseline on three deterministic small cases (including mixed duplicates and shifts).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Compute three integer FWHTs of $P,Q,R$, raise four scalars $x\pm y \pm z$ to counts, assemble $T[s]$ with the global $A$-modulation, then inverse FWHT to obtain the answer.}
\ASSUMPTIONS{Applicable for all $n\le 10^5$, $k\le 17$. Uses only $O(2^k)$ memory.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $P,Q,R$ and $A$.
\item Integer FWHT on $P,Q,R$ to get $S_1,S_2,S_3$.
\item For each $s$, compute $c_{\pm\pm}$ via quartering formulas, then $T[s]$ from four powers and apply $(-1)^{\langle s,A\rangle}$.
\item Modular FWHT on $T$, scale by $(2^{-k}\bmod \mathrm{MOD})$.
\item Output $T$.
\end{algosteps}
\OPTIMALITY{Any XOR-convolution over domain $2^k$ has an $\Omega(2^k\log 2^k)$ lower bound under standard models; this meets it up to small constants.}
\COMPLEXITY{$O(2^k \cdot k)$ time and $O(2^k)$ space.}
\[
\begin{aligned}
T(n) &= 4\cdot O(2^k k) + O(2^k) = O(2^k k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
#!/usr/bin/env python3
import sys

MOD = 998244353

def fwht_int(a):
    n = len(a)
    step = 1
    while step < n:
        for i in range(0, n, step << 1):
            for j in range(i, i + step):
                u = a[j]
                v = a[j + step]
                a[j] = u + v
                a[j + step] = u - v
        step <<= 1

def fwht_mod(a):
    n = len(a)
    step = 1
    while step < n:
        for i in range(0, n, step << 1):
            for j in range(i, i + step):
                u = a[j]
                v = a[j + step]
                a[j] = (u + v) % MOD
                a[j + step] = (u - v) % MOD
        step <<= 1

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); k = int(next(it))
    x = int(next(it)); y = int(next(it)); z = int(next(it))
    triples = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        triples.append((a, b, c))
    return n, k, x, y, z, triples

def solve_case(n, k, x, y, z, triples):
    M = 1 << k
    P = [0] * M
    Q = [0] * M
    R = [0] * M
    A = 0
    for (a, b, c) in triples:
        p = a ^ b
        q = a ^ c
        r = b ^ c  # or p ^ q
        P[p] += 1
        Q[q] += 1
        R[r] += 1
        A ^= a
    S1 = P[:]; S2 = Q[:]; S3 = R[:]
    fwht_int(S1)
    fwht_int(S2)
    fwht_int(S3)
    f_pp = (x + y + z) % MOD
    f_mp = (x - y + z) % MOD
    f_pm = (x + y - z) % MOD
    f_mm = (x - y - z) % MOD
    T = [0] * M
    for s in range(M):
        s1 = S1[s]; s2 = S2[s]; s3 = S3[s]
        c_pp = (n + s1 + s2 + s3) // 4
        c_mp = (n - s1 + s2 - s3) // 4
        c_pm = (n + s1 - s2 - s3) // 4
        c_mm = (n - s1 - s2 + s3) // 4
        val = 1
        if c_pp:
            val = (val * pow(f_pp, c_pp, MOD)) % MOD
        if c_mp:
            val = (val * pow(f_mp, c_mp, MOD)) % MOD
        if c_pm:
            val = (val * pow(f_pm, c_pm, MOD)) % MOD
        if c_mm:
            val = (val * pow(f_mm, c_mm, MOD)) % MOD
        if (bin(s & A).count("1") & 1) == 1:
            val = (-val) % MOD
        T[s] = val
    fwht_mod(T)
    inv2 = (MOD + 1) // 2
    invM = pow(inv2, k, MOD)
    for i in range(M):
        T[i] = (T[i] * invM) % MOD
    return T

def solve_all(data: str):
    n, k, x, y, z, triples = read_input(data)
    return solve_case(n, k, x, y, z, triples)

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Exactly 3 asserts
        # 1) Simple delta
        n, k, x, y, z = 1, 2, 1, 0, 0
        triples = [(1, 2, 3)]
        out = solve_case(n, k, x, y, z, triples)
        assert out == [0,1,0,0]
        # 2) All ones
        n, k, x, y, z = 2, 2, 1, 1, 0
        triples = [(0,1,0),(0,2,0)]
        out = solve_case(n, k, x, y, z, triples)
        assert out == [1,1,1,1]
        # 3) Cross-check with small brute
        def brute(n,k,x,y,z,triples):
            M=1<<k; F=[0]*M; F[0]=1
            for (a,b,c) in triples:
                mults={}
                mults[a]=mults.get(a,0)+x
                mults[b]=mults.get(b,0)+y
                mults[c]=mults.get(c,0)+z
                G=[0]*M
                for t in range(M):
                    ft=F[t]
                    if ft==0: continue
                    for v,m in mults.items():
                        G[t^v]=(G[t^v]+ft*(m%MOD))%MOD
                F=G
            return F
        n,k,x,y,z=3,3,2,1,1
        triples=[(1,2,3),(3,5,1),(7,0,4)]
        out = solve_case(n,k,x,y,z,triples)
        assert out == brute(n,k,x,y,z,triples)
        print("OK")
        return
    out = solve_all(data)
    print(" ".join(str(v % MOD) for v in out))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three deterministic asserts, including a brute-force cross-check on $k=3$.}
\RESULT{Outputs the count for each $t\in[0,2^k)$, modulo $998{,}244{,}353$, as a single line.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests verify edge multiplicities, uniform distributions, and a nontrivial mixed case against brute force.}
\LINE{CROSS-CHECKS}{Baseline DP vs. optimal FWHT on small $k$ confirm agreement.}
\LINE{EDGE-CASE GENERATOR}{Cover zeros in $(x,y,z)$, duplicated values ($a_i=b_i$, etc.), and $A$-shift behavior.}
\begin{minted}{python}
#!/usr/bin/env python3
import sys
from typing import List, Tuple

MOD = 998244353

def fwht_int(a: List[int]) -> None:
    n = len(a); step = 1
    while step < n:
        for i in range(0, n, step << 1):
            for j in range(i, i + step):
                u = a[j]; v = a[j + step]
                a[j] = u + v
                a[j + step] = u - v
        step <<= 1

def fwht_mod(a: List[int]) -> None:
    n = len(a); step = 1
    while step < n:
        for i in range(0, n, step << 1):
            for j in range(i, i + step):
                u = a[j]; v = a[j + step]
                a[j] = (u + v) % MOD
                a[j + step] = (u - v) % MOD
        step <<= 1

def read_input(s: str) -> Tuple[int,int,int,int,int,List[Tuple[int,int,int]]]:
    it = iter(s.strip().split())
    n = int(next(it)); k = int(next(it))
    x = int(next(it)); y = int(next(it)); z = int(next(it))
    triples = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        triples.append((a,b,c))
    return n,k,x,y,z,triples

def solve_case(n: int, k: int, x: int, y: int, z: int, triples: List[Tuple[int,int,int]]) -> List[int]:
    M = 1 << k
    P = [0]*M; Q = [0]*M; R = [0]*M
    A = 0
    for (a,b,c) in triples:
        p = a ^ b; q = a ^ c; r = b ^ c
        P[p] += 1; Q[q] += 1; R[r] += 1
        A ^= a
    S1, S2, S3 = P[:], Q[:], R[:]
    fwht_int(S1); fwht_int(S2); fwht_int(S3)
    f_pp = (x + y + z) % MOD
    f_mp = (x - y + z) % MOD
    f_pm = (x + y - z) % MOD
    f_mm = (x - y - z) % MOD
    T = [0]*M
    for s in range(M):
        s1, s2, s3 = S1[s], S2[s], S3[s]
        c_pp = (n + s1 + s2 + s3) // 4
        c_mp = (n - s1 + s2 - s3) // 4
        c_pm = (n + s1 - s2 - s3) // 4
        c_mm = (n - s1 - s2 + s3) // 4
        v = 1
        if c_pp: v = (v * pow(f_pp, c_pp, MOD)) % MOD
        if c_mp: v = (v * pow(f_mp, c_mp, MOD)) % MOD
        if c_pm: v = (v * pow(f_pm, c_pm, MOD)) % MOD
        if c_mm: v = (v * pow(f_mm, c_mm, MOD)) % MOD
        if (bin(s & A).count("1") & 1) == 1:
            v = (-v) % MOD
        T[s] = v
    fwht_mod(T)
    inv2 = (MOD + 1) // 2
    invM = pow(inv2, k, MOD)
    for i in range(M):
        T[i] = (T[i] * invM) % MOD
    return T

def brute(n,k,x,y,z,triples):
    M=1<<k; F=[0]*M; F[0]=1
    for (a,b,c) in triples:
        mults={}
        mults[a]=mults.get(a,0)+x
        mults[b]=mults.get(b,0)+y
        mults[c]=mults.get(c,0)+z
        G=[0]*M
        for t in range(M):
            ft=F[t]
            if ft==0: continue
            for v,m in mults.items():
                G[t^v]=(G[t^v]+ft*(m%MOD))%MOD
        F=G
    return F

def reference_main():
    data = sys.stdin.read()
    if not data.strip():
        # Tiny deterministic tests and cross-checks
        n,k,x,y,z=1,2,1,0,0
        triples=[(1,2,3)]
        assert solve_case(n,k,x,y,z,triples)==[0,1,0,0]
        n,k,x,y,z=2,2,1,1,0
        triples=[(0,1,0),(0,2,0)]
        assert solve_case(n,k,x,y,z,triples)==[1,1,1,1]
        n,k,x,y,z=3,3,2,1,1
        triples=[(1,2,3),(3,5,1),(7,0,4)]
        assert solve_case(n,k,x,y,z,triples)==brute(n,k,x,y,z,triples)
        print("OK")
        return
    n,k,x,y,z,triples = read_input(data)
    out = solve_case(n,k,x,y,z,triples)
    print(" ".join(str(v%MOD) for v in out))

if __name__ == "__main__":
    reference_main()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
#!/usr/bin/env python3
import sys

MOD = 998244353

def fwht_int(a):
    n = len(a); step = 1
    while step < n:
        for i in range(0, n, step << 1):
            for j in range(i, i + step):
                u = a[j]; v = a[j + step]
                a[j] = u + v
                a[j + step] = u - v
        step <<= 1

def fwht_mod(a):
    n = len(a); step = 1
    while step < n:
        for i in range(0, n, step << 1):
            for j in range(i, i + step):
                u = a[j]; v = a[j + step]
                a[j] = (u + v) % MOD
                a[j + step] = (u - v) % MOD
        step <<= 1

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); k = int(next(it))
    x = int(next(it)); y = int(next(it)); z = int(next(it))
    triples = []
    for _ in range(n):
        a = int(next(it)); b = int(next(it)); c = int(next(it))
        triples.append((a, b, c))
    return n, k, x, y, z, triples

def solve_case(n, k, x, y, z, triples):
    M = 1 << k
    P = [0] * M; Q = [0] * M; R = [0] * M
    A = 0
    for (a, b, c) in triples:
        p = a ^ b; q = a ^ c; r = b ^ c
        P[p] += 1; Q[q] += 1; R[r] += 1
        A ^= a
    S1, S2, S3 = P[:], Q[:], R[:]
    fwht_int(S1); fwht_int(S2); fwht_int(S3)
    f_pp = (x + y + z) % MOD
    f_mp = (x - y + z) % MOD
    f_pm = (x + y - z) % MOD
    f_mm = (x - y - z) % MOD
    T = [0] * M
    for s in range(M):
        s1, s2, s3 = S1[s], S2[s], S3[s]
        c_pp = (n + s1 + s2 + s3) // 4
        c_mp = (n - s1 + s2 - s3) // 4
        c_pm = (n + s1 - s2 - s3) // 4
        c_mm = (n - s1 - s2 + s3) // 4
        v = 1
        if c_pp: v = (v * pow(f_pp, c_pp, MOD)) % MOD
        if c_mp: v = (v * pow(f_mp, c_mp, MOD)) % MOD
        if c_pm: v = (v * pow(f_pm, c_pm, MOD)) % MOD
        if c_mm: v = (v * pow(f_mm, c_mm, MOD)) % MOD
        if (bin(s & A).count("1") & 1) == 1:
            v = (-v) % MOD
        T[s] = v
    fwht_mod(T)
    inv2 = (MOD + 1) // 2
    invM = pow(inv2, k, MOD)
    for i in range(M):
        T[i] = (T[i] * invM) % MOD
    return T

def main():
    data = sys.stdin.read()
    if not data.strip():
        # Sanity asserts
        n,k,x,y,z=1,2,1,0,0
        triples=[(1,2,3)]
        assert solve_case(n,k,x,y,z,triples)==[0,1,0,0]
        n,k,x,y,z=2,2,1,1,0
        triples=[(0,1,0),(0,2,0)]
        assert solve_case(n,k,x,y,z,triples)==[1,1,1,1]
        n,k,x,y,z=3,3,2,1,1
        triples=[(1,2,3),(3,5,1),(7,0,4)]
        out = solve_case(n,k,x,y,z,triples)
        # Compare with a tiny brute
        def brute(n,k,x,y,z,triples):
            M=1<<k; F=[0]*M; F[0]=1
            for (a,b,c) in triples:
                mults={}
                mults[a]=mults.get(a,0)+x
                mults[b]=mults.get(b,0)+y
                mults[c]=mults.get(c,0)+z
                G=[0]*M
                for t in range(M):
                    ft=F[t]
                    if ft==0: continue
                    for v,m in mults.items():
                        G[t^v]=(G[t^v]+ft*(m%MOD))%MOD
                F=G
            return F
        assert out == brute(n,k,x,y,z,triples)
        print("OK")
        return
    n, k, x, y, z, triples = read_input(data)
    out = solve_case(n, k, x, y, z, triples)
    print(" ".join(str(v % MOD) for v in out))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count XOR outcomes from $n$ triples with multiplicities via Walsh--Hadamard transform and three aggregated spectra.}
\WHY{Hard interviews test whether you can spot transform structure and reduce an $O(n2^k)$ convolution to $O(2^k k)$.}
\CHECKLIST{
- Compute $A=\bigoplus a_i$.
- Build $P,Q,R$ for $p_i,q_i,r_i$.
- FWHT over integers to get $S_1,S_2,S_3$.
- Derive $c_{\pm\pm}$ for each frequency index.
- Multiply four powers of $(x\pm y \pm z)$.
- Apply modulation by $A$, inverse FWHT, scale.}
\EDGECASES{
- Any of $x,y,z$ can be $0$.
- Duplicates: $a_i=b_i$ or $b_i=c_i$ or $a_i=c_i$.
- $k=1$ minimal spectrum.
- Large $n$ up to $10^5$; counts remain within integer range in FWHT ($[-n,n]$).
- Shift by $A$ is implicit; no extra cyclic shift needed.
- Bases $(x\pm y \pm z)$ may be negative; reduce modulo before exponentiation.}
\PITFALLS{
- Mixing integer FWHT (for counts) with modular FWHT (for answers).
- Forgetting the final scaling by $2^{-k}$ modulo $\mathrm{MOD}$.
- Miscomputing the four count formulas (signs).
- Overflow if using non-Python integers for counts.
- Using $(-1)$ as Python int with modulo; always take modulo after sign.
- Not merging multiplicities when values coincide in the baseline DP.}
\FAILMODES{Baseline $O(n2^k)$ TLE on $n=10^5$. The transform method survives due to domain-only dependence.}
\ELI{We recenter each triple at $a_i$ and only care about whether we flip along $p_i$ and $q_i$. In the Walsh domain, these become $\pm1$ signs. Count how often each sign pair occurs, raise four numbers to those counts, and transform back.}
\NotePages{3}

\end{document}