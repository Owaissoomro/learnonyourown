% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Maximum Segment Sum After Removals}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/maximum-segment-sum-after-removals/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given two 0-indexed integer arrays \texttt{nums} and \texttt{removeQueries}, both of length \texttt{n}. For the $i$th query, the element in \texttt{nums} at the index \texttt{removeQueries[i]} is removed, splitting \texttt{nums} into different segments.

A segment is a contiguous sequence of positive integers in \texttt{nums}. A segment sum is the sum of every element in a segment.

Return an integer array \texttt{answer}, of length \texttt{n}, where \texttt{answer[i]} is the maximum segment sum after applying the $i$th removal.

Note: The same index will not be removed more than once.

Example 1:

Input: \texttt{nums = [1,2,5,6,1]}, \texttt{removeQueries = [0,3,2,4,1]}

Output: \texttt{[14,7,2,2,0]}

Explanation: Using 0 to indicate a removed element, the answer is as follows:

Query 1: Remove the 0th element, \texttt{nums} becomes \texttt{[0,2,5,6,1]} and the maximum segment sum is 14 for segment \texttt{[2,5,6,1]}.

Query 2: Remove the 3rd element, \texttt{nums} becomes \texttt{[0,2,5,0,1]} and the maximum segment sum is 7 for segment \texttt{[2,5]}.

Query 3: Remove the 2nd element, \texttt{nums} becomes \texttt{[0,2,0,0,1]} and the maximum segment sum is 2 for segment \texttt{[2]}.

Query 4: Remove the 4th element, \texttt{nums} becomes \texttt{[0,2,0,0,0]} and the maximum segment sum is 2 for segment \texttt{[2]}.

Query 5: Remove the 1st element, \texttt{nums} becomes \texttt{[0,0,0,0,0]} and the maximum segment sum is 0, since there are no segments.

Finally, we return \texttt{[14,7,2,2,0]}.

Example 2:

Input: \texttt{nums = [3,2,11,1]}, \texttt{removeQueries = [3,2,1,0]}

Output: \texttt{[16,5,3,0]}

Explanation: Using 0 to indicate a removed element, the answer is as follows:

Query 1: Remove the 3rd element, \texttt{nums} becomes \texttt{[3,2,11,0]} and the maximum segment sum is 16 for segment \texttt{[3,2,11]}.

Query 2: Remove the 2nd element, \texttt{nums} becomes \texttt{[3,2,0,0]} and the maximum segment sum is 5 for segment \texttt{[3,2]}.

Query 3: Remove the 1st element, \texttt{nums} becomes \texttt{[3,0,0,0]} and the maximum segment sum is 3 for segment \texttt{[3]}.

Query 4: Remove the 0th element, \texttt{nums} becomes \texttt{[0,0,0,0]} and the maximum segment sum is 0, since there are no segments.

Finally, we return \texttt{[16,5,3,0]}.

Constraints:
\begin{bullets}
\item \texttt{n == nums.length == removeQueries.length}
\item $1 \le n \le 10^5$
\item $1 \le \texttt{nums[i]} \le 10^9$
\item $0 \le \texttt{removeQueries[i]} < n$
\item All the values of \texttt{removeQueries} are unique.
\end{bullets}}
\BREAKDOWN{We must maintain the maximum sum over all contiguous positive segments as array positions are removed one by one. Removing at index cuts segments; the forward process is hard to maintain. Reverse the process: start with all removed (zeros), then add elements back in reverse order, merging adjacent active segments and tracking the best sum.}
\ELI{Undo removals from the end: when you add back a number, merge with neighbors and update the best sum; record the best sum before each add.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{
\begin{bullets}
\item \texttt{nums}: list of $n$ positive integers; $1 \le n \le 10^5$, $1 \le \texttt{nums[i]} \le 10^9$.
\item \texttt{removeQueries}: list of $n$ distinct integers with $0 \le \texttt{removeQueries[i]} < n$ indicating removal order.
\end{bullets}
}
\OUTPUTS{Return list \texttt{answer} of length $n$ where \texttt{answer[i]} equals the maximum segment sum after performing the first $i{+}1$ removals.}
\SAMPLES{
\begin{bullets}
\item \texttt{nums=[1,2,5,6,1]}, \texttt{removeQueries=[0,3,2,4,1]} $\to$ \texttt{[14,7,2,2,0]}.
\item \texttt{nums=[3,2,11,1]}, \texttt{removeQueries=[3,2,1,0]} $\to$ \texttt{[16,5,3,0]}.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the index set be $I=\{0,1,\ldots,n-1\}$. After $t$ removals (forward), the active set is $A_t = I \setminus \{q_0,\ldots,q_{t-1}\}$ where $q_k=\texttt{removeQueries}[k]$. A segment is a maximal interval $[l,r]\subseteq I$ such that $\{l,\ldots,r\}\subseteq A_t$ and $l=0$ or $l-1\notin A_t$, and $r=n-1$ or $r+1\notin A_t$. The segment sum is $S(l,r)=\sum_{i=l}^r \texttt{nums}[i]$. The required output is $ans[t] = \max\{S(l,r):[l,r]\text{ is a segment under }A_{t+1}\}$.}
\varmapStart
\var{n}{array length}
\var{q_t}{removal index at step $t$}
\var{A_t}{active indices after $t$ removals}
\var{S(l,r)}{sum of \texttt{nums} on interval $[l,r]$}
\var{ans[t]}{maximum segment sum after $t{+}1$ removals}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
A_{t+1} &= A_t \setminus \{q_t\},\quad A_0 = I, \\
ans[t] &= \max_{[l,r]\text{ is a segment under }A_{t+1}} \ \sum_{i=l}^{r} \texttt{nums}[i].
\end{aligned}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item All \texttt{nums[i]} are positive, so segments are exactly maximal contiguous runs of active indices.
\item All removals are unique; thus the reverse process adds each index exactly once.
\end{bullets}
}
\INVARIANTS{
\begin{bullets}
\item Reverse process: active components are disjoint intervals.
\item Union of adjacent active indices preserves interval structure.
\item The maximum segment sum is nondecreasing when adding back elements in reverse.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate removals forward and rescan the entire array after each removal to compute the maximum sum over contiguous positive runs.}
\ASSUMPTIONS{Direct simulation; no auxiliary data structures beyond the array copy.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Copy \texttt{nums} to a working array \texttt{arr}.
\item For each query index \texttt{pos} in \texttt{removeQueries}, set \texttt{arr[pos]} to 0.
\item Scan \texttt{arr}: accumulate sum across positive values, reset to 0 at zeros, track the maximum.
\item Record the maximum for this step; continue.
\end{algosteps}
\COMPLEXITY{Each scan is $O(n)$ and there are $n$ removals, so $T(n)=O(n^2)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= \sum_{t=1}^{n} O(n) = O(n^2).
\end{aligned}
\]
\CORRECTNESS{Since all numbers are positive, the maximum sum over segments equals the maximum sum over contiguous runs of nonzero entries. The forward simulation explicitly constructs the array after each removal and computes this value.}
\EDGECASES{Single element arrays, removing ends, and when all elements are removed yield 0.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        n = len(nums)
        arr = nums[:]  # working copy
        ans = [0] * n
        for i, pos in enumerate(removeQueries):
            arr[pos] = 0
            best = 0
            cur = 0
            for x in arr:
                if x > 0:
                    cur += x
                    if cur > best:
                        best = cur
                else:
                    cur = 0
            ans[i] = best
        return ans

# basic asserts (examples)
if __name__ == "__main__":
    s = Solution()
    assert s.maximumSegmentSum([1,2,5,6,1], [0,3,2,4,1]) == [14,7,2,2,0]
    assert s.maximumSegmentSum([3,2,11,1], [3,2,1,0]) == [16,5,3,0]
    # small extra
    assert s.maximumSegmentSum([5], [0]) == [0]
\end{minted}
\VALIDATION{Correct on the two provided examples and trivial length-one case. This approach is too slow for the largest constraints but serves as a specification oracle for tiny inputs.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Reverse Add with DSU Boundaries and Prefix Sums}
\WHICHFORMULA{Process removals in reverse as additions. Maintain disjoint-set union (DSU) over active indices. For each component, keep its leftmost and rightmost indices; compute its sum by a prefix sum array. Track the running maximum.}
\ASSUMPTIONS{All values are positive; components are intervals. DSU with path compression and union by size keeps near-linear time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute prefix sums \texttt{pref} with \texttt{pref[i+1]=pref[i]+nums[i]}.
\item Initialize all indices inactive. Prepare DSU arrays \texttt{parent}, \texttt{size}, \texttt{L}, \texttt{R}.
\item Iterate $i$ from $n-1$ down to $0$:
  \begin{bullets}
  \item Set \texttt{answer[i]} to current maximum.
  \item Activate position \texttt{p=removeQueries[i]}; make a singleton set with \texttt{L[p]=R[p]=p}.
  \item If neighbors are active, union with them; the new component has \texttt{L=min(Lx,Ly)}, \texttt{R=max(Rx,Ry)}.
  \item Let \texttt{root=find(p)}; compute sum as \texttt{pref[R[root]+1]-pref[L[root]]}; update maximum.
  \end{bullets}
\end{algosteps}
\COMPLEXITY{Each index is added and unioned at most twice; DSU amortized cost is almost constant. Overall $T(n)=O(n \alpha(n))$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n \alpha(n)),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Reverse adding preserves the invariant that active indices form disjoint intervals. DSU unions adjacent intervals into larger intervals. Prefix sums yield exact component sums from their boundaries. The recorded value before each addition equals the forward maximum after the corresponding removal.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        n = len(nums)
        parent = list(range(n))
        size = [1] * n
        L = list(range(n))
        R = list(range(n))
        active = [False] * n
        pref = [0] * (n + 1)
        for i, x in enumerate(nums):
            pref[i + 1] = pref[i] + x

        def find(x: int) -> int:
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x

        def union(a: int, b: int) -> int:
            ra, rb = find(a), find(b)
            if ra == rb:
                return ra
            if size[ra] < size[rb]:
                ra, rb = rb, ra
            parent[rb] = ra
            size[ra] += size[rb]
            L[ra] = L[ra] if L[ra] < L[rb] else L[rb]
            R[ra] = R[ra] if R[ra] > R[rb] else R[rb]
            return ra

        ans = [0] * n
        cur_max = 0

        for i in range(n - 1, -1, -1):
            ans[i] = cur_max
            p = removeQueries[i]
            active[p] = True
            parent[p] = p
            size[p] = 1
            L[p] = p
            R[p] = p
            root = p
            if p - 1 >= 0 and active[p - 1]:
                root = union(root, p - 1)
            if p + 1 < n and active[p + 1]:
                root = union(root, p + 1)
            root = find(root)
            seg_sum = pref[R[root] + 1] - pref[L[root]]
            if seg_sum > cur_max:
                cur_max = seg_sum

        return ans

# basic asserts (examples)
if __name__ == "__main__":
    s = Solution()
    assert s.maximumSegmentSum([1,2,5,6,1], [0,3,2,4,1]) == [14,7,2,2,0]
    assert s.maximumSegmentSum([3,2,11,1], [3,2,1,0]) == [16,5,3,0]
    # edge: single element
    assert s.maximumSegmentSum([7], [0]) == [0]
\end{minted}
\VALIDATION{Matches the baseline on small random cases; handles adjacency unions on both sides and endpoints.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Reverse Add with DSU Carrying Component Sums}
\WHICHFORMULA{Maintain DSU where each component stores its total sum directly. When two components are unioned, their sums add. Track the global maximum as elements are added back.}
\ASSUMPTIONS{All values positive; only adjacent actives can merge; DSU amortized time.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize DSU arrays \texttt{parent}, \texttt{size}, and \texttt{sum} (component sum), all inactive.
\item Iterate $i$ from $n-1$ to $0$:
  \begin{bullets}
  \item Record \texttt{answer[i]} as current maximum.
  \item Activate \texttt{p=removeQueries[i]}: set its parent to itself, \texttt{sum[p]=nums[p]}.
  \item If neighbors are active, union them and update the sum of the new root by addition.
  \item Update current maximum with \texttt{sum[find(p)]}.
  \end{bullets}
\end{algosteps}
\OPTIMALITY{Each index participates in at most two unions; find/union costs are amortized nearly constant. This matches known lower bounds for maintaining dynamic connectivity of a path under only insertions.}
\COMPLEXITY{$T(n)=O(n \alpha(n))$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n \alpha(n)),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        n = len(nums)
        parent = list(range(n))
        size = [0] * n
        comp_sum = [0] * n
        active = [False] * n

        def find(x: int) -> int:
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x

        def union(a: int, b: int) -> int:
            ra, rb = find(a), find(b)
            if ra == rb:
                return ra
            if size[ra] < size[rb]:
                ra, rb = rb, ra
            parent[rb] = ra
            size[ra] += size[rb]
            comp_sum[ra] += comp_sum[rb]
            return ra

        ans = [0] * n
        cur_max = 0

        for i in range(n - 1, -1, -1):
            ans[i] = cur_max
            p = removeQueries[i]
            active[p] = True
            parent[p] = p
            size[p] = 1
            comp_sum[p] = nums[p]
            root = p
            if p - 1 >= 0 and active[p - 1]:
                root = union(root, p - 1)
            if p + 1 < n and active[p + 1]:
                root = union(root, p + 1)
            root = find(root)
            if comp_sum[root] > cur_max:
                cur_max = comp_sum[root]
        return ans

# asserts: exactly 3 checks
if __name__ == "__main__":
    s = Solution()
    assert s.maximumSegmentSum([1,2,5,6,1], [0,3,2,4,1]) == [14,7,2,2,0]
    assert s.maximumSegmentSum([3,2,11,1], [3,2,1,0]) == [16,5,3,0]
    assert s.maximumSegmentSum([7], [0]) == [0]
\end{minted}
\VALIDATION{Three checks:
\begin{bullets}
\item \texttt{[1,2,5,6,1]} with removals \texttt{[0,3,2,4,1]} yields \texttt{[14,7,2,2,0]}.
\item \texttt{[3,2,11,1]} with removals \texttt{[3,2,1,0]} yields \texttt{[16,5,3,0]}.
\item Single element \texttt{[7]} with removal \texttt{[0]} yields \texttt{[0]}.
\end{bullets}
}
\RESULT{An array \texttt{answer} where \texttt{answer[i]} is the maximum sum of any contiguous positive segment after applying the first $i{+}1$ removals.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test against the provided examples; compare brute force vs. optimal on small randomized arrays; cover boundary cases like single element, removing ends first, and strictly increasing or equal values.}
\LINE{CROSS-CHECKS}{For $n \le 20$, randomly generate arrays and removal orders; verify that Approach C matches Approach A exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial patterns: removals left-to-right, right-to-left, alternating indices, and cluster removals to stress unions on both sides.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_increasing(n: int) -> Tuple[List[int], List[int]]:
    nums = list(range(1, n + 1))
    rem = list(range(n))
    return nums, rem

def gen_right_to_left(n: int) -> Tuple[List[int], List[int]]:
    nums = [5] * n
    rem = list(range(n - 1, -1, -1))
    return nums, rem

def gen_alternate(n: int) -> Tuple[List[int], List[int]]:
    nums = [1 + (i % 3) for i in range(n)]
    rem = list(range(0, n, 2)) + list(range(1, n, 2))
    return nums, rem

def brute(nums: List[int], rem: List[int]) -> List[int]:
    arr = nums[:]
    out = [0] * len(nums)
    for i, p in enumerate(rem):
        arr[p] = 0
        best = 0
        cur = 0
        for x in arr:
            if x > 0:
                cur += x
                best = max(best, cur)
            else:
                cur = 0
        out[i] = best
    return out

def optimal(nums: List[int], rem: List[int]) -> List[int]:
    # Approach C implementation
    n = len(nums)
    parent = list(range(n))
    size = [0] * n
    comp_sum = [0] * n
    active = [False] * n

    def find(x: int) -> int:
        while parent[x] != x:
            parent[x] = parent[parent[x]]
            x = parent[x]
        return x

    def union(a: int, b: int) -> int:
        ra, rb = find(a), find(b)
        if ra == rb:
            return ra
        if size[ra] < size[rb]:
            ra, rb = rb, ra
        parent[rb] = ra
        size[ra] += size[rb]
        comp_sum[ra] += comp_sum[rb]
        return ra

    ans = [0] * n
    cur_max = 0
    for i in range(n - 1, -1, -1):
        ans[i] = cur_max
        p = rem[i]
        active[p] = True
        parent[p] = p
        size[p] = 1
        comp_sum[p] = nums[p]
        root = p
        if p - 1 >= 0 and active[p - 1]:
            root = union(root, p - 1)
        if p + 1 < n and active[p + 1]:
            root = union(root, p + 1)
        root = find(root)
        cur_max = max(cur_max, comp_sum[root])
    return ans

if __name__ == "__main__":
    # cross-check small sizes
    random.seed(0)
    for n in range(1, 16):
        nums = [random.randint(1, 7) for _ in range(n)]
        rem = list(range(n))
        random.shuffle(rem)
        assert brute(nums, rem) == optimal(nums, rem)
    # adversarial patterns
    for gen in (gen_increasing, gen_right_to_left, gen_alternate):
        for n in (1, 2, 3, 5, 8, 12):
            nums, rem = gen(n)
            assert brute(nums, rem) == optimal(nums, rem)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        n = len(nums)
        parent = list(range(n))
        size = [0] * n
        comp_sum = [0] * n
        active = [False] * n

        def find(x: int) -> int:
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x

        def union(a: int, b: int) -> int:
            ra, rb = find(a), find(b)
            if ra == rb:
                return ra
            if size[ra] < size[rb]:
                ra, rb = rb, ra
            parent[rb] = ra
            size[ra] += size[rb]
            comp_sum[ra] += comp_sum[rb]
            return ra

        ans = [0] * n
        cur_max = 0

        for i in range(n - 1, -1, -1):
            ans[i] = cur_max
            p = removeQueries[i]
            active[p] = True
            parent[p] = p
            size[p] = 1
            comp_sum[p] = nums[p]
            root = p
            if p - 1 >= 0 and active[p - 1]:
                root = union(root, p - 1)
            if p + 1 < n and active[p + 1]:
                root = union(root, p + 1)
            root = find(root)
            if comp_sum[root] > cur_max:
                cur_max = comp_sum[root]
        return ans

if __name__ == "__main__":
    s = Solution()
    assert s.maximumSegmentSum([1,2,5,6,1], [0,3,2,4,1]) == [14,7,2,2,0]
    assert s.maximumSegmentSum([3,2,11,1], [3,2,1,0]) == [16,5,3,0]
    assert s.maximumSegmentSum([7], [0]) == [0]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Undo deletions with DSU to merge adjacent active indices and track the current maximum segment sum.}
\WHY{This pattern (reverse operations with DSU) appears frequently in interview problems where deletions complicate structure maintenance but insertions are easy.}
\CHECKLIST{
\begin{bullets}
\item Think reverse: removals $\to$ additions.
\item Initialize answer at each step to current maximum before adding.
\item Union left neighbor if active; union right neighbor if active.
\item Update component summary (sum or boundaries) and global maximum.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item Remove ends first vs. middle first.
\item All equal values.
\item Strictly increasing values.
\item Alternate removals creating many small segments.
\item Large values near $10^9$; ensure no overflow in languages with fixed-size integers.
\item No active elements (maximum is 0).
\item Adding merges both sides simultaneously.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Recording \texttt{answer[i]} after the addition instead of before.
\item Forgetting to path-compress finds; performance degrades.
\item Not resetting DSU state when activating a new singleton.
\item Double-adding or re-unioning the same neighbor without checking active.
\item Off-by-one computing segment sums with prefix sums (Approach B).
\item Using default integer types that overflow (not an issue in Python).
\item Mixing up \texttt{size} and \texttt{sum} updates on union.
\item Neglecting to handle boundary neighbors at indices 0 and $n{-}1$.
\end{bullets}
}
\FAILMODES{Forward maintenance of segments under deletions is complex; naive re-scan is $O(n^2)$. The reverse-DSU approach avoids splitting by turning deletions into merges, achieving near-linear time.}
\ELI{Instead of tracking how cuts split pieces, start with everything cut and glue pieces back. Each glue step merges with neighbors and we keep the best total we have ever seen. Record the best just before each glue to get the forward answers.}
\NotePages{3}

\end{document}