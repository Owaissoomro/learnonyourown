% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Challenges in school №41}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1333/D}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{There are $n$ children, who study at the school №41. It is well-known that they are good mathematicians. Once at a break, they arranged a challenge for themselves. All children arranged in a row and turned heads either to the left or to the right.

Children can do the following: in one second several pairs of neighboring children who are looking at each other can simultaneously turn the head in the opposite direction. For instance, the one who was looking at the right neighbor turns left and vice versa for the second child. Moreover, every second at least one pair of neighboring children performs such action. They are going to finish when there is no pair of neighboring children who are looking at each other.

You are given the number $n$, the initial arrangement of children and the number $k$. You have to find a way for the children to act if they want to finish the process in exactly $k$ seconds. More formally, for each of the $k$ moves, you need to output the numbers of the children who turn left during this move.

For instance, for the configuration shown below and $k=2$ children can do the following steps:

It is guaranteed that if the solution exists, it takes not more than $n^2$ ``headturns''.

Input:
The first line of input contains two integers $n$ and $k$ ($2 \le n \le 3000$, $1 \le k \le 3000000$) — the number of children and required number of moves.

The next line contains a string of length $n$ and consists only of characters L and R, where L means that the child looks to the left and R means that the child looks to the right.

Output:
If there is no solution, print a single line with number $-1$.

Otherwise, output $k$ lines. Each line has to start with a number $n_i$ ($1\le n_i \le \tfrac{n}{2}$) — the number of pairs of children, who turn at this move. After that print $n_i$ distinct integers — the numbers of the children who will turn left during this move.

After performing all ``headturns'', there can not be a pair of two neighboring children looking at each other.

If there are many solutions, print any of them.

Note:
The first sample contains a pair of children who look at each other. After one move, they can finish the process.

In the second sample, children can not make any move. As a result, they can not end in $k>0$ moves.

The third configuration is described in the statement.}
\BREAKDOWN{Simulate the process as rounds of disjoint ``RL'' swaps from left to right. Collect all swap positions in each round, compute minimal rounds and total swaps, check feasibility $($minimal rounds $\le k \le$ total swaps$)$. Then split rounds into exactly $k$ moves by outputting some swaps as singletons and bundling the rest per round.}
\ELI{Think of it like bubble sort: every day swap each ``RL'' to ``LR'' left-to-right; then slice these swaps into exactly $k$ moves.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n,k$ with $2\le n\le 3000$, $1\le k\le 3{,}000{,}000$; followed by a string $s$ of length $n$ over $\{ \text{L}, \text{R} \}$ describing initial directions.}
\OUTPUTS{If impossible, print $-1$. Otherwise print exactly $k$ lines. On move $t$, print $n_t$ then $n_t$ distinct integers: the $1$-indexed positions of children who turn left on that move. Pairs within a move must be disjoint and look at each other at that moment.}
\SAMPLES{Example 1

Input
3 2
RLL

Output
1 1
1 2

Example 2

Input
2 2
RL

Output
-1}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $s\in\{\text{L},\text{R}\}^n$. A round scans $i=1$ to $n-1$, collects all indices $i$ with $(s_i,s_{i+1})=(\text{R},\text{L})$ such that no two chosen $i$ are adjacent, and simultaneously swaps them to $(\text{L},\text{R})$. Let $P_t$ be the list of positions chosen in round $t$. The process stops at the smallest $T$ with $P_T=\varnothing$.}
\varmapStart
\var{n}{number of children}
\var{k}{required number of moves to finish}
\var{s}{initial orientation string}
\var{P_t}{positions of left-turning children on round $t$, $1$-indexed}
\var{D}{number of nonempty rounds $D=\#\{t:P_t\neq\varnothing\}$}
\var{S}{total swaps $S=\sum_{t=1}^{D}\lvert P_t\rvert$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Round formation: } P_t=\{\,i\in[1,n-1]: s_i=\text{R},\ s_{i+1}=\text{L},\ i-1\notin P_t\,\}.\\
&\text{State update: }\forall i\in P_t:\ (s_i,s_{i+1})\gets(\text{L},\text{R}).\\
&\text{Feasibility: } D \le k \le S.
\end{aligned}
\]
}
\ASSUMPTIONS{Scan left-to-right so $P_t$ is a set of disjoint positions; swaps commute within a round. Indexing is $1$-based in outputs.}
\INVARIANTS{
\begin{bullets}
\item The inversion count $I=\#\{(i,j):i<j,\ s_i=\text{R},\ s_j=\text{L}\}$ decreases by exactly $\lvert P_t\rvert$ each round; therefore $S=I$.
\item $D$ is the minimal number of moves; $S$ is the maximal attainable by doing one swap per move.
\item Within a round, executing swaps in increasing index order preserves validity and outputs correct positions.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Generate all rounds by repeatedly scanning for ``RL'' pairs and swapping them. Compute $D$ and $S$, check $D\le k \le S$. Then split rounds into $k$ moves by outputting some swaps one-by-one and the rest bundled per round.}
\ASSUMPTIONS{A full scan per round is acceptable since $n\le 3000$ and $S\le n^2$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build lists $P_1,P_2,\ldots,P_D$ by scanning $s$ left-to-right; swap disjoint ``RL'' pairs each round.
\item Let $S=\sum\lvert P_t\rvert$ and $D=\#\{t\}$. If $k\notin[D,S]$, print $-1$.
\item For $t=1$ to $D$: while $k>(D-t+1)$, output a singleton $\{i\}$ from $P_t$ in order and decrement $k$; output the remaining positions of $P_t$ as one move.
\end{algosteps}
\COMPLEXITY{Each round scan is $O(n)$ and there are at most $O(n)$ rounds. Splitting is linear in $S$.}
\[
\begin{aligned}
T(n) &= O(n\cdot D) + O(S) \ \le\ O(n^2),\\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Disjointness ensures within-round swaps commute; executing in order yields the same state. Bounds $D$ and $S$ are tight by the inversion argument, so feasibility and exact-$k$ construction follow.}
\EDGECASES{All L or all R $\Rightarrow D=0$; single pair ``RL''; alternating patterns; $k$ equals $D$ or $S$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); k = int(next(it)); s = next(it).strip()
    return n, k, s

def build_rounds(s):
    n = len(s)
    s_list = list(s)
    rounds = []
    while True:
        pos0 = []
        i = 0
        while i < n - 1:
            if s_list[i] == 'R' and s_list[i+1] == 'L':
                pos0.append(i)  # 0-based
                i += 2
            else:
                i += 1
        if not pos0:
            break
        rounds.append([p + 1 for p in pos0])  # 1-based positions to output
        for p in pos0:
            s_list[p], s_list[p+1] = s_list[p+1], s_list[p]
    return rounds

def plan_moves(n, k, s):
    if len(s) != n:
        s = s[:n]
    rounds = build_rounds(s)
    D = len(rounds)
    S = sum(len(r) for r in rounds)
    if k < D or k > S:
        return False, []
    # Split rounds into exactly k moves
    moves = []
    remaining = k
    for i in range(D):
        rest = []
        for pos in rounds[i]:
            if remaining > (D - i):
                moves.append([pos])
                remaining -= 1
            else:
                rest.append(pos)
        if rest:
            moves.append(rest)
    assert remaining == 0
    assert len(moves) == k
    return True, moves

def solve_case(n, k, s):
    ok, moves = plan_moves(n, k, s)
    if not ok:
        return "-1"
    out_lines = []
    for mv in moves:
        out_lines.append(str(len(mv)) + " " + " ".join(map(str, mv)))
    return "\n".join(out_lines)

def solve_all():
    args = read_input()
    if args is None:
        return
    n, k, s = args
    print(solve_case(n, k, s))

if __name__ == "__main__":
    # Basic asserts
    assert plan_moves(2, 1, "RL")[0] is True
    assert plan_moves(2, 2, "RL")[0] is False
    ok, ms = plan_moves(3, 2, "RLL"); assert ok and ms == [[1], [2]]
    # Run solver if input provided
    if sys.stdin and not sys.stdin.isatty():
        solve_all()
\end{minted}
\VALIDATION{Checked minimal/maximal $k$ bounds; singleton outputs preserve disjointness and order; indices are $1$-based.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Round Formation and Greedy Splitting}
\WHICHFORMULA{Same inversion-based bounds, but ensure linear passes and avoid extra string joins; store indices $0$-based for swapping, mirror $1$-based only when emitting.}
\ASSUMPTIONS{Non-overlapping pairs per round; executing within a round in increasing index order is valid and stable for indices.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate rounds by scanning once per round, swapping in-place using stored $0$-based positions.
\item Compute $D$ and $S$ and validate $D\le k \le S$.
\item For round $i$ in order, emit singletons while $k > D-i$, then emit the remaining positions of that round as one move.
\end{algosteps}
\COMPLEXITY{Same big-O but tight constants: each index touched $O(1)$ times per round; $T(n)\le O(n^2)$.}
\[
\begin{aligned}
T(n) &= O\!\left(\sum_{t=1}^{D} n\right) + O(S) \le O(n^2).
\end{aligned}
\]
\CORRECTNESS{Greedy splitting maintains at least one move for each remaining round, producing exactly $k$ moves. The inversion argument ensures feasibility bounds are necessary and sufficient.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); k = int(next(it)); s = next(it).strip()
    return n, k, s

def rounds_and_stats(s):
    n = len(s)
    s_list = list(s)
    rounds = []
    while True:
        pos0 = []
        i = 0
        while i < n - 1:
            if s_list[i] == 'R' and s_list[i+1] == 'L':
                pos0.append(i)
                i += 2
            else:
                i += 1
        if not pos0:
            break
        rounds.append([p + 1 for p in pos0])  # 1-based for output
        for p in pos0:
            s_list[p], s_list[p+1] = s_list[p+1], s_list[p]
    D = len(rounds)
    S = sum(len(r) for r in rounds)
    return rounds, D, S

def plan_moves(n, k, s):
    if len(s) != n:
        s = s[:n]
    rounds, D, S = rounds_and_stats(s)
    if k < D or k > S:
        return False, []
    moves = []
    remaining = k
    for i in range(D):
        keep = []
        for pos in rounds[i]:
            if remaining > (D - i):
                moves.append([pos])
                remaining -= 1
            else:
                keep.append(pos)
        if keep:
            moves.append(keep)
    assert remaining == 0
    assert len(moves) == k
    return True, moves

def solve_case(n, k, s):
    ok, moves = plan_moves(n, k, s)
    if not ok:
        return "-1"
    return "\n".join(str(len(mv)) + " " + " ".join(map(str, mv)) for mv in moves)

def solve_all():
    args = read_input()
    if args is None:
        return
    n, k, s = args
    sys.stdout.write(solve_case(n, k, s))

if __name__ == "__main__":
    # Unit asserts
    assert plan_moves(3, 1, "RLL")[0] is False  # need at least 2 rounds
    ok, ms = plan_moves(3, 2, "RLL"); assert ok and ms == [[1], [2]]
    assert plan_moves(4, 4, "RRLL")[0] is True  # S = 4 possible
    if sys.stdin and not sys.stdin.isatty():
        solve_all()
\end{minted}
\VALIDATION{Edge cases: no moves possible; exact minimal moves; maximal $S$ moves; positions remain within $[1,n-1]$ and distinct within each move.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use the inversion-count bounds and left-to-right disjoint swap rounds; greedy split ensures exactly $k$ moves with minimal recomputation.}
\ASSUMPTIONS{Swaps commute within a round; inversion count strictly decreases; $k$ in $[D,S]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute all rounds $P_t$ by scanning and swapping; accumulate $D$ and $S$.
\item If $k<D$ or $k>S$, print $-1$.
\item For each round $t$, emit singletons while allowed by the remaining-moves budget; then emit the rest as one group. Continue until exactly $k$ groups are produced.
\end{algosteps}
\OPTIMALITY{Lower bound $D$ equals the minimal number of moves since each round must appear at least once. Upper bound $S$ is achievable by taking one swap per move. The construction achieves any $k$ between them, hence optimal with respect to feasibility.}
\COMPLEXITY{$T(n)\le O(n^2)$, $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n\cdot D) + O(S) \le O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); k = int(next(it)); s = next(it).strip()
    return n, k, s

def build_rounds(s):
    n = len(s)
    a = list(s)
    rounds = []
    while True:
        pos0 = []
        i = 0
        while i < n - 1:
            if a[i] == 'R' and a[i+1] == 'L':
                pos0.append(i)
                i += 2
            else:
                i += 1
        if not pos0:
            break
        rounds.append([p + 1 for p in pos0])  # 1-based indices of left-turners
        for p in pos0:
            a[p], a[p+1] = a[p+1], a[p]
    return rounds

def plan_moves(n, k, s):
    if len(s) != n:
        s = s[:n]
    rounds = build_rounds(s)
    D = len(rounds)
    S = sum(len(r) for r in rounds)
    if k < D or k > S:
        return False, []
    res = []
    remaining = k
    for i in range(D):
        tail = []
        for pos in rounds[i]:
            if remaining > (D - i):
                res.append([pos])
                remaining -= 1
            else:
                tail.append(pos)
        if tail:
            res.append(tail)
    assert remaining == 0
    assert len(res) == k
    return True, res

def solve_case(n, k, s):
    ok, groups = plan_moves(n, k, s)
    if not ok:
        return "-1"
    return "\n".join(str(len(g)) + " " + " ".join(map(str, g)) for g in groups)

def solve_all():
    args = read_input()
    if args is None:
        return
    n, k, s = args
    out = solve_case(n, k, s)
    sys.stdout.write(out)

if __name__ == "__main__":
    # Exactly 3 asserts
    assert plan_moves(2, 1, "RL")[0] is True
    assert plan_moves(2, 2, "RL")[0] is False
    ok, ans = plan_moves(3, 2, "RLL"); assert ok and ans == [[1], [2]]
    # Run if input is piped
    if sys.stdin and not sys.stdin.isatty():
        solve_all()
\end{minted}
\VALIDATION{Three asserts cover the trivial feasible, trivial infeasible, and a two-round exact case.}
\RESULT{Outputs exactly $k$ moves; within each move, indices are distinct and valid; after all moves, no adjacent pair looks at each other.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test feasibility bounds; verify sequence splitting hits exact $k$; cross-check that total moves printed equals $k$ and that counts do not exceed $\tfrac{n}{2}$.}
\LINE{CROSS-CHECKS}{Compare outputs between Baseline and Final for random small $n$ by checking both produce same total swap multiset sizes and $k$ lines, and that $k$ is respected.}
\LINE{EDGE-CASE GENERATOR}{Create worst-case strings like all R then all L, alternating RL, or no-move strings LLL... and RRR....}
\begin{minted}{python}
import random

def gen_string(n, kind):
    if kind == "allR":
        return "R" * n
    if kind == "allL":
        return "L" * n
    if kind == "half":
        return "R" * (n//2) + "L" * (n - n//2)
    if kind == "alt":
        return "".join("RL"[(i%2)] for i in range(n))
    return "".join(random.choice("RL") for _ in range(n))

def brute_bounds(s):
    # Compute minimal rounds D and total swaps S by simulation
    n = len(s)
    a = list(s)
    D = 0
    S = 0
    while True:
        pos = []
        i = 0
        while i < n - 1:
            if a[i] == 'R' and a[i+1] == 'L':
                pos.append(i); i += 2
            else:
                i += 1
        if not pos:
            break
        D += 1; S += len(pos)
        for p in pos:
            a[p], a[p+1] = a[p+1], a[p]
    return D, S

def reference(n, k, s):
    # Use final approach
    from sys import stdout
    from math import inf
    def build_rounds(s):
        n = len(s); a = list(s); rounds = []
        while True:
            pos0 = []; i = 0
            while i < n - 1:
                if a[i] == 'R' and a[i+1] == 'L':
                    pos0.append(i); i += 2
                else:
                    i += 1
            if not pos0: break
            rounds.append([p+1 for p in pos0])
            for p in pos0:
                a[p], a[p+1] = a[p+1], a[p]
        return rounds
    rounds = build_rounds(s)
    D = len(rounds); S = sum(len(r) for r in rounds)
    if k < D or k > S:
        return "-1"
    res = []; remaining = k
    for i in range(D):
        tail = []
        for pos in rounds[i]:
            if remaining > (D - i):
                res.append([pos]); remaining -= 1
            else:
                tail.append(pos)
        if tail: res.append(tail)
    return "\n".join(str(len(g)) + " " + " ".join(map(str, g)) for g in res)

# Quick deterministic checks
for s in ["RL", "RLL", "RRLL", "LLLRRR", "RLRLRL", "LLLL", "RRRR"]:
    D, S = brute_bounds(s)
    n = len(s)
    if D == 0:
        assert reference(n, 0, s) != "-1"
        if S >= 1:
            assert reference(n, 1, s) == "-1"
    else:
        assert reference(n, D, s) != "-1"
        assert reference(n, S, s) != "-1"
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); k = int(next(it)); s = next(it).strip()
    return n, k, s

def build_rounds(s: str):
    n = len(s)
    a = list(s)
    rounds = []
    while True:
        pos0 = []
        i = 0
        while i < n - 1:
            if a[i] == 'R' and a[i+1] == 'L':
                pos0.append(i)
                i += 2
            else:
                i += 1
        if not pos0:
            break
        rounds.append([p + 1 for p in pos0])  # 1-based for output
        for p in pos0:
            a[p], a[p+1] = a[p+1], a[p]
    return rounds

def plan_moves(n: int, k: int, s: str):
    if len(s) != n:
        s = s[:n]
    rounds = build_rounds(s)
    D = len(rounds)
    S = sum(len(r) for r in rounds)
    if k < D or k > S:
        return False, []
    res = []
    remaining = k
    for i in range(D):
        tail = []
        for pos in rounds[i]:
            if remaining > (D - i):
                res.append([pos])
                remaining -= 1
            else:
                tail.append(pos)
        if tail:
            res.append(tail)
    assert remaining == 0
    assert len(res) == k
    return True, res

def solve_case(n, k, s):
    ok, groups = plan_moves(n, k, s)
    if not ok:
        return "-1"
    return "\n".join(str(len(g)) + " " + " ".join(map(str, g)) for g in groups)

def solve_all():
    args = read_input()
    if args is None:
        return
    n, k, s = args
    sys.stdout.write(solve_case(n, k, s))

if __name__ == "__main__":
    # Asserts
    assert plan_moves(2, 1, "RL")[0] is True
    assert plan_moves(2, 2, "RL")[0] is False
    ok, g = plan_moves(3, 2, "RLL"); assert ok and g == [[1], [2]]
    if sys.stdin and not sys.stdin.isatty():
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Simulate disjoint ``RL'' swaps per day and split them to hit exactly $k$ moves between the minimal $D$ and maximal $S$.}
\WHY{Classic greedy construction with tight feasibility bounds appears frequently in interviews and contests.}
\CHECKLIST{
\begin{bullets}
\item Gather all disjoint ``RL'' pairs left-to-right.
\item Swap them to form the next string state.
\item Accumulate rounds and total swaps; compute $D$ and $S$.
\item If $k\notin[D,S]$, print $-1$.
\item Greedily emit singletons while $k$ exceeds remaining rounds; bundle the remainder per round.
\item Output $1$-based indices.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item No moves possible: all L or all R.
\item Single pair ``RL'' with $k=1$ OK, with $k>1$ impossible.
\item Alternating patterns like ``RLRL...''.
\item ``RR..RLL..L'' long blocks.
\item $k=D$ (no splits) and $k=S$ (all singletons).
\item Max $n=3000$; ensure no quadratic blow-up beyond $O(n^2)$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting $1$-based indices in output.
\item Splitting too much and running out of moves for later rounds.
\item Choosing overlapping pairs within a move.
\item Recomputing indices incorrectly after earlier swaps; keep round order.
\item Mishandling input parsing or trailing whitespace.
\item Printing extra spaces or wrong line counts.
\end{bullets}
}
\FAILMODES{Approaches that try to arbitrarily split without preserving at least one move per remaining round will fail to reach exactly $k$. Not tracking feasibility bounds $D$ and $S$ leads to false positives.}
\ELI{Every day, swap all neighboring kids facing each other. Count how many days and how many total swaps this takes. If your required $k$ is between these two numbers, you can schedule some swaps solo and the rest bundled to finish in exactly $k$ steps.}
\NotePages{3}

\end{document}