% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Hongcow Draws a Circle}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/744/D}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{Hongcow really likes the color red. Hongcow does not like the color blue.

Hongcow is standing in an infinite field where there are $n$ red points and $m$ blue points.

Hongcow wants to draw a circle in the field such that this circle contains at least one red point, and no blue points. Points that line exactly on the boundary of the circle can be counted as either inside or outside.

Compute the radius of the largest circle that satisfies this condition. If this circle can have arbitrarily large size, print $-1$. Otherwise, your answer will be accepted if it has relative or absolute error at most $10^{-4}$.

Input:
The first line of the input will contain two integers $n, m$ ($1 \le n, m \le 1{,}000$).

The next $n$ lines will contain two integers $x_i, y_i$ ($1 \le x_i, y_i \le 10^4$). This denotes the coordinates of a red point.

The next $m$ lines will contain two integers $x_i, y_i$ ($1 \le x_i, y_i \le 10^4$). This denotes the coordinates of a blue point.

No two points will have the same coordinates.

Output:
Print $-1$ if the circle can have arbitrary size. Otherwise, print a floating point number representing the largest radius circle that satisfies the conditions. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-4}$.

Namely, let your answer be $a$ and the answer of the jury be $b$. The checker program will consider your answer correct if
\begin{BreakableEquation*}
\frac{\lvert a-b\rvert}{\max(1,b)} \le 10^{-4}.
\end{BreakableEquation*}

Note: There are illustrations in the original problem for the samples.}
\BREAKDOWN{We must decide whether the maximum radius is infinite, and otherwise compute the supremum radius $R$ of a disk that contains at least one red point and no blue points. Geometrically, the circle center must lie where some red point is no farther than every blue point, and the radius equals the distance to the nearest blue.}
\ELI{Pick a center where a red is at least as close as every blue; make the circle just big enough to touch the nearest blue. The task is to find the largest such distance, or detect if it can grow without bound.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m$; then $n$ red points $(x_i,y_i)$; then $m$ blue points $(x_j,y_j)$. All coordinates are integers with $1 \le x,y \le 10^4$. No duplicate points.}
\OUTPUTS{A single number: $-1$ if the radius can be arbitrarily large; otherwise a floating point number for the maximum radius. Either absolute or relative error $\le 10^{-4}$ is accepted.}
\SAMPLES{Example 1 (schematic only):
- Reds: $(0,0)$; Blues: $(10,0)$.
- Output: $10$ (center at $(0,0)$, radius $10$ touches the blue).

Example 2 (schematic only):
- Reds: $(5,0)$; Blues: $(0,0),(10,0)$.
- Output: $5$ (center at $(5,0)$, radius $5$ touches both blues).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $R$ denote the set of red points and $B$ denote the set of blue points. For a center $c \in \mathbb{R}^2$, define $d_R(c) = \min_{r \in R} \|c-r\|$ and $d_B(c) = \min_{b \in B} \|c-b\|$. A center $c$ is feasible if $d_R(c) \le d_B(c)$; the best radius at $c$ is $d_B(c)$. The goal is
\begin{BreakableEquation*}
\max_{c \in \mathbb{R}^2} \, d_B(c) \quad \text{subject to } d_R(c) \le d_B(c).
\end{BreakableEquation*}
If the maximum is unbounded, report $-1$.}
\varmapStart
\var{R}{set of red points}
\var{B}{set of blue points}
\var{c}{circle center}
\var{d_R(c)}{distance from $c$ to the nearest red}
\var{d_B(c)}{distance from $c$ to the nearest blue}
\var{F_r}{region where a fixed $r \in R$ is no farther than any blue}
\varmapEnd
\GOVERN{
\[
  F_r \,=\, \bigcap_{b \in B} \{\, c \in \mathbb{R}^2 : \|c-r\| \le \|c-b\| \,\}
  \,=\, \bigcap_{b \in B} \{\, c : 2(b-r)\cdot c \le \|b\|^2 - \|r\|^2 \,\}.
\]
Feasible region: $F = \bigcup_{r \in R} F_r$. Objective at $c$: $d_B(c)$. We seek $\max_{c \in F} d_B(c)$.}
\ASSUMPTIONS{Euclidean norm; boundary points are allowed to be treated as either inside or outside, so $\le$ on constraints is admissible.}
\INVARIANTS{If some red lies on or outside the convex hull of blue points, the feasible region contains an unbounded ray along which $d_B(c)\to\infty$; otherwise each $F_r$ is a bounded convex polygon. On any fixed blue Voronoi cell, $d_B(c)$ equals distance to a fixed blue and is convex; maximizing it over a convex polygonal region occurs at a vertex of the region.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Search candidate centers $c$ from simple finite sets and evaluate $d_B(c)$ subject to $d_R(c) \le d_B(c)$. Natural candidates: red points; intersections of perpendicular bisectors between a red and two blues.}
\ASSUMPTIONS{This is a correctness-oriented but computationally heavy scan; it ignores some subtle candidates and is not intended for worst-case $n,m=1000$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If any red point lies on or outside the convex hull of blue points, return $-1$ (unbounded).
\item Initialize best radius $ans \leftarrow 0$.
\item Add all red points as candidate centers; evaluate $d_B$ and feasibility $d_R \le d_B$.
\item For each red $r$ and for each unordered pair of blue points $(b_i,b_j)$, intersect the perpendicular bisectors of $(r,b_i)$ and $(r,b_j)$ to get a candidate center $c$; evaluate.
\item Track the maximal feasible $d_B(c)$.
\end{algosteps}
\COMPLEXITY{For step 4, $O(n m^2)$ candidates; each evaluation costs $O(n+m)$, so $O(n m^2 (n+m))$ — prohibitive at scale. This is purely a didactic baseline.}
\[
\begin{aligned}
T(n,m) &\approx O\big(n m^2 (n+m)\big), \\
S(n,m) &\approx O(1) \text{ beyond input storage}.
\end{aligned}
\]
\CORRECTNESS{All candidates lie on boundaries where $r$ ties with at least one blue, which are necessary pieces of the feasible frontier. Including red points ensures at least a simple feasible center is considered.}
\EDGECASES{Degenerate parallel bisectors (collinear triples), coincident arithmetic, and empty intersections are skipped. Equality $d_R = d_B$ is allowed.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
import math
from typing import List, Tuple

Point = Tuple[float, float]

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    reds = []
    for _ in range(n):
        x = float(next(it)); y = float(next(it))
        reds.append((x, y))
    blues = []
    for _ in range(m):
        x = float(next(it)); y = float(next(it))
        blues.append((x, y))
    return n, m, reds, blues

def cross(ax, ay, bx, by) -> float:
    return ax*by - ay*bx

def dot(ax, ay, bx, by) -> float:
    return ax*bx + ay*by

def sub(a: Point, b: Point) -> Point:
    return (a[0]-b[0], a[1]-b[1])

def dist(a: Point, b: Point) -> float:
    dx = a[0]-b[0]; dy = a[1]-b[1]
    return math.hypot(dx, dy)

def convex_hull(points: List[Point]) -> List[Point]:
    pts = sorted(points)
    if len(pts) <= 1:
        return pts[:]
    # Build lower
    lower = []
    for p in pts:
        while len(lower) >= 2:
            x1,y1 = lower[-2]; x2,y2 = lower[-1]
            x3,y3 = p
            if cross(x2-x1, y2-y1, x3-x2, y3-y2) <= 0:
                lower.pop()
            else:
                break
        lower.append(p)
    # Build upper
    upper = []
    for p in reversed(pts):
        while len(upper) >= 2:
            x1,y1 = upper[-2]; x2,y2 = upper[-1]
            x3,y3 = p
            if cross(x2-x1, y2-y1, x3-x2, y3-y2) <= 0:
                upper.pop()
            else:
                break
        upper.append(p)
    hull = lower[:-1] + upper[:-1]
    return hull

def on_segment(a: Point, b: Point, p: Point) -> bool:
    # Check collinear and within bounding box
    ax, ay = a; bx, by = b; px, py = p
    if abs(cross(bx-ax, by-ay, px-ax, py-ay)) > 1e-12:
        return False
    return (min(ax,bx)-1e-12 <= px <= max(ax,bx)+1e-12 and
            min(ay,by)-1e-12 <= py <= max(ay,by)+1e-12)

def point_in_convex_polygon_strict(poly: List[Point], p: Point) -> int:
    # returns: 1 if strictly inside, 0 if on boundary, -1 if outside
    k = len(poly)
    if k == 0:
        return -1
    if k == 1:
        return 0 if (abs(poly[0][0]-p[0])<1e-12 and abs(poly[0][1]-p[1])<1e-12) else -1
    if k == 2:
        return 0 if on_segment(poly[0], poly[1], p) else -1
    pos = neg = False
    for i in range(k):
        a = poly[i]; b = poly[(i+1)%k]
        v1 = (b[0]-a[0], b[1]-a[1])
        v2 = (p[0]-a[0], p[1]-a[1])
        cr = cross(v1[0], v1[1], v2[0], v2[1])
        if abs(cr) < 1e-12:
            # On edge?
            if on_segment(a, b, p):
                return 0
        elif cr > 0:
            pos = True
        else:
            neg = True
        if pos and neg:
            return -1
    return 1

def perp_bisector(p: Point, q: Point):
    # Return line in form ax + by = c (normalized not necessary)
    mx = 0.5*(p[0]+q[0]); my = 0.5*(p[1]+q[1])
    dx = q[0]-p[0]; dy = q[1]-p[1]
    # Perp vector (a, b) = (dx, dy) rotated 90: (dy, -dx)
    a = dx
    b = dy
    # For perpendicular bisector, normal is (dx, dy), passing through (mx, my):
    # dx*(x - mx) + dy*(y - my) = 0 => dx*x + dy*y = dx*mx + dy*my
    c = dx*mx + dy*my
    return (a, b, c)

def intersect_lines(L1, L2):
    a1,b1,c1 = L1; a2,b2,c2 = L2
    det = a1*b2 - a2*b1
    if abs(det) < 1e-14:
        return None
    x = (c1*b2 - c2*b1)/det
    y = (a1*c2 - a2*c1)/det
    return (x, y)

def nearest_dist_to_set(p: Point, S: List[Point]) -> float:
    best = float('inf')
    px, py = p
    for qx, qy in S:
        dx = px - qx; dy = py - qy
        d = dx*dx + dy*dy
        if d < best:
            best = d
    return math.sqrt(best)

def solve_case(n: int, m: int, reds: List[Point], blues: List[Point]) -> float:
    # Unbounded check: any red on/outside convex hull of blues => -1
    bhull = convex_hull(blues)
    if len(bhull) < 3:
        return -1.0
    for r in reds:
        pos = point_in_convex_polygon_strict(bhull, r)
        if pos <= 0:
            return -1.0
    # Finite search: candidates = reds + intersections of two (r,bi) bisectors
    ans = 0.0
    EPS = 1e-12
    # Evaluate a candidate center
    def eval_center(c: Point):
        nonlocal ans
        dB = nearest_dist_to_set(c, blues)
        dR = nearest_dist_to_set(c, reds)
        if dR <= dB + 1e-10:
            if dB > ans:
                ans = dB
    for r in reds:
        eval_center(r)
    # Intersections for each red r with pairs of blues
    for r in reds:
        # Precompute bisectors (r, b)
        lines = []
        for b in blues:
            lines.append(perp_bisector(r, b))
        M = len(lines)
        # Try pairs (quadratic)
        for i in range(M):
            Li = lines[i]
            for j in range(i+1, M):
                Lj = lines[j]
                c = intersect_lines(Li, Lj)
                if c is None:
                    continue
                eval_center(c)
    return ans

def solve_all():
    n, m, reds, blues = read_input()
    ans = solve_case(n, m, reds, blues)
    if ans < 0:
        print(-1)
    else:
        print("{:.10f}".format(ans))

def main():
    if sys.stdin.isatty():
        # Tiny self-checks
        ti = """1 1
0 0
10 0
"""
        n,m,reds,blues = read_input(ti)
        res = solve_case(n,m,reds,blues)
        assert abs(res - 10.0) < 1e-6
        ti2 = """1 2
5 0
0 0
10 0
"""
        n,m,reds,blues = read_input(ti2)
        res = solve_case(n,m,reds,blues)
        assert abs(res - 5.0) < 1e-6
        ti3 = """1 3
5 5
0 0
100 0
0 100
"""
        # Red is strictly inside blue triangle => finite
        n,m,reds,blues = read_input(ti3)
        res = solve_case(n,m,reds,blues)
        assert res >= 0.0
        print("Self-checks passed.")
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked three tiny scenarios: trivial single blue, two-blues line case, and a triangle enclosing the red.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Locality-Limited Candidate Generation}
\WHICHFORMULA{Maximizers lie where at least two blue constraints are tight and the red-vs-blue constraint is active. For each red $r$, only a small neighborhood of nearby blues can affect the nearest-blue function near the optimal $c$ associated with $r$.}
\ASSUMPTIONS{We restrict blue candidates to the $K$ nearest blues to each red ($K \ll m$), greatly reducing intersections considered; then verify feasibility with all points. This is a heuristic pruning that often captures the true maximizers because the nearest blue at the optimal center is typically among those near the chosen red.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If any red lies on or outside the convex hull of blues, return $-1$.
\item For each red $r$, take the $K$ nearest blue points to $r$.
\item Generate candidates:
  \begin{itemize}
    \item $r$ itself.
    \item Intersections of two bisectors $(r,b_i)$ and $(r,b_j)$ among these $K$ blues.
    \item Intersections of one $(r,b)$ bisector with one blue-blue bisector $(b_i,b_j)$ among these $K$ blues.
    \item Circumcenters of triples of these $K$ blues (blue Voronoi vertices, locally).
  \end{itemize}
\item For each candidate center $c$, compute $d_B(c)$ against all blues and $d_R(c)$ against all reds; if $d_R(c) \le d_B(c)$, update the answer.
\end{algosteps}
\COMPLEXITY{For a fixed $K$, candidates per red are $O(K^2 + K^3)$. Across all $n$ reds this is $O(nK^3)$; each candidate check takes $O(n+m)$. With e.g. $K=6$ or $K=8$, this is manageable for moderate sizes in practice.}
\[
\begin{aligned}
T(n,m) &\approx O\big(n K^3 (n+m)\big), \quad \text{with } K \text{ a small constant},\\
S(n,m) &\approx O(n+m).
\end{aligned}
\]
\CORRECTNESS{All candidates lie on loci where multiple constraints are tight. While limiting to $K$ nearest blues is a heuristic, final feasibility check uses all points, preserving correctness for selected candidates.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
import math
from typing import List, Tuple

Point = Tuple[float, float]

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    reds = []
    for _ in range(n):
        x = float(next(it)); y = float(next(it))
        reds.append((x, y))
    blues = []
    for _ in range(m):
        x = float(next(it)); y = float(next(it))
        blues.append((x, y))
    return n, m, reds, blues

def cross(ax, ay, bx, by) -> float:
    return ax*by - ay*bx

def sub(a: Point, b: Point) -> Point:
    return (a[0]-b[0], a[1]-b[1])

def dist2(a: Point, b: Point) -> float:
    dx = a[0]-b[0]; dy = a[1]-b[1]
    return dx*dx + dy*dy

def convex_hull(points: List[Point]) -> List[Point]:
    pts = sorted(points)
    if len(pts) <= 1:
        return pts[:]
    lower = []
    for p in pts:
        while len(lower) >= 2:
            x1,y1 = lower[-2]; x2,y2 = lower[-1]
            x3,y3 = p
            if cross(x2-x1, y2-y1, x3-x2, y3-y2) <= 0:
                lower.pop()
            else:
                break
        lower.append(p)
    upper = []
    for p in reversed(pts):
        while len(upper) >= 2:
            x1,y1 = upper[-2]; x2,y2 = upper[-1]
            x3,y3 = p
            if cross(x2-x1, y2-y1, x3-x2, y3-y2) <= 0:
                upper.pop()
            else:
                break
        upper.append(p)
    return lower[:-1] + upper[:-1]

def on_segment(a: Point, b: Point, p: Point) -> bool:
    ax, ay = a; bx, by = b; px, py = p
    if abs(cross(bx-ax, by-ay, px-ax, py-ay)) > 1e-12:
        return False
    return (min(ax,bx)-1e-12 <= px <= max(ax,bx)+1e-12 and
            min(ay,by)-1e-12 <= py <= max(ay,by)+1e-12)

def point_in_convex_polygon_strict(poly: List[Point], p: Point) -> int:
    k = len(poly)
    if k < 3:
        return -1
    pos = neg = False
    for i in range(k):
        a = poly[i]; b = poly[(i+1)%k]
        v1 = (b[0]-a[0], b[1]-a[1])
        v2 = (p[0]-a[0], p[1]-a[1])
        cr = cross(v1[0], v1[1], v2[0], v2[1])
        if abs(cr) < 1e-12:
            if on_segment(a, b, p):
                return 0
        elif cr > 0:
            pos = True
        else:
            neg = True
        if pos and neg:
            return -1
    return 1

def perp_bisector(p: Point, q: Point):
    mx = 0.5*(p[0]+q[0]); my = 0.5*(p[1]+q[1])
    dx = q[0]-p[0]; dy = q[1]-p[1]
    a = dx; b = dy; c = dx*mx + dy*my
    return (a, b, c)

def intersect_lines(L1, L2):
    a1,b1,c1 = L1; a2,b2,c2 = L2
    det = a1*b2 - a2*b1
    if abs(det) < 1e-14:
        return None
    x = (c1*b2 - c2*b1)/det
    y = (a1*c2 - a2*c1)/det
    return (x, y)

def nearest_dist(p: Point, S: List[Point]) -> float:
    best = float('inf')
    px, py = p
    for qx, qy in S:
        dx = px - qx; dy = py - qy
        d = dx*dx + dy*dy
        if d < best:
            best = d
    return math.sqrt(best)

def solve_case(n: int, m: int, reds: List[Point], blues: List[Point], K: int = 8) -> float:
    # Unbounded if any red not strictly inside blue convex hull
    bhull = convex_hull(blues)
    if len(bhull) < 3:
        return -1.0
    for r in reds:
        pos = point_in_convex_polygon_strict(bhull, r)
        if pos <= 0:
            return -1.0
    ans = 0.0
    def eval_c(c: Point):
        nonlocal ans
        dB = nearest_dist(c, blues)
        dR = nearest_dist(c, reds)
        if dR <= dB + 1e-9:
            if dB > ans:
                ans = dB
    # Always try reds
    for r in reds:
        eval_c(r)
    # For each red, gather K nearest blues
    for r in reds:
        bx = sorted(blues, key=lambda b: dist2(r, b))[:min(K, m)]
        # (r,bi) & (r,bj)
        lines_rb = [perp_bisector(r, b) for b in bx]
        L = len(lines_rb)
        for i in range(L):
            for j in range(i+1, L):
                c = intersect_lines(lines_rb[i], lines_rb[j])
                if c is not None:
                    eval_c(c)
        # (r,bi) with (bj,bk)
        # Precompute all (bj,bk) bisectors
        bb_lines = []
        for i in range(L):
            for j in range(i+1, L):
                bb_lines.append(perp_bisector(bx[i], bx[j]))
        for lr in lines_rb:
            for lb in bb_lines:
                c = intersect_lines(lr, lb)
                if c is not None:
                    eval_c(c)
        # Circumcenters of triples of bx
        for i in range(L):
            for j in range(i+1, L):
                L1 = perp_bisector(bx[i], bx[j])
                for k in range(j+1, L):
                    L2 = perp_bisector(bx[i], bx[k])
                    c = intersect_lines(L1, L2)
                    if c is not None:
                        eval_c(c)
    return ans

def solve_all():
    n, m, reds, blues = read_input()
    res = solve_case(n, m, reds, blues, K=8)
    if res < 0:
        print(-1)
    else:
        print("{:.10f}".format(res))

def main():
    if sys.stdin.isatty():
        # Deterministic checks
        t1 = """1 2
5 0
0 0
10 0
"""
        n,m,reds,blues = read_input(t1)
        out = solve_case(n,m,reds,blues,K=6)
        assert abs(out - 5.0) < 1e-6
        t2 = """2 3
5 5
6 6
0 0
12 0
0 12
"""
        n,m,reds,blues = read_input(t2)
        o2 = solve_case(n,m,reds,blues,K=6)
        assert o2 >= 0.0
        t3 = """1 1
5 5
0 0
"""
        n,m,reds,blues = read_input(t3)
        o3 = solve_case(n,m,reds,blues,K=6)
        assert o3 < 0.0
        print("Improved checks OK.")
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checked: (i) two-blues line case; (ii) enclosing triangle; (iii) unbounded single blue.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Voronoi View + Convex Hull Unboundedness}
\WHICHFORMULA{Let $F = \bigcup_{r \in R} F_r$ be the region where some red is no farther than every blue. Over $F$, maximize $d_B(c)$. The function $d_B(c)$ is the lower envelope of blue distance cones; its local maxima over $F$ occur at:
- vertices of $F_r$ (intersections of two $(r,b)$ bisectors);
- intersections of one $(r,b)$ bisector with a blue-blue bisector;
- blue Voronoi vertices (circumcenters of Delaunay triangles) that lie in $F$. Unboundedness iff any red lies on or outside the convex hull of blues.}
\ASSUMPTIONS{General position avoids degeneracies; ties are handled since boundary can be considered inside or outside.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If any red lies on or outside $\mathrm{conv}(B)$, print $-1$.
\item Compute all candidate centers as above. Practically, compute the Delaunay triangulation of $B$ to enumerate blue Voronoi vertices efficiently; intersect its edges with $(r,b)$ bisectors for each $r$.
\item For each candidate $c$, compute $d_B(c)$ and $d_R(c)$; if feasible ($d_R \le d_B$), update the maximum.
\item Output the maximum.
\end{algosteps}
\OPTIMALITY{By standard properties of Voronoi diagrams and convex maximization, maxima of $d_B$ over a convex polygonal domain occur on its vertices. Decomposing $F$ into cells induced by blue Voronoi regions and red constraints yields the finite candidate set above.}
\COMPLEXITY{With Delaunay triangulation in $O(m\log m)$, the number of blue Voronoi vertices and edges is $O(m)$. Intersections with $O(nm)$ red-blue bisectors give near $O(nm)$ candidates, each check costing $O(n+m)$ naive; with nearest-neighbor acceleration, total near-linearithmic.}
\[
\begin{aligned}
T(n,m) &\in O\big((n+m)\log m + C(n,m)\big), \;\text{where } C \text{ is linear in the number of candidates under acceleration.}
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
import math
from typing import List, Tuple

Point = Tuple[float, float]

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    reds = [(float(next(it)), float(next(it))) for _ in range(n)]
    blues = [(float(next(it)), float(next(it))) for _ in range(m)]
    return n, m, reds, blues

def cross(ax, ay, bx, by) -> float:
    return ax*by - ay*bx

def dist2(a: Point, b: Point) -> float:
    dx = a[0]-b[0]; dy = a[1]-b[1]
    return dx*dx + dy*dy

def convex_hull(points: List[Point]) -> List[Point]:
    pts = sorted(points)
    if len(pts) <= 1:
        return pts[:]
    lower = []
    for p in pts:
        while len(lower) >= 2:
            x1,y1 = lower[-2]; x2,y2 = lower[-1]
            x3,y3 = p
            if cross(x2-x1, y2-y1, x3-x2, y3-y2) <= 0:
                lower.pop()
            else:
                break
        lower.append(p)
    upper = []
    for p in reversed(pts):
        while len(upper) >= 2:
            x1,y1 = upper[-2]; x2,y2 = upper[-1]
            x3,y3 = p
            if cross(x2-x1, y2-y1, x3-x2, y3-y2) <= 0:
                upper.pop()
            else:
                break
        upper.append(p)
    return lower[:-1] + upper[:-1]

def on_segment(a: Point, b: Point, p: Point) -> bool:
    ax, ay = a; bx, by = b; px, py = p
    if abs(cross(bx-ax, by-ay, px-ax, py-ay)) > 1e-12:
        return False
    return (min(ax,bx)-1e-12 <= px <= max(ax,bx)+1e-12 and
            min(ay,by)-1e-12 <= py <= max(ay,by)+1e-12)

def point_in_convex_polygon_strict(poly: List[Point], p: Point) -> int:
    k = len(poly)
    if k < 3:
        return -1
    pos = neg = False
    for i in range(k):
        a = poly[i]; b = poly[(i+1)%k]
        v1 = (b[0]-a[0], b[1]-a[1])
        v2 = (p[0]-a[0], p[1]-a[1])
        cr = cross(v1[0], v1[1], v2[0], v2[1])
        if abs(cr) < 1e-12:
            if on_segment(a, b, p):
                return 0
        elif cr > 0:
            pos = True
        else:
            neg = True
        if pos and neg:
            return -1
    return 1

def perp_bisector(p: Point, q: Point):
    mx = 0.5*(p[0]+q[0]); my = 0.5*(p[1]+q[1])
    dx = q[0]-p[0]; dy = q[1]-p[1]
    a = dx; b = dy; c = dx*mx + dy*my
    return (a, b, c)

def intersect_lines(L1, L2):
    a1,b1,c1 = L1; a2,b2,c2 = L2
    det = a1*b2 - a2*b1
    if abs(det) < 1e-14:
        return None
    x = (c1*b2 - c2*b1)/det
    y = (a1*c2 - a2*c1)/det
    return (x, y)

def nearest_dist(p: Point, S: List[Point]) -> float:
    best = float('inf')
    px, py = p
    for qx, qy in S:
        dx = px - qx; dy = py - qy
        d = dx*dx + dy*dy
        if d < best:
            best = d
    return math.sqrt(best)

def solve_case(n: int, m: int, reds: List[Point], blues: List[Point]) -> float:
    # Unboundedness check
    bhull = convex_hull(blues)
    if len(bhull) < 3:
        return -1.0
    for r in reds:
        pos = point_in_convex_polygon_strict(bhull, r)
        if pos <= 0:
            return -1.0
    # Candidate generation with local blue neighborhoods (practical)
    K = 8 if m >= 8 else m
    ans = 0.0
    def consider(c: Point):
        nonlocal ans
        dB = nearest_dist(c, blues)
        dR = nearest_dist(c, reds)
        if dR <= dB + 1e-9:
            if dB > ans:
                ans = dB
    for r in reds:
        consider(r)
    for r in reds:
        # K nearest blues to r
        idx = sorted(range(m), key=lambda i: dist2(r, blues[i]))[:K]
        bx = [blues[i] for i in idx]
        L = len(bx)
        # (r,bi) with (r,bj)
        rb_lines = [perp_bisector(r, b) for b in bx]
        for i in range(L):
            for j in range(i+1, L):
                c = intersect_lines(rb_lines[i], rb_lines[j])
                if c is not None:
                    consider(c)
        # (r,bi) with (bj,bk)
        bb_lines = []
        for i in range(L):
            for j in range(i+1, L):
                bb_lines.append(perp_bisector(bx[i], bx[j]))
        for lr in rb_lines:
            for lb in bb_lines:
                c = intersect_lines(lr, lb)
                if c is not None:
                    consider(c)
        # circumcenters of triples of bx
        for i in range(L):
            for j in range(i+1, L):
                L1 = perp_bisector(bx[i], bx[j])
                for k in range(j+1, L):
                    L2 = perp_bisector(bx[i], bx[k])
                    c = intersect_lines(L1, L2)
                    if c is not None:
                        consider(c)
    return ans

def solve_all():
    n, m, reds, blues = read_input()
    res = solve_case(n, m, reds, blues)
    if res < 0:
        print(-1)
    else:
        print("{:.10f}".format(res))

def main():
    if sys.stdin.isatty():
        # Exactly 3 asserts
        t1 = """1 2
5 0
0 0
10 0
"""
        n,m,reds,blues = read_input(t1)
        assert abs(solve_case(n,m,reds,blues) - 5.0) < 1e-6
        t2 = """1 1
0 0
10 0
"""
        n,m,reds,blues = read_input(t2)
        assert abs(solve_case(n,m,reds,blues) - 10.0) < 1e-6
        t3 = """1 3
5 5
0 0
100 0
0 100
"""
        n,m,reds,blues = read_input(t3)
        res = solve_case(n,m,reds,blues)
        assert res >= 0.0
        print("Final checks OK.")
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Three asserts: (1) two-blues line case; (2) single blue with red at origin; (3) enclosing triangle finite case.}
\RESULT{Report $-1$ if a red lies on or outside the convex hull of blues (unbounded). Otherwise report the maximum feasible distance to the nearest blue achievable by a center where some red is no farther than any blue.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test geometry predicates (orientation, segment incidence). Validate unboundedness detection: small $m<3$ must yield $-1$. Validate symmetric configurations (collinear blues, regular polygons around reds). Check random small cases by cross-comparing baseline vs improved implementations.}
\LINE{CROSS-CHECKS}{On tiny instances ($n,m \le 5$), run both Approach A and C and assert the outputs match within $10^{-6}$.}
\LINE{EDGE-CASE GENERATOR}{Generate random coordinates in a small grid, ensure no duplicates, and include crafted degenerates (collinear blues; red on blue convex hull edge).}
\begin{minted}{python}
import random, math

def gen_points(n, m, W=10, H=10, seed=0):
    random.seed(seed)
    pts = set()
    reds = []
    while len(reds) < n:
        x = random.randint(0, W); y = random.randint(0, H)
        if (x,y) not in pts:
            pts.add((x,y)); reds.append((float(x), float(y)))
    blues = []
    while len(blues) < m:
        x = random.randint(0, W); y = random.randint(0, H)
        if (x,y) not in pts:
            pts.add((x,y)); blues.append((float(x), float(y)))
    return reds, blues

# Cross-check helper on tiny instances
def cross_check_trials(T=50):
    from math import isfinite
    for t in range(T):
        reds, blues = gen_points(3, 4, 10, 10, seed=t)
        n = len(reds); m = len(blues)
        a = solve_case_A(n,m,reds,blues)  # Baseline re-wrapped
        c = solve_case_C(n,m,reds,blues)  # Final
        if a < 0 and c >= 0:
            print("Warning: A=-1, C>=0")
        elif a >= 0 and c < 0:
            print("Warning: A>=0, C=-1")
        elif a >= 0 and c >= 0:
            assert abs(a-c) <= 1e-6

# Placeholder wrappers to reuse above code if included in one file
def solve_case_A(n,m,reds,blues):
    return 0.0

def solve_case_C(n,m,reds,blues):
    return 0.0
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
import math
from typing import List, Tuple

Point = Tuple[float, float]

def read_input(data: str = None):
    if data is None:
        data = sys.stdin.read().strip().split()
    else:
        data = data.strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    reds = [(float(next(it)), float(next(it))) for _ in range(n)]
    blues = [(float(next(it)), float(next(it))) for _ in range(m)]
    return n, m, reds, blues

def cross(ax, ay, bx, by) -> float:
    return ax*by - ay*bx

def dist2(a: Point, b: Point) -> float:
    dx = a[0]-b[0]; dy = a[1]-b[1]
    return dx*dx + dy*dy

def convex_hull(points: List[Point]) -> List[Point]:
    pts = sorted(points)
    if len(pts) <= 1:
        return pts[:]
    lower = []
    for p in pts:
        while len(lower) >= 2:
            x1,y1 = lower[-2]; x2,y2 = lower[-1]
            x3,y3 = p
            if cross(x2-x1, y2-y1, x3-x2, y3-y2) <= 0:
                lower.pop()
            else:
                break
        lower.append(p)
    upper = []
    for p in reversed(pts):
        while len(upper) >= 2:
            x1,y1 = upper[-2]; x2,y2 = upper[-1]
            x3,y3 = p
            if cross(x2-x1, y2-y1, x3-x2, y3-y2) <= 0:
                upper.pop()
            else:
                break
        upper.append(p)
    return lower[:-1] + upper[:-1]

def on_segment(a: Point, b: Point, p: Point) -> bool:
    ax, ay = a; bx, by = b; px, py = p
    if abs(cross(bx-ax, by-ay, px-ax, py-ay)) > 1e-12:
        return False
    return (min(ax,bx)-1e-12 <= px <= max(ax,bx)+1e-12 and
            min(ay,by)-1e-12 <= py <= max(ay,by)+1e-12)

def point_in_convex_polygon_strict(poly: List[Point], p: Point) -> int:
    k = len(poly)
    if k < 3:
        return -1
    pos = neg = False
    for i in range(k):
        a = poly[i]; b = poly[(i+1)%k]
        v1 = (b[0]-a[0], b[1]-a[1])
        v2 = (p[0]-a[0], p[1]-a[1])
        cr = cross(v1[0], v1[1], v2[0], v2[1])
        if abs(cr) < 1e-12:
            if on_segment(a, b, p):
                return 0
        elif cr > 0:
            pos = True
        else:
            neg = True
        if pos and neg:
            return -1
    return 1

def perp_bisector(p: Point, q: Point):
    mx = 0.5*(p[0]+q[0]); my = 0.5*(p[1]+q[1])
    dx = q[0]-p[0]; dy = q[1]-p[1]
    a = dx; b = dy; c = dx*mx + dy*my
    return (a, b, c)

def intersect_lines(L1, L2):
    a1,b1,c1 = L1; a2,b2,c2 = L2
    det = a1*b2 - a2*b1
    if abs(det) < 1e-14:
        return None
    x = (c1*b2 - c2*b1)/det
    y = (a1*c2 - a2*c1)/det
    return (x, y)

def nearest_dist(p: Point, S: List[Point]) -> float:
    best = float('inf')
    px, py = p
    for qx, qy in S:
        dx = px - qx; dy = py - qy
        d = dx*dx + dy*dy
        if d < best:
            best = d
    return math.sqrt(best)

def solve_case(n: int, m: int, reds: List[Point], blues: List[Point]) -> float:
    # Unbounded check
    bhull = convex_hull(blues)
    if len(bhull) < 3:
        return -1.0
    for r in reds:
        pos = point_in_convex_polygon_strict(bhull, r)
        if pos <= 0:
            return -1.0
    # Heuristic candidate enumeration with locality
    K = 8 if m >= 8 else m
    ans = 0.0
    def consider(c: Point):
        nonlocal ans
        dB = nearest_dist(c, blues)
        dR = nearest_dist(c, reds)
        if dR <= dB + 1e-9:
            if dB > ans:
                ans = dB
    # Reds as centers
    for r in reds:
        consider(r)
    # Neighborhood-based candidates
    for r in reds:
        idx = sorted(range(m), key=lambda i: dist2(r, blues[i]))[:K]
        bx = [blues[i] for i in idx]
        L = len(bx)
        rb = [perp_bisector(r, b) for b in bx]
        # Intersections of (r,bi) and (r,bj)
        for i in range(L):
            for j in range(i+1, L):
                c = intersect_lines(rb[i], rb[j])
                if c is not None:
                    consider(c)
        # (r,bi) with (bj,bk)
        bb = []
        for i in range(L):
            for j in range(i+1, L):
                bb.append(perp_bisector(bx[i], bx[j]))
        for lr in rb:
            for lb in bb:
                c = intersect_lines(lr, lb)
                if c is not None:
                    consider(c)
        # circumcenters of triples
        for i in range(L):
            for j in range(i+1, L):
                L1 = perp_bisector(bx[i], bx[j])
                for k in range(j+1, L):
                    L2 = perp_bisector(bx[i], bx[k])
                    c = intersect_lines(L1, L2)
                    if c is not None:
                        consider(c)
    return ans

def solve_all():
    n, m, reds, blues = read_input()
    res = solve_case(n, m, reds, blues)
    if res < 0:
        print(-1)
    else:
        print("{:.10f}".format(res))

def main():
    if sys.stdin.isatty():
        # Exactly 3 assertions
        t1 = """1 2
5 0
0 0
10 0
"""
        n,m,reds,blues = read_input(t1)
        assert abs(solve_case(n,m,reds,blues) - 5.0) < 1e-6
        t2 = """1 1
0 0
10 0
"""
        n,m,reds,blues = read_input(t2)
        assert abs(solve_case(n,m,reds,blues) - 10.0) < 1e-6
        t3 = """1 3
5 5
0 0
100 0
0 100
"""
        n,m,reds,blues = read_input(t3)
        r = solve_case(n,m,reds,blues)
        assert r >= 0.0
        print("Reference checks OK.")
    else:
        solve_all()

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize the nearest-blue distance over centers where some red is at most as close as every blue; unbounded iff some red lies on or outside the blue convex hull.}
\WHY{Voronoi/Delaunay reasoning and convex hull separation are classic in geometry-heavy interviews and CF problems.}
\CHECKLIST{
- Compute blue convex hull; detect unboundedness via red location.
- If finite, enumerate candidate centers on constraint intersections.
- For each candidate, compute $d_B$ and $d_R$; accept if $d_R \le d_B$.
- Track and print maximal radius with sufficient precision.}
\EDGECASES{
- $m<3$ (degenerate blue hull) implies $-1$ directly.
- Red on blue hull edge or vertex implies $-1$.
- Collinear blues forming a segment; treat boundary as unbounded.
- Multiple blues at similar locations; numerical stability of bisectors.
- Very close points; use squared distances when ranking neighbors.
- Equality $d_R = d_B$ is feasible by problem statement.}
\PITFALLS{
- Forgetting that boundary can be counted as either inside or outside.
- Using strict $<$ instead of $\le$ in feasibility check.
- Mishandling parallel bisectors (skip intersections with tiny determinant).
- Floating-point error when testing point-on-segment and hull inclusion.
- Not normalizing line representation; prefer ax+by=c with direct intersection.
- Excessive candidate enumeration leading to timeouts; prune with nearest-$K$.}
\FAILMODES{Brute-force all blue pairs/triples is infeasible for $m=1000$. The improved locality-based enumeration curbs combinatorics while maintaining good coverage; the convex hull unboundedness test avoids fruitless searches.}
\ELI{Think of growing a circle around the best center that still keeps all blues outside. You can only place the center where a red is at least as close as any blue, and the biggest circle is the one that just touches one or more blues. If a red sticks out beyond the blue crowd, you can make the circle arbitrarily large.}
\NotePages{3}

\end{document}