% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Number Factorization}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1787/B}}
\LINE{DIFFICULTY / RATING}{1100}
\STATEMENT{Given an integer $n$.

Consider all pairs of integer arrays $a$ and $p$ of the same length such that $n = \prod a_i^{p_i}$ (i.e. $a_1^{p_1}\cdot a_2^{p_2}\cdot\ldots$) ($a_i>1; p_i>0$) and $a_i$ is the product of some (possibly one) distinct prime numbers.

For example, for $n = 28 = 2^2\cdot 7^1 = 4^1 \cdot 7^1$ the array pair $a = [2, 7]$, $p = [2, 1]$ is correct, but the pair of arrays $a = [4, 7]$, $p = [1, 1]$ is not, because $4=2^2$ is a product of non-distinct prime numbers.

Your task is to find the maximum value of $\sum a_i \cdot p_i$ (i.e. $a_1\cdot p_1 + a_2\cdot p_2 + \ldots$) over all possible pairs of arrays $a$ and $p$. Note that you do not need to minimize or maximize the length of the arrays.

Input:
Each test contains multiple test cases. The first line contains an integer $t$ ($1 \le t \le 1000$) — the number of test cases.

Each test case contains only one integer $n$ ($2 \le n \le 10^9$).

Output:
For each test case, print the maximum value of $\sum a_i \cdot p_i$.

Note:
In the first test case, $100 = 10^2$ so that $a = [10]$, $p = [2]$ when $\sum a_i \cdot p_i$ hits the maximum value $10\cdot 2 = 20$. Also, $a = [100]$, $p = [1]$ does not work since $100$ is not made of distinct prime factors.

In the second test case, we can consider $10$ as $10^1$, so $a = [10]$, $p = [1]$. Notice that when $10 = 2^1\cdot 5^1$, $\sum a_i \cdot p_i = 7$.}
\BREAKDOWN{Squarefree $a_i$ means each $a_i$ uses each prime at most once. Group prime exponents of $n$ into the largest possible squarefree products, layer by layer. The optimal is to take in each layer the product of all primes with remaining positive exponent.}
\ELI{Peel $n$ by repeatedly multiplying all still-present distinct primes; add that product to the answer each time.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases.\\
- $t$ integer, $1 \le t \le 1000$.\\
- For each test, one integer $n$, $2 \le n \le 10^9$.}
\OUTPUTS{For each test case, print a single integer: the maximum possible value of $\sum a_i \cdot p_i$ under the constraints. One line per test case.}
\SAMPLES{Example mini-cases (not from the platform statement):\\
- $n=28$: answer $16$ because $28 \to 14 + 2$.\\
- $n=100$: answer $20$ because $100 \to 10 + 10$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $n=\prod_{j=1}^m q_j^{e_j}$ be the prime factorization with distinct primes $q_j$ and exponents $e_j \ge 1$. We seek arrays $(a_i,p_i)$ with each $a_i$ squarefree (product of distinct primes) such that $\prod a_i^{p_i}=n$, maximizing $\sum a_i p_i$.}
\varmapStart
\var{q_j}{the $j$-th distinct prime dividing $n$}
\var{e_j}{its multiplicity in $n$}
\var{L}{number of ``layers'' used}
\var{S_k}{set of indices $j$ with $e_j \ge k$}
\var{A_k}{the product $\prod_{j \in S_k} q_j$}
\var{F(n)}{the maximum value sought}
\varmapEnd
\GOVERN{
\[
  F(n) \;=\; \sum_{k=1}^{\max_j e_j} \prod_{j:~e_j \ge k} q_j
  \quad=\quad \sum_{k \ge 1} A_k,\ \text{where } A_k=\prod_{j\in S_k} q_j,\ S_k=\{j: e_j \ge k\}.
\]
}
\ASSUMPTIONS{Standard integer arithmetic; primes are unique; $n\ge 2$ so at least one prime factor exists.}
\INVARIANTS{%
- At each layer $k$, each prime $q_j$ appears in $A_k$ iff it still has positive remaining exponent.\\
- The product of all layer contributions divides $n$ exactly: dividing $n$ by $A_k$ decrements each $e_j$ by $1$ when $j\in S_k$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly simulate the layer-peeling formula by repeatedly extracting the product of distinct prime divisors of the current $n$.}
\ASSUMPTIONS{Trial division up to $\lfloor\sqrt{n}\rfloor$ per layer is acceptable for $n \le 10^9$ and modest number of layers.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item While $n>1$, compute $c=\prod$ of distinct prime divisors of $n$ via trial division.
\item Add $c$ to the answer, then set $n\gets n/c$.
\item Repeat until $n=1$; output the accumulated sum.
\end{algosteps}
\COMPLEXITY{Let $L$ be the number of layers (equals $\max_j e_j$). Each layer does trial division up to $\sqrt{n_{\text{current}}}$. Worst-case rough bound $O(L\sqrt{n})$, acceptable for constraints but not optimal.}
\[
\begin{aligned}
T(n) &\le \sum_{k=1}^{L} O\big(\sqrt{n_k}\big) \;\le\; O\!\left(L\sqrt{n}\right),\\
S(n) &= O(1).
\end{aligned}
\]
\CORRECTNESS{Each iteration removes exactly one copy of every remaining prime exponent, matching the governing formula. Grouping all available primes per layer maximizes the sum by maximizing each layer's multiplicative product.}
\EDGECASES{Prime powers (e.g., $2^{30}$) yield many layers of $2$; squarefree $n$ gives one layer equal to $n$ itself.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def layer_product_distinct_primes(m: int) -> int:
    """Return product of distinct prime divisors of m (m >= 2)."""
    cur = 1
    d = 2
    x = m
    # Handle factor 2
    if x % d == 0:
        cur *= d
        while x % d == 0:
            x //= d
    d = 3
    while d * d <= x:
        if x % d == 0:
            cur *= d
            while x % d == 0:
                x //= d
        d += 2
    if x > 1:
        cur *= x
    return cur

def solve_case_baseline(n: int) -> int:
    ans = 0
    while n > 1:
        c = layer_product_distinct_primes(n)
        ans += c
        n //= c
    return ans

def read_input() -> list:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    arr = [int(next(it)) for _ in range(t)]
    return arr

def solve_all():
    arr = read_input()
    if not arr:
        return
    out_lines = []
    for n in arr:
        out_lines.append(str(solve_case_baseline(n)))
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    assert layer_product_distinct_primes(28) == 14
    assert solve_case_baseline(100) == 20
    assert solve_case_baseline(10) == 10
    assert solve_case_baseline(28) == 16
    assert solve_case_baseline(2) == 2
    assert solve_case_baseline(4) == 4

if __name__ == "__main__":
    _self_test()
    # Uncomment the next line to run against stdin
    # solve_all()
\end{minted}
\VALIDATION{Checked on $n\in\{2,4,10,28,100\}$ and internal helper consistency.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Single Factorization, Layered Decrement}
\WHICHFORMULA{Factor $n$ once into primes with exponents $e_j$, then sum $\prod_{j: e_j \ge k} q_j$ for $k=1,\ldots,\max e_j$ by decrementing exponents each layer.}
\ASSUMPTIONS{Trial division factorization up to $\sqrt{n}$ once per test; then $O(\#\text{primes} \cdot \max e_j)$ layering.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Factor $n$ into $\{(q_j,e_j)\}$ by trial division.
\item While some $e_j>0$, compute $c=\prod_{j: e_j>0} q_j$, add to answer, and decrement all positive $e_j$.
\item Output the accumulated sum.
\end{algosteps}
\COMPLEXITY{After $O(\sqrt{n})$ factorization, each layer is $O(m)$ where $m$ is the number of distinct primes of $n$. If $E=\max e_j$, time is $O(\sqrt{n} + mE)$ and space $O(m)$.}
\[
\begin{aligned}
T(n) &= O(\sqrt{n}) + O(mE), \quad S(n)=O(m).
\end{aligned}
\]
\CORRECTNESS{Directly implements the governing formula; decrementing exponents ensures each prime contributes exactly once per remaining layer.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def factorize(n: int):
    """Return list of (prime, exponent) for n >= 2."""
    fac = []
    d = 2
    cnt = 0
    while n % d == 0:
        n //= d
        cnt += 1
    if cnt:
        fac.append((d, cnt))
    d = 3
    while d * d <= n:
        cnt = 0
        while n % d == 0:
            n //= d
            cnt += 1
        if cnt:
            fac.append((d, cnt))
        d += 2
    if n > 1:
        fac.append((n, 1))
    return fac

def solve_case_improved(n: int) -> int:
    fac = factorize(n)
    exps = [e for _, e in fac]
    primes = [p for p, _ in fac]
    ans = 0
    while True:
        cur = 1
        any_pos = False
        for i, e in enumerate(exps):
            if e > 0:
                cur *= primes[i]
                exps[i] -= 1
                any_pos = True
        if not any_pos:
            break
        ans += cur
    return ans

def read_input() -> list:
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    arr = [int(next(it)) for _ in range(t)]
    return arr

def solve_all():
    arr = read_input()
    if not arr:
        return
    out_lines = []
    for n in arr:
        out_lines.append(str(solve_case_improved(n)))
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    assert factorize(28) == [(2, 2), (7, 1)]
    assert solve_case_improved(100) == 20
    assert solve_case_improved(10) == 10
    assert solve_case_improved(28) == 16
    assert solve_case_improved(2) == 2
    assert solve_case_improved(4) == 4

if __name__ == "__main__":
    _self_test()
    # Uncomment to run
    # solve_all()
\end{minted}
\VALIDATION{Validated on the same set as baseline; also ensures factorization correctness for $28$.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Layer Sum via Prime Exponents}
\WHICHFORMULA{Same as Approach B: one factorization then layer-wise decrement. This is optimal for the constraints and linear in the total exponent mass.}
\ASSUMPTIONS{Number of distinct primes $m$ for $n\le 10^9$ is small; $E=\max e_j \le 30$ since $2^{30}\approx 10^9$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Factorize $n$ by trial division.
\item Initialize arrays of primes and exponents.
\item In each iteration: multiply primes that still have positive exponent, add to answer, decrement those exponents. Stop when all are zero.
\end{algosteps}
\OPTIMALITY{Given $n$ fixed, the number of layers equals $\max e_j$, and each layer scans $m$ primes. This matches a natural lower bound of touching each exponent once, hence is tight up to constant factors after the one-time factorization.}
\COMPLEXITY{$T(n)=O(\sqrt{n}+mE)$, $S(n)=O(m)$.}
\[
\begin{aligned}
T(n) &= O(\sqrt{n}) + O(mE).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def factorize(n: int):
    fac = []
    # factor 2
    cnt = 0
    while n % 2 == 0:
        n //= 2
        cnt += 1
    if cnt:
        fac.append((2, cnt))
    d = 3
    while d * d <= n:
        cnt = 0
        while n % d == 0:
            n //= d
            cnt += 1
        if cnt:
            fac.append((d, cnt))
        d += 2
    if n > 1:
        fac.append((n, 1))
    return fac

def solve_case(n: int) -> int:
    fac = factorize(n)
    primes = [p for p, _ in fac]
    exps = [e for _, e in fac]
    ans = 0
    while True:
        cur = 1
        any_pos = False
        for i in range(len(exps)):
            if exps[i] > 0:
                cur *= primes[i]
                exps[i] -= 1
                any_pos = True
        if not any_pos:
            break
        ans += cur
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    arr = [int(next(it)) for _ in range(t)]
    return arr

def solve_all():
    arr = read_input()
    if not arr:
        return
    out_lines = []
    for n in arr:
        out_lines.append(str(solve_case(n)))
    sys.stdout.write("\n".join(out_lines))

def _self_test():
    # Exactly 3 asserts
    assert solve_case(100) == 20
    assert solve_case(10) == 10
    assert solve_case(28) == 16

if __name__ == "__main__":
    _self_test()
    # Uncomment to run on stdin
    # solve_all()
\end{minted}
\VALIDATION{Asserts: $(100,20)$, $(10,10)$, $(28,16)$.}
\RESULT{For each test case, output $\sum_{k\ge 1}\ \prod_{p^e\parallel n,~e\ge k} p$, i.e., the sum of layer products of remaining distinct primes.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test on known values; randomized cross-check for small $n$ by comparing baseline vs improved; adversarial cases: prime, prime powers, product of two primes with equal exponents.}
\LINE{CROSS-CHECKS}{Compare Approach A and B on $n\le 10^5$ randomly; verify equality.}
\LINE{EDGE-CASE GENERATOR}{Generates primes, prime powers $2^k$, and products like $2^a 3^b 5^c$.}
\begin{minted}{python}
import sys
import random

def baseline(n: int) -> int:
    def layer_product_distinct_primes(m: int) -> int:
        cur = 1
        x = m
        if x % 2 == 0:
            cur *= 2
            while x % 2 == 0:
                x //= 2
        d = 3
        while d * d <= x:
            if x % d == 0:
                cur *= d
                while x % d == 0:
                    x //= d
            d += 2
        if x > 1:
            cur *= x
        return cur
    ans = 0
    while n > 1:
        c = layer_product_distinct_primes(n)
        ans += c
        n //= c
    return ans

def improved(n: int) -> int:
    def factorize(x: int):
        fac = []
        cnt = 0
        while x % 2 == 0:
            x //= 2
            cnt += 1
        if cnt:
            fac.append((2, cnt))
        d = 3
        while d * d <= x:
            cnt = 0
            while x % d == 0:
                x //= d
                cnt += 1
            if cnt:
                fac.append((d, cnt))
            d += 2
        if x > 1:
            fac.append((x, 1))
        return fac
    fac = factorize(n)
    primes = [p for p, _ in fac]
    exps = [e for _, e in fac]
    ans = 0
    while True:
        cur = 1
        any_pos = False
        for i in range(len(exps)):
            if exps[i] > 0:
                cur *= primes[i]
                exps[i] -= 1
                any_pos = True
        if not any_pos:
            break
        ans += cur
    return ans

def random_tests():
    # Deterministic seed
    random.seed(12345)
    # Small range to keep it fast
    for _ in range(300):
        n = random.randint(2, 100000)
        assert baseline(n) == improved(n)
    # Specific edge cases
    for k in range(2, 31):
        n = 2 ** k
        assert baseline(n) == improved(n)
    for a in range(1, 10):
        for b in range(1, 10):
            n = (2 ** a) * (3 ** b)
            assert baseline(n) == improved(n)

if __name__ == "__main__":
    random_tests()
    print("OK")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def factorize(n: int):
    fac = []
    cnt = 0
    while n % 2 == 0:
        n //= 2
        cnt += 1
    if cnt:
        fac.append((2, cnt))
    d = 3
    while d * d <= n:
        cnt = 0
        while n % d == 0:
            n //= d
            cnt += 1
        if cnt:
            fac.append((d, cnt))
        d += 2
    if n > 1:
        fac.append((n, 1))
    return fac

def solve_case(n: int) -> int:
    fac = factorize(n)
    primes = [p for p, _ in fac]
    exps = [e for _, e in fac]
    ans = 0
    while True:
        cur = 1
        any_pos = False
        for i in range(len(exps)):
            if exps[i] > 0:
                cur *= primes[i]
                exps[i] -= 1
                any_pos = True
        if not any_pos:
            break
        ans += cur
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(data)
    t = int(next(it))
    arr = [int(next(it)) for _ in range(t)]
    return arr

def main():
    arr = read_input()
    if not arr:
        return
    out = []
    for n in arr:
        out.append(str(solve_case(n)))
    sys.stdout.write("\n".join(out))

def _self_test():
    assert solve_case(100) == 20
    assert solve_case(10) == 10
    assert solve_case(28) == 16
    assert solve_case(4) == 4
    assert solve_case(2) == 2

if __name__ == "__main__":
    _self_test()
    # Uncomment for submission
    # main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize $\sum a_i p_i$ with squarefree $a_i$ by peeling $n$ in layers of all remaining distinct primes.}
\WHY{A classic layering/greedy factorization pattern; shows up in number theory and greedy-structure proofs.}
\CHECKLIST{%
- Factor $n$ once.\\
- Initialize exponents.\\
- Loop: multiply all primes with positive exponent; add; decrement.\\
- Stop when all exponents are zero.}
\EDGECASES{%
- $n$ prime $\Rightarrow$ answer $n$.\\
- $n$ squarefree composite $\Rightarrow$ one layer equal to $n$.\\
- Prime powers like $p^k$.\\
- Mix of small primes with large exponents, e.g., $2^a 3^b$.\\
- Largest $n=10^9$ with $n=2^9\cdot 5^9$.\\
- $n$ having a large prime factor close to $\sqrt{n}$.}
\PITFALLS{%
- Forgetting to include a residual prime after trial division loop.\\
- Using integer division incorrectly when updating $n$.\\
- Overflow not an issue in Python, but beware in other languages.\\
- Loop termination when all exponents hit zero.\\
- Inefficient recomputation of factors per layer in final submission.\\
- Mishandling even factor $2$ vs odd trial steps.}
\FAILMODES{Brute recomputation per layer may be slower on crafted inputs; single factorization avoids this. Large $t$ with many worst-case $n$ is handled by Approach C.}
\ELI{Keep stripping one copy of every prime from $n$ at once; each strip adds the product of those primes to your sum. Repeat until $n$ is gone.}
\NotePages{3}

\end{document}