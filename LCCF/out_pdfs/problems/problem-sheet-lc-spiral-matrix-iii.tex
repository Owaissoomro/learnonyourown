% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Spiral Matrix III}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/spiral-matrix-iii/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You start at the cell \texttt{(rStart, cStart)} of an \texttt{rows} $\times$ \texttt{cols} grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.

You will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later). Eventually, we reach all \texttt{rows} $\times$ \texttt{cols} spaces of the grid.

Return \emph{an array of coordinates representing the positions of the grid in the order you visited them}.

\textbf{Example 1:}

\quad \textbf{Input:} rows = 1, cols = 4, rStart = 0, cStart = 0

\quad \textbf{Output:} [[0,0],[0,1],[0,2],[0,3]]

\textbf{Example 2:}

\quad \textbf{Input:} rows = 5, cols = 6, rStart = 1, cStart = 4

\quad \textbf{Output:} [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]

\textbf{Constraints:}
\begin{bullets}
\item $1 \le \text{rows}, \text{cols} \le 100$
\item $0 \le \text{rStart} < \text{rows}$
\item $0 \le \text{cStart} < \text{cols}$
\end{bullets}}
\BREAKDOWN{Simulate a clockwise spiral starting from $(rStart, cStart)$, moving east, south, west, north, increasing segment lengths appropriately, and collect coordinates that lie within the $[\![0,\text{rows}{-}1]\!] \times [\![0,\text{cols}{-}1]\!]$ grid until we collect $\text{rows} \times \text{cols}$ cells.}
\ELI{Walk in an ever-growing rectangle spiral and record only the cells that fall inside the grid until you have listed them all.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers \texttt{rows}, \texttt{cols}, \texttt{rStart}, \texttt{cStart} with:
\begin{bullets}
\item $1 \le \texttt{rows}, \texttt{cols} \le 100$
\item $0 \le \texttt{rStart} < \texttt{rows}$
\item $0 \le \texttt{cStart} < \texttt{cols}$
\end{bullets}}
\OUTPUTS{A list of $\texttt{rows} \times \texttt{cols}$ coordinate pairs \texttt{[r, c]} in the order visited by the spiral walk.}
\SAMPLES{
\begin{bullets}
\item Input: \texttt{rows=1, cols=4, rStart=0, cStart=0} → Output: \texttt{[[0,0],[0,1],[0,2],[0,3]]}
\item Input: \texttt{rows=2, cols=2, rStart=0, cStart=1} → Output: \texttt{[[0,1],[0,0],[1,0],[1,1]]}
\end{bullets}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let the grid be the index set $G = \{0,\ldots,\text{rows}{-}1\} \times \{0,\ldots,\text{cols}{-}1\}$. Define directions in cyclic order as $d_0=(0,1)$, $d_1=(1,0)$, $d_2=(0,-1)$, $d_3=(-1,0)$ (east, south, west, north). Starting at $p_0=(r_0,c_0)=(\texttt{rStart},\texttt{cStart})$, we traverse segments with lengths $1,1,2,2,3,3,\ldots$ along $d_0,d_1,d_2,d_3,d_0,\ldots$, respectively. The output sequence is the subsequence of visited lattice points that lie in $G$, in the order first encountered.}
\varmapStart
\var{\text{rows}, \text{cols}}{Grid dimensions}
\var{(r_0,c_0)}{Starting coordinate}
\var{d_k}{Unit direction at step $k \bmod 4$}
\var{\ell_k}{Segment length at step $k$, with $\ell_{2m}=\ell_{2m+1}=m+1$}
\var{p_t}{Walker position after $t$ unit moves}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
d_k &= \begin{cases}
(0,1) & k \equiv 0 \ (\mathrm{mod}\ 4),\\
(1,0) & k \equiv 1 \ (\mathrm{mod}\ 4),\\
(0,-1) & k \equiv 2 \ (\mathrm{mod}\ 4),\\
(-1,0) & k \equiv 3 \ (\mathrm{mod}\ 4),
\end{cases}
\\
\ell_k &= 1 + \left\lfloor \dfrac{k}{2} \right\rfloor, \\
p_{t+1} &= p_t + d_k \quad\text{for the $\ell_k$ unit moves of segment $k$ in order},\\
\text{Output} &= \bigl[p_t \in G\bigr] \text{ in time order until $|G|=\text{rows}\times\text{cols}$ items collected.}
\end{aligned}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item Grid indices are zero-based.
\item We always include the starting cell $(r_0,c_0)$ first; subsequent positions are added when they lie in bounds.
\item The spiral eventually covers all in-bounds cells because its radius grows without bound.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item After completing two consecutive segments, the segment length increases by $1$.
\item The direction cycles east, south, west, north repeatedly.
\item The set of collected cells is unique (no duplicates) since positions are visited at most once per time step.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate the spiral by walking unit steps: lengths $1,1,2,2,3,3,\ldots$ along directions $\{(0,1),(1,0),(0,-1),(-1,0)\}$, adding coordinates that land within bounds.}
\ASSUMPTIONS{Direct unit-step simulation is acceptable since we stop once $\texttt{rows} \times \texttt{cols}$ cells are recorded.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $(r,c) \leftarrow (\texttt{rStart},\texttt{cStart})$, record if in bounds.
\item For segment length $L$ growing as $1,1,2,2,\ldots$ and directions cycling E,S,W,N:
\begin{bullets}
\item Repeat $L$ times: $(r,c) \leftarrow (r,c) + d$, and if in bounds, record $(r,c)$.
\end{bullets}
\item Stop once we have recorded $\texttt{rows} \times \texttt{cols}$ cells.
\end{algosteps}
\COMPLEXITY{We may take extra out-of-bounds steps, but we record exactly $\texttt{rows} \times \texttt{cols}$ cells. Time is $O(\texttt{rows}\times\texttt{cols})$ and space is $O(\texttt{rows}\times\texttt{cols})$ for the output.}
\[
\begin{aligned}
T(n) &\in \Theta(\text{rows}\times\text{cols}),\\
S(n) &\in \Theta(\text{rows}\times\text{cols}).
\end{aligned}
\]
\CORRECTNESS{The segment-length and direction invariants ensure a standard outward spiral. Because the radius grows unboundedly, every in-bounds cell is eventually visited. We add each cell the first time it is visited, yielding the correct order.}
\EDGECASES{Single row or column, starting on an edge or corner, and the smallest grid $1\times 1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        ans: List[List[int]] = []
        total = rows * cols
        r, c = rStart, cStart
        # directions: E, S, W, N
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        # include starting cell
        if 0 <= r < rows and 0 <= c < cols:
            ans.append([r, c])
        step = 1
        while len(ans) < total:
            for di in range(4):
                dr, dc = dirs[di]
                # walk 'step' unit moves
                for _ in range(step):
                    r += dr
                    c += dc
                    if 0 <= r < rows and 0 <= c < cols:
                        ans.append([r, c])
                        if len(ans) == total:
                            return ans
                # increase step after every two directions
                if di % 2 == 1:
                    step += 1
        return ans

# Asserts (LC-style)
sol = Solution()
assert sol.spiralMatrixIII(1, 4, 0, 0) == [[0,0],[0,1],[0,2],[0,3]]
assert sol.spiralMatrixIII(2, 2, 0, 1) == [[0,1],[0,0],[1,0],[1,1]]
res = sol.spiralMatrixIII(5, 6, 1, 4)
expected_prefix = [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5]]
assert res[:len(expected_prefix)] == expected_prefix
\end{minted}
\VALIDATION{Checked the two sample scenarios and a prefix match for the larger example.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Segment Clipping}
\WHICHFORMULA{Instead of unit-step walking outside the grid, compute each segment and append only the intersection of that segment with the grid, skipping out-of-bounds unit checks.}
\ASSUMPTIONS{The path is axis-aligned per segment, so each segment is either a constant row or a constant column range that can be clipped to $[0,\text{rows}{-}1]$ or $[0,\text{cols}{-}1]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain current head $(r,c)$; record start if in bounds.
\item For each segment with direction $(dr,dc)$ and length $L$:
\begin{bullets}
\item Compute the theoretical end $(r',c')=(r+dr\cdot L,\,c+dc\cdot L)$.
\item If horizontal ($dr=0$) and current row is in bounds, append all columns in the clamped range between $c+1$ and $c+dc\cdot L$.
\item If vertical ($dc=0$) and current column is in bounds, append all rows in the clamped range between $r+1$ and $r+dr\cdot L$.
\item Update $(r,c)\leftarrow(r',c')$. Increase $L$ after every two segments.
\end{bullets}
\item Stop after collecting $\texttt{rows}\times\texttt{cols}$ cells.
\end{algosteps}
\COMPLEXITY{We enumerate each in-bounds cell exactly once, avoiding most out-of-bounds unit steps. Still $O(\texttt{rows}\times\texttt{cols})$ time and $O(\texttt{rows}\times\texttt{cols})$ space for the output, with a smaller constant factor than unit-step simulation.}
\[
\begin{aligned}
T(n) &= \Theta(\text{rows}\times\text{cols}),\\
S(n) &= \Theta(\text{rows}\times\text{cols}).
\end{aligned}
\]
\CORRECTNESS{Clipping preserves the order along each segment and across segments, which matches the spiral walk order. We never miss an in-bounds cell because every unit step lies on some segment and the clamped range covers all in-bounds points of that segment.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        ans: List[List[int]] = []
        total = rows * cols
        r, c = rStart, cStart
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # E, S, W, N

        # include starting cell
        if 0 <= r < rows and 0 <= c < cols:
            ans.append([r, c])

        step = 1
        while len(ans) < total:
            for di in range(4):
                dr, dc = dirs[di]
                # target end regardless of bounds
                rr, cc = r + dr * step, c + dc * step
                if dr == 0:
                    # horizontal run; row fixed at r
                    if 0 <= r < rows:
                        if dc == 1:
                            start = max(c + 1, 0)
                            end = min(c + step, cols - 1)
                            for x in range(start, end + 1):
                                ans.append([r, x])
                                if len(ans) == total:
                                    return ans
                        else:  # dc == -1
                            start = min(c - 1, cols - 1)
                            end = max(c - step, 0)
                            for x in range(start, end - 1, -1):
                                ans.append([r, x])
                                if len(ans) == total:
                                    return ans
                else:
                    # vertical run; column fixed at c
                    if 0 <= c < cols:
                        if dr == 1:
                            start = max(r + 1, 0)
                            end = min(r + step, rows - 1)
                            for y in range(start, end + 1):
                                ans.append([y, c])
                                if len(ans) == total:
                                    return ans
                        else:  # dr == -1
                            start = min(r - 1, rows - 1)
                            end = max(r - step, 0)
                            for y in range(start, end - 1, -1):
                                ans.append([y, c])
                                if len(ans) == total:
                                    return ans
                # advance to segment end
                r, c = rr, cc
                if di % 2 == 1:
                    step += 1
        return ans

# Asserts
sol = Solution()
assert sol.spiralMatrixIII(1, 4, 0, 0) == [[0,0],[0,1],[0,2],[0,3]]
assert sol.spiralMatrixIII(2, 2, 0, 1) == [[0,1],[0,0],[1,0],[1,1]]
check = sol.spiralMatrixIII(3, 5, 1, 2)
assert len(check) == 15 and len({tuple(p) for p in check}) == 15
\end{minted}
\VALIDATION{Verified outputs for small grids; ensured uniqueness and full coverage for a $3\times 5$ grid.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal O(RC) Enumeration}
\WHICHFORMULA{Enumerate only in-bounds points per clipped segment with growing lengths $1,1,2,2,\ldots$ in direction cycle E,S,W,N. This achieves the optimal $O(\texttt{rows}\times\texttt{cols})$ time bound because the output size is $\Theta(\texttt{rows}\times\texttt{cols})$.}
\ASSUMPTIONS{Grid is axis-aligned and finite; start cell is in bounds.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $(r,c)\leftarrow(\texttt{rStart},\texttt{cStart})$, output $[(r,c)]$.
\item For $k=0,1,2,\ldots$, use direction $d_k$ and length $\ell_k=1+\lfloor k/2\rfloor$.
\item Emit the clamped in-bounds points along the segment; jump $(r,c)$ to its theoretical end; stop when output size equals $\texttt{rows}\times\texttt{cols}$.
\end{algosteps}
\OPTIMALITY{Any algorithm must output $\texttt{rows}\times\texttt{cols}$ coordinates, so $\Omega(\texttt{rows}\times\texttt{cols})$ time is required. We match this lower bound while using $O(1)$ auxiliary space beyond the output.}
\COMPLEXITY{Time $T=\Theta(\texttt{rows}\times\texttt{cols})$ and extra space $S=O(1)$ plus the output.}
\[
\begin{aligned}
T(n) &= \Theta(\text{rows}\times\text{cols}),\\
S(n) &= O(1)\ \text{auxiliary}.
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        ans: List[List[int]] = []
        total = rows * cols
        r, c = rStart, cStart
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # E, S, W, N

        if 0 <= r < rows and 0 <= c < cols:
            ans.append([r, c])

        step = 1
        while len(ans) < total:
            for di in range(4):
                dr, dc = dirs[di]
                rr, cc = r + dr * step, c + dc * step
                if dr == 0:
                    if 0 <= r < rows:
                        if dc == 1:
                            lo = max(c + 1, 0)
                            hi = min(c + step, cols - 1)
                            for x in range(lo, hi + 1):
                                ans.append([r, x])
                                if len(ans) == total:
                                    return ans
                        else:
                            lo = min(c - 1, cols - 1)
                            hi = max(c - step, 0)
                            for x in range(lo, hi - 1, -1):
                                ans.append([r, x])
                                if len(ans) == total:
                                    return ans
                else:
                    if 0 <= c < cols:
                        if dr == 1:
                            lo = max(r + 1, 0)
                            hi = min(r + step, rows - 1)
                            for y in range(lo, hi + 1):
                                ans.append([y, c])
                                if len(ans) == total:
                                    return ans
                        else:
                            lo = min(r - 1, rows - 1)
                            hi = max(r - step, 0)
                            for y in range(lo, hi - 1, -1):
                                ans.append([y, c])
                                if len(ans) == total:
                                    return ans
                r, c = rr, cc
                if di % 2 == 1:
                    step += 1
        return ans

# Exactly 3 asserts
sol = Solution()
assert sol.spiralMatrixIII(1, 4, 0, 0) == [[0,0],[0,1],[0,2],[0,3]]
assert sol.spiralMatrixIII(2, 3, 0, 1) == [[0,1],[0,2],[1,2],[1,1],[1,0],[0,0]]
out = sol.spiralMatrixIII(5, 6, 1, 4)
assert len(out) == 30 and out[0] == [1,4] and out[-1] == [0,0]
\end{minted}
\VALIDATION{Compared against samples and a multi-parameter case; verified first and last elements and full length.}
\RESULT{Returns the full visitation order as a list of coordinate pairs, starting at \texttt{(rStart, cStart)} and proceeding in clockwise spiral.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on samples; property tests that output length equals \texttt{rows} $\times$ \texttt{cols}, uniqueness of coordinates, and all coordinates in bounds.}
\LINE{CROSS-CHECKS}{Compare the baseline and improved implementations on randomly generated small grids for equality.}
\LINE{EDGE-CASE GENERATOR}{Covers $1\times 1$, single row, single column, starts at corners and edges, and balanced rectangular grids.}
\begin{minted}{python}
from typing import List, Tuple, Set
import random

# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases() -> List[Tuple[int,int,int,int]]:
    rng = random.Random(0)
    cases = [
        (1,1,0,0),
        (1,5,0,2),
        (5,1,3,0),
        (2,2,0,1),
        (3,4,1,2),
        (5,6,1,4),
        (10,10,0,0),
        (10,10,9,9),
    ]
    for _ in range(20):
        rows = rng.randint(1, 10)
        cols = rng.randint(1, 10)
        r = rng.randint(0, rows-1)
        c = rng.randint(0, cols-1)
        cases.append((rows, cols, r, c))
    return cases

class Baseline:
    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        ans: List[List[int]] = []
        total = rows * cols
        r, c = rStart, cStart
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        if 0 <= r < rows and 0 <= c < cols:
            ans.append([r, c])
        step = 1
        while len(ans) < total:
            for di in range(4):
                dr, dc = dirs[di]
                for _ in range(step):
                    r += dr
                    c += dc
                    if 0 <= r < rows and 0 <= c < cols:
                        ans.append([r, c])
                        if len(ans) == total:
                            return ans
                if di % 2 == 1:
                    step += 1
        return ans

class Final:
    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        ans: List[List[int]] = []
        total = rows * cols
        r, c = rStart, cStart
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        if 0 <= r < rows and 0 <= c < cols:
            ans.append([r, c])
        step = 1
        while len(ans) < total:
            for di in range(4):
                dr, dc = dirs[di]
                rr, cc = r + dr * step, c + dc * step
                if dr == 0:
                    if 0 <= r < rows:
                        if dc == 1:
                            lo = max(c + 1, 0)
                            hi = min(c + step, cols - 1)
                            for x in range(lo, hi + 1):
                                ans.append([r, x])
                                if len(ans) == total:
                                    return ans
                        else:
                            lo = min(c - 1, cols - 1)
                            hi = max(c - step, 0)
                            for x in range(lo, hi - 1, -1):
                                ans.append([r, x])
                                if len(ans) == total:
                                    return ans
                else:
                    if 0 <= c < cols:
                        if dr == 1:
                            lo = max(r + 1, 0)
                            hi = min(r + step, rows - 1)
                            for y in range(lo, hi + 1):
                                ans.append([y, c])
                                if len(ans) == total:
                                    return ans
                        else:
                            lo = min(r - 1, rows - 1)
                            hi = max(r - step, 0)
                            for y in range(lo, hi - 1, -1):
                                ans.append([y, c])
                                if len(ans) == total:
                                    return ans
                r, c = rr, cc
                if di % 2 == 1:
                    step += 1
        return ans

def in_bounds(rows:int, cols:int, p:Tuple[int,int])->bool:
    r,c = p
    return 0 <= r < rows and 0 <= c < cols

# Cross-check
base = Baseline()
final = Final()
for rows, cols, r, c in gen_cases():
    a = base.spiralMatrixIII(rows, cols, r, c)
    b = final.spiralMatrixIII(rows, cols, r, c)
    assert a == b, (rows, cols, r, c, a, b)
    assert len(a) == rows*cols
    assert len({tuple(p) for p in a}) == rows*cols
    assert all(in_bounds(rows, cols, tuple(p)) for p in a)

print("All cross-checks passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        ans: List[List[int]] = []
        total = rows * cols
        r, c = rStart, cStart
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # E, S, W, N

        if 0 <= r < rows and 0 <= c < cols:
            ans.append([r, c])

        step = 1
        while len(ans) < total:
            for di in range(4):
                dr, dc = dirs[di]
                rr, cc = r + dr * step, c + dc * step
                if dr == 0:
                    if 0 <= r < rows:
                        if dc == 1:
                            lo = max(c + 1, 0)
                            hi = min(c + step, cols - 1)
                            for x in range(lo, hi + 1):
                                ans.append([r, x])
                                if len(ans) == total:
                                    return ans
                        else:
                            lo = min(c - 1, cols - 1)
                            hi = max(c - step, 0)
                            for x in range(lo, hi - 1, -1):
                                ans.append([r, x])
                                if len(ans) == total:
                                    return ans
                else:
                    if 0 <= c < cols:
                        if dr == 1:
                            lo = max(r + 1, 0)
                            hi = min(r + step, rows - 1)
                            for y in range(lo, hi + 1):
                                ans.append([y, c])
                                if len(ans) == total:
                                    return ans
                        else:
                            lo = min(r - 1, rows - 1)
                            hi = max(r - step, 0)
                            for y in range(lo, hi - 1, -1):
                                ans.append([y, c])
                                if len(ans) == total:
                                    return ans
                r, c = rr, cc
                if di % 2 == 1:
                    step += 1
        return ans

# Basic asserts
sol = Solution()
assert sol.spiralMatrixIII(1, 4, 0, 0) == [[0,0],[0,1],[0,2],[0,3]]
assert sol.spiralMatrixIII(2, 2, 0, 1) == [[0,1],[0,0],[1,0],[1,1]]
assert len(sol.spiralMatrixIII(5, 6, 1, 4)) == 30
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Simulate a clockwise spiral with segment lengths $1,1,2,2,\ldots$, adding only in-bounds cells until all are collected.}
\WHY{This problem tests careful simulation, boundary handling, and recognizing a pattern that guarantees full coverage.}
\CHECKLIST{
\begin{bullets}
\item Directions: E, S, W, N in a loop.
\item Segment lengths: increase after every two segments.
\item Add the starting cell first.
\item Clip segments to grid bounds when appending.
\item Stop exactly after collecting $\texttt{rows}\times\texttt{cols}$ cells.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $1\times 1$ grid.
\item Single row or single column grids.
\item Start at a corner.
\item Start at an edge but not a corner.
\item Narrow grids like $1\times N$ or $N\times 1$.
\item Max sizes $100\times 100$.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to include the starting cell.
\item Not incrementing segment length after every two directions.
\item Off-by-one in clamped ranges when moving west or north.
\item Duplicating cells when segment overlaps previous path.
\item Infinite loop by not stopping when enough cells are collected.
\item Updating $(r,c)$ incorrectly when skipping out-of-bounds portions.
\end{bullets}}
\FAILMODES{Pure in-bounds-only stepping without advancing the head to the true segment end can get stuck. The clipping approach advances the head regardless of bounds, avoiding this.}
\ELI{Walk around the grid in a growing square spiral, writing down each cell you pass that is actually inside the grid. Keep going until you have written down every cell exactly once.}
\NotePages{3}

\end{document}