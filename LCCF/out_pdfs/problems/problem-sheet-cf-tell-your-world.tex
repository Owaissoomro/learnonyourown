% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tell Your World}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/849/B}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{Connect the countless points with lines, till we reach the faraway yonder.

There are $n$ points on a coordinate plane, the $i$-th of which being $(i, y_i)$.

Determine whether it is possible to draw two parallel and non-overlapping lines, such that every point in the set lies on exactly one of them, and each of them passes through at least one point in the set.

Input:
The first line of input contains a positive integer $n$ ($3 \le n \le 1{,}000$) — the number of points.

The second line contains $n$ space-separated integers $y_1, y_2, \ldots, y_n$ ($-10^9 \le y_i \le 10^9$) — the vertical coordinates of each point.

Output:
Output ``Yes'' (without quotes) if it is possible to fulfill the requirements, and ``No'' otherwise.

You can print each letter in any case (upper or lower).

Note:
In the first example, there are five points: $(1, 7)$, $(2, 5)$, $(3, 8)$, $(4, 6)$ and $(5, 9)$. It is possible to draw a line that passes through points $1, 3, 5$, and another one that passes through points $2, 4$ and is parallel to the first one.

In the second example, while it is possible to draw two lines that cover all points, they cannot be made parallel.

In the third example, it is impossible to satisfy both requirements at the same time.}
\BREAKDOWN{We must decide if the points $(i, y_i)$ can be partitioned into exactly two distinct parallel lines. Equivalently, there exists a slope $k$ and two intercepts $b_1 \ne b_2$ such that for each $i$, $y_i = k\,i + b_1$ or $y_i = k\,i + b_2$.}
\ELI{All points must lie on two lines with the same tilt; check if one common slope can explain all points using at most two different offsets.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A single test case:
\begin{bullets}
\item $n$ — integer, $3 \le n \le 1{,}000$.
\item $y_1,\ldots,y_n$ — integers with $-10^9 \le y_i \le 10^9$.
\end{bullets}}
\OUTPUTS{Print ``Yes'' if all points can be covered by two distinct parallel lines (each point on exactly one line, each line has at least one point), otherwise print ``No''.}
\SAMPLES{Example 1
\begin{tcolorbox}
Input\par
5\par
7 5 8 6 9\par
Output\par
Yes
\end{tcolorbox}
Example 2
\begin{tcolorbox}
Input\par
4\par
2 4 6 8\par
Output\par
No
\end{tcolorbox}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Given $n \in \mathbb{N}$ and sequence $(y_i)_{i=1}^n \subset \mathbb{Z}$, decide if there exist $k \in \mathbb{Q}$ and distinct $b_1,b_2 \in \mathbb{Q}$ such that
\begin{BreakableEquation*}
\forall i \in \{1,\ldots,n\},\quad y_i \in \{k\,i + b_1,\; k\,i + b_2\}.
\end{BreakableEquation*}
Equivalently, with $x_i=i$, each point lies on one of two lines with equal slope and different intercepts.}
\varmapStart
\var{n}{number of points}
\var{y_i}{vertical coordinate of point at $x=i$}
\var{k}{common slope of both lines}
\var{b_1,b_2}{intercepts of the two lines, with $b_1 \ne b_2$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\exists k,b_1,b_2\ (b_1 \ne b_2)\ \text{s.t.}\ \forall i,\ (y_i - k\,i - b_1)\,(y_i - k\,i - b_2)=0.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Coordinates are exact integers; $x_i=i$ are distinct; lines are Euclidean lines.}
\INVARIANTS{
\begin{bullets}
\item Parallel lines must share the same slope $k$.
\item For any fixed $(k, b)$, the quantity $y_i - k\,i$ is constant across points on that line.
\item Cross-multiplication avoids floating error: $(y_j - y_i)(t - i) = (y_t - y_i)(j - i)$ iff $i,j,t$ are collinear.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Fix slope $k$ by choosing any pair $(a,b)$, $a<b$. Then compute the set of intercepts for all points under that $k$; if there are at most two distinct intercepts and not all on the same line, answer ``Yes''.}
\ASSUMPTIONS{Use integer arithmetic via cross-multiplication to avoid precision. For a chosen slope represented by $(\Delta x, \Delta y)=(b-a, y_b - y_a)$, points share a line iff $y_i \Delta x - \Delta y \cdot i$ is equal.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For every pair $(a,b)$ with $1 \le a < b \le n$, set $\Delta x=b-a$, $\Delta y=y_b-y_a$.
\item Compute $c_i = y_i \Delta x - \Delta y \cdot i$ for all $i$ and collect distinct values.
\item If the number of distinct $c_i$ equals $2$, return ``Yes''; if it is $1$, continue; if it exceeds $2$, try next pair.
\end{algosteps}
\COMPLEXITY{There are $\tfrac{n(n-1)}{2}$ pairs; per pair we scan $n$ points.
\[
\begin{aligned}
T(n) &= \Theta\!\bigl(n^2 \cdot n\bigr)=\Theta(n^3),\\
S(n) &= \Theta(n)\ \text{for the set of intercepts.}
\end{aligned}
\]}
\CORRECTNESS{If a valid partition exists with slope $k$, then taking any pair from the same line yields that $k$. Under this $k$, each point's intercept value $c_i$ belongs to exactly one of two constants (the two lines), hence exactly two distinct values appear. If all points are collinear, only one value appears, correctly rejecting. Any incorrect slope produces more than two distinct intercepts, which we ignore.}
\EDGECASES{All points on one line; exactly one point on one line and the rest on the other; large magnitudes of $y_i$; arbitrary sign patterns; minimal $n=3$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 849B - Baseline O(n^3): try all slopes (pairs) and check intercept classes

from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[int]]:
    if data is None:
        import sys
        toks = sys.stdin.read().strip().split()
    else:
        toks = data.strip().split()
    it = iter(toks)
    n = int(next(it))
    ys = [int(next(it)) for _ in range(n)]
    return n, ys

def solve_case(n: int, ys: List[int]) -> str:
    # Early impossibility: n>=3 always; handle trivially though
    if n < 3:
        return "No"
    # Try all pairs to define slope
    # x-coordinates are 1..n
    for a in range(n):
        for b in range(a + 1, n):
            dx = b - a
            dy = ys[b] - ys[a]
            cset = set()
            for i in range(n):
                c = ys[i] * dx - dy * (i + 1)
                cset.add(c)
                if len(cset) > 2:
                    break
            if len(cset) == 2:
                return "Yes"
    return "No"

def solve_all() -> str:
    n, ys = read_input()
    return solve_case(n, ys)

def main():
    print(solve_all())

if __name__ == "__main__":
    # Inline tests
    assert solve_case(5, [7, 5, 8, 6, 9]) == "Yes"   # sample-like
    assert solve_case(4, [2, 4, 6, 8]) == "No"       # all collinear -> cannot split into two distinct parallel lines
    assert solve_case(4, [1, 10, 2, 11]) == "Yes"    # two perfect interleaved lines of slope 1
    main()
\end{minted}
\VALIDATION{Manually verified tiny cases; asserts included in code.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Among the first three points, two must lie on the same of the two target lines (pigeonhole). Trying pairs among $\{1,2,3\}$ suffices to find the common slope $k$. Then validate in one scan using cross-multiplication.}
\ASSUMPTIONS{Indices are $1$-based for $x$; use cross-multiplication to test membership on a line of slope $k$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each candidate pair $(i,j) \in \{(1,2),(1,3),(2,3)\}$, set $\Delta x=j-i$, $\Delta y=y_j-y_i$ to represent the slope $k=\Delta y / \Delta x$.
\item Collect indices that lie on the line through $(i,y_i)$ with slope $k$ via $(y_t-y_i)\Delta x = \Delta y (t-i)$.
\item If no points remain, reject this pair. If exactly one remains, accept. Otherwise, check all remaining points are collinear with the same slope $k$ (i.e., share common $c=y\Delta x - \Delta y \cdot x$); if so, accept.
\end{algosteps}
\COMPLEXITY{We try at most three pairs, each scanning all points once or twice.
\[
\begin{aligned}
T(n) &= \Theta(n),\\
S(n) &= \Theta(1)\ \text{auxiliary plus index lists}.
\end{aligned}
\]}
\CORRECTNESS{By pigeonhole, two of the first three points lie on the same of the two target lines. Their pair determines the common slope $k$. Points not on that line must all lie on a line parallel to it; thus they must be collinear under slope $k$, which is exactly what the check enforces. If all points lie on the first line, we reject (two distinct lines required). If one point remains, a parallel line through it exists and is distinct.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF 849B - Improved O(n): try only pairs among first three points

from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[int]]:
    if data is None:
        import sys
        toks = sys.stdin.read().strip().split()
    else:
        toks = data.strip().split()
    it = iter(toks)
    n = int(next(it))
    ys = [int(next(it)) for _ in range(n)]
    return n, ys

def check_with_pair(ys: List[int], i: int, j: int) -> bool:
    # i, j are 0-based indices; x = idx+1
    dx = j - i
    dy = ys[j] - ys[i]
    n = len(ys)
    on_first = [False] * n
    # mark points on the primary line
    for t in range(n):
        if (ys[t] - ys[i]) * dx == dy * (t - i):
            on_first[t] = True
    rem = [t for t in range(n) if not on_first[t]]
    if len(rem) == 0:
        return False  # would use only one line
    if len(rem) == 1:
        return True   # second line through this point, parallel to the first
    # Check remaining points lie on a line parallel to the first:
    r0 = rem[0]
    for t in rem[1:]:
        if (ys[t] - ys[r0]) * dx != dy * (t - r0):
            return False
    return True

def solve_case(n: int, ys: List[int]) -> str:
    if n < 3:
        return "No"
    # try pairs (1,2), (1,3), (2,3) in 1-based => (0,1), (0,2), (1,2)
    pairs = [(0, 1), (0, 2), (1, 2)]
    for i, j in pairs:
        if j < n and check_with_pair(ys, i, j):
            return "Yes"
    return "No"

def solve_all() -> str:
    n, ys = read_input()
    return solve_case(n, ys)

def main():
    print(solve_all())

if __name__ == "__main__":
    # Inline tests
    assert solve_case(5, [7, 5, 8, 6, 9]) == "Yes"
    assert solve_case(4, [2, 4, 6, 8]) == "No"
    assert solve_case(4, [1, 10, 2, 11]) == "Yes"
    main()
\end{minted}
\VALIDATION{Checked sample-like cases and a few crafted edge cases via asserts.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Pigeonhole on the first three points yields a correct candidate pair; cross-multiplication validates membership on two parallel lines in linear time.}
\ASSUMPTIONS{Indices are consecutive $x=i$; integer arithmetic is exact; parallel means equal slope and distinct intercept.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Generate candidate pairs $(1,2)$, $(1,3)$, $(2,3)$ to define the common slope $k$.
\item For a candidate $(i,j)$, mark points on the line through $(i,y_i)$ with that slope.
\item Verify the remaining points are collinear with the same slope; accept if yes and at least one remaining point exists.
\end{algosteps}
\OPTIMALITY{Any valid configuration must place at least two of the first three points on the same line; hence one of the three pairs recovers the true slope. Each check is linear, giving $\Theta(n)$ time; this is optimal up to constants because we must inspect all points.}
\COMPLEXITY{
\[
\begin{aligned}
T(n) &= \Theta(n),\quad S(n)=\Theta(1).
\end{aligned}
\]}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF 849B - Tell Your World (Final O(n) solution)
# Uses only standard library. Includes read_input, solve_case/solve_all, main, and asserts.

from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[int]]:
    if data is None:
        import sys
        toks = sys.stdin.read().strip().split()
    else:
        toks = data.strip().split()
    it = iter(toks)
    n = int(next(it))
    ys = [int(next(it)) for _ in range(n)]
    return n, ys

def _check_pair(ys: List[int], i: int, j: int) -> bool:
    # 0-based indices; x = idx+1
    dx = j - i
    dy = ys[j] - ys[i]
    n = len(ys)
    on_first = [False] * n
    for t in range(n):
        if (ys[t] - ys[i]) * dx == dy * (t - i):
            on_first[t] = True
    rem = [t for t in range(n) if not on_first[t]]
    if len(rem) == 0:
        return False
    if len(rem) == 1:
        return True
    r0 = rem[0]
    for t in rem[1:]:
        if (ys[t] - ys[r0]) * dx != dy * (t - r0):
            return False
    return True

def solve_case(n: int, ys: List[int]) -> str:
    if n < 3:
        return "No"
    # Try pairs among first three points
    pairs = [(0, 1), (0, 2), (1, 2)]
    for i, j in pairs:
        if j < n and _check_pair(ys, i, j):
            return "Yes"
    return "No"

def solve_all() -> str:
    n, ys = read_input()
    return solve_case(n, ys)

def main():
    print(solve_all())

if __name__ == "__main__":
    # Deterministic asserts
    assert solve_case(5, [7, 5, 8, 6, 9]) == "Yes"   # interleaving two parallel lines
    assert solve_case(4, [2, 4, 6, 8]) == "No"       # all on one line -> cannot use two distinct parallel lines
    assert solve_case(6, [0, 2, 1, 3, 2, 4]) == "Yes"  # two lines with slope 1: y=x and y=x-1
    main()
\end{minted}
\VALIDATION{Three asserts included cover an interleaved-Yes, an all-collinear-No, and a staggered-Yes.}
\RESULT{Print ``Yes'' iff the points can be partitioned into exactly two distinct parallel lines; otherwise print ``No''.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cross-check the final method against the baseline on random small $n$; verify boundary cases: all collinear, exactly one point on the second line, large magnitudes, monotone increasing/decreasing, alternating sequences.}
\LINE{CROSS-CHECKS}{For $n \le 10$, randomly generate $y_i$ in a small range and assert the improved/optimal answer equals the baseline $O(n^3)$ answer.}
\LINE{EDGE-CASE GENERATOR}{Generate instances with: all collinear; two perfect parallel lines; one-point second line; noisy cases that force rejection.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials

from typing import List, Tuple
import random

def gen_collinear(n: int, k: int, b: int) -> List[int]:
    return [k * (i + 1) + b for i in range(n)]

def gen_two_parallel(n: int, k: int, b1: int, b2: int) -> List[int]:
    ys = []
    for i in range(n):
        # alternate assigning to the two lines
        b = b1 if (i % 2 == 0) else b2
        ys.append(k * (i + 1) + b)
    return ys

def brute_yes(n: int, ys: List[int]) -> str:
    # Baseline checker copied conceptually (O(n^3))
    for a in range(n):
        for b in range(a + 1, n):
            dx = b - a
            dy = ys[b] - ys[a]
            cset = set()
            for i in range(n):
                c = ys[i] * dx - dy * (i + 1)
                cset.add(c)
                if len(cset) > 2:
                    break
            if len(cset) == 2:
                return "Yes"
    return "No"

def fast_yes(n: int, ys: List[int]) -> str:
    # Final solver
    def _check_pair(i: int, j: int) -> bool:
        dx = j - i
        dy = ys[j] - ys[i]
        on_first = [False] * n
        for t in range(n):
            if (ys[t] - ys[i]) * dx == dy * (t - i):
                on_first[t] = True
        rem = [t for t in range(n) if not on_first[t]]
        if len(rem) == 0:
            return False
        if len(rem) == 1:
            return True
        r0 = rem[0]
        for t in rem[1:]:
            if (ys[t] - ys[r0]) * dx != dy * (t - r0):
                return False
        return True
    pairs = [(0, 1), (0, 2), (1, 2)]
    if n < 3:
        return "No"
    for i, j in pairs:
        if j < n and _check_pair(i, j):
            return "Yes"
    return "No"

def run_cross_checks():
    random.seed(0)
    # Specific edges
    for n in [3, 4, 5, 8]:
        ys = gen_collinear(n, 2, 3)
        assert fast_yes(n, ys) == "No"
        ys = gen_two_parallel(n, 1, 0, 5)
        assert fast_yes(n, ys) == "Yes"
    # Random fuzz (small n to keep brute force fast)
    for n in range(3, 10):
        for _ in range(200):
            ys = [random.randint(-5, 5) for _ in range(n)]
            assert brute_yes(n, ys) == fast_yes(n, ys)
    return "ok"

if __name__ == "__main__":
    print(run_cross_checks())
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# CF 849B - Tell Your World (Final Reference Implementation)
# Reads from stdin, writes to stdout. Includes minimal asserts.

from typing import List, Tuple

def read_input(data: str = None) -> Tuple[int, List[int]]:
    if data is None:
        import sys
        toks = sys.stdin.read().strip().split()
    else:
        toks = data.strip().split()
    it = iter(toks)
    n = int(next(it))
    ys = [int(next(it)) for _ in range(n)]
    return n, ys

def _check_pair(ys: List[int], i: int, j: int) -> bool:
    dx = j - i
    dy = ys[j] - ys[i]
    n = len(ys)
    on_first = [False] * n
    for t in range(n):
        if (ys[t] - ys[i]) * dx == dy * (t - i):
            on_first[t] = True
    rem = [t for t in range(n) if not on_first[t]]
    if len(rem) == 0:
        return False
    if len(rem) == 1:
        return True
    r0 = rem[0]
    for t in rem[1:]:
        if (ys[t] - ys[r0]) * dx != dy * (t - r0):
            return False
    return True

def solve_case(n: int, ys: List[int]) -> str:
    if n < 3:
        return "No"
    pairs = [(0, 1), (0, 2), (1, 2)]
    for i, j in pairs:
        if j < n and _check_pair(ys, i, j):
            return "Yes"
    return "No"

def solve_all() -> str:
    n, ys = read_input()
    return solve_case(n, ys)

def main():
    print(solve_all())

if __name__ == "__main__":
    # Minimal sanity asserts
    assert solve_case(5, [7, 5, 8, 6, 9]) == "Yes"
    assert solve_case(4, [2, 4, 6, 8]) == "No"
    assert solve_case(4, [1, 10, 2, 11]) == "Yes"
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Partition $(i,y_i)$ into exactly two distinct parallel lines using one common slope and two intercepts.}
\WHY{Common CF/ICPC pattern: deducing structure (parallel lines) and leveraging pigeonhole on first few items to reduce search to $O(n)$.}
\CHECKLIST{
\begin{bullets}
\item Try pairs among the first three points.
\item Compute $(\Delta x,\Delta y)$ and use cross-multiplication to test collinearity.
\item Collect remainders; reject if none, accept if one.
\item Otherwise, ensure all remainders are collinear with the same slope.
\item Print ``Yes''/``No'' accordingly.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item All points collinear $\Rightarrow$ ``No'' (cannot form two distinct parallel lines).
\item Exactly one point off the main line $\Rightarrow$ ``Yes''.
\item $n=3$ with two on one line and one off $\Rightarrow$ ``Yes''.
\item Large $|y_i|$ values near $10^9$; ensure no overflow in languages with fixed-width ints.
\item Non-monotone $y_i$.
\item Alternating between two parallel lines.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Using floating-point slopes/intercepts; must use integer cross-multiplication.
\item Forgetting that $x=i$ is $1$-based; use $i$ or $(i-1)$ consistently.
\item Accepting the case where all points lie on one line (must be rejected).
\item Checking only one candidate pair; must try the three among the first three points.
\item Mishandling sign or multiplying in wrong order in cross-multiplication.
\item Early exit incorrectly when more than two intercepts appear for a wrong slope.
\end{bullets}}
\FAILMODES{Brute force over all slopes can TLE in Python for $n=1000$; the $O(n)$ method survives by trying only three candidate slopes and scanning once. Floating-point approaches fail on precision and equality checks.}
\ELI{Two train tracks with the same tilt must explain all points. Try the first few points to lock the tilt, gather points on one track, and ensure the rest align on the other. If you can do that with at least one point on each track, answer ``Yes''.}
\NotePages{3}

\end{document}