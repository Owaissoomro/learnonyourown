% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Inna and Huge Candy Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/400/C}}
\LINE{DIFFICULTY / RATING}{CF: 400/C \ \textbar\ Rating: 1500}
\STATEMENT{Inna and Dima decided to surprise Sereja. They brought a really huge candy matrix, it is big even for Sereja! Let us number the rows of the giant matrix from $1$ to $n$ from top to bottom and the columns from $1$ to $m$, from left to right. We will represent the cell at the intersection of the $i$-th row and $j$-th column as $(i,j)$. As expected, some cells of the giant candy matrix contain candies. Overall the matrix has $p$ candies: the $k$-th candy is at cell $(x_k, y_k)$.

The time moved closer to dinner and Inna was already going to eat $p$ of her favourite sweets from the matrix, when suddenly Sereja (for a reason he did not share with anyone) rotated the matrix $x$ times clockwise by $90^\circ$. Then he performed the horizontal rotate of the matrix $y$ times. And then he rotated the matrix $z$ times counterclockwise by $90^\circ$. The figure below shows what the rotates of the matrix look like.

Inna got really upset, but Dima suddenly understood two things: the candies did not get damaged and he remembered which cells contained Inna's favourite sweets before Sereja's strange actions. Help the guys find the new coordinates in the candy matrix after the transformation Sereja made!

Input:
The first line of the input contains six integers $n, m, x, y, z, p$ with $1 \le n, m \le 10^9$, $0 \le x, y, z \le 10^9$, $1 \le p \le 10^5$.

Each of the following $p$ lines contains two integers $x_k, y_k$ ($1 \le x_k \le n$, $1 \le y_k \le m$) — the initial coordinates of the $k$-th candy. Two candies can lie on the same cell.

Output:
For each of the $p$ candies, print on a single line its space-separated new coordinates.

Note:
Just for clarity. Horizontal rotating is like a mirroring of the matrix about the vertical axis (columns are reversed).}
\BREAKDOWN{We must compose three transformations on a grid: clockwise $90^\circ$ rotations, horizontal mirror, and counterclockwise $90^\circ$ rotations. Counts reduce modulo $4$ (for rotations) and modulo $2$ (for the mirror). Apply them in the given order while keeping track of the current matrix dimensions.}
\ELI{Rotate and flip the grid as instructed, keeping track of row/column swaps; then report where each candy ends up.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Integers $n, m, x, y, z, p$ with $1 \le n, m \le 10^9$, $0 \le x, y, z \le 10^9$, $1 \le p \le 10^5$; then $p$ pairs $(x_k, y_k)$ with $1 \le x_k \le n$, $1 \le y_k \le m$.}
\OUTPUTS{For each input point, output its final coordinates after the operations, one point per line as ``row column''.}
\SAMPLES{Example 1: $n{=}2, m{=}3, x{=}1, y{=}0, z{=}0$, points $(1,1)$, $(2,3)$ $\to$ $(1,2)$, $(3,1)$. Example 2: $n{=}3, m{=}4, x{=}0, y{=}1, z{=}1$, points $(1,2)$, $(3,4)$ $\to$ $(2,1)$, $(4,3)$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{The state of a candy is a pair $(i,j)$ with $1 \le i \le r$, $1 \le j \le c$, where $(r,c)$ is the current matrix shape. Operations are isometries from the dihedral group of the rectangle: rotations by $\pm 90^\circ$ swap $(r,c)$, and a horizontal mirror keeps $(r,c)$ but reverses the column index.}
\varmapStart
\var{n,m}{Initial matrix dimensions (rows, columns).}
\var{x}{Number of $90^\circ$ clockwise rotations (applied first).}
\var{y}{Number of horizontal mirrors (applied second).}
\var{z}{Number of $90^\circ$ counterclockwise rotations (applied last).}
\var{(i,j)}{Initial coordinates of a candy (1-indexed).}
\var{(r,c)}{Current matrix dimensions while composing transforms.}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{CW}(r,c):(i,j) &\mapsto (j,\, r{-}i{+}1),\quad (r,c)\mapsto(c,r),\\
\text{H}(r,c):(i,j) &\mapsto (i,\, c{-}j{+}1),\quad (r,c)\mapsto(r,c),\\
\text{CCW}(r,c):(i,j) &\mapsto (c{-}j{+}1,\, i),\quad (r,c)\mapsto(c,r).
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are 1-based and remain within bounds after each transform; rotation counts reduce modulo $4$, mirror count modulo $2$.}
\INVARIANTS{(i) Integrality and bounds: after each step, coordinates stay integers within the current shape. (ii) Bijection: the composed transformation is a bijection on cells. (iii) Shape tracking: after each $90^\circ$ rotation, $(r,c)$ swaps.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Apply up to three operations in sequence on each point: $x \bmod 4$ clockwise rotations, $y \bmod 2$ horizontal mirror, $z \bmod 4$ counterclockwise rotations, updating $(r,c)$ as we go.}
\ASSUMPTIONS{Counts are reduced modulo their periods; per-point work is constant because at most $3{+}1{+}3$ simple steps.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Reduce $x \gets x \bmod 4$, $y \gets y \bmod 2$, $z \gets z \bmod 4$.
\item For each point $(i,j)$, set $(r,c) \gets (n,m)$, then:
\begin{bullets}
\item Repeat $x$ times: $(i,j)\gets(j,\, r{-}i{+}1)$, swap $(r,c)$.
\item If $y{=}1$: $(i,j)\gets(i,\, c{-}j{+}1)$.
\item Repeat $z$ times: $(i,j)\gets(c{-}j{+}1,\, i)$, swap $(r,c)$.
\end{bullets}
\item Output $(i,j)$.
\end{algosteps}
\COMPLEXITY{Per point $O(1)$ arithmetic; overall $O(p)$ time and $O(1)$ extra space.}
\[
\begin{aligned}
T(p) &= p\cdot O(1) = O(p),\quad S = O(1).
\end{aligned}
\]
\CORRECTNESS{Follows from composing the exact isometries in the given order with correct current dimensions $(r,c)$. Modulo reduction preserves equivalence classes of repeated operations.}
\EDGECASES{Single row/column ($n{=}1$ or $m{=}1$), large counts ($x,y,z$ huge), overlapping candies, $p{=}1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def transform_point(n, m, x, y, z, i, j):
    # Reduce counts by periods
    x %= 4
    y %= 2
    z %= 4
    r, c = n, m
    a, b = i, j
    # x times CW
    for _ in range(x):
        a, b = b, r - a + 1
        r, c = c, r
    # y times horizontal mirror (at most once)
    if y == 1:
        b = c - b + 1
    # z times CCW
    for _ in range(z):
        a, b = c - b + 1, a
        r, c = c, r
    return a, b

def transform_all(n, m, x, y, z, points):
    return [transform_point(n, m, x, y, z, i, j) for (i, j) in points]

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    x = int(next(it)); y = int(next(it)); z = int(next(it))
    p = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(p)]
    return n, m, x, y, z, pts

def solve_all():
    args = read_input()
    if args is None:
        return
    n, m, x, y, z, pts = args
    res = transform_all(n, m, x, y, z, pts)
    out = sys.stdout
    out.write("\n".join(f"{i} {j}" for (i, j) in res))

def _self_test():
    # Tiny sanity checks (no output on success)
    # Example 1: one CW rotation
    n, m, x, y, z = 2, 3, 1, 0, 0
    pts = [(1, 1), (2, 3)]
    assert transform_all(n, m, x, y, z, pts) == [(1, 2), (3, 1)]
    # Example 2: H then one CCW -> transpose
    n, m, x, y, z = 3, 4, 0, 1, 1
    pts = [(1, 2), (3, 4)]
    assert transform_all(n, m, x, y, z, pts) == [(2, 1), (4, 3)]
    # Reversibility: apply inverse sequence -> identity
    import random
    random.seed(0)
    for _ in range(200):
        n = random.randint(1, 10)
        m = random.randint(1, 10)
        x = random.randint(0, 20)
        y = random.randint(0, 20)
        z = random.randint(0, 20)
        p = 10
        pts = [(random.randint(1, n), random.randint(1, m)) for __ in range(p)]
        fwd = transform_all(n, m, x, y, z, pts)
        inv = transform_all(n, m, z, y, x, fwd)  # inverse: z CW, H^y, x CCW
        assert inv == pts

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Correctness holds on crafted examples, random reversibility checks, and degenerate shapes such as $n{=}1$ or $m{=}1$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Pre-reduce counts ($x\bmod 4$, $y\bmod 2$, $z\bmod 4$) and precompose the three isometries; still constant-time per point without any loops dependent on $x,y,z$.}
\ASSUMPTIONS{The dihedral group on the rectangle has $8$ elements; the composition depends only on $x \bmod 4$, $y \bmod 2$, $z \bmod 4$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Reduce counts modulo their periods.
\item Build a callable that maps $(i,j)$ using at most $3$ assignments: CW and CCW applied $0..3$ times each, and an optional mirror.
\item Apply it to each point.
\end{algosteps}
\COMPLEXITY{Same $O(p)$ time, $O(1)$ space; fewer branches in practice.}
\[
\begin{aligned}
T(p) &= O(p),\quad S(p)=O(1).
\end{aligned}
\]
\CORRECTNESS{Closed under composition; we maintain $(r,c)$ precisely and use exact formulas for each isometry.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

def make_mapper(n, m, x, y, z):
    x %= 4; y %= 2; z %= 4
    def map_point(i, j):
        r, c = n, m
        a, b = i, j
        if x:
            if x == 1:
                a, b = b, r - a + 1
                r, c = c, r
            elif x == 2:
                a, b = r - a + 1, c - b + 1
            elif x == 3:
                a, b = c - b + 1, a
                r, c = c, r
        if y == 1:
            b = c - b + 1
        if z:
            if z == 1:
                a, b = c - b + 1, a
            elif z == 2:
                a, b = r - a + 1, c - b + 1
            elif z == 3:
                a, b = b, r - a + 1
        return a, b
    return map_point

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    x = int(next(it)); y = int(next(it)); z = int(next(it))
    p = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(p)]
    return n, m, x, y, z, pts

def solve_all():
    args = read_input()
    if args is None:
        return
    n, m, x, y, z, pts = args
    f = make_mapper(n, m, x, y, z)
    out = sys.stdout
    out.write("\n".join(f"{i} {j}" for (i, j) in (f(i, j) for (i, j) in pts)))

def _self_test():
    n, m, x, y, z = 2, 3, 1, 0, 0
    f = make_mapper(n, m, x, y, z)
    assert [f(1, 1), f(2, 3)] == [(1, 2), (3, 1)]
    n, m, x, y, z = 3, 4, 0, 1, 1
    f = make_mapper(n, m, x, y, z)
    assert [f(1, 2), f(3, 4)] == [(2, 1), (4, 3)]
    # Random reversibility
    import random
    random.seed(1)
    for _ in range(100):
        n = random.randint(1, 8)
        m = random.randint(1, 8)
        x = random.randint(0, 20)
        y = random.randint(0, 20)
        z = random.randint(0, 20)
        f = make_mapper(n, m, x, y, z)
        finv = make_mapper(n, m, z, y, x)  # inverse sequence
        for i in range(1, n+1):
            for j in range(1, m+1):
                assert finv(*f(i, j)) == (i, j)
if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Matches Baseline on random grids; inverse mapping test passes; consistent on degenerate cases ($n{=}1$ or $m{=}1$).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Use dihedral-group composition with modulo reduction; per-point constant-time mapping with tracked shape $(r,c)$. This is time-optimal since every point must be output.}
\ASSUMPTIONS{Shape updates are necessary only across at most two swaps; operations are associative and closed.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Reduce $x \gets x \bmod 4$, $y \gets y \bmod 2$, $z \gets z \bmod 4$.
\item For each point, apply CW $x$ times, optional mirror, and CCW $z$ times, updating $(r,c)$ accordingly.
\item Print the results.
\end{algosteps}
\OPTIMALITY{Any algorithm must process all $p$ points and output $p$ pairs, implying $\Omega(p)$ time. The method achieves $O(p)$ with $O(1)$ extra memory, hence optimal up to constants.}
\COMPLEXITY{Linear in $p$, constant extra space.}
\[
\begin{aligned}
T(p) &= O(p),\quad S(p)=O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def transform_point(n, m, x, y, z, i, j):
    x %= 4; y %= 2; z %= 4
    r, c = n, m
    a, b = i, j
    for _ in range(x):
        a, b = b, r - a + 1
        r, c = c, r
    if y == 1:
        b = c - b + 1
    for _ in range(z):
        a, b = c - b + 1, a
        r, c = c, r
    return a, b

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    x = int(next(it)); y = int(next(it)); z = int(next(it))
    p = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(p)]
    return n, m, x, y, z, pts

def solve_all():
    args = read_input()
    if args is None:
        return
    n, m, x, y, z, pts = args
    out = sys.stdout
    out.write("\n".join(
        f"{ii} {jj}"
        for (ii, jj) in (transform_point(n, m, x, y, z, i, j) for (i, j) in pts)
    ))

def _self_test():
    # Exactly 3 asserts
    assert transform_point(2, 3, 1, 0, 0, 1, 1) == (1, 2)
    assert transform_point(3, 4, 0, 1, 1, 3, 4) == (4, 3)
    # Inverse sequence restores original
    pts = [(1, 1), (2, 3), (3, 2)]
    fwd = [transform_point(5, 7, 9, 2, 11, i, j) for (i, j) in pts]
    inv = [transform_point(5, 7, 11, 2, 9, i, j) for (i, j) in fwd]
    assert inv == pts

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Three targeted asserts, including an inverse-composition identity, pass.}
\RESULT{For each candy, output its final $(\text{row},\text{column})$ under the composed transformation, with the final shape implicitly determined by the operations.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test primitive transforms (CW, H, CCW); randomized reversibility; regression tests derived from hand-computed tiny cases.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A/B/C on random inputs; ensure perfect agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate $n{=}1$ or $m{=}1$, large $x,y,z$, and repeated identical points to stress boundaries and idempotence.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_cases(seed=42, trials=5):
    random.seed(seed)
    cases = []
    for _ in range(trials):
        n = random.choice([1, 2, 10, 1000])
        m = random.choice([1, 3, 11, 1000])
        x = random.randint(0, 10**9)
        y = random.randint(0, 10**9)
        z = random.randint(0, 10**9)
        p = random.choice([1, 2, 5, 20])
        pts = [(random.randint(1, n), random.randint(1, m)) for __ in range(p)]
        cases.append((n, m, x, y, z, pts))
    return cases

def apply_ref(n, m, x, y, z, pts):
    def tp(n, m, x, y, z, i, j):
        x %= 4; y %= 2; z %= 4
        r, c = n, m
        a, b = i, j
        for _ in range(x):
            a, b = b, r - a + 1
            r, c = c, r
        if y == 1:
            b = c - b + 1
        for _ in range(z):
            a, b = c - b + 1, a
            r, c = c, r
        return a, b
    return [tp(n, m, x, y, z, i, j) for (i, j) in pts]

def test_reversibility():
    for (n, m, x, y, z, pts) in gen_cases():
        fwd = apply_ref(n, m, x, y, z, pts)
        inv = apply_ref(n, m, z, y, x, fwd)
        assert inv == pts

if __name__ == "__main__":
    test_reversibility()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def transform_point(n, m, x, y, z, i, j):
    x %= 4; y %= 2; z %= 4
    r, c = n, m
    a, b = i, j
    for _ in range(x):
        a, b = b, r - a + 1
        r, c = c, r
    if y == 1:
        b = c - b + 1
    for _ in range(z):
        a, b = c - b + 1, a
        r, c = c, r
    return a, b

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return None
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    x = int(next(it)); y = int(next(it)); z = int(next(it))
    p = int(next(it))
    pts = [(int(next(it)), int(next(it))) for _ in range(p)]
    return n, m, x, y, z, pts

def solve_all():
    args = read_input()
    if args is None:
        return
    n, m, x, y, z, pts = args
    out = sys.stdout
    out.write("\n".join(
        f"{ii} {jj}"
        for (ii, jj) in (transform_point(n, m, x, y, z, i, j) for (i, j) in pts)
    ))

def _self_test():
    # No prints; assertions only
    assert transform_point(2, 3, 1, 0, 0, 2, 3) == (3, 1)
    assert transform_point(3, 4, 0, 1, 1, 1, 2) == (2, 1)
    pts = [(1, 1), (2, 2)]
    fwd = [transform_point(5, 7, 8, 3, 5, i, j) for (i, j) in pts]
    inv = [transform_point(5, 7, 5, 3, 8, i, j) for (i, j) in fwd]
    assert inv == pts

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compose CW rotations, a horizontal mirror, and CCW rotations on $(i,j)$ with dimension tracking.}
\WHY{Tests understanding of grid isometries, modulo reduction, and careful index arithmetic.}
\CHECKLIST{
\begin{bullets}
\item Reduce $x \bmod 4$, $y \bmod 2$, $z \bmod 4$.
\item Track $(r,c)$ and swap on each $90^\circ$ rotation.
\item Mirror uses current $c$ (columns) at the time of mirroring.
\item Use 1-based formulas: $r{-}i{+}1$, $c{-}j{+}1$.
\item Apply in the exact order: $x$ CW, $y$ H, $z$ CCW.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n{=}1$ or $m{=}1$ (rotations swap $1$ with $m$ or $n$).
\item $x,y,z$ extremely large (must reduce by period).
\item $p{=}1$ and points at corners/edges.
\item Overlapping candies (mapping is bijective; duplicates remain duplicates).
\item All operations zero (identity).
\item Net odd number of $90^\circ$ rotations (shape swap at the end).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to update $(r,c)$ after each rotation.
\item Using $0$-based instead of $1$-based formulas.
\item Mirroring with stale $c$ after a preceding rotation.
\item Not reducing counts, leading to slow or overflow-prone code.
\item Mixing up CW vs CCW mapping formulas.
\item Printing debug output alongside answers.
\end{bullets}
}
\FAILMODES{If one assumes the final shape is always $(n,m)$, odd total rotations will misplace points. If one mirrors using the initial $m$ instead of current $c$, answers are wrong whenever $x \bmod 2 = 1$.}
\ELI{You spin the board a few times, maybe flip it in a mirror, then spin it back. Each step has a simple formula; just do them in order and keep track of how tall and wide the board is right now.}
\NotePages{3}

\end{document}