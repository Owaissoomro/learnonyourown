% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Columns Swaps}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1385/G}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{You are given a table $a$ of size $2 \times n$ (i.e. two rows and $n$ columns) consisting of integers from $1$ to $n$.

In one move, you can choose some column $j$ ($1 \le j \le n$) and swap values $a_{1, j}$ and $a_{2, j}$ in it. Each column can be chosen no more than once.

Your task is to find the minimum number of moves required to obtain permutations of size $n$ in both first and second rows of the table or determine if it is impossible to do that.

You have to answer $t$ independent test cases.

Recall that the permutation of size $n$ is such an array of size $n$ that contains each integer from $1$ to $n$ exactly once (the order of elements does not matter).

Input:
The first line of the input contains one integer $t$ ($1 \le t \le 2 \cdot 10^4$) — the number of test cases. Then $t$ test cases follow.

The first line of the test case contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of columns in the table. The second line of the test case contains $n$ integers $a_{1, 1}, a_{1, 2}, \dots, a_{1, n}$ ($1 \le a_{1, i} \le n$), where $a_{1, i}$ is the $i$-th element of the first row of the table. The third line of the test case contains $n$ integers $a_{2, 1}, a_{2, 2}, \dots, a_{2, n}$ ($1 \le a_{2, i} \le n$), where $a_{2, i}$ is the $i$-th element of the second row of the table.

It is guaranteed that the sum of $n$ does not exceed $2 \cdot 10^5$ ($\sum n \le 2 \cdot 10^5$).

Output:
For each test case print the answer: $-1$ if it is impossible to obtain permutation of size $n$ in both first and the second rows of the table, or one integer $k$ in the first line, where $k$ is the minimum number of moves required to obtain permutations in both rows, and $k$ distinct integers $pos_1, pos_2, \dots, pos_k$ in the second line ($1 \le pos_i \le n$) in any order — indices of columns in which you need to swap values to obtain permutations in both rows. If there are several answers, you can print any.}
\BREAKDOWN{Check feasibility: every value $1..n$ must appear exactly twice globally. Build a constraint graph on columns with XOR condition along each edge. Solve each connected component, picking the cheaper of two complementary solutions, and collect swap positions.}
\ELI{Treat each value as connecting two columns with a rule saying whether exactly one or either zero-or-two of those columns must be swapped; then per cycle pick the smaller side to swap.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integer $n$; arrays $a_1[1..n]$ and $a_2[1..n]$ with entries in $[1..n]$. Constraints: $1 \le t \le 2 \cdot 10^4$, $1 \le n \le 2 \cdot 10^5$, and $\sum n \le 2 \cdot 10^5$.}
\OUTPUTS{For each test case: if impossible, print $-1$. Otherwise print $k$ on one line and then $k$ distinct column indices (any order) on the next line to swap. If $k=0$, print an empty second line.}
\SAMPLES{Example 1 (possible):
t=1
n=4
a\_1: 1 1 2 3
a\_2: 2 3 4 4
One valid output: 2 on the first line and any two-column set like ``2 4'' on the second.

Example 2 (impossible):
t=1
n=3
a\_1: 1 1 1
a\_2: 1 2 3
Output: -1}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let columns be vertices $V=\{1,\ldots,n\}$. For each value $x\in\{1,\ldots,n\}$, suppose it appears exactly twice at positions $(r_1,c_1)$ and $(r_2,c_2)$ with $r_i\in\{1,2\}$, $c_i\in V$. Create an undirected edge $e=(c_1,c_2)$ labeled $s=\mathbf{1}[r_1=r_2]$. Decision variables $x_c\in\{0,1\}$ denote whether we swap column $c$.}
\varmapStart
\var{x_c}{swap decision for column $c$ ($1$ means swap)}
\var{(c_1,c_2,s)}{edge connecting the two columns holding the same value; $s=1$ if both occurrences start in the same row, else $s=0$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\forall\text{ edges }(u,v,s):\quad x_u \oplus x_v = s.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Feasible iff every value $1..n$ occurs exactly twice in the entire table. The multigraph on columns induced by edges has every vertex of degree $2$ counting self-loops, hence it decomposes into cycles.}
\INVARIANTS{
- Along any cycle, the XOR of labels $s$ must be $0$ for consistency (automatically true for valid instances; otherwise impossible). 
- Flipping all $x$ inside a connected component preserves feasibility, so each component has two complementary solutions; choose the cheaper one.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Model as XOR constraints $x_u \oplus x_v = s$ on a graph whose components are cycles. For each component, try assigning a seed $x=0$ and deduce all others by DFS; the complementary assignment is obtained by flipping all bits. Pick the smaller side.}
\ASSUMPTIONS{All values appear exactly twice; otherwise impossible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count occurrences of each value; if any count $\ne 2$, print $-1$.
\item Build adjacency on columns: for each value, add an undirected labeled edge $(c_1,c_2,s)$ with $s=\mathbf{1}[r_1=r_2]$.
\item For each unvisited column, run DFS to assign $x$ using $x_v=x_u\oplus s$; detect contradictions.
\item In that component, count nodes with $x=0$ and $x=1$; add the smaller class to the answer set.
\item Output the collected columns.
\end{algosteps}
\COMPLEXITY{Linear in total input size.}
\[
\begin{aligned}
T(n) &= O(n) \quad \text{(build edges + DFS over $n$ columns and $n$ edges)} \\
S(n) &= O(n) \quad \text{(adjacency + stacks + bookkeeping).}
\end{aligned}
\]
\CORRECTNESS{Each edge enforces exactly the right parity: same-row duplicates require exactly one swap among the two columns; different-row duplicates require an even number of swaps. DFS enforces all constraints; per component, flipping all bits maintains feasibility, so choosing the smaller class minimizes the number of swaps.}
\EDGECASES{Self-loop when both occurrences are in the same column $(c_1=c_2)$ with $s=0$; it imposes no constraint. Components with one node are handled and may contribute zero swaps.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import defaultdict, deque

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it)
        a1 = [next(it) for _ in range(n)]
        a2 = [next(it) for _ in range(n)]
        cases.append((n, a1, a2))
    return cases

def solve_case(n, a1, a2):
    # 1) feasibility: each value must appear exactly twice
    pos = defaultdict(list)  # val -> list of (row, col)
    for j, v in enumerate(a1):
        pos[v].append((0, j))
    for j, v in enumerate(a2):
        pos[v].append((1, j))
    for v in range(1, n+1):
        if len(pos[v]) != 2:
            return -1, []

    # 2) build adjacency with labeled edges
    adj = [[] for _ in range(n)]  # (neighbor, s)
    for v in range(1, n+1):
        (r1, c1), (r2, c2) = pos[v]
        s = 1 if r1 == r2 else 0
        adj[c1].append((c2, s))
        adj[c2].append((c1, s))

    # 3) DFS assign x, collect minimal swaps per component
    color = [-1] * n  # x in {0,1}
    answer = []

    for i in range(n):
        if color[i] != -1:
            continue
        # start new component with seed 0
        stack = [i]
        color[i] = 0
        comp_nodes = [i]
        ok = True
        while stack and ok:
            u = stack.pop()
            for v, s in adj[u]:
                need = color[u] ^ s
                if color[v] == -1:
                    color[v] = need
                    comp_nodes.append(v)
                    stack.append(v)
                elif color[v] != need:
                    ok = False
                    break
        if not ok:
            return -1, []
        # choose smaller class
        zeros = [u for u in comp_nodes if color[u] == 0]
        ones = [u for u in comp_nodes if color[u] == 1]
        pick = ones if len(ones) < len(zeros) else zeros
        answer.extend(pick)

    # convert to 1-based positions
    answer = [x+1 for x in answer]
    return len(answer), answer

def solve_all(cases):
    out_lines = []
    for (n, a1, a2) in cases:
        k, cols = solve_case(n, a1, a2)
        if k == -1:
            out_lines.append("-1")
        else:
            out_lines.append(str(k))
            out_lines.append(" ".join(map(str, cols)))
    return "\n".join(out_lines)

def _apply_swaps(a1, a2, cols):
    a1 = a1[:]
    a2 = a2[:]
    for c in cols:
        a1[c], a2[c] = a2[c], a1[c]
    return a1, a2

def _is_perm(arr):
    n = len(arr)
    seen = [0]*(n+1)
    for v in arr:
        if v < 1 or v > n or seen[v]:
            return False
        seen[v] = 1
    return True

def _check_solution(n, a1, a2, k, cols):
    if k == -1:
        # brute check impossibility for small n (optional)
        # Here we'll just confirm a value count != 2 case implies -1.
        from collections import Counter
        cnt = Counter(a1 + a2)
        return any(cnt[v] != 2 for v in range(1, n+1))
    cols0 = [c-1 for c in cols]
    b1, b2 = _apply_swaps(a1, a2, cols0)
    return _is_perm(b1) and _is_perm(b2)

def main():
    # Unit tests
    # 1) simple possible with zero swaps
    n = 3
    a1 = [1,2,3]
    a2 = [1,2,3]
    k, cols = solve_case(n, a1, a2)
    assert k == 0 and cols == [], (k, cols)
    assert _check_solution(n, a1, a2, k, cols)

    # 2) impossible case (value 1 appears 4 times)
    n = 3
    a1 = [1,1,1]
    a2 = [1,2,3]
    k, cols = solve_case(n, a1, a2)
    assert k == -1

    # 3) nontrivial component
    n = 4
    a1 = [1,1,2,3]
    a2 = [2,3,4,4]
    k, cols = solve_case(n, a1, a2)
    assert k == 2
    assert _check_solution(n, a1, a2, k, cols)

    # I/O path
    cases = read_input()
    if cases:
        print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Unit asserts include: trivial zero-swap case, an impossible case, and a mixed case where exactly two swaps are needed.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized with Union-Find Compression of $s=0$ Edges}
\WHICHFORMULA{Compress all $s=0$ constraints ($x_u=x_v$) via DSU first, then the remaining $s=1$ constraints form a bipartite graph on DSU components requiring opposite parity across edges. Color it and choose the lighter color in each connected component, weighted by component sizes.}
\ASSUMPTIONS{Feasibility still requires that every value appears exactly twice. If any $s=1$ edge collapses inside a DSU group, it is a contradiction.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build occurrence lists; if any value does not appear exactly twice, print $-1$.
\item DSU-merge columns connected by $s=0$ constraints.
\item For each $s=1$ constraint, connect the DSU representatives with an undirected edge; if both endpoints coincide, print $-1$.
\item For each connected component in this graph, 2-color it; choose the smaller total weight side (weight = number of original columns in the DSU node).
\item Output the union of all chosen DSU nodes' original columns.
\end{algosteps}
\COMPLEXITY{Matches baseline but with faster propagation by contracting $s=0$ chains.}
\[
\begin{aligned}
T(n) &= O(n \,\alpha(n)) \text{ (DSU) } + O(n) \text{ (graph build + BFS)} \\
\end{aligned}
\]
\CORRECTNESS{All $s=0$ equalities are enforced by DSU. Remaining $s=1$ edges force opposite parity across adjacent groups; bipartite coloring is exactly the parity assignment. Picking the lighter color minimizes the total number of swapped columns.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import defaultdict, deque

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.sz = [1]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb: return False
        if self.sz[ra] < self.sz[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        self.sz[ra] += self.sz[rb]
        return True

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it)
        a1 = [next(it) for _ in range(n)]
        a2 = [next(it) for _ in range(n)]
        cases.append((n, a1, a2))
    return cases

def solve_case(n, a1, a2):
    pos = defaultdict(list)
    for j, v in enumerate(a1):
        pos[v].append((0, j))
    for j, v in enumerate(a2):
        pos[v].append((1, j))
    for v in range(1, n+1):
        if len(pos[v]) != 2:
            return -1, []

    dsu = DSU(n)
    odd_edges = []  # edges between DSU reps that must differ
    for v in range(1, n+1):
        (r1, c1), (r2, c2) = pos[v]
        if r1 != r2:
            dsu.union(c1, c2)
    # gather group members
    group_members = defaultdict(list)
    for i in range(n):
        group_members[dsu.find(i)].append(i)
    # build odd edges on compressed nodes
    comp_adj = defaultdict(list)
    for v in range(1, n+1):
        (r1, c1), (r2, c2) = pos[v]
        if r1 == r2:
            u = dsu.find(c1)
            w = dsu.find(c2)
            if u == w:
                return -1, []
            comp_adj[u].append(w)
            comp_adj[w].append(u)

    # 2-color each connected component on compressed graph
    color = {}
    ans_cols = []
    visited = set()
    nodes = set(group_members.keys())
    # ensure isolated nodes also considered
    nodes |= set(comp_adj.keys())
    for start in nodes:
        if start in color:
            continue
        # BFS component
        q = deque([start])
        color[start] = 0
        part = [[], []]  # store compressed nodes by color
        while q:
            u = q.popleft()
            part[color[u]].append(u)
            for v in comp_adj.get(u, []):
                if v not in color:
                    color[v] = color[u] ^ 1
                    q.append(v)
                elif color[v] == color[u]:
                    return -1, []
        # If the node had no neighbors, we prefer not to swap its group
        # Choose lighter side by weight (group sizes)
        w0 = sum(len(group_members[g]) for g in part[0])
        w1 = sum(len(group_members[g]) for g in part[1])
        pick = 0 if w0 <= w1 else 1
        # add original columns from chosen color groups
        for g in part[pick]:
            ans_cols.extend(group_members[g])

    # convert to 1-based
    ans_cols = [c+1 for c in ans_cols]
    return len(ans_cols), ans_cols

def solve_all(cases):
    out_lines = []
    for (n, a1, a2) in cases:
        k, cols = solve_case(n, a1, a2)
        if k == -1:
            out_lines.append("-1")
        else:
            out_lines.append(str(k))
            out_lines.append(" ".join(map(str, cols)))
    return "\n".join(out_lines)

def _apply_swaps(a1, a2, cols):
    a1 = a1[:]
    a2 = a2[:]
    for c in cols:
        a1[c], a2[c] = a2[c], a1[c]
    return a1, a2

def _is_perm(arr):
    n = len(arr)
    seen = [0]*(n+1)
    for v in arr:
        if v < 1 or v > n or seen[v]:
            return False
        seen[v] = 1
    return True

def _check_solution(n, a1, a2, k, cols):
    if k == -1:
        from collections import Counter
        cnt = Counter(a1 + a2)
        return any(cnt[v] != 2 for v in range(1, n+1))
    cols0 = [c-1 for c in cols]
    b1, b2 = _apply_swaps(a1, a2, cols0)
    return _is_perm(b1) and _is_perm(b2)

def main():
    # Tiny tests
    n = 3
    a1 = [1,2,3]
    a2 = [1,2,3]
    k, cols = solve_case(n, a1, a2)
    assert k == 0 and cols == []
    assert _check_solution(n, a1, a2, k, cols)

    n = 4
    a1 = [1,1,2,3]
    a2 = [2,3,4,4]
    k, cols = solve_case(n, a1, a2)
    assert k == 2
    assert _check_solution(n, a1, a2, k, cols)

    n = 3
    a1 = [1,1,1]
    a2 = [1,2,3]
    k, cols = solve_case(n, a1, a2)
    assert k == -1

    cases = read_input()
    if cases:
        print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Checks include trivial, impossible, and mixed nontrivial cases to ensure correctness and formatting.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{DSU Compression + Bipartite Coloring (Provably Minimal)}
\WHICHFORMULA{Use DSU to contract all parity-$0$ equalities, then color the resulting graph built from parity-$1$ constraints. The two colorings in a connected component are complements; pick the lighter color by summing sizes of DSU groups.}
\ASSUMPTIONS{Each value appears exactly twice. Any parity-$1$ edge inside a DSU group yields a contradiction. The compressed graph is bipartite; otherwise the instance is impossible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Collect occurrences; abort if any value has count $\ne 2$.
\item DSU-union columns linked by different-row duplicates ($s=0$).
\item Build an adjacency on DSU representatives using same-row duplicates ($s=1$); check for self-conflicts.
\item BFS each compressed component to 2-color it; choose the color with smaller total number of original columns; add those columns to answer.
\item Output the chosen indices.
\end{algosteps}
\OPTIMALITY{Within each connected component, the feasible solution space consists of exactly two complementary assignments; choosing the color with smaller weight is globally optimal because components are independent.}
\COMPLEXITY{$O(n \alpha(n))$ time and $O(n)$ space; optimal up to inverse-Ackermann factors.}
\[
\begin{aligned}
T(n) &= O(n \alpha(n)) + O(n) \\
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import defaultdict, deque

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.sz = [1]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb: return False
        if self.sz[ra] < self.sz[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        self.sz[ra] += self.sz[rb]
        return True

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it)
        a1 = [next(it) for _ in range(n)]
        a2 = [next(it) for _ in range(n)]
        cases.append((n, a1, a2))
    return cases

def solve_case(n, a1, a2):
    pos = defaultdict(list)
    for j, v in enumerate(a1):
        pos[v].append((0, j))
    for j, v in enumerate(a2):
        pos[v].append((1, j))
    for v in range(1, n+1):
        if len(pos[v]) != 2:
            return -1, []

    dsu = DSU(n)
    # Union s=0 edges
    for v in range(1, n+1):
        (r1, c1), (r2, c2) = pos[v]
        if r1 != r2:
            dsu.union(c1, c2)

    # Compressed groups
    group_members = defaultdict(list)
    for i in range(n):
        group_members[dsu.find(i)].append(i)

    # Build compressed graph for s=1 edges
    comp_adj = defaultdict(list)
    for v in range(1, n+1):
        (r1, c1), (r2, c2) = pos[v]
        if r1 == r2:
            u = dsu.find(c1)
            w = dsu.find(c2)
            if u == w:
                return -1, []
            comp_adj[u].append(w)
            comp_adj[w].append(u)

    # BFS 2-coloring; choose lighter side
    color = {}
    ans_cols = []
    all_nodes = set(group_members.keys()) | set(comp_adj.keys())

    for start in all_nodes:
        if start in color:
            continue
        q = deque([start])
        color[start] = 0
        parts = [[], []]
        while q:
            u = q.popleft()
            parts[color[u]].append(u)
            for v in comp_adj.get(u, []):
                if v not in color:
                    color[v] = color[u] ^ 1
                    q.append(v)
                elif color[v] == color[u]:
                    return -1, []
        # choose min-weight color
        w0 = sum(len(group_members[g]) for g in parts[0])
        w1 = sum(len(group_members[g]) for g in parts[1])
        pick = 0 if w0 <= w1 else 1
        for g in parts[pick]:
            ans_cols.extend(group_members[g])

    ans_cols = [c+1 for c in ans_cols]
    return len(ans_cols), ans_cols

def solve_all(cases):
    out_lines = []
    for (n, a1, a2) in cases:
        k, cols = solve_case(n, a1, a2)
        if k == -1:
            out_lines.append("-1")
        else:
            out_lines.append(str(k))
            out_lines.append(" ".join(map(str, cols)))
    return "\n".join(out_lines)

# --- Tests ---
def _apply_swaps(a1, a2, cols):
    a1 = a1[:]
    a2 = a2[:]
    for c in cols:
        a1[c], a2[c] = a2[c], a1[c]
    return a1, a2

def _is_perm(arr):
    n = len(arr)
    seen = [0]*(n+1)
    for v in arr:
        if v < 1 or v > n or seen[v]:
            return False
        seen[v] = 1
    return True

def _check_solution(n, a1, a2, k, cols):
    if k == -1:
        from collections import Counter
        cnt = Counter(a1 + a2)
        return any(cnt[v] != 2 for v in range(1, n+1))
    cols0 = [c-1 for c in cols]
    b1, b2 = _apply_swaps(a1, a2, cols0)
    return _is_perm(b1) and _is_perm(b2)

def main():
    # Exactly 3 asserts
    # 1) Zero swaps needed
    n = 3
    a1 = [1,2,3]
    a2 = [1,2,3]
    k, cols = solve_case(n, a1, a2)
    assert k == 0 and cols == []
    assert _check_solution(n, a1, a2, k, cols)

    # 2) Nontrivial
    n = 4
    a1 = [1,1,2,3]
    a2 = [2,3,4,4]
    k, cols = solve_case(n, a1, a2)
    assert k == 2 and _check_solution(n, a1, a2, k, cols)

    # 3) Impossible
    n = 3
    a1 = [1,1,1]
    a2 = [1,2,3]
    k, cols = solve_case(n, a1, a2)
    assert k == -1

    cases = read_input()
    if cases:
        print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly three asserts: trivial, nontrivial, and impossible cases; each checks feasibility and that the constructed answer yields permutations.}
\RESULT{A list of column indices to swap exactly once each, achieving permutations in both rows with a minimum count; any valid minimum set is acceptable.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: zero-swap identity, an impossible frequency case, and a mixed case with cycles. Property: applying returned swaps yields both rows as permutations.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A, B, and C on random small cases by verifying that all produce valid solutions with equal swap counts.}
\LINE{EDGE-CASE GENERATOR}{Generate small random $n \le 8$ arrays with values in $[1..n]$, then filter to keep only those where each value occurs exactly twice (or deliberately violate this to test impossibility).}
\begin{minted}{python}
import random
from collections import Counter

def gen_cases(seed=0, trials=200):
    random.seed(seed)
    cases = []
    for _ in range(trials):
        n = random.randint(1, 8)
        vals = list(range(1, n+1))
        # generate occurrences: either proper or broken
        if random.random() < 0.8:
            # proper: each value exactly twice
            bag = []
            for v in vals:
                bag.extend([v, v])
            random.shuffle(bag)
            a1 = bag[:n]
            a2 = bag[n:]
        else:
            # broken counts
            bag = []
            for _ in range(2*n):
                bag.append(random.randint(1, n))
            random.shuffle(bag)
            a1 = bag[:n]
            a2 = bag[n:]
        cases.append((n, a1, a2))
    return cases

def is_perm(arr):
    n = len(arr)
    seen = [0]*(n+1)
    for v in arr:
        if v < 1 or v > n or seen[v]:
            return False
        seen[v] = 1
    return True

def apply_swaps(a1, a2, cols0):
    a1 = a1[:]
    a2 = a2[:]
    for c in cols0:
        a1[c], a2[c] = a2[c], a1[c]
    return a1, a2

# Reference solver: Approach C
def solve_ref(n, a1, a2):
    # paste a minimal version of Approach C's solve_case
    from collections import defaultdict, deque
    class DSU:
        def __init__(self, n):
            self.p = list(range(n))
            self.sz = [1]*n
        def find(self, x):
            while self.p[x] != x:
                self.p[x] = self.p[self.p[x]]
                x = self.p[x]
            return x
        def union(self, a, b):
            ra, rb = self.find(a), self.find(b)
            if ra == rb: return False
            if self.sz[ra] < self.sz[rb]:
                ra, rb = rb, ra
            self.p[rb] = ra
            self.sz[ra] += self.sz[rb]
            return True

    pos = defaultdict(list)
    for j, v in enumerate(a1):
        pos[v].append((0, j))
    for j, v in enumerate(a2):
        pos[v].append((1, j))
    for v in range(1, n+1):
        if len(pos[v]) != 2:
            return -1, []
    dsu = DSU(n)
    for v in range(1, n+1):
        (r1, c1), (r2, c2) = pos[v]
        if r1 != r2:
            dsu.union(c1, c2)
    group_members = {}
    for i in range(n):
        r = dsu.find(i)
        group_members.setdefault(r, []).append(i)
    comp_adj = {}
    for v in range(1, n+1):
        (r1, c1), (r2, c2) = pos[v]
        if r1 == r2:
            u = dsu.find(c1)
            w = dsu.find(c2)
            if u == w:
                return -1, []
            comp_adj.setdefault(u, []).append(w)
            comp_adj.setdefault(w, []).append(u)
    color = {}
    ans = []
    all_nodes = set(group_members.keys()) | set(comp_adj.keys())
    for s in all_nodes:
        if s in color:
            continue
        q = deque([s])
        color[s] = 0
        part = [[], []]
        while q:
            u = q.popleft()
            part[color[u]].append(u)
            for v in comp_adj.get(u, []):
                if v not in color:
                    color[v] = color[u]^1
                    q.append(v)
                elif color[v] == color[u]:
                    return -1, []
        w0 = sum(len(group_members[g]) for g in part[0])
        w1 = sum(len(group_members[g]) for g in part[1])
        pick = 0 if w0 <= w1 else 1
        for g in part[pick]:
            ans.extend(group_members[g])
    return len(ans), [x+1 for x in ans]

def test_harness():
    cases = gen_cases(1, 200)
    for (n, a1, a2) in cases:
        k, cols = solve_ref(n, a1, a2)
        if k == -1:
            # if feasible counts hold, ensure solver rarely flags false -1
            # we'll quickly verify by trying to enforce via XOR-DFS (light check)
            from collections import defaultdict
            pos = defaultdict(list)
            for j, v in enumerate(a1):
                pos[v].append((0, j))
            for j, v in enumerate(a2):
                pos[v].append((1, j))
            if all(len(pos[v]) == 2 for v in range(1, n+1)):
                # Accept as possibly impossible; skip heavy brute-force
                pass
        else:
            b1, b2 = apply_swaps(a1, a2, [c-1 for c in cols])
            assert is_perm(b1) and is_perm(b2)

if __name__ == "__main__":
    test_harness()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import defaultdict, deque

class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.sz = [1]*n
    def find(self, x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb: return False
        if self.sz[ra] < self.sz[rb]:
            ra, rb = rb, ra
        self.p[rb] = ra
        self.sz[ra] += self.sz[rb]
        return True

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return []
    it = iter(map(int, data))
    t = next(it)
    cases = []
    for _ in range(t):
        n = next(it)
        a1 = [next(it) for _ in range(n)]
        a2 = [next(it) for _ in range(n)]
        cases.append((n, a1, a2))
    return cases

def solve_case(n, a1, a2):
    pos = defaultdict(list)
    for j, v in enumerate(a1):
        pos[v].append((0, j))
    for j, v in enumerate(a2):
        pos[v].append((1, j))
    for v in range(1, n+1):
        if len(pos[v]) != 2:
            return -1, []

    dsu = DSU(n)
    # Merge equal-parity edges (different rows => x equal)
    for v in range(1, n+1):
        (r1, c1), (r2, c2) = pos[v]
        if r1 != r2:
            dsu.union(c1, c2)

    group_members = defaultdict(list)
    for i in range(n):
        group_members[dsu.find(i)].append(i)

    comp_adj = defaultdict(list)
    for v in range(1, n+1):
        (r1, c1), (r2, c2) = pos[v]
        if r1 == r2:
            u = dsu.find(c1)
            w = dsu.find(c2)
            if u == w:
                return -1, []
            comp_adj[u].append(w)
            comp_adj[w].append(u)

    color = {}
    ans_cols = []
    all_nodes = set(group_members.keys()) | set(comp_adj.keys())

    for start in all_nodes:
        if start in color:
            continue
        q = deque([start])
        color[start] = 0
        parts = [[], []]
        while q:
            u = q.popleft()
            parts[color[u]].append(u)
            for v in comp_adj.get(u, []):
                if v not in color:
                    color[v] = color[u] ^ 1
                    q.append(v)
                elif color[v] == color[u]:
                    return -1, []
        w0 = sum(len(group_members[g]) for g in parts[0])
        w1 = sum(len(group_members[g]) for g in parts[1])
        pick = 0 if w0 <= w1 else 1
        for g in parts[pick]:
            ans_cols.extend(group_members[g])

    ans_cols = [c+1 for c in ans_cols]
    return len(ans_cols), ans_cols

def solve_all(cases):
    out_lines = []
    for (n, a1, a2) in cases:
        k, cols = solve_case(n, a1, a2)
        if k == -1:
            out_lines.append("-1")
        else:
            out_lines.append(str(k))
            out_lines.append(" ".join(map(str, cols)))
    return "\n".join(out_lines)

def _apply_swaps(a1, a2, cols):
    a1 = a1[:]
    a2 = a2[:]
    for c in cols:
        a1[c], a2[c] = a2[c], a1[c]
    return a1, a2

def _is_perm(arr):
    n = len(arr)
    seen = [0]*(n+1)
    for v in arr:
        if v < 1 or v > n or seen[v]:
            return False
        seen[v] = 1
    return True

def _check_solution(n, a1, a2, k, cols):
    if k == -1:
        from collections import Counter
        cnt = Counter(a1 + a2)
        return any(cnt[v] != 2 for v in range(1, n+1))
    cols0 = [c-1 for c in cols]
    b1, b2 = _apply_swaps(a1, a2, cols0)
    return _is_perm(b1) and _is_perm(b2)

def main():
    # Self-checks
    n = 3
    a1 = [1,2,3]
    a2 = [1,2,3]
    k, cols = solve_case(n, a1, a2)
    assert k == 0 and cols == []
    assert _check_solution(n, a1, a2, k, cols)

    n = 4
    a1 = [1,1,2,3]
    a2 = [2,3,4,4]
    k, cols = solve_case(n, a1, a2)
    assert k == 2 and _check_solution(n, a1, a2, k, cols)

    n = 3
    a1 = [1,1,1]
    a2 = [1,2,3]
    k, cols = solve_case(n, a1, a2)
    assert k == -1

    cases = read_input()
    if cases:
        print(solve_all(cases))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize column swaps so that each row becomes a permutation by solving XOR parity constraints on a 2-regular multigraph over columns.}
\WHY{This pattern appears in interview tasks involving parity constraints, bipartite coloring, and DSU compression for equalities.}
\CHECKLIST{
- Verify each value $1..n$ appears exactly twice globally.
- Build constraints: edge between the two columns of each value with $s=\mathbf{1}[\text{same row}]$.
- Either DFS with $x_v=x_u\oplus s$ or DSU-compress $s=0$ and color $s=1$ graph.
- Per component, choose the lighter color class and output its columns.}
\EDGECASES{
- Value count not equal to two $\Rightarrow$ impossible.
- Self-loop edges $(c,c)$ only occur with $s=0$; they impose no restriction.
- Components of size one (isolated DSU groups) should default to no swap.
- Multiple edges between the same pair of components are fine.
- Odd cycle in $s=1$ compressed graph $\Rightarrow$ contradiction $\Rightarrow$ impossible.
- $k=0$ must still print an empty second line.}
\PITFALLS{
- Forgetting to print a blank line when $k=0$.
- Mixing $0$-based and $1$-based indices when outputting positions.
- Not handling self-loops properly during DFS (ensure they do not force $1=0$).
- Missing contradiction checks when revisiting colored nodes.
- Using recursion that may overflow; prefer iterative DFS/BFS.
- Building adjacency with only one direction; remember edges are undirected.}
\FAILMODES{Brute-force over subsets or naive backtracking fails due to exponential complexity. Approaches without handling parity constraints can get stuck or produce invalid duplicates. DSU+coloring survives due to linear-time structure and explicit parity enforcement.}
\ELI{Every number appears twice and connects two columns with a rule: if it showed up in the same row both times, exactly one of those two columns must be swapped; otherwise either both or neither. These rules form loops; for each loop, pick the smaller side to flip.}
\NotePages{3}

\end{document}