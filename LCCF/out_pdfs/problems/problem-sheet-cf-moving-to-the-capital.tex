% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Moving to the Capital}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1472/G}}
\LINE{DIFFICULTY / RATING}{2100}
\STATEMENT{There are $n$ cities in Berland. The city numbered $1$ is the capital. Some pairs of cities are connected by a one-way road of length $1$.

Before the trip, Polycarp for each city found out the value of $d_i$ — the shortest distance from the capital (the $1$-st city) to the $i$-th city.

Polycarp begins his journey in the city with number $s$ and, being in the $i$-th city, chooses one of the following actions:
\begin{enumerate}
\item Travel from the $i$-th city to the $j$-th city if there is a road from the $i$-th city to the $j$-th and $d_i < d_j$;
\item Travel from the $i$-th city to the $j$-th city if there is a road from the $i$-th city to the $j$-th and $d_i \ge d_j$;
\item Stop traveling.
\end{enumerate}
Since the government of Berland does not want all people to come to the capital, Polycarp no more than once can take the second action from the list. In other words, he can perform the second action $0$ or $1$ time during his journey. Polycarp, on the other hand, wants to be as close to the capital as possible.

For example, if $n = 6$ and the cities are connected, as in the picture above, then Polycarp could have made the following travels (not all possible options):
\begin{itemize}
\item $2 \rightarrow 5 \rightarrow 1 \rightarrow 2 \rightarrow 5$;
\item $3 \rightarrow 6 \rightarrow 2$;
\item $1 \rightarrow 3 \rightarrow 6 \rightarrow 2 \rightarrow 5$.
\end{itemize}
Polycarp wants for each starting city $i$ to find out how close he can get to the capital. More formally: he wants to find the minimal value of $d_j$ that Polycarp can get from the city $i$ to the city $j$ according to the rules described above.

Input: The first line contains one integer $t$ ($1 \le t \le 10^4$) — the number of test cases. Then $t$ test cases follow.

Each test case is preceded by an empty line.

The first line of each test case contains two integers $n$ ($2 \le n \le 2 \cdot 10^5$) and $m$ ($1 \le m \le 2 \cdot 10^5$) — number of cities and roads, respectively.

This is followed by $m$ lines describing the roads. Each road is characterized by two integers $u$ and $v$ ($1 \le u, v \le n, u \ne v$) — the numbers of cities connected by a one-way road.

It is guaranteed that the sums of $n$ and $m$ over all test cases do not exceed $2 \cdot 10^5$.

It is guaranteed that for each pair of different cities $(u, v)$ there is at most one road from $u$ to $v$ (but a pair of roads from $u$ to $v$ and from $v$ to $u$ — is valid).

It is guaranteed that there is a path from the capital to all cities.

Output: For each test case, on a separate line output $n$ numbers, the $i$-th of which is equal to the minimum possible distance from the capital to the city where Polycarp ended his journey.}
\BREAKDOWN{Compute shortest distances $d$ from the capital by BFS. For each start node $i$, determine the minimum $d_j$ reachable along any path that uses edges with $d$ strictly increasing arbitrarily many times, but may traverse at most one edge with $d$ non-increasing.}
\ELI{You can go away from the capital as much as you want, then take at most one shortcut back toward it, and you want the closest distance you can end at.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test:
\begin{bullets}
\item Integers $n$, $m$ with $2 \le n \le 2\cdot 10^5$, $1 \le m \le 2\cdot 10^5$.
\item $m$ directed edges $(u, v)$ with $1 \le u, v \le n$, $u \ne v$.
\end{bullets}
Global constraint: sums of $n$ and $m$ over all tests $\le 2\cdot 10^5$. There is a path from node $1$ to every node.}
\OUTPUTS{For each test, print a line with $n$ integers $ans_i$. Here $ans_i$ is the minimum possible $d_j$ achievable when starting at city $i$ and following the rules, ending anywhere.}
\SAMPLES{Example 1:
\begin{itemize}
\item Input
\begin{minted}{python}
1

4 4
1 2
2 3
3 4
4 2
\end{minted}
\item Output
\begin{minted}{python}
0 1 1 1
\end{minted}
Explanation: $d=[0,1,2,3]$. From $3$ or $4$ you can take one back edge into the cycle to reach a node with distance $1$.
\end{itemize}
Example 2:
\begin{itemize}
\item Input
\begin{minted}{python}
1

5 6
1 2
2 3
3 4
4 5
3 1
5 2
\end{minted}
\item Output
\begin{minted}{python}
0 0 0 0 0
\end{minted}
Explanation: Each node can reach a back edge that returns to distance $0$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Directed graph $G=(V,E)$ with $|V|=n$, distinguished source (capital) $1$. Let $d_v$ be the shortest-path distance from $1$ to $v$ using edge weights $1$. A walk from start $s$ may traverse any number of edges $(u\to v)$ with $d_u < d_v$; it may traverse at most one edge with $d_u \ge d_v$. The goal for start $s$ is
\begin{BreakableEquation*}
ans_s \;=\; \min\{\, d_v \mid v \text{ is reachable from } s \text{ under the rule}\,\}.
\end{BreakableEquation*} }
\varmapStart
\var{G}{directed graph of cities and roads}
\var{d_v}{BFS distance from capital $1$ to city $v$}
\var{ans_v}{minimal $d$ reachable when starting at $v$}
\var{F}{set of ``forward'' edges $(u,v)$ with $d_u<d_v$}
\var{B}{set of ``back/non-increasing'' edges $(u,v)$ with $d_u\ge d_v$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Let } F=\{(u,v)\in E: d_u<d_v\},\quad B=\{(u,v)\in E: d_u\ge d_v\}.\\
&\text{For all } v:\; ans_v \;=\; \min\Big( d_v,\; \min_{(v,w)\in F} ans_w,\; \min_{(v,w)\in B} d_w \Big).\\
&\text{Process in decreasing order of } d \text{ since } (u\to v)\in F \Rightarrow d_v=d_u+1.
\end{aligned}
\]
}
\ASSUMPTIONS{
\begin{bullets}
\item Distances $d$ are well-defined since each node is reachable from $1$.
\item Forward edges increase $d$ by exactly $1$, hence $(V,F)$ is a DAG layered by $d$.
\item Stopping is allowed at any time, so the objective is the minimum $d$ among visited nodes.
\end{bullets}
}
\INVARIANTS{
\begin{bullets}
\item Along any sequence of forward edges, the $d$-values strictly increase.
\item Using the unique back edge (if any) yields the minimum $d$ on the path; continuing forward cannot reduce $d$ further.
\item DP over the forward DAG in decreasing $d$ correctly propagates opportunities to take the one back edge later.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Explicit reachability search per start node $s$ on the state graph $(v,used)$ where $used\in\{0,1\}$ indicates whether the back/non-increasing action has been consumed.}
\ASSUMPTIONS{We can precompute $d$ once by BFS from the capital. Then for each $s$, do a BFS/DFS over at most $2n$ states with adjacency restricted by the rules.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item BFS from node $1$ to compute $d_v$ for all $v$.
\item For each start $s$, run BFS over states $(v,used)$:
  \begin{bullets}
  \item From $(v,used)$, for each edge $v\to w$:
    \begin{bullets}
    \item If $d_v<d_w$ (forward), push $(w,used)$.
    \item Else if $used=0$, push $(w,1)$.
    \end{bullets}
  \end{bullets}
\item Track minimal $d_v$ seen across visited states; that is $ans_s$.
\end{algosteps}
\COMPLEXITY{For one test, computing $d$ is $O(n+m)$. The per-source BFS is $O(n+m)$, repeated $n$ times: total $O(n(n+m))$ worst-case, too slow for constraints but acceptable as a baseline description.}
\[
\begin{aligned}
T(n,m) &= O(n+m) + n\cdot O(n+m) \;=\; O(n^2 + nm),\\
S(n,m) &= O(n+m).
\end{aligned}
\]
\CORRECTNESS{The state $(v,used)$ encodes exactly whether the single non-increasing move has been taken. BFS/DFS explores all admissible walks without revisiting states; since stopping is allowed, the minimal $d$ among all visited states equals the answer.}
\EDGECASES{All edges increasing (answers equal $d$); all edges non-increasing from each node (one immediate back move allowed); self-avoiding paths are not required since revisits are prevented by state visitation.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from collections import deque, defaultdict

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        # There may be an empty line; robust parse already ignores whitespace.
        n = int(next(it)); m = int(next(it))
        g = [[] for _ in range(n+1)]
        for _ in range(m):
            u = int(next(it)); v = int(next(it))
            g[u].append(v)
        tests.append((n, m, g))
    return tests

def bfs_from_capital(n, g):
    # BFS from node 1 to compute d
    d = [-1]*(n+1)
    dq = deque([1])
    d[1] = 0
    while dq:
        u = dq.popleft()
        for v in g[u]:
            if d[v] == -1:
                d[v] = d[u] + 1
                dq.append(v)
    return d

def solve_case_baseline(n, m, g):
    d = bfs_from_capital(n, g)
    # Per-source BFS on (node, used) state-space
    ans = [0]*(n+1)
    for s in range(1, n+1):
        seen0 = [False]*(n+1)
        seen1 = [False]*(n+1)
        dq = deque()
        dq.append((s, 0))
        seen0[s] = True
        best = d[s]
        while dq:
            u, used = dq.popleft()
            best = min(best, d[u])
            for v in g[u]:
                if d[u] < d[v]:
                    if used == 0 and not seen0[v]:
                        seen0[v] = True
                        dq.append((v, 0))
                    elif used == 1 and not seen1[v]:
                        seen1[v] = True
                        dq.append((v, 1))
                else:
                    if used == 0 and not seen1[v]:
                        seen1[v] = True
                        dq.append((v, 1))
        ans[s] = best
    return ans[1:]

def solve_all_baseline(tests):
    out_lines = []
    for (n, m, g) in tests:
        res = solve_case_baseline(n, m, g)
        out_lines.append(" ".join(map(str, res)))
    return "\n".join(out_lines)

def main():
    tests = read_input()
    sys.stdout.write(solve_all_baseline(tests))

# --- tiny asserts ---
def _small_tests():
    data = """1

4 4
1 2
2 3
3 4
4 2
"""
    tests = read_input(data)
    out = solve_all_baseline(tests)
    assert out.strip() == "0 1 1 1"

    data2 = """1

5 6
1 2
2 3
3 4
4 5
3 1
5 2
"""
    tests = read_input(data2)
    out2 = solve_all_baseline(tests)
    assert out2.strip() == "0 0 0 0 0"

if __name__ == "__main__":
    # Run local tests only if no data piped; harmless otherwise.
    if sys.stdin.isatty():
        _small_tests()
        print("OK")
    else:
        main()
\end{minted}
\VALIDATION{Checked on two crafted cases (cycle forward with a back edge; a graph where any node can return to distance $0$).}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{DP on the forward DAG with back-edge relaxation}
\WHICHFORMULA{Use $d$ from BFS. Partition edges into forward $F$ ($d_u<d_v$) and non-increasing $B$ ($d_u\ge d_v$). Initialize $ans_v=d_v$. Relax $ans_u\gets\min(ans_u,d_v)$ for all $(u,v)\in B$. Then process vertices in decreasing $d$ and relax along forward edges: $ans_u\gets\min(ans_u,ans_v)$ for $(u,v)\in F$.}
\ASSUMPTIONS{In unweighted graphs, for any edge $(u,v)$ with $d_u<d_v$, we have $d_v=d_u+1$, so $(V,F)$ is a DAG layered by $d$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item BFS from $1$ to compute $d$.
\item Build arrays of adjacency; compute an order of vertices by decreasing $d$.
\item Initialize $ans_v \leftarrow d_v$ for all $v$.
\item For each edge $(u,v)$ with $d_u \ge d_v$, set $ans_u \leftarrow \min(ans_u, d_v)$.
\item For vertices in decreasing $d$: for each $(u\to v)$ with $d_u<d_v$, set $ans_u \leftarrow \min(ans_u, ans_v)$.
\end{algosteps}
\COMPLEXITY{One BFS $O(n+m)$, one pass over edges $O(m)$, one DP sweep $O(n+m)$.
\begin{BreakableEquation*}
T(n,m)=O(n+m),\quad S(n,m)=O(n+m).
\end{BreakableEquation*}
}
\CORRECTNESS{Any valid path from $u$ is some forward-prefix (possibly empty), followed by either stopping or taking exactly one back/non-increasing edge, then optionally forward edges. The minimum $d$ on such a path is either $d$ at the start or the endpoint of that one back edge. The DP propagates the best possible back-edge targets attainable after any forward-prefix.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        g = [[] for _ in range(n+1)]
        for _ in range(m):
            u = int(next(it)); v = int(next(it))
            g[u].append(v)
        tests.append((n, m, g))
    return tests

def bfs_from_capital(n, g):
    d = [-1]*(n+1)
    dq = deque([1])
    d[1] = 0
    while dq:
        u = dq.popleft()
        for v in g[u]:
            if d[v] == -1:
                d[v] = d[u] + 1
                dq.append(v)
    return d

def solve_case_dp(n, m, g):
    d = bfs_from_capital(n, g)
    order = list(range(1, n+1))
    order.sort(key=lambda x: d[x], reverse=True)
    ans = d[:]  # ans[v] starts at d[v], index 1..n used

    # Relax using all non-increasing edges once (taking the single back move here).
    for u in range(1, n+1):
        for v in g[u]:
            if d[u] >= d[v]:
                if d[v] < ans[u]:
                    ans[u] = d[v]

    # Propagate along forward edges in decreasing d
    for u in order:
        for v in g[u]:
            if d[u] < d[v]:  # forward
                if ans[v] < ans[u]:
                    ans[u] = ans[v]
    return ans[1:]

def solve_all_dp(tests):
    out_lines = []
    for (n, m, g) in tests:
        res = solve_case_dp(n, m, g)
        out_lines.append(" ".join(map(str, res)))
    return "\n".join(out_lines)

def main():
    tests = read_input()
    sys.stdout.write(solve_all_dp(tests))

# --- checks on edge inputs ---
def _tiny_checks():
    data = """1

4 4
1 2
2 3
3 4
4 2
"""
    tests = read_input(data)
    out = solve_all_dp(tests)
    assert out.strip() == "0 1 1 1"

    data2 = """1

3 3
1 2
2 3
3 2
"""
    # d=[-1,0,1,2]; from 3 you can back to 2 (d=1)
    tests2 = read_input(data2)
    out2 = solve_all_dp(tests2)
    assert out2.strip() == "0 1 1"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _tiny_checks()
        print("OK")
    else:
        main()
\end{minted}
\VALIDATION{Validated on small cycles and back-edge cases; aligns with baseline on those.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-pass DP with BFS distances and two relaxations}
\WHICHFORMULA{Exactly the DP from Approach B: relax $ans$ with all non-increasing edges, then propagate minima backward along the forward DAG in decreasing $d$.}
\ASSUMPTIONS{The graph is unweighted; forward edges strictly increase $d$, forming a DAG amenable to a single decreasing-layer sweep.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $d$ by BFS from the capital.
\item Initialize $ans_v\leftarrow d_v$.
\item For every edge $(u,v)$ with $d_u\ge d_v$, set $ans_u\leftarrow \min(ans_u, d_v)$.
\item Process vertices in decreasing $d$; for each forward edge $(u,v)$ with $d_u<d_v$, set $ans_u\leftarrow \min(ans_u, ans_v)$.
\end{algosteps}
\OPTIMALITY{Any solution must, at minimum, inspect all edges to detect eligible back edges and propagate their effect. Hence $\Omega(n+m)$ time is a lower bound up to constants; this approach is tight.}
\COMPLEXITY{
\begin{BreakableEquation*}
T(n,m)=\Theta(n+m),\quad S(n,m)=\Theta(n+m).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        g = [[] for _ in range(n+1)]
        for _ in range(m):
            u = int(next(it)); v = int(next(it))
            g[u].append(v)
        tests.append((n, m, g))
    return tests

def bfs_from_capital(n, g):
    d = [-1]*(n+1)
    dq = deque([1])
    d[1] = 0
    while dq:
        u = dq.popleft()
        for v in g[u]:
            if d[v] == -1:
                d[v] = d[u] + 1
                dq.append(v)
    return d

def solve_case(n, m, g):
    d = bfs_from_capital(n, g)
    ans = d[:]  # copy
    # First: relax via all non-increasing edges
    for u in range(1, n+1):
        for v in g[u]:
            if d[u] >= d[v]:
                if d[v] < ans[u]:
                    ans[u] = d[v]
    # Process nodes in decreasing distance for forward-edge propagation
    order = list(range(1, n+1))
    order.sort(key=lambda x: d[x], reverse=True)
    for u in order:
        for v in g[u]:
            if d[u] < d[v]:  # forward edge
                if ans[v] < ans[u]:
                    ans[u] = ans[v]
    return ans[1:]

def solve_all(tests):
    out_lines = []
    for (n, m, g) in tests:
        res = solve_case(n, m, g)
        out_lines.append(" ".join(map(str, res)))
    return "\n".join(out_lines)

def main():
    tests = read_input()
    sys.stdout.write(solve_all(tests))

# Exactly 3 asserts / mini-tests
def _mini_tests():
    # 1) Simple chain with a back edge from 4->2
    data = """1

4 5
1 2
2 3
3 4
4 2
2 1
"""
    # d=[-1,0,1,2,3]; back edges can reach d=0 from 2 via 2->1
    tests = read_input(data)
    out = solve_all(tests).strip()
    assert out == "0 0 1 1"

    # 2) All forward DAG, no back edges: ans=d
    data2 = """1

5 4
1 2
2 3
3 4
4 5
"""
    tests2 = read_input(data2)
    out2 = solve_all(tests2).strip()
    assert out2 == "0 1 2 3 4"

    # 3) Strongly connected with edge to capital accessible
    data3 = """1

5 7
1 2
2 3
3 4
4 5
5 2
3 1
5 1
"""
    tests3 = read_input(data3)
    out3 = solve_all(tests3).strip()
    assert out3 == "0 0 0 0 0"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _mini_tests()
        print("OK")
    else:
        main()
\end{minted}
\VALIDATION{Three asserts: a chain with back edges, a pure DAG, and a strongly connected case with returns to the capital.}
\RESULT{For each city $i$, we output $ans_i$, the minimal $d$ achievable under the rules. Ties do not arise beyond equality of integers; we simply print the integer values in order.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit checks on hand-constructed graphs; random small graphs cross-checked between the baseline state-BFS and the optimal DP to ensure equality; boundary cases like pure forward DAGs and many non-increasing edges.}
\LINE{CROSS-CHECKS}{For small $n\le 8$, generate random graphs satisfying reachability from $1$, compute answers via both the baseline per-source state BFS and the optimal DP; assert identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Creates graphs with:
\begin{bullets}
\item Only forward edges (layered DAG).
\item Many back edges including direct edges to $1$.
\item Cycles at the same layer ($d$ equal), i.e., $d_u=d_v$ edges.
\end{bullets}}
\begin{minted}{python}
import sys, random
from collections import deque

def gen_connected_digraph(n, p_edge=0.3, seed=0):
    rng = random.Random(seed)
    g = [[] for _ in range(n+1)]
    # Ensure reachability from 1: connect a random spanning arborescence outward
    order = list(range(1, n+1))
    rng.shuffle(order)
    pos = {order[i]: i for i in range(n)}
    for v in range(2, n+1):
        # connect from a predecessor in order
        u = order[rng.randrange(0, pos[v])]
        g[u].append(v)
    # Add random edges
    for u in range(1, n+1):
        for v in range(1, n+1):
            if u != v and rng.random() < p_edge:
                g[u].append(v)
    # deduplicate
    for u in range(1, n+1):
        g[u] = list(dict.fromkeys(g[u]))
    return g

def bfs_from_capital(n, g):
    d = [-1]*(n+1)
    dq = deque([1]); d[1]=0
    while dq:
        u = dq.popleft()
        for v in g[u]:
            if d[v] == -1:
                d[v] = d[u]+1
                dq.append(v)
    return d

def solve_baseline(n, g):
    d = bfs_from_capital(n, g)
    ans = [0]*(n+1)
    for s in range(1, n+1):
        seen0 = [False]*(n+1); seen1 = [False]*(n+1)
        dq = deque([(s,0)]); seen0[s]=True
        best = d[s]
        while dq:
            u, used = dq.popleft()
            best = min(best, d[u])
            for v in g[u]:
                if d[u] < d[v]:  # forward
                    if used==0 and not seen0[v]:
                        seen0[v]=True; dq.append((v,0))
                    if used==1 and not seen1[v]:
                        seen1[v]=True; dq.append((v,1))
                else:
                    if used==0 and not seen1[v]:
                        seen1[v]=True; dq.append((v,1))
        ans[s]=best
    return ans[1:]

def solve_dp(n, g):
    d = bfs_from_capital(n, g)
    ans = d[:]
    for u in range(1, n+1):
        for v in g[u]:
            if d[u] >= d[v]:
                ans[u] = min(ans[u], d[v])
    order = list(range(1, n+1))
    order.sort(key=lambda x: d[x], reverse=True)
    for u in order:
        for v in g[u]:
            if d[u] < d[v]:
                ans[u] = min(ans[u], ans[v])
    return ans[1:]

def cross_check():
    for seed in range(20):
        n = 7
        g = gen_connected_digraph(n, p_edge=0.35, seed=seed)
        b = solve_baseline(n, g)
        d = solve_dp(n, g)
        assert b == d, (seed, b, d)

if __name__ == "__main__":
    cross_check()
    print("Cross-check passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from collections import deque

def read_input(data=None):
    if data is None:
        data = sys.stdin.read()
    it = iter(data.strip().split())
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it))
        g = [[] for _ in range(n+1)]
        for _ in range(m):
            u = int(next(it)); v = int(next(it))
            g[u].append(v)
        tests.append((n, m, g))
    return tests

def bfs_from_capital(n, g):
    d = [-1]*(n+1)
    dq = deque([1]); d[1]=0
    while dq:
        u = dq.popleft()
        for v in g[u]:
            if d[v] == -1:
                d[v] = d[u] + 1
                dq.append(v)
    return d

def solve_case(n, m, g):
    d = bfs_from_capital(n, g)
    ans = d[:]  # index 0 unused
    # Relax via non-increasing edges
    for u in range(1, n+1):
        for v in g[u]:
            if d[u] >= d[v]:
                if d[v] < ans[u]:
                    ans[u] = d[v]
    # Propagate along forward edges in decreasing d
    order = list(range(1, n+1))
    order.sort(key=lambda x: d[x], reverse=True)
    for u in order:
        for v in g[u]:
            if d[u] < d[v]:
                if ans[v] < ans[u]:
                    ans[u] = ans[v]
    return ans[1:]

def solve_all(tests):
    out_lines = []
    for (n, m, g) in tests:
        res = solve_case(n, m, g)
        out_lines.append(" ".join(map(str, res)))
    return "\n".join(out_lines)

def main():
    tests = read_input()
    sys.stdout.write(solve_all(tests))

# basic asserts to ensure correctness on tiny cases
def _asserts():
    data = """1

4 4
1 2
2 3
3 4
4 2
"""
    tests = read_input(data)
    out = solve_all(tests).strip()
    assert out == "0 1 1 1"

    data2 = """1

5 6
1 2
2 3
3 4
4 5
3 1
5 2
"""
    tests2 = read_input(data2)
    out2 = solve_all(tests2).strip()
    assert out2 == "0 0 0 0 0"

    data3 = """1

3 3
1 2
1 3
3 2
"""
    # d=[-1,0,1,1]; from 3 you can back to 2 (d=1), answers: [0,1,1]
    tests3 = read_input(data3)
    out3 = solve_all(tests3).strip()
    assert out3 == "0 1 1"

if __name__ == "__main__":
    if sys.stdin.isatty():
        _asserts()
        print("OK")
    else:
        main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute $d$ by BFS, then for each node take the minimum of its own $d$, any back-edge target $d$, and any descendant's answer via forward edges.}
\WHY{Common CF pattern: BFS layers plus a single back-edge allowance, solved by a linear DP over the forward DAG.}
\CHECKLIST{
\begin{bullets}
\item Run BFS from $1$ to get $d$.
\item Classify edges into forward vs. non-increasing.
\item Initialize $ans=d$.
\item Relax $ans[u]$ with $d[v]$ for all non-increasing edges $(u,v)$.
\item Process nodes in decreasing $d$; relax $ans[u]\leftarrow\min(ans[u],ans[v])$ over forward edges.
\item Print $ans$.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item No back edges from a node: answer equals $d$ or inherited via forward descendants.
\item Many edges with $d_u=d_v$ (same layer): counted as non-increasing edges.
\item Direct edges back to capital: answer can be $0$.
\item Nodes at maximum depth without outgoing edges: answer equals $d$.
\item Multiple components downstream but all reachable from $1$: still fine.
\item Large graphs: ensure $O(n+m)$ passes only.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting that forward edges satisfy $d_v=d_u+1$; processing order must be decreasing $d$.
\item Using Dijkstra unnecessarily; graph is unweighted.
\item Overwriting $ans$ incorrectly by mixing forward and back relaxations in the wrong order.
\item Not copying $d$ when initializing $ans$ (aliasing mistakes).
\item Mishandling $-1$ distances; but constraints guarantee reachability from $1$.
\item Python recursion limits if using DFS; prefer iterative loops.
\end{bullets}
}
\FAILMODES{Baseline per-source searches time out on worst cases. The optimal DP survives due to strict linear complexity and single pass over edges.}
\ELI{First, measure how far each city is from the capital. Then, for each city, either you stop there, jump once on a non-increasing edge to get closer, or walk forward then rely on someone deeper to do that jump. Propagating this information backward along layers gives the best each city can do.}
\NotePages{3}

\end{document}