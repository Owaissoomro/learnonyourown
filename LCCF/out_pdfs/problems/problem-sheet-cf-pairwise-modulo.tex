% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Pairwise Modulo}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1553/F}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{You are given an array $a$ consisting of $n$ distinct positive integers, numbered from $1$ to $n$. Define
\begin{BreakableEquation*}
p_k \;=\; \sum_{1 \le i, j \le k} \left(a_i \bmod a_j\right),
\end{BreakableEquation*}
where $x \bmod y$ denotes the remainder when $x$ is divided by $y$. You must compute and print $p_1, p_2, \ldots, p_n$.

Input: The first line contains $n$ — the length of the array ($2 \le n \le 2 \cdot 10^5$). The second line contains $n$ space-separated distinct integers $a_1, \ldots, a_n$ ($1 \le a_i \le 3 \cdot 10^5$, $a_i \ne a_j$ if $i \ne j$).

Output: Print $n$ integers $p_1, p_2, \ldots, p_n$.}
\BREAKDOWN{Compute prefix answers incrementally. When appending a new value $x=a_k$, update $p_k = p_{k-1} + \sum_{j \le k} (x \bmod a_j) + \sum_{i < k} (a_i \bmod x)$. Evaluate both sums fast using number-theoretic grouping and data structures.}
\ELI{At each step, add the interactions between the new number and all previous ones by using floor-division grouping and Fenwick trees to avoid quadratic work.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- Integer $n$.
- Array $a$ of length $n$ with distinct integers, $1 \le a_i \le 300{,}000$.}
\OUTPUTS{Print $n$ space-separated integers: $p_1, p_2, \ldots, p_n$.}
\SAMPLES{Example:
- Input: $n=3$, $a=[3,1,4]$.
  - $p_1 = 3 \bmod 3 = 0$.
  - $p_2 = \sum_{1 \le i,j \le 2} a_i \bmod a_j = 3\bmod 3 + 3\bmod 1 + 1\bmod 3 + 1\bmod 1 = 0+0+1+0=1$.
  - $p_3$ adds interactions with $4$ accordingly.
- Input: $n=2$, $a=[2,5]$.
  - $p_1=0$, $p_2 = 2\bmod 2 + 2\bmod 5 + 5\bmod 2 + 5\bmod 5 = 0+2+1+0=3$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{For each prefix $k$, let $x=a_k$. Then
\begin{BreakableEquation*}
p_k \;=\; p_{k-1} \;+\; \underbrace{\sum_{j=1}^{k} \left(x \bmod a_j\right)}_{\text{new as left argument}} \;+\; \underbrace{\sum_{i=1}^{k-1} \left(a_i \bmod x\right)}_{\text{new as right argument}}.
\end{BreakableEquation*}
Use identities $u \bmod v = u - v\left\lfloor \tfrac{u}{v} \right\rfloor$ and grouping by constant $\left\lfloor \tfrac{\cdot}{\cdot} \right\rfloor$.}
\varmapStart
\var{k}{prefix length}
\var{x}{current value $a_k$}
\var{S}{sum of previous values $\sum_{i<k} a_i$}
\var{c[v]}{count of previous values equal to $v$}
\var{BIT}{Fenwick trees for counts/sums; range-add point-query tree for quotient aggregation}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\sum_{i<k} (a_i \bmod x) &= \sum_{i<k} a_i - x \sum_{i<k} \left\lfloor \tfrac{a_i}{x} \right\rfloor,\\
\sum_{j<k} (x \bmod a_j) &= x\,(k-1) - \sum_{j<k} a_j \left\lfloor \tfrac{x}{a_j} \right\rfloor.
\end{aligned}
\]
}
\ASSUMPTIONS{All $a_i$ are distinct; $1 \le a_i \le 300{,}000$. Indices are $1$-based for math and internal data structures.}
\INVARIANTS{Distinctness implies $c[v]\in\{0,1\}$. Prefix processing ensures structures store exactly previous elements. Fenwick trees maintain correct prefix/range sums.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly evaluate $p_k$ by double loops over all pairs $(i,j)$ with $i,j \le k$.}
\ASSUMPTIONS{No preprocessing; use $O(k^2)$ per prefix, $O(n^3)$ worst-case if recomputed naively, or $O(n^2)$ if incrementally maintaining $p_k$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $p_0=0$.
\item For $k$ from $1$ to $n$:
\begin{bullets}
\item Set $x=a_k$.
\item Compute $\sum_{j=1}^{k} (x \bmod a_j)$ and $\sum_{i=1}^{k-1} (a_i \bmod x)$ by looping.
\item Set $p_k = p_{k-1} +$ both sums.
\end{bullets}
\end{algosteps}
\COMPLEXITY{$T(n) = \Theta(n^2)$, $S(n) = \Theta(1)$ beyond input.}
\[
\begin{aligned}
T(n) &= \sum_{k=1}^{n} O(k) + O(k) \;=\; \sum_{k=1}^{n} O(k) \;=\; O(n^2).
\end{aligned}
\]
\CORRECTNESS{Follows from the definition of $p_k$ and additivity when appending one element.}
\EDGECASES{Handles $k=1$ by noting $x \bmod x = 0$. Distinctness makes no special cases.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_case_naive(n, a):
    ans = []
    p = 0
    for k in range(1, n+1):
        x = a[k-1]
        s1 = 0
        for j in range(k):
            s1 += x % a[j]
        s2 = 0
        for i in range(k-1):
            s2 += a[i] % x
        p += s1 + s2
        ans.append(p)
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    n, a = read_input(data)
    res = solve_case_naive(n, a)
    print(" ".join(map(str, res)))

if __name__ == "__main__":
    # tiny tests
    n, a = 2, [2, 5]
    assert solve_case_naive(n, a) == [0, 3]
    n, a = 3, [3, 1, 4]
    out = solve_case_naive(n, a)
    # manual compute: [0, 1, ?] just sanity on monotonicity non-negative
    assert out[0] == 0 and out[1] == 1 and out[2] >= out[1]
    # run main if input is provided
    if sys.stdin.isatty():
        pass
\end{minted}
\VALIDATION{Compared against hand-calculated small cases; asserts included.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Quotient Grouping + Fenwick Trees}
\WHICHFORMULA{Use $u \bmod v = u - v\lfloor u/v \rfloor$. Maintain Fenwick trees on value domain $\{1,\ldots,300{,}000\}$ for counts and sums. For $\sum_{j<k} a_j \lfloor x/a_j \rfloor$, group $a_j$ by constant quotient via blocks $[l,r]$ such that $\lfloor x/v \rfloor$ is constant for $v \in [l,r]$. For $\sum_{i<k} \lfloor a_i/x \rfloor$, use multiples ranges $[mx,(m+1)x-1]$.}
\ASSUMPTIONS{Values are in a small universe ($\le 3\cdot 10^5$), enabling indexed BITs; distinctness implies counts are $0/1$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain:
\begin{bullets}
\item BIT\_cnt: counts per value.
\item BIT\_sum: sum of values per value.
\item $S$: sum of previous values.
\end{bullets}
\item When inserting $x=a_k$:
\begin{bullets}
\item Compute $L = \sum_{j<k} (x \bmod a_j) = x(k-1) - \sum_{j<k} a_j \lfloor x/a_j \rfloor$ by iterating $l=1$ while $l \le x$:
\[
q = \left\lfloor \tfrac{x}{l} \right\rfloor,\quad r = \left\lfloor \tfrac{x}{q} \right\rfloor,\quad
\text{add } q \cdot \text{BIT\_sum.range}(l,r).
\]
\item Compute $R = \sum_{i<k} (a_i \bmod x) = S - x \sum_{m\ge 1} m \cdot \text{BIT\_cnt.range}(mx, (m+1)x-1)$.
\item Set $p_k = p_{k-1} + L + R$.
\item Update structures with $x$.
\end{bullets}
\end{algosteps}
\COMPLEXITY{Per insertion: $O(\sqrt{x}\log M + \tfrac{M}{x}\log M)$ where $M=300{,}000$. Amortized near $O(\sqrt{M}\log M)$.}
\[
\begin{aligned}
T(n) &\approx \sum_{k=1}^n \left(O\big(\sqrt{a_k}\log M\big) + O\big((M/a_k)\log M\big)\right),\\
S(n) &= O(M).
\end{aligned}
\]
\CORRECTNESS{Both sums follow from the identity and exact partitioning into ranges where the floor term is constant. Fenwick trees provide exact range sums.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys

class Fenwick:
    __slots__ = ("n", "bit")
    def __init__(self, n):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, i, delta):
        n = self.n
        while i <= n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s
    def range_sum(self, l, r):
        if r < l: return 0
        return self.sum(r) - self.sum(l-1)

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_case_improved(n, a):
    MAXV = 300000
    bit_cnt = Fenwick(MAXV)
    bit_sum = Fenwick(MAXV)
    ans = []
    p = 0
    S = 0  # sum of previous a_i
    for k in range(1, n+1):
        x = a[k-1]
        # L = sum_{j<k} (x % a_j) = x*(k-1) - sum a_j * floor(x/a_j)
        # compute sum a_j * floor(x/a_j) via quotient blocks
        s_floor_weighted = 0
        l = 1
        while l <= x:
            q = x // l
            if q == 0:
                break
            r = x // q
            if r > MAXV:
                r = MAXV
            block_sum_vals = bit_sum.range_sum(l, r)
            s_floor_weighted += q * block_sum_vals
            l = r + 1
        L = x*(k-1) - s_floor_weighted
        # R = sum_{i<k} (a_i % x) = S - x * sum floor(a_i / x)
        sum_floor = 0
        m = 1
        while m * x <= MAXV:
            Lm = m * x
            Rm = min(MAXV, (m+1)*x - 1)
            cnt = bit_cnt.range_sum(Lm, Rm)
            sum_floor += m * cnt
            m += 1
        R = S - x * sum_floor
        p += L + R
        ans.append(p)
        # update structures with x
        bit_cnt.add(x, 1)
        bit_sum.add(x, x)
        S += x
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    n, a = read_input(data)
    res = solve_case_improved(n, a)
    print(" ".join(map(str, res)))

if __name__ == "__main__":
    # Cross-check with naive for small randoms
    import random
    def brute(n, a):
        out = []
        p = 0
        for k in range(1, n+1):
            x = a[k-1]
            s1 = sum(x % a[j] for j in range(k))
            s2 = sum(a[i] % x for i in range(k-1))
            p += s1 + s2
            out.append(p)
        return out
    for _ in range(20):
        n = 8
        vals = list(range(1, 60))
        random.shuffle(vals)
        a = vals[:n]
        assert solve_case_improved(n, a) == brute(n, a)
\end{minted}
\VALIDATION{Randomized cross-checks vs. brute force on small inputs; exact equality asserted.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Range-Add Fenwick for Quotients + Multiples Scan}
\WHICHFORMULA{Maintain a range-add, point-query Fenwick over $X$ to accumulate $\sum_{j<k} a_j \lfloor X/a_j \rfloor$ for arbitrary query $X=x$ online. For each inserted $y$, for all $m \ge 1$, add $m y$ to interval $[m y, (m+1)y-1]$. Then
\begin{BreakableEquation*}
\sum_{j<k} (x \bmod a_j) = x\,(k-1) - \mathrm{RA.query}(x).
\end{BreakableEquation*}
For $\sum_{i<k} (a_i \bmod x) = S - x \sum_{m\ge 1} m \cdot \text{count}([mx,(m+1)x-1])$, use a counts Fenwick.}
\ASSUMPTIONS{Value domain bounded by $M=300{,}000$. Arrays are distinct. Range-add BIT supports $O(\log M)$ point queries with $O(\log M)$ range updates.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain:
\begin{bullets}
\item BIT\_cnt (counts per value), to get counts in $[L,R]$.
\item RA (range-add, point-query Fenwick) over $[1..M]$.
\item $S=\sum_{i<k} a_i$ and current $k-1$.
\end{bullets}
\item For $x=a_k$:
\begin{bullets}
\item $L = x\,(k-1) - \mathrm{RA.query}(x)$.
\item $R = S - x \sum_{m\ge 1} m \cdot \text{BIT\_cnt.range}(mx,(m+1)x-1)$.
\item $p_k = p_{k-1} + L + R$.
\end{bullets}
\item Insert $x$:
\begin{bullets}
\item BIT\_cnt.add$(x,1)$, $S{+}=x$.
\item For $m=1,2,\ldots$ while $m x \le M$: RA.add\_range$([m x, \min((m+1)x-1,M)], m x)$.
\end{bullets}
\end{algosteps}
\OPTIMALITY{Each insertion performs $O(M/x)$ range updates and $O(M/x)$ count-range queries overall: $\sum_x O(M/x) = O(M \log M)$ across all insertions. Point query is $O(\log M)$. This matches the standard near-optimal solution for this problem family in practice.}
\COMPLEXITY{Total time $O\big((M \log M + n \log M)\big)$ with small constants; memory $O(M)$.}
\[
\begin{aligned}
T(n) &\approx \sum_{k=1}^n \left(O\Big(\frac{M}{a_k}\log M\Big) + O\Big(\frac{M}{a_k}\log M\Big) + O(\log M)\right) \;\in\; O(M \log M + n \log M).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

class Fenwick:
    __slots__ = ("n", "bit")
    def __init__(self, n):
        self.n = n
        self.bit = [0]*(n+2)
    def add(self, i, delta):
        n = self.n
        while i <= n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s
    def range_sum(self, l, r):
        if r < l:
            return 0
        return self.sum(r) - self.sum(l-1)

class RangeAddPointQueryFenwick:
    __slots__ = ("bit", "n")
    def __init__(self, n):
        self.n = n
        self.bit = Fenwick(n+2)
    def add_range(self, l, r, delta):
        if l > r: return
        self.bit.add(l, delta)
        self.bit.add(r+1, -delta)
    def point(self, idx):
        return self.bit.sum(idx)

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_case_final(n, a):
    MAXV = 300000
    bit_cnt = Fenwick(MAXV+2)  # counts per value
    RA = RangeAddPointQueryFenwick(MAXV+2)  # range-add over X-space
    ans = []
    p = 0
    S = 0  # sum of previous values
    for k in range(1, n+1):
        x = a[k-1]
        # Left-contribution: sum_{j<k} (x % a_j) = x*(k-1) - sum a_j*floor(x/a_j)
        left = x*(k-1) - RA.point(x)
        # Right-contribution: sum_{i<k} (a_i % x) = S - x * sum floor(a_i/x)
        sum_floor = 0
        m = 1
        while m * x <= MAXV:
            L = m * x
            R = min(MAXV, (m+1) * x - 1)
            cnt = bit_cnt.range_sum(L, R)
            if cnt:
                sum_floor += m * cnt
            m += 1
        right = S - x * sum_floor
        p += left + right
        ans.append(p)
        # Insert x into structures
        bit_cnt.add(x, 1)
        S += x
        m = 1
        while m * x <= MAXV:
            L = m * x
            R = min(MAXV, (m+1) * x - 1)
            RA.add_range(L, R, m * x)
            m += 1
    return ans

def main():
    data = sys.stdin.read()
    if not data.strip():
        return
    n, a = read_input(data)
    res = solve_case_final(n, a)
    print(" ".join(map(str, res)))

if __name__ == "__main__":
    # Validate correctness on small random inputs by comparing to brute force
    import random
    def brute(n, a):
        out = []
        p = 0
        for k in range(1, n+1):
            x = a[k-1]
            s1 = sum(x % a[j] for j in range(k))
            s2 = sum(a[i] % x for i in range(k-1))
            p += s1 + s2
            out.append(p)
        return out
    for _ in range(10):
        n = 10
        pool = list(range(1, 200))
        random.shuffle(pool)
        a = pool[:n]
        assert solve_case_final(n, a) == brute(n, a)
    # Deterministic checks
    assert solve_case_final(2, [2,5]) == [0, 3]
    assert solve_case_final(3, [3,1,4])[0] == 0
\end{minted}
\VALIDATION{Exactly 3 asserts included at the end of the file, plus randomized small tests.}
\RESULT{Outputs the sequence $p_1, p_2, \ldots, p_n$; no tie-breaking is needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests compare the optimized methods against a brute-force implementation on random small arrays to ensure exact equality. Edge cases: strictly increasing, decreasing, and mixed values; smallest and largest possible $a_i$ in the allowed range.}
\LINE{CROSS-CHECKS}{Cross-validate Approach B and C against the naive baseline for $n \le 12$ on random permutations.}
\LINE{EDGE-CASE GENERATOR}{Produce arrays of size up to $12$ with values sampled without replacement from $[1,200]$.}
\begin{minted}{python}
import random

def gen_cases(t=50, nmax=12, vmax=200):
    for _ in range(t):
        n = random.randint(1, nmax)
        vals = list(range(1, vmax+1))
        random.shuffle(vals)
        a = vals[:n]
        yield n, a

def brute(n, a):
    out, p = [], 0
    for k in range(1, n+1):
        x = a[k-1]
        p += sum(x % a[j] for j in range(k))
        p += sum(a[i] % x for i in range(k-1))
        out.append(p)
    return out

# Reference solution (Approach C) packaged for testing
class Fenwick:
    __slots__ = ("n","bit")
    def __init__(self, n): self.n=n; self.bit=[0]*(n+2)
    def add(self,i,d):
        n=self.n
        while i<=n: self.bit[i]+=d; i+=i&-i
    def sum(self,i):
        s=0
        while i>0: s+=self.bit[i]; i-=i&-i
        return s
    def range_sum(self,l,r): return 0 if r<l else self.sum(r)-self.sum(l-1)

class RangeAddPointQueryFenwick:
    __slots__=("bit","n")
    def __init__(self,n): self.n=n; self.bit=Fenwick(n+2)
    def add_range(self,l,r,d):
        if l>r: return
        self.bit.add(l,d); self.bit.add(r+1,-d)
    def point(self,i): return self.bit.sum(i)

def solve_ref(n, a):
    MAXV=300000
    bit_cnt=Fenwick(MAXV+2)
    RA=RangeAddPointQueryFenwick(MAXV+2)
    res=[]; p=0; S=0
    for k in range(1,n+1):
        x=a[k-1]
        left=x*(k-1)-RA.point(x)
        sum_floor=0
        m=1
        while m*x<=MAXV:
            L=m*x; R=min(MAXV,(m+1)*x-1)
            sum_floor += m * bit_cnt.range_sum(L,R)
            m+=1
        right=S - x*sum_floor
        p += left + right
        res.append(p)
        bit_cnt.add(x,1)
        S += x
        m=1
        while m*x<=MAXV:
            L=m*x; R=min(MAXV,(m+1)*x-1)
            RA.add_range(L,R,m*x)
            m+=1
    return res

def self_test():
    for n,a in gen_cases():
        assert solve_ref(n,a) == brute(n,a)
    # fixed checks
    assert solve_ref(2,[2,5]) == [0,3]
    assert solve_ref(1,[7]) == [0]

if __name__ == "__main__":
    self_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

class Fenwick:
    __slots__ = ("n", "bit")
    def __init__(self, n):
        self.n = n
        self.bit = [0]*(n+2)
    def add(self, i, delta):
        n = self.n
        while i <= n:
            self.bit[i] += delta
            i += i & -i
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s
    def range_sum(self, l, r):
        if r < l:
            return 0
        return self.sum(r) - self.sum(l-1)

class RangeAddPointQueryFenwick:
    __slots__ = ("bit", "n")
    def __init__(self, n):
        self.n = n
        self.bit = Fenwick(n+2)
    def add_range(self, l, r, delta):
        if l > r: return
        self.bit.add(l, delta)
        self.bit.add(r+1, -delta)
    def point(self, idx):
        return self.bit.sum(idx)

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it))
    a = [int(next(it)) for _ in range(n)]
    return n, a

def solve_all(n, a):
    MAXV = 300000
    bit_cnt = Fenwick(MAXV+2)
    RA = RangeAddPointQueryFenwick(MAXV+2)
    ans = []
    p = 0
    S = 0
    for k in range(1, n+1):
        x = a[k-1]
        left = x*(k-1) - RA.point(x)
        sum_floor = 0
        m = 1
        while m * x <= MAXV:
            L = m * x
            R = min(MAXV, (m+1) * x - 1)
            cnt = bit_cnt.range_sum(L, R)
            if cnt:
                sum_floor += m * cnt
            m += 1
        right = S - x * sum_floor
        p += left + right
        ans.append(p)
        bit_cnt.add(x, 1)
        S += x
        m = 1
        while m * x <= MAXV:
            L = m * x
            R = min(MAXV, (m+1) * x - 1)
            RA.add_range(L, R, m * x)
            m += 1
    return ans

def main():
    n, a = read_input()
    res = solve_all(n, a)
    print(" ".join(map(str, res)))

if __name__ == "__main__":
    # Basic asserts
    assert solve_all(2, [2,5]) == [0,3]
    assert solve_all(1, [7]) == [0]
    # small random cross-check
    import random
    def brute(n, a):
        out, p = [], 0
        for k in range(1, n+1):
            x = a[k-1]
            p += sum(x % a[j] for j in range(k))
            p += sum(a[i] % x for i in range(k-1))
            out.append(p)
        return out
    for _ in range(5):
        n = 8
        vals = list(range(1, 60))
        random.shuffle(vals)
        a = vals[:n]
        assert solve_all(n, a) == brute(n, a)
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Incrementally compute $p_k = \sum_{i,j \le k} a_i \bmod a_j$ using quotient grouping and Fenwick trees.}
\WHY{Classic pattern: transform remainders to floor-division sums and exploit value-domain data structures; common in advanced CF problems.}
\CHECKLIST{
- Maintain $S$, counts BIT, and range-add BIT.
- For new $x$, compute left via $x(k-1)-\text{RA.query}(x)$.
- Compute right via multiples ranges on counts.
- Update both structures with $x$ afterwards.
}
\EDGECASES{
- $k=1$: both sums yield $0$.
- $x=1$: right sum is $0$, left sum equals number of previous elements.
- Large $x$ near $M$: loops run only $m=1$ few times.
- Sparse previous values: BIT queries handle empty ranges (return $0$).
- Distinctness guaranteed: counts are $0/1$.
- Maximum bounds: ensure indices up to $300{,}000$ inclusive.}
\PITFALLS{
- Off-by-one on range ends: use $[mx,(m+1)x-1]$ with clamp to $M$.
- Update RA after querying for current $x$ (not before).
- Use 64-bit integers in languages with fixed-width types; Python int is unbounded.
- Ensure $r=\lfloor x/q \rfloor$ in quotient blocking (Approach B).
- Initialize Fenwick sizes with a small cushion to avoid overflow at $r+1$.
- Avoid using raw index $0$ in BIT sums.}
\FAILMODES{Naive $O(n^2)$ will time out for $n=2\cdot 10^5$. Partial optimizations that only handle one side fast still fail. The final method balances both contributions with harmonic loops and BIT queries.}
\ELI{Turn remainders into subtractions of floor-division parts. Precompute how much each prior number contributes to every possible $x$ via range additions, and count how many prior numbers fall into each multiple block for $x$. Combine both to update the running total.}
\NotePages{3}

\end{document}