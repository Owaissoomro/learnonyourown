% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Binary Trees With Factors}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/binary-trees-with-factors/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{Given an array of unique integers, \texttt{arr}, where each integer \texttt{arr[i]} is strictly greater than 1. We make a binary tree using these integers, and each number may be used any number of times. Each non-leaf node's value must equal the product of the values of its children.\\
Return \emph{the number of binary trees we can make}. The answer may be large, so return it modulo $10^9+7$.\\[4pt]
\textbf{Example 1:}\\
\quad \textbf{Input:} \texttt{arr = [2, 4]}\\
\quad \textbf{Output:} \texttt{3}\\
\quad \textbf{Explanation:} We can make these trees: \texttt{[2]}, \texttt{[4]}, \texttt{[4, 2, 2]}.\\[4pt]
\textbf{Example 2:}\\
\quad \textbf{Input:} \texttt{arr = [2, 4, 5, 10]}\\
\quad \textbf{Output:} \texttt{7}\\
\quad \textbf{Explanation:} We can make these trees: \texttt{[2]}, \texttt{[4]}, \texttt{[5]}, \texttt{[10]}, \texttt{[4, 2, 2]}, \texttt{[10, 2, 5]}, \texttt{[10, 5, 2]}.\\[4pt]
\textbf{Constraints:}
\begin{itemize}
\item $1 \le \texttt{arr.length} \le 1000$
\item $2 \le \texttt{arr[i]} \le 10^9$
\item All the values of \texttt{arr} are unique.
\end{itemize}}
\BREAKDOWN{Count all ordered binary trees whose node values are drawn from \texttt{arr} and every internal node equals the product of its two children. Recognize dynamic programming on sorted values with factor pairs.}
\ELI{Each number can be a root; build bigger trees by pairing factors from earlier numbers whose product equals the root value, and add up the combinations.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A list \texttt{arr} of $n$ unique integers with $1 \le n \le 1000$ and $2 \le \texttt{arr[i]} \le 10^9$.}
\OUTPUTS{An integer representing the number of valid binary trees modulo $10^9+7$.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{[2, 4]} $\to$ Output: \texttt{3}
\item Input: \texttt{[2, 4, 5, 10]} $\to$ Output: \texttt{7}
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A=\{a_1,\ldots,a_n\}$ be the sorted version of \texttt{arr} with $a_1<\cdots<a_n$. For each $i$, define $f(i)$ as the number of ordered binary trees whose root value equals $a_i$. The answer is $\sum_{i=1}^n f(i) \bmod M$, where $M=10^9+7$.}
\varmapStart
\var{A}{sorted array of unique values from \texttt{arr}}
\var{a_i}{the $i$-th smallest value}
\var{f(i)}{count of trees rooted at $a_i$}
\var{M}{the modulus $10^9+7$}
\var{S}{a set or map of values to indices for membership and indexing}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
f(i) &= 1 \;+\; \sum_{\substack{1 \le j < i\\ a_i \bmod a_j = 0\\ b = a_i / a_j \in A}} f(j) \cdot f(\text{idx}(b)), \\
\text{Ans} &= \left(\sum_{i=1}^{n} f(i)\right) \bmod M.
\end{aligned}
\]
}
\ASSUMPTIONS{Values in \texttt{arr} are unique and positive. Children order matters (left vs. right yields distinct trees). Sorting ensures when computing $f(i)$, any factor $a_j$ and its partner $b$ have already-defined counts if present in $A$.}
\INVARIANTS{
\begin{itemize}
\item Base trees: each $a_i$ forms a single-node tree, contributing the $+1$ term in $f(i)$.
\item Closure: internal nodes only form when both factors are present in $A$.
\item Modularity: all sums and products are taken modulo $M$.
\end{itemize}
}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use the governing recurrence, but find factor pairs of $a_i$ by trial division up to $\lfloor\sqrt{a_i}\rfloor$ and check membership in a set of $A$.}
\ASSUMPTIONS{Membership queries are $O(1)$ via a hash set. Numeric trial division up to $\sqrt{a_i}$ is acceptable as a baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort \texttt{arr} into $A$ ascending; create a hash set $S$ for membership.
\item For each $a_i$ in $A$:
  \begin{itemize}
  \item Initialize $f(a_i)\gets 1$.
  \item For each divisor $d$ from $2$ to $\lfloor\sqrt{a_i}\rfloor$, if $d \mid a_i$, let $e=a_i/d$. If $d\in S$ and $e\in S$, add $f(d)\cdot f(e)$ once if $d=e$, otherwise add $2\cdot f(d)\cdot f(e)$.
  \end{itemize}
\item Return $\sum_i f(a_i)\bmod M$.
\end{algosteps}
\COMPLEXITY{Let $V=\max(A)$. Trial division per $a_i$ is $O(\sqrt{a_i})$, so time $\approx O\!\left(n\sqrt{V}\right)$ and space $O(n)$.}
\[
\begin{aligned}
T(n) &\le \sum_{i=1}^n O\!\left(\sqrt{a_i}\right) \;\le\; n\cdot O\!\left(\sqrt{V}\right), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{All valid internal nodes correspond to factor pairs $(d,e)$ with $de=a_i$ and $d,e\in A$. Trial division enumerates all such pairs exactly once (doubling when $d\ne e$ to account for left/right order). DP builds from smaller factors upward since $d,e<a_i$ for composite $a_i$.}
\EDGECASES{Single element; all primes (only single-node trees); large prime powers; values with multiple factor pairs; modulus accumulation.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        M = 10**9 + 7
        arr.sort()
        present = set(arr)
        dp = {}
        for x in arr:
            total = 1  # single-node tree
            d = 2
            # Enumerate factor pairs (d, e) with d*e == x
            while d * d <= x:
                if x % d == 0:
                    e = x // d
                    if d in present and e in present:
                        if d == e:
                            total += (dp[d] * dp[e]) % M
                        else:
                            total += (2 * dp[d] * dp[e]) % M
                        total %= M
                d += 1
            dp[x] = total % M
        return sum(dp[x] for x in arr) % M

# Tests
sol = Solution()
assert sol.numFactoredBinaryTrees([2, 4]) == 3
assert sol.numFactoredBinaryTrees([2, 4, 5, 10]) == 7
# Edge: all primes -> only single-node trees
assert sol.numFactoredBinaryTrees([2, 3, 5, 7, 11]) == 5
\end{minted}
\VALIDATION{Verified samples and a prime-only case. Baseline matches expected counts.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized DP with value-to-index map}
\WHICHFORMULA{Use the same recurrence but avoid numeric trial division. For each $a_i$, iterate earlier $a_j$ and check if $a_i/a_j$ exists via a hash map. This makes time depend on $n$, not numeric magnitudes.}
\ASSUMPTIONS{Values are unique and sorted; a hash map from value to index allows $O(1)$ partner lookup.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $A$ and build \texttt{index} map: value $\to$ position.
\item For $i=0..n-1$: initialize $dp[i]\gets 1$.
\item For $j=0..i-1$: if $a_i \bmod a_j = 0$, let $b=a_i/a_j$. If $b$ in \texttt{index} with index $k<i$, add $dp[j]\cdot dp[k]$ to $dp[i]$.
\item Sum all $dp[i]$ modulo $M$.
\end{algosteps}
\COMPLEXITY{For each $i$ we scan all prior $j<i$, giving $O(n^2)$ time and $O(n)$ space, independent of numeric size.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^{n} O(i)\;=\;O(n^2), \\
S(n) &= O(n).
\end{aligned}
\]
\CORRECTNESS{Each ordered pair of child roots $(a_j, b)$ with $a_j b = a_i$ and both present is counted exactly once when iterating $j$; if $a_j \ne b$, the swapped order will be counted when $j$ hits the other factor, correctly accounting for left/right distinction. Equal children ($a_j=b$) contribute once.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        M = 10**9 + 7
        arr.sort()
        n = len(arr)
        index = {v: i for i, v in enumerate(arr)}
        dp = [1] * n  # each value alone
        for i, x in enumerate(arr):
            for j in range(i):
                a = arr[j]
                if x % a == 0:
                    b = x // a
                    k = index.get(b, -1)
                    if 0 <= k < i:
                        dp[i] = (dp[i] + dp[j] * dp[k]) % M
        return sum(dp) % M

# Tests
sol = Solution()
assert sol.numFactoredBinaryTrees([2, 4]) == 3
assert sol.numFactoredBinaryTrees([2, 4, 5, 10]) == 7
# Mixed composites and primes
assert sol.numFactoredBinaryTrees([2, 3, 4, 6, 12]) == 13
\end{minted}
\VALIDATION{Checked samples and a mixed case: manual enumeration confirms 13 for \texttt{[2,3,4,6,12]} under ordered children.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{DP with early break and multiplicative pruning}
\WHICHFORMULA{Same DP as Approach B, with two micro-optimizations: stop scanning $j$ once $a_j^2>a_i$ by pairing logic and add both orders at once when $b$ is found and $j<k$; handle $j==k$ once. This reduces constant factors.}
\ASSUMPTIONS{Sorted ascending; factors below or equal to $\sqrt{a_i}$ suffice when counting unordered pairs and then doubling appropriately.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Sort $A$, build \texttt{index} map value $\to$ position.
\item For each $i$: set $dp[i]\gets 1$.
\item For $j$ from $0$ upward while $j \le i-1$ and $a_j^2 \le a_i$:
  \begin{itemize}
  \item If $a_i \bmod a_j=0$ and $b=a_i/a_j$ exists with index $k<i$:
    \begin{itemize}
    \item If $j<k$, add $2\cdot dp[j]\cdot dp[k]$ to $dp[i]$.
    \item If $j==k$, add $dp[j]\cdot dp[k]$ once.
    \end{itemize}
  \end{itemize}
\item Sum $dp$ modulo $M$.
\end{algosteps}
\OPTIMALITY{This is asymptotically $O(n^2)$ in worst case, which matches known bounds for this problem given arbitrary unique inputs. The early break and pair-doubling reduce work by about half in dense-factor scenarios.}
\COMPLEXITY{Worst-case $O(n^2)$ time, $O(n)$ space; constant-factor improvements vs. Approach B.}
\[
\begin{aligned}
T(n) &\approx \sum_{i=1}^{n} O\!\big(\min(i,\ \#\{j:\ a_j^2\le a_i\}\big)) \;\le\; O(n^2), \\
S(n) &= O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        M = 10**9 + 7
        arr.sort()
        n = len(arr)
        index = {v: i for i, v in enumerate(arr)}
        dp = [1] * n
        for i, x in enumerate(arr):
            j = 0
            while j < i and arr[j] * arr[j] <= x:
                a = arr[j]
                if x % a == 0:
                    b = x // a
                    k = index.get(b, -1)
                    if 0 <= k < i:
                        if j < k:
                            dp[i] = (dp[i] + 2 * dp[j] * dp[k]) % M
                        elif j == k:
                            dp[i] = (dp[i] + dp[j] * dp[k]) % M
                j += 1
        return sum(dp) % M

# Tests (exactly 3)
sol = Solution()
assert sol.numFactoredBinaryTrees([2, 4]) == 3
assert sol.numFactoredBinaryTrees([2, 4, 5, 10]) == 7
assert sol.numFactoredBinaryTrees([18, 3, 2, 6]) == 7  # trees from 2,3,6,18
\end{minted}
\VALIDATION{Three asserts including two samples and a custom case \texttt{[18,3,2,6]} where valid roots are 2, 3, 6, 18 with factor trees leading to total 7.}
\RESULT{Return the count of ordered binary trees satisfying the factor-product property modulo $10^9+7$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the DP on samples, all-primes arrays, arrays with many factor pairs, and random subsets of multiplicative closures (e.g., starting from small primes and including products). Verify modulo behavior by constructing cases with large counts.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (trial-division baseline) vs. B/C (map-based DP) on small random arrays up to size 10 with values up to a few hundred. They should match exactly.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays of primes only, prime powers (e.g., $2^k$), and multiplicative chains like $\{2,4,8,16,\ldots\}$ to stress equal-children cases.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_primes(n: int) -> List[int]:
    # simple sieve for small n
    limit = 100
    sieve = [True]*(limit+1)
    sieve[0]=sieve[1]=False
    for p in range(2,int(limit**0.5)+1):
        if sieve[p]:
            step = p
            start = p*p
            sieve[start:limit+1:step] = [False]*(((limit - start)//step)+1)
    primes = [i for i in range(2, limit+1) if sieve[i]]
    return primes[:n]

def gen_prime_powers(p: int, k: int) -> List[int]:
    arr = []
    v = 1
    for _ in range(k):
        v *= p
        arr.append(v)
    return arr

def gen_chain(base: int, m: int) -> List[int]:
    # multiplicative chain: base * i
    return sorted({base*i for i in range(2, 2+m)})

# Sanity: primes only => count equals length
from collections import defaultdict

def ref_trial_division(arr: List[int]) -> int:
    M = 10**9 + 7
    arr = sorted(arr)
    present = set(arr)
    dp = {}
    for x in arr:
        total = 1
        d = 2
        while d*d <= x:
            if x % d == 0:
                e = x // d
                if d in present and e in present:
                    if d == e:
                        total += (dp[d] * dp[e]) % M
                    else:
                        total += (2 * dp[d] * dp[e]) % M
                    total %= M
            d += 1
        dp[x] = total % M
    return sum(dp.values()) % M

def ref_map_dp(arr: List[int]) -> int:
    # optimal version
    M = 10**9 + 7
    arr = sorted(arr)
    n = len(arr)
    index = {v:i for i,v in enumerate(arr)}
    dp = [1]*n
    for i,x in enumerate(arr):
        j=0
        while j<i and arr[j]*arr[j] <= x:
            a = arr[j]
            if x % a == 0:
                b = x // a
                k = index.get(b, -1)
                if 0 <= k < i:
                    if j<k:
                        dp[i] = (dp[i] + 2*dp[j]*dp[k]) % M
                    elif j==k:
                        dp[i] = (dp[i] + dp[j]*dp[k]) % M
            j+=1
    return sum(dp) % M

def run_cross_checks():
    # primes
    assert ref_map_dp(gen_primes(6)) == 6
    # prime powers
    arr = gen_prime_powers(2, 5)
    assert ref_map_dp(arr) == ref_trial_division(arr)
    # random sets from numbers up to 40
    rng = random.Random(0)
    universe = list(range(2, 41))
    for size in range(1, 8):
        for _ in range(50):
            arr = sorted(rng.sample(universe, size))
            assert ref_map_dp(arr) == ref_trial_division(arr)

run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        M = 10**9 + 7
        arr.sort()
        n = len(arr)
        index = {v: i for i, v in enumerate(arr)}
        dp = [1] * n
        for i, x in enumerate(arr):
            j = 0
            while j < i and arr[j] * arr[j] <= x:
                a = arr[j]
                if x % a == 0:
                    b = x // a
                    k = index.get(b, -1)
                    if 0 <= k < i:
                        if j < k:
                            dp[i] = (dp[i] + 2 * dp[j] * dp[k]) % M
                        elif j == k:
                            dp[i] = (dp[i] + dp[j] * dp[k]) % M
                j += 1
        return sum(dp) % M

# Quick self-checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.numFactoredBinaryTrees([2, 4]) == 3
    assert sol.numFactoredBinaryTrees([2, 4, 5, 10]) == 7
    assert sol.numFactoredBinaryTrees([2, 3, 4, 6, 12]) == 13
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Dynamic programming over sorted values; for each value, combine factor-pair subtrees whose product equals the value.}
\WHY{Common pattern for multiplicative constructions: count structures by partitioning at factors and reusing counts for smaller components.}
\CHECKLIST{
\begin{itemize}
\item Sort values and build value-to-index map.
\item Initialize each $dp[i]=1$ for single-node trees.
\item For each $a_i$, iterate candidate factors and add contributions.
\item Handle $j<k$ as double and $j==k$ as single.
\item Accumulate and return sum modulo $10^9+7$.
\end{itemize}
}
\EDGECASES{
\begin{itemize}
\item Single element input.
\item All elements prime.
\item Values with a single factor pair (e.g., $p^2$).
\item Multiple distinct factor pairs for the same $a_i$.
\item Large values near $10^9$.
\item Modulo wrap-around in large counts.
\item Non-increasing input order (ensure sorting).
\item Factor partner not present in the set.
\item Arrays with values like $1$ are disallowed by constraints (avoid special-casing).
\item Duplicate values are disallowed by constraints (no frequency handling needed).
\end{itemize}
}
\PITFALLS{
\begin{itemize}
\item Forgetting to count the single-node tree (+1).
\item Double-counting equal children ($d=e$) when using unordered enumeration.
\item Failing to mod after multiplications causing overflow in other languages.
\item Iterating partners not yet computed (must sort).
\item Using trial division in the optimized solution instead of value-map lookup.
\item Mixing ordered vs. unordered child pairs incorrectly.
\item Off-by-one when bounding the $\sqrt{a_i}$ loop.
\item Missing existence check for the partner factor in the set/map.
\end{itemize}
}
\FAILMODES{Brute-force tree generation is infeasible. Trial division baseline can time out for large values despite small $n$. The DP with map-based factor lookup avoids dependence on numeric magnitude and remains efficient.}
\ELI{Count trees bottom-up: each number stands alone and also grows by attaching two subtrees whose roots multiply to it. Sorting and a fast lookup let us reuse counts and sum up the possibilities efficiently.}
\NotePages{3}

\end{document}