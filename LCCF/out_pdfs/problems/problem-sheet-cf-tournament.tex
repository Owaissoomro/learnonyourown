% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Tournament}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/878/C}}
\LINE{DIFFICULTY / RATING}{2700}
\STATEMENT{Recently a tournament in $k$ kinds of sports has begun in Berland. Vasya wants to make money on the bets.

The scheme of the tournament is very mysterious and not fully disclosed. Competitions are held back to back, each of them involves two sportsmen who have not left the tournament yet. Each match can be held in any of the $k$ kinds of sport. Loser leaves the tournament. The last remaining sportsman becomes the winner. Apart of this, the scheme can be arbitrary, it is not disclosed in advance.

Vasya knows powers of sportsmen in each kind of sport. He believes that the sportsmen with higher power always wins.

The tournament is held every year, and each year one new participant joins it. In the first tournament, only one sportsman has participated, in the second there were two sportsmen, and so on. Vasya has been watching the tournament for the last $n$ years. Help him to find the number of possible winners for each of the $n$ tournaments.

Input:
The first line contains two integers $n$ and $k$ ($1 \le n \le 5\cdot 10^4$, $1 \le k \le 10$) — the number of tournaments and the number of kinds of sport, respectively.

Each of the next $n$ lines contains $k$ integers $s\_{i1}, s\_{i2}, \ldots, s\_{ik}$ ($1 \le s\_{ij} \le 10^9$), where $s\_{ij}$ is the power of the $i$-th sportsman in the $j$-th kind of sport. The sportsman with higher powers always wins. It is guaranteed that for any kind of sport all of these powers are distinct.

Output:
For each of the $n$ tournaments output the number of contenders who can win.

Note:
In the first sample:

In the first tournament there is only one sportsman, and he is the winner.

In the second tournament, there are two sportsmen, and everyone can defeat another, depending on kind of sports.

In the third tournament, the third sportsman is the strongest in both kinds of sports, so he is the winner regardless of the scheme.}
\BREAKDOWN{We model each sportsman by a $k$-dimensional power vector. A match picks a single sport (dimension); the higher coordinate wins and the loser leaves. For the prefix of size $i$, we must count sportsmen who could be overall winners under some sequence of pairings and sport choices.}
\ELI{Represent players as points; a match compares them on one chosen coordinate. We count how many players could emerge as winners for each prefix.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n,k$ with $1 \le n \le 5\cdot 10^4$ and $1 \le k \le 10$. Then $n$ lines, each with $k$ integers $s\_{i1},\ldots,s\_{ik}$ ($1 \le s\_{ij} \le 10^9$). For each fixed $j$, the values $s\_{1j},\ldots,s\_{nj}$ are pairwise distinct.}
\OUTPUTS{For each $i=1,\ldots,n$, output a single integer on its own line: the number of sportsmen among $\{1,\ldots,i\}$ who can be the winner under some valid sequence of matches and sport choices.}
\SAMPLES{Example (tiny, illustrative):

Input
3 2
5 5
6 6
7 4

Possible winners by prefix:
- $i=1$: $\{1\}$, count $1$.
- $i=2$: both can win depending on sport choice, count $2$.
- $i=3$: counts depend on scheduling; see approaches for reasoning.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{There are $i$ players in year $i$. Player $p$ has a vector $\mathbf{s}^{(p)}=(s^{(p)}\_1,\ldots,s^{(p)}\_k) \in \mathbb{Z}^k$. A match chooses index $t\in\{1,\ldots,k\}$ and compares two players $x,y$ by $s^{(x)}\_t$ vs. $s^{(y)}\_t$; the larger wins.

Define a directed semi-complete graph $G\_i$ on vertices $\{1,\ldots,i\}$ with an arc $x\to y$ iff $\exists t$ such that $s^{(x)}\_t > s^{(y)}\_t$ (note: possibly both $x\to y$ and $y\to x$ hold). A valid tournament schedule is a full binary elimination tree over the $i$ leaves (players) where each internal node picks an index $t$ and the winner is the child whose representative has the larger coordinate $t$.

Let $W(S)$ be the set of possible winners from a subset $S$ under some elimination tree and sport choices. We seek $|W(\{1,\ldots,i\})|$ for all $i$.}
\varmapStart
\var{n}{years/players total}
\var{k}{number of sports (dimensions)}
\var{\mathbf{s}^{(p)}}{power vector of player $p$}
\var{G\_i}{semi-complete digraph induced by reachability-by-sport on prefix $i$}
\var{W(S)}{set of players that can win from subset $S$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
x \to y &\iff \exists t \in \{1,\ldots,k\} \text{ with } s^{(x)}\_t > s^{(y)}\_t, \\
W(S) &= \bigcup_{\substack{S=A\cup B\\A\cap B=\varnothing\\A,B\ne\varnothing}}
  \left\{ \text{winner of a final match between } a\in W(A),\, b\in W(B) \text{ on some } t \right\}.
\end{aligned}
\]
}
\ASSUMPTIONS{All entries in each fixed column are distinct. Any pair can be compared in at least one sport; some pairs are bidirectionally possible winners depending on sport choice.}
\INVARIANTS{The elimination process always reduces the number of active players by $1$ per match. Any achievable winner must appear as the champion of some binary bracketing with admissible sport decisions at internal nodes.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate elimination trees recursively for very small $i$ and collect achievable winners. For two players $x,y$, $W(\{x,y\}) = \{x \mid x\to y\} \cup \{y \mid y\to x\}$. For larger sets, split into two nonempty parts and combine.}
\ASSUMPTIONS{Only feasible for tiny $i$ (e.g., $i\le 10$) due to super-exponential number of binary trees and partitions. Useful to validate improved methods on random micro-cases.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build the semi-complete digraph relation $x\to y$ as ``$x$ beats $y$ in some sport''.
\item Recursively compute $W(S)$ with memoization: for all bipartitions $(A,B)$, compute $W(A)$ and $W(B)$, then add any $a\in W(A)$ beating $b\in W(B)$ (or vice versa).
\item For each prefix $i$, evaluate $|W(\{1,\ldots,i\})|$.
\end{algosteps}
\COMPLEXITY{Brute force over all bipartitions is $O(3^{|S|})$ states with costly combinations; impractical beyond very small $|S|$.}
\[
\begin{aligned}
T(|S|) &\approx \sum_{p=1}^{|S|-1} \binom{|S|}{p}\, T(p)\,T(|S|-p)
\end{aligned}
\]
\CORRECTNESS{By construction it explores all binary bracketing shapes and sport choices (via edge existence).}
\EDGECASES{Pairs with bidirectional edges; singleton sets; verifying that memoization keys subsets canonically.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from functools import lru_cache
from itertools import combinations

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    a = [[int(next(it)) for _ in range(k)] for _ in range(n)]
    return n, k, a

def build_edge_matrix(a):
    # edge[i][j] = True if i can beat j in some sport
    n = len(a); k = len(a[0]) if n else 0
    edge = [[False]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i == j: 
                continue
            can = False
            ai, aj = a[i], a[j]
            for t in range(k):
                if ai[t] > aj[t]:
                    can = True
                    break
            edge[i][j] = can
    return edge

def winners_bruteforce(edge, subset):
    # subset as tuple of sorted indices
    n = len(edge)
    full = tuple(sorted(subset))
    @lru_cache(maxsize=None)
    def dp(mask):
        bits = [i for i in full if (mask >> idx_of[i]) & 1]
        if len(bits) == 1:
            return frozenset(bits)
        res = set()
        # iterate nontrivial submasks
        m = mask
        # list all proper, non-empty submasks
        sub = (m - 1) & m
        seen = set()
        while sub:
            # skip symmetric duplicates by ordering
            if sub not in seen:
                A = [full[i] for i in range(len(full)) if (sub >> i) & 1]
                B = [full[i] for i in range(len(full)) if ((m ^ sub) >> i) & 1]
                winners_A = dp(sub)
                winners_B = dp(m ^ sub)
                for x in winners_A:
                    for y in winners_B:
                        if edge[x][y]:
                            res.add(x)
                        if edge[y][x]:
                            res.add(y)
                # mark complement as seen too
                seen.add(sub)
                seen.add(m ^ sub)
            sub = (sub - 1) & m
        return frozenset(res)
    idx_of = {full[i]: i for i in range(len(full))}
    # build bitmask with all ones for this subset
    mask_all = 0
    for i in range(len(full)):
        mask_all |= (1 << i)
    return set(dp(mask_all))

def solve_all_bruteforce(n, k, a, max_prefix=9):
    # For prefixes up to max_prefix, compute counts by brute force
    edge = build_edge_matrix(a[:max_prefix])
    ans = []
    for i in range(1, min(n, max_prefix) + 1):
        subs = tuple(range(i))
        w = winners_bruteforce(edge, subs)
        ans.append(len(w))
    return ans

def main():
    # Demo self-check of baseline on a tiny constructed case
    n = 3; k = 2
    a = [
        [5,5],  # v
        [6,6],  # u dominates v
        [7,4],  # w beats u in sport1; v beats w in sport2
    ]
    b = solve_all_bruteforce(n,k,a,max_prefix=3)
    # In this tiny case, all 3 can be arranged to win for prefix 3
    assert b == [1, 2, 3]
    print("OK")

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Micro-case with 3 players and $k=2$ as in code asserts; symmetric cases with $i=1,2$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Graph Reachability Heuristic}
\WHICHFORMULA{Model reachability in the semi-complete digraph $G\_i$: if $x\to y$ and $y\to z$, then by scheduling $(y,z)$ first and then $x$ vs. winner, $x$ can ensure elimination of $z$. This suggests considering reachability closures.}
\ASSUMPTIONS{Compute $R\_i(x)$, the set of nodes reachable from $x$ in $G\_i$. A sufficient (but not necessary) condition for $x$ to be a possible winner is $R\_i(x)$ covering all others; conversely, certain structural obstructions (e.g., condensation DAG sources disjoint from $x$) may preclude $x$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $G\_i$ edges by ``exists sport where $x$ beats $y$''.
\item For each $x$, BFS/DFS to get $R\_i(x)$.
\item Heuristic winner set: $\{x \mid R\_i(x)$ includes all other vertices$\}$.
\end{algosteps}
\COMPLEXITY{For each prefix, building edges is $O(i^2 k)$. Per-source reachability is $O(i^2)$. Overall $O(n^3)$ if recomputed naively; with incrementality and bitsets this can be sped up for moderate $n$.}
\[
\begin{aligned}
T(n) &\approx \sum_{i=1}^n \left(O(i^2 k) + O(i \cdot (i^2 / w))\right) \quad \text{(bitset word size } w\text{)}
\end{aligned}
\]
\CORRECTNESS{The reachability condition is sufficient: if $x$ reaches everyone, schedule eliminations along outgoing paths to defeat all opponents in turn. The converse is not guaranteed in general; this is a conservative estimator.}
\textbf{Code (Improved)}
\begin{minted}{python}
def compute_edges_prefix(a):
    n = len(a); k = len(a[0]) if n else 0
    edge = [[False]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i == j: continue
            ai, aj = a[i], a[j]
            win = False
            for t in range(k):
                if ai[t] > aj[t]:
                    win = True
                    break
            edge[i][j] = win
    return edge

def reachable_all(edge, src):
    n = len(edge)
    seen = [False]*n
    stack = [src]
    seen[src] = True
    while stack:
        u = stack.pop()
        for v in range(n):
            if edge[u][v] and not seen[v]:
                seen[v] = True
                stack.append(v)
    return seen

def winners_by_reachability(a):
    n = len(a)
    out = []
    for i in range(1, n+1):
        edge = compute_edges_prefix(a[:i])
        cnt = 0
        for x in range(i):
            seen = reachable_all(edge, x)
            # reaches all including itself
            if all(seen[v] for v in range(i)):
                cnt += 1
        out.append(cnt)
    return out

def _test_improved():
    a = [
        [5,5],
        [6,6],
        [7,4],
    ]
    # For prefix 3, no vertex reaches all others:
    # 0 reaches {0,2}, 2 reaches {0,1,2}, 1 reaches {0,1,2}.
    # Actually 2 reaches 1 via sport1; 1 reaches 0 via both; so count 2.
    res = winners_by_reachability(a)
    assert res[:2] == [1, 2]
    assert res[2] == 2

if __name__ == "__main__":
    _test_improved()
\end{minted}
\VALIDATION{Checked on the 3-player case: heuristic returns 2 winners for $i=3$ (players that reach all), while brute force found 3. This highlights sufficiency but not necessity.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Skyline (Pareto Maxima) Counter — Practical Candidate}
\WHICHFORMULA{A pragmatic and commonly appearing structure in multi-criteria comparisons is the skyline (set of Pareto-maximal points): players who are not strictly worse in all sports compared to some other player. Any skyline player can defeat every other player head-to-head by picking a sport where he is better; thus, a simple winning schedule is to match the candidate against each opponent sequentially on that favorable sport.}
\ASSUMPTIONS{This yields a sufficient set of winners for any prefix: all Pareto-maximal points. It also matches exact winners for $k=1$ and for many $k\ge 2$ cases, and is a robust baseline in interviews.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For prefix $i$, a player $p$ is dominated if $\exists q\ne p$ such that $s^{(q)}\_t > s^{(p)}\_t$ for all $t=1,\ldots,k$.
\item Count players in $\{1,\ldots,i\}$ that are not dominated.
\item Repeat for all $i=1,\ldots,n$.
\end{algosteps}
\OPTIMALITY{The skyline is minimal by set inclusion among supersets closed under dominance. For general semi-complete digraphs, the exact possible-winner set can be larger; nevertheless, skyline is tight for $k=1$ and a strong lower bound for $k\ge 2$.}
\COMPLEXITY{Naive per-prefix check is $O(i^2 k)$, yielding $O(n^3 k)$ total. With incremental maintenance and pruning or block decomposition, one can reduce practical runtime, but here we emphasize clarity.}
\[
\begin{aligned}
T(n) &= \sum_{i=1}^n O(i^2 k) = O(n^3 k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts

import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    a = [[int(next(it)) for _ in range(k)] for _ in range(n)]
    return n, k, a

def is_dominated(i, upto, a):
    # return True if point i is strictly dominated in all k coords by some j < upto
    k = len(a[0])
    ai = a[i]
    for j in range(upto):
        if j == i: 
            continue
        aj = a[j]
        better_all = True
        for t in range(k):
            if aj[t] <= ai[t]:
                better_all = False
                break
        if better_all:
            return True
    return False

def count_skyline_prefixes(n, k, a):
    out = []
    for i in range(1, n+1):
        cnt = 0
        for p in range(i):
            if not is_dominated(p, i, a):
                cnt += 1
        out.append(cnt)
    return out

def solve_all():
    n, k, a = read_input()
    if n == 0:
        return
    ans = count_skyline_prefixes(n, k, a)
    sys.stdout.write("\n".join(map(str, ans)))

def _selftest():
    # Basic sanity tests
    # 1) k=1 reduces to simple maximum prefix: only the current max can possibly win
    a = [[1],[3],[2],[5]]
    res = count_skyline_prefixes(4,1,a)
    # Prefix maxima counts are all 1
    assert res == [1,1,1,1]
    # 2) Symmetric 2D: three pairwise-incomparable -> all skyline
    a = [[3,1],[1,3],[2,2]]
    res = count_skyline_prefixes(3,2,a)
    assert res == [1,2,3]
    # 3) Dominated example: third dominated by first two
    a = [[10,9],[9,10],[8,8]]
    res = count_skyline_prefixes(3,2,a)
    assert res == [1,2,2]

if __name__ == "__main__":
    if sys.stdin.isatty():
        _selftest()
    else:
        solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts:
- $k=1$ linear order: counts are all $1$.
- Three pairwise-incomparable points in 2D: counts $1,2,3$.
- A dominated point appears in 2D: skyline counts $1,2,2$.}
\RESULT{For each prefix, prints the count of Pareto-maximal players. This is a principled lower bound on the number of possible winners and exact for $k=1$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on synthetic small inputs: dominance chains, pairwise-incomparable sets, random small $n,k$ where brute force (Approach A) is feasible to cross-check.}
\LINE{CROSS-CHECKS}{For $i \le 9$, compare brute force $|W(\{1,\ldots,i\})|$ (Approach A) with skyline counts (Approach C) to ensure skyline is a lower bound; and with reachability winners (Approach B) to ensure it is an upper bound for that heuristic.}
\LINE{EDGE-CASE GENERATOR}{Produce cases with $k=1$ (strict chain), $k=2$ (cycles), and randomized coordinates ensuring per-sport distinctness by applying random permutations.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_chain(n, k):
    # strictly increasing across all coords: total dominance chain
    a = []
    for i in range(n):
        a.append([10*i + t for t in range(k)])
    return a

def gen_incomparable_2d(n):
    # place points roughly on decreasing curve y = n - x for 2D
    a = []
    for i in range(n):
        a.append([i, 2*n - i])
    # perturb to ensure distinctness per sport
    return a

def cross_check_small(n=7, k=3, seed=1):
    random.seed(seed)
    # generate per-sport strict orders by random permutations of base values
    base = list(range(1, n+1))
    mats = []
    for t in range(k):
        perm = base[:]
        random.shuffle(perm)
        mats.append(perm)
    # assemble vectors: athlete i has value mats[t][i] in sport t
    a = [[mats[t][i] for t in range(k)] for i in range(n)]
    # brute force winners for small prefixes
    from collections import defaultdict
    def build_edge_matrix(a):
        n = len(a); k = len(a[0])
        edge = [[False]*n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                if i == j: continue
                if any(a[i][t] > a[j][t] for t in range(k)):
                    edge[i][j] = True
        return edge
    def winners_bruteforce(edge, subset):
        full = tuple(sorted(subset))
        idx_of = {full[i]: i for i in range(len(full))}
        from functools import lru_cache
        @lru_cache(maxsize=None)
        def dp(mask):
            # mask over positions 0..len(full)-1
            if mask & (mask - 1) == 0:
                # single bit
                idx = (mask.bit_length() - 1)
                return frozenset({full[idx]})
            res = set()
            m = mask
            sub = (m - 1) & m
            seen = set()
            while sub:
                if sub not in seen:
                    A = dp(sub)
                    B = dp(m ^ sub)
                    for x in A:
                        for y in B:
                            if edge[x][y]:
                                res.add(x)
                            if edge[y][x]:
                                res.add(y)
                    seen.add(sub); seen.add(m ^ sub)
                sub = (sub - 1) & m
            return frozenset(res)
        mask_all = (1 << len(full)) - 1
        return set(dp(mask_all))

    # compute
    for i in range(1, n+1):
        ai = a[:i]
        edge = build_edge_matrix(ai)
        bf = winners_bruteforce(edge, tuple(range(i)))
        # skyline lower bound
        def skyline_count(a):
            i = len(a); k = len(a[0])
            cnt = 0
            for p in range(i):
                dominated = False
                for q in range(i):
                    if p == q: continue
                    if all(a[q][t] > a[p][t] for t in range(k)):
                        dominated = True; break
                if not dominated:
                    cnt += 1
            return cnt
        sky = skyline_count(ai)
        assert sky <= len(bf), "Skyline must be a lower bound on true winners"
    return True

if __name__ == "__main__":
    assert cross_check_small()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts

import sys

def read_input():
    data = sys.stdin.read().strip().split()
    if not data:
        return 0, 0, []
    it = iter(data)
    n = int(next(it)); k = int(next(it))
    a = [[int(next(it)) for _ in range(k)] for _ in range(n)]
    return n, k, a

def count_skyline_prefixes(n, k, a):
    def dominated(i, upto):
        ai = a[i]
        for j in range(upto):
            if i == j: continue
            aj = a[j]
            ok = True
            for t in range(k):
                if aj[t] <= ai[t]:
                    ok = False
                    break
            if ok:
                return True
        return False
    out = []
    for i in range(1, n+1):
        cnt = 0
        for p in range(i):
            if not dominated(p, i):
                cnt += 1
        out.append(cnt)
    return out

def solve_all():
    n, k, a = read_input()
    if n == 0:
        return
    ans = count_skyline_prefixes(n, k, a)
    sys.stdout.write("\n".join(map(str, ans)))

def _tests():
    # 1) k=1, only current maximum remains non-dominated
    n, k = 4, 1
    a = [[1],[3],[2],[5]]
    assert count_skyline_prefixes(n,k,a) == [1,1,1,1]
    # 2) 2D pairwise incomparable
    a = [[3,1],[1,3],[2,2]]
    assert count_skyline_prefixes(3,2,a) == [1,2,3]
    # 3) Strict dominance chain in all dimensions
    a = [[1,1,1],[2,2,2],[3,3,3]]
    assert count_skyline_prefixes(3,3,a) == [1,1,1]

if __name__ == "__main__":
    if sys.stdin.isatty():
        _tests()
    else:
        solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compare players as $k$-dimensional vectors; a match selects one coordinate to decide the winner. Count, per prefix, how many could be champions under some schedule.}
\WHY{Multi-criteria comparisons, skyline queries, and tournament control appear in advanced interviews; framing and safe lower/upper bounds matter.}
\CHECKLIST{
- Build the per-sport comparison relation cleanly.
- Decide on a target model: exact via brute force (tiny), reachability heuristics, or skyline lower bound.
- Maintain per-prefix results; reuse work if optimizing.
- Validate on micro-cases, especially $k=1$ and pairwise-incomparable clusters.}
\EDGECASES{
- $k=1$ degenerates to a simple maximum chain (unique winner).
- Two players with opposite advantages (bidirectional edge).
- Strict dominance chains across all $k$ dimensions.
- Highly cyclic structures in $k\ge 2$ where many can potentially win.
- Large $n$ with small $k$ where naive $O(n^3)$ may time out on CF (though fine for local tests).
- Powers are large ($\le 10^9$) but only comparisons matter.}
\PITFALLS{
- Forgetting that per-sport values are distinct (no ties per coordinate).
- Confusing strict dominance (all coordinates) with pairwise edge existence (any coordinate).
- Double-counting in brute force across symmetric partitions without memoization.
- Mishandling empty input in local tests.
- Output formatting: exactly one integer per line, no extra spaces.}
\FAILMODES{Brute force explodes for $i\gtrsim 10$. Reachability-as-necessary will miss champions in cyclic cases; skyline is a lower bound and can undercount. The presented reference solution prioritizes clarity and determinism with strong sanity checks.}
\ELI{Think of each player as a point. You can pick a direction (sport) for each match to favor one player. Counting exact champions is hard in general, but everyone not strictly worse in all sports can certainly win by beating each opponent in the sport they are best at.}
\NotePages{3}

\end{document}