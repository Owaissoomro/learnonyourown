% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Devu and Flowers}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/451/E}}
\LINE{DIFFICULTY / RATING}{2300}
\STATEMENT{Devu wants to decorate his garden with flowers. He has purchased $n$ boxes, where the $i$-th box contains $f_i$ flowers. All flowers in a single box are of the same color (hence they are indistinguishable). Also, no two boxes have flowers of the same color.

Now Devu wants to select exactly $s$ flowers from the boxes to decorate his garden. Devu would like to know, in how many different ways can he select the flowers from each box? Since this number may be very large, he asks you to find the number modulo $10^9+7$.

Devu considers two ways different if there is at least one box from which different number of flowers are selected in these two ways.

Input: The first line of input contains two space-separated integers $n$ and $s$ ($1 \le n \le 20$, $0 \le s \le 10^{14}$). The second line contains $n$ space-separated integers $f_1, f_2, \ldots, f_n$ ($0 \le f_i \le 10^{12}$).

Output: Output a single integer — the number of ways in which Devu can select the flowers modulo $10^9+7$.

Note: Sample 1. There are two ways of selecting $3$ flowers: \{1, 2\} and \{0, 3\}. Sample 2. There is only one way of selecting $4$ flowers: \{2, 2\}. Sample 3. There are three ways of selecting $5$ flowers: \{1, 2, 2\}, \{0, 3, 2\}, and \{1, 3, 1\}.}
\BREAKDOWN{Count the number of integer vectors $(x_1,\ldots,x_n)$ with $0 \le x_i \le f_i$ and $\sum x_i = s$. Use stars-and-bars with upper bounds via inclusion–exclusion. Because $s$ is large but $n$ is small, compute $\binom{m}{k}$ with large $m$ and small $k=n-1$ modulo a prime.}
\ELI{Start with all solutions to $\sum x_i=s$ and subtract those violating $x_i \le f_i$ using inclusion–exclusion; compute the resulting small-$k$ binomials modulo $10^9+7$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test:
- $n$ (integer), $1 \le n \le 20$.
- $s$ (integer), $0 \le s \le 10^{14}$.
- Array $f[1..n]$ (integers), $0 \le f_i \le 10^{12}$.}
\OUTPUTS{One integer: the number of $n$-tuples $(x_1,\ldots,x_n)$ with $0 \le x_i \le f_i$ and $\sum x_i = s$, modulo $10^9+7$.}
\SAMPLES{Example 1:
Input:
2 3
1 3

Output:
2

Example 2:
Input:
2 4
2 2

Output:
1}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Find the number of integer solutions to
\begin{BreakableEquation*}
x_i \in \mathbb{Z}_{\ge 0},\quad 0 \le x_i \le f_i,\quad \sum_{i=1}^{n} x_i = s.
\end{BreakableEquation*}
By inclusion–exclusion over subsets $T \subseteq [n]$ that violate $x_i \le f_i$, let $b(T)=s-\sum_{i\in T}(f_i+1)$. The count equals
\begin{BreakableEquation*}
\sum_{T \subseteq [n]} (-1)^{|T|} \binom{b(T)+n-1}{n-1},
\end{BreakableEquation*}
with the convention $\binom{m}{k}=0$ if $m<0$ or $m<k$.}
\varmapStart
\var{n}{number of boxes}
\var{s}{total flowers to select}
\var{f_i}{capacity (upper bound) of box $i$}
\var{T}{subset of indices violating the upper bound}
\var{b(T)}{adjusted remainder $s-\sum_{i\in T}(f_i+1)$}
\varmapEnd
\GOVERN{
\[
\text{Ans}=\sum_{T \subseteq [n]} (-1)^{|T|}\, \binom{b(T)+n-1}{n-1},\qquad
\binom{m}{k}=\begin{cases}
\dfrac{m(m-1)\cdots(m-k+1)}{k!}, & m\ge k\ge 0,\\[4pt]
0, & \text{otherwise.}
\end{cases}
\]
}
\ASSUMPTIONS{All $f_i,s$ are integers; $n$ is small. Arithmetic is mod $10^9+7$ (a prime). For $k=n-1<10^9+7$, $k!$ is invertible modulo the prime, so the binomial via falling factorial over $k!$ is valid for large $m$.}
\INVARIANTS{For any $T$, $b(T)$ decreases monotonically as $T$ grows. Terms with $b(T)<0$ contribute $0$. The inclusion–exclusion alternates signs by $|T|$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Coefficient extraction of the generating function $\prod_{i=1}^n \left(1+x+\cdots+x^{f_i}\right)$ at $x^s$ using DP.}
\ASSUMPTIONS{Feasible only for small $s$; demonstrates correctness but not scalable to $s\approx 10^{14}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dp[0]=1$, others $0$ for indices $0\ldots s$.
\item For each $i=1\ldots n$, update with bounded knapsack transition using prefix sums to respect $x_i \le f_i$.
\item Answer is $dp[s] \bmod 10^9+7$.
\end{algosteps}
\COMPLEXITY{For general $s$:
\[
\begin{aligned}
T(n,s) &= \Theta\!\big(n\cdot s\big) \quad (\text{with prefix-sum optimization}) \\
S(s) &= \Theta(s).
\end{aligned}
\]
}
\CORRECTNESS{Standard DP counts ways to allocate $t$ flowers among first $i$ boxes with capacity bounds; the transition sums over all admissible picks for the $i$-th box.}
\EDGECASES{$s=0$ (only the all-zero selection), any $f_i=0$, and $n=1$ reduce to simple counts.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
import sys

MOD = 1_000_000_007

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); s = int(next(it))
    except StopIteration:
        return None
    f = [int(next(it)) for _ in range(n)]
    return n, s, f

def solve_case_baseline(n: int, s: int, f):
    # DP by bounded knapsack; only for small s (demonstration)
    dp = [0] * (s + 1)
    dp[0] = 1
    for cap in f:
        ndp = [0] * (s + 1)
        # prefix sums for O(1) range sum per t
        pref = [0] * (s + 2)
        for t in range(s + 1):
            pref[t + 1] = (pref[t] + dp[t]) % MOD
        for t in range(s + 1):
            lo = max(0, t - cap)
            hi = t
            ndp[t] = (pref[hi + 1] - pref[lo]) % MOD
        dp = ndp
    return dp[s] % MOD

def solve_all_baseline(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, s, f = parsed
    # Guard against huge s in baseline; cap for demo, else fallback trivial
    if s > 200000:
        # Not feasible; return -1 to indicate "too big" in baseline demo
        return "-1"
    return str(solve_case_baseline(n, s, f))

def main():
    data = sys.stdin.read()
    out = solve_all_baseline(data)
    if out != "":
        print(out)

if __name__ == "__main__":
    # Tiny asserts (baseline correctness on small inputs)
    assert solve_all_baseline("2 3\n1 3\n") == "2"  # {1,2}, {0,3}
    assert solve_all_baseline("2 4\n2 2\n") == "1"  # {2,2}
    assert solve_all_baseline("3 5\n1 3 2\n") == "3"  # {1,2,2}, {0,3,2}, {1,3,1}
    # Do not run main() in tests
    pass
\end{minted}
\VALIDATION{Checked on small crafted cases; baseline returns expected counts where $s$ is small.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Inclusion–Exclusion + Small-$k$ Binomial}
\WHICHFORMULA{Use inclusion–exclusion over violating boxes and compute each term $\binom{m}{k}$ with $k=n-1\le 19$ via falling factorial divided by $k!$ modulo a prime.}
\ASSUMPTIONS{$n \le 20$ so $2^n$ subsets are feasible; $k<n\ll 10^9+7$ so $k!$ is invertible modulo $10^9+7$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Let $k=n-1$ and precompute $\text{inv\_fact}[k]=(k!)^{-1}\bmod p$.
\item For each subset $T\subseteq [n]$:
  compute $b=s-\sum_{i\in T}(f_i+1)$.
\item If $b\ge 0$, add $(-1)^{|T|}\cdot \binom{b+n-1}{k}$ using
$\binom{M}{k}=\prod_{j=0}^{k-1}(M-j)\cdot \text{inv\_fact}[k]\bmod p$.
\end{algosteps}
\COMPLEXITY{Dominated by $2^n$ subsets and $O(k)$ per binomial:
\begin{BreakableEquation*}
T(n)=\Theta(2^n\cdot n),\quad S(n)=\Theta(1).
\end{BreakableEquation*}
}
\CORRECTNESS{Classical inclusion–exclusion: for any $T$, shift $x_i'=x_i-(f_i+1)$ for $i\in T$; this enforces the violation and reduces to counting nonnegative solutions summing to $b$. Alternating signs ensure overcount corrections. Falling-factorial identity matches binomial over integers, and modulo a prime with $k<p$ is valid.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
import sys

MOD = 1_000_000_007

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); s = int(next(it))
    except StopIteration:
        return None
    f = [int(next(it)) for _ in range(n)]
    return n, s, f

def inv_mod(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def inv_fact_k(k: int) -> int:
    fact = 1
    for i in range(2, k + 1):
        fact = (fact * i) % MOD
    return inv_mod(fact)

def nCr_large_m_small_k(m: int, k: int, invfact_k: int) -> int:
    if k < 0 or m < 0 or m < k:
        return 0
    num = 1
    # Compute m * (m-1) * ... * (m-k+1) mod MOD
    # Reduce each term modulo MOD safely.
    for j in range(k):
        num = (num * ((m - j) % MOD)) % MOD
    return (num * invfact_k) % MOD

def solve_case_ie(n: int, s: int, f):
    k = n - 1
    invfact_k = inv_fact_k(k)
    ans = 0
    Nmask = 1 << n
    for mask in range(Nmask):
        bits = mask.bit_count()
        sum_take = 0
        t = mask
        idx = 0
        # Compute sum_{i in T} (f_i + 1)
        while t:
            if t & 1:
                sum_take += f[idx] + 1
            idx += 1
            t >>= 1
        # Handle remaining indices (when t becomes 0 but idx < n)
        while idx < n:
            if (mask >> idx) & 1:
                sum_take += f[idx] + 1
            idx += 1
        b = s - sum_take
        if b >= 0:
            m = b + n - 1
            term = nCr_large_m_small_k(m, k, invfact_k)
            if bits & 1:
                ans = (ans - term) % MOD
            else:
                ans = (ans + term) % MOD
    return ans % MOD

def solve_all_ie(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, s, f = parsed
    return str(solve_case_ie(n, s, f))

def main():
    data = sys.stdin.read()
    out = solve_all_ie(data)
    if out != "":
        print(out)

if __name__ == "__main__":
    # Asserts on tiny inputs
    assert solve_all_ie("2 3\n1 3\n") == "2"
    assert solve_all_ie("2 4\n2 2\n") == "1"
    assert solve_all_ie("3 5\n1 3 2\n") == "3"
    pass
\end{minted}
\VALIDATION{Verified on examples; handles large $s$ because binomial uses only $k\le 19$ multiplicative steps per subset.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Inclusion–Exclusion with Precomputed Subset Sums}
\WHICHFORMULA{Same inclusion–exclusion as Approach B, but precompute all subset sums of $(f_i+1)$ to avoid repeated per-bit scans; compute $\binom{m}{n-1}$ using $O(n)$ multiplicative steps.}
\ASSUMPTIONS{$n\le 20$ so $2^n$ subset-sum precomputation is fast.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute $g[\text{mask}]=\sum_{i\in \text{mask}} (f_i+1)$ for all masks using DP: $g[0]=0$, and $g[\text{mask}]=g[\text{mask}\setminus\{\text{lsb}\}]+(f_{\text{lsb}}+1)$.
\item Precompute $\text{inv\_fact}[n-1]$ modulo $p=10^9+7$.
\item For each mask, let $b=s-g[\text{mask}]$. If $b\ge 0$, accumulate $(-1)^{\text{popcount(mask)}}\cdot \binom{b+n-1}{n-1}$ via falling factorial.
\end{algosteps}
\OPTIMALITY{Given $n\le 20$, the $2^n$ barrier is information-theoretic for inclusion–exclusion. Each binomial needs only $O(n)$ work; any asymptotically faster exact method over arbitrary $f_i$ is unlikely.}
\COMPLEXITY{Precompute subset sums in $\Theta(2^n)$. Then
\[
\begin{aligned}
T(n) &= \Theta(2^n + 2^n\cdot n) = \Theta(2^n n),\\
S(n) &= \Theta(2^n).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
import sys

MOD = 1_000_000_007

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); s = int(next(it))
    except StopIteration:
        return None
    f = [int(next(it)) for _ in range(n)]
    return n, s, f

def inv_mod(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def inv_fact_k(k: int) -> int:
    fact = 1
    for i in range(2, k + 1):
        fact = (fact * i) % MOD
    return inv_mod(fact)

def nCr_large_m_small_k(m: int, k: int, invfact_k: int) -> int:
    if k < 0 or m < 0 or m < k:
        return 0
    num = 1
    for j in range(k):
        num = (num * ((m - j) % MOD)) % MOD
    return (num * invfact_k) % MOD

def solve_case(n: int, s: int, f):
    k = n - 1
    invfact_k = inv_fact_k(k)
    # Precompute subset sums of (f_i + 1)
    add = [fi + 1 for fi in f]
    Nmask = 1 << n
    subsum = [0] * Nmask
    for mask in range(1, Nmask):
        lsb = mask & -mask
        idx = (lsb.bit_length() - 1)
        subsum[mask] = subsum[mask ^ lsb] + add[idx]
    ans = 0
    for mask in range(Nmask):
        b = s - subsum[mask]
        if b >= 0:
            m = b + n - 1
            term = nCr_large_m_small_k(m, k, invfact_k)
            if (mask.bit_count() & 1) == 1:
                ans = (ans - term) % MOD
            else:
                ans = (ans + term) % MOD
    return ans % MOD

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, s, f = parsed
    return str(solve_case(n, s, f))

def main():
    data = sys.stdin.read()
    out = solve_all(data)
    if out != "":
        print(out)

if __name__ == "__main__":
    # Exactly 3 asserts
    assert solve_all("2 3\n1 3\n") == "2"
    assert solve_all("2 4\n2 2\n") == "1"
    assert solve_all("3 5\n1 3 2\n") == "3"
    # main guarded; not auto-executed in tests
    pass
\end{minted}
\VALIDATION{Asserts pass for the given small examples. Additionally, trivial checks: if $s=0$ then answer is $1$ if and only if all $x_i=0$ is valid, which the formula yields by $\binom{n-1}{n-1}=1$ for the empty subset and all other subsets produce $\binom{<n-1}{n-1}=0$.}
\RESULT{Print a single integer: the number of admissible selections modulo $10^9+7$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on tiny instances; random small $n\le 6$, $s\le 20$ cross-check DP (Approach A) vs inclusion–exclusion (Approach C). Edge cases: $s=0$, all $f_i=0$, some $f_i=0$, $n=1$, and large $f_i$ relative to $s$.}
\LINE{CROSS-CHECKS}{On small ranges, compare outputs from baseline DP and final IE; they must match modulo $10^9+7$.}
\LINE{EDGE-CASE GENERATOR}{Generate random arrays $f$ with zeros and large caps, and random $s$ near $0$, near $\sum f_i$, and beyond $\sum f_i$ (which should yield $0$).}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

MOD = 1_000_000_007

def gen_cases(seed=0):
    random.seed(seed)
    cases = []
    # Edge: s=0
    cases.append((3, 0, [5, 0, 7]))
    # Edge: all zeros
    cases.append((4, 0, [0, 0, 0, 0]))
    # n=1
    cases.append((1, 5, [3]))
    # Random small cross-checks
    for _ in range(10):
        n = random.randint(1, 6)
        f = [random.randint(0, 7) for _ in range(n)]
        s = random.randint(0, 20)
        cases.append((n, s, f))
    return cases

def dp_count(n, s, f):
    dp = [0] * (s + 1)
    dp[0] = 1
    for cap in f:
        ndp = [0] * (s + 1)
        pref = [0] * (s + 2)
        for t in range(s + 1):
            pref[t + 1] = (pref[t] + dp[t]) % MOD
        for t in range(s + 1):
            lo = max(0, t - cap)
            ndp[t] = (pref[t + 1] - pref[lo]) % MOD
        dp = ndp
    return dp[s] % MOD

def ie_count(n, s, f):
    # Final method
    def inv_mod(a): return pow(a, MOD - 2, MOD)
    k = n - 1
    fact = 1
    for i in range(2, k + 1):
        fact = (fact * i) % MOD
    invfact_k = inv_mod(fact)
    add = [fi + 1 for fi in f]
    Nmask = 1 << n
    subsum = [0] * Nmask
    for mask in range(1, Nmask):
        lsb = mask & -mask
        idx = (lsb.bit_length() - 1)
        subsum[mask] = subsum[mask ^ lsb] + add[idx]
    ans = 0
    for mask in range(Nmask):
        b = s - subsum[mask]
        if b >= 0:
            m = b + n - 1
            # nCr with small k
            if m < k:
                term = 0
            else:
                num = 1
                for j in range(k):
                    num = (num * ((m - j) % MOD)) % MOD
                term = (num * invfact_k) % MOD
            if (mask.bit_count() & 1) == 1:
                ans = (ans - term) % MOD
            else:
                ans = (ans + term) % MOD
    return ans % MOD

def run_cross_checks():
    for (n, s, f) in gen_cases(42):
        # Only compare when s is small enough for DP
        if s <= 200:
            a = dp_count(n, s, f)
            b = ie_count(n, s, f)
            assert a == b, (n, s, f, a, b)

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
import sys

MOD = 1_000_000_007

def read_input(data: str):
    it = iter(data.strip().split())
    try:
        n = int(next(it)); s = int(next(it))
    except StopIteration:
        return None
    f = [int(next(it)) for _ in range(n)]
    return n, s, f

def inv_mod(a: int) -> int:
    return pow(a, MOD - 2, MOD)

def inv_fact_k(k: int) -> int:
    fact = 1
    for i in range(2, k + 1):
        fact = (fact * i) % MOD
    return inv_mod(fact)

def nCr_large_m_small_k(m: int, k: int, invfact_k: int) -> int:
    if k < 0 or m < 0 or m < k:
        return 0
    num = 1
    for j in range(k):
        num = (num * ((m - j) % MOD)) % MOD
    return (num * invfact_k) % MOD

def solve_case(n: int, s: int, f):
    k = n - 1
    invfact_k = inv_fact_k(k)
    add = [fi + 1 for fi in f]
    Nmask = 1 << n
    subsum = [0] * Nmask
    for mask in range(1, Nmask):
        lsb = mask & -mask
        idx = (lsb.bit_length() - 1)
        subsum[mask] = subsum[mask ^ lsb] + add[idx]
    ans = 0
    for mask in range(Nmask):
        b = s - subsum[mask]
        if b >= 0:
            m = b + n - 1
            term = nCr_large_m_small_k(m, k, invfact_k)
            if (mask.bit_count() & 1) == 1:
                ans = (ans - term) % MOD
            else:
                ans = (ans + term) % MOD
    return ans % MOD

def solve_all(data: str) -> str:
    parsed = read_input(data)
    if parsed is None:
        return ""
    n, s, f = parsed
    return str(solve_case(n, s, f))

def main():
    out = solve_all(sys.stdin.read())
    if out != "":
        print(out)

if __name__ == "__main__":
    # Sanity asserts
    assert solve_all("2 3\n1 3\n") == "2"
    assert solve_all("2 4\n2 2\n") == "1"
    assert solve_all("3 5\n1 3 2\n") == "3"
    # main guarded
    pass
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count bounded compositions using inclusion–exclusion and small-$k$ binomials modulo a prime.}
\WHY{A classic pattern: big target sum $s$ with small dimension $n$ favors inclusion–exclusion or generating functions over DP on $s$.}
\CHECKLIST{
- Write the inclusion–exclusion formula.
- Precompute subset sums of $f_i+1$.
- Compute $\binom{m}{n-1}$ via falling factorial times $(n-1)!^{-1}$.
- Accumulate alternating signs modulo $10^9+7$.
- Handle $m<0$ or $m<n-1$ as zero.
}
\EDGECASES{
- $s=0$.
- Some or all $f_i=0$.
- $n=1$ (answer is $[s \le f_1]$).
- $\sum f_i < s$ (answer $0$).
- Very large $s$ and $f_i$ (ensure no overflow; Python ints are unbounded).
- Terms where $m \equiv 0 \pmod{p}$ inside the product (naturally handled).
}
\PITFALLS{
- Forgetting that $\binom{m}{k}=0$ when $m<k$.
- Using DP on $s$ (TLE for large $s$).
- Incorrectly treating $k!$ modulo $p$ when $k\ge p$ (here $k\le 19$).
- Missing the $+n-1$ shift in stars-and-bars.
- Not alternating signs by subset parity.
- Recomputing subset sums in $O(n)$ inside the loop (optimize with precompute).
}
\FAILMODES{Brute-force or DP in $s$ fails for $s\approx 10^{14}$. The proposed method runs in $\Theta(2^n n)$ independent of $s$ magnitude.}
\ELI{Think of sharing $s$ candies among $n$ kids with each kid having a personal cap. Count all ways to share without caps, then subtract the ways where some kid exceeds their cap, carefully adding back overlaps. Since the number of kids is small, trying all groups that break the rules is fast.}
\NotePages{3}

\end{document}