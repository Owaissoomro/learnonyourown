% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — K-th Smallest in Lexicographical Order}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given two integers $n$ and $k$, return the $k$-th lexicographically smallest integer in the range $[1, n]$.

Example 1:

Input: $n = 13$, $k = 2$

Output: $10$

Explanation: The lexicographical order is $[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]$, so the second smallest number is $10$.

Example 2:

Input: $n = 1$, $k = 1$

Output: $1$

Constraints:
\begin{itemize}
\item $1 \le k \le n \le 10^9$.
\end{itemize}}
\BREAKDOWN{We must index the lexicographic ordering of integers $1$ through $n$ without materializing all of them. The core subproblem is: given a decimal prefix $p$, how many integers in $[1,n]$ start with $p$? With this, we can jump between subtrees of a conceptual lexicographic trie.}
\ELI{Walk the numbers as if browsing a dictionary; count how many words under a prefix to skip whole sections quickly.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers: $n$ and $k$ with $1 \le k \le n \le 10^9$.}
\OUTPUTS{Return a single integer: the $k$-th smallest number in lexicographic order among $\{1,2,\ldots,n\}$.}
\SAMPLES{
Example A: $n=13$, $k=2 \Rightarrow 10$.

Example B: $n=1$, $k=1 \Rightarrow 1$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $\mathcal{S}=\{1,2,\ldots,n\}$ and define a total order $\prec$ such that $a \prec b$ iff $\mathrm{str}(a)$ precedes $\mathrm{str}(b)$ in lexicographic order over digits. We seek $x \in \mathcal{S}$ with $\left|\{y \in \mathcal{S}: y \prec x\}\right| = k-1$.}
\varmapStart
\var{n}{the inclusive upper bound of the range}
\var{k}{1-indexed rank in lexicographic order}
\var{p}{a decimal prefix (node) in the implicit 10-ary trie}
\var{\mathrm{steps}(a,b)}{count of integers in $[1,n]$ that lie in $[a,b)$ in lexicographic prefix space}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\mathrm{steps}(a,b) \;=\; \sum_{t=0}^{\infty} \max\!\bigl(0,\, \min(n+1,\, b\cdot 10^{t}) - a\cdot 10^{t}\bigr),
\end{BreakableEquation*}
where the sum stops once $a\cdot 10^{t} > n$.
}
\ASSUMPTIONS{Lexicographic order is defined over the usual base-10 string representations without leading zeros. The implicit trie has children $p\cdot 10 + d$ for $d \in \{0,\ldots,9\}$, except the root uses digits $1$ to $9$ to avoid leading zeros.}
\INVARIANTS{
\begin{itemize}
\item For any prefix interval $[a,b)$, $\mathrm{steps}(a,b)$ equals the number of integers in $[1,n]$ whose string begins with a string in $[a,b)$.
\item Moving from prefix $a$ to $a+1$ skips exactly $\mathrm{steps}(a,a+1)$ lexicographic positions.
\item Descending from $a$ to $10a$ advances by one position (to $a$ itself) and remains within the subtree rooted at $a$.
\end{itemize}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Sort all integers $1..n$ by their string keys and pick index $k-1$. This matches the definition directly.}
\ASSUMPTIONS{Feasible only for small $n$ due to $O(n \log n)$ time and $O(n)$ memory.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build array $A=[1,2,\ldots,n]$.
\item Sort $A$ with key $\mathrm{str}(\cdot)$.
\item Return $A[k-1]$.
\end{algosteps}
\COMPLEXITY{$T(n)=O(n \log n)$ comparisons with string-key overhead; $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &= O(n \log n) \quad\text{(comparison sort with string keys)}.
\end{aligned}
\]
\CORRECTNESS{Sorting by string key induces the target lexicographic order; indexing at $k-1$ yields the $k$-th element by definition.}
\EDGECASES{When $k=1$ the answer is the lexicographically smallest number (always $1$). Large $n$ makes this approach impractical but still correct.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# LeetCode 440: K-th Smallest in Lexicographical Order
# Baseline: sort all numbers by string and index.
from typing import *

class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        arr = list(range(1, n + 1))
        arr.sort(key=str)
        return arr[k - 1]

# Basic asserts (small n only; baseline is O(n log n))
if __name__ == "__main__":
    s = Solution()
    assert s.findKthNumber(13, 2) == 10
    assert s.findKthNumber(1, 1) == 1
    # Additional tiny checks
    assert s.findKthNumber(20, 1) == 1
    # For n=20, lex order starts: 1,10,11,12,13,14,15,16,17,18,19,2,20,3,4,5,6,7,8,9
    assert s.findKthNumber(20, 12) == 2
\end{minted}
\VALIDATION{Cross-check a few hand-derivable sequences; avoid large $n$ for this baseline.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{On-the-fly DFS Enumeration (Pruning by Prefix)}
\WHICHFORMULA{Generate numbers in lexicographic order by DFS on the implicit 10-ary trie and stop once the $k$-th number is reached. Avoids sorting the entire list.}
\ASSUMPTIONS{Depth is bounded by $\lfloor \log_{10} n \rfloor + 1$. Worst-case still $O(k)$ visits.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Define a generator that, given a prefix $p$, yields $p$ then recurses on $10p,10p+1,\ldots,10p+9$ while $\le n$.
\item Seed with prefixes $1$ to $9$.
\item Count yielded numbers until reaching the $k$-th; return it.
\end{algosteps}
\COMPLEXITY{Visits exactly $k$ nodes in typical early stop; worst case $O(n)$. Memory $O(\log n)$ recursion depth (or $O(\log n)$ stack if iterative).}
\[
\begin{aligned}
T(n) &= O(k) \text{ \ (early-stop after $k$ yields; in worst case } O(n)\text{)},\\
S(n) &= O(\log n).
\end{aligned}
\]
\CORRECTNESS{The DFS preorder over the lexicographic trie yields numbers in lexicographic order because parents precede their descendants and siblings are visited in increasing digit order. Stopping after $k$ yields the $k$-th element.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import *

class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        # Iterative DFS to avoid recursion limits; yields lexicographic order
        def next_lex(curr: int) -> int:
            # Advance to next number in lexicographic order within [1, n]
            if curr * 10 <= n:
                return curr * 10
            while curr % 10 == 9 or curr + 1 > n:
                curr //= 10
            return curr + 1

        # Enumerate starting from 1, step to next lex order k-1 times.
        curr = 1
        # If n >= 1, the first element is 1
        k -= 1
        while k > 0:
            # compute next lex number without counting subtree sizes
            if curr * 10 <= n:
                curr *= 10
                k -= 1
            else:
                if curr + 1 <= n and (curr % 10) != 9:
                    curr += 1
                    k -= 1
                else:
                    # climb up until we can increment
                    while curr % 10 == 9 or curr + 1 > n:
                        curr //= 10
                    curr += 1
                    k -= 1
        return curr

if __name__ == "__main__":
    s = Solution()
    assert s.findKthNumber(13, 2) == 10
    assert s.findKthNumber(1, 1) == 1
    assert s.findKthNumber(20, 12) == 2
\end{minted}
\VALIDATION{Matches baseline on small $n$ and sample cases; handles transitions across sibling and ancestor prefixes correctly.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Prefix-Count Jumps in the Lexicographic Trie}
\WHICHFORMULA{Use $\mathrm{steps}(a,b)$ to count how many numbers belong to the subtree roots in $[a,b)$ and jump entire subtrees when possible. This is the classic solution.}
\ASSUMPTIONS{Decimal digits; no leading zeros; $n \le 10^9$ implies at most $10$ levels deep.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $curr\leftarrow 1$ and decrement $k\leftarrow k-1$ (the first number is $1$).
\item While $k>0$:
\begin{itemize}
\item Compute $s=\mathrm{steps}(curr,curr+1)$.
\item If $s \le k$, set $curr\leftarrow curr+1$ and $k\leftarrow k-s$ (skip this whole subtree).
\item Else set $curr\leftarrow 10\cdot curr$ and $k\leftarrow k-1$ (descend into subtree, counting $curr$ itself).
\end{itemize}
\item Return $curr$.
\end{algosteps}
\OPTIMALITY{Each loop either skips an entire subtree in one shot or goes one level deeper. The number of digit levels is $O(\log_{10} n)$, and subtree skips are bounded similarly, yielding near $O((\log n)^2)$ arithmetic operations with tiny constants.}
\COMPLEXITY{Each $\mathrm{steps}$ computation scans digit levels:
\[
\begin{aligned}
T(n) &\approx O\bigl((\log_{10} n)\cdot \text{iterations}\bigr) \le O\bigl((\log_{10} n)^2\bigr),\\
S(n) &= O(1).
\end{aligned}
\]
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import *

class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        def steps(a: int, b: int, n: int) -> int:
            # Count how many values x in [1..n] satisfy prefix in [a, b)
            s = 0
            while a <= n:
                s += max(0, min(n + 1, b) - a)
                a *= 10
                b *= 10
            return s

        curr = 1
        k -= 1  # the first number is 1
        while k > 0:
            s = steps(curr, curr + 1, n)
            if s <= k:
                curr += 1
                k -= s
            else:
                curr *= 10
                k -= 1
        return curr

if __name__ == "__main__":
    s = Solution()
    # Exactly 3 asserts
    assert s.findKthNumber(13, 2) == 10
    assert s.findKthNumber(1, 1) == 1
    # Additional non-trivial check
    assert s.findKthNumber(100, 90) == 9
\end{minted}
\VALIDATION{Three asserts cover samples and a deeper traversal case ($n=100,k=90 \Rightarrow 9$ as the tree skips many subtrees).}
\RESULT{Returns the unique integer in $[1,n]$ that appears in position $k$ under lexicographic order by decimal representation.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests over small ranges compare the optimal solution against the baseline sorter. Target boundary cases: $k=1$, $k=n$, powers of $10$ for $n$, and transitions across siblings/ancestors.}
\LINE{CROSS-CHECKS}{For $n \le 2000$, randomly sample $(n,k)$ and verify the optimal result equals the brute-force sorted result.}
\LINE{EDGE-CASE GENERATOR}{Generate cases with $n$ in $\{1,9,10,11,19,20,99,100,101,999,1000\}$ and $k \in \{1,2,9,10,n-1,n\}$.}
\begin{minted}{python}
from typing import *
import random

def brute(n: int, k: int) -> int:
    arr = list(range(1, n + 1))
    arr.sort(key=str)
    return arr[k - 1]

class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        def steps(a: int, b: int, n: int) -> int:
            s = 0
            while a <= n:
                s += max(0, min(n + 1, b) - a)
                a *= 10
                b *= 10
            return s
        curr = 1
        k -= 1
        while k > 0:
            s = steps(curr, curr + 1, n)
            if s <= k:
                curr += 1
                k -= s
            else:
                curr *= 10
                k -= 1
        return curr

if __name__ == "__main__":
    # Deterministic coverage
    seeds = [(13,2),(1,1),(20,12),(99,50),(100,90),(1000,1),(1000,1000)]
    sol = Solution()
    for n,k in seeds:
        assert sol.findKthNumber(n,k) == brute(n,k)
    # Random cross-checks on manageable sizes
    random.seed(0)
    for _ in range(200):
        n = random.randint(1, 2000)
        k = random.randint(1, n)
        assert sol.findKthNumber(n,k) == brute(n,k)
    print("All tests passed.")
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import *

class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        # Count how many integers in [1..n] lie within the lexicographic interval [a, b)
        def steps(a: int, b: int, n: int) -> int:
            s = 0
            while a <= n:
                s += max(0, min(n + 1, b) - a)
                a *= 10
                b *= 10
            return s

        curr = 1
        k -= 1  # first element is 1
        while k > 0:
            s = steps(curr, curr + 1, n)
            if s <= k:
                curr += 1
                k -= s
            else:
                curr *= 10
                k -= 1
        return curr

if __name__ == "__main__":
    s = Solution()
    assert s.findKthNumber(13, 2) == 10
    assert s.findKthNumber(1, 1) == 1
    assert s.findKthNumber(100, 90) == 9
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute the $k$-th lexicographic integer in $[1,n]$ by jumping among prefix subtrees using a digit-level step counter.}
\WHY{Tests trie-style reasoning and counting under prefixes, common in string and number lex-order problems; appears in senior interviews.}
\CHECKLIST{
\begin{itemize}
\item Define and verify $\mathrm{steps}(a,b)$ correctly with clamping to $n+1$.
\item Initialize $curr=1$, then loop while $k>0$.
\item If $\mathrm{steps}(curr,curr+1) \le k$ then skip subtree: $curr\leftarrow curr+1$, $k\leftarrow k-s$.
\item Else descend: $curr\leftarrow 10\cdot curr$, $k\leftarrow k-1$.
\item Handle bounds when $curr$ ends with $9$ or when $curr+1>n$ only in non-opt variants.
\end{itemize}}
\EDGECASES{
\begin{itemize}
\item $n=1$, $k=1$.
\item $n=9$ and $n=10$ boundary.
\item Large $n$ like $10^9$ with $k=1$ or $k=n$.
\item Prefix just exceeding $n$ when multiplying by $10$ in $\mathrm{steps}$.
\item Siblings transition where $curr$ ends with $9$ (relevant in DFS variant).
\item Deep chains of zeros inside a subtree, e.g., $1000$.
\end{itemize}}
\PITFALLS{
\begin{itemize}
\item Off-by-one in clamping: use $n+1$ in $\min(n+1, b)$.
\item Forgetting to decrement $k$ when descending into a subtree.
\item Miscounting when $a>b$ or not stopping when $a>n$ in $\mathrm{steps}$.
\item Treating lex order as numeric order; it is string order.
\item Using recursion without guarding stack depth in Python for DFS approach.
\item Sorting all numbers for large $n$ causing memory/time blowups.
\end{itemize}}
\FAILMODES{Baseline sort fails on performance for $n$ near $10^9$. DFS improved still $O(k)$ and can be slow when $k\approx n$. Prefix-count jumping remains fast due to subtree skips.}
\ELI{Think of numbers as words in a dictionary. To find the $k$-th word, either skip a whole section if it has fewer than $k$ words, or open that section and go deeper by one digit.}
\NotePages{3}

\end{document}