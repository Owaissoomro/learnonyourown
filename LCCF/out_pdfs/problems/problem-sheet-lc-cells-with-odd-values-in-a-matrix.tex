% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cells with Odd Values in a Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/}}
\LINE{DIFFICULTY / RATING}{easy}
\STATEMENT{There is an $m \times n$ matrix that is initialized to all $0$'s. There is also a 2D array \texttt{indices} where each \texttt{indices[i] = [r\_i, c\_i]} represents a 0-indexed location to perform increment operations on the matrix.

For each location \texttt{indices[i]}, do both of the following:
\begin{enumerate}[nosep,leftmargin=2em]
\item Increment all the cells on row $r_i$.
\item Increment all the cells on column $c_i$.
\end{enumerate}

Given $m$, $n$, and \texttt{indices}, return the number of odd-valued cells in the matrix after applying the increment to all locations in \texttt{indices}.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{m = 2, n = 3, indices = [[0,1],[1,1]]}

\quad \textbf{Output:} \texttt{6}

\quad \textbf{Explanation:} Initial matrix $=[[0,0,0],[0,0,0]]$. After applying first increment it becomes $[[1,2,1],[0,1,0]]$. The final matrix is $[[1,3,1],[1,3,1]]$, which contains 6 odd numbers.

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{m = 2, n = 2, indices = [[1,1],[0,0]]}

\quad \textbf{Output:} \texttt{0}

\quad \textbf{Explanation:} Final matrix is $[[2,2],[2,2]]$. There are no odd numbers.

\textbf{Constraints:}
\begin{itemize}[nosep,leftmargin=2em]
\item $1 \le m, n \le 50$
\item $1 \le \lvert \text{indices} \rvert \le 100$
\item $0 \le r_i < m$
\item $0 \le c_i < n$
\end{itemize}

\textbf{Follow up:} Could you solve this in $O(n + m + \lvert \text{indices} \rvert)$ time with only $O(n + m)$ extra space?}
\BREAKDOWN{Simulate row and column increments, but avoid touching every cell per operation by tracking parity for rows and columns. Derive a closed-form count of odd cells from counts of odd rows and odd columns.}
\ELI{A cell ends up odd if it was incremented an odd number of times, which happens exactly when its row parity and column parity differ.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{LeetCode function signature (Python): \texttt{def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int}. Here $m, n$ are positive integers, and \texttt{indices} is a list of pairs $[r_i, c_i]$ with $0 \le r_i < m$, $0 \le c_i < n$.}
\OUTPUTS{Return a single integer: the number of cells with odd values after applying all increments.}
\SAMPLES{
\begin{itemize}
\item Input: \texttt{m = 2, n = 3, indices = [[0,1],[1,1]]} $\rightarrow$ Output: \texttt{6}.
\item Input: \texttt{m = 2, n = 2, indices = [[1,1],[0,0]]} $\rightarrow$ Output: \texttt{0}.
\end{itemize}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $R \in \{0,1\}^m$ and $C \in \{0,1\}^n$ track the parity (odd$=1$, even$=0$) of increments applied to each row and column, respectively. For each pair $(r_i,c_i)$ in \texttt{indices}, toggle $R_{r_i}$ and $C_{c_i}$. A cell $(r,c)$ is odd iff $R_r \oplus C_c = 1$.}
\varmapStart
\var{m,n}{matrix dimensions (rows, columns)}
\var{k}{number of operations, $k=\lvert \text{indices} \rvert$}
\var{R_r}{parity of row $r$ after all operations}
\var{C_c}{parity of column $c$ after all operations}
\var{r_{\text{odd}}}{number of rows with $R_r=1$}
\var{c_{\text{odd}}}{number of columns with $C_c=1$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{odd\_cells} \;=\; r_{\text{odd}} \cdot (n - c_{\text{odd}}) \;+\; (m - r_{\text{odd}}) \cdot c_{\text{odd}}.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are valid; operations may repeat on the same row/column; parity toggling is independent across rows and columns.}
\INVARIANTS{
\begin{itemize}
\item Parity invariant: Applying an operation twice to the same row or column restores its original parity.
\item Independence: For any cell $(r,c)$, total increments equal $R_r + C_c$; only parity matters for odd/even.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly mutate the matrix: for each pair $(r_i,c_i)$, increment all $n$ entries in row $r_i$ and all $m$ entries in column $c_i$, then count odd entries.}
\ASSUMPTIONS{Small constraints make an $O(k(m+n))$ update plus $O(mn)$ scan feasible.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize matrix $A$ of size $m \times n$ with zeros.
\item For each $(r,c)$ in \texttt{indices}: increment all cells in row $r$; increment all cells in column $c$.
\item Count and return the number of entries in $A$ that are odd.
\end{algosteps}
\COMPLEXITY{Let $k=\lvert \text{indices} \rvert$. Each update touches $n$ cells in a row and $m$ cells in a column; counting odds scans all $mn$ cells.}
\[
\begin{aligned}
T(m,n,k) &= k\,(m+n) + mn, \\
S(m,n,k) &= mn \quad \text{for the explicit matrix.}
\end{aligned}
\]
\CORRECTNESS{Every operation is applied exactly as specified; final odd count is computed by definition.}
\EDGECASES{Repeated operations on the same row/column; $m=1$ or $n=1$; $k=1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        A = [[0] * n for _ in range(m)]
        for r, c in indices:
            # increment row r
            for j in range(n):
                A[r][j] += 1
            # increment column c
            for i in range(m):
                A[i][c] += 1
        # count odds
        return sum((A[i][j] & 1) for i in range(m) for j in range(n))

# basic asserts
sol = Solution()
assert sol.oddCells(2, 3, [[0, 1], [1, 1]]) == 6
assert sol.oddCells(2, 2, [[1, 1], [0, 0]]) == 0
# small extra check
assert sol.oddCells(1, 1, [[0, 0]]) == 1
\end{minted}
\VALIDATION{Manually checked the two provided examples and a single-cell case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Parity Tracking and Closed Form}
\WHICHFORMULA{Track parity for rows and columns separately; a cell is odd iff its row and column parities differ. Count odd rows and odd columns, then use the closed-form.}
\ASSUMPTIONS{Only parity matters for odd/even; use boolean arrays to track toggles.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize boolean arrays \texttt{row[m]} and \texttt{col[n]} to \texttt{False}.
\item For each $(r,c)$ in \texttt{indices}: toggle \texttt{row[r]} and \texttt{col[c]}.
\item Let $r_{\text{odd}}=\#\{\texttt{row[r]}=\texttt{True}\}$ and $c_{\text{odd}}=\#\{\texttt{col[c]}=\texttt{True}\}$; return $r_{\text{odd}}(n-c_{\text{odd}})+(m-r_{\text{odd}})c_{\text{odd}}$.
\end{algosteps}
\COMPLEXITY{Processing toggles is $O(k)$; counting parities is $O(m+n)$; no $mn$ term.}
\[
\begin{aligned}
T(m,n,k) &= O(k + m + n), \\
S(m,n,k) &= O(m + n).
\end{aligned}
\]
\CORRECTNESS{For each cell $(r,c)$, total increments parity equals $R_r \oplus C_c$. The count formula partitions cells by row/column parity.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        row = [False] * m
        col = [False] * n
        for r, c in indices:
            row[r] ^= True
            col[c] ^= True
        r_odd = sum(row)
        c_odd = sum(col)
        return r_odd * (n - c_odd) + (m - r_odd) * c_odd

# asserts (same API/signature)
sol = Solution()
assert sol.oddCells(2, 3, [[0, 1], [1, 1]]) == 6
assert sol.oddCells(2, 2, [[1, 1], [0, 0]]) == 0
# edge: repeated toggles cancel
assert sol.oddCells(3, 3, [[1, 2], [1, 2]]) == 0
\end{minted}
\VALIDATION{Checked repeated toggles cancel; verified on provided samples.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{One-Pass Parity Counts with On-the-fly Totals}
\WHICHFORMULA{Maintain parity arrays and the running counts $r_{\text{odd}}$ and $c_{\text{odd}}$ while processing \texttt{indices}, then apply the closed form without any post-pass.}
\ASSUMPTIONS{We can update the counts in $O(1)$ per toggle by adding $+1$ when toggling to odd and $-1$ when toggling back to even.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize boolean arrays \texttt{row[m]}, \texttt{col[n]} as \texttt{False} and integers \texttt{r\_odd = 0}, \texttt{c\_odd = 0}.
\item For each $(r,c)$ in \texttt{indices}: toggle \texttt{row[r]} and update \texttt{r\_odd} by $\pm 1$; toggle \texttt{col[c]} and update \texttt{c\_odd} by $\pm 1$.
\item Return \texttt{r\_odd * (n - c\_odd) + (m - r\_odd) * c\_odd}.
\end{algosteps}
\OPTIMALITY{Time is $O(k)$ with $O(m+n)$ space, matching the follow-up target and optimal for reading the input.}
\COMPLEXITY{We avoid any extra $O(m+n)$ pass and never touch all $mn$ cells.}
\[
\begin{aligned}
T(m,n,k) &= O(k), \\
S(m,n,k) &= O(m+n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        row = [False] * m
        col = [False] * n
        r_odd = 0
        c_odd = 0
        for r, c in indices:
            row[r] = not row[r]
            r_odd += 1 if row[r] else -1
            col[c] = not col[c]
            c_odd += 1 if col[c] else -1
        return r_odd * (n - c_odd) + (m - r_odd) * c_odd

# exactly 3 asserts
sol = Solution()
assert sol.oddCells(2, 3, [[0, 1], [1, 1]]) == 6
assert sol.oddCells(2, 2, [[1, 1], [0, 0]]) == 0
assert sol.oddCells(1, 4, [[0, 1], [0, 2], [0, 1]]) == 2
\end{minted}
\VALIDATION{Three asserts cover samples, boundary width, and repeated toggles.}
\RESULT{Returns the exact odd-cell count; there is no tie-breaking.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify against examples; fuzz small sizes by brute force cross-check; test repeated operations and degenerate dimensions ($m=1$ or $n=1$).}
\LINE{CROSS-CHECKS}{Compare baseline simulation vs. optimal method on small random cases to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate small matrices ($m,n \le 3$) and short operation lists, including duplicates, to stress parity toggling.}
\begin{minted}{python}
from typing import List
import itertools
import random

def brute(m: int, n: int, indices: List[List[int]]) -> int:
    A = [[0] * n for _ in range(m)]
    for r, c in indices:
        for j in range(n):
            A[r][j] += 1
        for i in range(m):
            A[i][c] += 1
    return sum((A[i][j] & 1) for i in range(m) for j in range(n))

class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        row = [False] * m
        col = [False] * n
        r_odd = 0
        c_odd = 0
        for r, c in indices:
            row[r] = not row[r]
            r_odd += 1 if row[r] else -1
            col[c] = not col[c]
            c_odd += 1 if col[c] else -1
        return r_odd * (n - c_odd) + (m - r_odd) * c_odd

# Cross-check on small exhaustive space (deterministic)
sol = Solution()
for m in range(1, 4):
    for n in range(1, 4):
        ops = [(r, c) for r in range(m) for c in range(n)]
        # test all sequences up to length 3
        for L in range(0, 4):
            for seq in itertools.product(ops, repeat=L):
                indices = [list(p) for p in seq]
                assert sol.oddCells(m, n, indices) == brute(m, n, indices)

# Spot checks
assert sol.oddCells(3, 5, [[0,0], [2,4], [0,0], [1,4]]) == brute(3, 5, [[0,0], [2,4], [0,0], [1,4]])
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        row = [False] * m
        col = [False] * n
        r_odd = 0
        c_odd = 0
        for r, c in indices:
            row[r] = not row[r]
            r_odd += 1 if row[r] else -1
            col[c] = not col[c]
            c_odd += 1 if col[c] else -1
        return r_odd * (n - c_odd) + (m - r_odd) * c_odd

# Minimal sanity tests
if __name__ == "__main__":
    sol = Solution()
    assert sol.oddCells(2, 3, [[0, 1], [1, 1]]) == 6
    assert sol.oddCells(2, 2, [[1, 1], [0, 0]]) == 0
    assert sol.oddCells(1, 4, [[0, 0], [0, 1], [0, 2], [0, 3]]) == 0
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count odd cells after row/column increments by tracking row and column parity and applying the closed-form count.}
\WHY{A common pattern: when only parity matters, track toggles instead of simulating full values; appears in array/matrix increment and parity problems.}
\CHECKLIST{
\begin{bullets}
\item Track parity, not magnitude.
\item Compute $r_{\text{odd}}$ and $c_{\text{odd}}$.
\item Apply $r_{\text{odd}}(n-c_{\text{odd}}) + (m-r_{\text{odd}})c_{\text{odd}}$.
\item Validate with simple examples.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Repeated operations on the same $(r,c)$.
\item All operations on one row or one column.
\item $m=1$ or $n=1$.
\item $k=1$.
\item Empty effect: pairs that toggle back to even counts.
\item Mixed dense/sparse operations.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to update $r_{\text{odd}}$/$c_{\text{odd}}$ when toggling.
\item Double-counting the intersection cell in brute force reasoning.
\item Using integer counts instead of parity, causing unnecessary work.
\item Overflow is not an issue here, but watch off-by-one in indices.
\item Building a full matrix unnecessarily increases memory/time.
\item Misapplying the formula (swapping $m,n$ or $r_{\text{odd}},c_{\text{odd}}$).
\end{bullets}
}
\FAILMODES{Brute-force cell updates scale poorly for larger $m,n$; parity approach remains $O(k)$ or $O(k+m+n)$ and is robust to duplicates.}
\ELI{Only whether a row and a column were hit an odd number of times matters. A cell is odd when exactly one of its row or column was toggled odd, and counting those combinations gives the answer in one shot.}
\NotePages{3}

\end{document}