% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Messenger}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/631/D}}
\LINE{DIFFICULTY / RATING}{CF: 631/D, Rating: 2100}
\STATEMENT{Each employee of the ``Blake Techologies'' company uses a special messaging app ``Blake Messenger''. All the staff likes this app and uses it constantly. However, some important features are missing. For example, many users want to be able to search through the message history. It was already announced that the new feature will appear in the nearest update, when developers faced some troubles that only you may help them to solve.

All the messages are represented as strings consisting of only lowercase English letters. In order to reduce the network load, strings are represented in a special compressed form. The compression algorithm works as follows: a string is represented as a concatenation of $n$ blocks, each block containing only equal characters. One block may be described as a pair $(l_i, c_i)$, where $l_i$ is the length of the $i$-th block and $c_i$ is the corresponding letter. Thus, the string $s$ may be written as the sequence of pairs $\langle (l_1, c_1), (l_2, c_2), \ldots, (l_n, c_n) \rangle$.

Your task is to write the program that, given two compressed strings $t$ and $s$, finds all occurrences of $s$ in $t$. Developers know that there may be many such occurrences, so they only ask you to find the number of them. Note that $p$ is the starting position of some occurrence of $s$ in $t$ if and only if $t_p t_{p+1} \ldots t_{p+|s|-1} = s$, where $t_i$ is the $i$-th character of string $t$.

Note that the way to represent the string in compressed form may not be unique. For example, the string ``aaaa'' may be given as $(4,a)$, $\langle (3,a), (1,a) \rangle$, $\langle (2,a), (2,a) \rangle$, \ldots

Input: The first line of the input contains two integers $n$ and $m$ ($1 \le n, m \le 200{,}000$) — the number of blocks in the strings $t$ and $s$, respectively.

The next line contains the descriptions of $n$ parts of string $t$ in the format ``$l_i$-$c_i$'' ($1 \le l_i \le 1{,}000{,}000$) — the length of the $i$-th part and the corresponding lowercase English letter.

The next line contains the descriptions of $m$ parts of string $s$ in the format ``$l_i$-$c_i$'' ($1 \le l_i \le 1{,}000{,}000$) — the length of the $i$-th part and the corresponding lowercase English letter.

Output: Print a single integer — the number of occurrences of $s$ in $t$.

Note: In the first sample, $t = \text{``aaabbccccaaacc''}$, and string $s = \text{``aabbc''}$. The only occurrence of string $s$ in string $t$ starts at position $p = 2$.

In the second sample, $t = \text{``aaabbbbbbaaaaaaacccceeeeeeeeaa''}$, and $s = \text{``aaa''}$. The occurrences of $s$ in $t$ start at positions $p = 1$, $p = 10$, $p = 11$, $p = 12$, $p = 13$, and $p = 14$.}
\BREAKDOWN{We are given two run-length encoded strings. Count how many starting positions in $t$ yield a substring equal to $s$. We must respect character runs and allow that the compressed representations are not unique, so we should first merge adjacent identical-character blocks. Then handle three cases: $|s|$ (in blocks) equals 1, equals 2, or at least 3; for the last case, do KMP over middle blocks and check end blocks by inequality constraints on lengths.}
\ELI{Treat each block as a token; match the middle tokens exactly with KMP, and only require that the first and last tokens have at least the needed lengths.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers $n$ and $m$ ($1 \le n,m \le 200{,}000$). A line with $n$ tokens ``$l$-$c$'' for $t$; a line with $m$ tokens ``$l$-$c$'' for $s$. Each $l$ is an integer ($1 \le l \le 1{,}000{,}000$), each $c$ is a lowercase English letter. Adjacent identical letters may appear in the compressed input and must be merged.}
\OUTPUTS{One integer: the number of occurrences of $s$ as a substring of $t$.}
\SAMPLES{Example 1: $t = \langle (3,a), (2,b), (4,c), (3,a), (2,c) \rangle$, $s = \langle (2,a), (2,b), (1,c) \rangle$ gives $1$.

Example 2: $t = \langle (5,a) \rangle$, $s = \langle (3,a) \rangle$ gives $3$ (positions $1,2,3$).}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T = \langle (L_1, \sigma_1), \ldots, (L_N, \sigma_N) \rangle$ and $S = \langle (\ell_1, \tau_1), \ldots, (\ell_M, \tau_M) \rangle$ be run-length encodings after merging consecutive equal letters. We seek the number of indices $p$ in the expanded $T$ such that the substring of length $|S| = \sum_{j=1}^M \ell_j$ equals the expansion of $S$.}
\varmapStart
\var{N}{number of blocks in merged $T$}
\var{M}{number of blocks in merged $S$}
\var{(L_i,\sigma_i)}{$i$-th block of $T$ (length and letter)}
\var{(\ell_j,\tau_j)}{$j$-th block of $S$ (length and letter)}
\var{K}{equals $M-2$ (size of middle pattern when $M \ge 3$)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{For }M=1:\ \text{count }i\text{ with }\sigma_i=\tau_1\text{ and }L_i \ge \ell_1,\ \text{adding }(L_i - \ell_1 + 1).
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{For }M=2:\ \text{count }i\in[1..N-1]\text{ with }(\sigma_i,\sigma_{i+1})=(\tau_1,\tau_2)\text{ and }(L_i \ge \ell_1, L_{i+1} \ge \ell_2).
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{For }M\ge 3:\ \text{find all indices }r\in[K..N]\text{ where }(L_{r-K+1..r-1},\sigma)= (\ell_{2..M-1},\tau)\ \text{exactly};
\end{BreakableEquation*}
\begin{BreakableEquation*}
\text{then require }\sigma_{r-K}=\tau_1,\ L_{r-K}\ge \ell_1,\ \sigma_{r+1}=\tau_M,\ L_{r+1}\ge \ell_M.
\end{BreakableEquation*}
}
\ASSUMPTIONS{Inputs are merged so that no adjacent blocks have the same letter. All lengths are positive integers.}
\INVARIANTS{Middle-block matching for $M \ge 3$ must be exact in both length and letter. End blocks only require letter equality and length lower bounds.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Decompress both $t$ and $s$ into explicit strings and run a standard linear-time substring search (e.g., KMP on characters).}
\ASSUMPTIONS{Suitable only for tiny lengths; decompression is infeasible in worst case due to lengths up to $10^6$ per block.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Parse tokens ``$l$-$c$'' for $t$ and $s$; merge adjacent identical letters for consistency.
\item Decompress merged blocks into full strings $T$ and $S$.
\item Run a classic KMP on $T$ vs $S$ and count matches.
\end{algosteps}
\COMPLEXITY{Let $|T|$ and $|S|$ be expanded lengths. Time $O(|T|+|S|)$; space $O(|T|+|S|)$, which is unacceptable for maximal inputs but fine as a conceptual baseline or for tiny tests.}
\[
\begin{aligned}
T(n) &= O(|T|+|S|),\quad S(n)=O(|T|+|S|).
\end{aligned}
\]
\CORRECTNESS{KMP guarantees all occurrences in linear time after decompression, which preserves exact strings by construction.}
\EDGECASES{Empty not allowed; single-block patterns; multiple adjacent identical tokens in input must be merged before decompression to avoid redundancy.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline (decompress + KMP on characters). For tiny inputs only.
from typing import List, Tuple

def merge_blocks(blocks: List[Tuple[int, str]]) -> List[Tuple[int, str]]:
    merged = []
    for l, c in blocks:
        if merged and merged[-1][1] == c:
            merged[-1] = (merged[-1][0] + l, c)
        else:
            merged.append((l, c))
    return merged

def parse_blocks_line(line: str) -> List[Tuple[int, str]]:
    tokens = line.strip().split()
    out = []
    for tok in tokens:
        if '-' not in tok:
            continue
        i = tok.rfind('-')
        l = int(tok[:i])
        c = tok[i+1:]
        c = c[0] if c else ''
        out.append((l, c))
    return merge_blocks(out)

def decompress(blocks: List[Tuple[int, str]]) -> str:
    return "".join(c * l for l, c in blocks)

def kmp_build(pattern: str) -> List[int]:
    pi = [0] * len(pattern)
    for i in range(1, len(pattern)):
        j = pi[i-1]
        while j and pattern[i] != pattern[j]:
            j = pi[j-1]
        if pattern[i] == pattern[j]:
            j += 1
        pi[i] = j
    return pi

def count_occurrences_decompressed(t_blocks: List[Tuple[int, str]], s_blocks: List[Tuple[int, str]]) -> int:
    t_blocks = merge_blocks(t_blocks)
    s_blocks = merge_blocks(s_blocks)
    T = decompress(t_blocks)
    S = decompress(s_blocks)
    if not S:
        return 0
    pi = kmp_build(S)
    j = 0
    ans = 0
    for ch in T:
        while j and ch != S[j]:
            j = pi[j-1]
        if ch == S[j]:
            j += 1
        if j == len(S):
            ans += 1
            j = pi[j-1]
    return ans

# CF-style API placeholders for baseline demonstration
def read_input():
    import sys
    data = sys.stdin.read().strip().splitlines()
    if not data:
        return None
    it = iter(data)
    first = next(it).strip()
    while first == "" and True:
        first = next(it).strip()
    n, m = map(int, first.split())
    t_line = next(it).strip()
    s_line = next(it).strip()
    t_blocks = parse_blocks_line(t_line)
    s_blocks = parse_blocks_line(s_line)
    return t_blocks, s_blocks

def solve_case_baseline(data) -> int:
    t_blocks, s_blocks = data
    return count_occurrences_decompressed(t_blocks, s_blocks)

def main():
    data = read_input()
    if data is None:
        return
    print(solve_case_baseline(data))

if __name__ == "__main__":
    # Tiny self-checks (baseline)
    assert count_occurrences_decompressed([(5, 'a')], [(3, 'a')]) == 3
    assert count_occurrences_decompressed([(2, 'a'), (1, 'a')], [(3, 'a')]) == 1
    assert count_occurrences_decompressed([(1, 'a'), (1, 'b'), (1, 'a')], [(1, 'b')]) == 1
    # Do not run main() for baseline auto-test
    pass
\end{minted}
\VALIDATION{Checked simple runs: single-block repeated letter; adjacency merging correctness; single-letter pattern in a small text.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Operate on Blocks; Handle $M=1$ and $M=2$ Separately}
\WHICHFORMULA{Avoid decompression by counting directly in block space. For $M=1$, each matching block contributes by the sliding window count $L - \ell + 1$. For $M=2$, count adjacent pairs with letter equality and minimal length constraints.}
\ASSUMPTIONS{Blocks are merged first; letters on adjacent blocks differ.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Merge adjacent equal-letter blocks in both inputs.
\item If $M=1$, sum $L_i - \ell_1 + 1$ over all blocks with $\sigma_i = \tau_1$ and $L_i \ge \ell_1$.
\item If $M=2$, count indices $i$ where $(\sigma_i,\sigma_{i+1})=(\tau_1,\tau_2)$ and $L_i \ge \ell_1$, $L_{i+1} \ge \ell_2$.
\end{algosteps}
\COMPLEXITY{Linear in number of blocks: $O(N)$ time, $O(1)$ extra space beyond input.}
\[
\begin{aligned}
T(n) &= O(N),\quad S(n)=O(1).
\end{aligned}
\]
\CORRECTNESS{Directly enumerates valid placements under the run-length semantics for patterns of one or two blocks.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Improved: block-space counting for M=1 and M=2; scaffolding matches final API.
from typing import List, Tuple

def merge_blocks(blocks: List[Tuple[int, str]]) -> List[Tuple[int, str]]:
    merged = []
    for l, c in blocks:
        if merged and merged[-1][1] == c:
            merged[-1] = (merged[-1][0] + l, c)
        else:
            merged.append((l, c))
    return merged

def parse_blocks_line(line: str) -> List[Tuple[int, str]]:
    tokens = line.strip().split()
    out = []
    for tok in tokens:
        if '-' not in tok:
            continue
        i = tok.rfind('-')
        l = int(tok[:i])
        c = tok[i+1:]
        c = c[0] if c else ''
        out.append((l, c))
    return merge_blocks(out)

def solve_counts_smallM(t_blocks: List[Tuple[int, str]], s_blocks: List[Tuple[int, str]]) -> int:
    t_blocks = merge_blocks(t_blocks)
    s_blocks = merge_blocks(s_blocks)
    M = len(s_blocks)
    if M == 1:
        L, ch = s_blocks[0]
        ans = 0
        for l, c in t_blocks:
            if c == ch and l >= L:
                ans += l - L + 1
        return ans
    if M == 2:
        (L1, c1), (L2, c2) = s_blocks
        ans = 0
        for i in range(len(t_blocks) - 1):
            l1, x1 = t_blocks[i]
            l2, x2 = t_blocks[i+1]
            if x1 == c1 and x2 == c2 and l1 >= L1 and l2 >= L2:
                ans += 1
        return ans
    raise ValueError("This helper is for M in {1,2} only")

# Basic asserts for M=1 and M=2 cases
assert solve_counts_smallM([(5, 'a')], [(3, 'a')]) == 3
assert solve_counts_smallM([(2, 'a'), (1, 'a')], [(3, 'a')]) == 1
assert solve_counts_smallM([(3, 'a'), (2, 'b')], [(2, 'a'), (2, 'b')]) == 1
\end{minted}
\VALIDATION{Validated exact small-$M$ logic with minimal merges and boundary counts.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{KMP on Middle Blocks}
\WHICHFORMULA{For $M \ge 3$, run KMP over the block sequence to match the middle $M-2$ blocks exactly (in both letter and length). For each match, verify the left and right neighboring blocks satisfy the end-constraints (same letter, length at least required).}
\ASSUMPTIONS{Both inputs are merged. Pattern length $M \ge 3$ implies at least one strict middle block to match exactly.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Merge adjacent equal-letter blocks in $t$ and $s$.
\item If $M=1$ or $M=2$, handle via Approach B.
\item Else build pattern $P = s[1..M-2]$ of length $K=M-2$ and its prefix-function $\pi$ using pair-equality on $(\ell, \tau)$.
\item KMP-scan $t$ blocks; for each match ending at index $r$, check left $t[r-K]$ against $s[0]$ and right $t[r+1]$ against $s[M-1]$ for letter equality and length lower bounds.
\item Count valid matches.
\end{algosteps}
\OPTIMALITY{Each block is processed $O(1)$ amortized times by KMP; neighbor checks are $O(1)$. This is linear in number of blocks and optimal up to constants.}
\COMPLEXITY{Time $O(N + M)$; space $O(M)$ for the prefix-function.}
\[
\begin{aligned}
T(n) &= O(N + M),\quad S(n)=O(M).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple, Optional

def merge_blocks(blocks: List[Tuple[int, str]]) -> List[Tuple[int, str]]:
    out: List[Tuple[int, str]] = []
    for l, c in blocks:
        if out and out[-1][1] == c:
            out[-1] = (out[-1][0] + l, c)
        else:
            out.append((l, c))
    return out

def parse_blocks_line(line: str) -> List[Tuple[int, str]]:
    tokens = line.strip().split()
    res: List[Tuple[int, str]] = []
    for tok in tokens:
        if '-' not in tok:
            continue
        k = tok.rfind('-')
        length = int(tok[:k])
        char = tok[k+1:] or ''
        char = char[0] if char else ''
        res.append((length, char))
    return merge_blocks(res)

def kmp_prefix(pattern: List[Tuple[int, str]]) -> List[int]:
    pi = [0] * len(pattern)
    def eq(a: Tuple[int, str], b: Tuple[int, str]) -> bool:
        return a[0] == b[0] and a[1] == b[1]
    for i in range(1, len(pattern)):
        j = pi[i-1]
        while j > 0 and not eq(pattern[i], pattern[j]):
            j = pi[j-1]
        if eq(pattern[i], pattern[j]):
            j += 1
        pi[i] = j
    return pi

def count_occurrences_blocks(t_blocks: List[Tuple[int, str]], s_blocks: List[Tuple[int, str]]) -> int:
    t_blocks = merge_blocks(t_blocks)
    s_blocks = merge_blocks(s_blocks)
    N = len(t_blocks)
    M = len(s_blocks)
    if M == 0:
        return 0
    if M == 1:
        L, ch = s_blocks[0]
        ans = 0
        for l, c in t_blocks:
            if c == ch and l >= L:
                ans += l - L + 1
        return ans
    if M == 2:
        (L1, c1), (L2, c2) = s_blocks
        ans = 0
        for i in range(N - 1):
            l1, x1 = t_blocks[i]
            l2, x2 = t_blocks[i+1]
            if x1 == c1 and x2 == c2 and l1 >= L1 and l2 >= L2:
                ans += 1
        return ans
    # M >= 3
    middle = s_blocks[1:-1]
    pi = kmp_prefix(middle)
    def eq(a: Tuple[int, str], b: Tuple[int, str]) -> bool:
        return a[0] == b[0] and a[1] == b[1]
    K = len(middle)
    j = 0
    ans = 0
    for idx, blk in enumerate(t_blocks):
        while j > 0 and not eq(blk, middle[j]):
            j = pi[j-1]
        if eq(blk, middle[j]):
            j += 1
        if j == K:
            end_idx = idx
            start_idx = end_idx - K + 1
            left_idx = start_idx - 1
            right_idx = end_idx + 1
            if 0 <= left_idx < N and 0 <= right_idx < N:
                Ll, cl = t_blocks[left_idx]
                Lr, cr = t_blocks[right_idx]
                Ls0, cs0 = s_blocks[0]
                LsM, csM = s_blocks[-1]
                if cl == cs0 and cr == csM and Ll >= Ls0 and Lr >= LsM:
                    ans += 1
            j = pi[j-1]
    return ans

# CF I/O
def read_input() -> Optional[Tuple[List[Tuple[int, str]], List[Tuple[int, str]]]]:
    import sys
    data = sys.stdin.read().strip().splitlines()
    if not data:
        return None
    it = iter(data)
    # Read first non-empty line with n, m
    first = ""
    while first == "":
        first = next(it).strip()
    n, m = map(int, first.split())
    t_line = next(it).strip()
    s_line = next(it).strip()
    t_blocks = parse_blocks_line(t_line)
    s_blocks = parse_blocks_line(s_line)
    return (t_blocks, s_blocks)

def solve_case(data: Tuple[List[Tuple[int, str]], List[Tuple[int, str]]]) -> int:
    t_blocks, s_blocks = data
    return count_occurrences_blocks(t_blocks, s_blocks)

def solve_all():
    data = read_input()
    if data is None:
        return
    print(solve_case(data))

# Self-checks
def _self_tests():
    # M=1
    assert count_occurrences_blocks([(5, 'a')], [(3, 'a')]) == 3
    assert count_occurrences_blocks([(2, 'a'), (3, 'a')], [(4, 'a')]) == 2  # merged to (5,'a')
    # M=2
    assert count_occurrences_blocks([(3, 'a'), (2, 'b')], [(2, 'a'), (2, 'b')]) == 1
    assert count_occurrences_blocks([(3, 'a'), (1, 'b')], [(2, 'a'), (2, 'b')]) == 0
    # M>=3: example-like
    t = [(3,'a'), (2,'b'), (4,'c'), (3,'a'), (2,'c')]
    s = [(2,'a'), (2,'b'), (1,'c')]
    assert count_occurrences_blocks(t, s) == 1
    # KMP middle exactness check (lengths must match in middle)
    t2 = [(2,'x'), (5,'y'), (2,'z')]
    s2 = [(1,'x'), (5,'y'), (1,'z')]
    assert count_occurrences_blocks(t2, s2) == 1
    s2_bad = [(1,'x'), (4,'y'), (1,'z')]
    assert count_occurrences_blocks(t2, s2_bad) == 0

if __name__ == "__main__":
    _self_tests()
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts shown in code: $M=1$ merging case; $M=2$ feasibility; $M \ge 3$ with middle exactness.}
\RESULT{Counts all starting positions where $s$ occurs in $t$ under run-length semantics; ties do not apply as output is a count.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Cover merging correctness; $M=1$ sliding-count; $M=2$ adjacent-pair check; $M \ge 3$ KMP with exact middle and inequality ends. Include adversarial adjacent identical tokens in input to test merge.}
\LINE{CROSS-CHECKS}{Compare baseline decompressed KMP vs. optimal block-KMP on small random instances to ensure equal counts.}
\LINE{EDGE-CASE GENERATOR}{Generate short random block sequences, randomly split/merge adjacent identical letters to simulate input non-uniqueness; verify stability of counts.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_blocks_string(seed=0, max_blocks=6, max_len=5):
    random.seed(seed)
    k = random.randint(1, max_blocks)
    blocks = []
    last = None
    for _ in range(k):
        c = chr(ord('a') + random.randint(0, 2))
        if last is not None and random.random() < 0.3:
            c = last  # encourage merges
        l = random.randint(1, max_len)
        blocks.append((l, c))
        last = c
    return blocks

def to_tokens(blocks):
    return " ".join(f"{l}-{c}" for l, c in blocks)

def cross_check(seed=1, trials=50):
    from typing import List, Tuple
    # import baseline and optimal from previous sections (assumed in same module)
    for s in range(seed, seed+trials):
        t = gen_blocks_string(s)
        p = gen_blocks_string(s+1000)
        # simulate non-unique compression by splitting randomly
        def split_random(blocks):
            out = []
            for l, c in blocks:
                if l >= 2 and random.random() < 0.5:
                    x = random.randint(1, l-1)
                    out.append((x, c))
                    out.append((l-x, c))
                else:
                    out.append((l, c))
            return out
        t_in = split_random(t)
        p_in = split_random(p)
        a = count_occurrences_decompressed(t_in, p_in)
        b = count_occurrences_blocks(t_in, p_in)
        assert a == b, (t_in, p_in, a, b)
    return True

if __name__ == "__main__":
    # Run cross-check on small sizes
    assert cross_check()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF) + asserts
from typing import List, Tuple, Optional

def merge_blocks(blocks: List[Tuple[int, str]]) -> List[Tuple[int, str]]:
    out: List[Tuple[int, str]] = []
    for l, c in blocks:
        if out and out[-1][1] == c:
            out[-1] = (out[-1][0] + l, c)
        else:
            out.append((l, c))
    return out

def parse_blocks_line(line: str) -> List[Tuple[int, str]]:
    tokens = line.strip().split()
    res: List[Tuple[int, str]] = []
    for tok in tokens:
        if '-' not in tok:
            continue
        k = tok.rfind('-')
        length = int(tok[:k])
        char = tok[k+1:] or ''
        char = char[0] if char else ''
        res.append((length, char))
    return merge_blocks(res)

def kmp_prefix(pattern: List[Tuple[int, str]]) -> List[int]:
    pi = [0] * len(pattern)
    def eq(a: Tuple[int, str], b: Tuple[int, str]) -> bool:
        return a[0] == b[0] and a[1] == b[1]
    for i in range(1, len(pattern)):
        j = pi[i-1]
        while j > 0 and not eq(pattern[i], pattern[j]):
            j = pi[j-1]
        if eq(pattern[i], pattern[j]):
            j += 1
        pi[i] = j
    return pi

def count_occurrences_blocks(t_blocks: List[Tuple[int, str]], s_blocks: List[Tuple[int, str]]) -> int:
    t_blocks = merge_blocks(t_blocks)
    s_blocks = merge_blocks(s_blocks)
    N = len(t_blocks)
    M = len(s_blocks)
    if M == 0:
        return 0
    if M == 1:
        L, ch = s_blocks[0]
        ans = 0
        for l, c in t_blocks:
            if c == ch and l >= L:
                ans += l - L + 1
        return ans
    if M == 2:
        (L1, c1), (L2, c2) = s_blocks
        ans = 0
        for i in range(N - 1):
            l1, x1 = t_blocks[i]
            l2, x2 = t_blocks[i+1]
            if x1 == c1 and x2 == c2 and l1 >= L1 and l2 >= L2:
                ans += 1
        return ans
    # M >= 3
    middle = s_blocks[1:-1]
    pi = kmp_prefix(middle)
    def eq(a: Tuple[int, str], b: Tuple[int, str]) -> bool:
        return a[0] == b[0] and a[1] == b[1]
    K = len(middle)
    j = 0
    ans = 0
    for idx, blk in enumerate(t_blocks):
        while j > 0 and not eq(blk, middle[j]):
            j = pi[j-1]
        if eq(blk, middle[j]):
            j += 1
        if j == K:
            end_idx = idx
            start_idx = end_idx - K + 1
            left_idx = start_idx - 1
            right_idx = end_idx + 1
            if 0 <= left_idx < N and 0 <= right_idx < N:
                Ll, cl = t_blocks[left_idx]
                Lr, cr = t_blocks[right_idx]
                Ls0, cs0 = s_blocks[0]
                LsM, csM = s_blocks[-1]
                if cl == cs0 and cr == csM and Ll >= Ls0 and Lr >= LsM:
                    ans += 1
            j = pi[j-1]
    return ans

def read_input() -> Optional[Tuple[List[Tuple[int, str]], List[Tuple[int, str]]]]:
    import sys
    data = sys.stdin.read().strip().splitlines()
    if not data:
        return None
    it = iter(data)
    first = ""
    while first == "":
        first = next(it).strip()
    n, m = map(int, first.split())
    t_line = next(it).strip()
    s_line = next(it).strip()
    t_blocks = parse_blocks_line(t_line)
    s_blocks = parse_blocks_line(s_line)
    return (t_blocks, s_blocks)

def solve_case(data: Tuple[List[Tuple[int, str]], List[Tuple[int, str]]]) -> int:
    t_blocks, s_blocks = data
    return count_occurrences_blocks(t_blocks, s_blocks)

def main():
    data = read_input()
    if data is None:
        return
    print(solve_case(data))

# Asserts
if __name__ == "__main__":
    # Core sanity tests
    assert count_occurrences_blocks([(5, 'a')], [(3, 'a')]) == 3
    assert count_occurrences_blocks([(3, 'a'), (2, 'b')], [(2, 'a'), (2, 'b')]) == 1
    assert count_occurrences_blocks([(2,'x'), (5,'y'), (2,'z')], [(1,'x'), (5,'y'), (1,'z')]) == 1
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count substring occurrences under run-length encoding by working on blocks: ends by inequality, middle by exact block KMP.}
\WHY{This pattern appears in compressed-string matching and in problems requiring handling of RLE constraints without expansion.}
\CHECKLIST{%
\begin{bullets}
\item Merge adjacent identical-character blocks in both inputs.
\item Handle $M=1$ and $M=2$ as special cases.
\item For $M \ge 3$, build KMP on middle blocks (length and letter).
\item For each middle match, check left/right neighbors for letter equality and length thresholds.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item Multiple adjacent identical tokens in input that must be merged.
\item Pattern of length $M=1$ within a long block ($L - \ell + 1$ positions).
\item Pattern of length $M=2$ spanning a block boundary exactly.
\item Middle-block length mismatch must reject even if letters match.
\item Ends must allow longer blocks (inequality, not equality).
\item Very small $N$ relative to $M$ (no matches).
\item Letters absent from $t$ entirely.
\item Large lengths with small block counts (avoid decompression).
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to merge adjacent identical letters before processing.
\item Using equality instead of $\ge$ for end-block lengths.
\item Off-by-one when mapping KMP match end index to neighbor indices.
\item Misparsing tokens with hyphens — always split on the last ``-''.
\item Treating end blocks like middle blocks (they differ).
\item Not guarding $N-1$ or neighbor indices when $M \ge 3$.
\item Assuming the character part always has length $1$ without slicing.
\end{bullets}
}
\FAILMODES{A decompress-based approach fails on maximum lengths. A naive block window compare for each start is $O(NM)$ and times out. The KMP-on-blocks approach processes each block amortized constant times and scales linearly.}
\ELI{Split the pattern into three parts: left end, exact middle, right end. Search the exact middle using KMP over block tokens, then only check the two neighbors by simple inequalities. This avoids expanding strings and runs fast.}
\NotePages{3}

\end{document}