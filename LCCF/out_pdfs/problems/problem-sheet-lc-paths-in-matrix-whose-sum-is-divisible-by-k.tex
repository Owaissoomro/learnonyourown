% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Paths in Matrix Whose Sum Is Divisible by K}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given a 0-indexed $m \times n$ integer matrix \texttt{grid} and an integer \texttt{k}. You are currently at position $(0, 0)$ and you want to reach position $(m-1, n-1)$ moving only down or right.

Return the number of paths where the sum of the elements on the path is divisible by \texttt{k}. Since the answer may be very large, return it modulo $10^9 + 7$.

\textbf{Example 1:}

\textbf{Input:} \texttt{grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3}

\textbf{Output:} \texttt{2}

\textbf{Explanation:} There are two paths where the sum of the elements on the path is divisible by \texttt{k}. The first path highlighted in red has a sum of $5 + 2 + 4 + 5 + 2 = 18$ which is divisible by $3$. The second path highlighted in blue has a sum of $5 + 3 + 0 + 5 + 2 = 15$ which is divisible by $3$.

\textbf{Example 2:}

\textbf{Input:} \texttt{grid = [[0,0]], k = 5}

\textbf{Output:} \texttt{1}

\textbf{Explanation:} The path highlighted in red has a sum of $0 + 0 = 0$ which is divisible by $5$.

\textbf{Example 3:}

\textbf{Input:} \texttt{grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1}

\textbf{Output:} \texttt{10}

\textbf{Explanation:} Every integer is divisible by $1$ so the sum of the elements on every possible path is divisible by \texttt{k}.

\textbf{Constraints:}
\begin{bullets}
\item $m = \texttt{grid.length}$
\item $n = \texttt{grid[i].length}$
\item $1 \le m, n \le 5 \times 10^{4}$
\item $1 \le m \times n \le 5 \times 10^{4}$
\item $0 \le \texttt{grid[i][j]} \le 100$
\item $1 \le \texttt{k} \le 50$
\end{bullets}
}
\BREAKDOWN{Count paths from $(0,0)$ to $(m-1,n-1)$ moving right/down such that the path-sum modulo $k$ equals $0$. The natural state tracks position and current sum modulo $k$, and transitions come from top or left.}
\ELI{Keep track of your running sum modulo $k$ while moving only right and down; count how many ways end with remainder $0$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{
- \texttt{grid}: List of $m$ rows, each a list of $n$ integers in $[0,100]$.\\
- \texttt{k}: integer in $[1,50]$.
}
\OUTPUTS{Return an integer: the number of valid paths modulo $10^9 + 7$.}
\SAMPLES{
- Input: \texttt{grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3} $\rightarrow$ Output: \texttt{2}.\\
- Input: \texttt{grid = [[0,0]], k = 5} $\rightarrow$ Output: \texttt{1}.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $F(i,j,r)$ be the number of paths from $(0,0)$ to $(i,j)$ whose sum is congruent to $r \pmod{k}$. The answer is $F(m-1,n-1,0) \bmod M$, where $M=10^9+7$.}
\varmapStart
\var{m,n}{grid dimensions}
\var{k}{divisor}
\var{M}{modulus $10^9+7$}
\var{a_{i,j}}{cell value $\texttt{grid}[i][j]$}
\var{F(i,j,r)}{paths count ending at $(i,j)$ with sum $\equiv r \pmod{k}$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&F(0,0,r) =
\begin{cases}
1, & r \equiv a_{0,0} \bmod k,\\
0, & \text{otherwise},
\end{cases}\\
&F(i,j,r) = \sum_{p=0}^{k-1} \Big( \mathbf{1}_{i>0}\,F(i-1,j,p) + \mathbf{1}_{j>0}\,F(i,j-1,p) \Big)\cdot \mathbf{1}_{\, (p + a_{i,j}) \bmod k = r},\\
&\text{Answer} = F(m-1,n-1,0) \bmod M.
\end{aligned}
\]
}
\ASSUMPTIONS{Grid indices are $0$-based. Moves are only right or down. All arithmetic on counts uses modulus $M=10^9+7$.}
\INVARIANTS{
- Nonnegativity: $F(i,j,r) \ge 0$ for all states.\\
- Conservation across remainders: For fixed $(i,j)$, $\sum_{r} F(i,j,r)$ equals the number of monotone paths to $(i,j)$.\\
- Boundary consistency: When $i=0$ or $j=0$, transitions use only available predecessor.}
\NotePages{3}

% ============ Optional Formula Pages (each own page) ============
% (If you add any Formula pages above, no extra notes are required unless desired.)

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Tree search over all monotone paths; accumulate sum modulo $k$ along the path and count those ending with remainder $0$.}
\ASSUMPTIONS{Only feasible for tiny grids; enumerate all $\binom{(m-1)+(n-1)}{m-1}$ monotone paths.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Depth-first search from $(0,0)$ with accumulator $s \equiv \text{sum} \pmod{k}$.
\item At each cell, recurse to $(i+1,j)$ and $(i,j+1)$ if inside grid.
\item At $(m-1,n-1)$, increment answer if $s \equiv 0 \pmod{k}$.
\end{algosteps}
\COMPLEXITY{Exponential in path length; worst-case $T(m,n)=\binom{(m-1)+(n-1)}{m-1}$ time, $S=$ recursion depth $O(m+n)$.}
\[
\begin{aligned}
T(m,n) &= \Theta\!\left(\binom{m+n-2}{m-1}\right),\quad
S(m,n)=O(m+n).
\end{aligned}
\]
\CORRECTNESS{Every monotone path is explored exactly once and is accepted iff its sum modulo $k$ equals $0$.}
\EDGECASES{Single-cell grid; single row/column; $k=1$; all zeros.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])
        ans = 0

        def dfs(i: int, j: int, rem: int) -> None:
            nonlocal ans
            rem = (rem + grid[i][j]) % k
            if i == m - 1 and j == n - 1:
                if rem == 0:
                    ans += 1
                return
            if i + 1 < m:
                dfs(i + 1, j, rem)
            if j + 1 < n:
                dfs(i, j + 1, rem)

        dfs(0, 0, 0)
        return ans % MOD

# tiny asserts (baseline exponential)
if __name__ == "__main__":
    sol = Solution()
    assert sol.numberOfPaths([[0]], 1) == 1
    assert sol.numberOfPaths([[5,2,4],[3,0,5],[0,7,2]], 3) == 2
    assert sol.numberOfPaths([[0,0]], 5) == 1
\end{minted}
\VALIDATION{Checked on the three examples and a $1\times 1$ case.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Bottom-up DP with remainder dimension}
\WHICHFORMULA{Tabulate $F(i,j,r)$ for all cells and remainders using the recurrence, combining from top and left.}
\ASSUMPTIONS{Space $O(m n k)$ is acceptable for clarity; all counts mod $10^9+7$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $dp[i][j][r]=0$ for all, set $dp[0][0][grid[0][0]\bmod k]=1$.
\item For each cell in row-major order, push contributions from top and left by shifting remainders by $a_{i,j}\bmod k$.
\item Return $dp[m-1][n-1][0]$.
\end{algosteps}
\COMPLEXITY{Time $O(m n k)$; space $O(m n k)$, which beats exponential search.}
\[
\begin{aligned}
T(m,n,k) &= \Theta(m n k),\quad S(m,n,k)=\Theta(m n k).
\end{aligned}
\]
\CORRECTNESS{Direct implementation of the governing recurrence ensures counts match all valid concatenations of paths from predecessors with correct remainder update.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])
        dp = [[[0] * k for _ in range(n)] for __ in range(m)]
        dp[0][0][grid[0][0] % k] = 1
        for i in range(m):
            for j in range(n):
                val = grid[i][j] % k
                if i == 0 and j == 0:
                    continue
                if i > 0:
                    top = dp[i - 1][j]
                    for r in range(k):
                        dp[i][j][(r + val) % k] = (dp[i][j][(r + val) % k] + top[r]) % MOD
                if j > 0:
                    left = dp[i][j - 1]
                    for r in range(k):
                        dp[i][j][(r + val) % k] = (dp[i][j][(r + val) % k] + left[r]) % MOD
        return dp[m - 1][n - 1][0] % MOD

if __name__ == "__main__":
    sol = Solution()
    assert sol.numberOfPaths([[5,2,4],[3,0,5],[0,7,2]], 3) == 2
    assert sol.numberOfPaths([[0,0]], 5) == 1
    assert sol.numberOfPaths([[7,3,4,9],[2,3,6,2],[2,3,7,0]], 1) == 10
\end{minted}
\VALIDATION{Verified on the three given examples; also consistent with Approach A on tiny cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Row-wise DP with $O(nk)$ memory}
\WHICHFORMULA{Maintain for current row the per-column remainder distributions; each cell aggregates from its top column vector (previous row) and left neighbor vector (current row).}
\ASSUMPTIONS{Works for all inputs; uses only two row buffers of shape $n \times k$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Keep \texttt{prev[j]} as a length-$k$ array for column $j$ from previous row; build \texttt{cur[j]} for current row.
\item For each cell $(i,j)$ with value $v$, shift-and-add: for all $p$, add \texttt{prev[j][p]} and \texttt{cur[j-1][p]} into \texttt{cur[j][(p+v)\%k]}.
\item Initialize base at $(0,0)$: \texttt{cur[0][v\%k]} = 1. Answer is \texttt{prev[n-1][0]} after final row.
\end{algosteps}
\OPTIMALITY{Any DP must at least process all $m n$ cells and $k$ remainders to be exact, implying $\Omega(m n k)$ time. The memory is minimized to $O(n k)$ via rolling arrays.}
\COMPLEXITY{Time $O(m n k)$; space $O(n k)$.}
\[
\begin{aligned}
T(m,n,k) &= \Theta(m n k),\quad S(n,k)=\Theta(n k).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])
        prev = [[0] * k for _ in range(n)]
        for i in range(m):
            cur = [[0] * k for _ in range(n)]
            for j in range(n):
                val = grid[i][j] % k
                if i == 0 and j == 0:
                    cur[0][val] = 1
                else:
                    if i > 0:
                        top = prev[j]
                        for r in range(k):
                            cur[j][(r + val) % k] = (cur[j][(r + val) % k] + top[r]) % MOD
                    if j > 0:
                        left = cur[j - 1]
                        for r in range(k):
                            cur[j][(r + val) % k] = (cur[j][(r + val) % k] + left[r]) % MOD
            prev = cur
        return prev[n - 1][0] % MOD

if __name__ == "__main__":
    sol = Solution()
    # Exactly 3 asserts
    assert sol.numberOfPaths([[5,2,4],[3,0,5],[0,7,2]], 3) == 2
    assert sol.numberOfPaths([[0,0]], 5) == 1
    assert sol.numberOfPaths([[7,3,4,9],[2,3,6,2],[2,3,7,0]], 1) == 10
\end{minted}
\VALIDATION{Matches known examples; stable under $k=1$ and single-row/column cases.}
\RESULT{Return the count of right/down paths with path-sum divisible by $k$, modulo $10^9+7$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on samples; boundary tests: $1\times 1$, single row, single column, $k=1$, all zeros, random small grids cross-checked against a full $O(m n k)$ DP.}
\LINE{CROSS-CHECKS}{Confirm Approach C equals Approach B on small random cases; equals brute force (Approach A) on tiny $2\times 2$ and $3\times 3$.}
\LINE{EDGE-CASE GENERATOR}{Generate deterministic small cases covering extremes and typical scenarios.}
\begin{minted}{python}
from typing import List

def ref_bruteforce(grid: List[List[int]], k: int) -> int:
    MOD = 10**9 + 7
    m, n = len(grid), len(grid[0])
    ans = 0
    def dfs(i: int, j: int, rem: int) -> None:
        nonlocal ans
        rem = (rem + grid[i][j]) % k
        if i == m - 1 and j == n - 1:
            if rem == 0:
                ans += 1
            return
        if i + 1 < m:
            dfs(i + 1, j, rem)
        if j + 1 < n:
            dfs(i, j + 1, rem)
    dfs(0, 0, 0)
    return ans % MOD

class DPFull:
    @staticmethod
    def solve(grid: List[List[int]], k: int) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])
        dp = [[[0] * k for _ in range(n)] for __ in range(m)]
        dp[0][0][grid[0][0] % k] = 1
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    continue
                val = grid[i][j] % k
                if i > 0:
                    for r in range(k):
                        dp[i][j][(r + val) % k] = (dp[i][j][(r + val) % k] + dp[i - 1][j][r]) % MOD
                if j > 0:
                    for r in range(k):
                        dp[i][j][(r + val) % k] = (dp[i][j][(r + val) % k] + dp[i][j - 1][r]) % MOD
        return dp[m - 1][n - 1][0] % MOD

class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])
        prev = [[0] * k for _ in range(n)]
        for i in range(m):
            cur = [[0] * k for _ in range(n)]
            for j in range(n):
                val = grid[i][j] % k
                if i == 0 and j == 0:
                    cur[0][val] = 1
                else:
                    if i > 0:
                        for r in range(k):
                            cur[j][(r + val) % k] = (cur[j][(r + val) % k] + prev[j][r]) % MOD
                    if j > 0:
                        for r in range(k):
                            cur[j][(r + val) % k] = (cur[j][(r + val) % k] + cur[j - 1][r]) % MOD
            prev = cur
        return prev[n - 1][0] % MOD

if __name__ == "__main__":
    # Deterministic edge cases
    cases = [
        ([[0]], 1),
        ([[0,0]], 5),
        ([[5],[2],[4]], 3),
        ([[5,2,4],[3,0,5],[0,7,2]], 3),
        ([[7,3,4,9],[2,3,6,2],[2,3,7,0]], 1),
        ([[1,2],[3,4]], 2),
    ]
    sol = Solution()
    for grid, k in cases:
        a = sol.numberOfPaths(grid, k)
        b = DPFull.solve(grid, k)
        assert a == b
    # Tiny cross-check with brute force
    assert sol.numberOfPaths([[1,2],[3,4]], 3) == ref_bruteforce([[1,2],[3,4]], 3)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])
        prev = [[0] * k for _ in range(n)]
        for i in range(m):
            cur = [[0] * k for _ in range(n)]
            for j in range(n):
                val = grid[i][j] % k
                if i == 0 and j == 0:
                    cur[0][val] = 1
                else:
                    if i > 0:
                        top = prev[j]
                        for r in range(k):
                            cur[j][(r + val) % k] = (cur[j][(r + val) % k] + top[r]) % MOD
                    if j > 0:
                        left = cur[j - 1]
                        for r in range(k):
                            cur[j][(r + val) % k] = (cur[j][(r + val) % k] + left[r]) % MOD
            prev = cur
        return prev[n - 1][0] % MOD

if __name__ == "__main__":
    sol = Solution()
    assert sol.numberOfPaths([[5,2,4],[3,0,5],[0,7,2]], 3) == 2
    assert sol.numberOfPaths([[0,0]], 5) == 1
    assert sol.numberOfPaths([[7,3,4,9],[2,3,6,2],[2,3,7,0]], 1) == 10
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{DP over cells with remainder classes: combine from top and left, shifting by current value modulo $k$.}
\WHY{Classic grid DP with state compression; appears in interviews to test modular DP modeling and memory optimization.}
\CHECKLIST{
- Define state $F(i,j,r)$ and base case at $(0,0)$.\\
- Shift remainders by $a_{i,j}\bmod k$ when transitioning.\\
- Combine from top and left; guard boundaries.\\
- Apply modulus $10^9+7$ on every addition.\\
- Return remainder $0$ at the destination.}
\EDGECASES{
- $m=n=1$ (single cell).\\
- Single row or single column.\\
- $k=1$ (everything valid).\\
- All zeros in grid.\\
- $k$ greater than any path sum (still use modulo).\\
- Values exactly multiples of $k$.\\
- Large $m n$ near $5\times 10^{4}$.\\
- $k$ near $50$.\\
- Non-square grids.\\
- Paths count exceeding Python int (use mod).}
\PITFALLS{
- Forgetting to include current cell value in the remainder shift.\\
- Updating in-place incorrectly and reusing overwritten states.\\
- Missing modulus on additions causing overflow or wrong outputs.\\
- Off-by-one at boundaries $(i=0)$ or $(j=0)$.\\
- Returning total paths instead of remainder-$0$ bin.\\
- Using sum instead of sum modulo $k$ for state.\\
- Mis-initializing base cell.\\
- Confusing $n$ (columns) and $m$ (rows).}
\FAILMODES{Brute force times out; memo without remainder dimension yields wrong counts; in-place 2D updates without row-buffering double count or miss left/top contributions. The rolling $n\times k$ DP avoids these.}
\ELI{Walk from top-left to bottom-right, keeping only how the sum behaves modulo $k$. At each cell, combine ways from top and left, and shift by this cell's value. In the end, read how many ways leave a remainder of $0$.}
\NotePages{3}

\end{document}