% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Cards Partition}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2018/A}}
\LINE{DIFFICULTY / RATING}{1600}
\STATEMENT{You have some cards. An integer between $1$ and $n$ is written on each card: specifically, for each $i$ from $1$ to $n$, you have $a_i$ cards which have the number $i$ written on them.

There is also a shop which contains unlimited cards of each type. You have $k$ coins, so you can buy at most $k$ new cards in total, and the cards you buy can contain any integer between $\mathbf{1}$ and $\mathbf{n}$, inclusive.

After buying the new cards, you must partition all your cards into decks, according to the following rules:
\begin{bullets}
\item all the decks must have the same size;
\item there are no pairs of cards with the same value in the same deck.
\end{bullets}
Find the maximum possible size of a deck after buying cards and partitioning them optimally.

Input: Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^4$). The description of the test cases follows.

The first line of each test case contains two integers $n$, $k$ ($1 \leq n \leq 2 \cdot 10^5$, $0 \leq k \leq 10^{16}$) — the number of distinct types of cards and the number of coins.

The second line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \leq a_i \leq 10^{10}$, $\sum a_i \geq 1$) — the number of cards of type $i$ you have at the beginning, for each $1 \leq i \leq n$.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$.

Output: For each test case, output a single integer: the maximum possible size of a deck if you operate optimally.

Note: In the first test case, you can buy one card with the number $1$, and your cards become $[1, 1, 1, 1, 2, 2, 3, 3]$. You can partition them into the decks $[1, 2], [1, 2], [1, 3], [1, 3]$: they all have size $2$, and they all contain distinct values. You can show that you cannot get a partition with decks of size greater than $2$, so the answer is $2$.

In the second test case, you can buy two cards with the number $1$ and one card with the number $3$, and your cards become $[1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 5, 5, 5, 5]$, which can be partitioned into $[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 2, 5], [2, 3, 5], [2, 4, 5]$. You can show that you cannot get a partition with decks of size greater than $3$, so the answer is $3$.}
\BREAKDOWN{We must determine, after optionally buying up to $k$ cards of any types, the largest deck size $m$ such that all cards can be partitioned into $D$ decks of size $m$, with no duplicate values in any deck. Key constraints: $D \cdot m$ equals the total cards after buying, and each type $i$ can appear at most once per deck, i.e., at most $D$ times overall.}
\ELI{Pick a number of decks $D$ large enough to fit the biggest pile; then use coins to fill missing types evenly until you hit either the total-card limit or the $n$-per-deck limit.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{
\begin{bullets}
\item $t$ — number of test cases, $1 \le t \le 10^4$.
\item For each test case: integers $n$, $k$ with $1 \le n \le 2 \cdot 10^5$, $0 \le k \le 10^{16}$.
\item An array $a_1,\ldots,a_n$ with $0 \le a_i \le 10^{10}$ and $\sum a_i \ge 1$.
\item Total $n$ across all test cases $\le 2 \cdot 10^5$.
\end{bullets}
}
\OUTPUTS{For each test case, a single integer: the maximum deck size $m$ achievable under the rules.}
\SAMPLES{
\begin{bullets}
\item Example: $n=3$, $k=1$, $a=[3,2,2] \Rightarrow$ answer $2$.
\item Example: $n=5$, $k=3$, $a=[2,6,1,2,4] \Rightarrow$ answer $3$.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $a_i$ be initial counts, choose purchases $b_i \ge 0$ integers with $\sum b_i \le k$. Let $c_i=a_i+b_i$. We must choose an integer number of decks $D \ge 1$ and a deck size $m \ge 1$ such that:
\begin{bullets}
\item All cards are used: $\sum_{i=1}^n c_i = D \cdot m$.
\item No duplicates per deck: $c_i \le D$ for all $i$ (at most one per deck per type).
\end{bullets}
Goal: maximize $m$.}
\varmapStart
\var{n}{number of types}
\var{k}{coins (max additional cards)}
\var{a_i}{initial count of type $i$}
\var{b_i}{bought count of type $i$}
\var{c_i}{final count of type $i$; $c_i=a_i+b_i$}
\var{T}{initial total, $T=\sum a_i$}
\var{X}{max total if we spend all coins, $X=T+k$}
\var{A_{\max}}{maximum initial pile, $A_{\max}=\max_i a_i$}
\var{D}{number of decks}
\var{m}{deck size (answer to maximize)}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Feasibility:} && c_i \le D \ \ \forall i,\quad \sum c_i = Dm,\quad \sum \max(0,c_i-a_i) \le k.\\
&\text{With }D \ge A_{\max}: && \sum c_i \le \min\{X,\ nD\}.\\
&\text{Thus }m(D) &= \left\lfloor \frac{\min\{X,\ nD\}}{D} \right\rfloor \ =\ \min\!\left(n,\ \left\lfloor \frac{X}{D} \right\rfloor\right),\qquad D \ge A_{\max}.\\
&\text{Answer:} && \max_{D \ge A_{\max}} m(D)
= \begin{cases}
n, & \text{if } A_{\max} \le \left\lfloor \dfrac{X}{n} \right\rfloor,\\[6pt]
\left\lfloor \dfrac{X}{A_{\max}} \right\rfloor, & \text{otherwise.}
\end{cases}
\end{aligned}
\]
}
\ASSUMPTIONS{All variables are integers. Purchases can be assigned to any types independently up to per-type cap $D-a_i$. Using $D \ge A_{\max}$ avoids infeasibility from oversized piles.}
\INVARIANTS{
\begin{bullets}
\item Per-type capacity: For fixed $D \ge A_{\max}$, total addable cards $\sum (D-a_i) = nD - T$.
\item Total-card bound: After buying, total cards $T' \le \min\{X,\ nD\}$.
\item Monotonicity: $\min\!\left(n,\left\lfloor \tfrac{X}{D}\right\rfloor\right)$ is non-increasing in $D$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate feasible $D$ and compute $m(D)=\min\!\left(n,\left\lfloor \tfrac{X}{D}\right\rfloor\right)$; pick the maximum over $D \in [A_{\max}, X]$.}
\ASSUMPTIONS{Works only for small $X$; correct by direct evaluation of the closed form per $D$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Read $n,k$ and array $a$; compute $T=\sum a_i$, $X=T+k$, $A_{\max}=\max a_i$.
\item For $D$ from $A_{\max}$ to $X$, compute $m(D)=\min\!\left(n,\left\lfloor \tfrac{X}{D}\right\rfloor\right)$ and track the maximum.
\item Output the maximum $m(D)$.
\end{algosteps}
\COMPLEXITY{This is $O(X-A_{\max}+1)$ per test, which is infeasible when $X$ is large. Space is $O(1)$ beyond input.}
\[
\begin{aligned}
T(n) &= \Theta(X - A_{\max} + 1) \\
     &= \Theta(T + k - \max_i a_i + 1) \\
\end{aligned}
\]
\CORRECTNESS{By the model, $m(D)$ is exact for each $D \ge A_{\max}$, so the maximum over all $D$ yields the optimal deck size.}
\EDGECASES{When $A_{\max}=X$, only $D=X$ is checked; when $A_{\max} \le \left\lfloor \tfrac{X}{n}\right\rfloor$, the loop returns $n$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys

def compute_answer_bruteforce(n, k, a):
    T = sum(a)
    X = T + k
    Amax = max(a)
    ans = 0
    # Guard: D must be at least Amax and at most X (since D*m = total cards >= D*1)
    for D in range(Amax, X + 1):
        m = min(n, X // D)
        if m > ans:
            ans = m
        # Early stop if we already hit n (can't get larger)
        if ans == n:
            break
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, k, a))
    return tests

def solve_case(n, k, a):
    # Use the closed form even in baseline driver to avoid timeouts on large inputs.
    T = sum(a)
    X = T + k
    Amax = max(a)
    if Amax <= X // n:
        return n
    return X // Amax

def solve_all():
    out_lines = []
    for (n, k, a) in read_input():
        out_lines.append(str(solve_case(n, k, a)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Basic asserts for sanity
    assert compute_answer_bruteforce(3, 1, [3, 2, 2]) == 2
    assert compute_answer_bruteforce(5, 3, [2, 6, 1, 2, 4]) == 3
    assert compute_answer_bruteforce(3, 100, [0, 0, 1]) == 3
    # Cross-check baseline brute force vs closed form on small ranges
    import random
    random.seed(0)
    for _ in range(200):
        n = random.randint(1, 6)
        a = [random.randint(0, 8) for __ in range(n)]
        if sum(a) == 0:
            a[random.randrange(n)] = 1
        k = random.randint(0, 20)
        bf = compute_answer_bruteforce(n, k, a)
        # Closed form
        T = sum(a); X = T + k; Amax = max(a)
        cf = n if Amax <= X // n else X // Amax
        assert bf == cf
    # If running on an online judge, uncomment the next line:
    # solve_all()
\end{minted}
\VALIDATION{Cross-check brute force vs closed form on randomized small inputs; spot-check the two examples and a case that reaches full $n$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Binary Search on Deck Size}
\WHICHFORMULA{Binary search the deck size $m$ and check feasibility by constructing the minimum number of decks $D$ required and verifying per-type and total constraints.}
\ASSUMPTIONS{For a target $m$, the smallest $D$ that could realize $m$ is constrained by $D \ge A_{\max}$ and $D \ge \left\lceil \tfrac{T}{m} \right\rceil$; feasibility also requires $D \cdot m \le \min\{X,\ nD\}$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $T$, $X$, $A_{\max}$.
\item Binary search $m$ in $[1,n]$.
\item For a mid $m$, let $D_0=\max\!\left(A_{\max}, \left\lceil \tfrac{T}{m} \right\rceil\right)$. Check if $D_0 \cdot m \le \min\{X,\ nD_0\}$. If yes, $m$ is feasible; else not.
\item Return the largest feasible $m$.
\end{algosteps}
\COMPLEXITY{Binary search over $[1,n]$ takes $O(\log n)$ checks; each check is $O(1)$. Total per test: $O(n + \log n)$ time, $O(1)$ extra space.}
\[
\begin{aligned}
T(n) &= O(n) \text{ to scan inputs } + O(\log n) \text{ for the search}. \\
\end{aligned}
\]
\CORRECTNESS{If $m$ is feasible, some $D \ge A_{\max}$ satisfies $D m \le \min\{X,\ nD\}$ and $D m \ge T$; the minimal such $D$ is $D_0$, and monotonicity ensures feasibility for all $m' \le m$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
import math

def feasible_m(n, T, X, Amax, m):
    if m == 0:
        return True
    # Minimal D to place all cards and achieve size m
    D = max(Amax, (T + m - 1) // m)
    # Check total-card and per-deck-type bounds
    return D * m <= min(X, n * D)

def compute_answer_bs(n, k, a):
    T = sum(a); X = T + k; Amax = max(a)
    lo, hi = 1, n
    ans = 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if feasible_m(n, T, X, Amax, mid):
            ans = mid
            lo = mid + 1
        else:
            hi = mid - 1
    return ans

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, k, a))
    return tests

def solve_case(n, k, a):
    # Closed form for final answer
    T = sum(a); X = T + k; Amax = max(a)
    return n if Amax <= X // n else X // Amax

def solve_all():
    out_lines = []
    for (n, k, a) in read_input():
        out_lines.append(str(solve_case(n, k, a)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Cross-check improved vs closed form on random tests
    import random
    random.seed(1)
    for _ in range(200):
        n = random.randint(1, 8)
        a = [random.randint(0, 12) for __ in range(n)]
        if sum(a) == 0:
            a[random.randrange(n)] = 1
        k = random.randint(0, 30)
        T = sum(a); X = T + k; Amax = max(a)
        cf = n if Amax <= X // n else X // Amax
        bs = compute_answer_bs(n, k, a)
        assert cf == bs
    # Spot checks
    assert compute_answer_bs(3, 1, [3, 2, 2]) == 2
    assert compute_answer_bs(5, 3, [2, 6, 1, 2, 4]) == 3
    # solve_all()
\end{minted}
\VALIDATION{Randomized consistency between binary search feasibility and the closed-form solution; spot-check example-like cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Closed-Form Maximization}
\WHICHFORMULA{Use $m(D)=\min\!\left(n,\left\lfloor \tfrac{X}{D}\right\rfloor\right)$ for $D \ge A_{\max}$, and the fact that it is non-increasing in $D$. The maximum occurs at $D=A_{\max}$ unless we can already achieve $m=n$, i.e., when $A_{\max} \le \left\lfloor \tfrac{X}{n}\right\rfloor$.}
\ASSUMPTIONS{Purchases can be distributed arbitrarily across types up to $D-a_i$ each; $D \ge A_{\max}$ is necessary to place the largest pile with at most one per deck.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $T=\sum a_i$, $X=T+k$, and $A_{\max}=\max a_i$.
\item If $A_{\max} \le \left\lfloor \tfrac{X}{n}\right\rfloor$, return $n$.
\item Otherwise, return $\left\lfloor \tfrac{X}{A_{\max}}\right\rfloor$.
\end{algosteps}
\OPTIMALITY{For $D \le \left\lfloor \tfrac{X}{n}\right\rfloor$, $m(D)=n$. If any such $D$ is feasible (i.e., $D \ge A_{\max}$), $n$ is optimal. Otherwise $D > \left\lfloor \tfrac{X}{n}\right\rfloor$, so $m(D)=\left\lfloor \tfrac{X}{D}\right\rfloor$ is maximized by the smallest admissible $D$, namely $A_{\max}$.}
\COMPLEXITY{One pass to compute $T$ and $A_{\max}$: $O(n)$ time and $O(1)$ extra space per test case.}
\[
\begin{aligned}
T(n) &= O(n), \quad S(n) = O(1).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys

def compute_answer(n, k, a):
    T = sum(a)
    X = T + k
    Amax = max(a)
    if Amax <= X // n:
        return n
    return X // Amax

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, k, a))
    return tests

def solve_case(n, k, a):
    return compute_answer(n, k, a)

def solve_all():
    out_lines = []
    for (n, k, a) in read_input():
        out_lines.append(str(solve_case(n, k, a)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Exactly 3 asserts
    assert compute_answer(3, 1, [3, 2, 2]) == 2
    assert compute_answer(5, 3, [2, 6, 1, 2, 4]) == 3
    assert compute_answer(3, 100, [0, 0, 1]) == 3
    # For online judge, uncomment:
    # solve_all()
\end{minted}
\VALIDATION{Asserts cover: a case returning 2, a case returning 3, and a case achieving full $n$.}
\RESULT{For each test case, print the maximum deck size $m$. Ties do not arise since a single integer is returned.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests for small crafted cases; property-based cross-checks between brute force and closed form for small $n,k$; boundary checks when $A_{\max} \le \left\lfloor \tfrac{X}{n}\right\rfloor$ and when $A_{\max} > \left\lfloor \tfrac{X}{n}\right\rfloor$.}
\LINE{CROSS-CHECKS}{Compare Approach A (bruteforce) and Approach C (closed form) on random small instances to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with a single dominant $a_i$, arrays with many zeros, $k=0$, and very large $k$ to force the $m=n$ branch.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
def gen_cases():
    cases = []
    # Minimal n
    cases.append((1, 0, [5]))          # Only one type
    cases.append((1, 10, [0]))         # Only one type, can buy
    # Zeros and dominant pile
    cases.append((5, 0, [10,0,0,0,0]))
    cases.append((5, 100, [10,0,0,0,0]))
    # Many small piles
    cases.append((6, 3, [1,1,1,1,1,1]))
    # Force full-n branch
    cases.append((4, 100, [0,0,0,1]))
    # k = 0 varied
    cases.append((3, 0, [3,2,2]))
    return cases

def reference(n, k, a):
    T = sum(a); X = T + k; Amax = max(a)
    return n if Amax <= X // n else X // Amax

def run_tests():
    for (n, k, a) in gen_cases():
        assert reference(n, k, a) >= 1
    # Randomized cross-check small domain
    import random
    random.seed(42)
    for _ in range(500):
        n = random.randint(1, 7)
        a = [random.randint(0, 12) for __ in range(n)]
        if sum(a) == 0:
            a[random.randrange(n)] = 1
        k = random.randint(0, 40)
        # Brute force over D to cross-check
        T = sum(a); X = T + k; Amax = max(a)
        bf = 0
        for D in range(Amax, X + 1):
            m = min(n, X // D)
            bf = max(bf, m)
            if bf == n:
                break
        assert bf == reference(n, k, a)

if __name__ == "__main__":
    run_tests()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys

def compute_answer(n, k, a):
    T = sum(a)
    X = T + k
    Amax = max(a)
    if Amax <= X // n:
        return n
    return X // Amax

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        tests.append((n, k, a))
    return tests

def solve_case(n, k, a):
    return compute_answer(n, k, a)

def solve_all():
    out_lines = []
    for (n, k, a) in read_input():
        out_lines.append(str(solve_case(n, k, a)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Lightweight internal tests
    assert compute_answer(3, 1, [3, 2, 2]) == 2
    assert compute_answer(5, 3, [2, 6, 1, 2, 4]) == 3
    assert compute_answer(3, 100, [0, 0, 1]) == 3
    # Uncomment for judge execution:
    # solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Maximize deck size $m$ by choosing decks $D \ge A_{\max}$ so that $Dm \le \min\{T+k,\ nD\}$ and $Dm \ge T$.}
\WHY{Appears in interviews to test capacity reasoning, per-bin caps, and turning combinatorial partitioning into simple algebra.}
\CHECKLIST{
\begin{bullets}
\item Compute $T=\sum a_i$, $A_{\max}=\max a_i$, $X=T+k$.
\item If $A_{\max} \le \left\lfloor \tfrac{X}{n}\right\rfloor$, answer $n$.
\item Else answer $\left\lfloor \tfrac{X}{A_{\max}}\right\rfloor$.
\item Use $64$-bit capable integers (Python int is arbitrary precision).
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $k=0$ (no buying).
\item Some $a_i=0$.
\item One huge pile: $A_{\max}$ dominates.
\item Very large $k$ so that full $n$ is achievable.
\item $n=1$ (answer is $1$ always).
\item Total $T$ just below multiples causing floor effects.
\item All mass in one type vs. evenly spread.
\item $T$ very large near limits; verify no overflow in other languages.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting that every type can appear at most once per deck, hence $c_i \le D$.
\item Trying to decrease counts (impossible); hence $D \ge A_{\max}$ is mandatory.
\item Enumerating $D$ up to $T+k$ causing TLE.
\item Over-buying beyond per-type caps $D-a_i$ (aggregate cap is $nD-T$).
\item Misreading “partition all cards”: $Dm=T'$ must use all cards after buying.
\item Integer division off-by-one in floors and ceilings.
\end{bullets}
}
\FAILMODES{Greedy filling by types without respecting per-type cap $D$ can overcount and predict infeasible $m$. The closed form automatically respects both the total-card limit $X$ and the $nD$ cap.}
\ELI{You need at least as many decks as your largest pile so you can spread duplicates. With $D$ decks, you can place at most $nD$ cards and at most $X=T+k$ cards exist. So deck size is $\min\!\big(n,\lfloor X/D\rfloor\big)$; pick the best $D$ — either you hit $n$, or you take $D=A_{\max}$.}
\NotePages{3}

\end{document}