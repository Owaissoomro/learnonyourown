% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Count the Number of Incremovable Subarrays II}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/count-the-number-of-incremovable-subarrays-ii/}}
\LINE{DIFFICULTY / RATING}{Hard}
\STATEMENT{You are given a 0-indexed array of positive integers \texttt{nums}. A subarray of \texttt{nums} is called incremovable if \texttt{nums} becomes strictly increasing after removing the subarray. For example, the subarray \texttt{[3, 4]} is an incremovable subarray of \texttt{[5, 3, 4, 6, 7]} because removing this subarray changes the array \texttt{[5, 3, 4, 6, 7]} to \texttt{[5, 6, 7]} which is strictly increasing.

Return the total number of incremovable subarrays of \texttt{nums}.

Note that an empty array is considered strictly increasing. A subarray is a contiguous non-empty sequence of elements within an array.

Examples:
\begin{itemize}
\item Input: \texttt{nums = [1,2,3,4]}. Output: \texttt{10}.
\item Input: \texttt{nums = [6,5,7,8]}. Output: \texttt{7}.
\item Input: \texttt{nums = [8,7,6,6]}. Output: \texttt{3}. Note that \texttt{[8,7]} is not incremovable because after removing it, \texttt{[6,6]} is non-decreasing but not strictly increasing.
\end{itemize}

Constraints: $1 \le n \le 10^5$, where $n$ is the length of \texttt{nums}; and $1 \le \texttt{nums}[i] \le 10^9$.}
\BREAKDOWN{We must count all pairs $(\ell,r)$ with $0 \le \ell \le r < n$ such that removing \texttt{nums[$\ell$..$r$]} yields a strictly increasing array. Use structure: the remaining prefix and suffix must be strictly increasing individually, and their boundary must also be strictly increasing.}
\ELI{Find the longest strictly increasing prefix and suffix; then slide a pointer to count how many middle subarrays can be removed while keeping the join strictly increasing.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{nums} of length $n$ with $1 \le n \le 10^5$ and $1 \le \texttt{nums}[i] \le 10^9$.}
\OUTPUTS{An integer: the number of contiguous non-empty subarrays whose removal makes the remaining array strictly increasing.}
\SAMPLES{
Example A: \texttt{nums = [1,2,3,4]} $\to$ \texttt{10}.\\
Example B: \texttt{nums = [8,7,6,6]} $\to$ \texttt{3}.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A = (a_0,\ldots,a_{n-1})$. Count pairs $(\ell,r)$, $0 \le \ell \le r < n$, such that the concatenation $A[0..\ell-1] \circ A[r+1..n-1]$ is strictly increasing.}
\varmapStart
\var{\ell,r}{subarray endpoints to remove}
\var{L}{max index s.t. $A[0..L]$ is strictly increasing}
\var{R}{min index s.t. $A[R..n-1]$ is strictly increasing}
\var{n}{array length}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Validity of }(\ell,r):\\
&\quad (1)\ \ell-1 \le L \quad\text{(prefix up to }\ell-1\text{ is strictly increasing)}\\
&\quad (2)\ r+1 \ge R \quad\text{(suffix from }r+1\text{ is strictly increasing)}\\
&\quad (3)\ \text{if } \ell>0 \text{ and } r<n-1,\ \ a_{\ell-1} < a_{r+1}\ \text{(boundary join is strictly increasing).}
\end{aligned}
\]
}
\ASSUMPTIONS{Strict means $<$ between consecutive kept elements. Indexing is 0-based. Empty prefix or suffix is vacuously strictly increasing.}
\INVARIANTS{
\begin{itemize}
\item The suffix $A[R..n-1]$ and prefix $A[0..L]$ are maximal and minimal respectively by construction.
\item For fixed $\ell$, the minimal $j=r+1$ satisfying the boundary condition is monotone non-decreasing in $\ell$; enables two-pointer counting.
\end{itemize}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate all subarrays $(\ell,r)$ and check if removing \texttt{nums[$\ell$..$r$]} yields a strictly increasing concatenation.}
\ASSUMPTIONS{Suitable only for very small $n$; serves as correctness reference.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each $\ell$ from $0$ to $n-1$:
\item For each $r$ from $\ell$ to $n-1$:
\item Check the concatenation of prefix $[0..\ell-1]$ and suffix $[r+1..n-1]$ is strictly increasing; if yes, increment the answer.
\end{algosteps}
\COMPLEXITY{Triple loop in the worst case.}
\[
\begin{aligned}
T(n) &= \Theta\!\bigl(n^3\bigr)\ \text{(naive check in }O(n)\text{ for each of }O(n^2)\text{ subarrays)}\\
S(n) &= O(1)
\end{aligned}
\]
\CORRECTNESS{By definition: we test exactly the predicate that defines incremovability for every possible subarray.}
\EDGECASES{Arrays of length $1$; already strictly increasing arrays; repeated equal values at the join.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0

        def is_strict_after_removal(L: int, R: int) -> bool:
            # Check concatenation of nums[0:L] and nums[R+1:n] is strictly increasing
            prev = None
            # prefix
            for i in range(L):
                if prev is not None and not (prev < nums[i]):
                    return False
                prev = nums[i]
            # suffix
            for i in range(R + 1, n):
                if prev is not None and not (prev < nums[i]):
                    return False
                prev = nums[i]
            return True

        for L in range(n):
            for R in range(L, n):
                if is_strict_after_removal(L, R):
                    ans += 1
        return ans

# Basic validation on small cases
if __name__ == "__main__":
    s = Solution()
    assert s.incremovableSubarrayCount([1,2,3,4]) == 10
    assert s.incremovableSubarrayCount([6,5,7,8]) == 7
    assert s.incremovableSubarrayCount([8,7,6,6]) == 3
\end{minted}
\VALIDATION{Covers the three examples; additional manual checks recommended for tiny random arrays.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Prefix/Suffix Structure + Binary Search}
\WHICHFORMULA{Use the longest increasing prefix and suffix. For each left boundary $\ell$, binary search the earliest right cut $j=r+1$ that satisfies both suffix position and boundary value constraint; then count the tail choices.}
\ASSUMPTIONS{The suffix $A[R..n-1]$ is strictly increasing, so its values are strictly increasing and suitable for binary search.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $L$ as the last index of the longest strictly increasing prefix. If $L=n-1$, return $\tfrac{n(n+1)}{2}$.
\item Compute $R$ as the first index of the longest strictly increasing suffix.
\item Build arrays: indices $I=[R,R+1,\ldots,n-1]$ and values $V=[a_R,a_{R+1},\ldots,a_{n-1}]$.
\item For $\ell=0,\ldots,L+1$: let base $b=\max(R,\ell+1)$. If $\ell=0$, set $j=b$. Else binary search the first index in $V$ with value $> a_{\ell-1}$, and also ensure index $\ge b$ (by taking the maximum of both lower bounds). Then add $n-j+1$ to the answer.
\end{algosteps}
\COMPLEXITY{Each of $L+2$ iterations performs $O(\log n)$ binary searches.}
\[
\begin{aligned}
T(n) &= O(n\log n) \\
S(n) &= O(n) \text{ for the suffix arrays}
\end{aligned}
\]
\CORRECTNESS{Conditions (1) and (2) ensure the remaining prefix/suffix are strictly increasing. The binary search enforces condition (3) by picking the minimal join $j$ with $a_{\ell-1}<a_j$, and all larger $j$ also satisfy it by monotonicity.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import bisect

class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        n = len(nums)
        # Longest increasing prefix
        L = 0
        while L + 1 < n and nums[L] < nums[L + 1]:
            L += 1
        if L == n - 1:
            return n * (n + 1) // 2  # already strictly increasing

        # Longest increasing suffix start
        R = n - 1
        while R - 1 >= 0 and nums[R - 1] < nums[R]:
            R -= 1

        # Prepare suffix index/value arrays
        idx_base = R
        vals = nums[R:]  # strictly increasing
        ans = 0

        for left in range(0, L + 2):
            base_j = max(R, left + 1)
            if left == 0:
                j = base_j
            else:
                # Lower bound by value: first position with vals[pos] > nums[left-1]
                pos_val = bisect.bisect_right(vals, nums[left - 1])
                # Lower bound by index: first position whose absolute index >= base_j
                pos_idx = base_j - idx_base
                if pos_idx < 0:
                    pos_idx = 0
                pos = max(pos_val, pos_idx)
                j = idx_base + pos
                if j > n:
                    j = n  # no valid join except removing to the end (handled below)
            if j < base_j:
                j = base_j
            if j > n:
                j = n
            ans += n - j + 1
        return ans

# Checks
if __name__ == "__main__":
    s = Solution()
    assert s.incremovableSubarrayCount([1,2,3,4]) == 10
    assert s.incremovableSubarrayCount([6,5,7,8]) == 7
    assert s.incremovableSubarrayCount([8,7,6,6]) == 3
    # Additional quick spot-checks
    assert s.incremovableSubarrayCount([2]) == 1
    assert s.incremovableSubarrayCount([2,2]) == 1  # only remove [2,2]
\end{minted}
\VALIDATION{Covers provided examples and a couple of tiny edge cases.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Two-Pointer Sweep on Join Index}
\WHICHFORMULA{Maintain a non-decreasing pointer $j=r+1$ over the strictly increasing suffix. For each $\ell$, advance $j$ until the boundary $a_{\ell-1} < a_j$ holds; enforce $j \ge \max(R,\ell+1)$. The number of valid $r$ is $n-j+1$.}
\ASSUMPTIONS{The minimal feasible $j$ is monotone in $\ell$, so a single pass suffices.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $L$ and $R$ as in Approach B. If already strictly increasing, return $\tfrac{n(n+1)}{2}$.
\item Initialize $j \leftarrow R$ and answer $ans \leftarrow 0$.
\item For $\ell = 0$ to $L+1$: while $j<n$ and $\ell>0$ and $a_{\ell-1} \ge a_j$, increment $j$. Then set $j \leftarrow \max(j, R, \ell+1)$ and add $n-j+1$ to $ans$.
\end{algosteps}
\OPTIMALITY{Each of $\ell$ and $j$ advances at most $n$ times; no backtracking. This yields a tight $O(n)$ bound, which is optimal up to constants since input size is $\Theta(n)$.}
\COMPLEXITY{Linear time and constant extra space.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(1)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List

class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        n = len(nums)
        # Longest strictly increasing prefix end index L
        L = 0
        while L + 1 < n and nums[L] < nums[L + 1]:
            L += 1
        if L == n - 1:
            return n * (n + 1) // 2  # every non-empty subarray works

        # Longest strictly increasing suffix start index R
        R = n - 1
        while R - 1 >= 0 and nums[R - 1] < nums[R]:
            R -= 1

        ans = 0
        j = R  # j is r+1 pointer into suffix, non-decreasing
        for left in range(0, L + 2):
            if left > 0:
                while j < n and nums[left - 1] >= nums[j]:
                    j += 1
            # Enforce positional constraints
            if j < left + 1:
                j = left + 1
            if j < R:
                j = R
            # Count choices of r (r ranges from j-1 to n-1)
            ans += n - j + 1
        return ans

# Exact 3 asserts (examples)
if __name__ == "__main__":
    s = Solution()
    assert s.incremovableSubarrayCount([1,2,3,4]) == 10
    assert s.incremovableSubarrayCount([6,5,7,8]) == 7
    assert s.incremovableSubarrayCount([8,7,6,6]) == 3
\end{minted}
\VALIDATION{Runs in $O(n)$; validated on the three official examples.}
\RESULT{The method returns the number of contiguous non-empty subarrays whose removal yields a strictly increasing array; ties are irrelevant since we sum counts.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on examples; randomized small arrays to cross-check brute force and optimal; boundary arrays: strictly increasing, strictly decreasing, all equal, alternating up/down, duplicates at the join.}
\LINE{CROSS-CHECKS}{For $n \le 9$, compare Approach A vs. Approach C on random inputs to ensure equality.}
\LINE{EDGE-CASE GENERATOR}{Produces arrays of small sizes with patterns: monotone up, monotone down, plateaus, and random.}
\begin{minted}{python}
from typing import List
import random

def brute(nums: List[int]) -> int:
    n = len(nums)
    ans = 0
    def ok(L: int, R: int) -> bool:
        prev = None
        for i in range(L):
            if prev is not None and not (prev < nums[i]):
                return False
            prev = nums[i]
        for i in range(R+1, n):
            if prev is not None and not (prev < nums[i]):
                return False
            prev = nums[i]
        return True
    for L in range(n):
        for R in range(L, n):
            if ok(L, R):
                ans += 1
    return ans

class SolutionRef:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        n = len(nums)
        L = 0
        while L + 1 < n and nums[L] < nums[L + 1]:
            L += 1
        if L == n - 1:
            return n * (n + 1) // 2
        R = n - 1
        while R - 1 >= 0 and nums[R - 1] < nums[R]:
            R -= 1
        ans = 0
        j = R
        for left in range(0, L + 2):
            if left > 0:
                while j < n and nums[left - 1] >= nums[j]:
                    j += 1
            if j < left + 1:
                j = left + 1
            if j < R:
                j = R
            ans += n - j + 1
        return ans

def run_cross_checks():
    rng = random.Random(0)
    for n in range(1, 10):
        for _ in range(200):
            nums = [rng.randint(1, 9) for _ in range(n)]
            b = brute(nums)
            f = SolutionRef().incremovableSubarrayCount(nums)
            assert b == f, (nums, b, f)
    print("Cross-checks passed.")

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List

class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        n = len(nums)
        # Longest strictly increasing prefix end index L
        L = 0
        while L + 1 < n and nums[L] < nums[L + 1]:
            L += 1
        if L == n - 1:
            return n * (n + 1) // 2

        # Longest strictly increasing suffix start index R
        R = n - 1
        while R - 1 >= 0 and nums[R - 1] < nums[R]:
            R -= 1

        ans = 0
        j = R  # r+1 pointer
        for left in range(0, L + 2):
            if left > 0:
                while j < n and nums[left - 1] >= nums[j]:
                    j += 1
            if j < left + 1:
                j = left + 1
            if j < R:
                j = R
            ans += n - j + 1
        return ans

# Sanity asserts
if __name__ == "__main__":
    s = Solution()
    assert s.incremovableSubarrayCount([1,2,3,4]) == 10
    assert s.incremovableSubarrayCount([6,5,7,8]) == 7
    assert s.incremovableSubarrayCount([8,7,6,6]) == 3
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count subarrays to remove so that the remaining prefix and suffix are strictly increasing and the boundary also increases.}
\WHY{This tests mastery of two-pointer invariants and converting a removal condition into a monotone counting problem.}
\CHECKLIST{
\begin{bullets}
\item Compute $L$ and $R$ correctly.
\item Handle the already strictly increasing case: return $\tfrac{n(n+1)}{2}$.
\item Maintain $j$ as $r+1$ and advance only forward.
\item Enforce $j \ge \max(R,\ell+1)$ before counting.
\item Boundary compare only when both sides are non-empty.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item Already strictly increasing.
\item All elements equal.
\item Strictly decreasing.
\item Duplicate values straddling the boundary.
\item Violations near the ends: $\ell=0$ or $r=n-1$.
\item Large values up to $10^9$ (no overflow in Python, but be mindful in other languages).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Off-by-one for $L$ and $R$ definitions.
\item Forgetting that removal subarray must be non-empty ($\ell \le r$).
\item Not forcing $j \ge \ell+1$, which violates $r \ge \ell$.
\item Comparing boundary when one side is empty (unnecessary and harmful).
\item Resetting $j$ backwards; must be monotone non-decreasing.
\end{bullets}
}
\FAILMODES{
\begin{bullets}
\item Naive $O(n^2)$ or $O(n^3)$ approaches TLE on $n=10^5$.
\item Incorrect handling of equal values at the join produces overcounts.
\end{bullets}
}
\ELI{Keep the longest sorted parts at the front and back. Slide a pointer in the back part so that the last kept left value is less than the first kept right value. Count how many right cuts work for each left cut, all in one pass.}
\NotePages{3}

\end{document}