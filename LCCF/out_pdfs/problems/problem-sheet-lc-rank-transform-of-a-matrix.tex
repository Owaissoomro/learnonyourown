% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Rank Transform of a Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/rank-transform-of-a-matrix/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{Given an \texttt{m x n} \texttt{matrix}, return \emph{a new matrix} \texttt{answer} \emph{where} \texttt{answer[row][col]} \emph{is the} \textbf{rank} \emph{of} \texttt{matrix[row][col]}.

The \textbf{rank} is an \textbf{integer} that represents how large an element is compared to other elements. It is calculated using the following rules:
\begin{itemize}
\item The rank is an integer starting from \texttt{1}.
\item If two elements \texttt{p} and \texttt{q} are in the \textbf{same row or column}, then:
\begin{itemize}
\item If \texttt{p < q} then \texttt{rank(p) < rank(q)}.
\item If \texttt{p == q} then \texttt{rank(p) == rank(q)}.
\item If \texttt{p > q} then \texttt{rank(p) > rank(q)}.
\end{itemize}
\item The \textbf{rank} should be as \textbf{small} as possible.
\end{itemize}
The test cases are generated so that \texttt{answer} is unique under the given rules.

\textbf{Example 1:}

\textbf{Input:} \texttt{matrix = [[1,2],[3,4]]}

\textbf{Output:} \texttt{[[1,2],[2,3]]}

\textbf{Explanation:}
The rank of \texttt{matrix[0][0]} is \texttt{1} because it is the smallest integer in its row and column.
The rank of \texttt{matrix[0][1]} is \texttt{2} because \texttt{matrix[0][1] > matrix[0][0]} and \texttt{matrix[0][0]} is rank \texttt{1}.
The rank of \texttt{matrix[1][0]} is \texttt{2} because \texttt{matrix[1][0] > matrix[0][0]} and \texttt{matrix[0][0]} is rank \texttt{1}.
The rank of \texttt{matrix[1][1]} is \texttt{3} because \texttt{matrix[1][1] > matrix[0][1]}, \texttt{matrix[1][1] > matrix[1][0]}, and both \texttt{matrix[0][1]} and \texttt{matrix[1][0]} are rank \texttt{2}.

\textbf{Example 2:}

\textbf{Input:} \texttt{matrix = [[7,7],[7,7]]}

\textbf{Output:} \texttt{[[1,1],[1,1]]}

\textbf{Example 3:}

\textbf{Input:} \texttt{matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]}

\textbf{Output:} \texttt{[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]}

\textbf{Constraints:}
\begin{itemize}
\item \texttt{m == matrix.length}
\item \texttt{n == matrix[i].length}
\item \texttt{1 <= m, n <= 500}
\item $-10^9 \le \texttt{matrix[row][col]} \le 10^9$
\end{itemize}}
\BREAKDOWN{We must assign the smallest possible positive integer ranks to all cells such that along any row or column, relative order of ranks respects the relative order of values, and equal values connected by a path of row/column equalities share the same rank. The uniqueness guarantee allows a deterministic construction by sweeping values in ascending order.}
\ELI{Process values from small to large; within each equal-value cluster connected by rows/columns, give all cells the same rank equal to one plus the best rank already seen in their row or column.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{A 2D list \texttt{matrix} of size \texttt{m x n} with integers, where $1 \le m,n \le 500$ and each entry is within $[-10^9,10^9]$.}
\OUTPUTS{A 2D list \texttt{answer} of the same shape, where \texttt{answer[i][j]} is the rank assigned to \texttt{matrix[i][j]} satisfying the row/column ordering constraints and minimality.}
\SAMPLES{
Example A: \texttt{[[1,2],[3,4]]} $\to$ \texttt{[[1,2],[2,3]}].

Example B: \texttt{[[7,7],[7,7]]} $\to$ \texttt{[[1,1],[1,1]]}.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $M \in \mathbb{Z}^{m \times n}$. We seek ranks $R \in \mathbb{Z}_{\ge 1}^{m \times n}$ minimizing lexicographically (equivalently, pointwise) subject to row/column constraints: for any $(i,j)$ and $(i',j')$ with $i=i'$ or $j=j'$, 
\[
M_{ij} < M_{i'j'} \implies R_{ij} < R_{i'j'},\quad
M_{ij} = M_{i'j'} \implies R_{ij} = R_{i'j'},\quad
M_{ij} > M_{i'j'} \implies R_{ij} > R_{i'j'}.
\]
Equal values propagate equality of ranks along paths alternating rows and columns.}
\varmapStart
\var{M_{ij}}{input value at row $i$, column $j$}
\var{R_{ij}}{rank to assign at row $i$, column $j$}
\var{\text{rowMax}[i]}{maximum rank already assigned in row $i$ among strictly smaller values}
\var{\text{colMax}[j]}{maximum rank already assigned in column $j$ among strictly smaller values}
\var{G_v}{bipartite subgraph induced by all cells with value $v$ between row-nodes and column-nodes}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
\text{Process distinct values } v_1< v_2<\cdots. \text{ For each } v:&\\
\text{For each connected component } C \text{ in } G_v:&\quad r_C \gets 1 + \max\bigl(\max_{i \in \text{rows}(C)} \text{rowMax}[i],\ \max_{j \in \text{cols}(C)} \text{colMax}[j]\bigr),\\
\forall (i,j)\in C:&\quad R_{ij} \gets r_C,\\
\forall i \in \text{rows}(C):&\quad \text{rowMax}[i] \gets r_C,\quad
\forall j \in \text{cols}(C):\quad \text{colMax}[j] \gets r_C.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are $0$-based; comparisons use integer order. Equal values connected through rows/columns must share ranks. The uniqueness guarantee ensures the sweep constructs the unique minimal feasible $R$.}
\INVARIANTS{
1) After finishing all values $< v$, rowMax and colMax store the maximum assigned rank in each row/column from processed values. 
2) When processing value $v$, all dependencies come only from smaller values, hence $r_C$ is well-defined and minimal. 
3) Within a component $C$ at value $v$, all cells receive the same rank $r_C$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Sweep values in ascending order. For each distinct value, form the subgraph of positions with that value; two positions are adjacent if they share a row or a column. Give every connected component a rank equal to one plus the maximum of current rowMax and colMax across its rows and columns.}
\ASSUMPTIONS{We can group positions by value and find connected components using BFS/DFS over row-to-columns and column-to-rows adjacency within the value group.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group all coordinates by their value; sort the distinct values increasingly.
\item For each value $v$: build maps row $\to$ columns and column $\to$ rows for positions with value $v$; run BFS to find components.
\item For each component, compute $r=1+\max(\text{rowMax over its rows},\ \text{colMax over its cols})$; assign $r$ to all its cells; stage updates to rowMax/colMax; apply after finishing value $v$.
\end{algosteps}
\COMPLEXITY{Building groups and sorting costs $O(mn\log(mn))$. Each cell appears in exactly one value layer and is visited $O(1)$ times across BFS using hash maps. Memory is linear in $mn$.}
\[
\begin{aligned}
T(m,n) &= O(mn\log(mn)) + O(mn) = O(mn\log(mn)),\\
S(m,n) &= O(mn).
\end{aligned}
\]
\CORRECTNESS{By processing in increasing $v$, all prerequisites from smaller values are already finalized in rowMax/colMax. Connectedness within the equal-value layer enforces equal ranks across any path of equalities in the same row/column. Taking $1+\max(\cdot)$ yields the smallest rank that respects the strict inequalities to smaller elements in those rows/columns.}
\EDGECASES{Single cell; all equal values; rows or columns with duplicates; negative values; large $m,n$; multiple disconnected components for the same value.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from collections import defaultdict, deque
from typing import List, Dict, Tuple, Set

class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0])
        ans = [[0]*n for _ in range(m)]
        # Map value -> list of positions
        by_val: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
        for i in range(m):
            for j in range(n):
                by_val[matrix[i][j]].append((i, j))
        # Row/col current max ranks from processed smaller values
        rowMax = [0]*m
        colMax = [0]*n

        for v in sorted(by_val.keys()):
            positions = by_val[v]
            # Build adjacency within this value: row -> cols, col -> rows
            rows: Dict[int, List[int]] = defaultdict(list)
            cols: Dict[int, List[int]] = defaultdict(list)
            for i, j in positions:
                rows[i].append(j)
                cols[j].append(i)

            visited_pos: Set[Tuple[int, int]] = set()
            # We'll also stage updates per row/col to avoid interfering mid-layer
            staged_row = dict()
            staged_col = dict()

            # Helper BFS over positions using row/col adjacency
            for start in positions:
                if start in visited_pos:
                    continue
                comp_positions: List[Tuple[int, int]] = []
                comp_rows: Set[int] = set()
                comp_cols: Set[int] = set()
                dq = deque([start])
                visited_pos.add(start)
                while dq:
                    i, j = dq.popleft()
                    comp_positions.append((i, j))
                    comp_rows.add(i)
                    comp_cols.add(j)
                    # neighbors in same row
                    for jj in rows[i]:
                        p = (i, jj)
                        if p not in visited_pos:
                            visited_pos.add(p)
                            dq.append(p)
                    # neighbors in same column
                    for ii in cols[j]:
                        p = (ii, j)
                        if p not in visited_pos:
                            visited_pos.add(p)
                            dq.append(p)

                base = 0
                if comp_rows:
                    base = max(base, max(rowMax[i] for i in comp_rows))
                if comp_cols:
                    base = max(base, max(colMax[j] for j in comp_cols))
                r = base + 1
                # Assign rank to component positions
                for (i, j) in comp_positions:
                    ans[i][j] = r
                # Stage updates
                for i in comp_rows:
                    staged_row[i] = max(staged_row.get(i, 0), r)
                for j in comp_cols:
                    staged_col[j] = max(staged_col.get(j, 0), r)

            # Apply staged updates after finishing this value layer
            for i, vmax in staged_row.items():
                rowMax[i] = max(rowMax[i], vmax)
            for j, vmax in staged_col.items():
                colMax[j] = max(colMax[j], vmax)

        return ans

# Tiny validations for the baseline
if __name__ == "__main__":
    s = Solution()
    assert s.matrixRankTransform([[1,2],[3,4]]) == [[1,2],[2,3]]
    assert s.matrixRankTransform([[7,7],[7,7]]) == [[1,1],[1,1]]
    inp = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
    out = [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
    assert s.matrixRankTransform(inp) == out
\end{minted}
\VALIDATION{Checked the three provided samples. Also implicitly validates that multiple disconnected components at the same value can yield different ranks while connected ones share the same.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use Union-Find (DSU) on the bipartite graph of row-nodes and column-nodes within each value layer. Union $(\text{row }i)$ with $(\text{col }j)$ for every cell $(i,j)$ that has the current value. Each DSU component then gets rank $1 + \max(\text{rowMax over its rows}, \text{colMax over its cols})$.}
\ASSUMPTIONS{Within a single value layer, edges only connect nodes pertaining to that layer. We can instantiate a fresh DSU over just the involved row/column indices to keep time and memory linear in the layer size.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Group positions by value and iterate values increasingly.
\item For each value $v$: map each touched row $i$ to node $i$, and each touched column $j$ to node $j+m$; union $i$ with $j+m$ for all $(i,j)$ in the layer.
\item For each DSU root, compute rank $r=1+\max(\text{rowMax},\text{colMax})$ over its member rows/cols; assign $r$ to all its cells and stage row/col updates; then apply updates after finishing the layer.
\end{algosteps}
\COMPLEXITY{Each cell participates in exactly one union in its value layer; DSU operations are nearly constant amortized. Overall $O(mn\log(mn))$ for sorting by value and $O(mn\,\alpha(m+n))$ for unions and finds; memory $O(mn)$.}
\[
\begin{aligned}
T(m,n) &= O(mn\log(mn) + mn\,\alpha(m+n)),\\
S(m,n) &= O(mn).
\end{aligned}
\]
\CORRECTNESS{Within a value layer, DSU components coincide with connected components of the equal-value bipartite graph, enforcing equal ranks. Processing in increasing value ensures only dependencies from smaller values influence the chosen rank via rowMax/colMax, yielding minimal feasible ranks.}
\textbf{Code (Improved)}
\begin{minted}{python}
from collections import defaultdict
from typing import List, Dict, Tuple

class DSU:
    def __init__(self):
        self.parent: Dict[int, int] = {}
        self.rank: Dict[int, int] = {}

    def find(self, x: int) -> int:
        if x not in self.parent:
            self.parent[x] = x
            self.rank[x] = 0
            return x
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.rank[ra] < self.rank[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        if self.rank[ra] == self.rank[rb]:
            self.rank[ra] += 1

class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0])
        ans = [[0]*n for _ in range(m)]
        by_val: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
        for i in range(m):
            for j in range(n):
                by_val[matrix[i][j]].append((i, j))
        rowMax = [0]*m
        colMax = [0]*n

        for v in sorted(by_val.keys()):
            positions = by_val[v]
            dsu = DSU()
            # Union rows and columns involved in this value layer
            for i, j in positions:
                dsu.union(i, j + m)

            # Collect members per DSU root
            comp_rows: Dict[int, List[int]] = defaultdict(list)
            comp_cols: Dict[int, List[int]] = defaultdict(list)
            for i, j in positions:
                rroot = dsu.find(i)
                croot = dsu.find(j + m)
                root = dsu.find(rroot)  # normalize
                comp_rows[root].append(i)
                comp_cols[root].append(j)

            # Determine rank per component and assign
            staged_row: Dict[int, int] = {}
            staged_col: Dict[int, int] = {}
            comp_rank: Dict[int, int] = {}
            for root in comp_rows.keys():
                base = 0
                if comp_rows[root]:
                    base = max(base, max(rowMax[i] for i in comp_rows[root]))
                if comp_cols[root]:
                    base = max(base, max(colMax[j] for j in comp_cols[root]))
                comp_rank[root] = base + 1
            # Assign to cells
            for i, j in positions:
                root = dsu.find(i)
                r = comp_rank[root]
                ans[i][j] = r
                staged_row[i] = max(staged_row.get(i, 0), r)
                staged_col[j] = max(staged_col.get(j, 0), r)
            # Apply staged updates
            for i, vmax in staged_row.items():
                rowMax[i] = max(rowMax[i], vmax)
            for j, vmax in staged_col.items():
                colMax[j] = max(colMax[j], vmax)

        return ans

# Checks for the improved approach
if __name__ == "__main__":
    s = Solution()
    assert s.matrixRankTransform([[1,2],[3,4]]) == [[1,2],[2,3]]
    assert s.matrixRankTransform([[7,7],[7,7]]) == [[1,1],[1,1]]
    assert s.matrixRankTransform([[1,1,1]]) == [[1,1,1]]
\end{minted}
\VALIDATION{Verified on samples and an extra single-row case with all equal values.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Canonical DSU per value layer with row/column offset, computing component rank as $1+\max(\text{rowMax},\text{colMax})$, updating after each value. This achieves optimal ranks and near-linear work aside from sorting.}
\ASSUMPTIONS{Values can be processed in non-decreasing order; DSU only spans indices touched by the current value to keep operations linear in layer size.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build dictionary from value to list of coordinates; sort values.
\item For each value: create DSU; union each row $i$ with column $j+m$ for cells $(i,j)$ of this value; gather component members.
\item For each component, compute $r=1+\max(\text{rowMax over rows},\text{colMax over cols})$; assign $r$ to its cells and update rowMax/colMax after the layer.
\end{algosteps}
\OPTIMALITY{Any feasible labeling must assign at least $1+\max(\text{rowMax},\text{colMax})$ to any cell because it has to exceed all ranks of strictly smaller values in its row or column. Our construction achieves exactly that lower bound for each connected equal-value component, hence it is optimal.}
\COMPLEXITY{Sorting dominates: $O(mn\log(mn))$; DSU adds $O(mn\,\alpha(m+n))$; memory $O(mn)$.}
\[
\begin{aligned}
T(m,n) &= O(mn\log(mn) + mn\,\alpha(m+n)),\\
S(m,n) &= O(mn).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from collections import defaultdict
from typing import List, Dict, Tuple

class DSU:
    def __init__(self):
        self.parent: Dict[int, int] = {}
        self.rank: Dict[int, int] = {}

    def find(self, x: int) -> int:
        if x not in self.parent:
            self.parent[x] = x
            self.rank[x] = 0
            return x
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.rank[ra] < self.rank[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        if self.rank[ra] == self.rank[rb]:
            self.rank[ra] += 1

class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0])
        ans = [[0]*n for _ in range(m)]
        by_val: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
        for i in range(m):
            for j in range(n):
                by_val[matrix[i][j]].append((i, j))
        rowMax = [0]*m
        colMax = [0]*n

        for v in sorted(by_val.keys()):
            positions = by_val[v]
            dsu = DSU()
            # Union rows and columns for this value layer
            for i, j in positions:
                dsu.union(i, j + m)

            # Collect per-component rows, cols, and cells
            comp_rows: Dict[int, List[int]] = defaultdict(list)
            comp_cols: Dict[int, List[int]] = defaultdict(list)
            comp_cells: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
            for i, j in positions:
                root = dsu.find(i)  # row node representative is the component id
                comp_rows[root].append(i)
                comp_cols[root].append(j)
                comp_cells[root].append((i, j))

            # Compute rank per component
            staged_row: Dict[int, int] = {}
            staged_col: Dict[int, int] = {}
            for root in comp_cells:
                base = 0
                if comp_rows[root]:
                    base = max(base, max(rowMax[i] for i in comp_rows[root]))
                if comp_cols[root]:
                    base = max(base, max(colMax[j] for j in comp_cols[root]))
                r = base + 1
                for (i, j) in comp_cells[root]:
                    ans[i][j] = r
                    staged_row[i] = max(staged_row.get(i, 0), r)
                    staged_col[j] = max(staged_col.get(j, 0), r)

            # Apply updates for this layer
            for i, vmax in staged_row.items():
                rowMax[i] = max(rowMax[i], vmax)
            for j, vmax in staged_col.items():
                colMax[j] = max(colMax[j], vmax)

        return ans

# Exact 3 asserts
if __name__ == "__main__":
    s = Solution()
    assert s.matrixRankTransform([[1,2],[3,4]]) == [[1,2],[2,3]]
    assert s.matrixRankTransform([[7,7],[7,7]]) == [[1,1],[1,1]]
    assert s.matrixRankTransform([[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]) == [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
\end{minted}
\VALIDATION{Three asserts: the two small cases and the larger example from the statement.}
\RESULT{Returns the unique minimal rank assignment matrix consistent with row/column relative ordering and equality constraints, with ties resolved via connected components of equal values.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Use the official samples, degenerate shapes (1x1, 1xN, Mx1), all-equal matrices, strictly increasing rows/columns, and cases with repeated values forming multiple disconnected components at the same value.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A (BFS components) and Approach C (DSU) on random small matrices to ensure identical transforms.}
\LINE{EDGE-CASE GENERATOR}{Deterministically generate matrices with patterns: constant, stripes per row/col, chessboard equalities, and random small-range integers to induce many equal-value components.}
\begin{minted}{python}
from typing import List
import random

def gen_constant(m: int, n: int, v: int) -> List[List[int]]:
    return [[v for _ in range(n)] for _ in range(m)]

def gen_stripes_row(m: int, n: int) -> List[List[int]]:
    return [[i for _ in range(n)] for i in range(m)]

def gen_stripes_col(m: int, n: int) -> List[List[int]]:
    return [[j for j in range(n)] for _ in range(m)]

def gen_chessboard(m: int, n: int) -> List[List[int]]:
    return [[(i + j) % 2 for j in range(n)] for i in range(m)]

def gen_random(m: int, n: int, seed: int = 0, lo: int = -3, hi: int = 3) -> List[List[int]]:
    rnd = random.Random(seed)
    return [[rnd.randint(lo, hi) for _ in range(n)] for _ in range(m)]
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from collections import defaultdict
from typing import List, Dict, Tuple

class DSU:
    def __init__(self):
        self.parent: Dict[int, int] = {}
        self.rank: Dict[int, int] = {}

    def find(self, x: int) -> int:
        if x not in self.parent:
            self.parent[x] = x
            self.rank[x] = 0
            return x
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, a: int, b: int) -> None:
        ra, rb = self.find(a), self.find(b)
        if ra == rb:
            return
        if self.rank[ra] < self.rank[rb]:
            ra, rb = rb, ra
        self.parent[rb] = ra
        if self.rank[ra] == self.rank[rb]:
            self.rank[ra] += 1

class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0])
        ans = [[0] * n for _ in range(m)]
        by_val: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
        for i in range(m):
            for j in range(n):
                by_val[matrix[i][j]].append((i, j))
        rowMax = [0] * m
        colMax = [0] * n

        for v in sorted(by_val.keys()):
            positions = by_val[v]
            dsu = DSU()
            for i, j in positions:
                dsu.union(i, j + m)

            comp_rows: Dict[int, List[int]] = defaultdict(list)
            comp_cols: Dict[int, List[int]] = defaultdict(list)
            comp_cells: Dict[int, List[Tuple[int, int]]] = defaultdict(list)
            for i, j in positions:
                root = dsu.find(i)
                comp_rows[root].append(i)
                comp_cols[root].append(j)
                comp_cells[root].append((i, j))

            staged_row: Dict[int, int] = {}
            staged_col: Dict[int, int] = {}
            for root, cells in comp_cells.items():
                base = 0
                if comp_rows[root]:
                    base = max(base, max(rowMax[i] for i in comp_rows[root]))
                if comp_cols[root]:
                    base = max(base, max(colMax[j] for j in comp_cols[root]))
                r = base + 1
                for (i, j) in cells:
                    ans[i][j] = r
                    if r > staged_row.get(i, 0):
                        staged_row[i] = r
                    if r > staged_col.get(j, 0):
                        staged_col[j] = r

            for i, vmax in staged_row.items():
                if vmax > rowMax[i]:
                    rowMax[i] = vmax
            for j, vmax in staged_col.items():
                if vmax > colMax[j]:
                    colMax[j] = vmax

        return ans

# Self-checks for the reference code
if __name__ == "__main__":
    s = Solution()
    assert s.matrixRankTransform([[1,2],[3,4]]) == [[1,2],[2,3]]
    assert s.matrixRankTransform([[7,7],[7,7]]) == [[1,1],[1,1]]
    assert s.matrixRankTransform([[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]) == [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Assign minimal ranks respecting row/column monotonicity by sweeping values and unifying equal-value components per layer.}
\WHY{This tests graph modeling of constraints, union-find proficiency, and careful layer-wise state updates—common in advanced interview problems.}
\CHECKLIST{
- Group cells by value and sort values.
- For the current value, build DSU over involved rows and columns; union row $i$ with col $j+m$.
- For each DSU component, compute base via current rowMax/colMax; assign rank $= \text{base}+1$.
- After finishing the value layer, update rowMax/colMax.
- Do not mix updates across different values.}
\EDGECASES{
- Single cell matrix.
- All entries equal across the entire matrix.
- Entire row or column equal.
- Repeated values forming multiple disconnected components at the same value.
- Negative and positive values mixed.
- Long thin matrices (1xN, Mx1).
- Large identical blocks with bridges through equalities.}
\PITFALLS{
- Updating rowMax/colMax too early within a value layer, causing overestimation.
- Forgetting to tie equal values across rows/columns into the same component.
- Using global DSU across values (incorrect; unions must be per-layer).
- Off-by-one when computing rank $1+\max(\cdot)$.
- Performance hit by naively connecting all pairs in a row/col instead of using DSU or adjacency maps.
- Reusing DSU incorrectly without reinitialization per layer.
- Not handling duplicate row/col indices when computing component maxima.}
\FAILMODES{Naively assigning per-cell rank $1+\max(\text{rowMax}[i],\text{colMax}[j])$ without unifying equal-value components can yield unequal ranks within an equal-value connected component—violating constraints. The DSU/BFS component method avoids this.}
\ELI{Sort the numbers. For each number, group all same-number cells that are connected by sharing rows or columns. Give that group a rank one higher than anything smaller seen in those rows or columns. Repeat for bigger numbers.}
\NotePages{3}

\end{document}