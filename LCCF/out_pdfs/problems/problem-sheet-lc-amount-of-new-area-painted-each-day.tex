% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Amount of New Area Painted Each Day}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/amount-of-new-area-painted-each-day/}}
\LINE{DIFFICULTY / RATING}{hard}
\STATEMENT{You are given an array $paint$ where $paint[i] = [start_i, end_i]$ describes the interval painted on day $i$, using half-open intervals $[start_i, end_i)$ on the integer number line. Painting a point that was already painted earlier does not increase the newly painted area for that day.

For each day $i$, compute the number of integer points $x$ such that $x \in [start_i, end_i)$ and $x$ was not painted on any previous day. Return the array of these daily newly painted amounts.}
\BREAKDOWN{We must track the union of all previously painted integer points and, for each new half-open interval, count the contribution not already covered. The challenge is to support up to large coordinates and many days efficiently.}
\ELI{Keep a memory of painted spots and, each day, count how many fresh spots you cover.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array $paint$ of length $n$ where each entry is a pair of integers $[start, end]$ with $0 \le start < end \le 5 \times 10^5$. $1 \le n \le 10^5$. The coordinate domain is the set of integers.}
\OUTPUTS{An integer array $ans$ of length $n$ where $ans[i]$ is the count of previously unpainted integer points in $[start_i, end_i)$.}
\SAMPLES{Example 1: $paint = [[1,4],[4,7],[5,8]] \Rightarrow ans = [3,3,1]$.

Example 2: $paint = [[1,5],[2,4]] \Rightarrow ans = [4,0]$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $U_i$ denote the union of painted integer points after processing days $0$ through $i$. Initially $U_{-1} = \varnothing$. For day $i$ with $I_i = \{x \in \mathbb{Z} : start_i \le x < end_i\}$, we want $ans[i] = |I_i \setminus U_{i-1}|$ and then $U_i = U_{i-1} \cup I_i$.}
\varmapStart
\var{n}{number of days}
\var{I_i}{integer set of day $i$ interval $[start_i, end_i)$}
\var{U_i}{union of painted integer points up to and including day $i$}
\var{ans[i]}{newly painted count on day $i$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
ans[i] &= |I_i \setminus U_{i-1}|, \\
U_i &= U_{i-1} \cup I_i, \\
U_{-1} &= \varnothing.
\end{aligned}
\]
}
\ASSUMPTIONS{Intervals are half-open. The domain is integers. Days are processed in the given order.}
\INVARIANTS{The sets $U_i$ are nested: $U_{i-1} \subseteq U_i$. The $ans[i]$ are nonnegative integers and $\sum_i ans[i] = |U_{n-1}|$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Direct set membership: maintain a hash set of already painted integer points. For each day, iterate all $x$ in $[start, end)$, count those not in the set, and insert them.}
\ASSUMPTIONS{Coordinates are moderate enough for iteration; serves as a correctness baseline and for testing.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $S \leftarrow \varnothing$ as a set of painted integer points.
\item For each interval $[s,e)$, iterate $x = s,\ldots,e-1$:
  if $x \notin S$, insert it and increment the daily counter.
\item Append the daily counter to the answer array.
\end{algosteps}
\COMPLEXITY{Let $L_i = end_i - start_i$. Time $T(n) = \sum_i O(L_i)$ and space $S(n) = O(|U_{n-1}|)$. This is too slow if coordinates span large gaps with many days.}
\[
\begin{aligned}
T(n) &= \sum_{i=0}^{n-1} (end_i - start_i), \\
S(n) &= |U_{n-1}|.
\end{aligned}
\]
\CORRECTNESS{Every integer point is counted exactly once, at the first day it is painted, because subsequent checks find it present in $S$.}
\EDGECASES{Single-point width is impossible since $start < end$. Adjacent intervals like $[a,b)$ and $[b,c)$ share no overlap. Large gaps do not affect correctness, only performance.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def amountPainted(self, paint: List[List[int]]) -> List[int]:
        seen = set()
        ans: List[int] = []
        for s, e in paint:
            new = 0
            for x in range(s, e):
                if x not in seen:
                    seen.add(x)
                    new += 1
            ans.append(new)
        return ans

# Baseline sanity checks
sol = Solution()
assert sol.amountPainted([[1, 4], [4, 7], [5, 8]]) == [3, 3, 1]
assert sol.amountPainted([[1, 5], [2, 4]]) == [4, 0]
assert sol.amountPainted([[0, 1], [0, 1], [0, 1]]) == [1, 0, 0]
\end{minted}
\VALIDATION{The asserts cover overlap, containment, and repeated identical intervals.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Maintain Disjoint Interval Union with Binary Search}
\WHICHFORMULA{Store the union of painted points as a sorted list of disjoint half-open intervals. For each new $[s,e)$, find overlapping neighbors via binary search, compute overlap length to subtract, then merge into the union.}
\ASSUMPTIONS{Intervals remain disjoint and sorted; adjacency is merged to keep invariant.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain a sorted list $J$ of disjoint half-open intervals representing the painted union.
\item For day interval $[s,e)$, use binary search to locate the first possibly overlapping interval.
\item Sweep and collect all intervals in $J$ that overlap or touch $[s,e)$, computing the total overlap with the original $[s,e)$.
\item New paint is $(e-s) - \text{overlap}$. Replace those intervals by the merged hull of them with $[s,e)$.
\end{algosteps}
\COMPLEXITY{Each day touches and merges only overlapping neighbors. Let $k_i$ be the number of merged intervals at day $i$; per day cost is $O(k_i + \log m)$ where $m$ is current number of components. In worst-case adversarial sequences this can be linear, but typical is much faster than brute force.}
\[
\begin{aligned}
T(n) &= \sum_i O(k_i + \log m_i), \\
S(n) &= O(m) \text{ intervals}.
\end{aligned}
\]
\CORRECTNESS{The maintained union $J$ is always exactly the set $U_i$. Overlap is subtracted precisely because the intervals in $J$ are disjoint and cover exactly the already painted points.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import bisect

class Solution:
    def amountPainted(self, paint: List[List[int]]) -> List[int]:
        # J stores disjoint, sorted half-open intervals [l, r)
        J: List[List[int]] = []
        ans: List[int] = []
        for s, e in paint:
            ps, pe = s, e  # preserve original interval for overlap calculation
            # Find insertion index by start
            i = bisect.bisect_left(J, [s, s])
            # Extend search one step left to catch potential overlap/touch
            if i > 0:
                i -= 1
            overlap = 0
            new_l, new_r = s, e
            # Collect indices to merge
            merged_indices = []
            j = i
            while j < len(J):
                l, r = J[j]
                if r < s and r < e:
                    j += 1
                    continue
                if l > e:
                    break
                # If they touch or overlap
                if r >= s and l <= e:
                    overlap += max(0, min(pe, r) - max(ps, l))
                    new_l = min(new_l, l)
                    new_r = max(new_r, r)
                    merged_indices.append(j)
                j += 1
            # Remove merged intervals from J
            for idx in reversed(merged_indices):
                J.pop(idx)
            # Insert merged hull
            ins = bisect.bisect_left(J, [new_l, new_l])
            J.insert(ins, [new_l, new_r])
            ans.append((pe - ps) - overlap)
        return ans

# Improved sanity checks
sol = Solution()
assert sol.amountPainted([[1, 4], [4, 7], [5, 8]]) == [3, 3, 1]
assert sol.amountPainted([[1, 5], [2, 4]]) == [4, 0]
assert sol.amountPainted([[1, 2], [3, 4], [2, 3]]) == [1, 1, 1]
\end{minted}
\VALIDATION{Covers overlapping, nested, and adjacent intervals.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Disjoint-Set ``Next Unpainted'' Jump Pointers}
\WHICHFORMULA{Use a map $parent$ implementing a union-find over integer points where $find(x)$ returns the smallest unpainted $y \ge x$. When painting $[s,e)$, repeatedly jump to $x = find(s)$, paint it, and union it to $x+1$, until $x \ge e$. This skips already painted runs in near-constant amortized time.}
\ASSUMPTIONS{Path compression on a sparse dictionary over touched positions yields almost-linear time in the number of newly painted points.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain dictionary $parent$ where a key $x$ exists iff $x$ is painted, with $parent[x] = x+1$ initially when $x$ becomes painted.
\item Define $find(x)$: if $x \notin parent$, return $x$; else compress path with $parent[x] \leftarrow find(parent[x])$.
\item For $[s,e)$: set $x \leftarrow find(s)$. While $x < e$, set $parent[x] \leftarrow x+1$ (mark painted), increment the daily counter, then $x \leftarrow find(x)$ and repeat.
\end{algosteps}
\OPTIMALITY{Each integer point is painted at most once and then participates in $O(1)$ amortized $find$ operations due to path compression. Thus total time is $O(\sum_i ans[i] \cdot \alpha(N))$ where $\alpha$ is the inverse Ackermann function and $N$ is the coordinate span touched. This is optimal up to near-constant factors because any algorithm must at least account for each newly painted unit once.}
\COMPLEXITY{Let $M = \sum_i ans[i] = |U_{n-1}|$.}
\[
\begin{aligned}
T(n) &= O\big(M \cdot \alpha(M)\big), \\
S(n) &= O(M).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Dict

class Solution:
    def amountPainted(self, paint: List[List[int]]) -> List[int]:
        parent: Dict[int, int] = {}

        def find(x: int) -> int:
            # Returns smallest y >= x that is not yet painted
            if x not in parent:
                return x
            parent[x] = find(parent[x])
            return parent[x]

        ans: List[int] = []
        for s, e in paint:
            new = 0
            x = find(s)
            while x < e:
                parent[x] = x + 1  # paint x; next candidate is x+1
                new += 1
                x = find(x)  # jump to next unpainted
            ans.append(new)
        return ans

# Exact 3 asserts
sol = Solution()
assert sol.amountPainted([[1, 4], [4, 7], [5, 8]]) == [3, 3, 1]
assert sol.amountPainted([[1, 5], [2, 4]]) == [4, 0]
assert sol.amountPainted([[1, 7], [2, 6], [3, 5], [1, 7]]) == [6, 0, 0, 0]
\end{minted}
\VALIDATION{The asserts include overlap chains, containment, and a final full-cover operation yielding zero.}
\RESULT{Returns the daily amounts of newly painted integer points for each half-open interval, with no tie-breaking needed.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on typical patterns: disjoint, adjacent, nested, repeated, and interleaved intervals. Property-based cross-check on small random cases comparing brute force vs.\ optimal.}
\LINE{CROSS-CHECKS}{For small coordinate ranges, compare Approach A and C outputs to ensure identical results. For medium ranges, compare Approach B and C.}
\LINE{EDGE-CASE GENERATOR}{Generates random intervals with varying lengths, including degenerate adjacency and full containment, to stress merging and jumping.}
\begin{minted}{python}
from typing import List
import random

# Deterministic generators for boundaries, degenerates, adversarials
def gen_small_cases(seed: int = 7) -> List[List[List[int]]]:
    random.seed(seed)
    cases = []
    # Hand-crafted edges
    cases.append([[0, 1]])
    cases.append([[0, 3], [3, 6], [1, 5]])
    cases.append([[2, 5], [2, 5], [2, 5]])
    cases.append([[0, 10], [1, 9], [2, 8], [3, 7]])
    # Random small ranges to enable brute-force checking
    for _ in range(5):
        n = random.randint(1, 8)
        arr = []
        for __ in range(n):
            a = random.randint(0, 12)
            b = random.randint(a + 1, 15)
            arr.append([a, b])
        cases.append(arr)
    return cases

# Reference brute force (Approach A)
class RefBrute:
    def amountPainted(self, paint: List[List[int]]) -> List[int]:
        seen = set()
        ans = []
        for s, e in paint:
            new = 0
            for x in range(s, e):
                if x not in seen:
                    seen.add(x)
                    new += 1
            ans.append(new)
        return ans

# Optimal (Approach C)
class RefOptimal:
    def amountPainted(self, paint: List[List[int]]) -> List[int]:
        parent = {}
        def find(x: int) -> int:
            if x not in parent:
                return x
            parent[x] = find(parent[x])
            return parent[x]
        ans = []
        for s, e in paint:
            new = 0
            x = find(s)
            while x < e:
                parent[x] = x + 1
                new += 1
                x = find(x)
            ans.append(new)
        return ans

def run_cross_checks():
    brute = RefBrute()
    opt = RefOptimal()
    for tc in gen_small_cases():
        assert brute.amountPainted(tc) == opt.amountPainted(tc)

if __name__ == "__main__":
    run_cross_checks()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Dict

class Solution:
    def amountPainted(self, paint: List[List[int]]) -> List[int]:
        parent: Dict[int, int] = {}

        def find(x: int) -> int:
            if x not in parent:
                return x
            parent[x] = find(parent[x])
            return parent[x]

        ans: List[int] = []
        for s, e in paint:
            new = 0
            x = find(s)
            while x < e:
                parent[x] = x + 1
                new += 1
                x = find(x)
            ans.append(new)
        return ans

# Quick self-checks
if __name__ == "__main__":
    sol = Solution()
    assert sol.amountPainted([[1, 4], [4, 7], [5, 8]]) == [3, 3, 1]
    assert sol.amountPainted([[1, 5], [2, 4]]) == [4, 0]
    assert sol.amountPainted([[0, 1], [0, 1], [0, 1]]) == [1, 0, 0]
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Compute new coverage per half-open interval while maintaining the union of painted integer points.}
\WHY{Tests fast set-union maintenance and DSU path compression tricks common in advanced interval and coverage problems.}
\CHECKLIST{Track that intervals are half-open; consider adjacency; avoid per-unit iteration by skipping painted blocks; ensure path compression in $find$.}
\EDGECASES{Adjacent intervals $[a,b)$ and $[b,c)$; fully nested intervals; repeated identical intervals; large first interval followed by small ones; out-of-order coverage with gaps; single day; maximal coordinate near limits; many days painting nothing new.}
\PITFALLS{Treating intervals as closed and off-by-one errors; forgetting to merge adjacency in the improved approach; missing path compression leading to timeouts; modifying a list while iterating without careful index management; integer overflow is not a concern in Python but be careful in other languages; forgetting that end is exclusive.}
\FAILMODES{Brute force times out on large coordinates; naive sweep without skipping painted runs is too slow; binary search union approach can degrade if repeatedly merging near the front without careful deletions. The DSU jump-pointer approach survives by skipping painted segments in near-constant time.}
\ELI{Remember that painting a number more than once does not help. The optimal trick keeps a pointer from each painted number to the next candidate so you can hop over long painted stretches quickly.}
\NotePages{3}

\end{document}