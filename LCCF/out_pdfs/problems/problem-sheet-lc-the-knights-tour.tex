% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — The Knight’s Tour}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/the-knights-tour/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{You are given an \(n \times n\) integer matrix \(\texttt{grid}\) that contains each integer from \(0\) to \(n^2-1\) exactly once. The value \(k\) indicates the step number in a proposed knight tour, where the tour must start at the top left cell so \(\texttt{grid}[0][0] = 0\). Return \(\texttt{True}\) if \(\texttt{grid}\) encodes a valid knight tour and \(\texttt{False}\) otherwise. A knight move between consecutive steps \(k\) and \(k+1\) means the positions differ by \((\lvert\Delta r\rvert,\lvert\Delta c\rvert) \in \{(1,2),(2,1)\}\).}
\BREAKDOWN{Check that the start is at \((0,0)\), map each label \(k\) to its position, and verify that every consecutive pair \(k \to k+1\) is a legal knight move within the board.}
\ELI{Turn the numbered board into a position list and make sure every step moves like a chess knight.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One square matrix \(\texttt{grid}\) of shape \(n \times n\) with integers. Valid ranges: \(1 \le n \le 500\), and values are intended to be a permutation of \(\{0,1,\ldots,n^2-1\}\).}
\OUTPUTS{A boolean: \(\texttt{True}\) if \(\texttt{grid}\) describes a valid knight tour starting at \((0,0)\), else \(\texttt{False}\).}
\SAMPLES{Example 1: \(n=1\). \(\texttt{grid} = [[0]] \Rightarrow \texttt{True}\). Example 2: \(n=3\). \(\texttt{grid} = \begin{bmatrix}0&1&2\\3&4&5\\6&7&8\end{bmatrix}\Rightarrow \texttt{False}\) because adjacent labels are not knight moves.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let \(V = \{(r,c) : 0 \le r,c < n\}\) be cells of the board and \(E = \{((r,c),(r',c')) : (\lvert r-r'\rvert,\lvert c-c'\rvert)\in\{(1,2),(2,1)\}\}\) the knight move edges. The input \(\texttt{grid}\) induces a bijection \(p : \{0,\ldots,n^2-1\} \to V\) where \(p(k)\) is the unique position of label \(k\). The predicate to check is: \(p(0)=(0,0)\) and \((p(k),p(k+1)) \in E\) for all \(k \in \{0,\ldots,n^2-2\}\).}
\varmapStart
\var{n}{board side length}
\var{\texttt{grid}}{given \(n \times n\) labeling}
\var{p(k)}{position \((r,c)\) where \(\texttt{grid}[r][c]=k\)}
\var{E}{set of legal knight moves}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Start: } p(0)=(0,0).\\
&\text{Adjacency: } \forall k \in \{0,\ldots,n^2-2\}:\quad (\Delta r,\Delta c) = (\,\lvert r_k-r_{k+1}\rvert,\,\lvert c_k-c_{k+1}\rvert\,) \in \{(1,2),(2,1)\},\\
&\text{where } p(k)=(r_k,c_k),\ p(k+1)=(r_{k+1},c_{k+1}).
\end{aligned}
\]
}
\ASSUMPTIONS{The matrix is square; indices are zero based; values should be within \([0,n^2-1]\) without repetition for a valid tour.}
\INVARIANTS{Labels are unique and within bounds; the knight move metric never yields \((0,0)\), and never leaves the board.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Directly realize the predicate by searching the entire board for each label \(k\) and \(k+1\), then checking the knight move condition.}
\ASSUMPTIONS{No preprocessing; tolerate duplicates or out of range numbers by failing when some \(k\) or \(k+1\) is not found.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Verify \(\texttt{grid}\) is square and \(\texttt{grid}[0][0]=0\).
\item For each \(k=0,\ldots,n^2-2\): linearly scan all cells to find the positions of \(k\) and \(k+1\).
\item Check \((\lvert\Delta r\rvert,\lvert\Delta c\rvert)\in\{(1,2),(2,1)\}\). If any step fails, return \(\texttt{False}\); else return \(\texttt{True}\).
\end{algosteps}
\COMPLEXITY{A full board scan per step yields \(T(n)=\Theta(n^2)\) work repeated \(\Theta(n^2)\) times.}
\[
\begin{aligned}
T(n) &= \sum_{k=0}^{n^2-2} \Theta(n^2) \\
     &= \Theta(n^4),\quad S(n)=\Theta(1).
\end{aligned}
\]
\CORRECTNESS{If the algorithm returns \(\texttt{True}\), then for each \(k\) both positions exist and are a legal knight move apart, and the start is at \((0,0)\), exactly matching the model. If any requirement is violated, it detects either a missing label or an illegal offset and returns \(\texttt{False}\).}
\EDGECASES{\(n=1\) must be \(\texttt{True}\) only if the single cell is \(0\). Any case where \(\texttt{grid}[0][0]\neq 0\) is \(\texttt{False}\). Non square input or missing labels cause \(\texttt{False}\).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        if n == 0:
            return False
        # Ensure square
        if any(len(row) != n for row in grid):
            return False
        # Start condition
        if grid[0][0] != 0:
            return False

        def find_value(val: int) -> Tuple[int, int] | None:
            for r in range(n):
                row = grid[r]
                for c in range(n):
                    if row[c] == val:
                        return (r, c)
            return None

        total = n * n
        for k in range(total - 1):
            a = find_value(k)
            b = find_value(k + 1)
            if a is None or b is None:
                return False
            r1, c1 = a
            r2, c2 = b
            dr, dc = abs(r1 - r2), abs(c1 - c2)
            if not ((dr == 1 and dc == 2) or (dr == 2 and dc == 1)):
                return False
        return True

# --- baseline quick asserts ---
sol = Solution()
assert sol.checkValidGrid([[0]]) is True
assert sol.checkValidGrid([[1]]) is False
assert sol.checkValidGrid([[0,1,2],[3,4,5],[6,7,8]]) is False
\end{minted}
\VALIDATION{Trivially correct on \(n=1\). Fails when the start is not \(0\). Rejects a monotone fill on \(3\times 3\) because differences are not knight moves.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Index Map and Early Rejections}
\WHICHFORMULA{Precompute the inverse mapping \(p(k)\) in one pass and then verify adjacency in a single linear pass. Also detect out of range values and duplicates.}
\ASSUMPTIONS{Values should lie in \([0,n^2-1]\). Use a visited bitset to catch duplicates while building \(p\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If not square or \(\texttt{grid}[0][0]\neq 0\), return \(\texttt{False}\).
\item Allocate an array \(\texttt{pos}\) of length \(n^2\) and a boolean \(\texttt{seen}\) of length \(n^2\).
\item Scan all cells: if a value \(v\) is out of range or already seen, return \(\texttt{False}\); else set \(\texttt{pos}[v]=(r,c)\) and mark seen.
\item For \(k=0,\ldots,n^2-2\), check that \(\texttt{pos}[k]\) and \(\texttt{pos}[k+1]\) differ by \((1,2)\) or \((2,1)\).
\end{algosteps}
\COMPLEXITY{One pass to build positions and one to verify transitions. This is optimal up to reading the input.}
\[
\begin{aligned}
T(n) &= \Theta(n^2) + \Theta(n^2) = \Theta(n^2),\quad S(n)=\Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{The inverse map ensures each label is present exactly once and within bounds. The adjacency scan enforces the knight move constraint for every consecutive pair, matching the governing predicate.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        if n == 0:
            return False
        if any(len(row) != n for row in grid):
            return False
        if grid[0][0] != 0:
            return False

        total = n * n
        pos: List[Tuple[int, int]] = [(-1, -1)] * total
        seen = [False] * total

        # Build inverse mapping with validation
        for r in range(n):
            row = grid[r]
            for c in range(n):
                v = row[c]
                if not (0 <= v < total):
                    return False
                if seen[v]:
                    return False
                seen[v] = True
                pos[v] = (r, c)

        # Ensure all labels 0..n^2-1 occurred exactly once
        if not all(seen):
            return False

        # Verify knight moves between consecutive labels
        for k in range(total - 1):
            r1, c1 = pos[k]
            r2, c2 = pos[k + 1]
            dr, dc = abs(r1 - r2), abs(c1 - c2)
            if not ((dr == 1 and dc == 2) or (dr == 2 and dc == 1)):
                return False
        return True

# --- improved quick asserts ---
sol = Solution()
assert sol.checkValidGrid([[0]]) is True
assert sol.checkValidGrid([[0, 1], [2, 3]]) is False
assert sol.checkValidGrid([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) is False
\end{minted}
\VALIDATION{Rejects duplicates, out of range entries, non square input, wrong start, and any illegal consecutive offset. Accepts the single cell tour.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Linear-Time Verification with Constant-Factor Optimizations}
\WHICHFORMULA{Same inverse map idea but use tiny helpers and early exits to minimize constant factors; this is asymptotically optimal because any algorithm must at least read all \(n^2\) entries.}
\ASSUMPTIONS{Square matrix, zero based indexing, and the tour must begin at \((0,0)\).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Early exit on non square or wrong start.
\item Single linear pass to validate range and uniqueness while filling \(\texttt{pos}\).
\item Linear pass to assert the knight offset on each consecutive pair.
\end{algosteps}
\OPTIMALITY{Lower bound \(\Omega(n^2)\) for reading input. The algorithm achieves \(O(n^2)\) time with \(O(n^2)\) auxiliary space, which is tight for explicit position indexing.}
\COMPLEXITY{Time \(T(n)=\Theta(n^2)\); space \(S(n)=\Theta(n^2)\).}
\[
\begin{aligned}
T(n) &= \Theta(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        if n == 0 or any(len(row) != n for row in grid):
            return False
        if grid[0][0] != 0:
            return False

        total = n * n
        pos: List[Tuple[int, int]] = [(-1, -1)] * total
        seen = [False] * total

        # Build mapping and validate values
        for r in range(n):
            row = grid[r]
            for c in range(n):
                v = row[c]
                if v < 0 or v >= total or seen[v]:
                    return False
                seen[v] = True
                pos[v] = (r, c)

        # Verify adjacency
        for k in range(total - 1):
            r1, c1 = pos[k]
            r2, c2 = pos[k + 1]
            dr = r1 - r2
            if dr < 0:
                dr = -dr
            dc = c1 - c2
            if dc < 0:
                dc = -dc
            if not ((dr == 1 and dc == 2) or (dr == 2 and dc == 1)):
                return False

        return True

# --- exactly 3 asserts (final) ---
sol = Solution()
assert sol.checkValidGrid([[0]]) is True
assert sol.checkValidGrid([[0, 1], [2, 3]]) is False
assert sol.checkValidGrid([[0, 2], [3, 1]]) is False  # wrong start adjacency
\end{minted}
\VALIDATION{Three asserts cover the trivial valid case, a small impossible layout, and a case with an incorrect consecutive move.}
\RESULT{Returns \(\texttt{True}\) if and only if the labeling forms a valid knight tour path starting from the top left cell.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover trivial \(n=1\), wrong start, out of range values, duplicates, and illegal offsets. Property check: random small boards almost always fail due to duplicates or adjacency violations.}
\LINE{CROSS-CHECKS}{Compare outputs of the baseline \(O(n^4)\) and improved \(O(n^2)\) methods on small random boards to ensure agreement.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial matrices with subtle violations such as swapping a single pair \(k\) and \(k+2\), or injecting a duplicate number and removing another.}
\begin{minted}{python}
from typing import List
import random

class Baseline:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        if n == 0 or any(len(row) != n for row in grid):
            return False
        if grid[0][0] != 0:
            return False

        def find(v: int):
            for r in range(n):
                for c in range(n):
                    if grid[r][c] == v:
                        return (r, c)
            return None

        total = n * n
        for k in range(total - 1):
            a = find(k)
            b = find(k + 1)
            if a is None or b is None:
                return False
            r1, c1 = a
            r2, c2 = b
            dr, dc = abs(r1 - r2), abs(c1 - c2)
            if not ((dr == 1 and dc == 2) or (dr == 2 and dc == 1)):
                return False
        return True

class Reference:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        if n == 0 or any(len(row) != n for row in grid):
            return False
        if grid[0][0] != 0:
            return False
        total = n * n
        pos = [(-1, -1)] * total
        seen = [False] * total
        for r in range(n):
            for c in range(n):
                v = grid[r][c]
                if not (0 <= v < total) or seen[v]:
                    return False
                seen[v] = True
                pos[v] = (r, c)
        for k in range(total - 1):
            r1, c1 = pos[k]
            r2, c2 = pos[k + 1]
            dr, dc = abs(r1 - r2), abs(c1 - c2)
            if not ((dr == 1 and dc == 2) or (dr == 2 and dc == 1)):
                return False
        return True

# Cross-check on deterministic random cases
rng = random.Random(0)
for n in range(1, 6):
    for _ in range(10):
        vals = list(range(n * n))
        rng.shuffle(vals)
        grid = [vals[i * n:(i + 1) * n] for i in range(n)]
        assert Baseline().checkValidGrid(grid) == Reference().checkValidGrid(grid)

# Adversarial tweaks
ref = Reference()
# duplicate injection
assert ref.checkValidGrid([[0, 0], [2, 3]]) is False
# out-of-range
assert ref.checkValidGrid([[0, 5], [1, 2]]) is False
# trivial success
assert ref.checkValidGrid([[0]]) is True
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        if n == 0 or any(len(row) != n for row in grid):
            return False
        if grid[0][0] != 0:
            return False

        total = n * n
        pos: List[Tuple[int, int]] = [(-1, -1)] * total
        seen = [False] * total

        for r in range(n):
            row = grid[r]
            for c in range(n):
                v = row[c]
                if v < 0 or v >= total or seen[v]:
                    return False
                seen[v] = True
                pos[v] = (r, c)

        for k in range(total - 1):
            r1, c1 = pos[k]
            r2, c2 = pos[k + 1]
            dr, dc = abs(r1 - r2), abs(c1 - c2)
            if not ((dr == 1 and dc == 2) or (dr == 2 and dc == 1)):
                return False

        return True

# sanity asserts
if __name__ == "__main__":
    sol = Solution()
    assert sol.checkValidGrid([[0]]) is True
    assert sol.checkValidGrid([[0, 1], [2, 3]]) is False
    assert sol.checkValidGrid([[1, 0], [2, 3]]) is False
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Verify a knight tour by inverting the grid into positions and checking consecutive knight moves from \((0,0)\).}
\WHY{A classic board path verification that tests mapping, indexing, and careful validation under time pressure.}
\CHECKLIST{%
\begin{bullets}
\item Check square shape and \(\texttt{grid}[0][0]=0\).
\item Build inverse map with bounds and duplicate checks.
\item Verify each consecutive step uses a knight move.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item \(n=1\) with \([0]\) is \(\texttt{True}\); any other single value is \(\texttt{False}\).
\item Non square matrices.
\item Values outside \([0,n^2-1]\).
\item Duplicated values and missing values.
\item Correct values but wrong start position.
\item Exactly one illegal transition in the middle.
\item Large \(n\) performance adherence to \(O(n^2)\).
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting to check \(\texttt{grid}[0][0]=0\).
\item Assuming uniqueness without validating duplicates.
\item Off by one on the last transition \(k=n^2-2\).
\item Swapped \(\Delta r,\Delta c\) logic; must be \((1,2)\) or \((2,1)\).
\item Not guarding out of range labels.
\item Early returning \(\texttt{True}\) without confirming all labels were seen.
\end{bullets}
}
\FAILMODES{Random permutations will usually be rejected; crafted duplicates or out of range values can trick naive checkers that skip validation. The improved method detects these reliably.}
\ELI{Make a list of where each number sits, then verify that you always jump like a knight from number \(k\) to \(k+1\), starting at the top left. If anything is off, answer \(\texttt{False}\).}
\NotePages{3}

\end{document}