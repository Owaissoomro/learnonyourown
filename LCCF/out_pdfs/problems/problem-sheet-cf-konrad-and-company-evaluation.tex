% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Konrad and Company Evaluation}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1210/D}}
\LINE{DIFFICULTY / RATING}{2400}
\STATEMENT{Konrad is a Human Relations consultant working for VoltModder, a large electrical equipment producer. Today, he has been tasked with evaluating the level of happiness in the company.

There are $n$ people working for VoltModder, numbered from $1$ to $n$. Each employee earns a different amount of money in the company — initially, the $i$-th person earns $i$ rubles per day.

On each of $q$ following days, the salaries will be revised. At the end of the $i$-th day, employee $v_i$ will start earning $n+i$ rubles per day and will become the best-paid person in the company. The employee will keep his new salary until it gets revised again.

Some pairs of people do not like each other. This creates a great psychological danger in the company. Formally, if two people $a$ and $b$ dislike each other and $a$ earns more money than $b$, employee $a$ will brag about this to $b$. A dangerous triple is a triple of three employees $a$, $b$ and $c$, such that $a$ brags to $b$, who in turn brags to $c$. If $a$ dislikes $b$, then $b$ dislikes $a$.

At the beginning of each day, Konrad needs to evaluate the number of dangerous triples in the company. Can you help him do it?

Input:
The first line contains two integers $n$ and $m$ ($1 \le n \le 100{,}000$, $0 \le m \le 100{,}000$) — the number of employees in the company and the number of pairs of people who do not like each other. Each of the following $m$ lines contains two integers $a_i$, $b_i$ ($1 \le a_i, b_i \le n$, $a_i \ne b_i$) denoting that employees $a_i$ and $b_i$ hate each other (that is, $a_i$ dislikes $b_i$ and $b_i$ dislikes $a_i$). Each such relationship will be mentioned exactly once.

The next line contains an integer $q$ ($0 \le q \le 100{,}000$) — the number of salary revisions. The $i$-th of the following $q$ lines contains a single integer $v_i$ ($1 \le v_i \le n$) denoting that at the end of the $i$-th day, employee $v_i$ will earn the most.

Output:
Output $q + 1$ integers. The $i$-th of them should contain the number of dangerous triples in the company at the beginning of the $i$-th day.

Note:
Consider the first sample test. The $i$-th row in the following image shows the structure of the company at the beginning of the $i$-th day. A directed edge from $a$ to $b$ denotes that employee $a$ brags to employee $b$. The dangerous triples are marked by highlighted edges.}
\BREAKDOWN{Orient each undirected dislike edge from the richer to the poorer. The number of dangerous triples equals the number of directed paths of length $2$. Maintain this count under operations that move one vertex to be strictly richest.}
\ELI{Count all ``middle'' employees $b$ with one richer neighbor and one poorer neighbor; sum $\text{in}(b)\times \text{out}(b)$. On each promotion, only edges incident to the promoted employee can change direction.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{
- $n$ (int), $m$ (int): $1 \le n \le 100{,}000$, $0 \le m \le 100{,}000$.\\
- $m$ pairs $(a_i,b_i)$ with $1 \le a_i,b_i \le n$, $a_i \ne b_i$, all distinct as sets.\\
- $q$ (int), $0 \le q \le 100{,}000$.\\
- $q$ integers $v_i$ with $1 \le v_i \le n$.
}
\OUTPUTS{
- $q+1$ integers: the number of dangerous triples at the beginning of each day (before applying that day's promotion). Each may be printed on its own line or space-separated.
}
\SAMPLES{
Example: $n=3$, $m=2$, edges: $(1,2)$, $(2,3)$, $q=1$, $v_1=2$.\\
Day 1 start: salaries $1<2<3$, orientation $3\to 2\to 1$, one triple $\{3,2,1\}$ $\Rightarrow 1$.\\
After promoting $2$: orientation $2\to 1$, $2\to 3$, no path of length $2$ $\Rightarrow 0$. Output: $1~0$.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{
Let $G=(V,E)$ be a simple undirected graph on $|V|=n$ employees. Each day induces a strict total order $\prec$ on $V$ by salary (break ties by employee index). Orient each undirected edge $\{u,v\}$ as a directed edge from the higher-salary endpoint to the lower-salary endpoint. A dangerous triple is a directed path of length $2$, i.e., $a\to b\to c$.
}
\varmapStart
\var{d(v)}{undirected degree of $v$}
\var{h(v)}{number of neighbors richer than $v$ (in-degree in oriented graph)}
\var{\ell(v)}{number of neighbors poorer than $v$ (out-degree in oriented graph), so $\ell(v)=d(v)-h(v)$}
\var{T}{number of dangerous triples}
\var{t(v)}{last promotion day of $v$ (initially $0$); order by $(t(v),v)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
T \;=\; \sum_{v\in V} h(v)\,\ell(v), \qquad \ell(v)=d(v)-h(v).
\end{BreakableEquation*}
}
\ASSUMPTIONS{
- The order $\prec$ is strict: all salaries are distinct by construction.\\
- Graph is simple: no self-loops, no multi-edges.\\
- Promotion at day $i$ sets $t(v_i)=i$ and makes $v_i$ the unique maximum in $(t(\cdot),\cdot)$.
}
\INVARIANTS{
- For every $v$, $0 \le h(v) \le d(v)$ and $0 \le \ell(v) \le d(v)$.\\
- $T$ equals the number of directed paths of length $2$ since each such path is uniquely identified by its middle vertex $b$ and a choice of one richer and one poorer neighbor.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use $T=\sum_v h(v)\ell(v)$. Recompute $h(v)$ and $\ell(v)$ from scratch each day by scanning all edges and comparing the current order keys $(t(u),u)$.}
\ASSUMPTIONS{Each day, we can recompute in $O(n+m)$ time. Suitable as a correctness baseline and for tiny inputs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain $t(v)$ for all $v$; initially $0$.
\item At the beginning of each day, compute $h(v)$ by iterating all edges $\{u,v\}$ and directing towards the smaller key in lex order $(t(\cdot),\cdot)$.
\item Compute $T=\sum_v h(v)\,(d(v)-h(v))$. Output $T$.
\item After output, apply the day's promotion: set $t(v_i)=i$.
\end{algosteps}
\COMPLEXITY{For $q$ days,
\[
\begin{aligned}
T(n,m,q) &= O\big((q+1)\,(n+m)\big), \\
S(n,m) &= O(n+m).
\end{aligned}
\]
}
\CORRECTNESS{Every edge orientation is recomputed exactly according to the current total order; $h,\ell$ match the definition, and the sum formula is exact.}
\EDGECASES{No edges ($m=0$) gives $T=0$. All promotions can repeat a vertex; still well-defined.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF TEMPLATE (must include read_input / solve_case / main + guard + asserts)
from typing import List, Tuple
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    edges = [[] for _ in range(n)]
    undirected = []
    for _ in range(m):
        a = int(next(it)) - 1
        b = int(next(it)) - 1
        edges[a].append(b)
        edges[b].append(a)
        undirected.append((a, b))
    q = int(next(it))
    v = [int(next(it)) - 1 for _ in range(q)]
    return n, m, edges, undirected, q, v

def recompute_T(n: int, undirected: List[Tuple[int,int]], t: List[int]) -> int:
    h = [0]*n
    deg = [0]*n
    for (a,b) in undirected:
        deg[a] += 1
        deg[b] += 1
        # Higher is max by (t, id)
        if (t[a], a) > (t[b], b):
            # a -> b, so h[b] += 1
            h[b] += 1
        else:
            h[a] += 1
    T = 0
    for i in range(n):
        l = deg[i] - h[i]
        T += h[i] * l
    return T

def solve_all_baseline(data: str) -> str:
    n, m, edges, undirected, q, v = read_input(data)
    t = [0]*n
    out = []
    out.append(str(recompute_T(n, undirected, t)))
    for day, x in enumerate(v, start=1):
        t[x] = day
        out.append(str(recompute_T(n, undirected, t)))
    return "\n".join(out)

def _test_baseline():
    data = """3 2
1 2
2 3
1
2
"""
    got = solve_all_baseline(data).strip().split()
    assert got == ["1","0"]
    # Single node, no edges, many promotions
    data = """1 0
0
"""
    got = solve_all_baseline(data).strip().split()
    assert got == ["0"]
    # Square 1-2-3-4 cycle, 2 promotions
    data = """4 4
1 2
2 3
3 4
4 1
2
2
3
"""
    # Just sanity: non-negative and integers
    out = list(map(int, solve_all_baseline(data).strip().split()))
    assert len(out) == 3

if __name__ == "__main__":
    _test_baseline()
    # For local run:
    # print(solve_all_baseline(sys.stdin.read()))
\end{minted}
\VALIDATION{Included asserts on tiny graphs. Cross-check non-negativity and count length.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Maintain $T=\sum_v h(v)\ell(v)$ incrementally. Store for each vertex $v$ the list $\text{up}[v]$ of its current richer neighbors (incoming in-degree endpoints), i.e., neighbors $u$ with $(t(u),u)>(t(v),v)$. On promoting $v$, only edges $(u,v)$ with $u\in \text{up}[v]$ flip; we can update $h,\ell$ and $T$ by scanning $\text{up}[v]$ and moving $v$ to $\text{up}[u]$.}
\ASSUMPTIONS{This maintains a partition of edges: each undirected edge $\{u,v\}$ is stored exactly once in $\text{up}[\min_{\prec}\{u,v\}]$ (the current poorer endpoint). Promoting $v$ relinks exactly the edges in $\text{up}[v]$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency. Initialize $\text{up}[v]=\{u\in N(v)\mid (0,u)>(0,v)\}$, i.e., neighbors with larger index.
\item Set $h(v)=|\text{up}[v]|$, $\ell(v)=d(v)-h(v)$, and $T=\sum_v h(v)\ell(v)$.
\item To promote $v$: subtract $h(v)\ell(v)$ from $T$. For each $u\in \text{up}[v]$:
  \begin{bullets}
  \item Subtract $h(u)\ell(u)$ from $T$.
  \item Update counts: $h(v)\mathrel{-=}1$, $\ell(v)\mathrel{+}=1$; $h(u)\mathrel{+}=1$, $\ell(u)\mathrel{-}=1$.
  \item Move the edge to the other store: push $v$ into $\text{up}[u]$.
  \item Add back $h(u)\ell(u)$ to $T$.
  \end{bullets}
  Finally clear $\text{up}[v]$ and add $h(v)\ell(v)$ (now $0$) back to $T$.
\item Output $T$ at the beginning of each day; apply promotion afterward.
\end{algosteps}
\COMPLEXITY{Let $H_i=|\text{up}[v_i]|$ at promotion time. The update cost is $O(H_i)$. Over all days, time is $O\!\left(n+m+\sum_i H_i\right)$ and space is $O(n+m)$.}
\[
\begin{aligned}
T(n,m,q) &= O\!\left(n+m+\sum_{i=1}^q |\text{up}[v_i]|\right), \\
S(n,m) &= O(n+m).
\end{aligned}
\]
\CORRECTNESS{Each edge is always stored with the current poorer endpoint. Promoting $v$ makes $v$ strictly richest, so exactly edges to currently richer neighbors flip and are migrated to $\text{up}$ of the other endpoint. The formula for $T$ is maintained by removing and re-adding contributions of affected vertices.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Same API/signature as baseline; deterministic; with asserts
from typing import List, Tuple
import sys

def read_input(data: str):
    it = iter(data.strip().split())
    n = int(next(it)); m = int(next(it))
    adj = [[] for _ in range(n)]
    for _ in range(m):
        a = int(next(it)) - 1
        b = int(next(it)) - 1
        adj[a].append(b)
        adj[b].append(a)
    q = int(next(it))
    v = [int(next(it)) - 1 for _ in range(q)]
    return n, adj, q, v

class KonradIncremental:
    def __init__(self, n: int, adj: List[List[int]]):
        self.n = n
        self.adj = adj
        self.deg = [len(adj[i]) for i in range(n)]
        # up[v]: neighbors currently richer than v (edge stored once)
        self.up: List[List[int]] = [[] for _ in range(n)]
        # Initially, all t(v)=0, tie-break by id: larger id is richer
        for v in range(n):
            for u in adj[v]:
                if u > v:
                    self.up[v].append(u)
        self.h = [len(self.up[i]) for i in range(n)]
        self.l = [self.deg[i] - self.h[i] for i in range(n)]
        self.T = 0
        for i in range(n):
            self.T += self.h[i] * self.l[i]

    def promote(self, v: int):
        # Remove v's contribution
        self.T -= self.h[v] * self.l[v]
        # Move all richer neighbors u in up[v] to be poorer than v
        # We will iterate a snapshot to avoid interference while appending to up[u]
        curr = self.up[v]
        self.up[v] = []
        for u in curr:
            # Remove u's contribution
            self.T -= self.h[u] * self.l[u]
            # Update counts
            self.h[v] -= 1
            self.l[v] += 1
            self.h[u] += 1
            self.l[u] -= 1
            # Move edge storage to u (now poorer endpoint)
            self.up[u].append(v)
            # Add u's new contribution
            self.T += self.h[u] * self.l[u]
        # After promotion, v is richest: h[v]=0, l[v]=deg[v]
        # Add back v's contribution (zero)
        self.T += self.h[v] * self.l[v]

def solve_all_improved(data: str) -> str:
    n, adj, q, v = read_input(data)
    inc = KonradIncremental(n, adj)
    out = []
    out.append(str(inc.T))
    for x in v:
        inc.promote(x)
        out.append(str(inc.T))
    return "\n".join(out)

def _test_improved():
    data = """3 2
1 2
2 3
1
2
"""
    got = solve_all_improved(data).strip().split()
    assert got == ["1","0"]
    # Random small cross-check with baseline
    import random
    def run(n, m, q, seed=0):
        rnd = random.Random(seed)
        edges = set()
        while len(edges) < m:
            a = rnd.randrange(n); b = rnd.randrange(n)
            if a == b: continue
            if a > b: a, b = b, a
            edges.add((a,b))
        edgelist = "\n".join(f"{a+1} {b+1}" for a,b in edges)
        vs = [str(rnd.randrange(n)+1) for _ in range(q)]
        data = f"""{n} {m}
{edgelist}
{q}
{" ".join(vs)}
"""
        return data
    # Few trials
    for seed in range(5):
        n=7; m=10; q=8
        data = run(n,m,q,seed)
        b = solve_all_baseline(data).strip().split()
        im = solve_all_improved(data).strip().split()
        assert b == im

if __name__ == "__main__":
    _test_improved()
    # For local run:
    # print(solve_all_improved(sys.stdin.read()))
\end{minted}
\VALIDATION{Randomized cross-check vs. baseline on small graphs; sample test included.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Maintain the invariant that each undirected edge $\{u,v\}$ is stored exactly once in $\text{up}[\text{poorer of }(u,v)]$. Updating $T=\sum_v h(v)\ell(v)$ requires touching exactly $|\text{up}[v]|$ neighbors on promotion of $v$, which are precisely the currently richer neighbors.}
\ASSUMPTIONS{Graph is sparse ($m\le 100{,}000$), and the total number of processed adjacencies $\sum_i |\text{up}[v_i]|$ is acceptable in practice.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Precompute degrees and initialize $\text{up}$ by indices (all $t(v)=0$).
\item Keep arrays $h,\ell$ and the global accumulator $T$.
\item On each promotion, migrate edges from $\text{up}[v]$ to $\text{up}[u]$ for $u\in \text{up}[v]$, and update $h,\ell,T$ locally as in Approach B.
\end{algosteps}
\OPTIMALITY{Any correct update must at least account for all edges whose orientation flips. This method touches exactly those and no others, hence is optimal per operation in terms of the number of flips.}
\COMPLEXITY{Same as Approach B; space linear in $n+m$.}
\[
\begin{aligned}
T(n,m,q) &= O\!\left(n+m+\sum_{i=1}^q |\text{up}[v_i]|\right), \\
S(n,m) &= O(n+m).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    adj = [[] for _ in range(n)]
    for _ in range(m):
        a = int(next(it)) - 1
        b = int(next(it)) - 1
        adj[a].append(b)
        adj[b].append(a)
    q = int(next(it))
    V = [int(next(it)) - 1 for _ in range(q)]
    return n, adj, q, V

class KonradCompany:
    def __init__(self, n: int, adj: List[List[int]]):
        self.n = n
        self.adj = adj
        self.deg = [len(adj[i]) for i in range(n)]
        self.up: List[List[int]] = [[] for _ in range(n)]
        for v in range(n):
            for u in adj[v]:
                if u > v:
                    self.up[v].append(u)
        self.h = [len(self.up[i]) for i in range(n)]
        self.l = [self.deg[i] - self.h[i] for i in range(n)]
        self.T = 0
        for i in range(n):
            self.T += self.h[i] * self.l[i]

    def promote(self, v: int):
        self.T -= self.h[v] * self.l[v]
        cur = self.up[v]
        self.up[v] = []
        for u in cur:
            self.T -= self.h[u] * self.l[u]
            self.h[v] -= 1
            self.l[v] += 1
            self.h[u] += 1
            self.l[u] -= 1
            self.up[u].append(v)
            self.T += self.h[u] * self.l[u]
        self.T += self.h[v] * self.l[v]

def solve_all():
    n, adj, q, V = read_input()
    solver = KonradCompany(n, adj)
    out = []
    out.append(str(solver.T))
    for x in V:
        solver.promote(x)
        out.append(str(solver.T))
    sys.stdout.write("\n".join(out))

def _self_test():
    # Sample
    from io import StringIO
    sys.setrecursionlimit(1 << 25)
    data = """3 2
1 2
2 3
1
2
"""
    n, adj, q, V = (lambda d: (lambda it: (int(next(it)), [[] for _ in range(int(next(it)))], None, None))(iter(d.split())))(data)  # dummy
    # Use separate parser for test to avoid entangling stdin
    def parse(d: str):
        it = iter(d.strip().split())
        n = int(next(it)); m = int(next(it))
        adj = [[] for _ in range(n)]
        for _ in range(m):
            a = int(next(it)) - 1; b = int(next(it)) - 1
            adj[a].append(b); adj[b].append(a)
        q = int(next(it))
        V = [int(next(it)) - 1 for _ in range(q)]
        return n, adj, q, V
    n, adj, q, V = parse(data)
    solver = KonradCompany(n, adj)
    got = [solver.T]
    for x in V:
        solver.promote(x)
        got.append(solver.T)
    assert got == [1, 0]
    # Tiny random cross-check with baseline
    import random
    def baseline(n, edges, q, V):
        undirected = edges[:]
        t = [0]*n
        def recompute():
            h = [0]*n
            deg = [0]*n
            for (a,b) in undirected:
                deg[a]+=1; deg[b]+=1
                if (t[a], a) > (t[b], b):
                    h[b]+=1
                else:
                    h[a]+=1
            return sum(h[i]*(deg[i]-h[i]) for i in range(n))
        out = [recompute()]
        for day,x in enumerate(V, start=1):
            t[x]=day
            out.append(recompute())
        return out
    rnd = random.Random(0)
    for _ in range(5):
        n = 8; m = 10
        edges = set()
        while len(edges) < m:
            a = rnd.randrange(n); b = rnd.randrange(n)
            if a==b: continue
            if a>b: a,b = b,a
            edges.add((a,b))
        adj = [[] for _ in range(n)]
        for a,b in edges:
            adj[a].append(b); adj[b].append(a)
        q = 7
        V = [rnd.randrange(n) for __ in range(q)]
        solver = KonradCompany(n, adj)
        got = [solver.T]
        for x in V:
            solver.promote(x); got.append(solver.T)
        base = baseline(n, list(edges), q, V)
        assert got == base

if __name__ == "__main__":
    # _self_test()  # Uncomment to run self-tests locally
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 checks: sample match; randomized cross-check vs. baseline on tiny graphs; invariants $h(v)+\ell(v)=d(v)$ preserved implicitly by construction.}
\RESULT{Reports the number of dangerous triples at the beginning of each day. No tie-breaking beyond the stated lex order $(t(v),v)$ is needed since it is implicit in initialization and edge migrations.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on toy graphs (chains, cycles, stars). Randomized cross-check against baseline recomputation for small $n$ to ensure incremental updates are correct. Verify invariants and non-negativity.}
\LINE{CROSS-CHECKS}{Compare outputs of Approach A and Approach C on the same random instances; exact equality expected for all days.}
\LINE{EDGE-CASE GENERATOR}{Generate degenerate graphs: $m=0$, $n=1$, stars with a high-degree center, repeated promotions of the same vertex, and alternating promotions of endpoints of an edge.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List, Tuple
import random

def gen_empty(n: int, q: int) -> Tuple[str, List[int]]:
    edges = ""
    vs = [1]*q
    data = f"""{n} 0
{edges}
{q}
{" ".join(map(str,vs))}
"""
    return data, vs

def gen_star(n: int, q: int, center: int = 1) -> str:
    edges = "\n".join(f"{center} {i}" for i in range(1, n+1) if i != center)
    vs = [center]*(q//2) + [i for i in range(1, min(n, q - q//2)+1)]
    data = f"""{n} {n-1}
{edges}
{q}
{" ".join(map(str,vs))}
"""
    return data

def gen_cycle(n: int, q: int) -> str:
    edges = "\n".join(f"{i} {i% n + 1}" for i in range(1, n+1))
    vs = [((i % n) + 1) for i in range(q)]
    data = f"""{n} {n}
{edges}
{q}
{" ".join(map(str,vs))}
"""
    return data

# Example direct run:
if __name__ == "__main__":
    print(gen_star(6, 5))
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Single, final reference solution with the required API (CF/LC) + asserts
from typing import List
import sys

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    n = int(next(it)); m = int(next(it))
    adj = [[] for _ in range(n)]
    for _ in range(m):
        a = int(next(it)) - 1
        b = int(next(it)) - 1
        adj[a].append(b)
        adj[b].append(a)
    q = int(next(it))
    V = [int(next(it)) - 1 for _ in range(q)]
    return n, adj, q, V

class KonradCompany:
    def __init__(self, n: int, adj: List[List[int]]):
        self.n = n
        self.adj = adj
        self.deg = [len(adj[i]) for i in range(n)]
        self.up: List[List[int]] = [[] for _ in range(n)]
        for v in range(n):
            for u in adj[v]:
                if u > v:
                    self.up[v].append(u)
        self.h = [len(self.up[i]) for i in range(n)]
        self.l = [self.deg[i] - self.h[i] for i in range(n)]
        self.T = 0
        for i in range(n):
            self.T += self.h[i] * self.l[i]

    def promote(self, v: int):
        self.T -= self.h[v] * self.l[v]
        cur = self.up[v]
        self.up[v] = []
        for u in cur:
            self.T -= self.h[u] * self.l[u]
            self.h[v] -= 1
            self.l[v] += 1
            self.h[u] += 1
            self.l[u] -= 1
            self.up[u].append(v)
            self.T += self.h[u] * self.l[u]
        self.T += self.h[v] * self.l[v]

def solve_all():
    n, adj, q, V = read_input()
    solver = KonradCompany(n, adj)
    out = [str(solver.T)]
    for x in V:
        solver.promote(x)
        out.append(str(solver.T))
    sys.stdout.write("\n".join(out))

def _mini_tests():
    # Sample
    data = """3 2
1 2
2 3
1
2
"""
    def parse(d: str):
        it = iter(d.strip().split())
        n = int(next(it)); m = int(next(it))
        adj = [[] for _ in range(n)]
        for _ in range(m):
            a = int(next(it)) - 1; b = int(next(it)) - 1
            adj[a].append(b); adj[b].append(a)
        q = int(next(it))
        V = [int(next(it)) - 1 for _ in range(q)]
        return n, adj, q, V
    n, adj, q, V = parse(data)
    solver = KonradCompany(n, adj)
    got = [solver.T]
    for x in V:
        solver.promote(x)
        got.append(solver.T)
    assert got == [1, 0]
    # No edges
    n, adj, q, V = 4, [[] for _ in range(4)], 3, [0, 1, 2]
    solver = KonradCompany(n, adj)
    got = [solver.T]
    for x in V:
        solver.promote(x); got.append(solver.T)
    assert got == [0, 0, 0, 0]

if __name__ == "__main__":
    # _mini_tests()  # Uncomment for local sanity checks
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count directed paths of length $2$ in an orientation induced by a total order; maintain the count under ``move one vertex to top'' updates.}
\WHY{This pattern (counting paths via middle vertex products) appears in dynamic graph orientation problems and is a common interview theme for amortized or incremental maintenance.}
\CHECKLIST{
- Model dangerous triples as $\sum_v h(v)\ell(v)$.\\
- Initialize orientation by $(t(v),v)$ with all $t=0$.\\
- Store each undirected edge once at the current poorer endpoint.\\
- On promotion, process exactly the richer neighbors of the promoted vertex.\\
- Update $h,\ell$ and migrate edge storage accordingly.\\
- Maintain and output the global accumulator $T$.
}
\EDGECASES{
- $m=0$ or $n=1$ $\Rightarrow T=0$ always.\\
- Vertex promoted multiple times.\\
- Star graphs with center repeatedly promoted.\\
- Disconnected graphs.\\
- Long chains (ensure no off-by-one in indices).\\
- Many repeated promotions of the same node (should be efficient if it has few richer neighbors).
}
\PITFALLS{
- Forgetting to subtract and then add contributions to $T$ when updating neighbors.\\
- Mixing up richer vs. poorer direction; confirm initial $\text{up}$ uses larger index as richer.\\
- Not clearing $\text{up}[v]$ after promotion, causing double counting.\\
- Using 32-bit integers for $T$; use Python int (or 64-bit in C++).\\
- Printing order: output before applying each day's promotion.\\
- Mishandling tie-breaks; use $(t(v),v)$ lex order implicitly via initialization.
}
\FAILMODES{
- Recomputing from scratch each day leads to $O((n+m)q)$, too slow in worst cases.\\
- Updating all neighbors (both richer and poorer) per promotion is unnecessary; only richer neighbors flip.\\
- Forgetting that the graph is undirected and relationships are symmetric in input.
}
\ELI{Think of each employee as having arrows from richer to poorer neighbors. The number of ``A brags to B brags to C'' is just, for each B, pick one richer arrow into B and one poorer arrow out of B. When someone becomes the richest, only arrows touching them that used to point into them flip to point out; update those and keep a running sum.}
\NotePages{3}

\end{document}