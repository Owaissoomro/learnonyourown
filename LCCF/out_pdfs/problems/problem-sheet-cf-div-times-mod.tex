% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Div Times Mod}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1085/B}}
\LINE{DIFFICULTY / RATING}{1100}
\STATEMENT{Vasya likes to solve equations. Today he wants to solve $(x~\mathrm{div}~k) \cdot (x \bmod k) = n$, where $\mathrm{div}$ and $\mathrm{mod}$ stand for integer division and modulo operations (refer to the Notes below for exact definition). In this equation, $k$ and $n$ are positive integer parameters, and $x$ is a positive integer unknown. If there are several solutions, Vasya wants to find the smallest possible $x$. Can you help him?

Input: The first line contains two integers $n$ and $k$ ($1 \le n \le 10^6$, $2 \le k \le 1000$).

Output: Print a single integer $x$ — the smallest positive integer solution to $(x~\mathrm{div}~k) \cdot (x \bmod k) = n$. It is guaranteed that this equation has at least one positive integer solution.

Note: The result of integer division $a~\mathrm{div}~b$ is equal to the largest integer $c$ such that $b \cdot c \le a$. $a$ modulo $b$ (shortened $a \bmod b$) is the only integer $c$ such that $0 \le c < b$, and $a - c$ is divisible by $b$.

In the first sample, $11~\mathrm{div}~3 = 3$ and $11 \bmod 3 = 2$. Since $3 \cdot 2 = 6$, then $x = 11$ is a solution to $(x~\mathrm{div}~3) \cdot (x \bmod 3) = 6$. One can see that $19$ is the only other positive integer solution, hence $11$ is the smallest one.}
\BREAKDOWN{Let $x = qk + r$ with $0 \le r < k$ and $q = \lfloor x/k \rfloor$. The equation becomes $q \cdot r = n$. Enumerate feasible $r$ that divide $n$ with $1 \le r < k$, set $q = n/r$, and minimize $x = qk + r$.}
\ELI{Factor $n$ into $q \cdot r$ with $r < k$ and pick the pair that minimizes $qk + r$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Two integers: $n$ and $k$ with $1 \le n \le 10^6$ and $2 \le k \le 1000$.}
\OUTPUTS{One integer: the minimum $x$ satisfying $(x~\mathrm{div}~k) \cdot (x \bmod k) = n$.}
\SAMPLES{Example 1: $n=6$, $k=3$ $\to$ answer $11$. Example 2: $n=35$, $k=10$ $\to$ answer $57$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Write $x = qk + r$ with integers $q \ge 1$, $r \in \{1,\ldots,k-1\}$. Find the minimum $x$ such that $q \cdot r = n$.}
\varmapStart
\var{n}{Target product of quotient and remainder}
\var{k}{Modulus / divisor base}
\var{q}{Quotient $\lfloor x/k \rfloor$}
\var{r}{Remainder $x \bmod k$ with $0 \le r < k$}
\var{x}{Unknown positive integer to minimize}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
x &= qk + r,\quad 0 \le r < k, \\
q \cdot r &= n, \\
\text{minimize } x &\text{ over all feasible } (q,r).
\end{aligned}
\]
}
\ASSUMPTIONS{$n,k$ integers within given bounds; at least one solution exists as per the statement; since $n \ge 1$, we must have $q \ge 1$ and $r \ge 1$.}
\INVARIANTS{For any $x$, $x \bmod k \in [0,k-1]$. Feasible solutions require $r \in [1,k-1]$ and $r \mid n$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Enumerate remainder $r \in \{1,\ldots,k-1\}$; if $r \mid n$ then $q=n/r$ and $x=qk+r$. Take the minimum.}
\ASSUMPTIONS{Direct check over all possible remainders; $k \le 1000$ makes this trivial.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize $\text{best} \leftarrow +\infty$.
\item For $r$ from $1$ to $k-1$: if $n \bmod r = 0$, compute $q = n/r$, candidate $x = qk + r$, and minimize.
\item Output $\text{best}$.
\end{algosteps}
\COMPLEXITY{Iterates at most $k-1$ remainders. With $k \le 1000$, this is very small.}
\[
\begin{aligned}
T(n,k) &= O(k) \\
S(n,k) &= O(1)
\end{aligned}
\]
\CORRECTNESS{Any feasible $x$ has remainder $r=x \bmod k \in [1,k-1]$ and quotient $q=\lfloor x/k \rfloor$ with $qr=n$. The loop considers exactly those $r$ that divide $n$ and are $<k$, generating all feasible candidates $x=qk+r$. Picking the minimum yields the smallest $x$.}
\EDGECASES{$r=0$ cannot occur since $n \ge 1$. If only $r=1$ is feasible, answer is $nk+1$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
import sys
from typing import Tuple

def solve_case(n: int, k: int) -> int:
    best = None
    upper = min(k - 1, n)
    for r in range(1, upper + 1):
        if n % r == 0:
            q = n // r
            x = q * k + r
            if best is None or x < best:
                best = x
    assert best is not None
    return best

def read_input() -> Tuple[int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, 0)
    n, k = map(int, data[:2])
    return (n, k)

def solve_all() -> None:
    n, k = read_input()
    if n == 0 and k == 0:
        return
    print(solve_case(n, k))

def _self_test() -> None:
    assert solve_case(6, 3) == 11  # from statement
    assert solve_case(1, 2) == 3   # only r=1, q=1 -> x=2*1+1=3
    # Constructed: n=35, k=10, feasible r in {1,5,7}; min x is r=7 => 5*10+7=57
    assert solve_case(35, 10) == 57

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Checked statement sample and two crafted cases including a composite $n$ with multiple feasible remainders.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized via Divisor Enumeration}
\WHICHFORMULA{Enumerate divisors of $n$ up to $\lfloor \sqrt{n} \rfloor$; test both $d$ and $n/d$ as candidate remainders $r$, keeping only $r<k$.}
\ASSUMPTIONS{Divisor enumeration gives $O(\sqrt{n})$ candidates, which is faster when $k$ can be close to $n$ in other problems; here both are tiny, but this is a standard improvement.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For $d=1$ to $\lfloor\sqrt{n}\rfloor$ with $d \mid n$:
\item Consider $r_1=d$ and $r_2=n/d$; for each with $r<k$, compute $x=(n/r)k+r$ and minimize.
\item Output the best $x$ found.
\end{algosteps}
\COMPLEXITY{Divisor loop is $O(\sqrt{n})$, each step does O(1) work.}
\[
\begin{aligned}
T(n,k) &= O(\sqrt{n}) \\
S(n,k) &= O(1)
\end{aligned}
\]
\CORRECTNESS{Every factor $r$ of $n$ appears as either $d$ or $n/d$ for some $d \mid n$. Filtering by $r<k$ enumerates exactly feasible remainders; minimizing $qk+r$ yields the smallest $x$.}
\textbf{Code (Improved)}
\begin{minted}{python}
import sys
from typing import Tuple

def solve_case(n: int, k: int) -> int:
    best = None
    d = 1
    while d * d <= n:
        if n % d == 0:
            r1 = d
            if r1 < k:
                q = n // r1
                x = q * k + r1
                if best is None or x < best:
                    best = x
            r2 = n // d
            if r2 != r1 and r2 < k:
                q = n // r2
                x = q * k + r2
                if best is None or x < best:
                    best = x
        d += 1
    assert best is not None
    return best

def read_input() -> Tuple[int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, 0)
    n, k = map(int, data[:2])
    return (n, k)

def solve_all() -> None:
    n, k = read_input()
    if n == 0 and k == 0:
        return
    print(solve_case(n, k))

def _self_test() -> None:
    assert solve_case(6, 3) == 11
    assert solve_case(1, 2) == 3
    assert solve_case(35, 10) == 57

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Covers square and non-square $n$ and multiple-factor cases; ensures duplicate factors at $d^2=n$ are not double-counted.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Factor-Pair Scan (Tight)}
\WHICHFORMULA{Same as Approach B: scanning divisors is optimal for generating exactly the feasible remainders and minimizing $qk+r$.}
\ASSUMPTIONS{Applies whenever $n \ge 1$, $k \ge 2$; guaranteed existence of a solution ensures at least one remainder $r<k$ divides $n$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Enumerate $d \mid n$ up to $\lfloor\sqrt{n}\rfloor$.
\item For each $r \in \{d, n/d\}$ with $r < k$, compute $x = (n/r)k + r$ and track the minimum.
\item Return the minimum $x$.
\end{algosteps}
\OPTIMALITY{Any solution corresponds to some factor $r$ of $n$ with $r<k$. The algorithm inspects each such $r$ exactly once and chooses the smallest $qk+r$. No algorithm can avoid considering all feasible remainders in the worst case, so this is tight up to constant factors.}
\COMPLEXITY{$O(\sqrt{n})$ time, $O(1)$ space, which is optimal for factor enumeration.}
\[
\begin{aligned}
T(n) &= O(\sqrt{n}) \\
S(n) &= O(1)
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
import sys
from typing import Tuple

def solve_case(n: int, k: int) -> int:
    best = None
    d = 1
    while d * d <= n:
        if n % d == 0:
            r1 = d
            if r1 < k:
                q = n // r1
                x = q * k + r1
                if best is None or x < best:
                    best = x
            r2 = n // d
            if r2 != r1 and r2 < k:
                q = n // r2
                x = q * k + r2
                if best is None or x < best:
                    best = x
        d += 1
    assert best is not None
    return best

def read_input() -> Tuple[int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, 0)
    n, k = map(int, data[:2])
    return (n, k)

def solve_all() -> None:
    n, k = read_input()
    if n == 0 and k == 0:
        return
    print(solve_case(n, k))

def _self_test() -> None:
    # Exactly 3 asserts
    assert solve_case(6, 3) == 11
    assert solve_case(1, 2) == 3
    assert solve_case(35, 10) == 57

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\VALIDATION{Three asserts: statement sample, trivial boundary with $k=2$, and a composite $n$ with multiple feasible remainders.}
\RESULT{Returns the minimum $x$; no ties possible since we select the minimum integer $x$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit-test the core solver on representative cases: smallest bounds, prime/composite $n$, and scenarios with multiple feasible remainders.}
\LINE{CROSS-CHECKS}{Compare Approach A (enumerate remainders) vs. Approach B/C (enumerate divisors) on random small inputs to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate $n$ as primes and squares, and $k$ near $2$ and near $n$ (though here $k \le 1000$) to stress both branches $r=d$ and $r=n/d$.}
\begin{minted}{python}
import random

def brute(n: int, k: int) -> int:
    best = None
    for r in range(1, min(k - 1, n) + 1):
        if n % r == 0:
            q = n // r
            x = q * k + r
            if best is None or x < best:
                best = x
    return best

def fast(n: int, k: int) -> int:
    best = None
    d = 1
    while d * d <= n:
        if n % d == 0:
            for r in (d, n // d):
                if r < k:
                    q = n // r
                    x = q * k + r
                    if best is None or x < best:
                        best = x
        d += 1
    return best

# Cross-check on random small cases
random.seed(0)
for _ in range(200):
    n = random.randint(1, 10**6)
    k = random.randint(2, 1000)
    assert brute(n, k) == fast(n, k)

# Deterministic boundary checks
assert fast(6, 3) == 11
assert fast(1, 2) == 3
assert fast(35, 10) == 57
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
import sys
from typing import Tuple

def solve_case(n: int, k: int) -> int:
    best = None
    d = 1
    while d * d <= n:
        if n % d == 0:
            r1 = d
            if r1 < k:
                q = n // r1
                x = q * k + r1
                if best is None or x < best:
                    best = x
            r2 = n // d
            if r2 != r1 and r2 < k:
                q = n // r2
                x = q * k + r2
                if best is None or x < best:
                    best = x
        d += 1
    assert best is not None
    return best

def read_input() -> Tuple[int, int]:
    data = sys.stdin.read().strip().split()
    if not data:
        return (0, 0)
    n, k = map(int, data[:2])
    return (n, k)

def solve_all() -> None:
    n, k = read_input()
    if n == 0 and k == 0:
        return
    print(solve_case(n, k))

def _self_test() -> None:
    assert solve_case(6, 3) == 11
    assert solve_case(1, 2) == 3
    assert solve_case(35, 10) == 57

if __name__ == "__main__":
    _self_test()
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Minimize $x=qk+r$ subject to $qr=n$ and $1 \le r < k$.}
\WHY{Classic quotient/remainder factorization; appears in problems mixing floor/mod arithmetic with optimization.}
\CHECKLIST{%
\begin{bullets}
\item Express $x$ as $qk+r$.
\item Enforce $qr=n$.
\item Restrict $1 \le r < k$.
\item Search over divisors of $n$ for feasible $r$.
\item Minimize $qk+r$.
\end{bullets}
}
\EDGECASES{%
\begin{bullets}
\item $n=1$, $k=2$ $\Rightarrow x=3$.
\item $r=0$ impossible since $n \ge 1$.
\item $k$ just above $1$; only $r=1$ feasible.
\item $n$ prime; feasible $r \in \{1,n\}$, but $r<n$ forces $r=1$ unless $k>n$.
\item Perfect square $n$; ensure not double-counting $d=\sqrt{n}$.
\item Large $k$ relative to $n$ within constraints; still check $r<k$.
\item Multiple feasible $r$; choose smallest $qk+r$, not smallest $r$ or $q$.
\end{bullets}
}
\PITFALLS{%
\begin{bullets}
\item Forgetting $r \ge 1$; allowing $r=0$ yields wrong $x$.
\item Searching over $q$ instead of $r$ and imposing $q<k$ (incorrect constraint).
\item Missing the case $d^2=n$ and double-counting or skipping.
\item Overflow worries in other languages; in Python this is safe.
\item Reading input incorrectly when there is trailing whitespace.
\item Assuming uniqueness of solution; must minimize.
\end{bullets}
}
\FAILMODES{Brute-forcing all $x$ is infeasible; enumerating all $r$ up to $k-1$ is fine but slower than divisor scan for larger $k$ in other settings. Divisor enumeration guarantees coverage and speed.}
\ELI{Write $x$ as blocks of size $k$ plus a remainder. The product condition forces the quotient and remainder to multiply to $n$. Try all remainders less than $k$ that divide $n$, compute the corresponding $x$, and take the smallest.}
\NotePages{3}

\end{document}