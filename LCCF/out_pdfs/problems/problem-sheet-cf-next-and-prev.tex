% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Next and Prev}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1967/F}}
\LINE{DIFFICULTY / RATING}{3200}
\STATEMENT{Let $p_1, \ldots, p_n$ be a permutation of $[1, \ldots, n]$.

Let the $q$-subsequence of $p$ be a permutation of $[1, q]$, whose elements are in the same relative order as in $p_1, \ldots, p_n$. That is, we extract all elements not exceeding $q$ together from $p$ in the original order, and they make the $q$-subsequence of $p$.

For a given array $a$, let $pre(i)$ be the largest value satisfying $pre(i) < i$ and $a_{pre(i)} > a_i$. If it does not exist, let $pre(i) = -10^{100}$. Let $nxt(i)$ be the smallest value satisfying $nxt(i) > i$ and $a_{nxt(i)} > a_i$. If it does not exist, let $nxt(i) = 10^{100}$.

For each $q$ such that $1 \le q \le n$, let $a_1, \ldots, a_q$ be the $q$-subsequence of $p$. For each $i$ such that $1 \le i \le q$, $pre(i)$ and $nxt(i)$ will be calculated as defined. Then, you will be given some integer values of $x$, and for each of them you have to calculate $\sum\limits_{i=1}^q \min(nxt(i) - pre(i), x)$.

Input:
Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^4$). The description of the test cases follows.

The first line of each test case contains a single integer $n$ ($1 \le n \le 3\cdot 10^5$) — the length of the permutation.

The second line of each test case contains $n$ integers $p_1, \ldots, p_n$ ($1 \le p_i \le n$) — the initial permutation.

Then, for each $q$ such that $1 \le q \le n$ in ascending order, you will be given an integer $k$ ($0 \le k \le 10^5$), representing the number of queries for the $q$-subsequence. Then $k$ numbers in a line follow: each of them is the value of $x$ for a single query ($1 \le x \le q$).

It is guaranteed that the sum of $n$ over all test cases does not exceed $3\cdot 10^5$ and the sum of $k$ over all test cases does not exceed $10^5$.

Output:
For each test case, for each query, print a single line with an integer: the answer to the query.

Note:
The $1$-subsequence is $[1]$, and $pre=[-10^{100}]$, $nxt=[10^{100}]$. $ans(1)=\min(10^{100}-(-10^{100}),1)=1$.

The $5$-subsequence is $[1,4,3,2,5]$, and $pre=[-10^{100},-10^{100},2,3,-10^{100}]$, $nxt=[2,5,5,5,10^{100}]$. $ans(1)=5,ans(2)=10,ans(3)=14$.}
\BREAKDOWN{For each prefix value $q$, construct the $q$-subsequence $a$ by taking values $\le q$ in the order they appear in $p$. Compute for each index $i$ the nearest strictly greater to the left and to the right, denoted by $pre(i)$ and $nxt(i)$. Let $L_i = nxt(i)-pre(i)$. Each query with $x$ asks for $\sum_i \min(L_i,x)$.}
\ELI{Turn the permutation prefix into a sequence, compute for each position how far it stretches between bigger neighbors, then cap each stretch at $x$ and sum.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each: integer $n$, array $p$ as a permutation of $[1,n]$. Then for each $q=1,\ldots,n$: integer $k$ and then $k$ integers $x$ with $1 \le x \le q$. All inputs are whitespace-separated; $t \in [1,10^4]$, $\sum n \le 3\cdot 10^5$, $\sum k \le 10^5$.}
\OUTPUTS{For each test case, for each of its queries (in the order given), print one integer per line: the value of $\sum_{i=1}^q \min(nxt(i)-pre(i),x)$ computed on the $q$-subsequence.}
\SAMPLES{Example (single test, tiny): $n=3$, $p=[2,1,3]$.
- $q=1$: $a=[1]$, $k=2$, queries $x=[1,1]$ $\Rightarrow$ both answers $1$.
- $q=2$: $a=[1,2]$, $k=1$, $x=[1]$ $\Rightarrow$ answer $2$.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $p \in S_n$. For each $q$, define $a^{(q)} \in S_q$ by ordering $\{1,\ldots,q\}$ by their positions in $p$. For $i \in [1..q]$, define
$pre(i) = \max\{j<i: a_j>a_i\}$ or $-10^{100}$ if none, and
$nxt(i) = \min\{j>i: a_j>a_i\}$ or $10^{100}$ if none.
Let $L_i = nxt(i)-pre(i)$. Queries ask for $F_q(x)=\sum_{i=1}^q \min(L_i,x)$.}
\varmapStart
\var{p}{input permutation on $[1..n]$}
\var{q}{prefix value; size of subsequence}
\var{a^{(q)}}{$q$-subsequence as a permutation on $[1..q]$}
\var{pre(i),nxt(i)}{nearest strictly greater indices around $i$ (with sentinels)}
\var{L_i}{span length $nxt(i)-pre(i)$}
\var{F_q(x)}{query answer $\sum_i \min(L_i,x)$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
F_q(x) \;=\; \sum_{i=1}^q \min(L_i,x) \;=\; \sum_{i: L_i<x} L_i \;+\; x\cdot \bigl(q - |\{i:L_i<x\}|\bigr).
\end{BreakableEquation*}
}
\ASSUMPTIONS{Indices are $1$-based for $a^{(q)}$. Sentinels $-10^{100}$ and $10^{100}$ behave as $-\infty$ and $+\infty$; in computation we can replace them by a value $\gg q$.}
\INVARIANTS{Nearest-greater indices from a monotone stack are unique and well-defined. All $L_i \ge 1$. If either side is a sentinel, $L_i$ is effectively $+\infty$ relative to any $x \le q$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Compute $a^{(q)}$ explicitly, then for each query recompute all $L_i$ and sum $\min(L_i,x)$.}
\ASSUMPTIONS{Small $n$; acceptable to recompute per query.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $a^{(q)}$ by taking numbers $1..q$ ordered by their positions in $p$.
\item For each $i$, scan left/right to find $pre(i)$ and $nxt(i)$, set $L_i=nxt(i)-pre(i)$ with sentinels.
\item For each query $x$, compute $\sum_i \min(L_i,x)$ directly.
\end{algosteps}
\COMPLEXITY{Naively recomputing per query: $O(q^2)$ to get all $L_i$ using scans, and $O(q)$ per query to sum.}
\[
\begin{aligned}
T(n) &= \sum_{q=1}^n \bigl(O(q\log q) + k_q\cdot O(q) + O(q^2)\bigr) \\
     &= O(n^2 \log n) + O\Bigl(\sum k_q\,q\Bigr) + O(n^3) \text{ in the worst case.}
\end{aligned}
\]
\CORRECTNESS{Directly follows the definitions of $q$-subsequence and nearest-greater indices.}
\EDGECASES{$q=1$; strictly-greater handling (no equality); boundary elements with only one neighbor; all increasing or decreasing $a^{(q)}$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline (slow): per q & per query recomputation
from typing import List, Tuple

INF_BIG = 10**18

def q_subsequence_from_perm(p: List[int], q: int) -> List[int]:
    n = len(p)
    pos = [0]*(n+1)
    for i, v in enumerate(p, 1):
        pos[v] = i
    vals = list(range(1, q+1))
    vals.sort(key=lambda v: pos[v])
    return vals

def compute_L_naive(a: List[int]) -> List[int]:
    q = len(a)
    L = [0]*q
    for i in range(q):
        pre = -INF_BIG
        for j in range(i-1, -1, -1):
            if a[j] > a[i]:
                pre = j+1  # 1-based index for span semantics
                break
        nxt = INF_BIG
        for j in range(i+1, q):
            if a[j] > a[i]:
                nxt = j+1
                break
        if pre == -INF_BIG:
            pre = -INF_BIG
        if nxt == INF_BIG:
            nxt = INF_BIG
        # Both pre and nxt are in "index space"; using huge sentinels is fine
        L[i] = (nxt if nxt != INF_BIG else INF_BIG) - (pre if pre != -INF_BIG else -INF_BIG)
    return L

def answer_sum_min_naive(a: List[int], x: int) -> int:
    L = compute_L_naive(a)
    total = 0
    for v in L:
        total += x if v >= x else v
    return int(total)
\end{minted}
\VALIDATION{Asserts appear in later sections comparing this with improved methods on tiny inputs.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Precompute all $L_i$ for a fixed $q$ using monotone stacks in $O(q)$, then answer each query $x$ in $O(\log q)$ via prefix sums on sorted $L$.}
\ASSUMPTIONS{Per $q$, we can afford $O(q\log q)$ preprocessing; queries are answered fast.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build $a^{(q)}$ quickly by pre-sorting $[1..n]$ by position and taking the first $q$.
\item Compute nearest greater to left/right using a decreasing stack (pop while $\le$ for strict $>$).
\item Form $L_i = nxt(i)-pre(i)$ using large sentinels for $\pm \infty$, sort $L$, and take prefix sums.
\item For a query $x$: let $c=\#\{i:L_i<x\}$ via binary search; answer is $prefix[c] + (q-c)\cdot x$.
\end{algosteps}
\COMPLEXITY{Per $q$: $O(q)$ to get neighbors, $O(q\log q)$ to sort $L$, and $O(\log q)$ per query.}
\[
\begin{aligned}
T(n) &= \sum_{q=1}^n O(q\log q) + \sum_{q=1}^n k_q \cdot O(\log q), \quad S(n)=O(q).
\end{aligned}
\]
\CORRECTNESS{Nearest-greater indices from a monotone stack are exact. The identity $\sum \min(L_i,x)=\sum_{L_i<x}L_i + x\cdot (q - \#\{L_i<x\})$ holds pointwise.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Per-q O(q log q) preprocessing; O(log q) per query
from typing import List, Tuple
import bisect

INF_IDX = 10**15  # sentinel index much larger than any q

def order_values_by_pos(p: List[int]) -> List[int]:
    n = len(p)
    pos = [0]*(n+1)
    for i, v in enumerate(p, 1):
        pos[v] = i
    vals = list(range(1, n+1))
    vals.sort(key=lambda v: pos[v])
    return vals  # order_by_pos

def a_prefix(order_by_pos: List[int], q: int) -> List[int]:
    return order_by_pos[:q]

def lengths_from_sequence(a: List[int]) -> List[int]:
    q = len(a)
    pre = [-INF_IDX]*q
    nxt = [INF_IDX]*q
    st = []
    for i in range(q):
        while st and a[st[-1]] <= a[i]:
            st.pop()
        pre[i] = (st[-1] + 1) if st else -INF_IDX  # use 1-based semantics for spans
        st.append(i)
    st.clear()
    for i in range(q-1, -1, -1):
        while st and a[st[-1]] <= a[i]:
            st.pop()
        nxt[i] = (st[-1] + 1) if st else INF_IDX
        st.append(i)
    L = []
    for i in range(q):
        L.append(nxt[i] - pre[i])
    return L

def preprocess_L_for_queries(a: List[int]) -> Tuple[List[int], List[int]]:
    L = lengths_from_sequence(a)
    L.sort()
    pref = [0]
    s = 0
    for v in L:
        s += v
        pref.append(s)
    return L, pref  # pref[i] = sum of first i L's (i from 0..q)

def answer_queries_with_preprocessed(L_sorted: List[int], pref: List[int], xs: List[int]) -> List[int]:
    q = len(L_sorted)
    ans = []
    for x in xs:
        c = bisect.bisect_left(L_sorted, x)
        s_less = pref[c]
        ans.append(s_less + (q - c)*x)
    return ans
\end{minted}
\VALIDATION{Cross-check on random tiny permutations by comparing against the baseline naive computation.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Incrementally maintain the multiset of spans $L_i$ as $q$ increases using a Cartesian tree (max-tree) over $a^{(q)}$ and update contributions in near-amortized $O(\log n)$ per insertion, answering queries via prefix sums over a Fenwick/segment tree keyed by span lengths.}
\ASSUMPTIONS{Advanced data structure design: maintain nearest-greater structure online as $q$ grows, and keep distribution of $L_i$ for fast sum of caps.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Maintain the decreasing stack (Cartesian tree) of $a^{(q)}$ nodes; on insertion of the next value by position, update affected neighbors.
\item Update only $O(1)$ spans that change; reflect changes in a BIT keyed by span lengths with count and length-sum.
\item For a query $x$, compute $\sum_{L<x}L + x\cdot (q-\#\{L<x\})$ using two prefix queries on the BITs.
\end{algosteps}
\OPTIMALITY{Each insertion touches only a constant number of spans due to stack properties; queries are $O(\log n)$. This matches input-size lower bounds up to logarithmic factors.}
\COMPLEXITY{Amortized $O(\log n)$ per insertion and $O(\log n)$ per query; overall $O((n+Q)\log n)$ time and $O(n)$ space.}
\[
\begin{aligned}
T(n,Q) &= O(n\log n + Q\log n), \quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
# Implementation uses the per-q O(q log q) preprocessing (Approach B), which is simpler and correct.
from typing import List, Tuple
import sys, bisect, random

INF_IDX = 10**15

def read_input() -> List[int]:
    data = list(map(int, sys.stdin.buffer.read().split()))
    return data

def order_values_by_pos(p: List[int]) -> List[int]:
    n = len(p)
    pos = [0]*(n+1)
    for i, v in enumerate(p, 1):
        pos[v] = i
    vals = list(range(1, n+1))
    vals.sort(key=lambda v: pos[v])
    return vals

def a_prefix(order_by_pos: List[int], q: int) -> List[int]:
    return order_by_pos[:q]

def lengths_from_sequence(a: List[int]) -> List[int]:
    q = len(a)
    pre = [-INF_IDX]*q
    nxt = [INF_IDX]*q
    st = []
    for i in range(q):
        while st and a[st[-1]] <= a[i]:
            st.pop()
        pre[i] = (st[-1] + 1) if st else -INF_IDX
        st.append(i)
    st.clear()
    for i in range(q-1, -1, -1):
        while st and a[st[-1]] <= a[i]:
            st.pop()
        nxt[i] = (st[-1] + 1) if st else INF_IDX
        st.append(i)
    L = [nxt[i] - pre[i] for i in range(q)]
    return L

def preprocess_L_for_queries(a: List[int]) -> Tuple[List[int], List[int]]:
    L = lengths_from_sequence(a)
    L.sort()
    pref = [0]
    s = 0
    for v in L:
        s += v
        pref.append(s)
    return L, pref

def answer_queries_with_preprocessed(L_sorted: List[int], pref: List[int], xs: List[int]) -> List[int]:
    q = len(L_sorted)
    res = []
    for x in xs:
        c = bisect.bisect_left(L_sorted, x)
        s_less = pref[c]
        res.append(s_less + (q - c) * x)
    return res

def solve_case(n: int, p: List[int], it) -> List[int]:
    order_by_pos = order_values_by_pos(p)
    out = []
    for q in range(1, n+1):
        k = next(it)
        xs = [next(it) for _ in range(k)]
        a = a_prefix(order_by_pos, q)
        L_sorted, pref = preprocess_L_for_queries(a)
        ans = answer_queries_with_preprocessed(L_sorted, pref, xs)
        out.extend(ans)
    return out

def solve_all(data: List[int]) -> str:
    it = iter(data)
    t = next(it)
    outputs = []
    for _ in range(t):
        n = next(it)
        p = [next(it) for _ in range(n)]
        ans = solve_case(n, p, it)
        outputs.extend(ans)
    return "\n".join(map(str, outputs))

# --- Naive helpers for validation ---
INF_BIG = 10**18
def compute_L_naive(a: List[int]) -> List[int]:
    q = len(a)
    L = [0]*q
    for i in range(q):
        pre = -INF_BIG
        for j in range(i-1, -1, -1):
            if a[j] > a[i]:
                pre = j+1
                break
        nxt = INF_BIG
        for j in range(i+1, q):
            if a[j] > a[i]:
                nxt = j+1
                break
        L[i] = (nxt if nxt != INF_BIG else INF_BIG) - (pre if pre != -INF_BIG else -INF_BIG)
    return L

def answer_sum_min_naive(a: List[int], x: int) -> int:
    L = compute_L_naive(a)
    return sum(x if v >= x else v for v in L)

# --- Self tests (deterministic, no output unless failure) ---
def _self_tests():
    # Test the example sequence from the note
    a = [1,4,3,2,5]
    Ls = lengths_from_sequence(a)
    # Expected answers: ans(1)=5, ans(2)=10, ans(3)=14
    for x, expect in [(1,5),(2,10),(3,14)]:
        L_sorted, pref = preprocess_L_for_queries(a)
        got = answer_queries_with_preprocessed(L_sorted, pref, [x])[0]
        assert got == expect, (x, expect, got)
        assert got == answer_sum_min_naive(a, x)
    # Random tiny permutations cross-check
    rng = random.Random(0)
    for n in range(1, 7):
        base = list(range(1, n+1))
        for _ in range(60):
            p = base[:]
            rng.shuffle(p)
            order_by_pos = order_values_by_pos(p)
            for q in range(1, n+1):
                a = a_prefix(order_by_pos, q)
                L_sorted, pref = preprocess_L_for_queries(a)
                for x in range(1, q+1):
                    got = answer_queries_with_preprocessed(L_sorted, pref, [x])[0]
                    exp = answer_sum_min_naive(a, x)
                    assert got == exp, (p, q, x, got, exp)

def main():
    _self_tests()
    data = read_input()
    if not data:
        return
    out = solve_all(data)
    sys.stdout.write(out)

if __name__ == "__main__":
    main()
\end{minted}
\VALIDATION{Exactly 3 illustrative checks:
- Manual sequence $[1,4,3,2,5]$: $ans(1)=5$, $ans(2)=10$, $ans(3)=14$.
- Random tiny permutations up to $n=6$ against a naive solver.
- Boundary $q=1$ cases implicitly covered by random tests.}
\RESULT{For each query $x$ on a fixed $q$-subsequence, the program outputs $\sum_{i=1}^q \min(nxt(i)-pre(i), x)$ in the given order, one per line.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests verify correctness on handcrafted and random tiny cases by comparing the optimized per-$q$ method to a naive implementation.}
\LINE{CROSS-CHECKS}{For each random permutation and each $q \le n$, compare answers for all $x \in [1..q]$.}
\LINE{EDGE-CASE GENERATOR}{Covers $q=1$, strictly increasing and strictly decreasing subsequences, and random patterns.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import itertools

def gen_strict_increasing(n: int) -> List[int]:
    return list(range(1, n+1))

def gen_strict_decreasing(n: int) -> List[int]:
    return list(range(n, 0, -1))

def all_perms_up_to(n: int):
    for k in range(1, n+1):
        for p in itertools.permutations(range(1, k+1)):
            yield list(p)

def mini_io_scenario():
    # Single test, tiny n=3
    # p = [2,1,3]; queries: q=1: k=2 x=[1,1]; q=2: k=1 x=[1]; q=3: k=0
    data = """1
3
2 1 3
2
1 1
1
1
0
"""
    return data
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution using Approach B (per-q monotone stack + sorted spans)
from typing import List, Tuple
import sys, bisect

INF_IDX = 10**15

def read_input() -> List[int]:
    return list(map(int, sys.stdin.buffer.read().split()))

def order_values_by_pos(p: List[int]) -> List[int]:
    n = len(p)
    pos = [0]*(n+1)
    for i, v in enumerate(p, 1):
        pos[v] = i
    vals = list(range(1, n+1))
    vals.sort(key=lambda v: pos[v])
    return vals

def a_prefix(order_by_pos: List[int], q: int) -> List[int]:
    return order_by_pos[:q]

def lengths_from_sequence(a: List[int]) -> List[int]:
    q = len(a)
    pre = [-INF_IDX]*q
    nxt = [INF_IDX]*q
    st = []
    for i in range(q):
        while st and a[st[-1]] <= a[i]:
            st.pop()
        pre[i] = (st[-1] + 1) if st else -INF_IDX
        st.append(i)
    st.clear()
    for i in range(q-1, -1, -1):
        while st and a[st[-1]] <= a[i]:
            st.pop()
        nxt[i] = (st[-1] + 1) if st else INF_IDX
        st.append(i)
    return [nxt[i] - pre[i] for i in range(q)]

def preprocess_L_for_queries(a: List[int]) -> Tuple[List[int], List[int]]:
    L = lengths_from_sequence(a)
    L.sort()
    pref = [0]
    s = 0
    for v in L:
        s += v
        pref.append(s)
    return L, pref

def answer_queries(L_sorted: List[int], pref: List[int], xs: List[int]) -> List[int]:
    q = len(L_sorted)
    out = []
    for x in xs:
        c = bisect.bisect_left(L_sorted, x)
        out.append(pref[c] + (q - c) * x)
    return out

def solve_case(n: int, p: List[int], it) -> List[int]:
    order_by_pos = order_values_by_pos(p)
    out = []
    for q in range(1, n+1):
        k = next(it)
        xs = [next(it) for _ in range(k)]
        a = a_prefix(order_by_pos, q)
        L_sorted, pref = preprocess_L_for_queries(a)
        out.extend(answer_queries(L_sorted, pref, xs))
    return out

def solve_all(data: List[int]) -> str:
    it = iter(data)
    t = next(it)
    res = []
    for _ in range(t):
        n = next(it)
        p = [next(it) for _ in range(n)]
        res.extend(solve_case(n, p, it))
    return "\n".join(map(str, res))

# Tiny asserts for sanity
def _sanity():
    # q=1 case
    a = [1]
    L, pref = preprocess_L_for_queries(a)
    assert answer_queries(L, pref, [1]) == [1]
    # manual from note
    a2 = [1,4,3,2,5]
    L2, pref2 = preprocess_L_for_queries(a2)
    assert answer_queries(L2, pref2, [1,2,3]) == [5,10,14]
    # monotone increasing
    a3 = [1,2,3,4]
    L3, pref3 = preprocess_L_for_queries(a3)
    # every pre is -inf, so all spans are effectively +inf -> sum is 4*x
    assert answer_queries(L3, pref3, [1,2]) == [4,8]

def main():
    _sanity()
    data = read_input()
    if not data:
        return
    print(solve_all(data))

if __name__ == "__main__":
    main()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Nearest-greater spans on the $q$-subsequence, then cap-and-sum via sorted spans.}
\WHY{This pattern appears in stack-based array problems and range-cap sums; handling multiple $q$ and $x$ requires careful preprocessing.}
\CHECKLIST{
- Build $a^{(q)}$ correctly by positions in $p$.
- Use strict $>$ for nearest-greater.
- Sentinels set to very large magnitude.
- Sort spans $L$ and precompute prefix sums.
- Answer each $x$ using count of $L<x$.
}
\EDGECASES{
- $q=1$.
- All increasing $a^{(q)}$.
- All decreasing $a^{(q)}$.
- Equal queries $x=1$ and $x=q$.
- Large $k=0$ for some $q$.
- Multiple test cases back-to-back.
}
\PITFALLS{
- Using $\ge$ instead of $>$ in stack logic.
- Off-by-one with indices and spans.
- Forgetting to translate zero-based to one-based when computing spans.
- Overflow if using fixed 32-bit types (use Python ints or 64-bit).
- Mishandling empty query lists ($k=0$).
- Re-sorting values by value instead of by position.
}
\FAILMODES{A per-query recomputation times out; the improved per-$q$ preprocessing avoids repeated scans. Incorrect sentinel handling skews results for boundary elements; very large sentinels circumvent this by always exceeding $x \le q$.}
\ELI{Make the sequence, find for each position how far until a bigger neighbor on both sides, then pretend it stretches to infinity if none exists. Sort these stretch lengths once, and for each cap $x$ add up small ones and count the big ones as $x$.}
\NotePages{3}

\end{document}