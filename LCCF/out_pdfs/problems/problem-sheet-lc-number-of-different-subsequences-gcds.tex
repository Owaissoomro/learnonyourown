% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Number of Different Subsequences GCDs}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/number-of-different-subsequences-gcds/}}
\LINE{DIFFICULTY / RATING}{Hard}
\STATEMENT{You are given an array \texttt{nums} that consists of positive integers.

The \textbf{GCD} (greatest common divisor) of a sequence of numbers is the greatest integer that divides all the numbers in the sequence evenly.
\begin{itemize}
\item For example, the GCD of the sequence \texttt{[4, 6, 16]} is \texttt{2}.
\end{itemize}

A \textbf{subsequence} of an array is a sequence that can be formed by removing some elements (possibly none) of the array.
\begin{itemize}
\item For example, \texttt{[2, 5, 10]} is a subsequence of \texttt{[1, 2, 1, 2, 4, 1, 5, 10]}.
\end{itemize}

Return the number of different GCDs among all non-empty subsequences of \texttt{nums}.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{nums = [6, 10, 3]}

\quad \textbf{Output:} \texttt{5}

\quad \textbf{Explanation:} The different GCDs are 6, 10, 3, 2, and 1.

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{nums = [5, 15, 40, 5, 6]}

\quad \textbf{Output:} \texttt{7}

\textbf{Constraints:}
\begin{itemize}
\item $1 \le \text{nums.length} \le 10^5$
\item $1 \le \text{nums}[i] \le 2 \times 10^5$
\end{itemize}
}
\BREAKDOWN{We must count distinct values that can appear as a GCD of at least one non-empty subsequence. Brute force over subsequences is infeasible; instead, leverage number theory: a value $g$ is achievable iff the GCD of all present multiples of $g$ equals $g$.}
\ELI{Check each candidate $g$ and combine the numbers that are multiples of $g$; if their GCD collapses to $g$, then $g$ is achievable.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{An array \texttt{nums} of length $n$ with $1 \le n \le 10^5$ and elements $1 \le \texttt{nums}[i] \le 2 \times 10^5$.}
\OUTPUTS{Return a single integer: the count of distinct GCDs over all non-empty subsequences of \texttt{nums}.}
\SAMPLES{
Example A: \texttt{nums = [6, 10, 3]} $\to$ \texttt{5}.

Example B: \texttt{nums = [5, 15, 40, 5, 6]} $\to$ \texttt{7}.
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $A \subset \{1,2,\ldots, U\}$ be the multiset of given numbers with $U = \max(\texttt{nums})$. Define
\begin{BreakableEquation*}
\mathcal{G} \triangleq \{ \gcd(S) : \varnothing \ne S \subseteq \texttt{nums} \}.
\end{BreakableEquation*}
We seek $|\mathcal{G}|$.}
\varmapStart
\var{n}{array length}
\var{U}{maximum value in \texttt{nums}}
\var{\mathrm{present}[x]}{indicator whether value $x$ appears in \texttt{nums}}
\var{g}{candidate GCD value}
\var{m}{multiple index so that $m$ ranges over $g,2g,3g,\ldots$}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
g \in \mathcal{G} \quad \Longleftrightarrow \quad \gcd\bigl(\{\, m \in [1..U] : \mathrm{present}[m] \land g \mid m \,\}\bigr) = g.
\end{BreakableEquation*}
Equivalently, scanning multiples:
\begin{BreakableEquation*}
\text{let } h \gets 0; \quad \forall m \in \{g,2g,\ldots,\lfloor U/g \rfloor g\}:~ \text{if }\mathrm{present}[m]\text{ then } h \gets \gcd(h,m).
\end{BreakableEquation*}
Then $g \in \mathcal{G}$ iff $h = g$.
}
\ASSUMPTIONS{The array entries are positive. Duplicate values are allowed. GCD is over integers and is associative/commutative: $\gcd(\gcd(a,b),c) = \gcd(a,b,c)$.}
\INVARIANTS{
\begin{bullets}
\item For fixed $g$, $h$ maintains $\gcd$ over all encountered present multiples of $g$.
\item If at any time $h=g$, further multiples cannot increase the GCD, thus $g$ is confirmed.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Dynamic propagation of all possible subsequence GCDs over a left-to-right scan. Maintain the set of GCDs obtainable by subsequences ending at current index.}
\ASSUMPTIONS{Avoid enumerating subsequences explicitly; use the identity $\gcd(x, \gcd(S)) = \gcd(\{x\}\cup S)$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Initialize an empty global set $G$ of seen GCDs and an empty current set $S$.
\item For each $x$ in \texttt{nums}: form $S' = \{x\} \cup \{\gcd(x, s) : s \in S\}$; assign $S \gets$ unique elements of $S'$; update $G \gets G \cup S$.
\item Return $|G|$.
\end{algosteps}
\COMPLEXITY{Let $K$ be the maximum size of $S$ during the scan. Typically $K$ is small (bounded by the number of divisors scale), but worst-case analysis yields quasi-polylogarithmic bounds in practice.}
\[
\begin{aligned}
T(n) &\approx \sum_{i=1}^n O(K_i \log U) \\
S(n) &= O(K) \text{ for the rolling set } + O(|G|).
\end{aligned}
\]
\CORRECTNESS{Every subsequence ending at position $i$ is either previous subsequence extended by $x$ or the singleton $\{x\}$. The set $S$ collects exactly the GCDs of such subsequences. The union over all positions gives all subsequence GCDs.}
\EDGECASES{Single element arrays; repeated elements; presence of $1$ (which guarantees answer includes $1$).}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List
import math

class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        # Rolling set of gcds for subsequences ending at current position
        curr = set()
        seen = set()
        for x in nums:
            nxt = {x}
            for g in curr:
                nxt.add(math.gcd(g, x))
            curr = nxt
            seen |= curr
        return len(seen)

# Basic validation
if __name__ == "__main__":
    sol = Solution()
    assert sol.countDifferentSubsequenceGCDs([6, 10, 3]) == 5
    assert sol.countDifferentSubsequenceGCDs([5, 15, 40, 5, 6]) == 7
    assert sol.countDifferentSubsequenceGCDs([7]) == 1
\end{minted}
\VALIDATION{Small hand-checks as above; also try duplicates such as \texttt{[2,2,2]} which should yield \texttt{1}.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Sieve Over Multiples with Early GCD Collapse}
\WHICHFORMULA{Characterize feasibility of $g$ via the GCD of all present multiples of $g$. Iterate $g=1\ldots U$; for each $g$, sweep multiples $m$ and fold $\gcd$. Early stop when the accumulator equals $g$.}
\ASSUMPTIONS{Use a boolean presence array up to $U=\max(\texttt{nums})$. GCD is monotonically non-increasing when folding more numbers, enabling early exit.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Compute $U=\max(\texttt{nums})$ and boolean array \texttt{present} of size $U$.
\item For $g$ from $1$ to $U$:
  \begin{bullets}
  \item Set $h \gets 0$.
  \item For $m$ in $\{g,2g,3g,\ldots\}$ up to $U$: if \texttt{present[m]} then $h \gets \gcd(h,m)$.
  \item If $h=g$, increment answer (early break allowed on $h=g$).
  \end{bullets}
\item Return the answer.
\end{algosteps}
\COMPLEXITY{Each $m$ contributes to at most $\lfloor U/m \rfloor$ candidates as a multiple. The harmonic sum gives near-linear complexity in $U$ with small $\log U$ factors for gcd.}
\[
\begin{aligned}
T(n) &\in O\!\left(U \log U\right) \quad \text{(in practice)} \\
S(n) &= O(U).
\end{aligned}
\]
\CORRECTNESS{If the GCD over all present multiples of $g$ equals $g$, there exists a subset of those multiples whose GCD is $g$; conversely, any subsequence with GCD $g$ is made of multiples of $g$, so the overall GCD of present multiples cannot be less than $g$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List
import math

class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        U = max(nums)
        present = [False] * (U + 1)
        for x in nums:
            present[x] = True

        ans = 0
        for g in range(1, U + 1):
            h = 0
            for m in range(g, U + 1, g):
                if present[m]:
                    h = math.gcd(h, m)
                    if h == g:
                        ans += 1
                        break
        return ans

# Basic validation
if __name__ == "__main__":
    sol = Solution()
    assert sol.countDifferentSubsequenceGCDs([6, 10, 3]) == 5
    assert sol.countDifferentSubsequenceGCDs([5, 15, 40, 5, 6]) == 7
    assert sol.countDifferentSubsequenceGCDs([1, 1, 1]) == 1
\end{minted}
\VALIDATION{Edge checks: presence of $1$; all elements equal; sparse large maximum (e.g., \texttt{[2, 100000]}).}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Number-Theoretic Sieve on Multiples (Final)}
\WHICHFORMULA{Final method: iterate $g=1\ldots U$, fold $\gcd$ over present multiples of $g$ with early termination at $h=g$. This is the standard optimal approach for this problem.}
\ASSUMPTIONS{Requires only $O(U)$ memory and visits each present value across $O(\tau)$ candidate $g$ where $\tau$ denotes number of divisors structure implied by multiples.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build \texttt{present} up to $U=\max(\texttt{nums})$.
\item For each $g$ from $1$ to $U$, accumulate $h = \gcd$ across multiples $m$ where \texttt{present[m]} is true.
\item If $h=g$, count $g$ and early break that loop.
\end{algosteps}
\OPTIMALITY{Any algorithm must, in effect, consider divisibility relations among the $U$-range. The sieve-by-multiples approach achieves near-linear complexity in $U$ while avoiding exponential subsequence enumeration, and matches known accepted solutions and lower-bound heuristics for this setting.}
\COMPLEXITY{Let $U=\max(\texttt{nums})$.}
\[
\begin{aligned}
T(n) &\approx \sum_{g=1}^U \left\lfloor \frac{U}{g} \right\rfloor = U \cdot H_U = O(U \log U), \\
S(n) &= O(U).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List
import math

class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        U = max(nums)
        present = [False] * (U + 1)
        for x in nums:
            present[x] = True

        ans = 0
        for g in range(1, U + 1):
            h = 0
            # Fold gcd over present multiples; early stop on h == g
            for m in range(g, U + 1, g):
                if present[m]:
                    h = math.gcd(h, m)
                    if h == g:
                        ans += 1
                        break
        return ans

# Exactly 3 asserts (mini-tests)
if __name__ == "__main__":
    sol = Solution()
    assert sol.countDifferentSubsequenceGCDs([6, 10, 3]) == 5
    assert sol.countDifferentSubsequenceGCDs([5, 15, 40, 5, 6]) == 7
    assert sol.countDifferentSubsequenceGCDs([7, 14, 21]) == 3  # gcds: 7,14,21
\end{minted}
\VALIDATION{Three asserts shown above cover mixed, duplicate, and pure-multiple cases.}
\RESULT{Return the count of integers $g$ such that the GCD of all present multiples of $g$ equals $g$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Verify examples; singleton arrays; arrays containing 1; all-equal arrays; arrays with large gaps up to the maximum to ensure sieve correctness.}
\LINE{CROSS-CHECKS}{Compare the baseline dynamic-GCD set method versus the sieve method on small random arrays to ensure identical outputs.}
\LINE{EDGE-CASE GENERATOR}{Generate adversarial inputs such as many copies of a prime, powers of two, and mixtures to stress gcd folding and early-stop behavior.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
from typing import List
import random

def gen_singleton(x: int) -> List[int]:
    return [x]

def gen_all_equal(x: int, n: int) -> List[int]:
    return [x] * n

def gen_powers_of_two(n: int) -> List[int]:
    return [1 << i for i in range(n)]

def gen_multiples(base: int, k: int) -> List[int]:
    return [base * i for i in range(1, k + 1)]

def gen_sparse(max_val: int) -> List[int]:
    # Few numbers near the extremes
    return [2, max_val // 2, max_val - 1, max_val]

# Small cross-check harness (non-random, deterministic)
if __name__ == "__main__":
    from math import gcd

    # Baseline
    class Baseline:
        def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
            curr, seen = set(), set()
            for x in nums:
                nxt = {x}
                for g in curr:
                    nxt.add(gcd(g, x))
                curr = nxt
                seen |= curr
            return len(seen)

    # Sieve reference
    class Reference:
        def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
            U = max(nums)
            present = [False] * (U + 1)
            for x in nums:
                present[x] = True
            ans = 0
            for g in range(1, U + 1):
                h = 0
                for m in range(g, U + 1, g):
                    if present[m]:
                        h = gcd(h, m)
                        if h == g:
                            ans += 1
                            break
            return ans

    base = Baseline()
    ref = Reference()

    tests = [
        [6, 10, 3],
        [5, 15, 40, 5, 6],
        gen_singleton(7),
        gen_all_equal(4, 5),
        gen_powers_of_two(6),
        gen_multiples(7, 6),
        gen_sparse(100)
    ]
    for t in tests:
        assert base.countDifferentSubsequenceGCDs(t) == ref.countDifferentSubsequenceGCDs(t)
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List
import math

class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        U = max(nums)
        present = [False] * (U + 1)
        for x in nums:
            present[x] = True

        ans = 0
        for g in range(1, U + 1):
            h = 0
            for m in range(g, U + 1, g):
                if present[m]:
                    h = math.gcd(h, m)
                    if h == g:
                        ans += 1
                        break
        return ans

if __name__ == "__main__":
    sol = Solution()
    assert sol.countDifferentSubsequenceGCDs([6, 10, 3]) == 5
    assert sol.countDifferentSubsequenceGCDs([5, 15, 40, 5, 6]) == 7
    assert sol.countDifferentSubsequenceGCDs([2, 2, 2]) == 1
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count distinct GCDs achievable by subsequences by sieving over candidate $g$ and checking present multiples.}
\WHY{Classic hard LC problem blending number theory and set DP; tests the ability to replace exponential search with divisibility-based sieving.}
\CHECKLIST{
\begin{bullets}
\item Compute $U=\max(\texttt{nums})$.
\item Build \texttt{present} array.
\item For each $g$ from $1$ to $U$, fold $\gcd$ over multiples and early stop on $h=g$.
\item Count and return.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$.
\item All elements equal.
\item Presence of $1$.
\item Large $U$ with sparse \texttt{present}.
\item Prime-only arrays.
\item Arrays where only one multiple per $g$ exists.
\item Duplicates in \texttt{nums}.
\item Maximum bounds near $2 \times 10^5$.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting early termination when $h=g$ (causes slowdown).
\item Using a map of multiples instead of a boolean array (unnecessary overhead).
\item Off-by-one in the multiples loop upper bound.
\item Not handling duplicates correctly in baseline DP.
\item Misinterpreting constraints \texttt{10^5} vs. \texttt{105}.
\item Using division checks instead of stepping by $g$ (slower).
\end{bullets}
}
\FAILMODES{Brute-force subsequence enumeration fails exponentially. Pairwise-only GCD combinations miss longer subsequences. The sieve approach survives due to direct multiple scanning and monotone GCD folding.}
\ELI{To know if $g$ can be a GCD, just look at numbers divisible by $g$ and take their GCD; if it becomes $g$, then some subsequence achieves it. Repeat for all $g$ up to the max number and count how many work.}
\NotePages{3}

\end{document}