% !TeX program = xelatex
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Check Knight Tour Configuration}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{LC}
\LINE{URL}{\url{https://leetcode.com/problems/check-knight-tour-configuration/}}
\LINE{DIFFICULTY / RATING}{medium}
\STATEMENT{There is a knight on an $n \times n$ chessboard. In a valid configuration, the knight starts \emph{at the top-left cell} of the board and visits every cell on the board \emph{exactly once}.

You are given an $n \times n$ integer matrix \texttt{grid} consisting of distinct integers from the range $[0, n \times n - 1]$ where \texttt{grid[row][col]} indicates that the cell $(\text{row}, \text{col})$ is the \texttt{grid[row][col]}th cell that the knight visited. The moves are 0-indexed.

Return \texttt{true} if \texttt{grid} represents a valid configuration of the knight's movements or \texttt{false} otherwise.

\textbf{Note} that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.

\textbf{Example 1:}

\quad \textbf{Input:} \texttt{grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]}

\quad \textbf{Output:} \texttt{true}

\quad \textbf{Explanation:} The above diagram represents the grid. It can be shown that it is a valid configuration.

\textbf{Example 2:}

\quad \textbf{Input:} \texttt{grid = [[0,3,6],[5,8,1],[2,7,4]]}

\quad \textbf{Output:} \texttt{false}

\quad \textbf{Explanation:} The 8th move of the knight is not valid considering its position after the 7th move.

\textbf{Constraints:}
\begin{bullets}
\item \texttt{n == grid.length == grid[i].length}
\item \texttt{3 <= n <= 7}
\item \texttt{0 <= grid[row][col] < n * n}
\item All integers in \texttt{grid} are unique.
\end{bullets}}
\BREAKDOWN{Map each visit index to its cell and verify that consecutive indices correspond to legal knight moves, starting from \texttt{grid[0][0]} equal to 0 and covering all $n^2$ cells exactly once.}
\ELI{Label each square by the step it was visited; check that the labels form a continuous knight path from 0 to $n^2-1$.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One variable \texttt{grid}: a list of lists of integers, shape $n \times n$, with $3 \le n \le 7$. Values should be distinct and lie in $[0, n^2-1]$.}
\OUTPUTS{Return a boolean: \texttt{True} if the configuration is a valid knight tour starting at the top-left cell with move index 0 and visiting all cells exactly once; otherwise \texttt{False}.}
\SAMPLES{
\begin{bullets}
\item \texttt{grid = [[0,3,6],[5,8,1],[2,7,4]]} $\to$ \texttt{False}.
\item \texttt{grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]} $\to$ \texttt{True}.
\end{bullets}
}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $V = \{0,1,\ldots,n^2-1\}$ be the visit indices. Let $p: V \to [n]\times[n]$ map each index $k$ to its cell $(r,c)$. The configuration is valid iff:
\begin{bullets}
\item $p(0) = (0,0)$;
\item $p$ is a bijection between $V$ and the $n^2$ cells;
\item For all $k \in \{0,\ldots,n^2-2\}$, the move from $p(k)$ to $p(k+1)$ is a legal knight move.
\end{bullets}}
\varmapStart
\var{n}{board dimension}
\var{p(k)}{cell $(r,c)$ visited at step $k$}
\var{M}{set of knight move offsets: $\{(\pm1,\pm2),(\pm2,\pm1)\}$}
\var{N}{total steps $n^2$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
p(0) &= (0,0), \\
\{p(k)\mid k\in V\} &= [n]\times[n], \\
\forall k\in[0,N-2]:~&p(k+1) - p(k) \in M.
\end{aligned}
\]
}
\ASSUMPTIONS{Indices are 0-based; all entries of \texttt{grid} are integers. If any value is out of $[0,n^2-1]$ or duplicates occur, the configuration is invalid.}
\INVARIANTS{
\begin{bullets}
\item Each step increases the visit index by 1 along the path.
\item Knight move constraint: for consecutive cells $(r,c)\to(r',c')$, $\{|r-r'|,|c-c'|\}=\{1,2\}$.
\end{bullets}
}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Simulate steps from 0 to $n^2-1$; at step $k$ linearly scan the entire grid to find the unique cell labeled $k+1$ and verify it is a knight move from the current cell.}
\ASSUMPTIONS{Constraints are tiny ($n \le 7$), so an $O(n^4)$ scan is acceptable for a baseline.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Verify \texttt{grid[0][0] == 0}; else return \texttt{False}.
\item Set current cell to $(0,0)$. For $k=0$ to $n^2-2$:
\begin{bullets}
\item Scan all cells to locate the cell with label $k+1$.
\item Check whether the move from current to that cell is a legal knight move.
\item Update current to that cell.
\end{bullets}
\item If all checks pass, return \texttt{True}.
\end{algosteps}
\COMPLEXITY{Let $N=n^2$. Each step does an $O(N)$ scan, repeated $N$ times, so $T(n)=O(N^2)=O(n^4)$; space $S(n)=O(1)$.}
\[
\begin{aligned}
T(n) &= \sum_{k=0}^{N-2} \Theta(N) = \Theta(N^2) = \Theta(n^4),\\
S(n) &= \Theta(1).
\end{aligned}
\]
\CORRECTNESS{The scan finds the unique next label $k+1$ (if present). We verify the knight move condition at every transition, starting at $(0,0)$ at label 0, so the path is validated end-to-end.}
\EDGECASES{Start not at $(0,0)$; missing label $k+1$; out-of-range values; duplicates; non-knight step.}
\textbf{Code (Baseline)}
\begin{minted}{python}
from typing import List

class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        if n == 0 or len(grid[0]) != n:
            return False
        # Start must be 0 at top-left
        if grid[0][0] != 0:
            return False

        def is_knight_move(r1: int, c1: int, r2: int, c2: int) -> bool:
            dr, dc = abs(r1 - r2), abs(c1 - c2)
            return (dr == 1 and dc == 2) or (dr == 2 and dc == 1)

        r, c = 0, 0
        total = n * n
        # Sequentially find next label by scanning the whole grid each time
        for k in range(total - 1):
            target = k + 1
            nr = nc = -1
            for i in range(n):
                for j in range(n):
                    v = grid[i][j]
                    if v == target:
                        nr, nc = i, j
                        break
                if nr != -1:
                    break
            if nr == -1:
                return False
            if not is_knight_move(r, c, nr, nc):
                return False
            r, c = nr, nc
        return True

# Tiny baseline asserts
assert Solution().checkValidGrid([[0,3,6],[5,8,1],[2,7,4]]) is False
assert Solution().checkValidGrid([[0,1,2],[3,4,5],[6,7,8]]) is False
assert Solution().checkValidGrid([[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]) is True
\end{minted}
\VALIDATION{Checks include the two examples and an obviously invalid filled-by-rows grid.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Index Map for O(1) Successor Lookup}
\WHICHFORMULA{Precompute an array \texttt{pos} of length $n^2$ mapping each label to its $(r,c)$ position. Then verify consecutive positions differ by a knight move.}
\ASSUMPTIONS{We rely on a single pass to build \texttt{pos}, robustly rejecting out-of-range and duplicate labels.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If \texttt{grid[0][0] != 0} return \texttt{False}.
\item Initialize \texttt{pos} with $(-1,-1)$ of length $n^2$.
\item For every cell $(i,j)$, let $v=\texttt{grid[i][j]}$; if $v$ is out of range or already seen, return \texttt{False}; else set $\texttt{pos}[v]=(i,j)$.
\item For $k=0$ to $n^2-2$, check that $(\texttt{pos}[k],\texttt{pos}[k+1])$ is a knight move.
\item Return \texttt{True} if all pass.
\end{algosteps}
\COMPLEXITY{Time $O(n^2)$ to build \texttt{pos} plus $O(n^2)$ checks, overall $O(n^2)$; space $O(n^2)$ for \texttt{pos}.}
\[
\begin{aligned}
T(n) &= \Theta(n^2) + \Theta(n^2) = \Theta(n^2),\\
S(n) &= \Theta(n^2).
\end{aligned}
\]
\CORRECTNESS{The bijection is enforced by range and duplicate checks while building \texttt{pos}, the start condition ensures the first move index is at $(0,0)$, and each consecutive pair is validated by the knight move predicate.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List

class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        if n == 0 or len(grid[0]) != n:
            return False
        # Start must be 0 at top-left
        if grid[0][0] != 0:
            return False

        total = n * n
        pos = [(-1, -1)] * total
        seen = [False] * total

        for i in range(n):
            for j in range(n):
                v = grid[i][j]
                if not isinstance(v, int):
                    return False
                if v < 0 or v >= total:
                    return False
                if seen[v]:
                    return False
                seen[v] = True
                pos[v] = (i, j)

        # Every value must appear exactly once
        if not all(seen):
            return False

        def is_knight_move(a, b) -> bool:
            (r1, c1), (r2, c2) = a, b
            dr, dc = abs(r1 - r2), abs(c1 - c2)
            return (dr == 1 and dc == 2) or (dr == 2 and dc == 1)

        for k in range(total - 1):
            if not is_knight_move(pos[k], pos[k + 1]):
                return False

        return True

# Improved asserts
assert Solution().checkValidGrid([[0,3,6],[5,8,1],[2,7,4]]) is False
assert Solution().checkValidGrid([[0,1,2],[3,4,5],[6,7,8]]) is False
assert Solution().checkValidGrid([[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]) is True
\end{minted}
\VALIDATION{Verifies invalid start sequences, an invalid 3x3 row-major fill, and the given valid 5x5 configuration.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Position Map + Local Move Check}
\WHICHFORMULA{Same as Approach B; asymptotically optimal as any algorithm must inspect all $n^2$ entries.}
\ASSUMPTIONS{Input values might violate uniqueness or range; handle defensively.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build \texttt{pos} and \texttt{seen} in one pass while validating range and duplicates.
\item Ensure \texttt{pos[0] == (0,0)} and all labels are present.
\item Check knight move adjacency along indices $0 \to 1 \to \cdots \to n^2-1$.
\end{algosteps}
\OPTIMALITY{A lower bound of $\Omega(n^2)$ follows from needing to read all $n^2$ entries to confirm a permutation and start cell. The algorithm matches this bound.}
\COMPLEXITY{Time $\Theta(n^2)$, space $\Theta(n^2)$.}
\[
\begin{aligned}
T(n) &= \Theta(n^2), \quad S(n) = \Theta(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        if n == 0 or any(len(row) != n for row in grid):
            return False

        total = n * n
        pos: List[Tuple[int, int]] = [(-1, -1)] * total
        seen = [False] * total

        for i in range(n):
            for j in range(n):
                v = grid[i][j]
                if not isinstance(v, int) or v < 0 or v >= total:
                    return False
                if seen[v]:
                    return False
                seen[v] = True
                pos[v] = (i, j)

        # All labels must be present and start must be (0,0)
        if not all(seen):
            return False
        if pos[0] != (0, 0):
            return False

        def is_knight(a: Tuple[int, int], b: Tuple[int, int]) -> bool:
            (r1, c1), (r2, c2) = a, b
            dr, dc = abs(r1 - r2), abs(c1 - c2)
            return (dr == 1 and dc == 2) or (dr == 2 and dc == 1)

        for k in range(total - 1):
            if not is_knight(pos[k], pos[k + 1]):
                return False

        return True

# Exactly 3 asserts
assert Solution().checkValidGrid([[0,3,6],[5,8,1],[2,7,4]]) is False
assert Solution().checkValidGrid([[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]) is True
assert Solution().checkValidGrid([[0,1,2],[3,4,5],[6,7,8]]) is False
\end{minted}
\VALIDATION{Three asserts: the two official examples and a trivial invalid grid.}
\RESULT{Return \texttt{True} iff the visit labels $0,\ldots,n^2-1$ exist exactly once, start at $(0,0)$, and each successive pair is a legal knight move.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover: start not at $(0,0)$, out-of-range values, duplicates, non-square grids, non-knight transitions, and a known valid 5x5 tour.}
\LINE{CROSS-CHECKS}{Compare outputs between baseline (scan) and improved (map) implementations on small crafted cases to ensure identical results.}
\LINE{EDGE-CASE GENERATOR}{Produce deterministic invalid boards (row-major fill), inject out-of-range or duplicate labels, and include the known valid example.}
\begin{minted}{python}
from typing import List, Tuple
import random

def make_row_major(n: int) -> List[List[int]]:
    """Deterministic invalid grid: labels increase left-to-right, top-to-bottom."""
    vals = list(range(n * n))
    return [vals[i*n:(i+1)*n] for i in range(n)]

def introduce_duplicate(grid: List[List[int]]) -> List[List[int]]:
    """Copy grid and overwrite one cell to duplicate another value."""
    n = len(grid)
    g = [row[:] for row in grid]
    if n * n >= 2:
        g[0][0] = g[0][1]
    return g

def introduce_out_of_range(grid: List[List[int]]) -> List[List[int]]:
    """Copy grid and set one cell to out-of-range."""
    n = len(grid)
    g = [row[:] for row in grid]
    g[0][0] = n * n  # invalid
    return g

# Known valid 5x5 from the problem
valid5 = [[0,11,16,5,20],
          [17,4,19,10,15],
          [12,1,8,21,6],
          [3,18,23,14,9],
          [24,13,2,7,22]]

# Sanity checks for generators
assert make_row_major(3) == [[0,1,2],[3,4,5],[6,7,8]]
assert introduce_duplicate([[0,1],[2,3]])[0][0] == 1
assert introduce_out_of_range([[0,1],[2,3]])[0][0] == 4
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
from typing import List, Tuple

class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        # must be square
        if n == 0 or any(len(row) != n for row in grid):
            return False

        total = n * n
        pos: List[Tuple[int, int]] = [(-1, -1)] * total
        seen = [False] * total

        # build position map with validation
        for i in range(n):
            for j in range(n):
                v = grid[i][j]
                if not isinstance(v, int) or v < 0 or v >= total:
                    return False
                if seen[v]:
                    return False
                seen[v] = True
                pos[v] = (i, j)

        # all labels present and start at top-left
        if not all(seen):
            return False
        if pos[0] != (0, 0):
            return False

        def is_knight(a: Tuple[int, int], b: Tuple[int, int]) -> bool:
            (r1, c1), (r2, c2) = a, b
            dr, dc = abs(r1 - r2), abs(c1 - c2)
            return (dr == 1 and dc == 2) or (dr == 2 and dc == 1)

        # verify consecutive moves
        for k in range(total - 1):
            if not is_knight(pos[k], pos[k + 1]):
                return False

        return True

# Reference asserts
S = Solution()
assert S.checkValidGrid([[0,3,6],[5,8,1],[2,7,4]]) is False
assert S.checkValidGrid([[0,1,2],[3,4,5],[6,7,8]]) is False
assert S.checkValidGrid([[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]) is True
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Build a label-to-position map and check that successive labels are connected by legal knight moves starting at $(0,0)$.}
\WHY{Common interview task: validate a permutation-based path with local constraints efficiently.}
\CHECKLIST{
\begin{bullets}
\item Confirm square shape and $n \ge 3$.
\item Check start cell label is 0 at $(0,0)$.
\item Build \texttt{pos} with range and duplicate checks.
\item Verify all labels present.
\item Check knight move between consecutive labels.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item Start not at $(0,0)$.
\item Duplicate labels or missing labels.
\item Values out of range $[0,n^2-1]$.
\item Non-square input.
\item Knight step blocked by non-knight move (e.g., $(0,0)\to(0,1)$).
\item Smallest $n=3$ cases where no full tour exists.
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to enforce \texttt{grid[0][0] == 0}.
\item Not validating duplicates or out-of-range values.
\item Mixing up $(1,2)$ vs $(2,1)$; ensure absolute differences are used.
\item Off-by-one in loop over $k$ up to $n^2-2$.
\item Assuming input guarantees uniqueness without verifying.
\item Not handling non-square grids in general Python environment.
\end{bullets}
}
\FAILMODES{Baseline scan may be slow for larger $n$, but within constraints it passes; improved solution handles all edge validations and is linear in the grid size.}
\ELI{Think of the grid as timestamps of visits. Map each timestamp to where it happened, then make sure every consecutive timestamp is exactly a knight's L-shaped move away.}
\NotePages{3}

\end{document}