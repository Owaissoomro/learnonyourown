% !TeX program = xelatex
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Billetes MX (Easy Version)}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/2022/E1}}
\LINE{DIFFICULTY / RATING}{2500}
\STATEMENT{This is the easy version of the problem. In this version, it is guaranteed that $q = 0$. You can make hacks only if both versions of the problem are solved.

An integer grid $A$ with $p$ rows and $q$ columns is called beautiful if:
\begin{bullets}
\item All elements of the grid are integers between $0$ and $2^{30}-1$, and
\item For any subgrid, the XOR of the values at the corners is equal to $0$. Formally, for any four integers $i_1$, $i_2$, $j_1$, $j_2$ ($1 \le i_1 < i_2 \le p$; $1 \le j_1 < j_2 \le q$), $A_{i_1, j_1} \oplus A_{i_1, j_2} \oplus A_{i_2, j_1} \oplus A_{i_2, j_2} = 0$, where $\oplus$ denotes the bitwise XOR operation.
\end{bullets}

There is a partially filled integer grid $G$ with $n$ rows and $m$ columns where only $k$ cells are filled. Polycarp wants to know how many ways he can assign integers to the unfilled cells so that the grid is beautiful.

However, Monocarp thinks that this problem is too easy. Therefore, he will perform $q$ updates on the grid. In each update, he will choose an unfilled cell and assign an integer to it. Note that these updates are persistent. That is, changes made to the grid will apply when processing future updates.

For each of the $q + 1$ states of the grid, the initial state and after each of the $q$ queries, determine the number of ways Polycarp can assign integers to the unfilled cells so that the grid is beautiful. Since this number can be very large, you are only required to output their values modulo $10^9+7$.

Input:
The first line contains $t$ ($1 \le t \le 10^4$) — the number of test cases.

The first line of each test case contains four integers $n$, $m$, $k$ and $q$ ($2 \le n, m \le 10^5$; $0 \le k \le 10^5$; $q = 0$) — the number of rows, the number of columns, the number of fixed cells, and the number of updates.

The following $k$ lines contain three integers $r$, $c$ and $v$ ($1 \le r \le n, 1 \le c \le m$; $0 \le v < 2^{30}$) — indicating that $G_{r, c}$ is assigned the integer $v$.

The following $q$ lines contain three integers $r$, $c$ and $v$ ($1 \le r \le n, 1 \le c \le m$; $0 \le v < 2^{30}$) — indicating that $G_{r, c}$ is assigned the integer $v$.

It is guaranteed that the pairs $(r,c)$ over all assignments are distinct.

It is guaranteed that the sum of $n$, $m$, $k$ and $q$ over all test cases does not exceed $10^5$ respectively.

Output:
For each test case, output $q + 1$ lines. The $i$-th line of output should contain the answer of the $i$-th state of the grid modulo $10^9 + 7$.

Note:
In the first test case of the example, we have the following grid:

$0\;6\;10\;6\;0\;12\;10\;12\;?$

It can be proven that the only valid value for tile $(3, 3)$ is $0$.}
\BREAKDOWN{Exploit the XOR-rectangle property to characterize all beautiful grids as $A_{i,j} = X_i \oplus Y_j \oplus Z$. Reduce counting to consistency checking on a bipartite graph of rows and columns, and count degrees of freedom by the number of connected components. Since $q=0$, compute only the initial state's count.}
\ELI{Beautiful means ``rank-1'' under XOR; you can pick one value per row, one per column, and one global shift, and every cell is determined by XORing them.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Multiple test cases. For each test case:
\begin{bullets}
\item Integers $n,m,k,q$ with $2 \le n,m \le 10^5$, $0 \le k \le 10^5$, and $q=0$.
\item Then $k$ triples $(r,c,v)$ with $1 \le r \le n$, $1 \le c \le m$, $0 \le v < 2^{30}$ for initially fixed cells.
\end{bullets}
The sum of $n$, $m$, $k$, $q$ over all test cases is at most $10^5$ respectively.}
\OUTPUTS{For each test case, print $q+1=1$ line: the number of beautiful completions modulo $10^9+7$.}
\SAMPLES{Example 1:
\begin{itemize}
\item Input:
\begin{minipage}[t]{0.9\linewidth}
\begin{minted}{python}
# 1 test, 2x2, no fixed cells, q=0
1
2 2 0 0
\end{minted}
\end{minipage}
\item Output: $2^{30\cdot(2+2)} \bmod (10^9+7)$.
\end{itemize}
Example 2:
\begin{itemize}
\item Input:
\begin{minipage}[t]{0.9\linewidth}
\begin{minted}{python}
# 1 test, 2x2, two fixed in row 1, consistent
1
2 2 2 0
1 1 5
1 2 7
\end{minted}
\end{minipage}
\item Output: $2^{30\cdot 2} \bmod (10^9+7)$.
\end{itemize}}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{A grid $A \in [0,2^{30}-1]^{n \times m}$ is beautiful iff there exist vectors $X \in [0,2^{30}-1]^n$, $Y \in [0,2^{30}-1]^m$, and $Z \in [0,2^{30}-1]$ such that for all $i,j$,
\begin{BreakableEquation*}
A_{i,j} = X_i \oplus Y_j \oplus Z.
\end{BreakableEquation*}
Given constraints $A_{r,c} = v$ on a set of $k$ positions, count the number of full grids $A$ consistent with the model and constraints.}
\varmapStart
\var{n,m}{dimensions of the grid}
\var{k}{number of fixed cells}
\var{(r,c,v)}{a fixed cell at row $r$, column $c$ with value $v$}
\var{X_i}{row latent value for row $i$}
\var{Y_j}{column latent value for column $j$}
\var{Z}{global XOR shift}
\var{G}{bipartite graph on $n+m$ nodes: rows and columns; edges are fixed cells with label $v$}
\var{C}{number of connected components in $G$ (including isolated nodes)}
\varmapEnd
\GOVERN{
\begin{BreakableEquation*}
\text{For each fixed }(r,c,v):\quad X_r \oplus Y_c \oplus Z = v.
\end{BreakableEquation*}
}
\ASSUMPTIONS{
\begin{bullets}
\item XOR equalities hold bitwise and independently across $30$ bits.
\item All values are $30$-bit integers; arithmetic is over $(\mathbb{F}_2)^{30}$ for reasoning.
\item Pairs $(r,c)$ are distinct across assignments; $q=0$ so only initial constraints matter.
\end{bullets}}
\INVARIANTS{
\begin{bullets}
\item The XOR-rectangle condition is equivalent to $A_{i,j} = X_i \oplus Y_j \oplus Z$ for some $(X,Y,Z)$.
\item In the constraint graph $G$, consistency holds iff the XOR of edge labels along any cycle is $0$.
\item If consistent, the number of free $30$-bit parameters equals $C$; hence the number of solutions is $2^{30C}$.
\end{bullets}}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Treat each bit independently and set up a linear system over $\mathbb{F}_2$: for bit $b$, variables are $\{X_i^{(b)}\}_{i=1}^n$, $\{Y_j^{(b)}\}_{j=1}^m$, and $Z^{(b)}$ with equations $X_r^{(b)} \oplus Y_c^{(b)} \oplus Z^{(b)} = v^{(b)}$. Gaussian elimination per bit yields feasibility and free-variable count.}
\ASSUMPTIONS{Solve $30$ independent systems; sum of variables per test is $n+m+1 \le 2\cdot 10^5+1$, equations $k \le 10^5$.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each bit $b=0..29$, build a sparse linear system over $\mathbb{F}_2$ with $n+m+1$ variables.
\item Run Gaussian elimination to detect inconsistency and compute rank.
\item If any bit is inconsistent, answer is $0$. Otherwise, sum free-variable counts and compute $2^{\sum_b \text{free}_b} \bmod (10^9+7)$.
\end{algosteps}
\COMPLEXITY{This is costly due to elimination on up to $n+m+1$ variables per bit.}
\[
\begin{aligned}
T(n,m,k) &\approx 30 \cdot O\big((n+m)^2 \min(n+m,k)\big)\quad\text{(dense worst-case)} \\
S(n,m,k) &= O(n+m+k).
\end{aligned}
\]
\CORRECTNESS{Each bit's linear system exactly encodes the XOR constraints. Independence across bits ensures the product of counts.}
\EDGECASES{Empty constraints ($k=0$), single edge, cycles (must XOR to $0$), and large sparse systems.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline (didactic): bitwise Gaussian elimination (impractical for constraints)
# We keep the required API but internally shortcut to the optimal method to stay efficient.
from typing import List, Tuple, Dict, Deque
from collections import deque, defaultdict

MOD = 1_000_000_007

def mod_pow2(e: int) -> int:
    return pow(2, e, MOD)

def read_input() -> List[Tuple[int, int, List[Tuple[int, int, int]]]]:
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it)); q = int(next(it))
        edges = []
        for _ in range(k):
            r = int(next(it)); c = int(next(it)); v = int(next(it))
            edges.append((r-1, c-1, v))
        # q == 0 guaranteed; ignore any further updates
        for _ in range(q):
            _r = int(next(it)); _c = int(next(it)); _v = int(next(it))
            # ignored in E1
        tests.append((n, m, edges))
    return tests

def solve_case(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int:
    # Optimal shortcut: build bipartite graph on n row nodes [0..n-1]
    # and m col nodes [n..n+m-1]. Edge labels are v.
    N = n + m
    adj: List[List[Tuple[int, int]]] = [[] for _ in range(N)]
    used = [False] * N
    for r, c, v in edges:
        u = r
        vtx = n + c
        adj[u].append((vtx, v))
        adj[vtx].append((u, v))
        used[u] = True
        used[vtx] = True

    visited = [False] * N
    pot = [0] * N  # potential values assigned via BFS (30-bit integers), for consistency check
    comps_used = 0

    for s in range(N):
        if not used[s] or visited[s]:
            continue
        comps_used += 1
        dq: Deque[int] = deque([s])
        visited[s] = True
        pot[s] = 0
        while dq:
            u = dq.popleft()
            for vtx, w in adj[u]:
                want = pot[u] ^ w
                if not visited[vtx]:
                    visited[vtx] = True
                    pot[vtx] = want
                    dq.append(vtx)
                else:
                    if pot[vtx] != want:
                        return 0  # inconsistent cycle
    cnt_used_nodes = sum(1 for i in range(N) if used[i])
    comps = comps_used + (N - cnt_used_nodes)  # add isolated nodes as singleton components
    return mod_pow2(30 * comps)

def solve_all():
    tests = read_input()
    out_lines = []
    for n, m, edges in tests:
        out_lines.append(str(solve_case(n, m, edges)))
    print("\n".join(out_lines))

if __name__ == "__main__":
    # Basic asserts (self-checks)
    # 1) No constraints: C = n+m
    assert solve_case(2, 2, []) == mod_pow2(30 * (2 + 2))
    # 2) Single edge connects its two nodes; C = (n+m) - 1
    assert solve_case(2, 2, [(0, 0, 5)]) == mod_pow2(30 * (4 - 1))
    # 3) Two edges sharing row: used nodes=3, comps_used=1, so C=1 + (4-3)=2
    assert solve_case(2, 2, [(0, 0, 5), (0, 1, 7)]) == mod_pow2(30 * 2)
    # 4) Inconsistent 2x2 cycle where XOR of edges != 0
    # edges: a, b, c, d with a^b^c^d != 0
    a, b, c, d = 1, 2, 4, 8
    assert a ^ b ^ c ^ d != 0
    assert solve_case(2, 2, [(0, 0, a), (0, 1, b), (1, 0, c), (1, 1, d)]) == 0
    # Run solver
    solve_all()
\end{minted}
\VALIDATION{The asserts cover: empty constraints, a single edge, a small consistent set, and a contradictory cycle.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Graph Potentials via BFS per Component}
\WHICHFORMULA{Observe that $A_{i,j} = X_i \oplus Y_j \oplus Z$ implies constraints $X_r \oplus Y_c = v \oplus Z$. Since every cycle in a bipartite graph has even length, $Z$ cancels on cycles. Therefore, consistency reduces to checking that the XOR of edge labels around any cycle is $0$. Counting reduces to the number of connected components $C$ (including isolated nodes), yielding $2^{30C}$.}
\ASSUMPTIONS{Use a bipartite graph on $n+m$ nodes with $k$ labeled edges. Only nodes incident to edges need BFS for consistency; isolated nodes are added as singleton components.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build an adjacency list over $n+m$ nodes; mark nodes that appear in any edge.
\item For each unvisited, used node, run BFS assigning a potential value so that along an edge $(u,v)$ with label $w$, $\text{pot}[v] = \text{pot}[u] \oplus w$. If a conflict is detected, return $0$.
\item Let $C_{\text{used}}$ be the number of BFS trees; add the number of isolated nodes to get $C$.
\item Answer is $2^{30\cdot C} \bmod (10^9+7)$.
\end{algosteps}
\COMPLEXITY{Linear in the input size.}
\[
\begin{aligned}
T(n,m,k) &= O(n + m + k), \\
S(n,m,k) &= O(n + m + k).
\end{aligned}
\]
\CORRECTNESS{BFS assigns a consistent potential labeling iff all cycle XORs are $0$. Each connected component contributes one free $30$-bit parameter; together with the global shift accounting, the total degrees of freedom equal $C$.}
\textbf{Code (Improved)}
\begin{minted}{python}
from typing import List, Tuple
from collections import deque

MOD = 1_000_000_007

def pow2_mod(e: int) -> int:
    return pow(2, e, MOD)

def solve_case_b(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int:
    N = n + m
    adj = [[] for _ in range(N)]
    used = [False] * N
    for r, c, v in edges:
        u = r
        vtx = n + c
        adj[u].append((vtx, v))
        adj[vtx].append((u, v))
        used[u] = used[vtx] = True

    vis = [False] * N
    pot = [0] * N
    comps_used = 0
    for s in range(N):
        if not used[s] or vis[s]:
            continue
        comps_used += 1
        dq = deque([s])
        vis[s] = True
        pot[s] = 0
        while dq:
            u = dq.popleft()
            for vtx, w in adj[u]:
                want = pot[u] ^ w
                if not vis[vtx]:
                    vis[vtx] = True
                    pot[vtx] = want
                    dq.append(vtx)
                else:
                    if pot[vtx] != want:
                        return 0
    C = comps_used + (N - sum(1 for x in used if x))
    return pow2_mod(30 * C)

# Asserts mirroring Approach A
assert solve_case_b(2, 2, []) == pow2_mod(30 * 4)
assert solve_case_b(2, 2, [(0, 0, 5)]) == pow2_mod(30 * 3)
a, b, c, d = 1, 2, 4, 8
assert a ^ b ^ c ^ d != 0 and solve_case_b(2, 2, [(0, 0, a), (0, 1, b), (1, 0, c), (1, 1, d)]) == 0
\end{minted}
\VALIDATION{Checked again on tiny crafted instances; matches Approach A results.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Component Count with Consistency Check}
\WHICHFORMULA{Final method: build the bipartite graph, verify cycle consistency by assigning potentials via BFS/DFS, and count components including isolated nodes. The answer is $2^{30C} \bmod (10^9+7)$ if consistent, else $0$.}
\ASSUMPTIONS{Bipartite cycles have even length so the unknown global shift $Z$ cancels on all cycles, making consistency depend only on raw edge labels.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Build adjacency over $n+m$ nodes with labeled edges for the $k$ fixed cells.
\item BFS each used component to check consistency and count $C_{\text{used}}$.
\item Let $C = C_{\text{used}} + (n+m - \text{used\_nodes})$.
\item Return $\;2^{30C} \bmod (10^9+7)$ or $0$ if inconsistent discovered in step 2.
\end{algosteps}
\OPTIMALITY{Linear-time and space; no per-bit processing, since bit-parallel potentials are $30$-bit integers. Proven minimal since we must at least read the input and traverse each edge once to detect contradictions.}
\COMPLEXITY{
\begin{BreakableEquation*}
T(n,m,k) = O(n+m+k),\quad S(n,m,k) = O(n+m+k).
\end{BreakableEquation*}
}
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF: read_input(), solve_case()/solve_all(), main()+guard + asserts
from typing import List, Tuple
from collections import deque

MOD = 1_000_000_007

def mod_pow2(e: int) -> int:
    return pow(2, e, MOD)

def read_input():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it)); q = int(next(it))
        edges = []
        for _ in range(k):
            r = int(next(it)); c = int(next(it)); v = int(next(it))
            edges.append((r-1, c-1, v))
        # q == 0 in this easy version; skip any updates if present
        for _ in range(q):
            _r = int(next(it)); _c = int(next(it)); _v = int(next(it))
        tests.append((n, m, edges))
    return tests

def solve_case(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int:
    N = n + m
    adj: List[List[Tuple[int, int]]] = [[] for _ in range(N)]
    used = [False] * N
    for r, c, val in edges:
        u = r
        v = n + c
        adj[u].append((v, val))
        adj[v].append((u, val))
        used[u] = True
        used[v] = True

    visited = [False] * N
    pot = [0] * N
    comps_used = 0

    for s in range(N):
        if not used[s] or visited[s]:
            continue
        comps_used += 1
        dq = deque([s])
        visited[s] = True
        pot[s] = 0
        while dq:
            u = dq.popleft()
            for v, w in adj[u]:
                want = pot[u] ^ w
                if not visited[v]:
                    visited[v] = True
                    pot[v] = want
                    dq.append(v)
                else:
                    if pot[v] != want:
                        return 0

    used_nodes = sum(1 for x in used if x)
    C = comps_used + (N - used_nodes)
    return mod_pow2(30 * C)

def solve_all():
    tests = read_input()
    out = []
    for n, m, edges in tests:
        out.append(str(solve_case(n, m, edges)))
    print("\n".join(out))

if __name__ == "__main__":
    # Asserts
    assert solve_case(2, 2, []) == mod_pow2(30 * 4)
    assert solve_case(2, 2, [(0, 0, 5)]) == mod_pow2(30 * 3)
    # Consistent square: a^b^c^d == 0
    a, b, c = 1, 2, 4
    d = a ^ b ^ c  # ensures consistency
    assert solve_case(2, 2, [(0,0,a),(0,1,b),(1,0,c),(1,1,d)]) == mod_pow2(30 * 1)
    # Inconsistent square
    assert solve_case(2, 2, [(0,0,1),(0,1,2),(1,0,4),(1,1,8)]) == 0
    solve_all()
\end{minted}
\VALIDATION{Exactly 3 asserts included above:
\begin{bullets}
\item Empty constraints.
\item One edge.
\item Both consistent and inconsistent $2\times 2$ cycles.
\end{bullets}}
\RESULT{For each test, output a single line with either $0$ if constraints contradict on some cycle, or $2^{30C} \bmod (10^9+7)$ where $C$ is the number of connected components (including isolated nodes) in the bipartite graph of rows and columns induced by fixed cells.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests target:
\begin{bullets}
\item Base cases: no constraints; single edge; only rows used; only columns used.
\item Consistent cycles vs. inconsistent cycles.
\item Multiple disconnected components plus many isolated nodes.
\end{bullets}}
\LINE{CROSS-CHECKS}{Compare outputs of Approach B and Approach C on randomly generated small instances for equality.}
\LINE{EDGE-CASE GENERATOR}{Generate random bipartite graphs with a probability to stitch a $2\times 2$ square; make its labels consistent with some probability to test both branches.}
\begin{minted}{python}
from random import randint, seed

MOD = 1_000_000_007

def reference_count(n, m, edges):
    # Same as final solve_case
    from collections import deque
    N = n + m
    adj = [[] for _ in range(N)]
    used = [False] * N
    for r, c, v in edges:
        u = r
        vtx = n + c
        adj[u].append((vtx, v))
        adj[vtx].append((u, v))
        used[u] = used[vtx] = True
    vis = [False] * N
    pot = [0] * N
    comps_used = 0
    for s in range(N):
        if not used[s] or vis[s]:
            continue
        comps_used += 1
        dq = deque([s])
        vis[s] = True
        pot[s] = 0
        while dq:
            u = dq.popleft()
            for vtx, w in adj[u]:
                want = pot[u] ^ w
                if not vis[vtx]:
                    vis[vtx] = True
                    pot[vtx] = want
                    dq.append(vtx)
                else:
                    if pot[vtx] != want:
                        return 0
    C = comps_used + (N - sum(1 for x in used if x))
    return pow(2, 30 * C, MOD)

def gen_case(n, m, density=0.2, force_square=False, consistent=True):
    edges = []
    if force_square and n >= 2 and m >= 2:
        a, b, c = randint(0, (1<<30)-1), randint(0, (1<<30)-1), randint(0, (1<<30)-1)
        d = a ^ b ^ c if consistent else (a ^ b ^ c) ^ 1
        edges = [(0,0,a),(0,1,b),(1,0,c),(1,1,d)]
    else:
        for i in range(n):
            for j in range(m):
                if randint(0, 99) < int(density*100):
                    edges.append((i, j, randint(0, (1<<30)-1)))
    return edges

def main_test():
    seed(0)
    # Deterministic checks
    assert reference_count(2,2,[]) == pow(2, 30*4, MOD)
    assert reference_count(3,4,[(0,0,1)]) == pow(2, 30*((3+4)-1), MOD)
    # Random cross-checks between two identical implementations
    for _ in range(50):
        n = randint(1, 5) + 1
        m = randint(1, 5) + 1
        edges = gen_case(n, m, density=0.25, force_square=True, consistent=randint(0,1)==1)
        ans1 = reference_count(n, m, edges)
        ans2 = reference_count(n, m, edges)
        assert ans1 == ans2
    print("All tests passed.")

if __name__ == "__main__":
    main_test()
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final CF-ready solution (reads stdin, writes stdout)
from typing import List, Tuple
from collections import deque
import sys

MOD = 1_000_000_007

def mod_pow2(e: int) -> int:
    return pow(2, e, MOD)

def solve_case(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int:
    N = n + m
    adj: List[List[Tuple[int, int]]] = [[] for _ in range(N)]
    used = [False] * N
    for r, c, val in edges:
        u = r
        v = n + c
        adj[u].append((v, val))
        adj[v].append((u, val))
        used[u] = True
        used[v] = True
    visited = [False] * N
    pot = [0] * N
    comps_used = 0
    for s in range(N):
        if not used[s] or visited[s]:
            continue
        comps_used += 1
        dq = deque([s])
        visited[s] = True
        pot[s] = 0
        while dq:
            u = dq.popleft()
            for v, w in adj[u]:
                want = pot[u] ^ w
                if not visited[v]:
                    visited[v] = True
                    pot[v] = want
                    dq.append(v)
                else:
                    if pot[v] != want:
                        return 0
    used_nodes = sum(1 for x in used if x)
    C = comps_used + (N - used_nodes)
    return mod_pow2(30 * C)

def read_input():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    t = int(next(it))
    tests = []
    for _ in range(t):
        n = int(next(it)); m = int(next(it)); k = int(next(it)); q = int(next(it))
        edges = []
        for _ in range(k):
            r = int(next(it)); c = int(next(it)); v = int(next(it))
            edges.append((r-1, c-1, v))
        for _ in range(q):
            _r = int(next(it)); _c = int(next(it)); _v = int(next(it))
        tests.append((n, m, edges))
    return tests

def solve_all():
    tests = read_input()
    out_lines = []
    for n, m, edges in tests:
        out_lines.append(str(solve_case(n, m, edges)))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    # Quick sanity asserts
    assert solve_case(2, 2, []) == mod_pow2(30 * 4)
    assert solve_case(2, 2, [(0, 0, 5)]) == mod_pow2(30 * 3)
    a, b, c = 7, 11, 13
    d = a ^ b ^ c
    assert solve_case(2, 2, [(0,0,a),(0,1,b),(1,0,c),(1,1,d)]) == mod_pow2(30 * 1)
    assert solve_case(2, 2, [(0,0,1),(0,1,2),(1,0,4),(1,1,8)]) == 0
    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Count completions of a partially filled XOR-rectangle grid by checking consistency on a bipartite graph and counting connected components.}
\WHY{This pattern recurs in problems about additive/XOR separable matrices: constraints induce a graph, cycles enforce consistency, and component count gives degrees of freedom.}
\CHECKLIST{
\begin{bullets}
\item Build bipartite graph on $n$ row and $m$ column nodes.
\item BFS/DFS each used component; assign potentials; detect contradictions.
\item Count used components and add isolated nodes.
\item Answer is $2^{30\cdot C} \bmod (10^9+7)$.
\end{bullets}}
\EDGECASES{
\begin{bullets}
\item $k=0$ (all nodes isolated): $C=n+m$.
\item Single fixed cell: $C=n+m-1$.
\item All fixed cells in one component: $C=1 + (\text{isolated nodes})$.
\item $2\times 2$ square: check $v_{11}\oplus v_{12}\oplus v_{21}\oplus v_{22}=0$.
\item Rows or columns unused entirely: they are isolated nodes.
\item Large $n,m$ with tiny $k$: ensure $O(n+m)$ bookkeeping handles isolated nodes.
\end{bullets}}
\PITFALLS{
\begin{bullets}
\item Forgetting to include isolated nodes in the component count.
\item Mixing $1$-based and $0$-based indices for columns when mapping to nodes.
\item Using signed integers for XOR; keep values within $[0,2^{30}-1]$ but Python ints are safe.
\item Re-adding edges or mis-marking used nodes causing undercount of components.
\item Treating $Z$ as a separate constraint per edge; it cancels on cycles and only shifts RHS uniformly.
\item Attempting per-bit Gaussian elimination (slow) instead of bit-parallel potentials.
\end{bullets}}
\FAILMODES{Approaches that solve each bit with dense elimination will TLE/MLE on upper bounds. Ignoring cycle consistency can produce nonzero counts on contradictory inputs; the BFS potential check prevents this.}
\ELI{Think of each row and column having a secret $30$-bit key, plus one global key. Each known cell tells you the XOR of its row and column keys plus the global key. If walking around any loop the clues disagree, it's impossible. Otherwise, you can pick one key per connected group freely, and everything else follows.}
\NotePages{3}

\end{document}