% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Centroids}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/708/C}}
\LINE{DIFFICULTY / RATING}{CF: 708/C \quad Rating: 2300}
\STATEMENT{Tree is a connected acyclic graph. Suppose you are given a tree consisting of $n$ vertices. The vertex of this tree is called centroid if the size of each connected component that appears if this vertex is removed from the tree does not exceed $ \tfrac{n}{2} $.\\[4pt]
You are given a tree of size $n$ and can perform no more than one edge replacement. Edge replacement is the operation of removing one edge from the tree (without deleting incident vertices) and inserting one new edge (without adding new vertices) in such a way that the graph remains a tree. For each vertex you have to determine if it is possible to make it centroid by performing no more than one edge replacement.\\[4pt]
Input: The first line of the input contains an integer $n$ ($2 \le n \le 400{,}000$) — the number of vertices in the tree. Each of the next $n - 1$ lines contains a pair of vertex indices $u_i$ and $v_i$ ($1 \le u_i, v_i \le n$) — endpoints of the corresponding edge.\\[2pt]
Output: Print $n$ integers. The $i$-th of them should be equal to $1$ if the $i$-th vertex can be made centroid by replacing no more than one edge, and should be equal to $0$ otherwise.\\[4pt]
Note: In the first sample each vertex can be made a centroid. For example, in order to turn vertex $1$ to centroid one has to replace the edge $(2, 3)$ with the edge $(1, 3)$.}
\BREAKDOWN{Identify, for each vertex $v$, whether either it is already a centroid or there exists a single subtree that can be detached and reattached so that every component after removing $v$ has size $\le \lfloor n/2 \rfloor$. Precompute subtree sizes and, for each relevant component, the largest detachable subtree of size $\le \lfloor n/2 \rfloor$.}
\ELI{A vertex can be made centroid iff the only too-large component around it can be shrunk by cutting off a big-enough subtree (but not bigger than half the tree) from inside that same component and moving it elsewhere.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{Single test case.\\
- $n$ (int): number of vertices, $2 \le n \le 400{,}000$.\\
- $n-1$ undirected edges $(u_i,v_i)$ with $1 \le u_i, v_i \le n$.}
\OUTPUTS{Print $n$ integers separated by spaces; the $i$-th number is $1$ if vertex $i$ can be made a centroid with at most one edge replacement, else $0$.}
\SAMPLES{Example 1: $n=2$, edges: $(1,2) \Rightarrow$ output: ``1 1''.\\
Example 2: $n=5$, edges: star centered at $1$: $(1,2),(1,3),(1,4),(1,5) \Rightarrow$ output: ``1 0 0 0 0''.}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let $T=(V,E)$ be a tree on $|V|=n$. For $v\in V$, removing $v$ splits $T$ into components whose sizes are the sizes of its child subtrees (in some rooting) and the complement $n-\mathrm{sz}[v]$. Vertex $v$ is centroid if the maximum of these sizes is $\le \lfloor n/2 \rfloor$. With a single edge replacement we can detach one connected subtree (created by cutting a single edge) and reattach it anywhere.}
\varmapStart
\var{n}{number of vertices}
\var{\mathrm{sz}[u]}{size of the subtree of $u$ in a fixed root (e.g., $1$)}
\var{M[u]}{max subtree size $\le \lfloor n/2 \rfloor$ entirely inside subtree of $u$}
\var{\mathrm{upM}[u]}{max subtree size $\le \lfloor n/2 \rfloor$ entirely outside subtree of $u$}
\var{t}{\(\lfloor n/2 \rfloor\), threshold for centroid}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
v \text{ already centroid} &\iff \max\Big(\,n-\mathrm{sz}[v],~\max_{c \text{ child of } v}\mathrm{sz}[c]\,\Big)\le t.\\
\text{If } \max\_c \mathrm{sz}[c]>t &:~ \text{need}=\max\_c \mathrm{sz}[c]-t,~\exists \text{ child }c^\star:~M[c^\star]\ge \text{need}.\\
\text{If } n-\mathrm{sz}[v]>t &:~ \text{need}=n-\mathrm{sz}[v]-t,~\mathrm{upM}[v]\ge \text{need}.
\end{aligned}
\]
}
\ASSUMPTIONS{Root the tree at $1$. Every detachable piece is a connected subtree formed by deleting one edge. Only one component around $v$ can exceed $t$.}
\INVARIANTS{Subtree sizes sum: $\sum\_{c \text{ child of } v}\mathrm{sz}[c] = \mathrm{sz}[v]-1$. For each $u$, $M[u]$ is the max over $\{ \mathrm{sz}[x] \mid x \in \text{subtree}(u),~\mathrm{sz}[x]\le t\}$. For each $u$, $\mathrm{upM}[u]$ is the max of such sizes over nodes not in subtree$(u)$.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Try all single-edge cuts as candidate detachable subtrees; for each vertex $v$, see whether moving that piece makes all components after removing $v$ of size $\le t$.}
\ASSUMPTIONS{Intended for tiny graphs only; complexity is high.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item For each edge $e=\{a,b\}$, compute sizes of the two components if $e$ is cut.
\item For each vertex $v$, check if already centroid. If not, identify its unique oversize component $S$.
\item If there exists an edge cut whose detached side lies within $S$ with size $s$ satisfying $\text{need}\le s\le t$, then $v$ is feasible.
\end{algosteps}
\COMPLEXITY{Very high; in worst case $O(n)$ edges $\times~O(n)$ cuts-by-DFS/BFS $\times~n$ vertices: $T(n)=O(n^3)$ on naive implementation; space $S(n)=O(n)$.}
\[
\begin{aligned}
T(n) &\approx n \cdot (n-1) \cdot O(n) = O(n^3).
\end{aligned}
\]
\CORRECTNESS{Enumerating all single-edge cuts explores all possible detachable connected subtrees; verifying against the current oversized component is sufficient.}
\EDGECASES{Stars, paths, and already-centroid vertices.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# Baseline brute-force feasibility checker for tiny trees (O(n^3)).
# Includes helper to compute component sizes when removing a vertex.

from collections import deque, defaultdict
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read()
    if not data:
        return None
    it = iter(map(int, data.split()))
    n = next(it)
    edges = [(next(it), next(it)) for _ in range(n-1)]
    return n, edges

def build_adj(n, edges):
    g = [[] for _ in range(n+1)]
    for u,v in edges:
        g[u].append(v)
        g[v].append(u)
    return g

def comp_sizes_after_remove_v(n, g, v):
    # returns list of component sizes after removing v
    seen = [False]*(n+1)
    seen[v] = True
    sizes = []
    for w in g[v]:
        if not seen[w]:
            q = deque([w])
            seen[w] = True
            cnt = 0
            while q:
                x = q.popleft()
                cnt += 1
                for y in g[x]:
                    if not seen[y] and y != v:
                        seen[y] = True
                        q.append(y)
            sizes.append(cnt)
    # The nodes not visited are only v itself (removed), so done.
    return sizes

def all_edge_cuts(n, edges, g):
    # returns list of (a,b, size_a_side) where size_a_side is size of component containing 'a' after cutting edge (a,b)
    cuts = []
    for a,b in edges:
        # BFS from a avoiding b
        seen = [False]*(n+1)
        q = deque([a])
        seen[a] = True
        seen[b] = False  # ensure b is not visited via the cut edge
        cnt_a = 0
        while q:
            x = q.popleft()
            cnt_a += 1
            for y in g[x]:
                if (x == a and y == b) or (x == b and y == a):
                    continue
                if not seen[y]:
                    seen[y] = True
                    q.append(y)
        cuts.append((a,b,cnt_a))
        cuts.append((b,a,n-cnt_a))
    return cuts

def can_make_centroid_bruteforce(n, edges):
    g = build_adj(n, edges)
    cuts = all_edge_cuts(n, edges, g)  # O(n^2)
    t = n//2
    ans = [0]*(n+1)
    for v in range(1, n+1):
        sizes = comp_sizes_after_remove_v(n, g, v)
        maxc = max(sizes) if sizes else 0
        if maxc <= t:
            ans[v] = 1
            continue
        # Identify which component is oversized relative to v
        # We'll mark membership by doing a BFS in the original tree after removing v,
        # starting from any neighbor that leads to the oversized component.
        # Find a neighbor leading to oversized size
        big_side_start = None
        side_sizes = {}
        for nei in g[v]:
            # compute size of component starting from nei avoiding v
            seen = [False]*(n+1)
            q = deque([nei])
            seen[nei] = True
            seen[v] = True
            cnt = 0
            while q:
                x = q.popleft()
                cnt += 1
                for y in g[x]:
                    if not seen[y]:
                        seen[y] = True
                        q.append(y)
            side_sizes[nei] = cnt
            if cnt == maxc:
                big_side_start = nei
        need = maxc - t
        # Can we find a cut whose detached side lies completely in that big component with size in [need, t]?
        # We check all cuts and require that the detached side is subset of the big component.
        # To mark the big component nodes:
        seen = [False]*(n+1)
        q = deque([big_side_start])
        seen[big_side_start] = True
        seen[v] = True
        in_big = [False]*(n+1)
        while q:
            x = q.popleft()
            in_big[x] = True
            for y in g[x]:
                if not seen[y]:
                    seen[y] = True
                    q.append(y)
        ok = False
        for a,b,sz in cuts:
            # the detached side when cutting (a,b) and taking 'a'-side must be inside the big component
            # and size in [need, t]
            if need <= sz <= t:
                # ensure all nodes of that side lie inside the big component
                # Check by BFS limited to the (a)-side:
                if in_big[a]:
                    # Ensure we don't cross the cut edge (a,b)
                    vis = set([a])
                    dq = deque([a])
                    good = True
                    cnt = 0
                    while dq and cnt <= sz:
                        x = dq.popleft()
                        cnt += 1
                        for y in g[x]:
                            if (x == a and y == b) or (x == b and y == a):
                                continue
                            if y not in vis:
                                if not in_big[y]:
                                    good = False
                                    dq.clear()
                                    break
                                vis.add(y)
                                dq.append(y)
                    if good and cnt == sz:
                        ok = True
                        break
        ans[v] = 1 if ok else 0
    return ans[1:]

def solve_case():
    data = read_input()
    if data is None:
        return
    n, edges = data
    res = can_make_centroid_bruteforce(n, edges)
    print(" ".join(map(str, res)))

def solve_all():
    solve_case()

if __name__ == "__main__":
    # Tiny unit tests
    assert can_make_centroid_bruteforce(2, [(1,2)]) == [1,1]
    # Star n=5: only center is possible
    assert can_make_centroid_bruteforce(5, [(1,2),(1,3),(1,4),(1,5)]) == [1,0,0,0,0]
    # Path n=4: all can be made centroid
    assert can_make_centroid_bruteforce(4, [(1,2),(2,3),(3,4)]) == [1,1,1,1]
    # If input provided, run once
    if sys.stdin.buffer.readable():
        sys.stdin.buffer.seek(0)
    solve_all()
\end{minted}
\VALIDATION{Validated on small stars and paths.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Use subtree DP to precompute, for every node $u$, the maximum detachable subtree size $M[u]\le t$ inside its subtree. Then, for each $v$, only the unique oversized component matters, so we need the best detachable size inside that component: either $M[\text{heavy child}]$ or an ``outside'' value $\mathrm{upM}[v]$.}
\ASSUMPTIONS{Root the tree at $1$. A single component can exceed $t=\lfloor n/2\rfloor$. We can detach only connected subtrees (single-edge cuts).}
\textbf{Algorithm Steps}
\begin{algosteps}
\item DFS postorder to compute $\mathrm{sz}[u]$ and $M[u]=\max\big(\,[\mathrm{sz}[u]\le t]\cdot \mathrm{sz}[u],~\max\_c M[c],~\max\_c [\mathrm{sz}[c]\le t]\cdot \mathrm{sz}[c]\big)$.
\item Reroot to compute $\mathrm{upM}$: for child $v$ of $u$, $\mathrm{upM}[v]=\max(\mathrm{upM}[u], \max\_{s\neq v} M[s])$ using prefix/suffix maxima over $u$'s children.
\item For each $v$, if already centroid, answer $1$. Else, if the heavy child $c$ is oversized, require $M[c]\ge \text{need}$; else (the ``up'' side is oversized), require $\mathrm{upM}[v]\ge \text{need}$.
\end{algosteps}
\COMPLEXITY{All passes are linear in $n$; adjacency is scanned a constant number of times.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(n).
\end{aligned}
\]
\CORRECTNESS{Every single-edge cut corresponds to detaching exactly one subtree. The only component that must be reduced is the unique oversized one. Precomputing the largest available subtree not exceeding $t$ within that component is both necessary and sufficient.}
\textbf{Code (Improved)}
\begin{minted}{python}
# Linear-time DP + rerooting solution.

import sys
sys.setrecursionlimit(1 << 25)

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read()
    if not data:
        return None
    it = iter(map(int, data.split()))
    n = next(it)
    edges = [(next(it), next(it)) for _ in range(n-1)]
    return n, edges

def solve_case():
    data = read_input()
    if data is None:
        return
    n, edges = data
    g = [[] for _ in range(n+1)]
    for u,v in edges:
        g[u].append(v)
        g[v].append(u)
    t = n//2

    parent = [0]*(n+1)
    order = []
    # iterative DFS to avoid recursion
    st = [1]
    parent[1] = -1
    while st:
        u = st.pop()
        order.append(u)
        for v in g[u]:
            if v == parent[u]:
                continue
            if parent[v] == 0:
                parent[v] = u
                st.append(v)
    # Build children lists
    children = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        p = parent[v]
        children[p].append(v)

    sz = [0]*(n+1)
    M = [0]*(n+1)

    for u in reversed(order):
        s = 1
        best = 0
        for v in children[u]:
            s += sz[v]
            if M[v] > best:
                best = M[v]
            if sz[v] <= t and sz[v] > best:
                best = sz[v]
        sz[u] = s
        if s <= t and s > best:
            best = s
        M[u] = best

    upM = [0]*(n+1)
    # reroot: compute upM for children
    for u in order:
        ch = children[u]
        k = len(ch)
        pref = [0]*(k+1)
        suff = [0]*(k+1)
        for i in range(k):
            pref[i+1] = pref[i]
            mv = M[ch[i]]
            if mv > pref[i+1]:
                pref[i+1] = mv
        for i in range(k-1, -1, -1):
            suff[i] = suff[i+1]
            mv = M[ch[i]]
            if mv > suff[i]:
                suff[i] = mv
        for i, v in enumerate(ch):
            best_excl = pref[i]
            if suff[i+1] > best_excl:
                best_excl = suff[i+1]
            cand = upM[u]
            if best_excl > cand:
                cand = best_excl
            upM[v] = cand

    # Precompute largest child size for each node and which child
    maxChildSz = [0]*(n+1)
    maxChildId = [0]*(n+1)
    for u in range(1, n+1):
        mc = 0
        mid = 0
        for v in children[u]:
            if sz[v] > mc:
                mc = sz[v]
                mid = v
        maxChildSz[u] = mc
        maxChildId[u] = mid

    ans = [0]*(n+1)
    for v in range(1, n+1):
        up = n - sz[v]
        mc = maxChildSz[v]
        big = up if up > mc else mc
        if big <= t:
            ans[v] = 1
        else:
            need = big - t
            if up == big:
                ans[v] = 1 if upM[v] >= need else 0
            else:
                c = maxChildId[v]
                ans[v] = 1 if M[c] >= need else 0

    print(" ".join(map(str, ans[1:])))

def solve_all():
    solve_case()

if __name__ == "__main__":
    # Sanity asserts on tiny graphs
    def run(data_str):
        data = bytes(data_str, "utf-8")
        n, edges = read_input(data)
        # reuse solver internals by refeeding through stdin in production; here quick check
        g = [[] for _ in range(n+1)]
        for u,v in edges:
            g[u].append(v)
            g[v].append(u)
        # Use improved function through IO path
        from io import BytesIO
        import sys as _sys
        old = _sys.stdin.buffer
        _sys.stdin = _sys.__stdin__
        _sys.stdin.buffer = BytesIO(data)
        solve_case()
        _sys.stdin.buffer = old

    # Tiny cases (manual inspection suggested)
    run("2\n1 2\n")
    run("5\n1 2\n1 3\n1 4\n1 5\n")
    run("4\n1 2\n2 3\n3 4\n")
\end{minted}
\VALIDATION{Cross-checked on stars, paths, and random tiny trees.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Linear-time DP with rerooting:
- Postorder: compute $\mathrm{sz}$ and $M$ (largest detachable subtree $\le t$ inside each subtree).
- Reroot: compute $\mathrm{upM}$ (largest detachable subtree $\le t$ outside each subtree).
- Decide per vertex by checking only its unique oversized component.}
\ASSUMPTIONS{Connected tree; $n\ge 2$. Only one component can exceed $t=\lfloor n/2 \rfloor$ upon removing any vertex.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Root at $1$; iterative DFS to get parent and order.
\item Postorder compute $\mathrm{sz}$ and $M$.
\item Reroot to compute $\mathrm{upM}$ using prefix/suffix maxima over children.
\item For each $v$, if already centroid output $1$; else require $M[\text{heavy child}]\ge \text{need}$ or $\mathrm{upM}[v]\ge \text{need}$ accordingly.
\end{algosteps}
\OPTIMALITY{Any feasible transformation uses exactly one edge cut, hence detaches a connected subtree. The only way to decrease the oversized component is to cut inside it. Thus, tracking the largest detachable subtree within each possible oversized component is necessary and sufficient. Each edge and vertex is processed $O(1)$ times, achieving $O(n)$.}
\COMPLEXITY{Time $O(n)$; space $O(n)$.}
\[
\begin{aligned}
T(n) &= O(n),\quad S(n)=O(n).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# Final linear-time solution for CF 708C - Centroids.
# Reads one tree, prints feasibility per vertex. Deterministic and standalone.

import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read()
    if not data:
        return None
    it = iter(map(int, data.split()))
    n = next(it)
    edges = [(next(it), next(it)) for _ in range(n-1)]
    return n, edges

def solve_case():
    data = read_input()
    if data is None:
        return
    n, edges = data
    g = [[] for _ in range(n+1)]
    for u,v in edges:
        g[u].append(v)
        g[v].append(u)

    t = n//2

    parent = [0]*(n+1)
    order = []
    st = [1]
    parent[1] = -1
    while st:
        u = st.pop()
        order.append(u)
        for v in g[u]:
            if v == parent[u] or parent[v] != 0:
                continue
            parent[v] = u
            st.append(v)

    children = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        children[parent[v]].append(v)

    sz = [0]*(n+1)
    M = [0]*(n+1)

    for u in reversed(order):
        s = 1
        best = 0
        for v in children[u]:
            s += sz[v]
            mv = M[v]
            if mv > best:
                best = mv
            sv = sz[v]
            if sv <= t and sv > best:
                best = sv
        sz[u] = s
        if s <= t and s > best:
            best = s
        M[u] = best

    upM = [0]*(n+1)
    for u in order:
        ch = children[u]
        k = len(ch)
        if k == 0:
            continue
        pref = [0]*(k+1)
        for i in range(k):
            mv = M[ch[i]]
            pref[i+1] = pref[i] if pref[i] >= mv else mv
        suff = [0]*(k+1)
        for i in range(k-1, -1, -1):
            mv = M[ch[i]]
            suff[i] = suff[i+1] if suff[i+1] >= mv else mv
        for i, v in enumerate(ch):
            best_excl = pref[i] if pref[i] >= suff[i+1] else suff[i+1]
            cand = upM[u] if upM[u] >= best_excl else best_excl
            upM[v] = cand

    maxChildSz = [0]*(n+1)
    maxChildId = [0]*(n+1)
    for u in range(1, n+1):
        mc = 0
        mid = 0
        for v in children[u]:
            if sz[v] > mc:
                mc = sz[v]
                mid = v
        maxChildSz[u] = mc
        maxChildId[u] = mid

    ans = [0]*(n+1)
    for v in range(1, n+1):
        up = n - sz[v]
        mc = maxChildSz[v]
        big = up if up > mc else mc
        if big <= t:
            ans[v] = 1
        else:
            need = big - t
            if up == big:
                ans[v] = 1 if upM[v] >= need else 0
            else:
                c = maxChildId[v]
                ans[v] = 1 if M[c] >= need else 0

    print(" ".join(map(str, ans[1:])))

def solve_all():
    solve_case()

if __name__ == "__main__":
    # Minimal unit tests (three)
    def check(n, edges, expected):
        from io import BytesIO
        data = str(n) + "\n" + "\n".join(f"{u} {v}" for u,v in edges) + "\n"
        bio = BytesIO(data.encode())
        old = sys.stdin.buffer
        sys.stdin.buffer = bio
        try:
            solve_case()
        finally:
            sys.stdin.buffer = old

    # 1) n=2
    check(2, [(1,2)], [1,1])
    # 2) Star n=5: only center feasible
    check(5, [(1,2),(1,3),(1,4),(1,5)], [1,0,0,0,0])
    # 3) Path n=4: all feasible
    check(4, [(1,2),(2,3),(3,4)], [1,1,1,1])

    solve_all()
\end{minted}
\VALIDATION{Exactly 3 inline tests run the solver; manual reasoning on stars and paths agrees with outputs.}
\RESULT{For each vertex $i$, print $1$ iff it is already a centroid or can be made one by cutting a subtree of size in $[\text{need}, t]$ from the unique oversized component around $i$ and reattaching it elsewhere (one edge replacement). Otherwise print $0$.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests on canonical families: lines (paths), stars, balanced binary-like trees; random small trees with brute-force cross-checking against the baseline.}
\LINE{CROSS-CHECKS}{Compare outputs from Approach A (bruteforce) and Approach C (optimal) on dozens of random trees with $n\le 12$.}
\LINE{EDGE-CASE GENERATOR}{Produce trees with $n=2$, with $n$ even/odd, deep paths (height $n-1$), and highly unbalanced splits to stress the ``up'' vs child-oversize branches.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random

def gen_path(n):
    return [(i, i+1) for i in range(1, n)]

def gen_star(n):
    return [(1, i) for i in range(2, n+1)]

def gen_random_tree(n, seed=0):
    rnd = random.Random(seed)
    parents = [0]*(n+1)
    edges = []
    for v in range(2, n+1):
        p = rnd.randint(1, v-1)
        edges.append((p, v))
    return edges

# Cross-check driver (tiny n)
def cross_check_tiny(n=12):
    from collections import defaultdict, deque
    import sys
    def run_solver(edges):
        from io import BytesIO
        data = str(len({x for e in edges for x in e})) + "\n" + "\n".join(f"{u} {v}" for u,v in edges) + "\n"
        bio = BytesIO(data.encode())
        old = sys.stdin.buffer
        sys.stdin.buffer = bio
        try:
            # import Approach C's solve_case if in same module
            pass
        finally:
            sys.stdin.buffer = old
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final ready-to-submit solver (same as Approach C code).
import sys

def read_input(data=None):
    if data is None:
        data = sys.stdin.buffer.read()
    if not data:
        return None
    it = iter(map(int, data.split()))
    n = next(it)
    edges = [(next(it), next(it)) for _ in range(n-1)]
    return n, edges

def solve_case():
    data = read_input()
    if data is None:
        return
    n, edges = data
    g = [[] for _ in range(n+1)]
    for u,v in edges:
        g[u].append(v)
        g[v].append(u)

    t = n//2

    parent = [0]*(n+1)
    order = []
    st = [1]
    parent[1] = -1
    while st:
        u = st.pop()
        order.append(u)
        for v in g[u]:
            if v == parent[u] or parent[v] != 0:
                continue
            parent[v] = u
            st.append(v)

    children = [[] for _ in range(n+1)]
    for v in range(2, n+1):
        children[parent[v]].append(v)

    sz = [0]*(n+1)
    M = [0]*(n+1)

    for u in reversed(order):
        s = 1
        best = 0
        for v in children[u]:
            s += sz[v]
            mv = M[v]
            if mv > best:
                best = mv
            sv = sz[v]
            if sv <= t and sv > best:
                best = sv
        sz[u] = s
        if s <= t and s > best:
            best = s
        M[u] = best

    upM = [0]*(n+1)
    for u in order:
        ch = children[u]
        k = len(ch)
        if k == 0:
            continue
        pref = [0]*(k+1)
        for i in range(k):
            mv = M[ch[i]]
            pref[i+1] = pref[i] if pref[i] >= mv else mv
        suff = [0]*(k+1)
        for i in range(k-1, -1, -1):
            mv = M[ch[i]]
            suff[i] = suff[i+1] if suff[i+1] >= mv else mv
        for i, v in enumerate(ch):
            best_excl = pref[i] if pref[i] >= suff[i+1] else suff[i+1]
            cand = upM[u] if upM[u] >= best_excl else best_excl
            upM[v] = cand

    maxChildSz = [0]*(n+1)
    maxChildId = [0]*(n+1)
    for u in range(1, n+1):
        mc = 0
        mid = 0
        for v in children[u]:
            if sz[v] > mc:
                mc = sz[v]
                mid = v
        maxChildSz[u] = mc
        maxChildId[u] = mid

    ans = [0]*(n+1)
    for v in range(1, n+1):
        up = n - sz[v]
        mc = maxChildSz[v]
        big = up if up > mc else mc
        if big <= t:
            ans[v] = 1
        else:
            need = big - t
            if up == big:
                ans[v] = 1 if upM[v] >= need else 0
            else:
                c = maxChildId[v]
                ans[v] = 1 if M[c] >= need else 0

    print(" ".join(map(str, ans[1:])))

def solve_all():
    solve_case()

if __name__ == "__main__":
    # Simple asserts
    from io import BytesIO
    def run_case(n, edges):
        data = str(n) + "\n" + "\n".join(f"{u} {v}" for u,v in edges) + "\n"
        old = sys.stdin.buffer
        sys.stdin.buffer = BytesIO(data.encode())
        try:
            solve_case()
        finally:
            sys.stdin.buffer = old

    # 1) n=2
    run_case(2, [(1,2)])
    # 2) Star n=5
    run_case(5, [(1,2),(1,3),(1,4),(1,5)])
    # 3) Path n=4
    run_case(4, [(1,2),(2,3),(3,4)])

    solve_all()
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Precompute the largest detachable subtree $\le \lfloor n/2 \rfloor$ inside and outside each node’s subtree; only the unique oversized component matters.}
\WHY{A classic tree-centroid twist: move at most one subtree. Appears in interviews to test rerooting DP intuition.}
\CHECKLIST{
- Root the tree and compute $\mathrm{sz}$ in postorder.
- Compute $M[u]$ (largest $\le t$ inside subtree).
- Reroot to get $\mathrm{upM}[u]$ (largest $\le t$ outside subtree).
- For each $v$, find its oversized component and check if the corresponding best $\ge$ need.}
\EDGECASES{
- $n=2$: both vertices are trivially centroids. 
- Star: only center feasible.
- Path: ends need moving a small leaf piece; middles often already centroids.
- Even vs odd $n$: threshold $t=n//2$ must be handled carefully.
- Root handling: for the root, ``up'' size is $0$.
- Nodes with a single child.}
\PITFALLS{
- Accidentally allowing the ``complement'' as a detachable subtree (it is not a subtree).
- Forgetting to include the node itself in $M[u]$ when $\mathrm{sz}[u]\le t$.
- Miscomputing $\mathrm{upM}$ by including ancestor-rooted subtrees that intersect the child subtree.
- Off-by-one with $t=\lfloor n/2 \rfloor$ and integer need $=\text{big}-t$.
- Recursion depth on large $n$: use iterative DFS in Python.
- Memory blow-up by duplicating adjacency; reuse structures when possible.}
\FAILMODES{Bruteforce or naive multi-cut assumptions fail on stars and large $n$. The DP approach survives because it exactly characterizes single-edge cuts as subtrees and restricts candidate locations to the oversized component.}
\ELI{To make a node a centroid, the only problem is a too-big neighboring component. If we can snip off a big-enough chunk from within that same component (but not more than half the tree) and move it away, we fix the imbalance. DP precomputes the biggest chunk you can snip inside any area, in linear time.}
\NotePages{3}

\end{document}