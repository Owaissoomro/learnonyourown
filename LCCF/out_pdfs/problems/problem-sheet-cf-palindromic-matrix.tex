% !TeX program = xelatex
\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{setspace}\setstretch{1.05}
\usepackage{fontspec}
\setmainfont{Latin Modern Roman}
\setmonofont{Latin Modern Mono}[BoldFont={Latin Modern Mono},ItalicFont={Latin Modern Mono}]
\usepackage{amsmath,mathtools,amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\usepackage{unicode-math}\setmathfont{Latin Modern Math}\allowdisplaybreaks[4]
% --- overflow and alignment slack ---
\setlength{\jot}{7pt}
\sloppy\emergencystretch=8em\hfuzz=1pt\vfuzz=2pt\raggedbottom
% --- breakable math helpers ---
\newenvironment{BreakableEquation}{\begin{equation}\begin{aligned}}{\end{aligned}\end{equation}}
\newenvironment{BreakableEquation*}{\begin{equation*}\begin{aligned}}{\end{aligned}\end{equation*}}
\newenvironment{tightalign}{\begingroup\small\allowdisplaybreaks\begin{align}}{\end{align}\endgroup}

\usepackage{xcolor}
\usepackage{xurl} % better URL wrapping
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}\fancyhf{}\lhead{\nouppercase{\leftmark}}\rhead{\thepage}\setlength{\headheight}{26pt}
\usepackage{enumitem,booktabs,tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}
\renewcommand{\arraystretch}{1.1}
\setlength{\parindent}{0pt}\setlength{\parskip}{8pt plus 2pt minus 1pt}

% Listings + upquote (no shell-escape needed)
\usepackage{listings}
\usepackage{upquote}
\lstdefinestyle{crisp}{
  basicstyle=\ttfamily\footnotesize,
  frame=single,
  breaklines=true,
  breakatwhitespace=false, % allow breaks inside long tokens
  tabsize=4,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=8pt,
  keepspaces=true,
  columns=fullflexible,
  backgroundcolor=\color{black!02},
  aboveskip=8pt,
  belowskip=8pt
}
% Guarantee that 'python' exists as a language for listings
\lstdefinelanguage{python}{
  morekeywords={def,return,class,if,elif,else,for,while,try,except,raise,assert,pass,break,continue,lambda,nonlocal,global,yield,import,from,as,with,True,False,None},
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
  morestring=[b]'
}
% minted shim (robust; no shell-escape; uses listings' own environment)
\lstnewenvironment{minted}[2][]{\lstset{style=crisp,language=#2,#1}}{}

\usepackage[most]{tcolorbox}
\tcbset{colback=white,colframe=black!15,boxrule=0.4pt,arc=2pt,left=6pt,right=6pt,top=6pt,bottom=6pt,before skip=10pt,after skip=10pt,breakable}
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{0.6em}{}
\titlespacing*{\section}{0pt}{*2.0}{*1.0}

% ===== CONSISTENCY TOOLKIT (macros) =====
\newlist{ledger}{enumerate}{1}
\setlist[ledger]{label=\textbullet,leftmargin=2em,itemsep=2pt,topsep=6pt}
\newcommand{\LEDGER}[1]{\textbf{ARITHMETIC LEDGER:}\par\begin{ledger}#1\end{ledger}}

\newlist{algosteps}{enumerate}{1}
\setlist[algosteps]{label=\arabic*.,leftmargin=2em,itemsep=2pt,topsep=6pt}

\newlist{bullets}{itemize}{1}
\setlist[bullets]{label=--,leftmargin=1.6em,itemsep=2pt,topsep=4pt}

\newcommand{\varmapStart}{\textbf{VARIABLE MAPPING:}\par\begin{bullets}}
\newcommand{\var}[2]{\item $#1$ — #2}
\newcommand{\varmapEnd}{\end{bullets}}

\newcommand{\LINE}[2]{\par\noindent\textbf{#1:}~#2\par}
\newcommand{\WHAT}[1]{\LINE{WHAT}{#1}}
\newcommand{\WHY}[1]{\LINE{WHY}{#1}}
\newcommand{\HOW}[1]{\LINE{HOW}{#1}}
\newcommand{\ELI}[1]{\LINE{ELI5}{#1}}
\newcommand{\STATEMENT}[1]{\LINE{STATEMENT}{#1}}
\newcommand{\BREAKDOWN}[1]{\LINE{PROBLEM BREAKDOWN}{#1}}
\newcommand{\MODEL}[1]{\LINE{CANONICAL MATHEMATICAL MODEL}{#1}}
\newcommand{\ASSUMPTIONS}[1]{\LINE{ASSUMPTIONS}{#1}}
\newcommand{\INVARIANTS}[1]{\LINE{INVARIANTS}{#1}}
\newcommand{\WHICHFORMULA}[1]{\LINE{WHICH FORMULA \& WHY}{#1}}
\newcommand{\GOVERN}[1]{\LINE{GOVERNING EQUATION(S)}{#1}}
\newcommand{\INPUTS}[1]{\LINE{INPUTS}{#1}}
\newcommand{\OUTPUTS}[1]{\LINE{OUTPUTS}{#1}}
\newcommand{\SAMPLES}[1]{\LINE{SAMPLES}{#1}}
\newcommand{\RESULT}[1]{\LINE{RESULT}{#1}}
\newcommand{\COMPLEXITY}[1]{\LINE{TIME/SPACE COMPLEXITY}{#1}}
\newcommand{\MEMORY}[1]{\LINE{MEMORY FOOTPRINT}{#1}}
\newcommand{\CORRECTNESS}[1]{\LINE{CORRECTNESS SKETCH}{#1}}
\newcommand{\OPTIMALITY}[1]{\LINE{OPTIMALITY}{#1}}
\newcommand{\FAILMODES}[1]{\LINE{FAILURE MODES}{#1}}
\newcommand{\VALIDATION}[1]{\LINE{VALIDATION}{#1}}
\newcommand{\UNITCHECK}[1]{\LINE{UNIT CHECK}{#1}}
\newcommand{\EDGECASES}[1]{\LINE{EDGE CASES}{#1}}
\newcommand{\CHECKLIST}[1]{\LINE{CHECKLIST}{#1}}
\newcommand{\DERIV}[1]{\LINE{DERIVATION}{#1}}
\newcommand{\LEMMAHEAD}[1]{\LINE{SUPPORTING LEMMA}{#1}}
\newcommand{\PITFALLS}[1]{\LINE{PITFALLS}{#1}}

\usepackage{etoolbox}\pretocmd{\section}{\clearpage}{}{}

\newcommand{\FormulaPage}[2]{%
  \clearpage
  \section*{Formula #1 — #2}%
  \addcontentsline{toc}{section}{Formula #1 — #2}%
}
\newcommand{\ApproachPage}[2]{%
  \clearpage
  \subsection*{Approach #1 — #2}%
  \addcontentsline{toc}{subsection}{Approach #1 — #2}%
}

\begin{document}
\title{Interview Problem Sheet — Palindromic Matrix}
\date{\today}
\author{}
\maketitle
\tableofcontents
\clearpage

% === Notes macro (BODY-ONLY; do not alter the preamble) ===
% Prints exactly N blank pages with empty headers/footers, then leaves you on the last blank page.
\newcommand{\NotePages}[1]{%
  \clearpage
  \begingroup
  \newcount\NPi \newcount\NPn
  \NPi=0 \NPn=#1
  \loop\ifnum\NPi<\NPn
    \advance\NPi by 1
    \mbox{}\thispagestyle{empty}%
    \ifnum\NPi<\NPn\clearpage\fi
  \repeat
  \endgroup
}

% ============ 1. Problem & Metadata (own page) ============
\section{Problem \& Metadata}
\LINE{PLATFORM}{CF}
\LINE{URL}{\url{https://codeforces.com/problemset/problem/1118/C}}
\LINE{DIFFICULTY / RATING}{1700}
\STATEMENT{Let's call some square matrix with integer values in its cells palindromic if it does not change after the order of rows is reversed and it does not change after the order of columns is reversed.

For example, the following matrices are palindromic:

The following matrices are not palindromic because they change after the order of rows is reversed:

The following matrices are not palindromic because they change after the order of columns is reversed:

You are given $n^2$ integers. Put them into a matrix of $n$ rows and $n$ columns so that each number is used exactly once, each cell contains exactly one number and the resulting matrix is palindromic. If there are multiple answers, print any. If there is no solution, print ``NO''.

Input:
The first line contains one integer $n$ ($1 \le n \le 20$).

The second line contains $n^2$ integers $a_1, a_2, \dots, a_{n^2}$ ($1 \le a_i \le 1000$) — the numbers to put into a matrix of $n$ rows and $n$ columns.

Output:
If it is possible to put all of the $n^2$ numbers into a matrix of $n$ rows and $n$ columns so that each number is used exactly once, each cell contains exactly one number and the resulting matrix is palindromic, then print ``YES''. Then print $n$ lines with $n$ space-separated numbers — the resulting matrix.

If it is impossible to construct any matrix, then print ``NO''.

You can print each letter in any case (upper or lower). For example, ``YeS'', ``no'' and ``yES'' are all acceptable.

Note:
Note that there exist multiple answers for the first two examples.}
\BREAKDOWN{We must decide feasibility from multiset counts, then construct one palindromic arrangement. For even $n$, all orbits have size $4$; for odd $n$, there are $4$-orbits, $(n-1)$ pairs along the middle row/column, and one center cell.}
\ELI{Group cells into orbits under reversing rows/columns and fill groups with identical numbers according to their frequencies.}
\NotePages{3}

% ============ 2. IO Contract (own page) ============
\section{IO Contract}
\INPUTS{One integer $n$; then $n^2$ integers $a_i$ with $1 \le n \le 20$ and $1 \le a_i \le 1000$.}
\OUTPUTS{If possible, print ``YES'' and an $n \times n$ matrix that is invariant under reversing rows and also under reversing columns; otherwise, print ``NO''.}
\SAMPLES{Example 1 (possible):
Input
1
7
Output
YES
7

Example 2 (possible):
2
1 1 1 1
Output
YES
1 1
1 1

Example 3 (impossible):
2
1 1 2 2
Output
NO}
\NotePages{3}

% ============ 3. Canonical Mathematical Model (own page) ============
\section{Canonical Mathematical Model}
\MODEL{Let indices be $i,j \in \{0,\ldots,n-1\}$. A matrix $M$ is palindromic iff $M_{i,j} = M_{n-1-i,j}$ and $M_{i,j} = M_{i,n-1-j}$ for all $i,j$. Equivalently, each orbit $\{(i,j),(n-1-i,j),(i,n-1-j),(n-1-i,n-1-j)\}$ has equal values. For odd $n$, there is one center cell, and $(n-1)$ pairs on the middle row/column.}
\varmapStart
\var{n}{matrix size}
\var{c_x}{frequency (count) of value $x$}
\var{q}{number of required $4$-orbits: $q = \left(\tfrac{n}{2}\right)^2$}
\var{p}{number of required pairs on middle row/column when $n$ is odd: $p = n-1$}
\varmapEnd
\GOVERN{
\[
\begin{aligned}
&\text{Even } n:\quad &&\forall x:\ c_x \equiv 0 \pmod{4}.\\
&\text{Odd } n:\quad &&\left|\{x: c_x \equiv 1 \pmod{2}\}\right| = 1,\\
&&&\sum_x \left\lfloor \frac{c_x}{4}\right\rfloor \ge \left(\frac{n-1}{2}\right)^2,\\
&&&\text{and enough pairs remain to fill } p=n-1 \text{ middle pairs.}
\end{aligned}
\]
}
\ASSUMPTIONS{Input multiset size equals $n^2$. Values are arbitrary integers in range. Any valid construction suffices.}
\INVARIANTS{Filling $4$-orbits uses counts in multiples of $4$; filling middle pairs uses counts in multiples of $2$; the center (if $n$ odd) uses one unit and forces exactly one odd count.}
\NotePages{3}

% ============ 4. Approach A — Baseline (own page) ============
\section{Approach A — Baseline}
\ApproachPage{A}{Brute Force / Direct}
\WHICHFORMULA{Use orbit decomposition: fill $4$-blocks first, then middle pairs (if $n$ odd), then the center. This greedy works because $4$-blocks cannot be synthesized from pairs, while pairs can be taken from leftover quads.}
\ASSUMPTIONS{Counts are small enough to materialize pools of quads and pairs.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count frequencies $c_x$ of all values.
\item If $n$ is odd, pick the unique odd-count value for the center and decrement its count; if none or more than one, answer ``NO''.
\item Build a pool of values repeated $\left\lfloor c_x/4 \right\rfloor$ times; if the pool has fewer than $q=\left\lfloor n/2\right\rfloor^2$ entries, answer ``NO''. Fill all quadrants symmetrically using this pool, subtracting $4$ per placement.
\item If $n$ is odd, build a pool of pairs from remaining counts, repeated $\left\lfloor c_x/2 \right\rfloor$ times; if fewer than $p=n-1$ pairs, answer ``NO''. Fill middle row pairs, then middle column pairs.
\item Output ``YES'' and the matrix.
\end{algosteps}
\COMPLEXITY{Time linear in $n^2$ plus number of distinct values; memory $O(n^2)$.}
\[
\begin{aligned}
T(n) &= O(n^2) + O(U) \\
S(n) &= O(n^2) \text{ to store the matrix, where $U$ is the number of distinct values.}
\end{aligned}
\]
\CORRECTNESS{Every filled group respects the required symmetries; counts never go negative. Necessity of quad lower bound and single odd (for odd $n$) is clear; sufficiency follows because pairs can always be sourced from leftover counts and, if needed, from leftover quads.}
\EDGECASES{n=1; all numbers equal; even $n$ with any count not divisible by $4$; odd $n$ with more than one odd count; minimal $n=2$.}
\textbf{Code (Baseline)}
\begin{minted}{python}
# CF 1118C — Palindromic Matrix (Baseline Greedy Construction)
# Includes: read_input(), solve_all(), main guard, and asserts.

from collections import Counter
import sys
from typing import List, Tuple

def read_input(data: str) -> Tuple[int, List[int]]:
    it = list(map(int, data.strip().split()))
    if not it:
        return 0, []
    n = it[0]
    arr = it[1:]
    # If more numbers than needed are present, slice to n^2.
    # CF guarantees exactly n^2 numbers.
    return n, arr[: n * n]

def construct_palindromic_matrix(n: int, arr: List[int]) -> Tuple[bool, List[List[int]]]:
    if n == 0:
        return False, []
    if len(arr) != n * n:
        return False, []

    freq = Counter(arr)
    mat = [[0] * n for _ in range(n)]
    half = n // 2

    # Center for odd n: must have exactly one odd count
    if n % 2 == 1:
        odds = [v for v, c in freq.items() if c % 2 == 1]
        if len(odds) != 1:
            return False, []
        center_val = odds[0]
        mat[half][half] = center_val
        freq[center_val] -= 1  # consume the single
        if freq[center_val] == 0:
            del freq[center_val]

    # Fill 4-orbit blocks
    needed_quads = half * half
    pool4 = []
    for v, c in freq.items():
        pool4.extend([v] * (c // 4))
    if len(pool4) < needed_quads:
        return False, []
    # We'll maintain fresh freq while placing
    freq = Counter(freq)  # copy
    idx4 = 0
    for i in range(half):
        for j in range(half):
            v = pool4[idx4]
            idx4 += 1
            # place v in four symmetric positions
            mat[i][j] = v
            mat[n - 1 - i][j] = v
            mat[i][n - 1 - j] = v
            mat[n - 1 - i][n - 1 - j] = v
            freq[v] -= 4
            if freq[v] == 0:
                del freq[v]

    # If n is odd, fill pairs along middle row and middle column
    if n % 2 == 1:
        # Build pairs pool from remaining counts
        pool2 = []
        for v, c in freq.items():
            pool2.extend([v] * (c // 2))
        needed_pairs = (n - 1)  # total number of 2-cells pairs on middle row+col
        if len(pool2) < needed_pairs:
            return False, []
        freq = Counter(freq)
        idx2 = 0
        # middle row (excluding center)
        for j in range(half):
            v = pool2[idx2]
            idx2 += 1
            mat[half][j] = v
            mat[half][n - 1 - j] = v
            # no need to track freq strictly here for correctness
        # middle column (excluding center)
        for i in range(half):
            v = pool2[idx2]
            idx2 += 1
            mat[i][half] = v
            mat[n - 1 - i][half] = v

    # Validate palindromic property and multiset usage
    # (defensive; can be removed in production)
    used = []
    for i in range(n):
        for j in range(n):
            used.append(mat[i][j])
            if mat[i][j] != mat[n - 1 - i][j]:  # row reverse
                return False, []
            if mat[i][j] != mat[i][n - 1 - j]:  # col reverse
                return False, []
    if Counter(used) != Counter(arr):
        return False, []

    return True, mat

def solve_all(data: str) -> str:
    n, arr = read_input(data)
    ok, mat = construct_palindromic_matrix(n, arr)
    if not ok:
        return "NO\n"
    out_lines = ["YES"]
    for row in mat:
        out_lines.append(" ".join(map(str, row)))
    return "\n".join(out_lines) + "\n"

def _parse_matrix_from_output(out: str) -> Tuple[bool, List[List[int]]]:
    lines = [ln.strip() for ln in out.strip().splitlines()]
    if not lines:
        return False, []
    if lines[0].upper() != "YES":
        return False, []
    rows = [list(map(int, ln.split())) for ln in lines[1:]]
    return True, rows

def _is_palindromic(mat: List[List[int]]) -> bool:
    n = len(mat)
    for i in range(n):
        for j in range(n):
            if mat[i][j] != mat[n - 1 - i][j]:
                return False
            if mat[i][j] != mat[i][n - 1 - j]:
                return False
    return True

if __name__ == "__main__":
    # Self-checks (run only when in TTY to avoid interfering with judge)
    if sys.stdin.isatty():
        # Test 1: n=1
        out = solve_all("1\n7\n")
        ok, M = _parse_matrix_from_output(out)
        assert ok and len(M) == 1 and M[0][0] == 7 and _is_palindromic(M)

        # Test 2: n=2, all ones
        out = solve_all("2\n1 1 1 1\n")
        ok, M = _parse_matrix_from_output(out)
        assert ok and len(M) == 2 and _is_palindromic(M)

        # Test 3: n=3, counts 1x4, 2x4, 3x1
        data = "3\n" + " ".join([str(1)] * 4 + [str(2)] * 4 + [str(3)] * 1) + "\n"
        out = solve_all(data)
        ok, M = _parse_matrix_from_output(out)
        assert ok and len(M) == 3 and _is_palindromic(M)

        # Test 4: impossible n=2 mixed
        out = solve_all("2\n1 1 2 2\n")
        assert out.strip().upper() == "NO"

    else:
        print(solve_all(sys.stdin.read()), end="")
\end{minted}
\VALIDATION{Tiny manual checks: $n=1$; $n=2$ all equal; $n=3$ with frequencies fitting $4$-orbits, pairs, and center; an impossible even case with non-multiples of $4$.}
\NotePages{3}

% ============ 5. Approach B — Improved (own page) ============
\section{Approach B — Improved}
\ApproachPage{B}{Optimized Data Structure / Pruning / DP}
\WHICHFORMULA{Add early feasibility pruning: odd-count check for odd $n$, quad lower bound, and pairs sufficiency. Keep the same constructive fill to ensure determinism.}
\ASSUMPTIONS{Same as baseline; use counters and precomputed pools to avoid scans during placement.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item Count frequencies and pre-check:
  \begin{itemize}
  \item If $n$ even and $\sum \lfloor c_x/4 \rfloor < (n/2)^2$, return ``NO''.
  \item If $n$ odd, ensure exactly one odd $c_x$, and $\sum \lfloor c_x/4 \rfloor \ge \left(\tfrac{n-1}{2}\right)^2$ and enough pairs in remainder to cover $p=n-1$ (breaking leftover quads if needed).
  \end{itemize}
\item Proceed with the same greedy construction as in Approach A.
\end{algosteps}
\COMPLEXITY{Same asymptotics as baseline; constant factors reduced by pruning.}
\[
\begin{aligned}
T(n) &= O(n^2 + U) \\
\end{aligned}
\]
\CORRECTNESS{Early checks match necessary conditions; construction identical to baseline preserves invariants.}
\textbf{Code (Improved)}
\begin{minted}{python}
# CF 1118C — Palindromic Matrix (Improved with early feasibility checks)

from collections import Counter
import sys
from typing import List, Tuple

def read_input(data: str):
    it = list(map(int, data.strip().split()))
    if not it:
        return 0, []
    n = it[0]
    arr = it[1:1 + n * n]
    return n, arr

def feasible(n: int, freq: Counter) -> bool:
    if n % 2 == 0:
        need_quads = (n // 2) * (n // 2)
        have_quads = sum(c // 4 for c in freq.values())
        return have_quads >= need_quads
    else:
        odds = sum(1 for c in freq.values() if c % 2 == 1)
        if odds != 1:
            return False
        # After reserving 1 for the center (from some odd), recompute caps
        # We can upper bound conservatively by removing 1 from some odd count
        have_quads = sum(c // 4 for c in freq.values())
        # If we borrow center from an odd c, quads reduce by either 0 or 1 depending on c%4==0.
        # Worst case reduction is 1, so ensure margin.
        need_quads = (n // 2) * (n // 2)
        if have_quads < need_quads:
            return False
        # Pairs availability: from remainders plus splittable leftover quads
        # Conservative sufficient condition: sum((c % 4) // 2) + 2 * (have_quads - need_quads) >= (n - 1)
        rem_pairs = sum((c % 4) // 2 for c in freq.values())
        extra_pairs = 2 * (have_quads - need_quads)
        return rem_pairs + extra_pairs >= (n - 1)

def construct(n: int, arr: List[int]) -> Tuple[bool, List[List[int]]]:
    freq = Counter(arr)
    if not feasible(n, freq):
        return False, []
    mat = [[0] * n for _ in range(n)]
    half = n // 2

    # Center
    if n % 2 == 1:
        for v, c in list(freq.items()):
            if c % 2 == 1:
                mat[half][half] = v
                freq[v] -= 1
                if freq[v] == 0:
                    del freq[v]
                break

    # Quads
    need_quads = half * half
    pool4 = []
    for v, c in freq.items():
        pool4.extend([v] * (c // 4))
    if len(pool4) < need_quads:
        return False, []  # should not happen due to feasible()
    freq = Counter(freq)
    k = 0
    for i in range(half):
        for j in range(half):
            v = pool4[k]; k += 1
            mat[i][j] = mat[n-1-i][j] = mat[i][n-1-j] = mat[n-1-i][n-1-j] = v
            freq[v] -= 4
            if freq[v] == 0:
                del freq[v]

    # Pairs
    if n % 2 == 1:
        pool2 = []
        for v, c in freq.items():
            pool2.extend([v] * (c // 2))
        if len(pool2) < (n - 1):
            return False, []
        k2 = 0
        # middle row
        for j in range(half):
            v = pool2[k2]; k2 += 1
            mat[half][j] = mat[half][n-1-j] = v
        # middle column
        for i in range(half):
            v = pool2[k2]; k2 += 1
            mat[i][half] = mat[n-1-i][half] = v

    # Final sanity (optional)
    def pal(M):
        N = len(M)
        for i in range(N):
            for j in range(N):
                if M[i][j] != M[N-1-i][j] or M[i][j] != M[i][N-1-j]:
                    return False
        return True
    if not pal(mat) or Counter(sum(mat, [])) != Counter(arr):
        return False, []
    return True, mat

def solve_all(data: str) -> str:
    n, arr = read_input(data)
    ok, mat = construct(n, arr)
    if not ok:
        return "NO\n"
    out = ["YES"] + [" ".join(map(str, row)) for row in mat]
    return "\n".join(out) + "\n"

if __name__ == "__main__":
    if sys.stdin.isatty():
        # Basic asserts
        assert solve_all("2\n1 1 1 1\n").splitlines()[0] == "YES"
        assert solve_all("2\n1 1 2 2\n").strip().upper() == "NO"
        out = solve_all("3\n" + " ".join(map(str, [1]*4 + [2]*4 + [3])) + "\n")
        assert out.splitlines()[0] == "YES"
    else:
        print(solve_all(sys.stdin.read()), end="")
\end{minted}
\VALIDATION{Checks mirror Approach A, plus feasibility pruning sanity assertions.}
\NotePages{3}

% ============ 6. Approach C — Optimal (own page) ============
\section{Approach C — Optimal}
\ApproachPage{C}{Provably Optimal Method}
\WHICHFORMULA{Orbit-based greedy is optimal: it uses exactly the minimum number of $4$-blocks and pairs required by symmetry constraints and thus succeeds iff a solution exists.}
\ASSUMPTIONS{Counts are exact; symmetry groups partition the grid cells.}
\textbf{Algorithm Steps}
\begin{algosteps}
\item If $n$ odd, assign the unique odd-count value to the center.
\item Fill all $4$-orbits in the $\tfrac{n}{2} \times \tfrac{n}{2}$ top-left block using values with at least $4$ remaining occurrences.
\item If $n$ odd, fill the middle row and middle column pairs using values with at least $2$ remaining occurrences.
\end{algosteps}
\OPTIMALITY{Any solution must allocate exactly $q=\left(\tfrac{n}{2}\right)^2$ quadruples and, when $n$ odd, $p=n-1$ pairs and one center. Our method prioritizes quadruples (the scarcest resource), then pairs, ensuring feasibility iff the necessary lower bounds are met.}
\COMPLEXITY{Linear-time in grid size with small overhead.}
\[
\begin{aligned}
T(n) &= O(n^2 + U),\quad S(n) = O(n^2).
\end{aligned}
\]
\textbf{Code (Final Submission)}
\begin{minted}{python}
# CF 1118C — Palindromic Matrix (Final Reference Solution)

from collections import Counter
import sys
from typing import List, Tuple

def read_input(data: str) -> Tuple[int, List[int]]:
    xs = list(map(int, data.strip().split()))
    if not xs:
        return 0, []
    n = xs[0]
    arr = xs[1:1 + n * n]
    return n, arr

def construct_palindromic(n: int, arr: List[int]) -> Tuple[bool, List[List[int]]]:
    if n == 0 or len(arr) != n * n:
        return False, []
    freq = Counter(arr)
    mat = [[0] * n for _ in range(n)]
    half = n // 2

    # Center for odd n
    if n % 2 == 1:
        odds = [v for v, c in freq.items() if c % 2 == 1]
        if len(odds) != 1:
            return False, []
        center = odds[0]
        mat[half][half] = center
        freq[center] -= 1
        if freq[center] == 0:
            del freq[center]

    # Prepare and place quads
    need_quads = (n // 2) * (n // 2)
    pool4 = []
    for v, c in freq.items():
        pool4.extend([v] * (c // 4))
    if len(pool4) < need_quads:
        return False, []
    # Place quads
    k = 0
    for i in range(half):
        for j in range(half):
            v = pool4[k]; k += 1
            mat[i][j] = mat[n-1-i][j] = mat[i][n-1-j] = mat[n-1-i][n-1-j] = v
            freq[v] -= 4
            if freq[v] == 0:
                del freq[v]

    # Pairs for odd n
    if n % 2 == 1:
        pool2 = []
        for v, c in freq.items():
            pool2.extend([v] * (c // 2))
        if len(pool2) < (n - 1):
            return False, []
        k2 = 0
        # middle row
        for j in range(half):
            v = pool2[k2]; k2 += 1
            mat[half][j] = mat[half][n-1-j] = v
        # middle column
        for i in range(half):
            v = pool2[k2]; k2 += 1
            mat[i][half] = mat[n-1-i][half] = v

    # Final verification (safe guard)
    def pal(M):
        N = len(M)
        for i in range(N):
            for j in range(N):
                if M[i][j] != M[N-1-i][j] or M[i][j] != M[i][N-1-j]:
                    return False
        return True
    if not pal(mat) or Counter(sum(mat, [])) != Counter(arr):
        return False, []

    return True, mat

def solve_all(data: str) -> str:
    n, arr = read_input(data)
    ok, mat = construct_palindromic(n, arr)
    if not ok:
        return "NO\n"
    out = ["YES"]
    out.extend(" ".join(map(str, row)) for row in mat)
    return "\n".join(out) + "\n"

# Minimal deterministic tests
if __name__ == "__main__":
    if sys.stdin.isatty():
        # 1) Trivial n=1
        out = solve_all("1\n9\n")
        assert out.splitlines()[0] == "YES"
        # 2) Even n feasible
        out = solve_all("2\n5 5 5 5\n")
        assert out.splitlines()[0] == "YES"
        # 3) Odd n mixed feasible
        data = "3\n" + " ".join(map(str, [4]*4 + [7]*4 + [9])) + "\n"
        out = solve_all(data)
        assert out.splitlines()[0] == "YES"
    else:
        print(solve_all(sys.stdin.read()), end="")
\end{minted}
\VALIDATION{Exactly three asserts: $n=1$ trivial, even $n=2$ all equal, odd $n=3$ with valid frequencies.}
\RESULT{Print ``YES'' and any valid palindromic matrix using all inputs exactly once; otherwise print ``NO''.}
\NotePages{3}

% ============ 7. Testing & Final Reference Implementation (own page) ============
\section{Testing \& Final Reference Implementation}
\LINE{TEST PLAN}{Unit tests cover trivial, feasible even/odd, and impossible cases. Property checks: symmetry under row/column reversal and multiset equality to input.}
\LINE{CROSS-CHECKS}{Compare outputs of Approaches A, B, and C on random small cases; all must either agree on ``NO'' or produce matrices that pass the palindrome and multiset checks.}
\LINE{EDGE-CASE GENERATOR}{Generate arrays with: exactly one odd count (odd $n$), multiple odd counts (should fail), all counts multiples of $4$ (even $n$), and near-threshold quads/pairs.}
\begin{minted}{python}
# Deterministic generators for boundaries, degenerates, adversarials
import random
from collections import Counter

def gen_even_ok(n: int, v: int = 1):
    assert n % 2 == 0
    return [v] * (n * n)

def gen_even_bad(n: int):
    assert n % 2 == 0
    arr = []
    # two values with count 2 each -> total 4 but not multiples of 4
    arr.extend([1, 1, 2, 2])
    while len(arr) < n * n:
        arr.append(3)
    return arr[: n * n]

def gen_odd_ok(n: int):
    assert n % 2 == 1
    half = n // 2
    q = half * half
    p = n - 1
    arr = []
    # Create q quads of value 1, p pairs of value 2, and 1 center value 3
    arr.extend([1] * (4 * q))
    arr.extend([2] * (2 * p))
    arr.append(3)
    # pad any remaining with 1's (none expected)
    while len(arr) < n * n:
        arr.append(1)
    return arr

def is_palindromic(mat):
    n = len(mat)
    for i in range(n):
        for j in range(n):
            if mat[i][j] != mat[n-1-i][j] or mat[i][j] != mat[i][n-1-j]:
                return False
    return True
\end{minted}
\textbf{Reference Code (Ready to Submit)}
\begin{minted}{python}
# Final reference solution matching CF requirements

from collections import Counter
import sys
from typing import List, Tuple

def read_input(data: str) -> Tuple[int, List[int]]:
    xs = list(map(int, data.strip().split()))
    if not xs:
        return 0, []
    n = xs[0]
    arr = xs[1:1 + n * n]
    return n, arr

def construct_palindromic(n: int, arr: List[int]):
    if n == 0 or len(arr) != n * n:
        return False, []
    freq = Counter(arr)
    mat = [[0] * n for _ in range(n)]
    half = n // 2

    if n % 2 == 1:
        odds = [v for v, c in freq.items() if c % 2 == 1]
        if len(odds) != 1:
            return False, []
        center = odds[0]
        mat[half][half] = center
        freq[center] -= 1
        if freq[center] == 0:
            del freq[center]

    need_quads = half * half
    pool4 = []
    for v, c in freq.items():
        pool4.extend([v] * (c // 4))
    if len(pool4) < need_quads:
        return False, []
    k = 0
    for i in range(half):
        for j in range(half):
            v = pool4[k]; k += 1
            mat[i][j] = mat[n-1-i][j] = mat[i][n-1-j] = mat[n-1-i][n-1-j] = v
            freq[v] -= 4
            if freq[v] == 0:
                del freq[v]

    if n % 2 == 1:
        pool2 = []
        for v, c in freq.items():
            pool2.extend([v] * (c // 2))
        if len(pool2) < (n - 1):
            return False, []
        k2 = 0
        for j in range(half):
            v = pool2[k2]; k2 += 1
            mat[half][j] = mat[half][n-1-j] = v
        for i in range(half):
            v = pool2[k2]; k2 += 1
            mat[i][half] = mat[n-1-i][half] = v

    # Sanity check
    flat = []
    for i in range(n):
        for j in range(n):
            flat.append(mat[i][j])
            if mat[i][j] != mat[n-1-i][j] or mat[i][j] != mat[i][n-1-j]:
                return False, []
    if Counter(flat) != Counter(arr):
        return False, []

    return True, mat

def solve_all(data: str) -> str:
    n, arr = read_input(data)
    ok, mat = construct_palindromic(n, arr)
    if not ok:
        return "NO\n"
    out = ["YES"]
    out.extend(" ".join(map(str, row)) for row in mat)
    return "\n".join(out) + "\n"

if __name__ == "__main__":
    if sys.stdin.isatty():
        # Basic asserts
        assert solve_all("1\n5\n").splitlines()[0] == "YES"
        assert solve_all("2\n1 1 1 1\n").splitlines()[0] == "YES"
        assert solve_all("2\n1 1 2 2\n").strip().upper() == "NO"
    else:
        print(solve_all(sys.stdin.read()), end="")
\end{minted}
\NotePages{3}

% ============ 8. Review & Pitfalls (own page) ============
\section{Review \& Pitfalls}
\WHAT{Fill $4$-orbits first, then middle pairs, then the center (if $n$ odd).}
\WHY{This pattern appears in symmetry/constructive multiset problems; quick feasibility checks save time in interviews.}
\CHECKLIST{
\begin{bullets}
\item Count frequencies.
\item If $n$ odd, ensure exactly one odd count and set center.
\item Build quad pool, ensure enough to fill $\left\lfloor n/2\right\rfloor^2$ blocks.
\item Place quads symmetrically.
\item If $n$ odd, build pairs pool and fill middle row/column.
\item Print matrix; verify mentally the symmetry.
\end{bullets}
}
\EDGECASES{
\begin{bullets}
\item $n=1$ trivial single cell.
\item Even $n$ with some counts $\not\equiv 0 \pmod 4$.
\item Odd $n$ with multiple odd counts.
\item Odd $n$ where quads barely sufficient.
\item Inputs with many distinct small counts.
\item All elements equal.
\item Values at upper bound $1000$ (no effect).
\item Reordered inputs with same multiset (order irrelevant).
\end{bullets}
}
\PITFALLS{
\begin{bullets}
\item Forgetting to decrement the center count.
\item Consuming more than the needed number of quads, starving pairs.
\item Miscounting number of pair groups: it is $n-1$, not $2(n-1)$.
\item Off-by-one in indices for symmetric placements.
\item Not verifying that the constructed matrix uses exactly $n^2$ elements.
\item Printing ``Yes''/``No'' with wrong capitalization in strict checkers (CF allows any case, but be consistent).
\item Building pools before subtracting the center.
\item Failing to handle $n=2$ correctly.
\end{bullets}
}
\FAILMODES{Greedy that fills pairs before quads can fail even if a solution exists because quads cannot be synthesized from pairs. The proposed method prioritizes quads, which is necessary.}
\ELI{Think of the grid as mirrored left-right and top-bottom. Each group of symmetric cells must share the same number. Use packs of four first, then pairs for the middle strips, and a single for the center if the size is odd.}
\NotePages{3}

\end{document}